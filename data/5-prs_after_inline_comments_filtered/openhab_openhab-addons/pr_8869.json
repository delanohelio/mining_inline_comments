{"pr_number": 8869, "pr_title": "[gardena] Rewriting the Gardena binding", "pr_createdAt": "2020-10-26T09:51:03Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8869", "timeline": [{"oid": "ad46cb7517693c057309d0d5c01b6d95dc74370e", "url": "https://github.com/openhab/openhab-addons/commit/ad46cb7517693c057309d0d5c01b6d95dc74370e", "message": "Rewriting the Gardena binding\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-10-26T09:47:37Z", "type": "commit"}, {"oid": "6eb5b14253ab6f43bb350f21a2b5249b40cffd8a", "url": "https://github.com/openhab/openhab-addons/commit/6eb5b14253ab6f43bb350f21a2b5249b40cffd8a", "message": "Optimized communication error message\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-11-08T10:11:16Z", "type": "commit"}, {"oid": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "url": "https://github.com/openhab/openhab-addons/commit/f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "message": "Fixed bundle stop\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-11-08T10:11:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgwOTc5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523809791", "bodyText": "It seems a bit unreasonable to log the stack trace when the network fails. Also, its good practice to log exceptions where they are eventually cought.", "author": "fwolter", "createdAt": "2020-11-15T20:32:53Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/GardenaSmartImpl.java", "diffHunk": "@@ -12,562 +12,376 @@\n  */\n package org.openhab.binding.gardena.internal;\n \n-import java.util.Collection;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n+import java.util.*;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n \n-import org.apache.commons.lang.ObjectUtils;\n-import org.apache.commons.lang.StringUtils;\n import org.eclipse.jetty.client.HttpClient;\n-import org.eclipse.jetty.client.HttpResponseException;\n import org.eclipse.jetty.client.api.ContentResponse;\n import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.AbstractTypedContentProvider;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n import org.eclipse.jetty.client.util.StringContentProvider;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n-import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.eclipse.jetty.util.Fields;\n import org.openhab.binding.gardena.internal.config.GardenaConfig;\n-import org.openhab.binding.gardena.internal.config.GardenaConfigWrapper;\n import org.openhab.binding.gardena.internal.exception.GardenaDeviceNotFoundException;\n import org.openhab.binding.gardena.internal.exception.GardenaException;\n-import org.openhab.binding.gardena.internal.exception.GardenaUnauthorizedException;\n-import org.openhab.binding.gardena.internal.model.Ability;\n+import org.openhab.binding.gardena.internal.model.DataItemDeserializer;\n import org.openhab.binding.gardena.internal.model.Device;\n-import org.openhab.binding.gardena.internal.model.Devices;\n-import org.openhab.binding.gardena.internal.model.Errors;\n-import org.openhab.binding.gardena.internal.model.Location;\n-import org.openhab.binding.gardena.internal.model.Locations;\n-import org.openhab.binding.gardena.internal.model.NoResult;\n-import org.openhab.binding.gardena.internal.model.Property;\n-import org.openhab.binding.gardena.internal.model.PropertyValue;\n-import org.openhab.binding.gardena.internal.model.Session;\n-import org.openhab.binding.gardena.internal.model.SessionWrapper;\n-import org.openhab.binding.gardena.internal.model.Setting;\n-import org.openhab.binding.gardena.internal.model.command.Command;\n-import org.openhab.binding.gardena.internal.model.command.MowerParkUntilFurtherNoticeCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerParkUntilNextTimerCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerStartOverrideTimerCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerStartResumeScheduleCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureAmbientTemperatureCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureLightCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureSoilHumidityCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureSoilTemperatureCommand;\n-import org.openhab.binding.gardena.internal.model.command.SettingCommand;\n-import org.openhab.binding.gardena.internal.model.command.SettingCommandWrapper;\n-import org.openhab.binding.gardena.internal.model.command.WateringCancelOverrideCommand;\n-import org.openhab.binding.gardena.internal.model.command.WateringManualOverrideCommand;\n-import org.openhab.binding.gardena.internal.model.deser.DateDeserializer;\n-import org.openhab.binding.gardena.internal.model.deser.PropertyValueDeserializer;\n-import org.openhab.binding.gardena.internal.model.property.BaseProperty;\n-import org.openhab.binding.gardena.internal.model.property.IrrigationControlWateringProperty;\n-import org.openhab.binding.gardena.internal.model.property.PropertyWrapper;\n-import org.openhab.binding.gardena.internal.model.property.StringProperty;\n+import org.openhab.binding.gardena.internal.model.api.*;\n+import org.openhab.binding.gardena.internal.model.command.GardenaCommand;\n+import org.openhab.binding.gardena.internal.model.command.GardenaCommandRequest;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.io.net.http.WebSocketFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n \n /**\n- * {@link GardenaSmart} implementation to access Gardena Smart Home.\n+ * {@link GardenaSmart} implementation to access Gardena smart system.\n  *\n  * @author Gerhard Riegler - Initial contribution\n  */\n-public class GardenaSmartImpl implements GardenaSmart {\n+public class GardenaSmartImpl implements GardenaSmart, GardenaSmartWebSocketListener {\n     private final Logger logger = LoggerFactory.getLogger(GardenaSmartImpl.class);\n \n-    public static final String DEVICE_CATEGORY_PUMP = \"electronic_pressure_pump\";\n-    private static final String ABILITY_MOWER = \"mower\";\n-    private static final String ABILITY_OUTLET = \"outlet\";\n-    private static final String ABILITY_HUMIDITY = \"humidity\";\n-    private static final String ABILITY_LIGHT = \"light\";\n-    private static final String ABILITY_AMBIENT_TEMPERATURE = \"ambient_temperature\";\n-    private static final String ABILITY_SOIL_TEMPERATURE = \"soil_temperature\";\n-    private static final String ABILITY_POWER = \"power\";\n-    private static final String ABILITY_WATERING = \"watering\";\n-    private static final String ABILITY_MANUAL_WATERING = \"manual_watering\";\n-\n-    private static final String PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME = \"button_manual_override_time\";\n-    private static final String PROPERTY_POWER_TIMER = \"power_timer\";\n-    private static final String PROPERTY_WATERING_TIMER = \"watering_timer_\";\n-    private static final String PROPERTY_MANUAL_WATERING_TIMER = \"manual_watering_timer\";\n-\n-    private static final String DEVICE_CATEGORY_MOWER = \"mower\";\n-    private static final String DEVICE_CATEGORY_GATEWAY = \"gateway\";\n-\n-    private static final String DEFAULT_MOWER_DURATION = \"180\";\n-\n-    private static final String URL = \"https://smart.gardena.com\";\n-    private static final String URL_LOGIN = URL + \"/v1/auth/token\";\n-    private static final String URL_LOCATIONS = URL + \"/v1/locations/?user_id=\";\n-    private static final String URL_DEVICES = URL + \"/v1/devices/?locationId=\";\n-    private static final String URL_COMMAND = URL + \"/v1/devices/%s/abilities/%s/command?locationId=%s\";\n-    private static final String URL_PROPERTY = URL + \"/v1/devices/%s/abilities/%s/properties/%s?locationId=%s\";\n-    private static final String URL_SETTING = URL + \"/v1/devices/%s/settings/%s?locationId=%s\";\n-\n-    private Gson gson = new GsonBuilder().registerTypeAdapter(Date.class, new DateDeserializer())\n-            .registerTypeAdapter(PropertyValue.class, new PropertyValueDeserializer()).create();\n-    private HttpClient httpClient;\n+    private Gson gson = new GsonBuilder().registerTypeAdapter(DataItem.class, new DataItemDeserializer()).create();\n \n-    private String mowerDuration = DEFAULT_MOWER_DURATION;\n-    private Session session;\n-    private GardenaConfig config;\n-    private String id;\n+    private static final String URL_API_HUSQUARNA = \"https://api.authentication.husqvarnagroup.dev/v1\";\n+    private static final String URL_API_GARDENA = \"https://api.smart.gardena.dev/v1\";\n+    private static final String URL_API_TOKEN = URL_API_HUSQUARNA + \"/oauth2/token\";\n+    private static final String URL_API_WEBSOCKET = URL_API_GARDENA + \"/websocket\";\n+    private static final String URL_API_LOCATIONS = URL_API_GARDENA + \"/locations\";\n+    private static final String URL_API_COMMAND = URL_API_GARDENA + \"/command\";\n \n+    private String id;\n+    private GardenaConfig config;\n     private ScheduledExecutorService scheduler;\n-    private ScheduledFuture<?> refreshThreadFuture;\n-    private RefreshDevicesThread refreshDevicesThread = new RefreshDevicesThread();\n \n+    private Map<String, Device> allDevicesById = new HashMap<>();\n+    private LocationsResponse locationsResponse = new LocationsResponse();\n     private GardenaSmartEventListener eventListener;\n \n-    private Map<String, Device> allDevicesById = new HashMap<>();\n-    private Set<Location> allLocations = new HashSet<>();\n+    private HttpClient httpClient;\n+    private List<GardenaSmartWebSocket> webSockets = new ArrayList<>();\n+    private PostOAuth2Response token;\n+    private boolean initialized = false;\n+    private HttpClientFactory httpClientFactory;\n+    private WebSocketFactory webSocketFactory;\n+\n+    private Set<Device> devicesToNotify = Collections.synchronizedSet(new HashSet<>());\n+    private ScheduledFuture<?> deviceToNotifyFuture;\n \n     @Override\n     public void init(String id, GardenaConfig config, GardenaSmartEventListener eventListener,\n-            ScheduledExecutorService scheduler) throws GardenaException {\n+            ScheduledExecutorService scheduler, HttpClientFactory httpClientFactory, WebSocketFactory webSocketFactory)\n+            throws GardenaException {\n         this.id = id;\n         this.config = config;\n         this.eventListener = eventListener;\n         this.scheduler = scheduler;\n+        this.httpClientFactory = httpClientFactory;\n+        this.webSocketFactory = webSocketFactory;\n \n-        if (!config.isValid()) {\n-            throw new GardenaException(\"Invalid config, no email or password specified\");\n-        }\n-\n-        httpClient = new HttpClient(new SslContextFactory(true));\n-        httpClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n+        start();\n+    }\n \n+    /**\n+     * Starts the client, loads the locations and devices.\n+     */\n+    private void start() throws GardenaException {\n+        logger.debug(\"Starting GardenaSmart\");\n         try {\n+            httpClient = httpClientFactory.createHttpClient(id);\n+            httpClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n+            httpClient.setIdleTimeout(httpClient.getConnectTimeout());\n             httpClient.start();\n-        } catch (Exception ex) {\n-            throw new GardenaException(ex.getMessage(), ex);\n-        }\n \n-        loadAllDevices();\n-    }\n+            // initially load access token\n+            verifyToken();\n+            locationsResponse = loadLocations();\n \n-    @Override\n-    public void dispose() {\n-        stopRefreshThread(true);\n-        if (httpClient != null) {\n-            try {\n-                httpClient.stop();\n-            } catch (Exception e) {\n-                // ignore\n+            // assemble devices\n+            for (LocationDataItem location : locationsResponse.data) {\n+                LocationResponse locationResponse = loadLocation(location.id);\n+                if (locationResponse.included != null) {\n+                    for (DataItem<?> dataItem : locationResponse.included) {\n+                        handleDataItem(dataItem);\n+                    }\n+                }\n             }\n-            httpClient.destroy();\n+\n+            for (Device device : allDevicesById.values()) {\n+                device.evaluateDeviceType();\n+            }\n+\n+            startWebsockets();\n+            initialized = true;\n+        } catch (Exception ex) {\n+            logger.warn(\"{}\", ex.getMessage(), ex);\n+            throw new GardenaException(ex.getMessage(), ex);", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMDA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523810086", "bodyText": "You should specify the concrete exceptions you want to catch, since catching Exception catches also all runtime exceptions.", "author": "fwolter", "createdAt": "2020-11-15T20:35:20Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/GardenaSmartImpl.java", "diffHunk": "@@ -12,562 +12,376 @@\n  */\n package org.openhab.binding.gardena.internal;\n \n-import java.util.Collection;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n+import java.util.*;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n \n-import org.apache.commons.lang.ObjectUtils;\n-import org.apache.commons.lang.StringUtils;\n import org.eclipse.jetty.client.HttpClient;\n-import org.eclipse.jetty.client.HttpResponseException;\n import org.eclipse.jetty.client.api.ContentResponse;\n import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.AbstractTypedContentProvider;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n import org.eclipse.jetty.client.util.StringContentProvider;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n-import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.eclipse.jetty.util.Fields;\n import org.openhab.binding.gardena.internal.config.GardenaConfig;\n-import org.openhab.binding.gardena.internal.config.GardenaConfigWrapper;\n import org.openhab.binding.gardena.internal.exception.GardenaDeviceNotFoundException;\n import org.openhab.binding.gardena.internal.exception.GardenaException;\n-import org.openhab.binding.gardena.internal.exception.GardenaUnauthorizedException;\n-import org.openhab.binding.gardena.internal.model.Ability;\n+import org.openhab.binding.gardena.internal.model.DataItemDeserializer;\n import org.openhab.binding.gardena.internal.model.Device;\n-import org.openhab.binding.gardena.internal.model.Devices;\n-import org.openhab.binding.gardena.internal.model.Errors;\n-import org.openhab.binding.gardena.internal.model.Location;\n-import org.openhab.binding.gardena.internal.model.Locations;\n-import org.openhab.binding.gardena.internal.model.NoResult;\n-import org.openhab.binding.gardena.internal.model.Property;\n-import org.openhab.binding.gardena.internal.model.PropertyValue;\n-import org.openhab.binding.gardena.internal.model.Session;\n-import org.openhab.binding.gardena.internal.model.SessionWrapper;\n-import org.openhab.binding.gardena.internal.model.Setting;\n-import org.openhab.binding.gardena.internal.model.command.Command;\n-import org.openhab.binding.gardena.internal.model.command.MowerParkUntilFurtherNoticeCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerParkUntilNextTimerCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerStartOverrideTimerCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerStartResumeScheduleCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureAmbientTemperatureCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureLightCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureSoilHumidityCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureSoilTemperatureCommand;\n-import org.openhab.binding.gardena.internal.model.command.SettingCommand;\n-import org.openhab.binding.gardena.internal.model.command.SettingCommandWrapper;\n-import org.openhab.binding.gardena.internal.model.command.WateringCancelOverrideCommand;\n-import org.openhab.binding.gardena.internal.model.command.WateringManualOverrideCommand;\n-import org.openhab.binding.gardena.internal.model.deser.DateDeserializer;\n-import org.openhab.binding.gardena.internal.model.deser.PropertyValueDeserializer;\n-import org.openhab.binding.gardena.internal.model.property.BaseProperty;\n-import org.openhab.binding.gardena.internal.model.property.IrrigationControlWateringProperty;\n-import org.openhab.binding.gardena.internal.model.property.PropertyWrapper;\n-import org.openhab.binding.gardena.internal.model.property.StringProperty;\n+import org.openhab.binding.gardena.internal.model.api.*;\n+import org.openhab.binding.gardena.internal.model.command.GardenaCommand;\n+import org.openhab.binding.gardena.internal.model.command.GardenaCommandRequest;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.io.net.http.WebSocketFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n \n /**\n- * {@link GardenaSmart} implementation to access Gardena Smart Home.\n+ * {@link GardenaSmart} implementation to access Gardena smart system.\n  *\n  * @author Gerhard Riegler - Initial contribution\n  */\n-public class GardenaSmartImpl implements GardenaSmart {\n+public class GardenaSmartImpl implements GardenaSmart, GardenaSmartWebSocketListener {\n     private final Logger logger = LoggerFactory.getLogger(GardenaSmartImpl.class);\n \n-    public static final String DEVICE_CATEGORY_PUMP = \"electronic_pressure_pump\";\n-    private static final String ABILITY_MOWER = \"mower\";\n-    private static final String ABILITY_OUTLET = \"outlet\";\n-    private static final String ABILITY_HUMIDITY = \"humidity\";\n-    private static final String ABILITY_LIGHT = \"light\";\n-    private static final String ABILITY_AMBIENT_TEMPERATURE = \"ambient_temperature\";\n-    private static final String ABILITY_SOIL_TEMPERATURE = \"soil_temperature\";\n-    private static final String ABILITY_POWER = \"power\";\n-    private static final String ABILITY_WATERING = \"watering\";\n-    private static final String ABILITY_MANUAL_WATERING = \"manual_watering\";\n-\n-    private static final String PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME = \"button_manual_override_time\";\n-    private static final String PROPERTY_POWER_TIMER = \"power_timer\";\n-    private static final String PROPERTY_WATERING_TIMER = \"watering_timer_\";\n-    private static final String PROPERTY_MANUAL_WATERING_TIMER = \"manual_watering_timer\";\n-\n-    private static final String DEVICE_CATEGORY_MOWER = \"mower\";\n-    private static final String DEVICE_CATEGORY_GATEWAY = \"gateway\";\n-\n-    private static final String DEFAULT_MOWER_DURATION = \"180\";\n-\n-    private static final String URL = \"https://smart.gardena.com\";\n-    private static final String URL_LOGIN = URL + \"/v1/auth/token\";\n-    private static final String URL_LOCATIONS = URL + \"/v1/locations/?user_id=\";\n-    private static final String URL_DEVICES = URL + \"/v1/devices/?locationId=\";\n-    private static final String URL_COMMAND = URL + \"/v1/devices/%s/abilities/%s/command?locationId=%s\";\n-    private static final String URL_PROPERTY = URL + \"/v1/devices/%s/abilities/%s/properties/%s?locationId=%s\";\n-    private static final String URL_SETTING = URL + \"/v1/devices/%s/settings/%s?locationId=%s\";\n-\n-    private Gson gson = new GsonBuilder().registerTypeAdapter(Date.class, new DateDeserializer())\n-            .registerTypeAdapter(PropertyValue.class, new PropertyValueDeserializer()).create();\n-    private HttpClient httpClient;\n+    private Gson gson = new GsonBuilder().registerTypeAdapter(DataItem.class, new DataItemDeserializer()).create();\n \n-    private String mowerDuration = DEFAULT_MOWER_DURATION;\n-    private Session session;\n-    private GardenaConfig config;\n-    private String id;\n+    private static final String URL_API_HUSQUARNA = \"https://api.authentication.husqvarnagroup.dev/v1\";\n+    private static final String URL_API_GARDENA = \"https://api.smart.gardena.dev/v1\";\n+    private static final String URL_API_TOKEN = URL_API_HUSQUARNA + \"/oauth2/token\";\n+    private static final String URL_API_WEBSOCKET = URL_API_GARDENA + \"/websocket\";\n+    private static final String URL_API_LOCATIONS = URL_API_GARDENA + \"/locations\";\n+    private static final String URL_API_COMMAND = URL_API_GARDENA + \"/command\";\n \n+    private String id;\n+    private GardenaConfig config;\n     private ScheduledExecutorService scheduler;\n-    private ScheduledFuture<?> refreshThreadFuture;\n-    private RefreshDevicesThread refreshDevicesThread = new RefreshDevicesThread();\n \n+    private Map<String, Device> allDevicesById = new HashMap<>();\n+    private LocationsResponse locationsResponse = new LocationsResponse();\n     private GardenaSmartEventListener eventListener;\n \n-    private Map<String, Device> allDevicesById = new HashMap<>();\n-    private Set<Location> allLocations = new HashSet<>();\n+    private HttpClient httpClient;\n+    private List<GardenaSmartWebSocket> webSockets = new ArrayList<>();\n+    private PostOAuth2Response token;\n+    private boolean initialized = false;\n+    private HttpClientFactory httpClientFactory;\n+    private WebSocketFactory webSocketFactory;\n+\n+    private Set<Device> devicesToNotify = Collections.synchronizedSet(new HashSet<>());\n+    private ScheduledFuture<?> deviceToNotifyFuture;\n \n     @Override\n     public void init(String id, GardenaConfig config, GardenaSmartEventListener eventListener,\n-            ScheduledExecutorService scheduler) throws GardenaException {\n+            ScheduledExecutorService scheduler, HttpClientFactory httpClientFactory, WebSocketFactory webSocketFactory)\n+            throws GardenaException {\n         this.id = id;\n         this.config = config;\n         this.eventListener = eventListener;\n         this.scheduler = scheduler;\n+        this.httpClientFactory = httpClientFactory;\n+        this.webSocketFactory = webSocketFactory;\n \n-        if (!config.isValid()) {\n-            throw new GardenaException(\"Invalid config, no email or password specified\");\n-        }\n-\n-        httpClient = new HttpClient(new SslContextFactory(true));\n-        httpClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n+        start();\n+    }\n \n+    /**\n+     * Starts the client, loads the locations and devices.\n+     */\n+    private void start() throws GardenaException {\n+        logger.debug(\"Starting GardenaSmart\");\n         try {\n+            httpClient = httpClientFactory.createHttpClient(id);\n+            httpClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n+            httpClient.setIdleTimeout(httpClient.getConnectTimeout());\n             httpClient.start();\n-        } catch (Exception ex) {\n-            throw new GardenaException(ex.getMessage(), ex);\n-        }\n \n-        loadAllDevices();\n-    }\n+            // initially load access token\n+            verifyToken();\n+            locationsResponse = loadLocations();\n \n-    @Override\n-    public void dispose() {\n-        stopRefreshThread(true);\n-        if (httpClient != null) {\n-            try {\n-                httpClient.stop();\n-            } catch (Exception e) {\n-                // ignore\n+            // assemble devices\n+            for (LocationDataItem location : locationsResponse.data) {\n+                LocationResponse locationResponse = loadLocation(location.id);\n+                if (locationResponse.included != null) {\n+                    for (DataItem<?> dataItem : locationResponse.included) {\n+                        handleDataItem(dataItem);\n+                    }\n+                }\n             }\n-            httpClient.destroy();\n+\n+            for (Device device : allDevicesById.values()) {\n+                device.evaluateDeviceType();\n+            }\n+\n+            startWebsockets();\n+            initialized = true;\n+        } catch (Exception ex) {\n+            logger.warn(\"{}\", ex.getMessage(), ex);\n+            throw new GardenaException(ex.getMessage(), ex);\n         }\n-        allLocations.clear();\n-        allDevicesById.clear();\n     }\n \n     /**\n-     * Schedules the device refresh thread.\n+     * Starts the websockets for each location.\n      */\n-    private void startRefreshThread() {\n-        refreshThreadFuture = scheduler.scheduleWithFixedDelay(refreshDevicesThread, 6, config.getRefresh(),\n-                TimeUnit.SECONDS);\n+    private void startWebsockets() throws Exception {\n+        for (LocationDataItem location : locationsResponse.data) {\n+            WebSocketCreatedResponse webSocketCreatedResponse = getWebsocketInfo(location.id);\n+            String socketId = id + \"-\" + location.attributes.name;\n+            webSockets.add(new GardenaSmartWebSocket(this, webSocketCreatedResponse, config, scheduler,\n+                    webSocketFactory, token, socketId));\n+        }\n     }\n \n     /**\n-     * Stops the device refresh thread.\n+     * Stops all websockets.\n      */\n-    private void stopRefreshThread(boolean force) {\n-        if (refreshThreadFuture != null) {\n-            refreshThreadFuture.cancel(force);\n-        }\n-    }\n-\n-    @Override\n-    public String getId() {\n-        return id;\n-    }\n-\n-    @Override\n-    public Set<Location> getLocations() {\n-        return allLocations;\n-    }\n-\n-    @Override\n-    public Device getDevice(String deviceId) throws GardenaException {\n-        Device device = allDevicesById.get(deviceId);\n-        if (device == null) {\n-            throw new GardenaDeviceNotFoundException(\n-                    String.format(\"Device with id '%s' not found on gateway '%s'\", deviceId, id));\n-        }\n-        return device;\n-    }\n-\n-    @Override\n-    public void loadAllDevices() throws GardenaException {\n-        stopRefreshThread(false);\n-        try {\n-            allLocations.clear();\n-            allDevicesById.clear();\n-\n-            verifySession();\n-            Locations locations = executeRequest(HttpMethod.GET,\n-                    URL_LOCATIONS + session.getSessionAttributes().getUserId(), null, Locations.class);\n-\n-            for (Location location : locations.getLocations()) {\n-                allLocations.add(location);\n-                Devices devices = loadDevices(location);\n-                for (Device device : devices.getDevices()) {\n-                    if (DEVICE_CATEGORY_GATEWAY.equals(device.getCategory())) {\n-                        location.getDeviceIds().remove(device.getId());\n-                    } else {\n-                        allDevicesById.put(device.getId(), device);\n-                    }\n-                }\n-            }\n-        } finally {\n-            startRefreshThread();\n+    private void stopWebsockets() {\n+        for (GardenaSmartWebSocket webSocket : webSockets) {\n+            webSocket.stop();\n         }\n+        webSockets.clear();\n     }\n \n     /**\n-     * Loads all devices for the location, adds virtual properties for commands.\n+     * Communicates with Gardena smart home system and parses the result.\n      */\n-    private Devices loadDevices(Location location) throws GardenaException {\n-        Devices devices = executeRequest(HttpMethod.GET, URL_DEVICES + location.getId(), null, Devices.class);\n-        for (Device device : devices.getDevices()) {\n-            device.setLocation(location);\n-            for (Ability ability : device.getAbilities()) {\n-                ability.setDevice(device);\n-                for (Property property : ability.getProperties()) {\n-                    property.setAbility(ability);\n-\n-                    if (device.getCategory().equals(DEVICE_CATEGORY_PUMP)) {\n-                        if (property.getName().equals(PROPERTY_MANUAL_WATERING_TIMER)) {\n-                            Integer duration = getIntegerValue(property.getValueAsString());\n-                            if (duration == null) {\n-                                duration = 0;\n-                            }\n-                            property.setValue(new PropertyValue(String.valueOf(duration / 60)));\n-                        }\n-                    }\n+    private <T> T executeRequest(HttpMethod method, String url, Object content, Class<T> result)\n+            throws GardenaException {\n+        try {\n+            AbstractTypedContentProvider contentProvider = null;\n+            String contentType = \"application/vnd.api+json\";\n+            if (content != null) {\n+                if (content instanceof Fields) {\n+                    contentProvider = new FormContentProvider((Fields) content);\n+                    contentType = \"application/x-www-form-urlencoded\";\n+                } else {\n+                    contentProvider = new StringContentProvider(gson.toJson(content));\n                 }\n             }\n-            for (Setting setting : device.getSettings()) {\n-                setting.setDevice(device);\n+\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\">>> {} {}, data: {}\", method, url, content == null ? null : gson.toJson(content));\n             }\n \n-            if (DEVICE_CATEGORY_MOWER.equals(device.getCategory())) {\n-                Ability mower = device.getAbility(ABILITY_MOWER);\n-                mower.addProperty(new Property(GardenaSmartCommandName.PARK_UNTIL_NEXT_TIMER, \"false\"));\n-                mower.addProperty(new Property(GardenaSmartCommandName.PARK_UNTIL_FURTHER_NOTICE, \"false\"));\n-                mower.addProperty(new Property(GardenaSmartCommandName.START_RESUME_SCHEDULE, \"false\"));\n-                mower.addProperty(new Property(GardenaSmartCommandName.START_OVERRIDE_TIMER, \"false\"));\n+            Request request = httpClient.newRequest(url).method(method).header(HttpHeader.CONTENT_TYPE, contentType)\n+                    .header(HttpHeader.ACCEPT, \"application/vnd.api+json\").header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n \n-                mower.addProperty(new Property(GardenaSmartCommandName.DURATION_PROPERTY, mowerDuration));\n+            if (!URL_API_TOKEN.equals(url)) {\n+                verifyToken();\n+                request.header(\"Authorization\", token.tokenType + \" \" + token.accessToken);\n+                request.header(\"Authorization-provider\", token.provider);\n+                request.header(\"X-Api-Key\", config.getApiKey());\n             }\n-        }\n-        return devices;\n-    }\n \n-    @Override\n-    public void sendCommand(Device device, GardenaSmartCommandName commandName, Object value) throws GardenaException {\n-        Ability ability = null;\n-        Command command = null;\n-\n-        switch (commandName) {\n-            case PARK_UNTIL_NEXT_TIMER:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerParkUntilNextTimerCommand();\n-                break;\n-            case PARK_UNTIL_FURTHER_NOTICE:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerParkUntilFurtherNoticeCommand();\n-                break;\n-            case START_RESUME_SCHEDULE:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerStartResumeScheduleCommand();\n-                break;\n-            case START_OVERRIDE_TIMER:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerStartOverrideTimerCommand(mowerDuration);\n-                break;\n-            case DURATION_PROPERTY:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                }\n-                mowerDuration = ObjectUtils.toString(value);\n-                return;\n-            case MEASURE_AMBIENT_TEMPERATURE:\n-                ability = device.getAbility(ABILITY_AMBIENT_TEMPERATURE);\n-                command = new SensorMeasureAmbientTemperatureCommand();\n-                break;\n-            case MEASURE_LIGHT:\n-                ability = device.getAbility(ABILITY_LIGHT);\n-                command = new SensorMeasureLightCommand();\n-                break;\n-            case MEASURE_SOIL_HUMIDITY:\n-                ability = device.getAbility(ABILITY_HUMIDITY);\n-                command = new SensorMeasureSoilHumidityCommand();\n-                break;\n-            case MEASURE_SOIL_TEMPERATURE:\n-                ability = device.getAbility(ABILITY_SOIL_TEMPERATURE);\n-                command = new SensorMeasureSoilTemperatureCommand();\n-                break;\n-            case OUTLET_MANUAL_OVERRIDE_TIME:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                }\n-                StringProperty prop = new StringProperty(PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME,\n-                        ObjectUtils.toString(value));\n-\n-                executeSetProperty(device, ABILITY_OUTLET, PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME, prop);\n-                break;\n-            case OUTLET_VALVE:\n-                ability = device.getAbility(ABILITY_OUTLET);\n-                if (value != null && value == Boolean.TRUE) {\n-                    String wateringDuration = device.getAbility(ABILITY_OUTLET)\n-                            .getProperty(PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME).getValueAsString();\n-                    command = new WateringManualOverrideCommand(wateringDuration);\n-                } else {\n-                    command = new WateringCancelOverrideCommand();\n-                }\n-                break;\n-            case POWER_TIMER:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                }\n-                prop = new StringProperty(PROPERTY_POWER_TIMER, ObjectUtils.toString(value));\n-                executeSetProperty(device, ABILITY_POWER, PROPERTY_POWER_TIMER, prop);\n-                break;\n-            case WATERING_TIMER_VALVE_1:\n-            case WATERING_TIMER_VALVE_2:\n-            case WATERING_TIMER_VALVE_3:\n-            case WATERING_TIMER_VALVE_4:\n-            case WATERING_TIMER_VALVE_5:\n-            case WATERING_TIMER_VALVE_6:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                } else if (!(value instanceof Integer)) {\n-                    throw new GardenaException(\"Watering duration value '\" + value + \"' not a number\");\n-                }\n-                int valveId = Integer.parseInt(StringUtils.right(commandName.toString(), 1));\n-                String wateringTimerProperty = PROPERTY_WATERING_TIMER + valveId;\n-                IrrigationControlWateringProperty irrigationProp = new IrrigationControlWateringProperty(\n-                        wateringTimerProperty, (Integer) value, valveId);\n-                executeSetProperty(device, ABILITY_WATERING, wateringTimerProperty, irrigationProp);\n-                break;\n-            case PUMP_MANUAL_WATERING_TIMER:\n-                Integer duration = getIntegerValue(value);\n-                if (duration == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a number value\");\n-                }\n-                prop = new StringProperty(PROPERTY_MANUAL_WATERING_TIMER, String.valueOf(duration * 60));\n+            request.content(contentProvider);\n+            ContentResponse contentResponse = request.send();\n+            int status = contentResponse.getStatus();\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"<<< status:{}, {}\", status, contentResponse.getContentAsString());\n+            }\n \n-                executeSetProperty(device, ABILITY_MANUAL_WATERING, PROPERTY_MANUAL_WATERING_TIMER, prop);\n-                break;\n-            default:\n-                throw new GardenaException(\"Unknown command \" + commandName);\n-        }\n+            if (status != 200 && status != 204 && status != 201 && status != 202) {\n+                throw new GardenaException(String.format(\"Error %s %s, %s\", status, contentResponse.getReason(), contentResponse.getContentAsString()));\n+            }\n \n-        if (command != null) {\n-            stopRefreshThread(false);\n-            executeRequest(HttpMethod.POST, getCommandUrl(device, ability), command, NoResult.class);\n-            startRefreshThread();\n+            if (result == null) {\n+                return null;\n+            }\n+            return gson.fromJson(contentResponse.getContentAsString(), result);\n+        } catch (Exception ex) {", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMDM1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523810352", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-11-15T20:37:37Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/GardenaSmartImpl.java", "diffHunk": "@@ -12,562 +12,376 @@\n  */\n package org.openhab.binding.gardena.internal;\n \n-import java.util.Collection;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n+import java.util.*;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n \n-import org.apache.commons.lang.ObjectUtils;\n-import org.apache.commons.lang.StringUtils;\n import org.eclipse.jetty.client.HttpClient;\n-import org.eclipse.jetty.client.HttpResponseException;\n import org.eclipse.jetty.client.api.ContentResponse;\n import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.AbstractTypedContentProvider;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n import org.eclipse.jetty.client.util.StringContentProvider;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n-import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.eclipse.jetty.util.Fields;\n import org.openhab.binding.gardena.internal.config.GardenaConfig;\n-import org.openhab.binding.gardena.internal.config.GardenaConfigWrapper;\n import org.openhab.binding.gardena.internal.exception.GardenaDeviceNotFoundException;\n import org.openhab.binding.gardena.internal.exception.GardenaException;\n-import org.openhab.binding.gardena.internal.exception.GardenaUnauthorizedException;\n-import org.openhab.binding.gardena.internal.model.Ability;\n+import org.openhab.binding.gardena.internal.model.DataItemDeserializer;\n import org.openhab.binding.gardena.internal.model.Device;\n-import org.openhab.binding.gardena.internal.model.Devices;\n-import org.openhab.binding.gardena.internal.model.Errors;\n-import org.openhab.binding.gardena.internal.model.Location;\n-import org.openhab.binding.gardena.internal.model.Locations;\n-import org.openhab.binding.gardena.internal.model.NoResult;\n-import org.openhab.binding.gardena.internal.model.Property;\n-import org.openhab.binding.gardena.internal.model.PropertyValue;\n-import org.openhab.binding.gardena.internal.model.Session;\n-import org.openhab.binding.gardena.internal.model.SessionWrapper;\n-import org.openhab.binding.gardena.internal.model.Setting;\n-import org.openhab.binding.gardena.internal.model.command.Command;\n-import org.openhab.binding.gardena.internal.model.command.MowerParkUntilFurtherNoticeCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerParkUntilNextTimerCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerStartOverrideTimerCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerStartResumeScheduleCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureAmbientTemperatureCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureLightCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureSoilHumidityCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureSoilTemperatureCommand;\n-import org.openhab.binding.gardena.internal.model.command.SettingCommand;\n-import org.openhab.binding.gardena.internal.model.command.SettingCommandWrapper;\n-import org.openhab.binding.gardena.internal.model.command.WateringCancelOverrideCommand;\n-import org.openhab.binding.gardena.internal.model.command.WateringManualOverrideCommand;\n-import org.openhab.binding.gardena.internal.model.deser.DateDeserializer;\n-import org.openhab.binding.gardena.internal.model.deser.PropertyValueDeserializer;\n-import org.openhab.binding.gardena.internal.model.property.BaseProperty;\n-import org.openhab.binding.gardena.internal.model.property.IrrigationControlWateringProperty;\n-import org.openhab.binding.gardena.internal.model.property.PropertyWrapper;\n-import org.openhab.binding.gardena.internal.model.property.StringProperty;\n+import org.openhab.binding.gardena.internal.model.api.*;\n+import org.openhab.binding.gardena.internal.model.command.GardenaCommand;\n+import org.openhab.binding.gardena.internal.model.command.GardenaCommandRequest;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.io.net.http.WebSocketFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n \n /**\n- * {@link GardenaSmart} implementation to access Gardena Smart Home.\n+ * {@link GardenaSmart} implementation to access Gardena smart system.\n  *\n  * @author Gerhard Riegler - Initial contribution\n  */\n-public class GardenaSmartImpl implements GardenaSmart {\n+public class GardenaSmartImpl implements GardenaSmart, GardenaSmartWebSocketListener {\n     private final Logger logger = LoggerFactory.getLogger(GardenaSmartImpl.class);\n \n-    public static final String DEVICE_CATEGORY_PUMP = \"electronic_pressure_pump\";\n-    private static final String ABILITY_MOWER = \"mower\";\n-    private static final String ABILITY_OUTLET = \"outlet\";\n-    private static final String ABILITY_HUMIDITY = \"humidity\";\n-    private static final String ABILITY_LIGHT = \"light\";\n-    private static final String ABILITY_AMBIENT_TEMPERATURE = \"ambient_temperature\";\n-    private static final String ABILITY_SOIL_TEMPERATURE = \"soil_temperature\";\n-    private static final String ABILITY_POWER = \"power\";\n-    private static final String ABILITY_WATERING = \"watering\";\n-    private static final String ABILITY_MANUAL_WATERING = \"manual_watering\";\n-\n-    private static final String PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME = \"button_manual_override_time\";\n-    private static final String PROPERTY_POWER_TIMER = \"power_timer\";\n-    private static final String PROPERTY_WATERING_TIMER = \"watering_timer_\";\n-    private static final String PROPERTY_MANUAL_WATERING_TIMER = \"manual_watering_timer\";\n-\n-    private static final String DEVICE_CATEGORY_MOWER = \"mower\";\n-    private static final String DEVICE_CATEGORY_GATEWAY = \"gateway\";\n-\n-    private static final String DEFAULT_MOWER_DURATION = \"180\";\n-\n-    private static final String URL = \"https://smart.gardena.com\";\n-    private static final String URL_LOGIN = URL + \"/v1/auth/token\";\n-    private static final String URL_LOCATIONS = URL + \"/v1/locations/?user_id=\";\n-    private static final String URL_DEVICES = URL + \"/v1/devices/?locationId=\";\n-    private static final String URL_COMMAND = URL + \"/v1/devices/%s/abilities/%s/command?locationId=%s\";\n-    private static final String URL_PROPERTY = URL + \"/v1/devices/%s/abilities/%s/properties/%s?locationId=%s\";\n-    private static final String URL_SETTING = URL + \"/v1/devices/%s/settings/%s?locationId=%s\";\n-\n-    private Gson gson = new GsonBuilder().registerTypeAdapter(Date.class, new DateDeserializer())\n-            .registerTypeAdapter(PropertyValue.class, new PropertyValueDeserializer()).create();\n-    private HttpClient httpClient;\n+    private Gson gson = new GsonBuilder().registerTypeAdapter(DataItem.class, new DataItemDeserializer()).create();\n \n-    private String mowerDuration = DEFAULT_MOWER_DURATION;\n-    private Session session;\n-    private GardenaConfig config;\n-    private String id;\n+    private static final String URL_API_HUSQUARNA = \"https://api.authentication.husqvarnagroup.dev/v1\";\n+    private static final String URL_API_GARDENA = \"https://api.smart.gardena.dev/v1\";\n+    private static final String URL_API_TOKEN = URL_API_HUSQUARNA + \"/oauth2/token\";\n+    private static final String URL_API_WEBSOCKET = URL_API_GARDENA + \"/websocket\";\n+    private static final String URL_API_LOCATIONS = URL_API_GARDENA + \"/locations\";\n+    private static final String URL_API_COMMAND = URL_API_GARDENA + \"/command\";\n \n+    private String id;\n+    private GardenaConfig config;\n     private ScheduledExecutorService scheduler;\n-    private ScheduledFuture<?> refreshThreadFuture;\n-    private RefreshDevicesThread refreshDevicesThread = new RefreshDevicesThread();\n \n+    private Map<String, Device> allDevicesById = new HashMap<>();\n+    private LocationsResponse locationsResponse = new LocationsResponse();\n     private GardenaSmartEventListener eventListener;\n \n-    private Map<String, Device> allDevicesById = new HashMap<>();\n-    private Set<Location> allLocations = new HashSet<>();\n+    private HttpClient httpClient;\n+    private List<GardenaSmartWebSocket> webSockets = new ArrayList<>();\n+    private PostOAuth2Response token;\n+    private boolean initialized = false;\n+    private HttpClientFactory httpClientFactory;\n+    private WebSocketFactory webSocketFactory;\n+\n+    private Set<Device> devicesToNotify = Collections.synchronizedSet(new HashSet<>());\n+    private ScheduledFuture<?> deviceToNotifyFuture;\n \n     @Override\n     public void init(String id, GardenaConfig config, GardenaSmartEventListener eventListener,\n-            ScheduledExecutorService scheduler) throws GardenaException {\n+            ScheduledExecutorService scheduler, HttpClientFactory httpClientFactory, WebSocketFactory webSocketFactory)\n+            throws GardenaException {\n         this.id = id;\n         this.config = config;\n         this.eventListener = eventListener;\n         this.scheduler = scheduler;\n+        this.httpClientFactory = httpClientFactory;\n+        this.webSocketFactory = webSocketFactory;\n \n-        if (!config.isValid()) {\n-            throw new GardenaException(\"Invalid config, no email or password specified\");\n-        }\n-\n-        httpClient = new HttpClient(new SslContextFactory(true));\n-        httpClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n+        start();\n+    }\n \n+    /**\n+     * Starts the client, loads the locations and devices.\n+     */\n+    private void start() throws GardenaException {\n+        logger.debug(\"Starting GardenaSmart\");\n         try {\n+            httpClient = httpClientFactory.createHttpClient(id);\n+            httpClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n+            httpClient.setIdleTimeout(httpClient.getConnectTimeout());\n             httpClient.start();\n-        } catch (Exception ex) {\n-            throw new GardenaException(ex.getMessage(), ex);\n-        }\n \n-        loadAllDevices();\n-    }\n+            // initially load access token\n+            verifyToken();\n+            locationsResponse = loadLocations();\n \n-    @Override\n-    public void dispose() {\n-        stopRefreshThread(true);\n-        if (httpClient != null) {\n-            try {\n-                httpClient.stop();\n-            } catch (Exception e) {\n-                // ignore\n+            // assemble devices\n+            for (LocationDataItem location : locationsResponse.data) {\n+                LocationResponse locationResponse = loadLocation(location.id);\n+                if (locationResponse.included != null) {\n+                    for (DataItem<?> dataItem : locationResponse.included) {\n+                        handleDataItem(dataItem);\n+                    }\n+                }\n             }\n-            httpClient.destroy();\n+\n+            for (Device device : allDevicesById.values()) {\n+                device.evaluateDeviceType();\n+            }\n+\n+            startWebsockets();\n+            initialized = true;\n+        } catch (Exception ex) {\n+            logger.warn(\"{}\", ex.getMessage(), ex);\n+            throw new GardenaException(ex.getMessage(), ex);\n         }\n-        allLocations.clear();\n-        allDevicesById.clear();\n     }\n \n     /**\n-     * Schedules the device refresh thread.\n+     * Starts the websockets for each location.\n      */\n-    private void startRefreshThread() {\n-        refreshThreadFuture = scheduler.scheduleWithFixedDelay(refreshDevicesThread, 6, config.getRefresh(),\n-                TimeUnit.SECONDS);\n+    private void startWebsockets() throws Exception {\n+        for (LocationDataItem location : locationsResponse.data) {\n+            WebSocketCreatedResponse webSocketCreatedResponse = getWebsocketInfo(location.id);\n+            String socketId = id + \"-\" + location.attributes.name;\n+            webSockets.add(new GardenaSmartWebSocket(this, webSocketCreatedResponse, config, scheduler,\n+                    webSocketFactory, token, socketId));\n+        }\n     }\n \n     /**\n-     * Stops the device refresh thread.\n+     * Stops all websockets.\n      */\n-    private void stopRefreshThread(boolean force) {\n-        if (refreshThreadFuture != null) {\n-            refreshThreadFuture.cancel(force);\n-        }\n-    }\n-\n-    @Override\n-    public String getId() {\n-        return id;\n-    }\n-\n-    @Override\n-    public Set<Location> getLocations() {\n-        return allLocations;\n-    }\n-\n-    @Override\n-    public Device getDevice(String deviceId) throws GardenaException {\n-        Device device = allDevicesById.get(deviceId);\n-        if (device == null) {\n-            throw new GardenaDeviceNotFoundException(\n-                    String.format(\"Device with id '%s' not found on gateway '%s'\", deviceId, id));\n-        }\n-        return device;\n-    }\n-\n-    @Override\n-    public void loadAllDevices() throws GardenaException {\n-        stopRefreshThread(false);\n-        try {\n-            allLocations.clear();\n-            allDevicesById.clear();\n-\n-            verifySession();\n-            Locations locations = executeRequest(HttpMethod.GET,\n-                    URL_LOCATIONS + session.getSessionAttributes().getUserId(), null, Locations.class);\n-\n-            for (Location location : locations.getLocations()) {\n-                allLocations.add(location);\n-                Devices devices = loadDevices(location);\n-                for (Device device : devices.getDevices()) {\n-                    if (DEVICE_CATEGORY_GATEWAY.equals(device.getCategory())) {\n-                        location.getDeviceIds().remove(device.getId());\n-                    } else {\n-                        allDevicesById.put(device.getId(), device);\n-                    }\n-                }\n-            }\n-        } finally {\n-            startRefreshThread();\n+    private void stopWebsockets() {\n+        for (GardenaSmartWebSocket webSocket : webSockets) {\n+            webSocket.stop();\n         }\n+        webSockets.clear();\n     }\n \n     /**\n-     * Loads all devices for the location, adds virtual properties for commands.\n+     * Communicates with Gardena smart home system and parses the result.\n      */\n-    private Devices loadDevices(Location location) throws GardenaException {\n-        Devices devices = executeRequest(HttpMethod.GET, URL_DEVICES + location.getId(), null, Devices.class);\n-        for (Device device : devices.getDevices()) {\n-            device.setLocation(location);\n-            for (Ability ability : device.getAbilities()) {\n-                ability.setDevice(device);\n-                for (Property property : ability.getProperties()) {\n-                    property.setAbility(ability);\n-\n-                    if (device.getCategory().equals(DEVICE_CATEGORY_PUMP)) {\n-                        if (property.getName().equals(PROPERTY_MANUAL_WATERING_TIMER)) {\n-                            Integer duration = getIntegerValue(property.getValueAsString());\n-                            if (duration == null) {\n-                                duration = 0;\n-                            }\n-                            property.setValue(new PropertyValue(String.valueOf(duration / 60)));\n-                        }\n-                    }\n+    private <T> T executeRequest(HttpMethod method, String url, Object content, Class<T> result)\n+            throws GardenaException {\n+        try {\n+            AbstractTypedContentProvider contentProvider = null;\n+            String contentType = \"application/vnd.api+json\";\n+            if (content != null) {\n+                if (content instanceof Fields) {\n+                    contentProvider = new FormContentProvider((Fields) content);\n+                    contentType = \"application/x-www-form-urlencoded\";\n+                } else {\n+                    contentProvider = new StringContentProvider(gson.toJson(content));\n                 }\n             }\n-            for (Setting setting : device.getSettings()) {\n-                setting.setDevice(device);\n+\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\">>> {} {}, data: {}\", method, url, content == null ? null : gson.toJson(content));\n             }\n \n-            if (DEVICE_CATEGORY_MOWER.equals(device.getCategory())) {\n-                Ability mower = device.getAbility(ABILITY_MOWER);\n-                mower.addProperty(new Property(GardenaSmartCommandName.PARK_UNTIL_NEXT_TIMER, \"false\"));\n-                mower.addProperty(new Property(GardenaSmartCommandName.PARK_UNTIL_FURTHER_NOTICE, \"false\"));\n-                mower.addProperty(new Property(GardenaSmartCommandName.START_RESUME_SCHEDULE, \"false\"));\n-                mower.addProperty(new Property(GardenaSmartCommandName.START_OVERRIDE_TIMER, \"false\"));\n+            Request request = httpClient.newRequest(url).method(method).header(HttpHeader.CONTENT_TYPE, contentType)\n+                    .header(HttpHeader.ACCEPT, \"application/vnd.api+json\").header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n \n-                mower.addProperty(new Property(GardenaSmartCommandName.DURATION_PROPERTY, mowerDuration));\n+            if (!URL_API_TOKEN.equals(url)) {\n+                verifyToken();\n+                request.header(\"Authorization\", token.tokenType + \" \" + token.accessToken);\n+                request.header(\"Authorization-provider\", token.provider);\n+                request.header(\"X-Api-Key\", config.getApiKey());\n             }\n-        }\n-        return devices;\n-    }\n \n-    @Override\n-    public void sendCommand(Device device, GardenaSmartCommandName commandName, Object value) throws GardenaException {\n-        Ability ability = null;\n-        Command command = null;\n-\n-        switch (commandName) {\n-            case PARK_UNTIL_NEXT_TIMER:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerParkUntilNextTimerCommand();\n-                break;\n-            case PARK_UNTIL_FURTHER_NOTICE:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerParkUntilFurtherNoticeCommand();\n-                break;\n-            case START_RESUME_SCHEDULE:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerStartResumeScheduleCommand();\n-                break;\n-            case START_OVERRIDE_TIMER:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerStartOverrideTimerCommand(mowerDuration);\n-                break;\n-            case DURATION_PROPERTY:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                }\n-                mowerDuration = ObjectUtils.toString(value);\n-                return;\n-            case MEASURE_AMBIENT_TEMPERATURE:\n-                ability = device.getAbility(ABILITY_AMBIENT_TEMPERATURE);\n-                command = new SensorMeasureAmbientTemperatureCommand();\n-                break;\n-            case MEASURE_LIGHT:\n-                ability = device.getAbility(ABILITY_LIGHT);\n-                command = new SensorMeasureLightCommand();\n-                break;\n-            case MEASURE_SOIL_HUMIDITY:\n-                ability = device.getAbility(ABILITY_HUMIDITY);\n-                command = new SensorMeasureSoilHumidityCommand();\n-                break;\n-            case MEASURE_SOIL_TEMPERATURE:\n-                ability = device.getAbility(ABILITY_SOIL_TEMPERATURE);\n-                command = new SensorMeasureSoilTemperatureCommand();\n-                break;\n-            case OUTLET_MANUAL_OVERRIDE_TIME:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                }\n-                StringProperty prop = new StringProperty(PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME,\n-                        ObjectUtils.toString(value));\n-\n-                executeSetProperty(device, ABILITY_OUTLET, PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME, prop);\n-                break;\n-            case OUTLET_VALVE:\n-                ability = device.getAbility(ABILITY_OUTLET);\n-                if (value != null && value == Boolean.TRUE) {\n-                    String wateringDuration = device.getAbility(ABILITY_OUTLET)\n-                            .getProperty(PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME).getValueAsString();\n-                    command = new WateringManualOverrideCommand(wateringDuration);\n-                } else {\n-                    command = new WateringCancelOverrideCommand();\n-                }\n-                break;\n-            case POWER_TIMER:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                }\n-                prop = new StringProperty(PROPERTY_POWER_TIMER, ObjectUtils.toString(value));\n-                executeSetProperty(device, ABILITY_POWER, PROPERTY_POWER_TIMER, prop);\n-                break;\n-            case WATERING_TIMER_VALVE_1:\n-            case WATERING_TIMER_VALVE_2:\n-            case WATERING_TIMER_VALVE_3:\n-            case WATERING_TIMER_VALVE_4:\n-            case WATERING_TIMER_VALVE_5:\n-            case WATERING_TIMER_VALVE_6:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                } else if (!(value instanceof Integer)) {\n-                    throw new GardenaException(\"Watering duration value '\" + value + \"' not a number\");\n-                }\n-                int valveId = Integer.parseInt(StringUtils.right(commandName.toString(), 1));\n-                String wateringTimerProperty = PROPERTY_WATERING_TIMER + valveId;\n-                IrrigationControlWateringProperty irrigationProp = new IrrigationControlWateringProperty(\n-                        wateringTimerProperty, (Integer) value, valveId);\n-                executeSetProperty(device, ABILITY_WATERING, wateringTimerProperty, irrigationProp);\n-                break;\n-            case PUMP_MANUAL_WATERING_TIMER:\n-                Integer duration = getIntegerValue(value);\n-                if (duration == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a number value\");\n-                }\n-                prop = new StringProperty(PROPERTY_MANUAL_WATERING_TIMER, String.valueOf(duration * 60));\n+            request.content(contentProvider);\n+            ContentResponse contentResponse = request.send();\n+            int status = contentResponse.getStatus();\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"<<< status:{}, {}\", status, contentResponse.getContentAsString());\n+            }\n \n-                executeSetProperty(device, ABILITY_MANUAL_WATERING, PROPERTY_MANUAL_WATERING_TIMER, prop);\n-                break;\n-            default:\n-                throw new GardenaException(\"Unknown command \" + commandName);\n-        }\n+            if (status != 200 && status != 204 && status != 201 && status != 202) {\n+                throw new GardenaException(String.format(\"Error %s %s, %s\", status, contentResponse.getReason(), contentResponse.getContentAsString()));\n+            }\n \n-        if (command != null) {\n-            stopRefreshThread(false);\n-            executeRequest(HttpMethod.POST, getCommandUrl(device, ability), command, NoResult.class);\n-            startRefreshThread();\n+            if (result == null) {\n+                return null;\n+            }\n+            return gson.fromJson(contentResponse.getContentAsString(), result);\n+        } catch (Exception ex) {\n+            throw new GardenaException(ex.getMessage(), ex);\n         }\n     }\n \n-    private Integer getIntegerValue(Object value) {\n-        try {\n-            return Integer.valueOf(ObjectUtils.toString(value));\n-        } catch (NumberFormatException ex) {\n-            return null;\n+    /**\n+     * Creates or refreshes the access token for the Gardena smart system.\n+     */\n+    private synchronized void verifyToken() throws GardenaException {\n+        Fields fields = new Fields();\n+        fields.add(\"client_id\", config.getApiKey());\n+\n+        if (token == null || token.isRefreshTokenExpired()) {\n+            // new token\n+            logger.debug(\"Gardena API login using password, reason: {}\",\n+                    token == null ? \"no token available\" : \"refresh token expired\");\n+            fields.add(\"grant_type\", \"password\");\n+            fields.add(\"username\", config.getEmail());\n+            fields.add(\"password\", config.getPassword());\n+            token = executeRequest(HttpMethod.POST, URL_API_TOKEN, fields, PostOAuth2Response.class);\n+            token.postProcess();\n+        } else if (token.isAccessTokenExpired()) {\n+            // refresh token\n+            logger.debug(\"Gardena API login using refreshToken, reason: access token expired\");\n+            fields.add(\"grant_type\", \"refresh_token\");\n+            fields.add(\"refresh_token\", token.refreshToken);\n+            try {\n+                PostOAuth2Response tempToken = executeRequest(HttpMethod.POST, URL_API_TOKEN, fields,\n+                        PostOAuth2Response.class);\n+                token.accessToken = tempToken.accessToken;\n+                token.expiresIn = tempToken.expiresIn;\n+                token.postProcess();\n+            } catch (GardenaException ex) {\n+                // refresh token issue\n+                token = null;\n+                verifyToken();\n+            }\n+        } else {\n+            logger.debug(\"Gardena API token valid\");\n         }\n+        logger.debug(\"{}\", token.toString());\n     }\n \n     /**\n-     * Sends the new property value for the ability.\n+     * Loads all locations.\n      */\n-    private void executeSetProperty(Device device, String ability, String property, BaseProperty value)\n-            throws GardenaException {\n-        String propertyUrl = String.format(URL_PROPERTY, device.getId(), ability, property,\n-                device.getLocation().getId());\n-        stopRefreshThread(false);\n-        executeRequest(HttpMethod.PUT, propertyUrl, new PropertyWrapper(value), NoResult.class);\n-        device.getAbility(ability).getProperty(property).setValue(new PropertyValue(value.getValue()));\n-        startRefreshThread();\n-    }\n-\n-    @Override\n-    public void sendSetting(Setting setting, Object value) throws GardenaException {\n-        SettingCommand settingCommand = new SettingCommand(setting.getName());\n-        settingCommand.setDeviceId(setting.getDevice().getId());\n-        settingCommand.setValue(value);\n-\n-        stopRefreshThread(false);\n-        executeRequest(HttpMethod.PUT, getSettingUrl(setting), new SettingCommandWrapper(settingCommand),\n-                NoResult.class);\n-        startRefreshThread();\n+    private LocationsResponse loadLocations() throws GardenaException {\n+        return executeRequest(HttpMethod.GET, URL_API_LOCATIONS, null, LocationsResponse.class);\n     }\n \n     /**\n-     * Returns the command url.\n+     * Loads all devices for a given location.\n      */\n-    private String getCommandUrl(Device device, Ability ability) throws GardenaException {\n-        return String.format(URL_COMMAND, device.getId(), ability.getName(), device.getLocation().getId());\n+    private LocationResponse loadLocation(String locationId) throws GardenaException {\n+        return executeRequest(HttpMethod.GET, URL_API_LOCATIONS + \"/\" + locationId, null, LocationResponse.class);\n     }\n \n     /**\n-     * Returns the settings url.\n+     * Returns the websocket url for a given location.\n      */\n-    private String getSettingUrl(Setting setting) {\n-        Device device = setting.getDevice();\n-        return String.format(URL_SETTING, device.getId(), setting.getId(), device.getLocation().getId());\n+    private WebSocketCreatedResponse getWebsocketInfo(String locationId) throws GardenaException {\n+        return executeRequest(HttpMethod.POST, URL_API_WEBSOCKET, new CreateWebSocketRequest(locationId),\n+                WebSocketCreatedResponse.class);\n     }\n \n     /**\n-     * Communicates with Gardena Smart Home and parses the result.\n+     * Stops the client.\n      */\n-    private synchronized <T> T executeRequest(HttpMethod method, String url, Object contentObject, Class<T> result)\n-            throws GardenaException {\n-        try {\n-            if (logger.isTraceEnabled()) {\n-                logger.trace(\"{} request:  {}\", method, url);\n-                if (contentObject != null) {\n-                    logger.trace(\"{} data   :  {}\", method, gson.toJson(contentObject));\n-                }\n-            }\n-\n-            Request request = httpClient.newRequest(url).method(method)\n-                    .timeout(config.getConnectionTimeout(), TimeUnit.SECONDS)\n-                    .idleTimeout(config.getConnectionTimeout(), TimeUnit.SECONDS)\n-                    .header(HttpHeader.CONTENT_TYPE, \"application/json\").header(HttpHeader.ACCEPT, \"application/json\")\n-                    .header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n-\n-            if (contentObject != null) {\n-                StringContentProvider content = new StringContentProvider(gson.toJson(contentObject));\n-                request.content(content);\n-            }\n-\n-            if (!result.equals(SessionWrapper.class)) {\n-                verifySession();\n-                request.header(\"authorization\", \"Bearer \" + session.getToken());\n-                request.header(\"authorization-provider\", session.getSessionAttributes().getProvider());\n-            }\n-\n-            ContentResponse contentResponse = request.send();\n-            int status = contentResponse.getStatus();\n-            if (logger.isTraceEnabled()) {\n-                logger.trace(\"Status  : {}\", status);\n-                logger.trace(\"Response: {}\", contentResponse.getContentAsString());\n-            }\n-\n-            if (status == 500) {\n-                throw new GardenaException(\n-                        gson.fromJson(contentResponse.getContentAsString(), Errors.class).toString());\n-            } else if (status != 200 && status != 204 && status != 201) {\n-                throw new GardenaException(String.format(\"Error %s %s\", status, contentResponse.getReason()));\n-            }\n-\n-            if (result == NoResult.class) {\n-                return null;\n-            }\n-\n-            return gson.fromJson(contentResponse.getContentAsString(), result);\n-        } catch (ExecutionException ex) {\n-            Throwable cause = ex.getCause();\n-            if (cause instanceof HttpResponseException) {\n-                HttpResponseException responseException = (HttpResponseException) ex.getCause();\n-                int status = responseException.getResponse().getStatus();\n-                if (status == 401) {\n-                    throw new GardenaUnauthorizedException(ex.getCause());\n-                }\n+    public void dispose() {\n+        logger.debug(\"Disposing GardenaSmart\");\n+        if (deviceToNotifyFuture != null) {\n+            deviceToNotifyFuture.cancel(true);\n+        }\n+        stopWebsockets();\n+        if (httpClient != null) {\n+            try {\n+                httpClient.stop();\n+            } catch (Exception e) {\n+                // ignore\n             }\n-            throw new GardenaException(ex.getMessage(), ex);\n-        } catch (Exception ex) {\n-            throw new GardenaException(ex.getMessage(), ex);\n+            httpClient.destroy();\n         }\n+        locationsResponse = new LocationsResponse();\n+        allDevicesById.clear();\n+        initialized = false;\n     }\n \n     /**\n-     * Verifies the Gardena Smart Home session and reconnects if necessary.\n+     * Restarts all websockets.\n      */\n-    private void verifySession() throws GardenaException {\n-        if (session == null\n-                || session.getCreated() + (config.getSessionTimeout() * 60000) <= System.currentTimeMillis()) {\n-            logger.trace(\"(Re)logging in to Gardena Smart Home\");\n-            session = executeRequest(HttpMethod.POST, URL_LOGIN, new GardenaConfigWrapper(config), SessionWrapper.class)\n-                    .getSession();\n+    @Override\n+    public synchronized void restartWebsockets() {\n+        logger.debug(\"Restarting GardenaSmart Webservice\");\n+        stopWebsockets();\n+        try {\n+            startWebsockets();\n+        } catch (Exception ex) {\n+            logger.warn(\"Restarting GardenaSmart Webservice failed: {}, restarting binding\", ex.getMessage());\n+            eventListener.onError();\n         }\n     }\n \n     /**\n-     * Thread which refreshes the data from Gardena Smart Home.\n+     * Sets the dataItem from the websocket event into the correct device.\n      */\n-    private class RefreshDevicesThread implements Runnable {\n-        private boolean connectionLost = false;\n-\n-        @Override\n-        public void run() {\n-            try {\n-                logger.debug(\"Refreshing gardena device data\");\n-                final Map<String, Device> newDevicesById = new HashMap<>();\n-\n-                for (Location location : allLocations) {\n-                    Devices devices = loadDevices(location);\n-                    for (Device device : devices.getDevices()) {\n-                        if (DEVICE_CATEGORY_GATEWAY.equals(device.getCategory())) {\n-                            location.getDeviceIds().remove(device.getId());\n-                        } else {\n-                            newDevicesById.put(device.getId(), device);\n-                        }\n+    private void handleDataItem(final DataItem<?> dataItem) throws GardenaException {\n+        final String deviceId = dataItem.getDeviceId();\n+        Device device = allDevicesById.get(deviceId);\n+        if (device == null && !(dataItem instanceof LocationDataItem)) {\n+            device = new Device(deviceId);\n+            allDevicesById.put(device.id, device);\n+\n+            if (initialized) {\n+                scheduler.schedule(() -> {\n+                    Device newDevice = allDevicesById.get(deviceId);\n+                    newDevice.evaluateDeviceType();\n+                    if (newDevice.deviceType != null) {\n+                        eventListener.onNewDevice(newDevice);\n                     }\n-                }\n-\n-                if (connectionLost) {\n-                    connectionLost = false;\n-                    logger.info(\"Connection resumed to Gardena Smart Home with id '{}'\", id);\n-                    eventListener.onConnectionResumed();\n-                }\n-\n-                // determine deleted devices\n-                Collection<Device> deletedDevices = allDevicesById.values().stream()\n-                        .filter(d -> !newDevicesById.values().contains(d)).collect(Collectors.toSet());\n+                }, 3, TimeUnit.SECONDS);\n+            }\n+        }\n \n-                // determine new devices\n-                Collection<Device> newDevices = newDevicesById.values().stream()\n-                        .filter(d -> !allDevicesById.values().contains(d)).collect(Collectors.toSet());\n+        if (device != null) {\n+            device.setDataItem(dataItem);\n+        }\n+    }\n \n-                // determine updated devices\n-                Collection<Device> updatedDevices = allDevicesById.values().stream().distinct()\n-                        .filter(newDevicesById.values()::contains).collect(Collectors.toSet());\n+    @Override\n+    public void onWebSocketClose() {\n+        restartWebsockets();\n+    }\n \n-                allDevicesById = newDevicesById;\n+    @Override\n+    public void onWebSocketError() {\n+        eventListener.onError();\n+    }\n \n-                for (Device deletedDevice : deletedDevices) {\n-                    eventListener.onDeviceDeleted(deletedDevice);\n+    @Override\n+    public void onWebSocketMessage(String msg) {\n+        try {\n+            DataItem<?> dataItem = gson.fromJson(msg, DataItem.class);\n+            handleDataItem(dataItem);\n+            Device device = allDevicesById.get(dataItem.getDeviceId());\n+            if (device != null && device.active) {\n+                devicesToNotify.add(device);\n+\n+                // delay the deviceUpdated event to filter multiple events for the same device dataItem property\n+                if (deviceToNotifyFuture == null) {\n+                    deviceToNotifyFuture = scheduler.schedule(() -> {\n+                        deviceToNotifyFuture = null;\n+                        Iterator<Device> notifyIterator = devicesToNotify.iterator();\n+                        while (notifyIterator.hasNext()) {\n+                            eventListener.onDeviceUpdated(notifyIterator.next());\n+                            notifyIterator.remove();\n+                        }\n+                    }, 1, TimeUnit.SECONDS);\n                 }\n+            }\n+        } catch (Exception ex) {", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMDUyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523810522", "bodyText": "Would scheduleWithFixedDelay() be sufficient? See https://www.openhab.org/docs/developer/guidelines.html#e-runtime-behavior", "author": "fwolter", "createdAt": "2020-11-15T20:39:12Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/GardenaSmartWebSocket.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.*;\n+import org.eclipse.jetty.websocket.api.extensions.Frame;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.frames.PongFrame;\n+import org.openhab.binding.gardena.internal.config.GardenaConfig;\n+import org.openhab.binding.gardena.internal.model.api.PostOAuth2Response;\n+import org.openhab.binding.gardena.internal.model.api.WebSocketCreatedResponse;\n+import org.openhab.core.io.net.http.WebSocketFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GardenaSmartWebSocket} implements the websocket for receiving constant updates from the Gardena smart\n+ * system.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@WebSocket\n+public class GardenaSmartWebSocket {\n+    private final Logger logger = LoggerFactory.getLogger(GardenaSmartWebSocket.class);\n+    private final GardenaSmartWebSocketListener socketEventListener;\n+    private final static long WEBSOCKET_IDLE_TIMEOUT = 300;\n+\n+    private WebSocketSession session;\n+    private WebSocketClient webSocketClient;\n+    private boolean closing;\n+    private Instant lastPong = Instant.now();\n+    private ScheduledExecutorService scheduler;\n+    private ScheduledFuture openhab;\n+    private ByteBuffer pingPayload = ByteBuffer.wrap(\"ping\".getBytes());\n+    private PostOAuth2Response token;\n+    private String socketId;\n+\n+    /**\n+     * Starts the websocket session.\n+     */\n+    public GardenaSmartWebSocket(GardenaSmartWebSocketListener socketEventListener,\n+            WebSocketCreatedResponse webSocketCreatedResponse, GardenaConfig config, ScheduledExecutorService scheduler,\n+            WebSocketFactory webSocketFactory, PostOAuth2Response token, String socketId) throws Exception {\n+        this.socketEventListener = socketEventListener;\n+        this.scheduler = scheduler;\n+        this.token = token;\n+        this.socketId = socketId;\n+\n+        webSocketClient = webSocketFactory.createWebSocketClient(String.valueOf(this.getClass().hashCode()));\n+        webSocketClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n+        webSocketClient.setStopTimeout(3000);\n+        webSocketClient.setMaxIdleTimeout(150000);\n+        webSocketClient.start();\n+\n+        logger.debug(\"Connecting to Gardena Webservice ({})\", socketId);\n+        session = (WebSocketSession) webSocketClient\n+                .connect(this, new URI(webSocketCreatedResponse.data.attributes.url)).get();\n+        session.setStopTimeout(3000);\n+    }\n+\n+    /**\n+     * Stops the websocket session.\n+     */\n+    public synchronized void stop() {\n+        closing = true;\n+        if (openhab != null) {\n+            openhab.cancel(true);\n+        }\n+        if (isRunning()) {\n+            logger.debug(\"Closing Gardena Webservice client ({})\", socketId);\n+            try {\n+                session.close();\n+            } catch (Exception ex) {\n+                // ignore\n+            } finally {\n+                try {\n+                    webSocketClient.stop();\n+                } catch (Exception e) {\n+                    // ignore\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns true, if the websocket is running.\n+     */\n+    public synchronized boolean isRunning() {\n+        return session != null && session.isOpen();\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        closing = false;\n+        logger.debug(\"Connected to Gardena Webservice ({})\", socketId);\n+\n+        openhab = scheduler.scheduleAtFixedRate(new ConnectionTrackerThread(), 2, 2, TimeUnit.MINUTES);", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMDY0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523810644", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be debug. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging\nAlso, logging the stack trace seems a bit unreasonable here.", "author": "fwolter", "createdAt": "2020-11-15T20:39:56Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/GardenaSmartWebSocket.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.*;\n+import org.eclipse.jetty.websocket.api.extensions.Frame;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.frames.PongFrame;\n+import org.openhab.binding.gardena.internal.config.GardenaConfig;\n+import org.openhab.binding.gardena.internal.model.api.PostOAuth2Response;\n+import org.openhab.binding.gardena.internal.model.api.WebSocketCreatedResponse;\n+import org.openhab.core.io.net.http.WebSocketFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GardenaSmartWebSocket} implements the websocket for receiving constant updates from the Gardena smart\n+ * system.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@WebSocket\n+public class GardenaSmartWebSocket {\n+    private final Logger logger = LoggerFactory.getLogger(GardenaSmartWebSocket.class);\n+    private final GardenaSmartWebSocketListener socketEventListener;\n+    private final static long WEBSOCKET_IDLE_TIMEOUT = 300;\n+\n+    private WebSocketSession session;\n+    private WebSocketClient webSocketClient;\n+    private boolean closing;\n+    private Instant lastPong = Instant.now();\n+    private ScheduledExecutorService scheduler;\n+    private ScheduledFuture openhab;\n+    private ByteBuffer pingPayload = ByteBuffer.wrap(\"ping\".getBytes());\n+    private PostOAuth2Response token;\n+    private String socketId;\n+\n+    /**\n+     * Starts the websocket session.\n+     */\n+    public GardenaSmartWebSocket(GardenaSmartWebSocketListener socketEventListener,\n+            WebSocketCreatedResponse webSocketCreatedResponse, GardenaConfig config, ScheduledExecutorService scheduler,\n+            WebSocketFactory webSocketFactory, PostOAuth2Response token, String socketId) throws Exception {\n+        this.socketEventListener = socketEventListener;\n+        this.scheduler = scheduler;\n+        this.token = token;\n+        this.socketId = socketId;\n+\n+        webSocketClient = webSocketFactory.createWebSocketClient(String.valueOf(this.getClass().hashCode()));\n+        webSocketClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n+        webSocketClient.setStopTimeout(3000);\n+        webSocketClient.setMaxIdleTimeout(150000);\n+        webSocketClient.start();\n+\n+        logger.debug(\"Connecting to Gardena Webservice ({})\", socketId);\n+        session = (WebSocketSession) webSocketClient\n+                .connect(this, new URI(webSocketCreatedResponse.data.attributes.url)).get();\n+        session.setStopTimeout(3000);\n+    }\n+\n+    /**\n+     * Stops the websocket session.\n+     */\n+    public synchronized void stop() {\n+        closing = true;\n+        if (openhab != null) {\n+            openhab.cancel(true);\n+        }\n+        if (isRunning()) {\n+            logger.debug(\"Closing Gardena Webservice client ({})\", socketId);\n+            try {\n+                session.close();\n+            } catch (Exception ex) {\n+                // ignore\n+            } finally {\n+                try {\n+                    webSocketClient.stop();\n+                } catch (Exception e) {\n+                    // ignore\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns true, if the websocket is running.\n+     */\n+    public synchronized boolean isRunning() {\n+        return session != null && session.isOpen();\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        closing = false;\n+        logger.debug(\"Connected to Gardena Webservice ({})\", socketId);\n+\n+        openhab = scheduler.scheduleAtFixedRate(new ConnectionTrackerThread(), 2, 2, TimeUnit.MINUTES);\n+    }\n+\n+    @OnWebSocketFrame\n+    public void onFrame(Frame pong) {\n+        if (pong instanceof PongFrame) {\n+            lastPong = Instant.now();\n+            logger.trace(\"Pong received ({})\", socketId);\n+        }\n+    }\n+\n+    @OnWebSocketClose\n+    public void onClose(int statusCode, String reason) {\n+        if (!closing) {\n+            logger.debug(\"Connection to Gardena Webservice was closed ({}): code: {}, reason: {}\", socketId, statusCode,\n+                    reason);\n+            socketEventListener.onWebSocketClose();\n+        }\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        if (!closing) {\n+            logger.warn(\"Gardena Webservice error ({}): {}, restarting\", socketId, cause.getMessage());\n+            logger.debug(\"{}\", cause.getMessage(), cause);\n+            socketEventListener.onWebSocketError();\n+        }\n+    }\n+\n+    @OnWebSocketMessage\n+    public void onMessage(String msg) {\n+        if (!closing) {\n+            logger.trace(\"<<< event ({}): {}\", socketId, msg);\n+            socketEventListener.onWebSocketMessage(msg);\n+        }\n+    }\n+\n+    /**\n+     * Sends a ping in regular interval to tell the Gardena smart system that the client is alive.\n+     */\n+    private class ConnectionTrackerThread implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            try {\n+                logger.trace(\"Sending ping ({})\", socketId);\n+                session.getRemote().sendPing(pingPayload);\n+\n+                if ((Instant.now().getEpochSecond() - lastPong.getEpochSecond() > WEBSOCKET_IDLE_TIMEOUT)\n+                        || token.isAccessTokenExpired()) {\n+                    session.close(1000, \"Timeout manually closing dead connection (\" + socketId + \")\");\n+                }\n+            } catch (IOException ex) {\n+                logger.error(\"{}\", ex.getMessage(), ex);", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMDc0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523810745", "bodyText": "Since we want to get rid of Apache Commons, can you replace this with native Java code? See #7722.", "author": "fwolter", "createdAt": "2020-11-15T20:40:49Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/config/GardenaConfig.java", "diffHunk": "@@ -46,87 +39,72 @@ public GardenaConfig(String email, String password) {\n     }\n \n     /**\n-     * Returns the email to connect to Gardena Smart Home.\n+     * Returns the email to connect to Gardena smart system.\n      */\n     public String getEmail() {\n         return email;\n     }\n \n     /**\n-     * Sets the email to connect to Gardena Smart Home.\n+     * Sets the email to connect to Gardena smart system.\n      */\n     public void setEmail(String email) {\n         this.email = email;\n     }\n \n     /**\n-     * Returns the password to connect to Gardena Smart Home.\n+     * Returns the password to connect to Gardena smart system.\n      */\n     public String getPassword() {\n         return password;\n     }\n \n     /**\n-     * Sets the password to connect to Gardena Smart Home.\n+     * Sets the password to connect to Gardena smart system.\n      */\n     public void setPassword(String password) {\n         this.password = password;\n     }\n \n     /**\n-     * Returns the session timeout to Gardena Smart Home.\n-     */\n-    public int getSessionTimeout() {\n-        return sessionTimeout;\n-    }\n-\n-    /**\n-     * Sets the session timeout to Gardena Smart Home.\n-     */\n-    public void setSessionTimeout(int sessionTimeout) {\n-        this.sessionTimeout = sessionTimeout;\n-    }\n-\n-    /**\n-     * Returns the connection timeout to Gardena Smart Home.\n+     * Returns the connection timeout to Gardena smart system.\n      */\n     public Integer getConnectionTimeout() {\n         return connectionTimeout;\n     }\n \n     /**\n-     * Sets the connection timeout to Gardena Smart Home.\n+     * Sets the connection timeout to Gardena smart system.\n      */\n     public void setConnectionTimeout(Integer connectionTimeout) {\n         this.connectionTimeout = connectionTimeout;\n     }\n \n     /**\n-     * Returns the refresh interval to fetch new data from Gardena Smart Home.\n+     * Returns the api key.\n      */\n-    public Integer getRefresh() {\n-        return refresh;\n+    public String getApiKey() {\n+        return apiKey;\n     }\n \n     /**\n-     * Returns the refresh interval to fetch new data from Gardena Smart Home.\n+     * Sets the api key.\n      */\n-    public void setRefresh(Integer refresh) {\n-        this.refresh = refresh;\n+    public void setApiKey(String apiKey) {\n+        this.apiKey = apiKey;\n     }\n \n     /**\n-     * Validate the config, if at least email and password is specified.\n+     * Validate the config if email, password and apiKey is specified.\n      */\n     public boolean isValid() {\n-        return StringUtils.isNotBlank(email) && StringUtils.isNotBlank(password);\n+        return StringUtils.isNotBlank(email) && StringUtils.isNotBlank(password) && StringUtils.isNotBlank(apiKey);", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMDg3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523810878", "bodyText": "Please add the NonNullByDefault annotation.", "author": "fwolter", "createdAt": "2020-11-15T20:41:56Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/discovery/GardenaDeviceDiscoveryService.java", "diffHunk": "@@ -41,15 +41,15 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * The {@link GardenaDeviceDiscoveryService} is used to discover devices that are connected to Gardena Smart Home.\n+ * The {@link GardenaDeviceDiscoveryService} is used to discover devices that are connected to Gardena smart system.\n  *\n  * @author Gerhard Riegler - Initial contribution\n  */\n public class GardenaDeviceDiscoveryService extends AbstractDiscoveryService", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMDk4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523810983", "bodyText": "See above. Concrete Exception. Logging to error. Logging stack trace.", "author": "fwolter", "createdAt": "2020-11-15T20:43:01Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/discovery/GardenaDeviceDiscoveryService.java", "diffHunk": "@@ -158,19 +150,18 @@ public void waitForScanFinishing() {\n      * Generates the DiscoveryResult from a Gardena device.\n      */\n     public void deviceDiscovered(Device device) {\n-        ThingUID accountUID = accountHandler.getThing().getUID();\n-        ThingUID thingUID = UidUtils.generateThingUID(device, accountHandler.getThing());\n-\n-        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withBridge(accountUID)\n-                .withLabel(device.getName()).build();\n-        thingDiscovered(discoveryResult);\n-    }\n+        if (device.active) {\n+            ThingUID accountUID = accountHandler.getThing().getUID();\n+            ThingUID thingUID = UidUtils.generateThingUID(device, accountHandler.getThing());\n \n-    /**\n-     * Removes the Gardena device.\n-     */\n-    public void deviceRemoved(Device device) {\n-        ThingUID thingUID = UidUtils.generateThingUID(device, accountHandler.getThing());\n-        thingRemoved(thingUID);\n+            try {\n+                DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withBridge(accountUID)\n+                        .withLabel(PropertyUtils.getPropertyValue(device, \"common.attributes.name.value\", String.class))\n+                        .build();\n+                thingDiscovered(discoveryResult);\n+            } catch (Exception ex) {\n+                logger.error(\"{}\", ex.getMessage(), ex);", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMTAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523811013", "bodyText": "Can you add the representationProperty?", "author": "fwolter", "createdAt": "2020-11-15T20:43:31Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/discovery/GardenaDeviceDiscoveryService.java", "diffHunk": "@@ -158,19 +150,18 @@ public void waitForScanFinishing() {\n      * Generates the DiscoveryResult from a Gardena device.\n      */\n     public void deviceDiscovered(Device device) {\n-        ThingUID accountUID = accountHandler.getThing().getUID();\n-        ThingUID thingUID = UidUtils.generateThingUID(device, accountHandler.getThing());\n-\n-        DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withBridge(accountUID)\n-                .withLabel(device.getName()).build();\n-        thingDiscovered(discoveryResult);\n-    }\n+        if (device.active) {\n+            ThingUID accountUID = accountHandler.getThing().getUID();\n+            ThingUID thingUID = UidUtils.generateThingUID(device, accountHandler.getThing());\n \n-    /**\n-     * Removes the Gardena device.\n-     */\n-    public void deviceRemoved(Device device) {\n-        ThingUID thingUID = UidUtils.generateThingUID(device, accountHandler.getThing());\n-        thingRemoved(thingUID);\n+            try {\n+                DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(thingUID).withBridge(accountUID)\n+                        .withLabel(PropertyUtils.getPropertyValue(device, \"common.attributes.name.value\", String.class))\n+                        .build();", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMTA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523811069", "bodyText": "NonNullByDefault annotation", "author": "fwolter", "createdAt": "2020-11-15T20:44:02Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/handler/GardenaAccountHandler.java", "diffHunk": "@@ -39,22 +35,26 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * The {@link GardenaAccountHandler} is the handler for a Gardena Smart Home access and connects it to the framework.\n+ * The {@link GardenaAccountHandler} is the handler for a Gardena smart system access and connects it to the framework.\n  *\n  * @author Gerhard Riegler - Initial contribution\n  */\n public class GardenaAccountHandler extends BaseBridgeHandler implements GardenaSmartEventListener {", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMTUyNA==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523811524", "bodyText": "See above. Apache commons.", "author": "fwolter", "createdAt": "2020-11-15T20:47:42Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/handler/GardenaThingHandler.java", "diffHunk": "@@ -142,210 +99,164 @@ public void channelLinked(ChannelUID channelUID) {\n      * Updates the channel from the Gardena device.\n      */\n     protected void updateChannel(ChannelUID channelUID) throws GardenaException, AccountHandlerNotAvailableException {\n-        Device device = getDevice();\n-        State state = convertToState(device, channelUID);\n-        if (state != null) {\n-            updateState(channelUID, state);\n+        boolean isCommand = channelUID.getGroupId().endsWith(\"_commands\");\n+        if (!isCommand || (isCommand && isLocalDurationCommand(channelUID))) {\n+            Device device = getDevice();\n+            State state = convertToState(device, channelUID);\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n         }\n     }\n \n     /**\n      * Converts a Gardena property value to a openHAB state.\n      */\n     private State convertToState(Device device, ChannelUID channelUID) throws GardenaException {\n-        String abilityName = channelUID.getGroupId();\n+        if (isLocalDurationCommand(channelUID)) {\n+            String dataItemProperty = getDeviceDataItemProperty(channelUID);\n+            return new DecimalType(Math.round(device.getLocalService(dataItemProperty).commandDuration / 60.0));\n+        }\n+\n+        String propertyPath = channelUID.getGroupId() + \".attributes.\";\n         String propertyName = channelUID.getIdWithoutGroup();\n \n+        if (propertyName.endsWith(\"_timestamp\")) {\n+            propertyPath += propertyName.replace(\"_\", \".\");\n+        } else {\n+            propertyPath += propertyName + \".value\";\n+        }\n+\n+        String acceptedItemType = StringUtils\n+                .substringBefore(getThing().getChannel(channelUID.getId()).getAcceptedItemType(), \":\");", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMTc0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523811743", "bodyText": "You might want to use this https://www.openhab.org/javadoc/v2.5/org/eclipse/smarthome/core/i18n/timezoneprovider as the user can configure a different time zone in the OH config. This class can be injected via the factory like the HttpClient.", "author": "fwolter", "createdAt": "2020-11-15T20:49:35Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/handler/GardenaThingHandler.java", "diffHunk": "@@ -142,210 +99,164 @@ public void channelLinked(ChannelUID channelUID) {\n      * Updates the channel from the Gardena device.\n      */\n     protected void updateChannel(ChannelUID channelUID) throws GardenaException, AccountHandlerNotAvailableException {\n-        Device device = getDevice();\n-        State state = convertToState(device, channelUID);\n-        if (state != null) {\n-            updateState(channelUID, state);\n+        boolean isCommand = channelUID.getGroupId().endsWith(\"_commands\");\n+        if (!isCommand || (isCommand && isLocalDurationCommand(channelUID))) {\n+            Device device = getDevice();\n+            State state = convertToState(device, channelUID);\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n         }\n     }\n \n     /**\n      * Converts a Gardena property value to a openHAB state.\n      */\n     private State convertToState(Device device, ChannelUID channelUID) throws GardenaException {\n-        String abilityName = channelUID.getGroupId();\n+        if (isLocalDurationCommand(channelUID)) {\n+            String dataItemProperty = getDeviceDataItemProperty(channelUID);\n+            return new DecimalType(Math.round(device.getLocalService(dataItemProperty).commandDuration / 60.0));\n+        }\n+\n+        String propertyPath = channelUID.getGroupId() + \".attributes.\";\n         String propertyName = channelUID.getIdWithoutGroup();\n \n+        if (propertyName.endsWith(\"_timestamp\")) {\n+            propertyPath += propertyName.replace(\"_\", \".\");\n+        } else {\n+            propertyPath += propertyName + \".value\";\n+        }\n+\n+        String acceptedItemType = StringUtils\n+                .substringBefore(getThing().getChannel(channelUID.getId()).getAcceptedItemType(), \":\");\n+\n         try {\n-            String value = device.getAbility(abilityName).getProperty(propertyName).getValueAsString();\n+            boolean isNullPropertyValue = PropertyUtils.isNull(device, propertyPath);\n+            boolean isDurationProperty = \"duration\".equals(propertyName);\n \n-            if (StringUtils.trimToNull(value) == null || StringUtils.equals(value, \"N/A\")) {\n+            if (isNullPropertyValue && !isDurationProperty) {\n                 return UnDefType.NULL;\n             }\n-\n-            switch (getThing().getChannel(channelUID.getId()).getAcceptedItemType()) {\n+            switch (acceptedItemType) {\n                 case \"String\":\n-                    return new StringType(value);\n+                    return new StringType(PropertyUtils.getPropertyValue(device, propertyPath, String.class));\n                 case \"Number\":\n-                    if (ABILITY_RADIO.equals(abilityName) && PROPERTY_STATE.equals(propertyName)) {\n-                        switch (value) {\n-                            case \"poor\":\n-                                return new DecimalType(1);\n-                            case \"good\":\n-                                return new DecimalType(2);\n-                            case \"excellent\":\n-                                return new DecimalType(4);\n-                            default:\n-                                return UnDefType.NULL;\n+                    if (isNullPropertyValue) {\n+                        return new DecimalType(0);\n+                    } else {\n+                        long value = PropertyUtils.getPropertyValue(device, propertyPath, Number.class).longValue();\n+                        // convert duration from seconds to minutes\n+                        if (isDurationProperty) {\n+                            value = Math.round(value / 60.0);\n                         }\n+                        return new DecimalType(value);\n                     }\n-                    return new DecimalType(value);\n-                case \"Switch\":\n-                    return Boolean.TRUE.toString().equalsIgnoreCase(value) || \"on\".equalsIgnoreCase(value)\n-                            ? OnOffType.ON\n-                            : OnOffType.OFF;\n                 case \"DateTime\":\n-                    Calendar cal = DateUtils.parseToCalendar(value);\n-                    if (cal != null && !cal.before(VALID_DATE_START)) {\n-                        return new DateTimeType(ZonedDateTime.ofInstant(cal.toInstant(), ZoneId.systemDefault()));\n-                    } else {\n-                        return UnDefType.NULL;\n-                    }\n+                    Date date = PropertyUtils.getPropertyValue(device, propertyPath, Date.class);\n+                    ZonedDateTime zdt = ZonedDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMTg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523811869", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-11-15T20:50:40Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/handler/GardenaThingHandler.java", "diffHunk": "@@ -142,210 +99,164 @@ public void channelLinked(ChannelUID channelUID) {\n      * Updates the channel from the Gardena device.\n      */\n     protected void updateChannel(ChannelUID channelUID) throws GardenaException, AccountHandlerNotAvailableException {\n-        Device device = getDevice();\n-        State state = convertToState(device, channelUID);\n-        if (state != null) {\n-            updateState(channelUID, state);\n+        boolean isCommand = channelUID.getGroupId().endsWith(\"_commands\");\n+        if (!isCommand || (isCommand && isLocalDurationCommand(channelUID))) {\n+            Device device = getDevice();\n+            State state = convertToState(device, channelUID);\n+            if (state != null) {\n+                updateState(channelUID, state);\n+            }\n         }\n     }\n \n     /**\n      * Converts a Gardena property value to a openHAB state.\n      */\n     private State convertToState(Device device, ChannelUID channelUID) throws GardenaException {\n-        String abilityName = channelUID.getGroupId();\n+        if (isLocalDurationCommand(channelUID)) {\n+            String dataItemProperty = getDeviceDataItemProperty(channelUID);\n+            return new DecimalType(Math.round(device.getLocalService(dataItemProperty).commandDuration / 60.0));\n+        }\n+\n+        String propertyPath = channelUID.getGroupId() + \".attributes.\";\n         String propertyName = channelUID.getIdWithoutGroup();\n \n+        if (propertyName.endsWith(\"_timestamp\")) {\n+            propertyPath += propertyName.replace(\"_\", \".\");\n+        } else {\n+            propertyPath += propertyName + \".value\";\n+        }\n+\n+        String acceptedItemType = StringUtils\n+                .substringBefore(getThing().getChannel(channelUID.getId()).getAcceptedItemType(), \":\");\n+\n         try {\n-            String value = device.getAbility(abilityName).getProperty(propertyName).getValueAsString();\n+            boolean isNullPropertyValue = PropertyUtils.isNull(device, propertyPath);\n+            boolean isDurationProperty = \"duration\".equals(propertyName);\n \n-            if (StringUtils.trimToNull(value) == null || StringUtils.equals(value, \"N/A\")) {\n+            if (isNullPropertyValue && !isDurationProperty) {\n                 return UnDefType.NULL;\n             }\n-\n-            switch (getThing().getChannel(channelUID.getId()).getAcceptedItemType()) {\n+            switch (acceptedItemType) {\n                 case \"String\":\n-                    return new StringType(value);\n+                    return new StringType(PropertyUtils.getPropertyValue(device, propertyPath, String.class));\n                 case \"Number\":\n-                    if (ABILITY_RADIO.equals(abilityName) && PROPERTY_STATE.equals(propertyName)) {\n-                        switch (value) {\n-                            case \"poor\":\n-                                return new DecimalType(1);\n-                            case \"good\":\n-                                return new DecimalType(2);\n-                            case \"excellent\":\n-                                return new DecimalType(4);\n-                            default:\n-                                return UnDefType.NULL;\n+                    if (isNullPropertyValue) {\n+                        return new DecimalType(0);\n+                    } else {\n+                        long value = PropertyUtils.getPropertyValue(device, propertyPath, Number.class).longValue();\n+                        // convert duration from seconds to minutes\n+                        if (isDurationProperty) {\n+                            value = Math.round(value / 60.0);\n                         }\n+                        return new DecimalType(value);\n                     }\n-                    return new DecimalType(value);\n-                case \"Switch\":\n-                    return Boolean.TRUE.toString().equalsIgnoreCase(value) || \"on\".equalsIgnoreCase(value)\n-                            ? OnOffType.ON\n-                            : OnOffType.OFF;\n                 case \"DateTime\":\n-                    Calendar cal = DateUtils.parseToCalendar(value);\n-                    if (cal != null && !cal.before(VALID_DATE_START)) {\n-                        return new DateTimeType(ZonedDateTime.ofInstant(cal.toInstant(), ZoneId.systemDefault()));\n-                    } else {\n-                        return UnDefType.NULL;\n-                    }\n+                    Date date = PropertyUtils.getPropertyValue(device, propertyPath, Date.class);\n+                    ZonedDateTime zdt = ZonedDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());\n+                    return new DateTimeType(zdt);\n             }\n         } catch (GardenaException e) {\n-            logger.warn(\"Channel '{}' cannot be updated as device does not contain property '{}:{}'\", channelUID,\n-                    abilityName, propertyName);\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Converts an openHAB type to a Gardena command property.\n-     */\n-    private Object convertFromType(Type type) {\n-        if (type instanceof OnOffType) {\n-            return type == OnOffType.ON ? Boolean.TRUE : Boolean.FALSE;\n-        } else if (type instanceof DecimalType) {\n-            return ((DecimalType) type).intValue();\n-        } else if (type instanceof StringType) {\n-            return ((StringType) type).toFullString();\n+            logger.warn(\"Channel '{}' cannot be updated as device does not contain propertyPath '{}'\", channelUID,\n+                    propertyPath);\n+        } catch (ClassCastException ex) {\n+            logger.warn(\"Value of propertyPath '{}' can not be casted to {}: {}\", propertyPath, acceptedItemType,\n+                    ex.getMessage());\n         }\n         return null;\n     }\n \n     @Override\n     public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Command received: {}\", command);\n         try {\n-            GardenaSmartCommandName commandName = getCommandName(channelUID);\n-            logger.debug(\"Received Gardena command: {}\", commandName);\n-\n+            boolean isOnCommand = command instanceof OnOffType && ((OnOffType) command) == OnOffType.ON;\n+            String dataItemProperty = getDeviceDataItemProperty(channelUID);\n             if (RefreshType.REFRESH == command) {\n-                logger.debug(\"Refreshing channel '{}'\", channelUID);\n-                if (commandName != null && commandName.toString().startsWith(\"MEASURE_\")) {\n-                    getGardenaSmart().sendCommand(getDevice(), commandName, null);\n-                } else {\n-                    updateChannel(channelUID);\n+                logger.debug(\"Refreshing Gardena connection\");\n+                getGardenaSmart().restartWebsockets();\n+            } else if (isLocalDurationCommand(channelUID)) {\n+                QuantityType<?> quantityType = (QuantityType<?>) command;\n+                getDevice().getLocalService(dataItemProperty).commandDuration = quantityType.intValue() * 60;\n+            } else if (isOnCommand) {\n+                GardenaCommand gardenaCommand = getGardenaCommand(dataItemProperty, channelUID);\n+                if (gardenaCommand != null) {\n+                    logger.debug(\"Received Gardena command: {}, {}\", gardenaCommand.getClass().getSimpleName(),\n+                            gardenaCommand.attributes.command);\n+\n+                    DataItem<?> dataItem = PropertyUtils.getPropertyValue(getDevice(), dataItemProperty,\n+                            DataItem.class);\n+                    if (dataItem == null) {\n+                        logger.warn(\"DataItem {} is empty, ignoring command.\", dataItemProperty);\n+                    } else {\n+                        getGardenaSmart().sendCommand(dataItem, gardenaCommand);\n+\n+                        scheduler.schedule(() -> {\n+                            updateState(channelUID, OnOffType.OFF);\n+                        }, 3, TimeUnit.SECONDS);\n+                    }\n                 }\n-            } else if (commandName != null) {\n-                getGardenaSmart().sendCommand(getDevice(), commandName, convertFromType(command));\n             }\n         } catch (AccountHandlerNotAvailableException | GardenaDeviceNotFoundException ex) {\n             // ignore\n         } catch (Exception ex) {\n             logger.warn(\"{}\", ex.getMessage(), ex);\n+            ((GardenaSmartEventListener) getBridge().getHandler()).onError();", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMjMyNA==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523812324", "bodyText": "Please use camelCase. You could use the SerializedName annotation to change the mapping.", "author": "fwolter", "createdAt": "2020-11-15T20:54:43Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/model/Device.java", "diffHunk": "@@ -12,123 +12,138 @@\n  */\n package org.openhab.binding.gardena.internal.model;\n \n-import java.util.ArrayList;\n-import java.util.List;\n+import static org.openhab.binding.gardena.internal.GardenaBindingConstants.*;\n \n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.StringUtils;\n import org.apache.commons.lang.builder.EqualsBuilder;\n import org.apache.commons.lang.builder.HashCodeBuilder;\n import org.openhab.binding.gardena.internal.exception.GardenaException;\n-\n-import com.google.gson.annotations.SerializedName;\n+import org.openhab.binding.gardena.internal.model.api.*;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * Represents a Gardena device.\n  *\n  * @author Gerhard Riegler - Initial contribution\n  */\n public class Device {\n-\n-    private String id;\n-    private String name;\n-    private String description;\n-    private String category;\n-    @SerializedName(\"configuration_synchronized\")\n-    private boolean configurationSynchronized;\n-    private List<Ability> abilities = new ArrayList<>();\n-    @SerializedName(\"scheduled_events\")\n-    private List<ScheduledEvent> scheduledEvents = new ArrayList<>();\n-    private transient Location location;\n-    private List<Setting> settings = new ArrayList<>();\n-\n-    /**\n-     * Returns the id of the device.\n-     */\n-    public String getId() {\n-        return id;\n+    private final Logger logger = LoggerFactory.getLogger(Device.class);\n+\n+    private transient static final String DEVICE_TYPE_PREFIX = \"gardena smart\";\n+    public boolean active = true;\n+    public String id;\n+    public String deviceType;\n+    public String location;\n+    public CommonServiceDataItem common;\n+    public MowerServiceDataItem mower;\n+    public PowerSocketServiceDataItem powerSocket;\n+    public SensorServiceDataItem sensor;\n+    public ValveServiceDataItem valve;\n+    public ValveServiceDataItem valve_1;", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMjU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523812566", "bodyText": "You could move this into a package called dto or append DTO to the class name to get rid of the checkstyle warning about missing NonNullByDefault annotation.", "author": "fwolter", "createdAt": "2020-11-15T20:56:48Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/model/api/CreateWebSocket.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal.model.api;\n+\n+/**\n+ * Represents a Gardena object that is sent via the Gardena API.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+\n+public class CreateWebSocket {", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzgxMzE1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r523813151", "bodyText": "See above.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (Exception ex) {\n          \n          \n            \n                    } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {", "author": "fwolter", "createdAt": "2020-11-15T21:01:24Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/util/PropertyUtils.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal.util;\n+\n+import java.lang.reflect.Field;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.openhab.binding.gardena.internal.exception.GardenaException;\n+\n+/**\n+ * Utility class to read nested properties.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+\n+public class PropertyUtils {\n+\n+    /**\n+     * Returns true if the property is null.\n+     */\n+    public static boolean isNull(Object instance, String propertyPath) throws GardenaException {\n+        return getPropertyValue(instance, propertyPath, Object.class) == null;\n+    }\n+\n+    /**\n+     * Returns the property value from the object instance, nested properties are possible.\n+     */\n+    public static <T> T getPropertyValue(Object instance, String propertyPath, Class<T> resultClass)\n+            throws GardenaException {\n+        String[] properties = StringUtils.split(propertyPath, \".\");\n+        return getPropertyValue(instance, properties, resultClass, 0);\n+    }\n+\n+    /**\n+     * Iterates through the nested properties and returns the field value.\n+     */\n+    private static <T> T getPropertyValue(Object instance, String[] properties, Class<T> resultClass, int nestedIndex)\n+            throws GardenaException {\n+        if (instance == null) {\n+            return null;\n+        }\n+        try {\n+            String propertyName = properties[nestedIndex];\n+            Field field = instance.getClass().getField(propertyName);\n+            Object result = field.get(instance);\n+            if (nestedIndex + 1 < properties.length) {\n+                return getPropertyValue(result, properties, resultClass, nestedIndex + 1);\n+            }\n+            return (T) result;\n+        } catch (Exception ex) {", "originalCommit": "f549d3d4efe014ad5a6354ff596dd5ac9ffaa604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c1e87888a71ff57af9ad5f22777ff3acb67f11fa", "url": "https://github.com/openhab/openhab-addons/commit/c1e87888a71ff57af9ad5f22777ff3acb67f11fa", "message": "Suggested changes according to pull request\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-11-28T14:54:59Z", "type": "commit"}, {"oid": "2297635f03cc6b21454042b399bef3ab3b2fd082", "url": "https://github.com/openhab/openhab-addons/commit/2297635f03cc6b21454042b399bef3ab3b2fd082", "message": "Merge branch 'main' into gardena_3\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>\n\n# Conflicts:\n#\tbundles/org.openhab.binding.gardena/src/main/resources/OH-INF/binding/binding.xml", "committedDate": "2020-11-28T14:55:50Z", "type": "commit"}, {"oid": "b42747d765efe0d249729c3097c003ee79debd02", "url": "https://github.com/openhab/openhab-addons/commit/b42747d765efe0d249729c3097c003ee79debd02", "message": "Added @NonNullByDefault annotations\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-02T20:03:55Z", "type": "commit"}, {"oid": "12428cd36c960e02c5710c9c85a1141730d11f67", "url": "https://github.com/openhab/openhab-addons/commit/12428cd36c960e02c5710c9c85a1141730d11f67", "message": "Changed light intensity pattern\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-05T13:34:17Z", "type": "commit"}, {"oid": "26f23acce2d301b9e97f08b43f416555f612b81a", "url": "https://github.com/openhab/openhab-addons/commit/26f23acce2d301b9e97f08b43f416555f612b81a", "message": "Merge branch 'main' into gardena_3", "committedDate": "2020-12-05T14:24:54Z", "type": "commit"}, {"oid": "4a973231cf0a1e6108cca9268cebd1b86dc61392", "url": "https://github.com/openhab/openhab-addons/commit/4a973231cf0a1e6108cca9268cebd1b86dc61392", "message": "Updated light intensity pattern\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-07T17:43:29Z", "type": "commit"}, {"oid": "eb02adf3ea4c748f4b3ec438ee5599ed52609bc3", "url": "https://github.com/openhab/openhab-addons/commit/eb02adf3ea4c748f4b3ec438ee5599ed52609bc3", "message": "Merge branch 'main' into gardena_3", "committedDate": "2020-12-07T17:44:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY0MzY3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r538643673", "bodyText": "Can you make this Nullable?", "author": "fwolter", "createdAt": "2020-12-08T17:36:59Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/discovery/GardenaDeviceDiscoveryService.java", "diffHunk": "@@ -41,18 +41,19 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * The {@link GardenaDeviceDiscoveryService} is used to discover devices that are connected to Gardena Smart Home.\n+ * The {@link GardenaDeviceDiscoveryService} is used to discover devices that are connected to Gardena smart system.\n  *\n  * @author Gerhard Riegler - Initial contribution\n  */\n+@NonNullByDefault\n public class GardenaDeviceDiscoveryService extends AbstractDiscoveryService\n         implements DiscoveryService, ThingHandlerService {\n \n     private final Logger logger = LoggerFactory.getLogger(GardenaDeviceDiscoveryService.class);\n-    private static final int DISCOVER_TIMEOUT_SECONDS = 30;\n+    private static final int DISCOVER_TIMEOUT_SECONDS = 5;\n \n     private @NonNullByDefault({}) GardenaAccountHandler accountHandler;\n-    private Future<?> scanFuture;\n+    private @NonNullByDefault({}) Future<?> scanFuture;", "originalCommit": "eb02adf3ea4c748f4b3ec438ee5599ed52609bc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY0NDM4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r538644389", "bodyText": "Can you make this Nullable?", "author": "fwolter", "createdAt": "2020-12-08T17:37:41Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/handler/GardenaAccountHandler.java", "diffHunk": "@@ -39,31 +37,31 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * The {@link GardenaAccountHandler} is the handler for a Gardena Smart Home access and connects it to the framework.\n+ * The {@link GardenaAccountHandler} is the handler for a Gardena smart system access and connects it to the framework.\n  *\n  * @author Gerhard Riegler - Initial contribution\n  */\n+@NonNullByDefault\n public class GardenaAccountHandler extends BaseBridgeHandler implements GardenaSmartEventListener {\n-\n     private final Logger logger = LoggerFactory.getLogger(GardenaAccountHandler.class);\n-    private static final long REINITIALIZE_DELAY_SECONDS = 10;\n+    private final static long REINITIALIZE_DELAY_SECONDS = 10;\n \n-    private GardenaDeviceDiscoveryService discoveryService;\n+    private @NonNullByDefault({}) GardenaDeviceDiscoveryService discoveryService;", "originalCommit": "eb02adf3ea4c748f4b3ec438ee5599ed52609bc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY0NTY2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r538645661", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be debug. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging\nThe log messages could be removed, as the status update is already logged by the framework.\nThe state change originated by updateStatus() is logged to events.log. Including the status detail message.", "author": "fwolter", "createdAt": "2020-12-08T17:38:47Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/handler/GardenaAccountHandler.java", "diffHunk": "@@ -142,21 +147,23 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n     @Override\n     public void onDeviceUpdated(Device device) {\n         for (ThingUID thingUID : UidUtils.getThingUIDs(device, getThing())) {\n-            Thing gardenaThing = getThing().getThing(thingUID);\n-            try {\n-                GardenaThingHandler gardenaThingHandler = (GardenaThingHandler) gardenaThing.getHandler();\n-                gardenaThingHandler.updateProperties(device);\n-                for (Channel channel : gardenaThing.getChannels()) {\n-                    gardenaThingHandler.updateChannel(channel.getUID());\n+            final Thing gardenaThing;\n+            final GardenaThingHandler gardenaThingHandler;\n+            if ((gardenaThing = getThing().getThing(thingUID)) != null\n+                    && (gardenaThingHandler = (GardenaThingHandler) gardenaThing.getHandler()) != null) {\n+                try {\n+                    gardenaThingHandler.updateProperties(device);\n+                    for (Channel channel : gardenaThing.getChannels()) {\n+                        gardenaThingHandler.updateChannel(channel.getUID());\n+                    }\n+                    gardenaThingHandler.updateStatus(device);\n+                } catch (GardenaException ex) {\n+                    logger.error(\"There is something wrong with your thing '{}', please check or recreate it: {}\",\n+                            gardenaThing.getUID(), ex.getMessage());\n+                    logger.debug(\"Gardena exception caught on device update.\", ex);\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, ex.getMessage());", "originalCommit": "eb02adf3ea4c748f4b3ec438ee5599ed52609bc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "52578f4b3f4f1c223821fca1dab3be05337ac9fd", "url": "https://github.com/openhab/openhab-addons/commit/52578f4b3f4f1c223821fca1dab3be05337ac9fd", "message": "Added nullables\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-09T18:08:32Z", "type": "commit"}, {"oid": "eff4b575d8a15120d46bbc6edb866b3e8fa92ddc", "url": "https://github.com/openhab/openhab-addons/commit/eff4b575d8a15120d46bbc6edb866b3e8fa92ddc", "message": "Optimized descriptions\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-09T18:15:19Z", "type": "commit"}, {"oid": "c359b205cd976b21743fac9409d172a68df7d97b", "url": "https://github.com/openhab/openhab-addons/commit/c359b205cd976b21743fac9409d172a68df7d97b", "message": "Fixed wording in description\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-09T18:17:41Z", "type": "commit"}, {"oid": "9b28b41fb250e2988035b9bc24ca14d2ea18e9f6", "url": "https://github.com/openhab/openhab-addons/commit/9b28b41fb250e2988035b9bc24ca14d2ea18e9f6", "message": "Label capitalization fixes\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-10T14:43:12Z", "type": "commit"}, {"oid": "dbae39d6a0ddc7501c62b155b974f79fa7ab28ac", "url": "https://github.com/openhab/openhab-addons/commit/dbae39d6a0ddc7501c62b155b974f79fa7ab28ac", "message": "Again some label capitalization fixes\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-10T16:02:47Z", "type": "commit"}, {"oid": "13b8c3efbdf377758b916770b16947949d37b3e9", "url": "https://github.com/openhab/openhab-addons/commit/13b8c3efbdf377758b916770b16947949d37b3e9", "message": "Hopefully fixed all checkstyle warnings\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-10T19:03:39Z", "type": "commit"}, {"oid": "01f7ff3d5a3a2bc41bfd5adabe9aa285024a3c43", "url": "https://github.com/openhab/openhab-addons/commit/01f7ff3d5a3a2bc41bfd5adabe9aa285024a3c43", "message": "Fixed label spelling\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-10T19:04:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY0OTYyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r540649621", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable static String substringBefore(@Nullable String str, String separator) {\n          \n          \n            \n                public static @Nullable String substringBefore(@Nullable String str, String separator) {", "author": "cpmeister", "createdAt": "2020-12-11T02:46:01Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/util/StringUtils.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Some String operations from commons lang.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StringUtils {\n+    /**\n+     * Gets the substring before the first occurrence of a separator.\n+     */\n+    public @Nullable static String substringBefore(@Nullable String str, String separator) {", "originalCommit": "01f7ff3d5a3a2bc41bfd5adabe9aa285024a3c43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY0OTY5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r540649691", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable static String substringBeforeLast(@Nullable String str, String separator) {\n          \n          \n            \n                public static @Nullable String substringBeforeLast(@Nullable String str, String separator) {", "author": "cpmeister", "createdAt": "2020-12-11T02:46:14Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/util/StringUtils.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Some String operations from commons lang.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StringUtils {\n+    /**\n+     * Gets the substring before the first occurrence of a separator.\n+     */\n+    public @Nullable static String substringBefore(@Nullable String str, String separator) {\n+        if (str != null && !str.isEmpty()) {\n+            int pos = str.indexOf(separator);\n+            return pos == -1 ? str : str.substring(0, pos);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * Gets the substring before the last occurrence of a separator.\n+     */\n+    public @Nullable static String substringBeforeLast(@Nullable String str, String separator) {", "originalCommit": "01f7ff3d5a3a2bc41bfd5adabe9aa285024a3c43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY0OTc1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r540649759", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable static String substringAfterLast(@Nullable String str, String separator) {\n          \n          \n            \n                public static @Nullable String substringAfterLast(@Nullable String str, String separator) {", "author": "cpmeister", "createdAt": "2020-12-11T02:46:27Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/util/StringUtils.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Some String operations from commons lang.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StringUtils {\n+    /**\n+     * Gets the substring before the first occurrence of a separator.\n+     */\n+    public @Nullable static String substringBefore(@Nullable String str, String separator) {\n+        if (str != null && !str.isEmpty()) {\n+            int pos = str.indexOf(separator);\n+            return pos == -1 ? str : str.substring(0, pos);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * Gets the substring before the last occurrence of a separator.\n+     */\n+    public @Nullable static String substringBeforeLast(@Nullable String str, String separator) {\n+        if (str != null && !str.isEmpty()) {\n+            int pos = str.lastIndexOf(separator);\n+            return pos == -1 ? str : str.substring(0, pos);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * Gets the substring after the last occurrence of a separator.\n+     */\n+    public @Nullable static String substringAfterLast(@Nullable String str, String separator) {", "originalCommit": "01f7ff3d5a3a2bc41bfd5adabe9aa285024a3c43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY1MDcyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r540650729", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable static <T> T getPropertyValue(@Nullable Object instance, String propertyPath, Class<T> resultClass)\n          \n          \n            \n                public static <T> @Nullable T getPropertyValue(@Nullable Object instance, String propertyPath, Class<T> resultClass)", "author": "cpmeister", "createdAt": "2020-12-11T02:49:15Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/util/PropertyUtils.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal.util;\n+\n+import java.lang.reflect.Field;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gardena.internal.exception.GardenaException;\n+\n+/**\n+ * Utility class to read nested properties.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PropertyUtils {\n+\n+    /**\n+     * Returns true if the property is null.\n+     */\n+    public static boolean isNull(@Nullable Object instance, String propertyPath) throws GardenaException {\n+        return getPropertyValue(instance, propertyPath, Object.class) == null;\n+    }\n+\n+    /**\n+     * Returns the property value from the object instance, nested properties are possible.\n+     */\n+    public @Nullable static <T> T getPropertyValue(@Nullable Object instance, String propertyPath, Class<T> resultClass)", "originalCommit": "01f7ff3d5a3a2bc41bfd5adabe9aa285024a3c43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY1MDgxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r540650818", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable static <T> T getPropertyValue(@Nullable Object instance, String[] properties,\n          \n          \n            \n                private static <T> @Nullable T getPropertyValue(@Nullable Object instance, String[] properties,", "author": "cpmeister", "createdAt": "2020-12-11T02:49:27Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/util/PropertyUtils.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal.util;\n+\n+import java.lang.reflect.Field;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gardena.internal.exception.GardenaException;\n+\n+/**\n+ * Utility class to read nested properties.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PropertyUtils {\n+\n+    /**\n+     * Returns true if the property is null.\n+     */\n+    public static boolean isNull(@Nullable Object instance, String propertyPath) throws GardenaException {\n+        return getPropertyValue(instance, propertyPath, Object.class) == null;\n+    }\n+\n+    /**\n+     * Returns the property value from the object instance, nested properties are possible.\n+     */\n+    public @Nullable static <T> T getPropertyValue(@Nullable Object instance, String propertyPath, Class<T> resultClass)\n+            throws GardenaException {\n+        String[] properties = propertyPath.split(\"\\\\.\");\n+        return getPropertyValue(instance, properties, resultClass, 0);\n+    }\n+\n+    /**\n+     * Iterates through the nested properties and returns the field value.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private @Nullable static <T> T getPropertyValue(@Nullable Object instance, String[] properties,", "originalCommit": "01f7ff3d5a3a2bc41bfd5adabe9aa285024a3c43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY1NDA0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r540654047", "bodyText": "Please turn this into a private method and call it using lambdas.", "author": "cpmeister", "createdAt": "2020-12-11T02:58:56Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/GardenaSmartWebSocket.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.*;\n+import org.eclipse.jetty.websocket.api.extensions.Frame;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.frames.PongFrame;\n+import org.openhab.binding.gardena.internal.config.GardenaConfig;\n+import org.openhab.binding.gardena.internal.model.dto.api.PostOAuth2Response;\n+import org.openhab.binding.gardena.internal.model.dto.api.WebSocketCreatedResponse;\n+import org.openhab.core.io.net.http.WebSocketFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GardenaSmartWebSocket} implements the websocket for receiving constant updates from the Gardena smart\n+ * system.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@NonNullByDefault\n+@WebSocket\n+public class GardenaSmartWebSocket {\n+    private final Logger logger = LoggerFactory.getLogger(GardenaSmartWebSocket.class);\n+    private final GardenaSmartWebSocketListener socketEventListener;\n+    private final long WEBSOCKET_IDLE_TIMEOUT = 300;\n+\n+    private WebSocketSession session;\n+    private WebSocketClient webSocketClient;\n+    private boolean closing;\n+    private Instant lastPong = Instant.now();\n+    private ScheduledExecutorService scheduler;\n+    private @Nullable ScheduledFuture<?> connectionTracker;\n+    private ByteBuffer pingPayload = ByteBuffer.wrap(\"ping\".getBytes());\n+    private @Nullable PostOAuth2Response token;\n+    private String socketId;\n+\n+    /**\n+     * Starts the websocket session.\n+     */\n+    public GardenaSmartWebSocket(GardenaSmartWebSocketListener socketEventListener,\n+            WebSocketCreatedResponse webSocketCreatedResponse, GardenaConfig config, ScheduledExecutorService scheduler,\n+            WebSocketFactory webSocketFactory, @Nullable PostOAuth2Response token, String socketId) throws Exception {\n+        this.socketEventListener = socketEventListener;\n+        this.scheduler = scheduler;\n+        this.token = token;\n+        this.socketId = socketId;\n+\n+        webSocketClient = webSocketFactory.createWebSocketClient(String.valueOf(this.getClass().hashCode()));\n+        webSocketClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n+        webSocketClient.setStopTimeout(3000);\n+        webSocketClient.setMaxIdleTimeout(150000);\n+        webSocketClient.start();\n+\n+        logger.debug(\"Connecting to Gardena Webservice ({})\", socketId);\n+        session = (WebSocketSession) webSocketClient\n+                .connect(this, new URI(webSocketCreatedResponse.data.attributes.url)).get();\n+        session.setStopTimeout(3000);\n+    }\n+\n+    /**\n+     * Stops the websocket session.\n+     */\n+    public synchronized void stop() {\n+        closing = true;\n+        final ScheduledFuture<?> connectionTracker = this.connectionTracker;\n+        if (connectionTracker != null) {\n+            connectionTracker.cancel(true);\n+        }\n+        if (isRunning()) {\n+            logger.debug(\"Closing Gardena Webservice client ({})\", socketId);\n+            try {\n+                session.close();\n+            } catch (Exception ex) {\n+                // ignore\n+            } finally {\n+                try {\n+                    webSocketClient.stop();\n+                } catch (Exception e) {\n+                    // ignore\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns true, if the websocket is running.\n+     */\n+    public synchronized boolean isRunning() {\n+        return session.isOpen();\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        closing = false;\n+        logger.debug(\"Connected to Gardena Webservice ({})\", socketId);\n+\n+        connectionTracker = scheduler.scheduleWithFixedDelay(new ConnectionTrackerThread(), 2, 2, TimeUnit.MINUTES);\n+    }\n+\n+    @OnWebSocketFrame\n+    public void onFrame(Frame pong) {\n+        if (pong instanceof PongFrame) {\n+            lastPong = Instant.now();\n+            logger.trace(\"Pong received ({})\", socketId);\n+        }\n+    }\n+\n+    @OnWebSocketClose\n+    public void onClose(int statusCode, String reason) {\n+        if (!closing) {\n+            logger.debug(\"Connection to Gardena Webservice was closed ({}): code: {}, reason: {}\", socketId, statusCode,\n+                    reason);\n+            socketEventListener.onWebSocketClose();\n+        }\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        if (!closing) {\n+            logger.warn(\"Gardena Webservice error ({}): {}, restarting\", socketId, cause.getMessage());\n+            logger.debug(\"{}\", cause.getMessage(), cause);\n+            socketEventListener.onWebSocketError();\n+        }\n+    }\n+\n+    @OnWebSocketMessage\n+    public void onMessage(String msg) {\n+        if (!closing) {\n+            logger.trace(\"<<< event ({}): {}\", socketId, msg);\n+            socketEventListener.onWebSocketMessage(msg);\n+        }\n+    }\n+\n+    /**\n+     * Sends a ping in regular interval to tell the Gardena smart system that the client is alive.\n+     */\n+    private class ConnectionTrackerThread implements Runnable {\n+\n+        @Override\n+        public void run() {", "originalCommit": "01f7ff3d5a3a2bc41bfd5adabe9aa285024a3c43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY1NTA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r540655069", "bodyText": "You have to keep track of the future returned here so you can cancel it in case the handler is disposed.", "author": "cpmeister", "createdAt": "2020-12-11T03:01:48Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/GardenaSmartImpl.java", "diffHunk": "@@ -12,562 +12,377 @@\n  */\n package org.openhab.binding.gardena.internal;\n \n-import java.util.Collection;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-\n-import org.apache.commons.lang.ObjectUtils;\n-import org.apache.commons.lang.StringUtils;\n+import java.util.*;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.jetty.client.HttpClient;\n-import org.eclipse.jetty.client.HttpResponseException;\n import org.eclipse.jetty.client.api.ContentResponse;\n import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.AbstractTypedContentProvider;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n import org.eclipse.jetty.client.util.StringContentProvider;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n-import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.eclipse.jetty.util.Fields;\n import org.openhab.binding.gardena.internal.config.GardenaConfig;\n-import org.openhab.binding.gardena.internal.config.GardenaConfigWrapper;\n import org.openhab.binding.gardena.internal.exception.GardenaDeviceNotFoundException;\n import org.openhab.binding.gardena.internal.exception.GardenaException;\n-import org.openhab.binding.gardena.internal.exception.GardenaUnauthorizedException;\n-import org.openhab.binding.gardena.internal.model.Ability;\n-import org.openhab.binding.gardena.internal.model.Device;\n-import org.openhab.binding.gardena.internal.model.Devices;\n-import org.openhab.binding.gardena.internal.model.Errors;\n-import org.openhab.binding.gardena.internal.model.Location;\n-import org.openhab.binding.gardena.internal.model.Locations;\n-import org.openhab.binding.gardena.internal.model.NoResult;\n-import org.openhab.binding.gardena.internal.model.Property;\n-import org.openhab.binding.gardena.internal.model.PropertyValue;\n-import org.openhab.binding.gardena.internal.model.Session;\n-import org.openhab.binding.gardena.internal.model.SessionWrapper;\n-import org.openhab.binding.gardena.internal.model.Setting;\n-import org.openhab.binding.gardena.internal.model.command.Command;\n-import org.openhab.binding.gardena.internal.model.command.MowerParkUntilFurtherNoticeCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerParkUntilNextTimerCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerStartOverrideTimerCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerStartResumeScheduleCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureAmbientTemperatureCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureLightCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureSoilHumidityCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureSoilTemperatureCommand;\n-import org.openhab.binding.gardena.internal.model.command.SettingCommand;\n-import org.openhab.binding.gardena.internal.model.command.SettingCommandWrapper;\n-import org.openhab.binding.gardena.internal.model.command.WateringCancelOverrideCommand;\n-import org.openhab.binding.gardena.internal.model.command.WateringManualOverrideCommand;\n-import org.openhab.binding.gardena.internal.model.deser.DateDeserializer;\n-import org.openhab.binding.gardena.internal.model.deser.PropertyValueDeserializer;\n-import org.openhab.binding.gardena.internal.model.property.BaseProperty;\n-import org.openhab.binding.gardena.internal.model.property.IrrigationControlWateringProperty;\n-import org.openhab.binding.gardena.internal.model.property.PropertyWrapper;\n-import org.openhab.binding.gardena.internal.model.property.StringProperty;\n+import org.openhab.binding.gardena.internal.model.DataItemDeserializer;\n+import org.openhab.binding.gardena.internal.model.dto.Device;\n+import org.openhab.binding.gardena.internal.model.dto.api.*;\n+import org.openhab.binding.gardena.internal.model.dto.command.GardenaCommand;\n+import org.openhab.binding.gardena.internal.model.dto.command.GardenaCommandRequest;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.io.net.http.WebSocketFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n \n /**\n- * {@link GardenaSmart} implementation to access Gardena Smart Home.\n+ * {@link GardenaSmart} implementation to access Gardena smart system.\n  *\n  * @author Gerhard Riegler - Initial contribution\n  */\n-public class GardenaSmartImpl implements GardenaSmart {\n+@NonNullByDefault\n+public class GardenaSmartImpl implements GardenaSmart, GardenaSmartWebSocketListener {\n     private final Logger logger = LoggerFactory.getLogger(GardenaSmartImpl.class);\n \n-    public static final String DEVICE_CATEGORY_PUMP = \"electronic_pressure_pump\";\n-    private static final String ABILITY_MOWER = \"mower\";\n-    private static final String ABILITY_OUTLET = \"outlet\";\n-    private static final String ABILITY_HUMIDITY = \"humidity\";\n-    private static final String ABILITY_LIGHT = \"light\";\n-    private static final String ABILITY_AMBIENT_TEMPERATURE = \"ambient_temperature\";\n-    private static final String ABILITY_SOIL_TEMPERATURE = \"soil_temperature\";\n-    private static final String ABILITY_POWER = \"power\";\n-    private static final String ABILITY_WATERING = \"watering\";\n-    private static final String ABILITY_MANUAL_WATERING = \"manual_watering\";\n-\n-    private static final String PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME = \"button_manual_override_time\";\n-    private static final String PROPERTY_POWER_TIMER = \"power_timer\";\n-    private static final String PROPERTY_WATERING_TIMER = \"watering_timer_\";\n-    private static final String PROPERTY_MANUAL_WATERING_TIMER = \"manual_watering_timer\";\n-\n-    private static final String DEVICE_CATEGORY_MOWER = \"mower\";\n-    private static final String DEVICE_CATEGORY_GATEWAY = \"gateway\";\n-\n-    private static final String DEFAULT_MOWER_DURATION = \"180\";\n-\n-    private static final String URL = \"https://smart.gardena.com\";\n-    private static final String URL_LOGIN = URL + \"/v1/auth/token\";\n-    private static final String URL_LOCATIONS = URL + \"/v1/locations/?user_id=\";\n-    private static final String URL_DEVICES = URL + \"/v1/devices/?locationId=\";\n-    private static final String URL_COMMAND = URL + \"/v1/devices/%s/abilities/%s/command?locationId=%s\";\n-    private static final String URL_PROPERTY = URL + \"/v1/devices/%s/abilities/%s/properties/%s?locationId=%s\";\n-    private static final String URL_SETTING = URL + \"/v1/devices/%s/settings/%s?locationId=%s\";\n-\n-    private Gson gson = new GsonBuilder().registerTypeAdapter(Date.class, new DateDeserializer())\n-            .registerTypeAdapter(PropertyValue.class, new PropertyValueDeserializer()).create();\n-    private HttpClient httpClient;\n+    private Gson gson = new GsonBuilder().registerTypeAdapter(DataItem.class, new DataItemDeserializer()).create();\n \n-    private String mowerDuration = DEFAULT_MOWER_DURATION;\n-    private Session session;\n-    private GardenaConfig config;\n-    private String id;\n+    private static final String URL_API_HUSQUARNA = \"https://api.authentication.husqvarnagroup.dev/v1\";\n+    private static final String URL_API_GARDENA = \"https://api.smart.gardena.dev/v1\";\n+    private static final String URL_API_TOKEN = URL_API_HUSQUARNA + \"/oauth2/token\";\n+    private static final String URL_API_WEBSOCKET = URL_API_GARDENA + \"/websocket\";\n+    private static final String URL_API_LOCATIONS = URL_API_GARDENA + \"/locations\";\n+    private static final String URL_API_COMMAND = URL_API_GARDENA + \"/command\";\n \n+    private String id;\n+    private GardenaConfig config;\n     private ScheduledExecutorService scheduler;\n-    private ScheduledFuture<?> refreshThreadFuture;\n-    private RefreshDevicesThread refreshDevicesThread = new RefreshDevicesThread();\n \n+    private Map<String, Device> allDevicesById = new HashMap<>();\n+    private LocationsResponse locationsResponse;\n     private GardenaSmartEventListener eventListener;\n \n-    private Map<String, Device> allDevicesById = new HashMap<>();\n-    private Set<Location> allLocations = new HashSet<>();\n+    private HttpClient httpClient;\n+    private List<GardenaSmartWebSocket> webSockets = new ArrayList<>();\n+    private @Nullable PostOAuth2Response token;\n+    private boolean initialized = false;\n+    private WebSocketFactory webSocketFactory;\n \n-    @Override\n-    public void init(String id, GardenaConfig config, GardenaSmartEventListener eventListener,\n-            ScheduledExecutorService scheduler) throws GardenaException {\n+    private Set<Device> devicesToNotify = Collections.synchronizedSet(new HashSet<>());\n+    private @Nullable ScheduledFuture<?> deviceToNotifyFuture;\n+\n+    public GardenaSmartImpl(String id, GardenaConfig config, GardenaSmartEventListener eventListener,\n+            ScheduledExecutorService scheduler, HttpClientFactory httpClientFactory, WebSocketFactory webSocketFactory)\n+            throws GardenaException {\n         this.id = id;\n         this.config = config;\n         this.eventListener = eventListener;\n         this.scheduler = scheduler;\n+        this.webSocketFactory = webSocketFactory;\n \n-        if (!config.isValid()) {\n-            throw new GardenaException(\"Invalid config, no email or password specified\");\n-        }\n-\n-        httpClient = new HttpClient(new SslContextFactory(true));\n-        httpClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n-\n+        logger.debug(\"Starting GardenaSmart\");\n         try {\n+            httpClient = httpClientFactory.createHttpClient(id);\n+            httpClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n+            httpClient.setIdleTimeout(httpClient.getConnectTimeout());\n             httpClient.start();\n-        } catch (Exception ex) {\n-            throw new GardenaException(ex.getMessage(), ex);\n-        }\n \n-        loadAllDevices();\n-    }\n+            // initially load access token\n+            verifyToken();\n+            locationsResponse = loadLocations();\n \n-    @Override\n-    public void dispose() {\n-        stopRefreshThread(true);\n-        if (httpClient != null) {\n-            try {\n-                httpClient.stop();\n-            } catch (Exception e) {\n-                // ignore\n+            // assemble devices\n+            for (LocationDataItem location : locationsResponse.data) {\n+                LocationResponse locationResponse = loadLocation(location.id);\n+                if (locationResponse.included != null) {\n+                    for (DataItem<?> dataItem : locationResponse.included) {\n+                        handleDataItem(dataItem);\n+                    }\n+                }\n+            }\n+\n+            for (Device device : allDevicesById.values()) {\n+                device.evaluateDeviceType();\n             }\n-            httpClient.destroy();\n+\n+            startWebsockets();\n+            initialized = true;\n+        } catch (Exception ex) {\n+            throw new GardenaException(ex.getMessage(), ex);\n         }\n-        allLocations.clear();\n-        allDevicesById.clear();\n     }\n \n     /**\n-     * Schedules the device refresh thread.\n+     * Starts the websockets for each location.\n      */\n-    private void startRefreshThread() {\n-        refreshThreadFuture = scheduler.scheduleWithFixedDelay(refreshDevicesThread, 6, config.getRefresh(),\n-                TimeUnit.SECONDS);\n+    private void startWebsockets() throws Exception {\n+        for (LocationDataItem location : locationsResponse.data) {\n+            WebSocketCreatedResponse webSocketCreatedResponse = getWebsocketInfo(location.id);\n+            String socketId = id + \"-\" + location.attributes.name;\n+            webSockets.add(new GardenaSmartWebSocket(this, webSocketCreatedResponse, config, scheduler,\n+                    webSocketFactory, token, socketId));\n+        }\n     }\n \n     /**\n-     * Stops the device refresh thread.\n+     * Stops all websockets.\n      */\n-    private void stopRefreshThread(boolean force) {\n-        if (refreshThreadFuture != null) {\n-            refreshThreadFuture.cancel(force);\n-        }\n-    }\n-\n-    @Override\n-    public String getId() {\n-        return id;\n-    }\n-\n-    @Override\n-    public Set<Location> getLocations() {\n-        return allLocations;\n-    }\n-\n-    @Override\n-    public Device getDevice(String deviceId) throws GardenaException {\n-        Device device = allDevicesById.get(deviceId);\n-        if (device == null) {\n-            throw new GardenaDeviceNotFoundException(\n-                    String.format(\"Device with id '%s' not found on gateway '%s'\", deviceId, id));\n-        }\n-        return device;\n-    }\n-\n-    @Override\n-    public void loadAllDevices() throws GardenaException {\n-        stopRefreshThread(false);\n-        try {\n-            allLocations.clear();\n-            allDevicesById.clear();\n-\n-            verifySession();\n-            Locations locations = executeRequest(HttpMethod.GET,\n-                    URL_LOCATIONS + session.getSessionAttributes().getUserId(), null, Locations.class);\n-\n-            for (Location location : locations.getLocations()) {\n-                allLocations.add(location);\n-                Devices devices = loadDevices(location);\n-                for (Device device : devices.getDevices()) {\n-                    if (DEVICE_CATEGORY_GATEWAY.equals(device.getCategory())) {\n-                        location.getDeviceIds().remove(device.getId());\n-                    } else {\n-                        allDevicesById.put(device.getId(), device);\n-                    }\n-                }\n-            }\n-        } finally {\n-            startRefreshThread();\n+    private void stopWebsockets() {\n+        for (GardenaSmartWebSocket webSocket : webSockets) {\n+            webSocket.stop();\n         }\n+        webSockets.clear();\n     }\n \n     /**\n-     * Loads all devices for the location, adds virtual properties for commands.\n+     * Communicates with Gardena smart home system and parses the result.\n      */\n-    private Devices loadDevices(Location location) throws GardenaException {\n-        Devices devices = executeRequest(HttpMethod.GET, URL_DEVICES + location.getId(), null, Devices.class);\n-        for (Device device : devices.getDevices()) {\n-            device.setLocation(location);\n-            for (Ability ability : device.getAbilities()) {\n-                ability.setDevice(device);\n-                for (Property property : ability.getProperties()) {\n-                    property.setAbility(ability);\n-\n-                    if (device.getCategory().equals(DEVICE_CATEGORY_PUMP)) {\n-                        if (property.getName().equals(PROPERTY_MANUAL_WATERING_TIMER)) {\n-                            Integer duration = getIntegerValue(property.getValueAsString());\n-                            if (duration == null) {\n-                                duration = 0;\n-                            }\n-                            property.setValue(new PropertyValue(String.valueOf(duration / 60)));\n-                        }\n-                    }\n+    private <T> T executeRequest(HttpMethod method, String url, @Nullable Object content, @Nullable Class<T> result)\n+            throws GardenaException {\n+        try {\n+            AbstractTypedContentProvider contentProvider = null;\n+            String contentType = \"application/vnd.api+json\";\n+            if (content != null) {\n+                if (content instanceof Fields) {\n+                    contentProvider = new FormContentProvider((Fields) content);\n+                    contentType = \"application/x-www-form-urlencoded\";\n+                } else {\n+                    contentProvider = new StringContentProvider(gson.toJson(content));\n                 }\n             }\n-            for (Setting setting : device.getSettings()) {\n-                setting.setDevice(device);\n+\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\">>> {} {}, data: {}\", method, url, content == null ? null : gson.toJson(content));\n             }\n \n-            if (DEVICE_CATEGORY_MOWER.equals(device.getCategory())) {\n-                Ability mower = device.getAbility(ABILITY_MOWER);\n-                mower.addProperty(new Property(GardenaSmartCommandName.PARK_UNTIL_NEXT_TIMER, \"false\"));\n-                mower.addProperty(new Property(GardenaSmartCommandName.PARK_UNTIL_FURTHER_NOTICE, \"false\"));\n-                mower.addProperty(new Property(GardenaSmartCommandName.START_RESUME_SCHEDULE, \"false\"));\n-                mower.addProperty(new Property(GardenaSmartCommandName.START_OVERRIDE_TIMER, \"false\"));\n+            Request request = httpClient.newRequest(url).method(method).header(HttpHeader.CONTENT_TYPE, contentType)\n+                    .header(HttpHeader.ACCEPT, \"application/vnd.api+json\").header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n \n-                mower.addProperty(new Property(GardenaSmartCommandName.DURATION_PROPERTY, mowerDuration));\n+            if (!URL_API_TOKEN.equals(url)) {\n+                verifyToken();\n+                final PostOAuth2Response token = this.token;\n+                if (token != null) {\n+                    request.header(\"Authorization\", token.tokenType + \" \" + token.accessToken);\n+                    request.header(\"Authorization-provider\", token.provider);\n+                }\n+                request.header(\"X-Api-Key\", config.getApiKey());\n             }\n-        }\n-        return devices;\n-    }\n \n-    @Override\n-    public void sendCommand(Device device, GardenaSmartCommandName commandName, Object value) throws GardenaException {\n-        Ability ability = null;\n-        Command command = null;\n-\n-        switch (commandName) {\n-            case PARK_UNTIL_NEXT_TIMER:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerParkUntilNextTimerCommand();\n-                break;\n-            case PARK_UNTIL_FURTHER_NOTICE:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerParkUntilFurtherNoticeCommand();\n-                break;\n-            case START_RESUME_SCHEDULE:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerStartResumeScheduleCommand();\n-                break;\n-            case START_OVERRIDE_TIMER:\n-                ability = device.getAbility(ABILITY_MOWER);\n-                command = new MowerStartOverrideTimerCommand(mowerDuration);\n-                break;\n-            case DURATION_PROPERTY:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                }\n-                mowerDuration = ObjectUtils.toString(value);\n-                return;\n-            case MEASURE_AMBIENT_TEMPERATURE:\n-                ability = device.getAbility(ABILITY_AMBIENT_TEMPERATURE);\n-                command = new SensorMeasureAmbientTemperatureCommand();\n-                break;\n-            case MEASURE_LIGHT:\n-                ability = device.getAbility(ABILITY_LIGHT);\n-                command = new SensorMeasureLightCommand();\n-                break;\n-            case MEASURE_SOIL_HUMIDITY:\n-                ability = device.getAbility(ABILITY_HUMIDITY);\n-                command = new SensorMeasureSoilHumidityCommand();\n-                break;\n-            case MEASURE_SOIL_TEMPERATURE:\n-                ability = device.getAbility(ABILITY_SOIL_TEMPERATURE);\n-                command = new SensorMeasureSoilTemperatureCommand();\n-                break;\n-            case OUTLET_MANUAL_OVERRIDE_TIME:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                }\n-                StringProperty prop = new StringProperty(PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME,\n-                        ObjectUtils.toString(value));\n-\n-                executeSetProperty(device, ABILITY_OUTLET, PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME, prop);\n-                break;\n-            case OUTLET_VALVE:\n-                ability = device.getAbility(ABILITY_OUTLET);\n-                if (value != null && value == Boolean.TRUE) {\n-                    String wateringDuration = device.getAbility(ABILITY_OUTLET)\n-                            .getProperty(PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME).getValueAsString();\n-                    command = new WateringManualOverrideCommand(wateringDuration);\n-                } else {\n-                    command = new WateringCancelOverrideCommand();\n-                }\n-                break;\n-            case POWER_TIMER:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                }\n-                prop = new StringProperty(PROPERTY_POWER_TIMER, ObjectUtils.toString(value));\n-                executeSetProperty(device, ABILITY_POWER, PROPERTY_POWER_TIMER, prop);\n-                break;\n-            case WATERING_TIMER_VALVE_1:\n-            case WATERING_TIMER_VALVE_2:\n-            case WATERING_TIMER_VALVE_3:\n-            case WATERING_TIMER_VALVE_4:\n-            case WATERING_TIMER_VALVE_5:\n-            case WATERING_TIMER_VALVE_6:\n-                if (value == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a value\");\n-                } else if (!(value instanceof Integer)) {\n-                    throw new GardenaException(\"Watering duration value '\" + value + \"' not a number\");\n-                }\n-                int valveId = Integer.parseInt(StringUtils.right(commandName.toString(), 1));\n-                String wateringTimerProperty = PROPERTY_WATERING_TIMER + valveId;\n-                IrrigationControlWateringProperty irrigationProp = new IrrigationControlWateringProperty(\n-                        wateringTimerProperty, (Integer) value, valveId);\n-                executeSetProperty(device, ABILITY_WATERING, wateringTimerProperty, irrigationProp);\n-                break;\n-            case PUMP_MANUAL_WATERING_TIMER:\n-                Integer duration = getIntegerValue(value);\n-                if (duration == null) {\n-                    throw new GardenaException(\"Command '\" + commandName + \"' requires a number value\");\n-                }\n-                prop = new StringProperty(PROPERTY_MANUAL_WATERING_TIMER, String.valueOf(duration * 60));\n+            request.content(contentProvider);\n+            ContentResponse contentResponse = request.send();\n+            int status = contentResponse.getStatus();\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(\"<<< status:{}, {}\", status, contentResponse.getContentAsString());\n+            }\n \n-                executeSetProperty(device, ABILITY_MANUAL_WATERING, PROPERTY_MANUAL_WATERING_TIMER, prop);\n-                break;\n-            default:\n-                throw new GardenaException(\"Unknown command \" + commandName);\n-        }\n+            if (status != 200 && status != 204 && status != 201 && status != 202) {\n+                throw new GardenaException(String.format(\"Error %s %s, %s\", status, contentResponse.getReason(),\n+                        contentResponse.getContentAsString()));\n+            }\n \n-        if (command != null) {\n-            stopRefreshThread(false);\n-            executeRequest(HttpMethod.POST, getCommandUrl(device, ability), command, NoResult.class);\n-            startRefreshThread();\n+            if (result == null) {\n+                return (T) null;\n+            }\n+            return (T) gson.fromJson(contentResponse.getContentAsString(), result);\n+        } catch (InterruptedException | TimeoutException | ExecutionException ex) {\n+            throw new GardenaException(ex.getMessage(), ex);\n         }\n     }\n \n-    private Integer getIntegerValue(Object value) {\n-        try {\n-            return Integer.valueOf(ObjectUtils.toString(value));\n-        } catch (NumberFormatException ex) {\n-            return null;\n+    /**\n+     * Creates or refreshes the access token for the Gardena smart system.\n+     */\n+    private synchronized void verifyToken() throws GardenaException {\n+        Fields fields = new Fields();\n+        fields.add(\"client_id\", config.getApiKey());\n+\n+        PostOAuth2Response token = this.token;\n+        if (token == null || token.isRefreshTokenExpired()) {\n+            // new token\n+            logger.debug(\"Gardena API login using password, reason: {}\",\n+                    token == null ? \"no token available\" : \"refresh token expired\");\n+            fields.add(\"grant_type\", \"password\");\n+            fields.add(\"username\", config.getEmail());\n+            fields.add(\"password\", config.getPassword());\n+            token = executeRequest(HttpMethod.POST, URL_API_TOKEN, fields, PostOAuth2Response.class);\n+            token.postProcess();\n+            this.token = token;\n+        } else if (token.isAccessTokenExpired()) {\n+            // refresh token\n+            logger.debug(\"Gardena API login using refreshToken, reason: access token expired\");\n+            fields.add(\"grant_type\", \"refresh_token\");\n+            fields.add(\"refresh_token\", token.refreshToken);\n+            try {\n+                PostOAuth2Response tempToken = executeRequest(HttpMethod.POST, URL_API_TOKEN, fields,\n+                        PostOAuth2Response.class);\n+                token.accessToken = tempToken.accessToken;\n+                token.expiresIn = tempToken.expiresIn;\n+                token.postProcess();\n+                this.token = token;\n+            } catch (GardenaException ex) {\n+                // refresh token issue\n+                this.token = null;\n+                verifyToken();\n+            }\n+        } else {\n+            logger.debug(\"Gardena API token valid\");\n         }\n+        logger.debug(\"{}\", token.toString());\n     }\n \n     /**\n-     * Sends the new property value for the ability.\n+     * Loads all locations.\n      */\n-    private void executeSetProperty(Device device, String ability, String property, BaseProperty value)\n-            throws GardenaException {\n-        String propertyUrl = String.format(URL_PROPERTY, device.getId(), ability, property,\n-                device.getLocation().getId());\n-        stopRefreshThread(false);\n-        executeRequest(HttpMethod.PUT, propertyUrl, new PropertyWrapper(value), NoResult.class);\n-        device.getAbility(ability).getProperty(property).setValue(new PropertyValue(value.getValue()));\n-        startRefreshThread();\n-    }\n-\n-    @Override\n-    public void sendSetting(Setting setting, Object value) throws GardenaException {\n-        SettingCommand settingCommand = new SettingCommand(setting.getName());\n-        settingCommand.setDeviceId(setting.getDevice().getId());\n-        settingCommand.setValue(value);\n-\n-        stopRefreshThread(false);\n-        executeRequest(HttpMethod.PUT, getSettingUrl(setting), new SettingCommandWrapper(settingCommand),\n-                NoResult.class);\n-        startRefreshThread();\n+    private LocationsResponse loadLocations() throws GardenaException {\n+        return executeRequest(HttpMethod.GET, URL_API_LOCATIONS, null, LocationsResponse.class);\n     }\n \n     /**\n-     * Returns the command url.\n+     * Loads all devices for a given location.\n      */\n-    private String getCommandUrl(Device device, Ability ability) throws GardenaException {\n-        return String.format(URL_COMMAND, device.getId(), ability.getName(), device.getLocation().getId());\n+    private LocationResponse loadLocation(String locationId) throws GardenaException {\n+        return executeRequest(HttpMethod.GET, URL_API_LOCATIONS + \"/\" + locationId, null, LocationResponse.class);\n     }\n \n     /**\n-     * Returns the settings url.\n+     * Returns the websocket url for a given location.\n      */\n-    private String getSettingUrl(Setting setting) {\n-        Device device = setting.getDevice();\n-        return String.format(URL_SETTING, device.getId(), setting.getId(), device.getLocation().getId());\n+    private WebSocketCreatedResponse getWebsocketInfo(String locationId) throws GardenaException {\n+        return executeRequest(HttpMethod.POST, URL_API_WEBSOCKET, new CreateWebSocketRequest(locationId),\n+                WebSocketCreatedResponse.class);\n     }\n \n     /**\n-     * Communicates with Gardena Smart Home and parses the result.\n+     * Stops the client.\n      */\n-    private synchronized <T> T executeRequest(HttpMethod method, String url, Object contentObject, Class<T> result)\n-            throws GardenaException {\n+    public void dispose() {\n+        logger.debug(\"Disposing GardenaSmart\");\n+        final ScheduledFuture<?> deviceToNotifyFuture = this.deviceToNotifyFuture;\n+        if (deviceToNotifyFuture != null) {\n+            deviceToNotifyFuture.cancel(true);\n+        }\n+        stopWebsockets();\n         try {\n-            if (logger.isTraceEnabled()) {\n-                logger.trace(\"{} request:  {}\", method, url);\n-                if (contentObject != null) {\n-                    logger.trace(\"{} data   :  {}\", method, gson.toJson(contentObject));\n-                }\n-            }\n-\n-            Request request = httpClient.newRequest(url).method(method)\n-                    .timeout(config.getConnectionTimeout(), TimeUnit.SECONDS)\n-                    .idleTimeout(config.getConnectionTimeout(), TimeUnit.SECONDS)\n-                    .header(HttpHeader.CONTENT_TYPE, \"application/json\").header(HttpHeader.ACCEPT, \"application/json\")\n-                    .header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\n-\n-            if (contentObject != null) {\n-                StringContentProvider content = new StringContentProvider(gson.toJson(contentObject));\n-                request.content(content);\n-            }\n-\n-            if (!result.equals(SessionWrapper.class)) {\n-                verifySession();\n-                request.header(\"authorization\", \"Bearer \" + session.getToken());\n-                request.header(\"authorization-provider\", session.getSessionAttributes().getProvider());\n-            }\n-\n-            ContentResponse contentResponse = request.send();\n-            int status = contentResponse.getStatus();\n-            if (logger.isTraceEnabled()) {\n-                logger.trace(\"Status  : {}\", status);\n-                logger.trace(\"Response: {}\", contentResponse.getContentAsString());\n-            }\n-\n-            if (status == 500) {\n-                throw new GardenaException(\n-                        gson.fromJson(contentResponse.getContentAsString(), Errors.class).toString());\n-            } else if (status != 200 && status != 204 && status != 201) {\n-                throw new GardenaException(String.format(\"Error %s %s\", status, contentResponse.getReason()));\n-            }\n-\n-            if (result == NoResult.class) {\n-                return null;\n-            }\n-\n-            return gson.fromJson(contentResponse.getContentAsString(), result);\n-        } catch (ExecutionException ex) {\n-            Throwable cause = ex.getCause();\n-            if (cause instanceof HttpResponseException) {\n-                HttpResponseException responseException = (HttpResponseException) ex.getCause();\n-                int status = responseException.getResponse().getStatus();\n-                if (status == 401) {\n-                    throw new GardenaUnauthorizedException(ex.getCause());\n-                }\n-            }\n-            throw new GardenaException(ex.getMessage(), ex);\n-        } catch (Exception ex) {\n-            throw new GardenaException(ex.getMessage(), ex);\n+            httpClient.stop();\n+        } catch (Exception e) {\n+            // ignore\n         }\n+        httpClient.destroy();\n+        locationsResponse = new LocationsResponse();\n+        allDevicesById.clear();\n+        initialized = false;\n     }\n \n     /**\n-     * Verifies the Gardena Smart Home session and reconnects if necessary.\n+     * Restarts all websockets.\n      */\n-    private void verifySession() throws GardenaException {\n-        if (session == null\n-                || session.getCreated() + (config.getSessionTimeout() * 60000) <= System.currentTimeMillis()) {\n-            logger.trace(\"(Re)logging in to Gardena Smart Home\");\n-            session = executeRequest(HttpMethod.POST, URL_LOGIN, new GardenaConfigWrapper(config), SessionWrapper.class)\n-                    .getSession();\n+    @Override\n+    public synchronized void restartWebsockets() {\n+        logger.debug(\"Restarting GardenaSmart Webservice\");\n+        stopWebsockets();\n+        try {\n+            startWebsockets();\n+        } catch (Exception ex) {\n+            logger.warn(\"Restarting GardenaSmart Webservice failed: {}, restarting binding\", ex.getMessage());\n+            eventListener.onError();\n         }\n     }\n \n     /**\n-     * Thread which refreshes the data from Gardena Smart Home.\n+     * Sets the dataItem from the websocket event into the correct device.\n      */\n-    private class RefreshDevicesThread implements Runnable {\n-        private boolean connectionLost = false;\n-\n-        @Override\n-        public void run() {\n-            try {\n-                logger.debug(\"Refreshing gardena device data\");\n-                final Map<String, Device> newDevicesById = new HashMap<>();\n-\n-                for (Location location : allLocations) {\n-                    Devices devices = loadDevices(location);\n-                    for (Device device : devices.getDevices()) {\n-                        if (DEVICE_CATEGORY_GATEWAY.equals(device.getCategory())) {\n-                            location.getDeviceIds().remove(device.getId());\n-                        } else {\n-                            newDevicesById.put(device.getId(), device);\n+    private void handleDataItem(final DataItem<?> dataItem) throws GardenaException {\n+        final String deviceId = dataItem.getDeviceId();\n+        Device device = allDevicesById.get(deviceId);\n+        if (device == null && !(dataItem instanceof LocationDataItem)) {\n+            device = new Device(deviceId);\n+            allDevicesById.put(device.id, device);\n+\n+            if (initialized) {\n+                scheduler.schedule(() -> {", "originalCommit": "01f7ff3d5a3a2bc41bfd5adabe9aa285024a3c43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3903836d6cbdffeca01c723c25b098e94c844139", "url": "https://github.com/openhab/openhab-addons/commit/3903836d6cbdffeca01c723c25b098e94c844139", "message": "Optimized method signature\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-11T17:26:31Z", "type": "commit"}, {"oid": "252e7089e56ed1019ffe1080662a4a43b15be7d6", "url": "https://github.com/openhab/openhab-addons/commit/252e7089e56ed1019ffe1080662a4a43b15be7d6", "message": "Fixed binding name\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-11T17:26:45Z", "type": "commit"}, {"oid": "e2ece239ebcbdf3120a8dbc1a6d35e5c488ea450", "url": "https://github.com/openhab/openhab-addons/commit/e2ece239ebcbdf3120a8dbc1a6d35e5c488ea450", "message": "Fixed disposing new device schedule\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-11T17:34:18Z", "type": "commit"}, {"oid": "b409d15f2f1a250218ea6bfdbace50888428afb5", "url": "https://github.com/openhab/openhab-addons/commit/b409d15f2f1a250218ea6bfdbace50888428afb5", "message": "Converted ConnectionTrackerThread to private method\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-11T17:45:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNjMyNg==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r541226326", "bodyText": "I'm not sure how safe the synchronized behavior is when doing iteration. I think it would be much safe here to use one of the concurrent implementations instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Set<Device> devicesToNotify = Collections.synchronizedSet(new HashSet<>());\n          \n          \n            \n                private Set<Device> devicesToNotify = ConcurrentHashMap.newKeySet();", "author": "cpmeister", "createdAt": "2020-12-11T20:00:41Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/GardenaSmartImpl.java", "diffHunk": "@@ -12,562 +12,384 @@\n  */\n package org.openhab.binding.gardena.internal;\n \n-import java.util.Collection;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Collectors;\n-\n-import org.apache.commons.lang.ObjectUtils;\n-import org.apache.commons.lang.StringUtils;\n+import java.util.*;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.jetty.client.HttpClient;\n-import org.eclipse.jetty.client.HttpResponseException;\n import org.eclipse.jetty.client.api.ContentResponse;\n import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.AbstractTypedContentProvider;\n+import org.eclipse.jetty.client.util.FormContentProvider;\n import org.eclipse.jetty.client.util.StringContentProvider;\n import org.eclipse.jetty.http.HttpHeader;\n import org.eclipse.jetty.http.HttpMethod;\n-import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.eclipse.jetty.util.Fields;\n import org.openhab.binding.gardena.internal.config.GardenaConfig;\n-import org.openhab.binding.gardena.internal.config.GardenaConfigWrapper;\n import org.openhab.binding.gardena.internal.exception.GardenaDeviceNotFoundException;\n import org.openhab.binding.gardena.internal.exception.GardenaException;\n-import org.openhab.binding.gardena.internal.exception.GardenaUnauthorizedException;\n-import org.openhab.binding.gardena.internal.model.Ability;\n-import org.openhab.binding.gardena.internal.model.Device;\n-import org.openhab.binding.gardena.internal.model.Devices;\n-import org.openhab.binding.gardena.internal.model.Errors;\n-import org.openhab.binding.gardena.internal.model.Location;\n-import org.openhab.binding.gardena.internal.model.Locations;\n-import org.openhab.binding.gardena.internal.model.NoResult;\n-import org.openhab.binding.gardena.internal.model.Property;\n-import org.openhab.binding.gardena.internal.model.PropertyValue;\n-import org.openhab.binding.gardena.internal.model.Session;\n-import org.openhab.binding.gardena.internal.model.SessionWrapper;\n-import org.openhab.binding.gardena.internal.model.Setting;\n-import org.openhab.binding.gardena.internal.model.command.Command;\n-import org.openhab.binding.gardena.internal.model.command.MowerParkUntilFurtherNoticeCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerParkUntilNextTimerCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerStartOverrideTimerCommand;\n-import org.openhab.binding.gardena.internal.model.command.MowerStartResumeScheduleCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureAmbientTemperatureCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureLightCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureSoilHumidityCommand;\n-import org.openhab.binding.gardena.internal.model.command.SensorMeasureSoilTemperatureCommand;\n-import org.openhab.binding.gardena.internal.model.command.SettingCommand;\n-import org.openhab.binding.gardena.internal.model.command.SettingCommandWrapper;\n-import org.openhab.binding.gardena.internal.model.command.WateringCancelOverrideCommand;\n-import org.openhab.binding.gardena.internal.model.command.WateringManualOverrideCommand;\n-import org.openhab.binding.gardena.internal.model.deser.DateDeserializer;\n-import org.openhab.binding.gardena.internal.model.deser.PropertyValueDeserializer;\n-import org.openhab.binding.gardena.internal.model.property.BaseProperty;\n-import org.openhab.binding.gardena.internal.model.property.IrrigationControlWateringProperty;\n-import org.openhab.binding.gardena.internal.model.property.PropertyWrapper;\n-import org.openhab.binding.gardena.internal.model.property.StringProperty;\n+import org.openhab.binding.gardena.internal.model.DataItemDeserializer;\n+import org.openhab.binding.gardena.internal.model.dto.Device;\n+import org.openhab.binding.gardena.internal.model.dto.api.*;\n+import org.openhab.binding.gardena.internal.model.dto.command.GardenaCommand;\n+import org.openhab.binding.gardena.internal.model.dto.command.GardenaCommandRequest;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.io.net.http.WebSocketFactory;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonSyntaxException;\n \n /**\n- * {@link GardenaSmart} implementation to access Gardena Smart Home.\n+ * {@link GardenaSmart} implementation to access Gardena smart system.\n  *\n  * @author Gerhard Riegler - Initial contribution\n  */\n-public class GardenaSmartImpl implements GardenaSmart {\n+@NonNullByDefault\n+public class GardenaSmartImpl implements GardenaSmart, GardenaSmartWebSocketListener {\n     private final Logger logger = LoggerFactory.getLogger(GardenaSmartImpl.class);\n \n-    public static final String DEVICE_CATEGORY_PUMP = \"electronic_pressure_pump\";\n-    private static final String ABILITY_MOWER = \"mower\";\n-    private static final String ABILITY_OUTLET = \"outlet\";\n-    private static final String ABILITY_HUMIDITY = \"humidity\";\n-    private static final String ABILITY_LIGHT = \"light\";\n-    private static final String ABILITY_AMBIENT_TEMPERATURE = \"ambient_temperature\";\n-    private static final String ABILITY_SOIL_TEMPERATURE = \"soil_temperature\";\n-    private static final String ABILITY_POWER = \"power\";\n-    private static final String ABILITY_WATERING = \"watering\";\n-    private static final String ABILITY_MANUAL_WATERING = \"manual_watering\";\n-\n-    private static final String PROPERTY_BUTTON_MANUAL_OVERRIDE_TIME = \"button_manual_override_time\";\n-    private static final String PROPERTY_POWER_TIMER = \"power_timer\";\n-    private static final String PROPERTY_WATERING_TIMER = \"watering_timer_\";\n-    private static final String PROPERTY_MANUAL_WATERING_TIMER = \"manual_watering_timer\";\n-\n-    private static final String DEVICE_CATEGORY_MOWER = \"mower\";\n-    private static final String DEVICE_CATEGORY_GATEWAY = \"gateway\";\n-\n-    private static final String DEFAULT_MOWER_DURATION = \"180\";\n-\n-    private static final String URL = \"https://smart.gardena.com\";\n-    private static final String URL_LOGIN = URL + \"/v1/auth/token\";\n-    private static final String URL_LOCATIONS = URL + \"/v1/locations/?user_id=\";\n-    private static final String URL_DEVICES = URL + \"/v1/devices/?locationId=\";\n-    private static final String URL_COMMAND = URL + \"/v1/devices/%s/abilities/%s/command?locationId=%s\";\n-    private static final String URL_PROPERTY = URL + \"/v1/devices/%s/abilities/%s/properties/%s?locationId=%s\";\n-    private static final String URL_SETTING = URL + \"/v1/devices/%s/settings/%s?locationId=%s\";\n-\n-    private Gson gson = new GsonBuilder().registerTypeAdapter(Date.class, new DateDeserializer())\n-            .registerTypeAdapter(PropertyValue.class, new PropertyValueDeserializer()).create();\n-    private HttpClient httpClient;\n+    private Gson gson = new GsonBuilder().registerTypeAdapter(DataItem.class, new DataItemDeserializer()).create();\n \n-    private String mowerDuration = DEFAULT_MOWER_DURATION;\n-    private Session session;\n-    private GardenaConfig config;\n-    private String id;\n+    private static final String URL_API_HUSQUARNA = \"https://api.authentication.husqvarnagroup.dev/v1\";\n+    private static final String URL_API_GARDENA = \"https://api.smart.gardena.dev/v1\";\n+    private static final String URL_API_TOKEN = URL_API_HUSQUARNA + \"/oauth2/token\";\n+    private static final String URL_API_WEBSOCKET = URL_API_GARDENA + \"/websocket\";\n+    private static final String URL_API_LOCATIONS = URL_API_GARDENA + \"/locations\";\n+    private static final String URL_API_COMMAND = URL_API_GARDENA + \"/command\";\n \n+    private String id;\n+    private GardenaConfig config;\n     private ScheduledExecutorService scheduler;\n-    private ScheduledFuture<?> refreshThreadFuture;\n-    private RefreshDevicesThread refreshDevicesThread = new RefreshDevicesThread();\n \n+    private Map<String, Device> allDevicesById = new HashMap<>();\n+    private LocationsResponse locationsResponse;\n     private GardenaSmartEventListener eventListener;\n \n-    private Map<String, Device> allDevicesById = new HashMap<>();\n-    private Set<Location> allLocations = new HashSet<>();\n+    private HttpClient httpClient;\n+    private List<GardenaSmartWebSocket> webSockets = new ArrayList<>();\n+    private @Nullable PostOAuth2Response token;\n+    private boolean initialized = false;\n+    private WebSocketFactory webSocketFactory;\n \n-    @Override\n-    public void init(String id, GardenaConfig config, GardenaSmartEventListener eventListener,\n-            ScheduledExecutorService scheduler) throws GardenaException {\n+    private Set<Device> devicesToNotify = Collections.synchronizedSet(new HashSet<>());", "originalCommit": "b409d15f2f1a250218ea6bfdbace50888428afb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNzA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r541227069", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static @Nullable <T> T getPropertyValue(@Nullable Object instance, String propertyPath, Class<T> resultClass)\n          \n          \n            \n                public static <T> @Nullable T getPropertyValue(@Nullable Object instance, String propertyPath, Class<T> resultClass)", "author": "cpmeister", "createdAt": "2020-12-11T20:01:32Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/util/PropertyUtils.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal.util;\n+\n+import java.lang.reflect.Field;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gardena.internal.exception.GardenaException;\n+\n+/**\n+ * Utility class to read nested properties.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PropertyUtils {\n+\n+    /**\n+     * Returns true if the property is null.\n+     */\n+    public static boolean isNull(@Nullable Object instance, String propertyPath) throws GardenaException {\n+        return getPropertyValue(instance, propertyPath, Object.class) == null;\n+    }\n+\n+    /**\n+     * Returns the property value from the object instance, nested properties are possible.\n+     */\n+    public static @Nullable <T> T getPropertyValue(@Nullable Object instance, String propertyPath, Class<T> resultClass)", "originalCommit": "b409d15f2f1a250218ea6bfdbace50888428afb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyNzI0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r541227246", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static @Nullable <T> T getPropertyValue(@Nullable Object instance, String[] properties,\n          \n          \n            \n                private static <T> @Nullable T getPropertyValue(@Nullable Object instance, String[] properties,", "author": "cpmeister", "createdAt": "2020-12-11T20:01:44Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/util/PropertyUtils.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal.util;\n+\n+import java.lang.reflect.Field;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gardena.internal.exception.GardenaException;\n+\n+/**\n+ * Utility class to read nested properties.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PropertyUtils {\n+\n+    /**\n+     * Returns true if the property is null.\n+     */\n+    public static boolean isNull(@Nullable Object instance, String propertyPath) throws GardenaException {\n+        return getPropertyValue(instance, propertyPath, Object.class) == null;\n+    }\n+\n+    /**\n+     * Returns the property value from the object instance, nested properties are possible.\n+     */\n+    public static @Nullable <T> T getPropertyValue(@Nullable Object instance, String propertyPath, Class<T> resultClass)\n+            throws GardenaException {\n+        String[] properties = propertyPath.split(\"\\\\.\");\n+        return getPropertyValue(instance, properties, resultClass, 0);\n+    }\n+\n+    /**\n+     * Iterates through the nested properties and returns the field value.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private static @Nullable <T> T getPropertyValue(@Nullable Object instance, String[] properties,", "originalCommit": "b409d15f2f1a250218ea6bfdbace50888428afb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIyOTczNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r541229735", "bodyText": "You need to cancel the Future returned by this in case the handler is disposed.", "author": "cpmeister", "createdAt": "2020-12-11T20:04:21Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/handler/GardenaThingHandler.java", "diffHunk": "@@ -142,210 +106,186 @@ public void channelLinked(ChannelUID channelUID) {\n      * Updates the channel from the Gardena device.\n      */\n     protected void updateChannel(ChannelUID channelUID) throws GardenaException, AccountHandlerNotAvailableException {\n-        Device device = getDevice();\n-        State state = convertToState(device, channelUID);\n-        if (state != null) {\n-            updateState(channelUID, state);\n+        String groupId = channelUID.getGroupId();\n+        if (groupId != null) {\n+            boolean isCommand = groupId.endsWith(\"_commands\");\n+            if (!isCommand || (isCommand && isLocalDurationCommand(channelUID))) {\n+                Device device = getDevice();\n+                State state = convertToState(device, channelUID);\n+                if (state != null) {\n+                    updateState(channelUID, state);\n+                }\n+            }\n         }\n     }\n \n     /**\n      * Converts a Gardena property value to a openHAB state.\n      */\n-    private State convertToState(Device device, ChannelUID channelUID) throws GardenaException {\n-        String abilityName = channelUID.getGroupId();\n+    private @Nullable State convertToState(Device device, ChannelUID channelUID) throws GardenaException {\n+        if (isLocalDurationCommand(channelUID)) {\n+            String dataItemProperty = getDeviceDataItemProperty(channelUID);\n+            return new DecimalType(Math.round(device.getLocalService(dataItemProperty).commandDuration / 60.0));\n+        }\n+\n+        String propertyPath = channelUID.getGroupId() + \".attributes.\";\n         String propertyName = channelUID.getIdWithoutGroup();\n \n+        if (propertyName.endsWith(\"_timestamp\")) {\n+            propertyPath += propertyName.replace(\"_\", \".\");\n+        } else {\n+            propertyPath += propertyName + \".value\";\n+        }\n+\n+        String acceptedItemType = null;\n         try {\n-            String value = device.getAbility(abilityName).getProperty(propertyName).getValueAsString();\n+            Channel channel = getThing().getChannel(channelUID.getId());\n+            if (channel != null) {\n+                acceptedItemType = StringUtils.substringBefore(channel.getAcceptedItemType(), \":\");\n \n-            if (StringUtils.trimToNull(value) == null || StringUtils.equals(value, \"N/A\")) {\n-                return UnDefType.NULL;\n-            }\n+                if (acceptedItemType != null) {\n+                    boolean isNullPropertyValue = PropertyUtils.isNull(device, propertyPath);\n+                    boolean isDurationProperty = \"duration\".equals(propertyName);\n \n-            switch (getThing().getChannel(channelUID.getId()).getAcceptedItemType()) {\n-                case \"String\":\n-                    return new StringType(value);\n-                case \"Number\":\n-                    if (ABILITY_RADIO.equals(abilityName) && PROPERTY_STATE.equals(propertyName)) {\n-                        switch (value) {\n-                            case \"poor\":\n-                                return new DecimalType(1);\n-                            case \"good\":\n-                                return new DecimalType(2);\n-                            case \"excellent\":\n-                                return new DecimalType(4);\n-                            default:\n-                                return UnDefType.NULL;\n-                        }\n-                    }\n-                    return new DecimalType(value);\n-                case \"Switch\":\n-                    return Boolean.TRUE.toString().equalsIgnoreCase(value) || \"on\".equalsIgnoreCase(value)\n-                            ? OnOffType.ON\n-                            : OnOffType.OFF;\n-                case \"DateTime\":\n-                    Calendar cal = DateUtils.parseToCalendar(value);\n-                    if (cal != null && !cal.before(VALID_DATE_START)) {\n-                        return new DateTimeType(ZonedDateTime.ofInstant(cal.toInstant(), ZoneId.systemDefault()));\n-                    } else {\n+                    if (isNullPropertyValue && !isDurationProperty) {\n                         return UnDefType.NULL;\n                     }\n+                    switch (acceptedItemType) {\n+                        case \"String\":\n+                            return new StringType(PropertyUtils.getPropertyValue(device, propertyPath, String.class));\n+                        case \"Number\":\n+                            if (isNullPropertyValue) {\n+                                return new DecimalType(0);\n+                            } else {\n+                                Number value = PropertyUtils.getPropertyValue(device, propertyPath, Number.class);\n+                                // convert duration from seconds to minutes\n+                                if (value != null) {\n+                                    if (isDurationProperty) {\n+                                        value = Math.round(value.longValue() / 60.0);\n+                                    }\n+                                    return new DecimalType(value.longValue());\n+                                }\n+                                return UnDefType.NULL;\n+                            }\n+                        case \"DateTime\":\n+                            Date date = PropertyUtils.getPropertyValue(device, propertyPath, Date.class);\n+                            if (date != null) {\n+                                ZonedDateTime zdt = ZonedDateTime.ofInstant(date.toInstant(),\n+                                        timeZoneProvider.getTimeZone());\n+                                return new DateTimeType(zdt);\n+                            }\n+                            return UnDefType.NULL;\n+                    }\n+                }\n             }\n         } catch (GardenaException e) {\n-            logger.warn(\"Channel '{}' cannot be updated as device does not contain property '{}:{}'\", channelUID,\n-                    abilityName, propertyName);\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Converts an openHAB type to a Gardena command property.\n-     */\n-    private Object convertFromType(Type type) {\n-        if (type instanceof OnOffType) {\n-            return type == OnOffType.ON ? Boolean.TRUE : Boolean.FALSE;\n-        } else if (type instanceof DecimalType) {\n-            return ((DecimalType) type).intValue();\n-        } else if (type instanceof StringType) {\n-            return ((StringType) type).toFullString();\n+            logger.warn(\"Channel '{}' cannot be updated as device does not contain propertyPath '{}'\", channelUID,\n+                    propertyPath);\n+        } catch (ClassCastException ex) {\n+            logger.warn(\"Value of propertyPath '{}' can not be casted to {}: {}\", propertyPath, acceptedItemType,\n+                    ex.getMessage());\n         }\n         return null;\n     }\n \n     @Override\n     public void handleCommand(ChannelUID channelUID, Command command) {\n+        logger.debug(\"Command received: {}\", command);\n         try {\n-            GardenaSmartCommandName commandName = getCommandName(channelUID);\n-            logger.debug(\"Received Gardena command: {}\", commandName);\n-\n+            boolean isOnCommand = command instanceof OnOffType && ((OnOffType) command) == OnOffType.ON;\n+            String dataItemProperty = getDeviceDataItemProperty(channelUID);\n             if (RefreshType.REFRESH == command) {\n-                logger.debug(\"Refreshing channel '{}'\", channelUID);\n-                if (commandName != null && commandName.toString().startsWith(\"MEASURE_\")) {\n-                    getGardenaSmart().sendCommand(getDevice(), commandName, null);\n+                logger.debug(\"Refreshing Gardena connection\");\n+                getGardenaSmart().restartWebsockets();\n+            } else if (isLocalDurationCommand(channelUID)) {\n+                QuantityType<?> quantityType = (QuantityType<?>) command;\n+                getDevice().getLocalService(dataItemProperty).commandDuration = quantityType.intValue() * 60;\n+            } else if (isOnCommand) {\n+                GardenaCommand gardenaCommand = getGardenaCommand(dataItemProperty, channelUID);\n+                logger.debug(\"Received Gardena command: {}, {}\", gardenaCommand.getClass().getSimpleName(),\n+                        gardenaCommand.attributes.command);\n+\n+                DataItem<?> dataItem = PropertyUtils.getPropertyValue(getDevice(), dataItemProperty, DataItem.class);\n+                if (dataItem == null) {\n+                    logger.warn(\"DataItem {} is empty, ignoring command.\", dataItemProperty);\n                 } else {\n-                    updateChannel(channelUID);\n+                    getGardenaSmart().sendCommand(dataItem, gardenaCommand);\n+\n+                    scheduler.schedule(() -> {\n+                        updateState(channelUID, OnOffType.OFF);\n+                    }, 3, TimeUnit.SECONDS);", "originalCommit": "b409d15f2f1a250218ea6bfdbace50888428afb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIzMjg0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r541232845", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    connectionTracker = scheduler.scheduleWithFixedDelay(() -> {\n          \n          \n            \n                        sendKeepAlivePing();\n          \n          \n            \n                    }, 2, 2, TimeUnit.MINUTES);\n          \n          \n            \n                    connectionTracker = scheduler.scheduleWithFixedDelay(this::sendKeepAlivePing, 2, 2, TimeUnit.MINUTES);", "author": "cpmeister", "createdAt": "2020-12-11T20:07:42Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/GardenaSmartWebSocket.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.*;\n+import org.eclipse.jetty.websocket.api.extensions.Frame;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.frames.PongFrame;\n+import org.openhab.binding.gardena.internal.config.GardenaConfig;\n+import org.openhab.binding.gardena.internal.model.dto.api.PostOAuth2Response;\n+import org.openhab.binding.gardena.internal.model.dto.api.WebSocketCreatedResponse;\n+import org.openhab.core.io.net.http.WebSocketFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GardenaSmartWebSocket} implements the websocket for receiving constant updates from the Gardena smart\n+ * system.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@NonNullByDefault\n+@WebSocket\n+public class GardenaSmartWebSocket {\n+    private final Logger logger = LoggerFactory.getLogger(GardenaSmartWebSocket.class);\n+    private final GardenaSmartWebSocketListener socketEventListener;\n+    private final long WEBSOCKET_IDLE_TIMEOUT = 300;\n+\n+    private WebSocketSession session;\n+    private WebSocketClient webSocketClient;\n+    private boolean closing;\n+    private Instant lastPong = Instant.now();\n+    private ScheduledExecutorService scheduler;\n+    private @Nullable ScheduledFuture<?> connectionTracker;\n+    private ByteBuffer pingPayload = ByteBuffer.wrap(\"ping\".getBytes());\n+    private @Nullable PostOAuth2Response token;\n+    private String socketId;\n+\n+    /**\n+     * Starts the websocket session.\n+     */\n+    public GardenaSmartWebSocket(GardenaSmartWebSocketListener socketEventListener,\n+            WebSocketCreatedResponse webSocketCreatedResponse, GardenaConfig config, ScheduledExecutorService scheduler,\n+            WebSocketFactory webSocketFactory, @Nullable PostOAuth2Response token, String socketId) throws Exception {\n+        this.socketEventListener = socketEventListener;\n+        this.scheduler = scheduler;\n+        this.token = token;\n+        this.socketId = socketId;\n+\n+        webSocketClient = webSocketFactory.createWebSocketClient(String.valueOf(this.getClass().hashCode()));\n+        webSocketClient.setConnectTimeout(config.getConnectionTimeout() * 1000L);\n+        webSocketClient.setStopTimeout(3000);\n+        webSocketClient.setMaxIdleTimeout(150000);\n+        webSocketClient.start();\n+\n+        logger.debug(\"Connecting to Gardena Webservice ({})\", socketId);\n+        session = (WebSocketSession) webSocketClient\n+                .connect(this, new URI(webSocketCreatedResponse.data.attributes.url)).get();\n+        session.setStopTimeout(3000);\n+    }\n+\n+    /**\n+     * Stops the websocket session.\n+     */\n+    public synchronized void stop() {\n+        closing = true;\n+        final ScheduledFuture<?> connectionTracker = this.connectionTracker;\n+        if (connectionTracker != null) {\n+            connectionTracker.cancel(true);\n+        }\n+        if (isRunning()) {\n+            logger.debug(\"Closing Gardena Webservice client ({})\", socketId);\n+            try {\n+                session.close();\n+            } catch (Exception ex) {\n+                // ignore\n+            } finally {\n+                try {\n+                    webSocketClient.stop();\n+                } catch (Exception e) {\n+                    // ignore\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns true, if the websocket is running.\n+     */\n+    public synchronized boolean isRunning() {\n+        return session.isOpen();\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        closing = false;\n+        logger.debug(\"Connected to Gardena Webservice ({})\", socketId);\n+\n+        connectionTracker = scheduler.scheduleWithFixedDelay(() -> {\n+            sendKeepAlivePing();\n+        }, 2, 2, TimeUnit.MINUTES);", "originalCommit": "b409d15f2f1a250218ea6bfdbace50888428afb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIzNDk3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r541234974", "bodyText": "You should specify the charset used here since the system default charset might not be the one you want since it varies from system to system.", "author": "cpmeister", "createdAt": "2020-12-11T20:09:53Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/GardenaSmartWebSocket.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.*;\n+import org.eclipse.jetty.websocket.api.extensions.Frame;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.frames.PongFrame;\n+import org.openhab.binding.gardena.internal.config.GardenaConfig;\n+import org.openhab.binding.gardena.internal.model.dto.api.PostOAuth2Response;\n+import org.openhab.binding.gardena.internal.model.dto.api.WebSocketCreatedResponse;\n+import org.openhab.core.io.net.http.WebSocketFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GardenaSmartWebSocket} implements the websocket for receiving constant updates from the Gardena smart\n+ * system.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@NonNullByDefault\n+@WebSocket\n+public class GardenaSmartWebSocket {\n+    private final Logger logger = LoggerFactory.getLogger(GardenaSmartWebSocket.class);\n+    private final GardenaSmartWebSocketListener socketEventListener;\n+    private final long WEBSOCKET_IDLE_TIMEOUT = 300;\n+\n+    private WebSocketSession session;\n+    private WebSocketClient webSocketClient;\n+    private boolean closing;\n+    private Instant lastPong = Instant.now();\n+    private ScheduledExecutorService scheduler;\n+    private @Nullable ScheduledFuture<?> connectionTracker;\n+    private ByteBuffer pingPayload = ByteBuffer.wrap(\"ping\".getBytes());", "originalCommit": "b409d15f2f1a250218ea6bfdbace50888428afb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIzNjg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/8869#discussion_r541236848", "bodyText": "You should leave a comment here as to why you are using the hashcode of a class to create a websocket client.", "author": "cpmeister", "createdAt": "2020-12-11T20:11:54Z", "path": "bundles/org.openhab.binding.gardena/src/main/java/org/openhab/binding/gardena/internal/GardenaSmartWebSocket.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gardena.internal;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.time.Instant;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.*;\n+import org.eclipse.jetty.websocket.api.extensions.Frame;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.jetty.websocket.common.WebSocketSession;\n+import org.eclipse.jetty.websocket.common.frames.PongFrame;\n+import org.openhab.binding.gardena.internal.config.GardenaConfig;\n+import org.openhab.binding.gardena.internal.model.dto.api.PostOAuth2Response;\n+import org.openhab.binding.gardena.internal.model.dto.api.WebSocketCreatedResponse;\n+import org.openhab.core.io.net.http.WebSocketFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GardenaSmartWebSocket} implements the websocket for receiving constant updates from the Gardena smart\n+ * system.\n+ *\n+ * @author Gerhard Riegler - Initial contribution\n+ */\n+@NonNullByDefault\n+@WebSocket\n+public class GardenaSmartWebSocket {\n+    private final Logger logger = LoggerFactory.getLogger(GardenaSmartWebSocket.class);\n+    private final GardenaSmartWebSocketListener socketEventListener;\n+    private final long WEBSOCKET_IDLE_TIMEOUT = 300;\n+\n+    private WebSocketSession session;\n+    private WebSocketClient webSocketClient;\n+    private boolean closing;\n+    private Instant lastPong = Instant.now();\n+    private ScheduledExecutorService scheduler;\n+    private @Nullable ScheduledFuture<?> connectionTracker;\n+    private ByteBuffer pingPayload = ByteBuffer.wrap(\"ping\".getBytes());\n+    private @Nullable PostOAuth2Response token;\n+    private String socketId;\n+\n+    /**\n+     * Starts the websocket session.\n+     */\n+    public GardenaSmartWebSocket(GardenaSmartWebSocketListener socketEventListener,\n+            WebSocketCreatedResponse webSocketCreatedResponse, GardenaConfig config, ScheduledExecutorService scheduler,\n+            WebSocketFactory webSocketFactory, @Nullable PostOAuth2Response token, String socketId) throws Exception {\n+        this.socketEventListener = socketEventListener;\n+        this.scheduler = scheduler;\n+        this.token = token;\n+        this.socketId = socketId;\n+\n+        webSocketClient = webSocketFactory.createWebSocketClient(String.valueOf(this.getClass().hashCode()));", "originalCommit": "b409d15f2f1a250218ea6bfdbace50888428afb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8a4baed30c75aec4fcfcb947974fad542a0a0af4", "url": "https://github.com/openhab/openhab-addons/commit/8a4baed30c75aec4fcfcb947974fad542a0a0af4", "message": "Suggested changes according to pull request\n\nSigned-off-by: Gerhard Riegler <gerhard.riegler@gmail.com>", "committedDate": "2020-12-12T08:01:13Z", "type": "commit"}]}