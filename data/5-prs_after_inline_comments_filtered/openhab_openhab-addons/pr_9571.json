{"pr_number": 9571, "pr_title": "[roku] binding - initial implementation", "pr_createdAt": "2020-12-29T02:01:40Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9571", "timeline": [{"oid": "e2aa6a07ff2c09771a2f05c8db84805e1e4d5e0e", "url": "https://github.com/openhab/openhab-addons/commit/e2aa6a07ff2c09771a2f05c8db84805e1e4d5e0e", "message": "Roku binding - initial implementation\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-29T01:45:14Z", "type": "commit"}, {"oid": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "url": "https://github.com/openhab/openhab-addons/commit/8f2b033d11cefd239754a7d66f6b4a2aed164a14", "message": "update channel names to camelCase\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-29T05:00:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NDY0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549664642", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (host != null && !host.equals(EMPTY)) {\n          \n          \n            \n                    if (!EMPTY.equals(host)) {", "author": "Hilbrand", "createdAt": "2020-12-29T11:08:14Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5NTk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549895948", "bodyText": "This is needed for the NonNullByDefault check passing host into RokuCommunicator on line 86", "author": "mlobstein", "createdAt": "2020-12-30T00:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NDY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NTg5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549665899", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (config.refresh >= 10)\n          \n          \n            \n                        refreshInterval = config.refresh;\n          \n          \n            \n                    if (config.refresh >= 10) {\n          \n          \n            \n                        refreshInterval = config.refresh;\n          \n          \n            \n                    }", "author": "Hilbrand", "createdAt": "2020-12-29T11:12:53Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NjcwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549666709", "bodyText": "It's not needed to call .toString() as that is done automatically.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Unsupported refresh command: {}\", command.toString());\n          \n          \n            \n                        logger.debug(\"Unsupported refresh command: {}\", command);\n          \n      \n    \n    \n  \n\nSame comment applies to all other occurrences.", "author": "Hilbrand", "createdAt": "2020-12-29T11:15:43Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            deviceInfo = communicator.getDeviceInfo();\n+            thing.setProperty(PROPERTY_MODEL_NAME, deviceInfo.getModelName());\n+            thing.setProperty(PROPERTY_MODEL_NUMBER, deviceInfo.getModelNumber());\n+            thing.setProperty(PROPERTY_DEVICE_LOCAITON, deviceInfo.getUserDeviceLocation());\n+            thing.setProperty(PROPERTY_SERIAL_NUMBER, deviceInfo.getSerialNumber());\n+            thing.setProperty(PROPERTY_DEVICE_ID, deviceInfo.getDeviceId());\n+            thing.setProperty(PROPERTY_SOFTWARE_VERSION, deviceInfo.getSoftwareVersion());\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+        startAutomaticRefresh();\n+        startAppListRefresh();\n+    }\n+\n+    /**\n+     * Start the job to periodically get status updates from the Roku\n+     */\n+    private void startAutomaticRefresh() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        ActiveApp activeApp = communicator.getActiveApp();\n+                        updateState(ACTIVE_APP, new StringType(activeApp.getApp().getId()));\n+                        updateStatus(ThingStatus.ONLINE);\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku active-app info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+\n+                    try {\n+                        Player playerInfo = communicator.getPlayerInfo();\n+                        // When nothing playing, 'close' is reported, replace with 'stop'\n+                        updateState(PLAY_MODE, new StringType(playerInfo.getState().replaceAll(CLOSE, STOP)));\n+\n+                        // Remove non-numeric from string, ie: ' ms'\n+                        String position = playerInfo.getPosition().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(position)) {\n+                            updateState(TIME_ELAPSED,\n+                                    new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_ELAPSED, UnDefType.UNDEF);\n+                        }\n+\n+                        String duration = playerInfo.getDuration().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(duration)) {\n+                            updateState(TIME_TOTAL,\n+                                    new QuantityType<>(Integer.parseInt(duration) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_TOTAL, UnDefType.UNDEF);\n+                        }\n+                    } catch (RokuHttpException | NumberFormatException e) {\n+                        logger.debug(\"Unable to retrieve Roku media-player info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+                }\n+            };\n+            this.refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update list of apps installed on the the Roku\n+     */\n+    private void startAppListRefresh() {\n+        ScheduledFuture<?> appListJob = this.appListJob;\n+        if (appListJob == null || appListJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        List<App> appList = communicator.getAppList();\n+\n+                        List<StateOption> appListOptions = new ArrayList<>();\n+                        // Roku Home will be selected in the drop-down any time an app is not running.\n+                        appListOptions.add(new StateOption(ROKU_HOME_ID, ROKU_HOME));\n+\n+                        appList.forEach(app -> {\n+                            appListOptions.add(new StateOption(app.getId(), app.getValue()));\n+                        });\n+\n+                        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), ACTIVE_APP),\n+                                appListOptions);\n+\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku installed app-list. Exception: {}\", e.getMessage(), e);\n+                    }\n+                }\n+            };\n+            this.appListJob = scheduler.scheduleWithFixedDelay(runnable, 10, 600, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob != null) {\n+            refreshJob.cancel(true);\n+            this.refreshJob = null;\n+        }\n+\n+        ScheduledFuture<?> appListJob = this.appListJob;\n+        if (appListJob != null) {\n+            appListJob.cancel(true);\n+            this.appListJob = null;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            logger.debug(\"Unsupported refresh command: {}\", command.toString());", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NzE0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549667147", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (device.isTv())\n          \n          \n            \n                            thingUid = new ThingUID(THING_TYPE_ROKU_TV, uuid);\n          \n          \n            \n                        if (device.isTv()) {\n          \n          \n            \n                            thingUid = new ThingUID(THING_TYPE_ROKU_TV, uuid);\n          \n          \n            \n                        }", "author": "Hilbrand", "createdAt": "2020-12-29T11:17:05Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error discovering devices\", e);\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided services.\n+     *\n+     * @return The Socket where answers to the discovery broadcast arrive\n+     */\n+    private @Nullable DatagramSocket sendDiscoveryBroacast(NetworkInterface ni) {\n+        try {\n+            InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+            final int port = 1900;\n+\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"No ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // Create the discovery message packet\n+            byte[] requestMessage = ROKU_DISCOVERY_MESSAGE.getBytes(StandardCharsets.UTF_8);\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+\n+            // Create socket and send the discovery message\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.setSoTimeout(3000);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.debug(\"sendDiscoveryBroacast() got IOException: {}\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and process those that come from a Roku.\n+     *\n+     * @param socket The socket where answers to the discovery broadcast arrive\n+     */\n+    private void scanResposesForKeywords(DatagramSocket socket) {\n+        boolean socketTimeout = false;\n+        do {\n+            byte[] receiveData = new byte[1024];\n+            DatagramPacket packet = new DatagramPacket(receiveData, receiveData.length);\n+            try {\n+                socket.receive(packet);\n+            } catch (SocketTimeoutException e) {\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            } catch (IOException e) {\n+                logger.debug(\"Got exception while trying to receive UPnP packets: {}\", e.getMessage());\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            }\n+            String response = new String(packet.getData(), StandardCharsets.UTF_8);\n+            if (response.contains(ROKU_SSDP_MATCH)) {\n+                parseResponseCreateThing(response);\n+            }\n+        } while (!socketTimeout);\n+    }\n+\n+    /**\n+     * Process the response from the Roku into a DiscoveryResult.\n+     *\n+     */\n+    private void parseResponseCreateThing(String response) {\n+        DiscoveryResult result;\n+\n+        String label = \"Roku\";\n+        String uuid = null;\n+        String host = null;\n+        int port = -1;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    host = value;\n+                    Matcher matchIp = IP_HOST_PATTERN.matcher(value);\n+                    if (matchIp.find()) {\n+                        host = matchIp.group(1);\n+                        port = Integer.parseInt(matchIp.group(2));\n+                    }\n+                    break;\n+                case \"usn\":\n+                    Matcher matchUid = USN_PATTERN.matcher(value);\n+                    if (matchUid.find()) {\n+                        uuid = matchUid.group(2);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        if (host == null || port == -1 || uuid == null) {\n+            logger.debug(\"Bad Format from Roku, received data was: {}\", response);\n+            return;\n+        } else {\n+            logger.debug(\"Found Roku, uuid: {} host: {}\", uuid, host);\n+        }\n+\n+        uuid = uuid.replace(\":\", \"\").toLowerCase();\n+\n+        ThingUID thingUid = new ThingUID(THING_TYPE_ROKU_PLAYER, uuid);\n+\n+        // Try to query the device using discovered host and port to get extended device info\n+        try {\n+            RokuCommunicator communicator = new RokuCommunicator(httpClient, host, port);\n+            DeviceInfo device = communicator.getDeviceInfo();\n+            label = device.getModelName() + \" \" + device.getModelNumber();\n+            if (device.isTv())\n+                thingUid = new ThingUID(THING_TYPE_ROKU_TV, uuid);", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NzQ3NA==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549667474", "bodyText": "If the RokuHttpException happens does it make sense to continue here and add the thing to discovery results? or should that code be placed with the try-catch?", "author": "Hilbrand", "createdAt": "2020-12-29T11:18:17Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error discovering devices\", e);\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided services.\n+     *\n+     * @return The Socket where answers to the discovery broadcast arrive\n+     */\n+    private @Nullable DatagramSocket sendDiscoveryBroacast(NetworkInterface ni) {\n+        try {\n+            InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+            final int port = 1900;\n+\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"No ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // Create the discovery message packet\n+            byte[] requestMessage = ROKU_DISCOVERY_MESSAGE.getBytes(StandardCharsets.UTF_8);\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+\n+            // Create socket and send the discovery message\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.setSoTimeout(3000);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.debug(\"sendDiscoveryBroacast() got IOException: {}\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and process those that come from a Roku.\n+     *\n+     * @param socket The socket where answers to the discovery broadcast arrive\n+     */\n+    private void scanResposesForKeywords(DatagramSocket socket) {\n+        boolean socketTimeout = false;\n+        do {\n+            byte[] receiveData = new byte[1024];\n+            DatagramPacket packet = new DatagramPacket(receiveData, receiveData.length);\n+            try {\n+                socket.receive(packet);\n+            } catch (SocketTimeoutException e) {\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            } catch (IOException e) {\n+                logger.debug(\"Got exception while trying to receive UPnP packets: {}\", e.getMessage());\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            }\n+            String response = new String(packet.getData(), StandardCharsets.UTF_8);\n+            if (response.contains(ROKU_SSDP_MATCH)) {\n+                parseResponseCreateThing(response);\n+            }\n+        } while (!socketTimeout);\n+    }\n+\n+    /**\n+     * Process the response from the Roku into a DiscoveryResult.\n+     *\n+     */\n+    private void parseResponseCreateThing(String response) {\n+        DiscoveryResult result;\n+\n+        String label = \"Roku\";\n+        String uuid = null;\n+        String host = null;\n+        int port = -1;\n+\n+        Scanner scanner = new Scanner(response);\n+        while (scanner.hasNextLine()) {\n+            String line = scanner.nextLine();\n+            String[] pair = line.split(\":\", 2);\n+            if (pair.length != 2) {\n+                continue;\n+            }\n+\n+            String key = pair[0].toLowerCase();\n+            String value = pair[1].trim();\n+            logger.debug(\"key: {} value: {}.\", key, value);\n+            switch (key) {\n+                case \"location\":\n+                    host = value;\n+                    Matcher matchIp = IP_HOST_PATTERN.matcher(value);\n+                    if (matchIp.find()) {\n+                        host = matchIp.group(1);\n+                        port = Integer.parseInt(matchIp.group(2));\n+                    }\n+                    break;\n+                case \"usn\":\n+                    Matcher matchUid = USN_PATTERN.matcher(value);\n+                    if (matchUid.find()) {\n+                        uuid = matchUid.group(2);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        scanner.close();\n+\n+        if (host == null || port == -1 || uuid == null) {\n+            logger.debug(\"Bad Format from Roku, received data was: {}\", response);\n+            return;\n+        } else {\n+            logger.debug(\"Found Roku, uuid: {} host: {}\", uuid, host);\n+        }\n+\n+        uuid = uuid.replace(\":\", \"\").toLowerCase();\n+\n+        ThingUID thingUid = new ThingUID(THING_TYPE_ROKU_PLAYER, uuid);\n+\n+        // Try to query the device using discovered host and port to get extended device info\n+        try {\n+            RokuCommunicator communicator = new RokuCommunicator(httpClient, host, port);\n+            DeviceInfo device = communicator.getDeviceInfo();\n+            label = device.getModelName() + \" \" + device.getModelNumber();\n+            if (device.isTv())\n+                thingUid = new ThingUID(THING_TYPE_ROKU_TV, uuid);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+\n+        result = DiscoveryResultBuilder.create(thingUid).withLabel(label).withRepresentationProperty(PROPERTY_UUID)\n+                .withProperty(PROPERTY_UUID, uuid).withProperty(PROPERTY_HOST_NAME, host)\n+                .withProperty(PROPERTY_PORT, port).build();\n+        this.thingDiscovered(result);", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5NjU4MA==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549896580", "bodyText": "At this point there is enough information to create the thing. This call being caught here only enhances the result. I would like to leave it as-is just in case the call to retrieve the extended info stops working due to a device firmware update or similar issue.", "author": "mlobstein", "createdAt": "2020-12-30T00:29:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NzQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NzkzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549667934", "bodyText": "With quantity type it's not necessarily needed to convert. So you can pass it as it and just give it the right unit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));\n          \n          \n            \n                                                new QuantityType<>(Integer.parseInt(position), API_MILLISECONDS_UNIT));", "author": "Hilbrand", "createdAt": "2020-12-29T11:19:59Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            deviceInfo = communicator.getDeviceInfo();\n+            thing.setProperty(PROPERTY_MODEL_NAME, deviceInfo.getModelName());\n+            thing.setProperty(PROPERTY_MODEL_NUMBER, deviceInfo.getModelNumber());\n+            thing.setProperty(PROPERTY_DEVICE_LOCAITON, deviceInfo.getUserDeviceLocation());\n+            thing.setProperty(PROPERTY_SERIAL_NUMBER, deviceInfo.getSerialNumber());\n+            thing.setProperty(PROPERTY_DEVICE_ID, deviceInfo.getDeviceId());\n+            thing.setProperty(PROPERTY_SOFTWARE_VERSION, deviceInfo.getSoftwareVersion());\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+        startAutomaticRefresh();\n+        startAppListRefresh();\n+    }\n+\n+    /**\n+     * Start the job to periodically get status updates from the Roku\n+     */\n+    private void startAutomaticRefresh() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        ActiveApp activeApp = communicator.getActiveApp();\n+                        updateState(ACTIVE_APP, new StringType(activeApp.getApp().getId()));\n+                        updateStatus(ThingStatus.ONLINE);\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku active-app info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+\n+                    try {\n+                        Player playerInfo = communicator.getPlayerInfo();\n+                        // When nothing playing, 'close' is reported, replace with 'stop'\n+                        updateState(PLAY_MODE, new StringType(playerInfo.getState().replaceAll(CLOSE, STOP)));\n+\n+                        // Remove non-numeric from string, ie: ' ms'\n+                        String position = playerInfo.getPosition().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(position)) {\n+                            updateState(TIME_ELAPSED,\n+                                    new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5NjgyMw==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549896823", "bodyText": "I did not think that the user needs millisecond precision in the elapsed time of the show they are watching.", "author": "mlobstein", "createdAt": "2020-12-30T00:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY2NzkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2OTI4MA==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549769280", "bodyText": "You can also put this into a method and than pass that method the scheduler with this::<method name>", "author": "Hilbrand", "createdAt": "2020-12-29T16:34:07Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            deviceInfo = communicator.getDeviceInfo();\n+            thing.setProperty(PROPERTY_MODEL_NAME, deviceInfo.getModelName());\n+            thing.setProperty(PROPERTY_MODEL_NUMBER, deviceInfo.getModelNumber());\n+            thing.setProperty(PROPERTY_DEVICE_LOCAITON, deviceInfo.getUserDeviceLocation());\n+            thing.setProperty(PROPERTY_SERIAL_NUMBER, deviceInfo.getSerialNumber());\n+            thing.setProperty(PROPERTY_DEVICE_ID, deviceInfo.getDeviceId());\n+            thing.setProperty(PROPERTY_SOFTWARE_VERSION, deviceInfo.getSoftwareVersion());\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+        startAutomaticRefresh();\n+        startAppListRefresh();\n+    }\n+\n+    /**\n+     * Start the job to periodically get status updates from the Roku\n+     */\n+    private void startAutomaticRefresh() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        ActiveApp activeApp = communicator.getActiveApp();\n+                        updateState(ACTIVE_APP, new StringType(activeApp.getApp().getId()));\n+                        updateStatus(ThingStatus.ONLINE);\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku active-app info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+\n+                    try {\n+                        Player playerInfo = communicator.getPlayerInfo();\n+                        // When nothing playing, 'close' is reported, replace with 'stop'\n+                        updateState(PLAY_MODE, new StringType(playerInfo.getState().replaceAll(CLOSE, STOP)));\n+\n+                        // Remove non-numeric from string, ie: ' ms'\n+                        String position = playerInfo.getPosition().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(position)) {\n+                            updateState(TIME_ELAPSED,\n+                                    new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_ELAPSED, UnDefType.UNDEF);\n+                        }\n+\n+                        String duration = playerInfo.getDuration().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(duration)) {\n+                            updateState(TIME_TOTAL,\n+                                    new QuantityType<>(Integer.parseInt(duration) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_TOTAL, UnDefType.UNDEF);\n+                        }\n+                    } catch (RokuHttpException | NumberFormatException e) {\n+                        logger.debug(\"Unable to retrieve Roku media-player info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+                }\n+            };\n+            this.refreshJob = scheduler.scheduleWithFixedDelay(runnable, 0, refreshInterval, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Start the job to periodically update list of apps installed on the the Roku\n+     */\n+    private void startAppListRefresh() {\n+        ScheduledFuture<?> appListJob = this.appListJob;\n+        if (appListJob == null || appListJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        List<App> appList = communicator.getAppList();\n+\n+                        List<StateOption> appListOptions = new ArrayList<>();\n+                        // Roku Home will be selected in the drop-down any time an app is not running.\n+                        appListOptions.add(new StateOption(ROKU_HOME_ID, ROKU_HOME));\n+\n+                        appList.forEach(app -> {\n+                            appListOptions.add(new StateOption(app.getId(), app.getValue()));\n+                        });\n+\n+                        stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(), ACTIVE_APP),\n+                                appListOptions);\n+\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku installed app-list. Exception: {}\", e.getMessage(), e);\n+                    }\n+                }\n+            };", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MDMxMA==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549770310", "bodyText": "By having 1 exception for all you might miss updating channels. Because if it fails on the first channel set, the other channels are not set. Also if only 1 fails on NumberFormatException should the thing go offline?", "author": "Hilbrand", "createdAt": "2020-12-29T16:37:06Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/handler/RokuHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.handler;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuConfiguration;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.RokuStateDescriptionOptionProvider;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.ActiveApp;\n+import org.openhab.binding.roku.internal.dto.Apps.App;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.binding.roku.internal.dto.Player;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class RokuHandler extends BaseThingHandler {\n+    private static final int DEFAULT_REFRESH_PERIOD_SEC = 10;\n+\n+    private final Logger logger = LoggerFactory.getLogger(RokuHandler.class);\n+    private final HttpClient httpClient;\n+    private final RokuStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> refreshJob;\n+    private @Nullable ScheduledFuture<?> appListJob;\n+\n+    private RokuCommunicator communicator;\n+    private DeviceInfo deviceInfo = new DeviceInfo();\n+    private int refreshInterval = DEFAULT_REFRESH_PERIOD_SEC;\n+\n+    private Object sequenceLock = new Object();\n+\n+    public RokuHandler(Thing thing, HttpClient httpClient,\n+            RokuStateDescriptionOptionProvider stateDescriptionProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.communicator = new RokuCommunicator(httpClient, EMPTY, -1);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Roku handler\");\n+        RokuConfiguration config = getConfigAs(RokuConfiguration.class);\n+\n+        final @Nullable String host = config.hostName;\n+\n+        if (host != null && !host.equals(EMPTY)) {\n+            this.communicator = new RokuCommunicator(httpClient, host, config.port);\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Host Name must be specified\");\n+            return;\n+        }\n+\n+        if (config.refresh >= 10)\n+            refreshInterval = config.refresh;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        try {\n+            deviceInfo = communicator.getDeviceInfo();\n+            thing.setProperty(PROPERTY_MODEL_NAME, deviceInfo.getModelName());\n+            thing.setProperty(PROPERTY_MODEL_NUMBER, deviceInfo.getModelNumber());\n+            thing.setProperty(PROPERTY_DEVICE_LOCAITON, deviceInfo.getUserDeviceLocation());\n+            thing.setProperty(PROPERTY_SERIAL_NUMBER, deviceInfo.getSerialNumber());\n+            thing.setProperty(PROPERTY_DEVICE_ID, deviceInfo.getDeviceId());\n+            thing.setProperty(PROPERTY_SOFTWARE_VERSION, deviceInfo.getSoftwareVersion());\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (RokuHttpException e) {\n+            logger.debug(\"Unable to retrieve Roku device-info. Exception: {}\", e.getMessage(), e);\n+        }\n+        startAutomaticRefresh();\n+        startAppListRefresh();\n+    }\n+\n+    /**\n+     * Start the job to periodically get status updates from the Roku\n+     */\n+    private void startAutomaticRefresh() {\n+        ScheduledFuture<?> refreshJob = this.refreshJob;\n+        if (refreshJob == null || refreshJob.isCancelled()) {\n+            Runnable runnable = () -> {\n+                synchronized (sequenceLock) {\n+                    try {\n+                        ActiveApp activeApp = communicator.getActiveApp();\n+                        updateState(ACTIVE_APP, new StringType(activeApp.getApp().getId()));\n+                        updateStatus(ThingStatus.ONLINE);\n+                    } catch (RokuHttpException e) {\n+                        logger.debug(\"Unable to retrieve Roku active-app info. Exception: {}\", e.getMessage(), e);\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    }\n+\n+                    try {\n+                        Player playerInfo = communicator.getPlayerInfo();\n+                        // When nothing playing, 'close' is reported, replace with 'stop'\n+                        updateState(PLAY_MODE, new StringType(playerInfo.getState().replaceAll(CLOSE, STOP)));\n+\n+                        // Remove non-numeric from string, ie: ' ms'\n+                        String position = playerInfo.getPosition().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(position)) {\n+                            updateState(TIME_ELAPSED,\n+                                    new QuantityType<>(Integer.parseInt(position) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_ELAPSED, UnDefType.UNDEF);\n+                        }\n+\n+                        String duration = playerInfo.getDuration().replaceAll(NON_DIGIT_PATTERN, EMPTY);\n+                        if (!EMPTY.equals(duration)) {\n+                            updateState(TIME_TOTAL,\n+                                    new QuantityType<>(Integer.parseInt(duration) / 1000, API_SECONDS_UNIT));\n+                        } else {\n+                            updateState(TIME_TOTAL, UnDefType.UNDEF);\n+                        }\n+                    } catch (RokuHttpException | NumberFormatException e) {", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTg5NzE3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549897171", "bodyText": "I looked at this again and removed the NumberFormatException from the catch. The code already removes non-numeric characters and checks for empty string before doing parseInt(). Catching NumberFormatException was redundant.", "author": "mlobstein", "createdAt": "2020-12-30T00:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MDMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MTYyNA==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549771624", "bodyText": "If you put the DatagramSocket into a try-with-resources you can omit all the calls to close.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            DatagramSocket socket = sendDiscoveryBroacast(ni);\n          \n          \n            \n                            if (socket != null) {\n          \n          \n            \n                                scanResposesForKeywords(socket);\n          \n          \n            \n                            }\n          \n          \n            \n                            try (DatagramSocket socket = sendDiscoveryBroacast(ni)) {\n          \n          \n            \n                                if (socket != null) {\n          \n          \n            \n                                    scanResposesForKeywords(socket);\n          \n          \n            \n                                }\n          \n          \n            \n                            }", "author": "Hilbrand", "createdAt": "2020-12-29T16:41:08Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MTk5MA==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549771990", "bodyText": "Same here with try-with-resources:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Scanner scanner = new Scanner(response);\n          \n          \n            \n                    try (Scanner scanner = new Scanner(response)) {\n          \n      \n    \n    \n  \n\nand remove the call to close below.", "author": "Hilbrand", "createdAt": "2020-12-29T16:42:21Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error discovering devices\", e);\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided services.\n+     *\n+     * @return The Socket where answers to the discovery broadcast arrive\n+     */\n+    private @Nullable DatagramSocket sendDiscoveryBroacast(NetworkInterface ni) {\n+        try {\n+            InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+            final int port = 1900;\n+\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"No ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // Create the discovery message packet\n+            byte[] requestMessage = ROKU_DISCOVERY_MESSAGE.getBytes(StandardCharsets.UTF_8);\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+\n+            // Create socket and send the discovery message\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.setSoTimeout(3000);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.debug(\"sendDiscoveryBroacast() got IOException: {}\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and process those that come from a Roku.\n+     *\n+     * @param socket The socket where answers to the discovery broadcast arrive\n+     */\n+    private void scanResposesForKeywords(DatagramSocket socket) {\n+        boolean socketTimeout = false;\n+        do {\n+            byte[] receiveData = new byte[1024];\n+            DatagramPacket packet = new DatagramPacket(receiveData, receiveData.length);\n+            try {\n+                socket.receive(packet);\n+            } catch (SocketTimeoutException e) {\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            } catch (IOException e) {\n+                logger.debug(\"Got exception while trying to receive UPnP packets: {}\", e.getMessage());\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            }\n+            String response = new String(packet.getData(), StandardCharsets.UTF_8);\n+            if (response.contains(ROKU_SSDP_MATCH)) {\n+                parseResponseCreateThing(response);\n+            }\n+        } while (!socketTimeout);\n+    }\n+\n+    /**\n+     * Process the response from the Roku into a DiscoveryResult.\n+     *\n+     */\n+    private void parseResponseCreateThing(String response) {\n+        DiscoveryResult result;\n+\n+        String label = \"Roku\";\n+        String uuid = null;\n+        String host = null;\n+        int port = -1;\n+\n+        Scanner scanner = new Scanner(response);", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MzA3OA==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549773078", "bodyText": "This seems a bit overkill. Because socketTimeout will never be true. Because if it's made true the method will call return. So you can remove this variable and simply make it a while(true)) loop.", "author": "Hilbrand", "createdAt": "2020-12-29T16:45:55Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error discovering devices\", e);\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided services.\n+     *\n+     * @return The Socket where answers to the discovery broadcast arrive\n+     */\n+    private @Nullable DatagramSocket sendDiscoveryBroacast(NetworkInterface ni) {\n+        try {\n+            InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+            final int port = 1900;\n+\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"No ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // Create the discovery message packet\n+            byte[] requestMessage = ROKU_DISCOVERY_MESSAGE.getBytes(StandardCharsets.UTF_8);\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+\n+            // Create socket and send the discovery message\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.setSoTimeout(3000);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.debug(\"sendDiscoveryBroacast() got IOException: {}\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and process those that come from a Roku.\n+     *\n+     * @param socket The socket where answers to the discovery broadcast arrive\n+     */\n+    private void scanResposesForKeywords(DatagramSocket socket) {\n+        boolean socketTimeout = false;\n+        do {\n+            byte[] receiveData = new byte[1024];\n+            DatagramPacket packet = new DatagramPacket(receiveData, receiveData.length);\n+            try {\n+                socket.receive(packet);\n+            } catch (SocketTimeoutException e) {\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            } catch (IOException e) {\n+                logger.debug(\"Got exception while trying to receive UPnP packets: {}\", e.getMessage());\n+                socket.close();\n+                socketTimeout = true;\n+                return;\n+            }\n+            String response = new String(packet.getData(), StandardCharsets.UTF_8);\n+            if (response.contains(ROKU_SSDP_MATCH)) {\n+                parseResponseCreateThing(response);\n+            }\n+        } while (!socketTimeout);", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc3MzI2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9571#discussion_r549773262", "bodyText": "Do you need a new byte block here? or can you reuse it by putting it above the do-while loop?", "author": "Hilbrand", "createdAt": "2020-12-29T16:46:28Z", "path": "bundles/org.openhab.binding.roku/src/main/java/org/openhab/binding/roku/internal/discovery/RokuDiscoveryService.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.roku.internal.discovery;\n+\n+import static org.openhab.binding.roku.internal.RokuBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Enumeration;\n+import java.util.Scanner;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.roku.internal.RokuHttpException;\n+import org.openhab.binding.roku.internal.communication.RokuCommunicator;\n+import org.openhab.binding.roku.internal.dto.DeviceInfo;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link RokuDiscoveryService} is responsible for discovery of Roku devices on the local network\n+ *\n+ * @author William Welliver - Initial contribution\n+ * @author Dan Cunningham - Refactoring and Improvements\n+ * @author Michael Lobstein - Modified for Roku binding\n+ */\n+\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.roku\")\n+public class RokuDiscoveryService extends AbstractDiscoveryService {\n+    private final Logger logger = LoggerFactory.getLogger(RokuDiscoveryService.class);\n+    private static final String ROKU_DISCOVERY_MESSAGE = \"M-SEARCH * HTTP/1.1\\r\\n\" + \"Host: 239.255.255.250:1900\\r\\n\"\n+            + \"Man: \\\"ssdp:discover\\\"\\r\\n\" + \"ST: roku:ecp\\r\\n\" + \"\\r\\n\";\n+\n+    private static final Pattern USN_PATTERN = Pattern.compile(\"^(uuid:roku:)?ecp:([0-9a-zA-Z]{1,16})\");\n+\n+    private static final Pattern IP_HOST_PATTERN = Pattern\n+            .compile(\"([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}):([0-9]{1,5})\");\n+\n+    private static final String ROKU_SSDP_MATCH = \"uuid:roku:ecp\";\n+    private static final int BACKGROUND_SCAN_INTERVAL_SECONDS = 300;\n+\n+    private final HttpClient httpClient;\n+\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+\n+    @Activate\n+    public RokuDiscoveryService(final @Reference HttpClientFactory httpClientFactory) {\n+        super(SUPPORTED_THING_TYPES_UIDS, 30, true);\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        scheduledFuture = scheduler.scheduleWithFixedDelay(this::doNetworkScan, 0, BACKGROUND_SCAN_INTERVAL_SECONDS,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void stopBackgroundDiscovery() {\n+        ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+        }\n+        this.scheduledFuture = null;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        doNetworkScan();\n+    }\n+\n+    /**\n+     * Enumerate all network interfaces, send the discovery broadcast and process responses.\n+     *\n+     */\n+    private synchronized void doNetworkScan() {\n+        try {\n+            Enumeration<NetworkInterface> nets = NetworkInterface.getNetworkInterfaces();\n+            while (nets.hasMoreElements()) {\n+                NetworkInterface ni = nets.nextElement();\n+                DatagramSocket socket = sendDiscoveryBroacast(ni);\n+                if (socket != null) {\n+                    scanResposesForKeywords(socket);\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"Error discovering devices\", e);\n+        }\n+    }\n+\n+    /**\n+     * Broadcasts a SSDP discovery message into the network to find provided services.\n+     *\n+     * @return The Socket where answers to the discovery broadcast arrive\n+     */\n+    private @Nullable DatagramSocket sendDiscoveryBroacast(NetworkInterface ni) {\n+        try {\n+            InetAddress m = InetAddress.getByName(\"239.255.255.250\");\n+            final int port = 1900;\n+\n+            if (!ni.isUp() || !ni.supportsMulticast()) {\n+                return null;\n+            }\n+\n+            Enumeration<InetAddress> addrs = ni.getInetAddresses();\n+            InetAddress a = null;\n+            while (addrs.hasMoreElements()) {\n+                a = addrs.nextElement();\n+                if (a instanceof Inet4Address) {\n+                    break;\n+                } else {\n+                    a = null;\n+                }\n+            }\n+            if (a == null) {\n+                logger.debug(\"No ipv4 address on {}\", ni.getName());\n+                return null;\n+            }\n+\n+            // Create the discovery message packet\n+            byte[] requestMessage = ROKU_DISCOVERY_MESSAGE.getBytes(StandardCharsets.UTF_8);\n+            DatagramPacket datagramPacket = new DatagramPacket(requestMessage, requestMessage.length, m, port);\n+\n+            // Create socket and send the discovery message\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.setSoTimeout(3000);\n+            socket.send(datagramPacket);\n+            return socket;\n+        } catch (IOException e) {\n+            logger.debug(\"sendDiscoveryBroacast() got IOException: {}\", e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Scans all messages that arrive on the socket and process those that come from a Roku.\n+     *\n+     * @param socket The socket where answers to the discovery broadcast arrive\n+     */\n+    private void scanResposesForKeywords(DatagramSocket socket) {\n+        boolean socketTimeout = false;\n+        do {\n+            byte[] receiveData = new byte[1024];", "originalCommit": "8f2b033d11cefd239754a7d66f6b4a2aed164a14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c569fc6bc2afb6c7a660c31a246a5d5d49ef3f5d", "url": "https://github.com/openhab/openhab-addons/commit/c569fc6bc2afb6c7a660c31a246a5d5d49ef3f5d", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-30T00:03:58Z", "type": "commit"}, {"oid": "457e278c88d9e1aafd40d8e26bc2ef6c04093a3c", "url": "https://github.com/openhab/openhab-addons/commit/457e278c88d9e1aafd40d8e26bc2ef6c04093a3c", "message": "spelling\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-30T00:38:41Z", "type": "commit"}, {"oid": "c1a31bb1c2c222af7575e1e772e8a9a40fbeb6e1", "url": "https://github.com/openhab/openhab-addons/commit/c1a31bb1c2c222af7575e1e772e8a9a40fbeb6e1", "message": "update README.md\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-12-30T05:26:34Z", "type": "commit"}, {"oid": "2b22a7117b1c960fc5d7624a2a24d2438e3cd4c9", "url": "https://github.com/openhab/openhab-addons/commit/2b22a7117b1c960fc5d7624a2a24d2438e3cd4c9", "message": "Merge branch 'main' into Roku_OH3", "committedDate": "2021-01-03T15:07:44Z", "type": "commit"}]}