{"pr_number": 9579, "pr_title": "[WlanThermo] Add support for new Nano V3, Mini V3, Link V1, Mini V1/V2(ESP32) devices [V3.x]", "pr_createdAt": "2020-12-29T13:29:51Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/9579", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0Nzk3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550447975", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import java.awt.*;\n          \n          \n            \n            import java.awt.Color;", "author": "fwolter", "createdAt": "2020-12-31T10:10:08Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;", "originalCommit": "1d8198157422913730de85f90ef717e523e063bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0OTYzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550449635", "bodyText": "You can avoid the compiler warning by specifying the wildcard. Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        channel.get(channelId).setMin(((QuantityType) command).doubleValue());\n          \n          \n            \n                                        channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());", "author": "fwolter", "createdAt": "2020-12-31T10:18:39Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+        if (data == null || settings == null) {\n+            return null;\n+        }\n+        System system = data.getSystem();\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(channelUID.getGroupId()) && system != null) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new DecimalType(system.getRssi());\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(channelUID.getGroupId().substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new DecimalType(channel.get(channelId).getTemp());\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new DecimalType(channel.get(channelId).getMin());\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new DecimalType(channel.get(channelId).getMax());\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new DecimalType(pm.getSet());\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(channelUID.getGroupId().substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType) command).doubleValue());", "originalCommit": "1d8198157422913730de85f90ef717e523e063bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDc2NzEwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550767106", "bodyText": "Changed to wildcard", "author": "CSchlipp", "createdAt": "2021-01-01T13:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0OTYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1Mjk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550452948", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-31T10:34:41Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");", "originalCommit": "1d8198157422913730de85f90ef717e523e063bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MzA2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550453060", "bodyText": "The log message could be removed, as the status update is already logged by the framework. The state change originated by updateStatus() is logged to events.log. Including the status detail message. Please check all.\nYou could mention, that the URL is incorrect in the message.", "author": "fwolter", "createdAt": "2020-12-31T10:35:18Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);", "originalCommit": "1d8198157422913730de85f90ef717e523e063bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MzQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550453454", "bodyText": "You could append the exception's message. Please check all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                \"Could not connect to WlanThermo at \" + config.getIpAddress());\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());", "author": "fwolter", "createdAt": "2020-12-31T10:37:14Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());", "originalCommit": "1d8198157422913730de85f90ef717e523e063bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDEyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454126", "bodyText": "You could initialize the config parameters in the config class to be able to remove the Nullable declaration. Or store config.getUsername() to a local variable here and do the null check on that.", "author": "fwolter", "createdAt": "2020-12-31T10:40:48Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {", "originalCommit": "1d8198157422913730de85f90ef717e523e063bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDE5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454191", "bodyText": "Please add curly brackets.", "author": "fwolter", "createdAt": "2020-12-31T10:41:12Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);", "originalCommit": "1d8198157422913730de85f90ef717e523e063bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDQxNA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454414", "bodyText": "Is there a reason why these are Nullable?", "author": "fwolter", "createdAt": "2020-12-31T10:42:22Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();", "originalCommit": "1d8198157422913730de85f90ef717e523e063bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2MTU5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550461599", "bodyText": "TBH I don't know why this came up as an error in the V3 branch when compiling locally...\nPrevious versions did not require the annotation, even the current auto-migrated binding is obviously compiling fine when run on Jenkins?", "author": "CSchlipp", "createdAt": "2020-12-31T11:19:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2MzQ3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550463470", "bodyText": "I see, Gson requires it. Then, you need to handle the null case, i.e. fix the compiler warnings about nulls.", "author": "fwolter", "createdAt": "2020-12-31T11:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDc2NzA5OA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550767098", "bodyText": "Done, remaining warnings are false positives", "author": "CSchlipp", "createdAt": "2021-01-01T13:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDcyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550454725", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-12-31T10:44:07Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);", "originalCommit": "1d8198157422913730de85f90ef717e523e063bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDUwNzU3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550507575", "bodyText": "This is usually the most crucial part in case sth goes wrong.\nI'd prefer to leave it with a dedicated debug log so that users can easily include it in in bug reports.", "author": "CSchlipp", "createdAt": "2020-12-31T15:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDUxMjgxMg==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550512812", "bodyText": "Is there any chance to log this only if something goes wrong?", "author": "fwolter", "createdAt": "2020-12-31T16:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDc1MzUzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550753531", "bodyText": "Payload is now only logged if response code != 200", "author": "CSchlipp", "createdAt": "2021-01-01T10:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NDcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550455289", "bodyText": "BaseThingHandler provides a scheduler. Is there any reason not using that?", "author": "fwolter", "createdAt": "2020-12-31T10:46:46Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.settings.Settings;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "originalCommit": "1d8198157422913730de85f90ef717e523e063bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2MjI5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550462297", "bodyText": "Ref. discussion in initial PR #8209, the scheduler from the BaseThingHandler constantly errored with RejectedExecutionExceptions. Wasn't able to track this down until now and went the same way as suggested for the Homematic binding in PR #1078", "author": "CSchlipp", "createdAt": "2020-12-31T11:24:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2MzcyMg==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550463722", "bodyText": "AFAIK, these happen if the scheduler is shut-down. This should only happen if OH is shut-down. Can you provide a stack trace?", "author": "fwolter", "createdAt": "2020-12-31T11:32:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDc3MjEwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550772105", "bodyText": "I don't have any stack traces for the scheduler issue anymore, but will try to reproduce this issue again during my local testing.\nIs this a blocker for merging or can it be tackled later on?", "author": "CSchlipp", "createdAt": "2021-01-01T14:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDk4NDU2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550984567", "bodyText": "The RejectedExecution exception is only a symptom of a larger issue. We should at least identify the root cause before merging it.", "author": "fwolter", "createdAt": "2021-01-03T10:06:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAxNzA3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r551017076", "bodyText": "Okay, I'll do some local tests to check if I can still reproduce this error in OH V3.x.", "author": "CSchlipp", "createdAt": "2021-01-03T15:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTUzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r551021534", "bodyText": "Stupid me - I think the error was a combination of the default scheduler shutting down and me not correctly cancelling all scheduled futures when disposing the things.\nI was missing an assignment during the initialization and therefore has some orphaned tasks still running. This is fixed now, it's either the checkConnection or the update task running, but never more than one at the same time.\nI couldn't reproduce the error anymore, nor is the thing handler anymore complaining about updated to the thing after it got disposed. Pretty confident that this solved the issue!", "author": "CSchlipp", "createdAt": "2021-01-03T15:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyMTk2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r551021966", "bodyText": "Sounds good!", "author": "fwolter", "createdAt": "2021-01-03T15:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTM5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550455396", "bodyText": "You could move this into a package called dto or append DTO to the class name to get rid of the checkstyle warning about missing NonNullByDefault annotation.", "author": "fwolter", "createdAt": "2020-12-31T10:47:16Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/data/Channel.java", "diffHunk": "@@ -0,0 +1,125 @@\n+\n+package org.openhab.binding.wlanthermo.internal.api.esp32.data;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ * Class is auto-generated from JSON using http://www.jsonschema2pojo.org/\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class Channel {", "originalCommit": "1d8198157422913730de85f90ef717e523e063bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ4ODczMA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r550488730", "bodyText": "Good to know, done!", "author": "CSchlipp", "createdAt": "2020-12-31T13:58:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1NTM5Ng=="}], "type": "inlineReview"}, {"oid": "b164d7b9377bcc6175b9fd74436ce847a5e7035e", "url": "https://github.com/openhab/openhab-addons/commit/b164d7b9377bcc6175b9fd74436ce847a5e7035e", "message": "moved auto-generated classed to dto package\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-12-31T13:56:28Z", "type": "forcePushed"}, {"oid": "8a18317f9b5e08b780468921a61707f3d62636e4", "url": "https://github.com/openhab/openhab-addons/commit/8a18317f9b5e08b780468921a61707f3d62636e4", "message": "Add support for ESP32 devices\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:54:41Z", "type": "commit"}, {"oid": "31a5d04ddc3a6b5c5530363b73518b70b46303e5", "url": "https://github.com/openhab/openhab-addons/commit/31a5d04ddc3a6b5c5530363b73518b70b46303e5", "message": "Fix Compiler warnings in V3 branch\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:54:41Z", "type": "commit"}, {"oid": "24680ba232d62a1bb28892e9632f216121a82d56", "url": "https://github.com/openhab/openhab-addons/commit/24680ba232d62a1bb28892e9632f216121a82d56", "message": "moved auto-generated classed to dto package\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:56:27Z", "type": "commit"}, {"oid": "7f85970721a73f875c0e7f888444f4bd599b88be", "url": "https://github.com/openhab/openhab-addons/commit/7f85970721a73f875c0e7f888444f4bd599b88be", "message": "fix typo\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:56:27Z", "type": "commit"}, {"oid": "56623060fc6c0346948b5ecc97627300ef287e35", "url": "https://github.com/openhab/openhab-addons/commit/56623060fc6c0346948b5ecc97627300ef287e35", "message": "fix imports\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:56:27Z", "type": "commit"}, {"oid": "dd494b93fa407635a654b993dd849c6a03a02db2", "url": "https://github.com/openhab/openhab-addons/commit/dd494b93fa407635a654b993dd849c6a03a02db2", "message": "reduce logs\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:56:27Z", "type": "commit"}, {"oid": "3021e06e7f6c899842f084c0c2cc5c8eea463b6b", "url": "https://github.com/openhab/openhab-addons/commit/3021e06e7f6c899842f084c0c2cc5c8eea463b6b", "message": "fix formatting\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:56:27Z", "type": "commit"}, {"oid": "6356ac26707482ce6a377110fd5e793d92ba2f2d", "url": "https://github.com/openhab/openhab-addons/commit/6356ac26707482ce6a377110fd5e793d92ba2f2d", "message": "removed nullable config\nfurther improved logging\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:56:27Z", "type": "commit"}, {"oid": "5855a565f6fb3de2edff5ba030b60a3fbb7ce64c", "url": "https://github.com/openhab/openhab-addons/commit/5855a565f6fb3de2edff5ba030b60a3fbb7ce64c", "message": "Only log payload if response code != 200\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:56:28Z", "type": "commit"}, {"oid": "c76ecfa4f6bcf829e1f5ab85934b3b899e5f19d5", "url": "https://github.com/openhab/openhab-addons/commit/c76ecfa4f6bcf829e1f5ab85934b3b899e5f19d5", "message": "fix compiler warnings\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:56:28Z", "type": "commit"}, {"oid": "db1da51cd9206457e0698940eb1a011df6b810b7", "url": "https://github.com/openhab/openhab-addons/commit/db1da51cd9206457e0698940eb1a011df6b810b7", "message": "fix channel naming\nSpecify Quantity Type for Temperature and Power Channels\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:56:28Z", "type": "commit"}, {"oid": "ebe40119d018ca06ae6ae62abd3bd4ceb904b10f", "url": "https://github.com/openhab/openhab-addons/commit/ebe40119d018ca06ae6ae62abd3bd4ceb904b10f", "message": "fixed checkstyle error\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:56:28Z", "type": "commit"}, {"oid": "c675da78571adef398e029f3b19d71bd371539e5", "url": "https://github.com/openhab/openhab-addons/commit/c675da78571adef398e029f3b19d71bd371539e5", "message": "Add license headers\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T14:56:28Z", "type": "commit"}, {"oid": "65628c952508831cf4eedea0f2250001f60b2c24", "url": "https://github.com/openhab/openhab-addons/commit/65628c952508831cf4eedea0f2250001f60b2c24", "message": "Rebase & Update License Headers\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T15:00:21Z", "type": "commit"}, {"oid": "65628c952508831cf4eedea0f2250001f60b2c24", "url": "https://github.com/openhab/openhab-addons/commit/65628c952508831cf4eedea0f2250001f60b2c24", "message": "Rebase & Update License Headers\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T15:00:21Z", "type": "forcePushed"}, {"oid": "d365c2394c4bdbb05a5b2df3823137f1b15a6ab4", "url": "https://github.com/openhab/openhab-addons/commit/d365c2394c4bdbb05a5b2df3823137f1b15a6ab4", "message": "Fix scheduled task not cancelled on dispose\nRevert to default scheduler\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-03T15:39:05Z", "type": "commit"}, {"oid": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "url": "https://github.com/openhab/openhab-addons/commit/aff5cb5d1d4586abbf71161d45993b63d09ab438", "message": "Retrigger Jenkins build\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-04T21:22:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNjY2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552926667", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2021-01-06T19:44:55Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/UtilEsp32.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The {@link UtilEsp32} class provides conversion functions for the WlanThermo Nano V3\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class UtilEsp32 {", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNzE2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552927169", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2021-01-06T19:45:57Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyNzQ2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552927468", "bodyText": "You should make this DecimalType instances static final fields so you can reuse them.", "author": "cpmeister", "createdAt": "2021-01-06T19:46:22Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552928641", "bodyText": "Please cache channel.get(channelId) to a local variable.", "author": "cpmeister", "createdAt": "2021-01-06T19:49:12Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODkwOA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552928908", "bodyText": "Typo?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n          \n          \n            \n                                    state = new StringType(settings.getSensors().get(channel.get(channelId).getType()).getName());", "author": "cpmeister", "createdAt": "2021-01-06T19:49:54Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDM3OTIzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r554379235", "bodyText": "No, this is referring to the \"typ\" field of the class \"Channel\", not to the \"type\" field of class \"Sensor\".\nThe naming is a bit unfortunate, but generated from the API of the device.", "author": "CSchlipp", "createdAt": "2021-01-09T11:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyOTc2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552929760", "bodyText": "Instead of assigning the return variable and then breaking, it would simplify the code in this method to just return the state immediately where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (channel.get(channelId).getTemp() == 999.0) {\n          \n          \n            \n                                        state = UnDefType.UNDEF;\n          \n          \n            \n                                    } else {\n          \n          \n            \n                                        state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n          \n          \n            \n                                    }\n          \n          \n            \n                                    break;\n          \n          \n            \n                                    if (channel.get(channelId).getTemp() == 999.0) {\n          \n          \n            \n                                        return UnDefType.UNDEF;\n          \n          \n            \n                                    }\n          \n          \n            \n                                    return new QuantityType<>(channel.get(channelId).getTemp(), unit);", "author": "cpmeister", "createdAt": "2021-01-06T19:51:51Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzMjQ3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552932477", "bodyText": "Always try to call .equals on the constant so you can avoid accidental NPEs.\nAlso this seems like a good place to use the ternary operator as well.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Unit<Temperature> unit;\n          \n          \n            \n                    if (system.getUnit().equals(\"F\")) {\n          \n          \n            \n                        unit = ImperialUnits.FAHRENHEIT;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        // Default to Celsius\n          \n          \n            \n                        unit = SIUnits.CELSIUS;\n          \n          \n            \n                    }\n          \n          \n            \n                    Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;", "author": "cpmeister", "createdAt": "2021-01-06T19:56:03Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDMwMw==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552934303", "bodyText": "You should make sure that the unit of the incoming quantity type is what you expect. Use QuantityType.toUnit to get a QuantityType instance with your expected unit.", "author": "cpmeister", "createdAt": "2021-01-06T19:59:55Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new QuantityType<>(channel.get(channelId).getMin(), unit);\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new QuantityType<>(channel.get(channelId).getMax(), unit);\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new QuantityType<>(pm.getSet(), unit);\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return false;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552934848", "bodyText": "Using the && operator would reduce the amount of nested indentation going on here.", "author": "cpmeister", "createdAt": "2021-01-06T20:01:11Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new QuantityType<>(channel.get(channelId).getMin(), unit);\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new QuantityType<>(channel.get(channelId).getMax(), unit);\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new QuantityType<>(pm.getSet(), unit);\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return false;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMax(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(1);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(0);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setColor(UtilEsp32.toHex(((StringType) command).toString()));\n+                            success = true;\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().equals(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).doubleValue());\n+                        success = true;\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        String state = ((StringType) command).toString();\n+                        if (state.equalsIgnoreCase(\"off\") || state.equalsIgnoreCase(\"manual\")\n+                                || state.equalsIgnoreCase(\"auto\")) {\n+                            pm.setTyp(state);\n+                            success = true;\n+                        }\n+                }\n+            }\n+        }\n+        return success;\n+    }\n+\n+    public String getTrigger(ChannelUID channelUID, Data data) {\n+        String trigger = null;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return null;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                if (CHANNEL_ALARM_OPENHAB.equals(channelUID.getIdWithoutGroup())) {\n+                    if (channel.get(channelId).getTemp() != 999) {", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ1MTM3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r554451375", "bodyText": "Agree, but it wouldn't make the code clearer or better to understand. I tried to structure the different functions in the command handler all in the same way, so one can easily figure out where e.g. new Triggers have to be added.\nIn the end, the compiler is optimizing it anyways, so I'd plead for leaving it more readable.", "author": "CSchlipp", "createdAt": "2021-01-09T17:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4MTU2OA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556881568", "bodyText": "Fair enough.", "author": "cpmeister", "createdAt": "2021-01-13T22:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNTE5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552935192", "bodyText": "These channel ids should be constants specified in your WlanThermoBindingConstants file.", "author": "cpmeister", "createdAt": "2021-01-06T20:02:00Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {\n+        State state = null;\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null || settings == null) {\n+            return null;\n+        }\n+\n+        System system = data.getSystem();\n+\n+        Unit<Temperature> unit;\n+        if (system.getUnit().equals(\"F\")) {\n+            unit = ImperialUnits.FAHRENHEIT;\n+        } else {\n+            // Default to Celsius\n+            unit = SIUnits.CELSIUS;\n+        }\n+\n+        List<Channel> channel = data.getChannel();\n+        if (\"system\".equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        state = new DecimalType(system.getSoc());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        state = OnOffType.from(system.getCharge());\n+                    } else {\n+                        state = UnDefType.UNDEF;\n+                    }\n+                    break;\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        state = new DecimalType(4);\n+                    } else if (dbm >= -95) {\n+                        state = new DecimalType(3);\n+                    } else if (dbm >= -105) {\n+                        state = new DecimalType(2);\n+                    } else {\n+                        state = new DecimalType(1);\n+                    }\n+                    break;\n+                case SYSTEM_RSSI:\n+                    state = new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+                    break;\n+            }\n+        } else if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel != null && channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        state = new StringType(channel.get(channelId).getName());\n+                        break;\n+                    case CHANNEL_TYP:\n+                        state = new StringType(settings.getSensors().get(channel.get(channelId).getTyp()).getName());\n+                        break;\n+                    case CHANNEL_TEMP:\n+                        if (channel.get(channelId).getTemp() == 999.0) {\n+                            state = UnDefType.UNDEF;\n+                        } else {\n+                            state = new QuantityType<>(channel.get(channelId).getTemp(), unit);\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        state = new QuantityType<>(channel.get(channelId).getMin(), unit);\n+                        break;\n+                    case CHANNEL_MAX:\n+                        state = new QuantityType<>(channel.get(channelId).getMax(), unit);\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(1));\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        state = OnOffType.from(BigInteger.valueOf(channel.get(channelId).getAlarm()).testBit(0));\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() > channel.get(channelId).getMax()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.get(channelId).getTemp() != 999\n+                                && channel.get(channelId).getTemp() < channel.get(channelId).getMin()) {\n+                            state = OnOffType.ON;\n+                        } else {\n+                            state = OnOffType.OFF;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR:\n+                        String color = channel.get(channelId).getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            state = HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.get(channelId).getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            state = new StringType(UtilEsp32.toColorName(colorHex));\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(\"pit1\")) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        state = new DecimalType(pm.getChannel());\n+                        break;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        state = new DecimalType(pm.getPid());\n+                        break;\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        state = new DecimalType(pm.getValue());\n+                        break;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        state = new QuantityType<>(pm.getSet(), unit);\n+                        break;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        state = new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    public boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        boolean success = false;\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || data == null) {\n+            return false;\n+        }\n+        List<Channel> channel = data.getChannel();\n+        if (channelUID.getId().startsWith(\"channel\")) {\n+            int channelId = Integer.parseInt(groupId.substring(\"channel\".length())) - 1;\n+            if (channel.size() > 0 && channelId < channel.size()) {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setName(command.toFullString());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMin(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.get(channelId).setMax(((QuantityType<?>) command).doubleValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(1);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.get(channelId).getAlarm()).clearBit(0);\n+                            }\n+                            channel.get(channelId).setAlarm(value.intValue());\n+                            success = true;\n+                        }\n+                        break;\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.get(channelId).setColor(UtilEsp32.toHex(((StringType) command).toString()));\n+                            success = true;\n+                        }\n+                        break;\n+                }\n+            }\n+        } else if (channelUID.getId().equals(\"pit1\")) {", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNTcyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552935729", "bodyText": "Any reason this couldn't be static final?", "author": "cpmeister", "createdAt": "2021-01-06T20:03:25Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNjIzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552936234", "bodyText": "This class is stateless, so I see no reason you couldn't make all of it's method static.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public State getState(ChannelUID channelUID, Data data, Settings settings) {\n          \n          \n            \n                public static State getState(ChannelUID channelUID, Data data, Settings settings) {", "author": "cpmeister", "createdAt": "2021-01-06T20:04:34Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public State getState(ChannelUID channelUID, Data data, Settings settings) {", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNjQzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552936434", "bodyText": "This declaration can go away once you make all the methods static.", "author": "cpmeister", "createdAt": "2021-01-06T20:05:07Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzOTMzNA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552939334", "bodyText": "Can you merge the checkConnection and update methods into a single method so that you only require a single period task to be set during initialize? Things can go wrong if you are assigning the pollingScheduler field in other threads outside of the initialize and dispose methods.", "author": "cpmeister", "createdAt": "2021-01-06T20:12:07Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDMxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552940315", "bodyText": "A communication error should be an offline status.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n          \n          \n            \n                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n          \n      \n    \n    \n  \n\nAlso if there is a credential problem here, why would you continue to send post requests for the other channels? That would just spam the logs with a bunch of failed auth attempts.", "author": "cpmeister", "createdAt": "2021-01-06T20:14:36Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDUxMw==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552940513", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n          \n          \n            \n                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"", "author": "cpmeister", "createdAt": "2021-01-06T20:15:05Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDU5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552940591", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n          \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,", "author": "cpmeister", "createdAt": "2021-01-06T20:15:15Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjA3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552942070", "bodyText": "So the mini uses \"fahrenheit\" instead of \"F\"?", "author": "cpmeister", "createdAt": "2021-01-06T20:18:55Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/WlanThermoMiniCommandHandler.java", "diffHunk": "@@ -33,7 +36,21 @@\n \n     public State getState(ChannelUID channelUID, App app) {\n         State state = null;\n-        if (\"system\".equals(channelUID.getGroupId())) {\n+\n+        String groupId = channelUID.getGroupId();\n+        if (groupId == null || app == null) {\n+            return null;\n+        }\n+\n+        Unit<Temperature> unit;\n+        if (app.getTempUnit().equals(\"fahrenheit\")) {", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDM4Mzk2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r554383969", "bodyText": "yes, the API implementations unfortunately differ between the devices.", "author": "CSchlipp", "createdAt": "2021-01-09T11:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MTAwNA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552951004", "bodyText": "Since handleCommand is called from UI threads you shouldn't make them execute potentially long running tasks like http requests. I suggest calling push asynchronously to prevent the UI from becoming unresponsive.", "author": "cpmeister", "createdAt": "2021-01-06T20:40:46Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MjA1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552952055", "bodyText": "An you exit the push method as soon as possible if you catch an InterruptedException since that means that openhab is trying to shutdown. You should not delay shutdown if at all possible.", "author": "cpmeister", "createdAt": "2021-01-06T20:43:36Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MjQ0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r552952449", "bodyText": "To exit early you will need to change this to regular for-each loop.", "author": "cpmeister", "createdAt": "2021-01-06T20:44:34Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private WlanThermoEsp32CommandHandler wlanThermoEsp32CommandHandler = new WlanThermoEsp32CommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                ScheduledFuture<?> oldScheduler = pollingScheduler;\n+                if (oldScheduler != null) {\n+                    oldScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+            if (s != null) {\n+                updateState(channelUID, s);\n+            }\n+        } else {\n+            if (wlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            if (data == null || settings == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to parse Data and/or Settings values!\");\n+                return;\n+            }\n+\n+            // Update Channels if required\n+            Map<String, String> properties = editProperties();\n+            Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+            int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+            int tempChannels = data.getChannel().size();\n+\n+            // Update properties\n+            properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                    settings.getFeatures().getBluetooth().toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+            properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+            updateProperties(properties);\n+\n+            // Update channel state\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            ScheduledFuture<?> oldScheduler = pollingScheduler;\n+            if (oldScheduler != null) {\n+                oldScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null) {\n+            return;\n+        }\n+        data.getChannel().forEach(c -> {", "originalCommit": "aff5cb5d1d4586abbf71161d45993b63d09ab438", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "609d21312e7597805de74b705a7ffd9d94615c2b", "url": "https://github.com/openhab/openhab-addons/commit/609d21312e7597805de74b705a7ffd9d94615c2b", "message": "fix constants\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-09T11:26:46Z", "type": "commit"}, {"oid": "6f1f5e95b09eb675b431d87e333149fcf9a0a72f", "url": "https://github.com/openhab/openhab-addons/commit/6f1f5e95b09eb675b431d87e333149fcf9a0a72f", "message": "make Util classes NonNullByDefault\nMake CommandHandlers static\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-09T11:50:39Z", "type": "commit"}, {"oid": "81fc86a2883a8d99f91c6534ce57b680692bfb24", "url": "https://github.com/openhab/openhab-addons/commit/81fc86a2883a8d99f91c6534ce57b680692bfb24", "message": "Rework CommandHandler Returns\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-09T16:46:16Z", "type": "commit"}, {"oid": "182345803d527b479c19f1b80125cc15ca25ad6a", "url": "https://github.com/openhab/openhab-addons/commit/182345803d527b479c19f1b80125cc15ca25ad6a", "message": "Set Thing status to OFFLINE on Communication Error\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-09T16:50:06Z", "type": "commit"}, {"oid": "00908e75982933f14f4783c274490db04a32c59d", "url": "https://github.com/openhab/openhab-addons/commit/00908e75982933f14f4783c274490db04a32c59d", "message": "Don't try to update other channels if one fails due to wrong credentials\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-09T16:55:26Z", "type": "commit"}, {"oid": "d1089575be5b391b0194bfaf615a0dfca9d6c012", "url": "https://github.com/openhab/openhab-addons/commit/d1089575be5b391b0194bfaf615a0dfca9d6c012", "message": "Exit immediately if interrupted\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-09T17:05:34Z", "type": "commit"}, {"oid": "7a32b382d5e39365e3a1cdc89f26bae61546ef58", "url": "https://github.com/openhab/openhab-addons/commit/7a32b382d5e39365e3a1cdc89f26bae61546ef58", "message": "merge checkConnection and update method\nexecute push method with scheduler\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-09T17:23:00Z", "type": "commit"}, {"oid": "b2f971b82b6db4f4accb916f8eb8bc86fd7c31c5", "url": "https://github.com/openhab/openhab-addons/commit/b2f971b82b6db4f4accb916f8eb8bc86fd7c31c5", "message": "change rssi channel to category Number\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-09T17:25:23Z", "type": "commit"}, {"oid": "a7de6f611d3430ed1fc232d321e98cfe9be1ccef", "url": "https://github.com/openhab/openhab-addons/commit/a7de6f611d3430ed1fc232d321e98cfe9be1ccef", "message": "Improve Exception handling\nFix Triggers not working anymore after code modifications\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-10T21:30:51Z", "type": "commit"}, {"oid": "c3dab0e24208697fa824c7ae766fded8d19c00bc", "url": "https://github.com/openhab/openhab-addons/commit/c3dab0e24208697fa824c7ae766fded8d19c00bc", "message": "Make Pitmaster values writeable for ESP32 and NanoV1\nImmediately update values if connected\nSupport setting HEX Colors for ESP32\nSupport Additional Pitmaster channels for ESP32\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-12T23:47:09Z", "type": "commit"}, {"oid": "c1c9ac7f28764809641c2454e814ea14e9f54724", "url": "https://github.com/openhab/openhab-addons/commit/c1c9ac7f28764809641c2454e814ea14e9f54724", "message": "Only push changes if thing is ONLINE\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-13T17:36:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1NDY1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556854657", "bodyText": "I'd think that you would return something here just to avoid throwing a WlanThermoUnknownChannelException since it is clear at this point in the code that the channel is actually known.", "author": "cpmeister", "createdAt": "2021-01-13T21:37:30Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandler.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.Color;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        List<Channel> channelList = data.getChannel();\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    if (system.getSoc() != null) {\n+                        return new DecimalType(system.getSoc());\n+                    } else {\n+                        return UnDefType.UNDEF;\n+                    }\n+                case SYSTEM_CHARGE:\n+                    if (system.getCharge() != null) {\n+                        return OnOffType.from(system.getCharge());\n+                    } else {\n+                        return UnDefType.UNDEF;\n+                    }\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList != null && channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.getSensors().get(channel.getTyp()).getName());\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilEsp32.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilEsp32.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        if (command instanceof HSBType) {\n+                            channel.setColor(UtilEsp32.toHex((HSBType) command));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PITMASTER_PREFIX.length())) - 1;\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > channelId) {\n+                Pm pm = data.getPitmaster().getPm().get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_STATE:\n+                        String state = ((StringType) command).toString();\n+                        if (state.equalsIgnoreCase(\"off\") || state.equalsIgnoreCase(\"manual\")\n+                                || state.equalsIgnoreCase(\"auto\")) {\n+                            pm.setTyp(state);\n+                            return true;\n+                        }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static String getTrigger(ChannelUID channelUID, @Nullable Data data)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                if (CHANNEL_ALARM_OPENHAB.equals(channelUID.getIdWithoutGroup())) {\n+                    if (channel.getTemp() != 999) {\n+                        if (channel.getTemp() > channel.getMax()) {\n+                            return TRIGGER_ALARM_MAX;\n+                        } else if (channel.getTemp() < channel.getMin()) {\n+                            return TRIGGER_ALARM_MIN;\n+                        }\n+                    }\n+                }", "originalCommit": "c1c9ac7f28764809641c2454e814ea14e9f54724", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1NTk1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556855953", "bodyText": "You should return at this point to that you don't continue to query the other channels.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                        }\n          \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                            return;\n          \n          \n            \n                        }", "author": "cpmeister", "createdAt": "2021-01-13T21:38:40Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                if (data == null || settings == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Failed to parse Data and/or Settings values!\");\n+                    return;\n+                }\n+\n+                // Update Channels if required\n+                Map<String, String> properties = editProperties();\n+                Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+                int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+                int tempChannels = data.getChannel().size();\n+\n+                // Update properties\n+                properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                        settings.getFeatures().getBluetooth().toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+                updateProperties(properties);\n+\n+                // Update channel state\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                            triggerChannel(channel.getUID(), trigger);\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // Push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+            }", "originalCommit": "c1c9ac7f28764809641c2454e814ea14e9f54724", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1ODc0NA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556858744", "bodyText": "see earlier comment.", "author": "cpmeister", "createdAt": "2021-01-13T21:41:15Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/WlanThermoMiniCommandHandler.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.mini.dto.builtin.*;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoMiniCommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniCommandHandler {\n+\n+    public static final String ERROR = \"er\";\n+\n+    public static State getState(ChannelUID channelUID, @Nullable App app)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || app == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        Unit<Temperature> unit = \"fahrenheit\".equals(app.getTempUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case WlanThermoBindingConstants.SYSTEM_CPU_TEMP:\n+                    if (app.getCpuTemp() == null) {\n+                        return UnDefType.UNDEF;\n+                    } else {\n+                        return new DecimalType(app.getCpuTemp());\n+                    }\n+                case WlanThermoBindingConstants.SYSTEM_CPU_LOAD:\n+                    if (app.getCpuLoad() == null) {\n+                        return UnDefType.UNDEF;\n+                    } else {\n+                        return new DecimalType(app.getCpuLoad());\n+                    }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length()));\n+            if (channelId >= 0 && channelId <= 9) {\n+                Channel channel = app.getChannel();\n+                if (channel == null) {\n+                    return UnDefType.UNDEF;\n+                }\n+                Data data = channel.getData(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case WlanThermoBindingConstants.CHANNEL_NAME:\n+                        return new StringType(data.getName());\n+                    case WlanThermoBindingConstants.CHANNEL_TEMP:\n+                        if (data.getState().equals(ERROR)) {\n+                            return UnDefType.UNDEF;\n+                        } else {\n+                            return new QuantityType<>(data.getTemp(), unit);\n+                        }\n+                    case WlanThermoBindingConstants.CHANNEL_MIN:\n+                        return new QuantityType<>(data.getTempMin(), unit);\n+                    case WlanThermoBindingConstants.CHANNEL_MAX:\n+                        return new QuantityType<>(data.getTempMax(), unit);\n+                    case WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(data.getAlert());\n+                    case WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (!data.getState().equals(ERROR) && data.getTemp() > data.getTempMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (!data.getState().equals(ERROR) && data.getTemp() < data.getTempMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case WlanThermoBindingConstants.CHANNEL_COLOR:\n+                        Color c = Color.decode(UtilMini.toHex(data.getColor()));\n+                        return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                    case WlanThermoBindingConstants.CHANNEL_COLOR_NAME:\n+                        return new StringType(data.getColor());\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_PREFIX)) {\n+            Pit pit;\n+            if (groupId.equals(CHANNEL_PITMASTER_1)) {\n+                pit = app.getPit();\n+            } else if (groupId.equals(CHANNEL_PITMASTER_2)) {\n+                pit = app.getPit2();\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+            if (pit == null || !pit.getEnabled()) {\n+                return UnDefType.UNDEF;\n+            }\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED:\n+                    return OnOffType.from(pit.getEnabled());\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT:\n+                    return new DecimalType(pit.getCurrent());\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT:\n+                    return new QuantityType<>(pit.getSetpoint(), unit);\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE:\n+                    return new DecimalType(pit.getControlOut());\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN:\n+                    return OnOffType.from(pit.getOpenLid().equals(\"True\"));\n+                case WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID:\n+                    return new DecimalType(pit.getCh());\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static String getTrigger(ChannelUID channelUID, @Nullable App app)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || app == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelId >= 0 && channelId <= 9) {\n+                Channel channel = app.getChannel();\n+                if (channel == null) {\n+                    throw new WlanThermoInputException();\n+                }\n+                Data data = channel.getData(channelId);\n+                if (CHANNEL_ALARM_OPENHAB.equals(channelUID.getIdWithoutGroup())) {\n+                    if (!data.getState().equals(ERROR)) {\n+                        if (data.getTemp() > data.getTempMax()) {\n+                            return TRIGGER_ALARM_MAX;\n+                        } else if (data.getTemp() < data.getTempMin()) {\n+                            return TRIGGER_ALARM_MIN;\n+                        }\n+                    }\n+                }", "originalCommit": "c1c9ac7f28764809641c2454e814ea14e9f54724", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2NDg2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556864869", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                        }\n          \n          \n            \n                            logger.debug(\"Push interrupted. {}\", e.getMessage());\n          \n          \n            \n                            return;\n          \n          \n            \n                        }", "author": "cpmeister", "createdAt": "2021-01-13T21:46:58Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1Handler.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoV1Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoV1Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoNanoV1Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                // Update channels\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoNanoV1CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoNanoV1CommandHandler.getTrigger(channel.getUID(), data);\n+                            triggerChannel(channel.getUID(), trigger);\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoNanoV1CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoNanoV1CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+            }", "originalCommit": "c1c9ac7f28764809641c2454e814ea14e9f54724", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MDUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556870526", "bodyText": "Where did you get these numbers from? To my knowledge a dbm of -95 is pretty much the noise floor for most wireless applications.", "author": "cpmeister", "createdAt": "2021-01-13T21:51:50Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }", "originalCommit": "c1c9ac7f28764809641c2454e814ea14e9f54724", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA2OTM4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557069389", "bodyText": "As I couldn't find any generic conversion function, I've checked the source code of the WlanThermo device and took the same numbers.\nBenefit: The signal indicator now gives the same number of bars as shown on the display of the device.", "author": "CSchlipp", "createdAt": "2021-01-14T06:29:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MDUyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwMjYwNg==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557702606", "bodyText": "Well if it matches what is shown on the device then I guess that is the correct implementation. Keep it as is then.", "author": "cpmeister", "createdAt": "2021-01-14T21:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MDUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MTg0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556871842", "bodyText": "You should make sure that the units are converted to what you expect them to be. Use QuantityType.toUnit to handle the conversion.", "author": "cpmeister", "createdAt": "2021-01-13T21:53:05Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        pm.setChannel(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        pm.setPid(((QuantityType<?>) command).intValue());\n+                        return true;\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        pm.setSet(((QuantityType<?>) command).toUnit(unit).doubleValue());", "originalCommit": "c1c9ac7f28764809641c2454e814ea14e9f54724", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA2OTg1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557069851", "bodyText": "That already included in all channels, where unit conversion might be required.\nThe PITMASTER_PIDPROFILE channel however only contains an integer reference to a profile, so no conversion needed.", "author": "CSchlipp", "createdAt": "2021-01-14T06:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MTg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxMzgxOA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557713818", "bodyText": "If PITMASTER_PIDPROFILE is just a integer reference then why does it need to be a QuantityType?\nSame question for CHANNEL_PITMASTER_CHANNEL_ID.", "author": "cpmeister", "createdAt": "2021-01-14T21:36:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MTg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNzY1OA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557717658", "bodyText": "Ah, now I understood what you meant.\nReverted to DecimalType.", "author": "CSchlipp", "createdAt": "2021-01-14T21:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MzQ4OA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556873488", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {\n          \n          \n            \n                    } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {", "author": "cpmeister", "createdAt": "2021-01-13T21:54:33Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, @Nullable Data data, @Nullable Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        if (channelUID.getGroupId() == null || data == null || settings == null) {\n+            throw new WlanThermoInputException();\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(UtilNano.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, @Nullable Data data) {\n+        if (channelUID.getGroupId() == null || data == null || data.getSystem() == null) {\n+            return false;\n+        }\n+\n+        String groupId = channelUID.getGroupId();\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId <= channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMin(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_MAX:\n+                        if (command instanceof QuantityType) {\n+                            channel.setMax(((QuantityType<?>) command).toUnit(unit).doubleValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_DEVICE:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(1);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(1);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_ALARM_PUSH:\n+                        if (command instanceof OnOffType) {\n+                            BigInteger value;\n+                            if (command == OnOffType.ON) {\n+                                value = BigInteger.valueOf(channel.getAlarm()).setBit(0);\n+                            } else {\n+                                value = BigInteger.valueOf(channel.getAlarm()).clearBit(0);\n+                            }\n+                            channel.setAlarm(value.intValue());\n+                            return true;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setColor(UtilNano.toHex(((StringType) command).toString()));\n+                            return true;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().equals(CHANNEL_PITMASTER_1)) {", "originalCommit": "c1c9ac7f28764809641c2454e814ea14e9f54724", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA3MDc5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557070795", "bodyText": "That's actually a difference in the NanoV1 device, it does only provide a single Pitmaster channel.\nTherefore, I can directly check for the whole id instead of checking the prefix first and then obtaining the actual channel numbers.", "author": "CSchlipp", "createdAt": "2021-01-14T06:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MzQ4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcwODQ0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557708443", "bodyText": "But just a couple of lines down you are expecting channelUID.getIdWithoutGroup() to return different results? Wouldn't the CHANNEL_PITMASTER_1 be the only result that could be returned? As the code is written now the switch statement serves no purpose.", "author": "cpmeister", "createdAt": "2021-01-14T21:25:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MzQ4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNTgxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557715811", "bodyText": "True, mixed up group and ID. Fixed.", "author": "CSchlipp", "createdAt": "2021-01-14T21:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3MzQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3NzQ3MA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r556877470", "bodyText": "Why are you changing the properties every time? Thing properties should generally be considered immutable characteristics of the device so you should only need to update it when something changes.", "author": "cpmeister", "createdAt": "2021-01-13T21:58:04Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                if (data == null || settings == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Failed to parse Data and/or Settings values!\");\n+                    return;\n+                }\n+\n+                // Update Channels if required\n+                Map<String, String> properties = editProperties();\n+                Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+                int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+                int tempChannels = data.getChannel().size();\n+\n+                // Update properties\n+                properties.put(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                        settings.getFeatures().getBluetooth().toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+                updateProperties(properties);", "originalCommit": "c1c9ac7f28764809641c2454e814ea14e9f54724", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzA4MjgzMA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557082830", "bodyText": "The number of temperature and pitmaster channels might change during operation as the user attaches bluetooth sensors.\nOn the one hand, I do understand that properties should usually be immutable, but on the other hand I don't think that having the number of attached sensors is worth an own channel.\nI've changed the code so that only the channel number properties are updated, is that okay for you?", "author": "CSchlipp", "createdAt": "2021-01-14T07:05:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3NzQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzkyMDEwNA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557920104", "bodyText": "It wasn't really what I had in mind but it doesn't really sound like you can avoid updating the properties. So I guess this is fine.", "author": "cpmeister", "createdAt": "2021-01-15T06:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg3NzQ3MA=="}], "type": "inlineReview"}, {"oid": "cf34d9c6431cd097e900c307a6f31a2e36a54b97", "url": "https://github.com/openhab/openhab-addons/commit/cf34d9c6431cd097e900c307a6f31a2e36a54b97", "message": "Improve Triggers\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-14T07:02:30Z", "type": "commit"}, {"oid": "eb1c960f6b0a76946a505ad85f39f46f5c344a96", "url": "https://github.com/openhab/openhab-addons/commit/eb1c960f6b0a76946a505ad85f39f46f5c344a96", "message": "reduce updates to properties\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-14T07:03:18Z", "type": "commit"}, {"oid": "0aaff6395abedf04f6d586a4729d8f0782e98239", "url": "https://github.com/openhab/openhab-addons/commit/0aaff6395abedf04f6d586a4729d8f0782e98239", "message": "return early on InterruptedException\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-14T07:03:36Z", "type": "commit"}, {"oid": "e34237471e1a1396febb22f8fca0bc0f5feca604", "url": "https://github.com/openhab/openhab-addons/commit/e34237471e1a1396febb22f8fca0bc0f5feca604", "message": "fix pitmaster getState\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-14T21:39:22Z", "type": "commit"}, {"oid": "2b7f277653a110317a13579a5541085a4c0c4fe8", "url": "https://github.com/openhab/openhab-addons/commit/2b7f277653a110317a13579a5541085a4c0c4fe8", "message": "Changed QuantityType to DecimalType for channels without unit\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-14T21:43:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNDU2MA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557714560", "bodyText": "This code is nearly identical to the code right above it. Please consider refactoring this into a separate method.", "author": "cpmeister", "createdAt": "2021-01-14T21:37:35Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1Handler.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_NONE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoV1Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoV1Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoNanoV1Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                // Update channels\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoNanoV1CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoNanoV1CommandHandler.getTrigger(channel.getUID(), data);\n+                            if (!trigger.equals(TRIGGER_NONE)) {\n+                                triggerChannel(channel.getUID(), trigger);\n+                            }\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoNanoV1CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoNanoV1CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+                return;\n+            }\n+        }\n+\n+        // push update for pitmaster channels\n+        try {\n+            String json = gson.toJson(data.getPitmaster().getPm());\n+            URI uri = config.getUri(\"/setpitmaster\");\n+            int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                    .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+            if (status == 401) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+            } else if (status != 200) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update pitmaster channel on device, Statuscode \" + status + \" on URI \"\n+                                + uri.toString());\n+                logger.debug(\"Payload sent: {}\", json);\n+            } else {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update pitmaster channel on device: \" + e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Push interrupted. {}\", e.getMessage());\n+        }", "originalCommit": "0aaff6395abedf04f6d586a4729d8f0782e98239", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcyODU0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557728541", "bodyText": "Done", "author": "CSchlipp", "createdAt": "2021-01-14T22:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNDU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcxNzc5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r557717795", "bodyText": "Same suggestion here.", "author": "cpmeister", "createdAt": "2021-01-14T21:44:00Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32Handler.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_NONE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoExtendedConfiguration;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoEsp32Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoEsp32Handler.class);\n+\n+    private WlanThermoExtendedConfiguration config = new WlanThermoExtendedConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final Gson gson = new Gson();\n+    private @Nullable Data data = new Data();\n+    private @Nullable Settings settings = new Settings();\n+\n+    public WlanThermoEsp32Handler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (!config.getUsername().isEmpty() && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            try {\n+                // Update objects with data from device\n+                String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+                data = gson.fromJson(json, Data.class);\n+                logger.debug(\"Received at /data: {}\", json);\n+                json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+                settings = gson.fromJson(json, Settings.class);\n+                logger.debug(\"Received at /settings: {}\", json);\n+\n+                if (data == null || settings == null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Failed to parse Data and/or Settings values!\");\n+                    return;\n+                }\n+\n+                // Update Channels if required\n+                Map<String, String> properties = editProperties();\n+                Boolean pmEnabled = settings.getFeatures().getBluetooth();\n+                int pmChannels = pmEnabled ? data.getPitmaster().getPm().size() : 0;\n+                int tempChannels = data.getChannel().size();\n+\n+                // Update properties\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_MODEL, settings.getDevice().getDevice());\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_SERIAL, settings.getDevice().getSerial());\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_ESP32_BT_ENABLED,\n+                        settings.getFeatures().getBluetooth().toString());\n+                properties.putIfAbsent(WlanThermoBindingConstants.PROPERTY_ESP32_PM_ENABLED, pmEnabled.toString());\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_TEMP_CHANNELS, String.valueOf(tempChannels));\n+                properties.put(WlanThermoBindingConstants.PROPERTY_ESP32_PM_CHANNELS, String.valueOf(pmChannels));\n+                updateProperties(properties);\n+\n+                // Update channel state\n+                for (Channel channel : thing.getChannels()) {\n+                    try {\n+                        State state = WlanThermoEsp32CommandHandler.getState(channel.getUID(), data, settings);\n+                        updateState(channel.getUID(), state);\n+                    } catch (WlanThermoUnknownChannelException e) {\n+                        // if we could not obtain a state, try trigger instead\n+                        try {\n+                            String trigger = WlanThermoEsp32CommandHandler.getTrigger(channel.getUID(), data);\n+                            if (!trigger.equals(TRIGGER_NONE)) {\n+                                triggerChannel(channel.getUID(), trigger);\n+                            }\n+                        } catch (WlanThermoUnknownChannelException e1) {\n+                            logger.debug(\"{}\", e.getMessage());\n+                        }\n+                    }\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Update failed: \" + e.getMessage());\n+                for (Channel channel : thing.getChannels()) {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Update interrupted. {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            try {\n+                State s = WlanThermoEsp32CommandHandler.getState(channelUID, data, settings);\n+                updateState(channelUID, s);\n+            } catch (WlanThermoException e) {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        } else {\n+            if (WlanThermoEsp32CommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                scheduler.execute(this::push);\n+            } else {\n+                logger.debug(\"Could not handle command of type {} for channel {}!\",\n+                        command.getClass().toGenericString(), channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void push() {\n+        if (data == null || this.thing.getStatus() != ThingStatus.ONLINE) {\n+            return;\n+        }\n+\n+        // Push update for sensor channels\n+        for (org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    break;\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.debug(\"Payload sent: {}\", json);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device: \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Push interrupted. {}\", e.getMessage());\n+                return;\n+            }\n+        }\n+\n+        // push update for pitmaster channels\n+        try {\n+            String json = gson.toJson(data.getPitmaster().getPm());\n+            URI uri = config.getUri(\"/setpitmaster\");\n+            int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                    .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+            if (status == 401) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+            } else if (status != 200) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update pitmaster channel on device, Statuscode \" + status + \" on URI \"\n+                                + uri.toString());\n+                logger.debug(\"Payload sent: {}\", json);\n+            } else {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update pitmaster channel on device: \" + e.getMessage());\n+        } catch (InterruptedException e) {\n+            logger.debug(\"Push interrupted. {}\", e.getMessage());\n+        }", "originalCommit": "0aaff6395abedf04f6d586a4729d8f0782e98239", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "89a24245aa707305935fce86cec41b3ed986dfb6", "url": "https://github.com/openhab/openhab-addons/commit/89a24245aa707305935fce86cec41b3ed986dfb6", "message": "extract POST request to new method\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-14T22:04:53Z", "type": "commit"}, {"oid": "26aef3fccc1c5dd2add505b9d2f1ea6b632e034f", "url": "https://github.com/openhab/openhab-addons/commit/26aef3fccc1c5dd2add505b9d2f1ea6b632e034f", "message": "spotless:apply\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-15T07:36:42Z", "type": "commit"}, {"oid": "a273604b8cba86e0b5d410e6feb5875592ab79e5", "url": "https://github.com/openhab/openhab-addons/commit/a273604b8cba86e0b5d410e6feb5875592ab79e5", "message": "Add Unit Tests\nEnsure Gson objects are NonNull\nGenerify Handlers\nGenerify Utils\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-17T16:43:58Z", "type": "commit"}, {"oid": "d7c3d69678bd102e37d16a689eb28c222cfacc59", "url": "https://github.com/openhab/openhab-addons/commit/d7c3d69678bd102e37d16a689eb28c222cfacc59", "message": "Check if pitmaster is enabled for ESP32 devices\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-17T17:05:16Z", "type": "commit"}, {"oid": "483da477f329def4b5438d2ef1e3839552c901a0", "url": "https://github.com/openhab/openhab-addons/commit/483da477f329def4b5438d2ef1e3839552c901a0", "message": "Revert RSSI conversion for NanoV1 devices\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-17T17:12:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MDQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559240466", "bodyText": "Always pass the cause exceptions into new exceptions you throw.\nPlease add such a constructor is one doesn't already exist.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new WlanThermoInputException();\n          \n          \n            \n                        throw new WlanThermoInputException(e);\n          \n      \n    \n    \n  \n\nAlso, I don't think that a WlanThermoInputException is the correct thing to throw here if you get a TimeoutException. The WlanThermoInputException message implies incorrect data but a Timeout is not related to that at all, so the exception message would be misleading. Consider having the doGet method throw WlanThermoException instead so you can throw broader types of exceptions.", "author": "cpmeister", "createdAt": "2021-01-17T21:24:35Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandler.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoUtil.requireNonNull;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class WlanThermoHandler extends BaseThingHandler {\n+\n+    private final boolean extendedConfig;\n+    protected WlanThermoConfiguration config = new WlanThermoConfiguration();\n+    protected final HttpClient httpClient;\n+    protected final Logger logger = LoggerFactory.getLogger(WlanThermoHandler.class);\n+    protected final Gson gson = new Gson();\n+    @Nullable\n+    protected ScheduledFuture<?> pollingScheduler;\n+\n+    public WlanThermoHandler(Thing thing, HttpClient httpClient, boolean extendedConfig) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.extendedConfig = extendedConfig;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (extendedConfig) {\n+                config = getConfigAs(WlanThermoExtendedConfiguration.class);\n+                WlanThermoExtendedConfiguration extendedConfig = (WlanThermoExtendedConfiguration) config;\n+                if (extendedConfig.getUsername().isEmpty() && !extendedConfig.getPassword().isEmpty()) {\n+                    AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                    authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                            extendedConfig.getUsername(), extendedConfig.getPassword()));\n+                }\n+            } else {\n+                config = getConfigAs(WlanThermoConfiguration.class);\n+            }\n+            pollingScheduler = scheduler.scheduleWithFixedDelay(this::checkConnectionAndUpdate, 0,\n+                    config.getPollingInterval(), TimeUnit.SECONDS);\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> oldScheduler = pollingScheduler;\n+        if (oldScheduler != null) {\n+            boolean stopped = oldScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        pollingScheduler = null;\n+    }\n+\n+    protected void checkConnectionAndUpdate() {\n+        if (this.thing.getStatus() != ThingStatus.ONLINE) {\n+            try {\n+                if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    // rerun immediately to update state\n+                    checkConnectionAndUpdate();\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"WlanThermo not found under given address.\");\n+                }\n+            } catch (URISyntaxException | ExecutionException | TimeoutException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Could not connect to WlanThermo at \" + config.getIpAddress() + \": \" + e.getMessage());\n+            } catch (InterruptedException e) {\n+                logger.debug(\"Connection check interrupted. {}\", e.getMessage());\n+            }\n+        } else {\n+            pull();\n+        }\n+    }\n+\n+    protected boolean doPost(String endpoint, String json) throws InterruptedException {\n+        try {\n+            URI uri = config.getUri(endpoint);\n+            int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                    .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+            if (status == 401) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                return false;\n+            } else if (status != 200) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                logger.debug(\"Payload sent: {}\", json);\n+                // Still continue to try next channel\n+                return true;\n+            } else {\n+                updateStatus(ThingStatus.ONLINE);\n+                return true;\n+            }\n+        } catch (TimeoutException | ExecutionException | URISyntaxException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Failed to update channel on device: \" + e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    protected <T> T doGet(String endpoint, Class<T> object) throws InterruptedException, WlanThermoInputException {\n+        try {\n+            String json = httpClient.GET(config.getUri(endpoint)).getContentAsString();\n+            logger.debug(\"Received at {}: {}\", endpoint, json);\n+            return requireNonNull(gson.fromJson(json, object));\n+        } catch (URISyntaxException | ExecutionException | TimeoutException | WlanThermoException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Update failed: \" + e.getMessage());\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            throw new WlanThermoInputException();", "originalCommit": "483da477f329def4b5438d2ef1e3839552c901a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM0NzAxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559347019", "bodyText": "A Timeout would however result in invalid input data for the binding.\nChanged it anyways.", "author": "CSchlipp", "createdAt": "2021-01-18T06:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MDQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MTU2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559241569", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                protected ScheduledFuture<?> pollingScheduler;\n          \n          \n            \n                protected @Nullable ScheduledFuture<?> pollingScheduler;", "author": "cpmeister", "createdAt": "2021-01-17T21:33:52Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandler.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoUtil.requireNonNull;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.openhab.core.thing.*;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public abstract class WlanThermoHandler extends BaseThingHandler {\n+\n+    private final boolean extendedConfig;\n+    protected WlanThermoConfiguration config = new WlanThermoConfiguration();\n+    protected final HttpClient httpClient;\n+    protected final Logger logger = LoggerFactory.getLogger(WlanThermoHandler.class);\n+    protected final Gson gson = new Gson();\n+    @Nullable\n+    protected ScheduledFuture<?> pollingScheduler;", "originalCommit": "483da477f329def4b5438d2ef1e3839552c901a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MTkyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559241925", "bodyText": "Please put test data in their own files and then load them in runtime. You can do this by loading the resources from the ClassLoader.", "author": "cpmeister", "createdAt": "2021-01-17T21:36:41Z", "path": "bundles/org.openhab.binding.wlanthermo/src/test/java/org/openhab/binding/wlanthermo/internal/api/esp32/WlanThermoEsp32CommandHandlerTest.java", "diffHunk": "@@ -0,0 +1,601 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.esp32;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_NONE;\n+\n+import java.awt.*;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.function.Executable;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUtil;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.esp32.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoEsp32CommandHandlerTest} class tests the {@link WlanThermoEsp32CommandHandler}\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+class WlanThermoEsp32CommandHandlerTest {\n+\n+    private static final ThingUID THING_UID = new ThingUID(\"wlanthermo\", \"esp32\", \"test\");\n+\n+    //@formatter:off\n+    private static final String DATA_INPUT_JSON = \"{\\n\" +", "originalCommit": "483da477f329def4b5438d2ef1e3839552c901a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MjQ4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559242487", "bodyText": "Is this fall through intentional?", "author": "cpmeister", "createdAt": "2021-01-17T21:41:07Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/WlanThermoNanoV1CommandHandler.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.*;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoUtil.requireNonNull;\n+\n+import java.awt.*;\n+import java.math.BigInteger;\n+import java.util.List;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoInputException;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoUnknownChannelException;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Channel;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.Pm;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.data.System;\n+import org.openhab.binding.wlanthermo.internal.api.nano.dto.settings.Settings;\n+import org.openhab.core.library.types.*;\n+import org.openhab.core.library.unit.ImperialUnits;\n+import org.openhab.core.library.unit.SIUnits;\n+import org.openhab.core.library.unit.Units;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+\n+/**\n+ * The {@link WlanThermoNanoV1CommandHandler} is responsible for mapping the Commands to the respective data fields\n+ * of the API.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoV1CommandHandler {\n+\n+    public static State getState(ChannelUID channelUID, Data data, Settings settings)\n+            throws WlanThermoUnknownChannelException, WlanThermoInputException {\n+        String groupId = requireNonNull(channelUID.getGroupId());\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+        List<Channel> channelList = data.getChannel();\n+\n+        if (SYSTEM.equals(groupId)) {\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case SYSTEM_SOC:\n+                    return new DecimalType(system.getSoc());\n+                case SYSTEM_CHARGE:\n+                    return OnOffType.from(system.getCharge());\n+                case SYSTEM_RSSI_SIGNALSTRENGTH:\n+                    int dbm = system.getRssi();\n+                    if (dbm >= -80) {\n+                        return SIGNAL_STRENGTH_4;\n+                    } else if (dbm >= -95) {\n+                        return SIGNAL_STRENGTH_3;\n+                    } else if (dbm >= -105) {\n+                        return SIGNAL_STRENGTH_2;\n+                    } else {\n+                        return SIGNAL_STRENGTH_1;\n+                    }\n+                case SYSTEM_RSSI:\n+                    return new QuantityType<>(system.getRssi(), Units.DECIBEL_MILLIWATTS);\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        return new StringType(channel.getName());\n+                    case CHANNEL_TYP:\n+                        return new StringType(settings.sensors.get(channel.getTyp()));\n+                    case CHANNEL_TEMP:\n+                        return channel.getTemp() == 999.0 ? UnDefType.UNDEF\n+                                : new QuantityType<>(channel.getTemp(), unit);\n+                    case CHANNEL_MIN:\n+                        return new QuantityType<>(channel.getMin(), unit);\n+                    case CHANNEL_MAX:\n+                        return new QuantityType<>(channel.getMax(), unit);\n+                    case CHANNEL_ALARM_DEVICE:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(1));\n+                    case CHANNEL_ALARM_PUSH:\n+                        return OnOffType.from(BigInteger.valueOf(channel.getAlarm()).testBit(0));\n+                    case CHANNEL_ALARM_OPENHAB_HIGH:\n+                        if (channel.getTemp() != 999 && channel.getTemp() > channel.getMax()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_ALARM_OPENHAB_LOW:\n+                        if (channel.getTemp() != 999 && channel.getTemp() < channel.getMin()) {\n+                            return OnOffType.ON;\n+                        } else {\n+                            return OnOffType.OFF;\n+                        }\n+                    case CHANNEL_COLOR:\n+                        String color = channel.getColor();\n+                        if (color != null && !color.isEmpty()) {\n+                            Color c = Color.decode(color);\n+                            return HSBType.fromRGB(c.getRed(), c.getGreen(), c.getBlue());\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                    case CHANNEL_COLOR_NAME:\n+                        String colorHex = channel.getColor();\n+                        if (colorHex != null && !colorHex.isEmpty()) {\n+                            return new StringType(WlanThermoNanoV1Util.toColorName(colorHex));\n+                        } else {\n+                            return UnDefType.UNDEF;\n+                        }\n+                }\n+            }\n+        } else if (channelUID.getId().startsWith(CHANNEL_PITMASTER_1)) {\n+            if (data.getPitmaster() != null && data.getPitmaster().getPm() != null\n+                    && data.getPitmaster().getPm().size() > 0) {\n+                Pm pm = data.getPitmaster().getPm().get(0);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_PITMASTER_CHANNEL_ID:\n+                        return new DecimalType(pm.getChannel());\n+                    case CHANNEL_PITMASTER_PIDPROFILE:\n+                        return new DecimalType(pm.getPid());\n+                    case CHANNEL_PITMASTER_DUTY_CYCLE:\n+                        return new DecimalType(pm.getValue());\n+                    case CHANNEL_PITMASTER_SETPOINT:\n+                        return new QuantityType<>(pm.getSet(), unit);\n+                    case CHANNEL_PITMASTER_STATE:\n+                        return new StringType(pm.getTyp());\n+                }\n+            } else {\n+                return UnDefType.UNDEF;\n+            }\n+        }\n+        throw new WlanThermoUnknownChannelException(channelUID);\n+    }\n+\n+    public static boolean setState(ChannelUID channelUID, Command command, Data data) {\n+        String groupId;\n+        try {\n+            groupId = requireNonNull(channelUID.getGroupId());\n+        } catch (WlanThermoInputException e) {\n+            return false;\n+        }\n+\n+        List<Channel> channelList = data.getChannel();\n+        System system = data.getSystem();\n+        Unit<Temperature> unit = \"F\".equals(system.getUnit()) ? ImperialUnits.FAHRENHEIT : SIUnits.CELSIUS;\n+\n+        if (channelUID.getId().startsWith(CHANNEL_PREFIX)) {\n+            int channelId = Integer.parseInt(groupId.substring(CHANNEL_PREFIX.length())) - 1;\n+            if (channelList.size() > 0 && channelId < channelList.size()) {\n+                Channel channel = channelList.get(channelId);\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case CHANNEL_NAME:\n+                        if (command instanceof StringType) {\n+                            channel.setName(command.toFullString());\n+                            return true;\n+                        }\n+                    case CHANNEL_MIN:", "originalCommit": "483da477f329def4b5438d2ef1e3839552c901a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTM0NzE4NA==", "url": "https://github.com/openhab/openhab-addons/pull/9579#discussion_r559347184", "bodyText": "No, this bug was introduced by the change of the return handling. Thanks, fixed.", "author": "CSchlipp", "createdAt": "2021-01-18T06:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTI0MjQ4Nw=="}], "type": "inlineReview"}, {"oid": "1270e69000d427c6eefe94a1462b8c1f20c6a77e", "url": "https://github.com/openhab/openhab-addons/commit/1270e69000d427c6eefe94a1462b8c1f20c6a77e", "message": "fix Fallthrough bug introduced by change of return handling\nmove test json to resources\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-18T06:48:57Z", "type": "commit"}, {"oid": "00c450f4e2f81ed1cf6d0b02a3dc41c6434b098f", "url": "https://github.com/openhab/openhab-addons/commit/00c450f4e2f81ed1cf6d0b02a3dc41c6434b098f", "message": "remove unused throws\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-18T06:53:55Z", "type": "commit"}, {"oid": "7b15ff901766669c455bc69a2c9e55bdf33da8db", "url": "https://github.com/openhab/openhab-addons/commit/7b15ff901766669c455bc69a2c9e55bdf33da8db", "message": "remove unused import\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2021-01-18T21:26:14Z", "type": "commit"}]}