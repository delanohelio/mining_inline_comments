{"pr_number": 6985, "pr_title": "[shelly] Support for Duo, EM3, DW, Smoke, Addon; new CoAP-based updates; bug fixes", "pr_createdAt": "2020-02-09T13:48:20Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/6985", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTAyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402669026", "bodyText": "Shouldn't it already be stopped as part of the handler getting disposed?\nWhy do you need to call this here?", "author": "cpmeister", "createdAt": "2020-04-03T00:21:17Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -130,6 +142,7 @@ public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n     @Override\n     protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n         if (thingHandler instanceof ShellyBaseHandler) {\n+            ((ShellyBaseHandler) thingHandler).stop();", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzg4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403433886", "bodyText": "Sometimes I see \"xxx, but thing handled is already disposed\". Maybe this is a timing issue when shutting down the thing, but another event comes in at that time. Put it in just to avoid this potential scenario, but I could also remove it", "author": "markus7017", "createdAt": "2020-04-04T06:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NDUyMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403684520", "bodyText": "removed it", "author": "markus7017", "createdAt": "2020-04-05T10:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTM2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402669362", "bodyText": "Why are you suppressing warnings here?", "author": "cpmeister", "createdAt": "2020-04-03T00:22:31Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNTUyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403435527", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-04T07:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402669991", "bodyText": "Why do you need to suppress warnings? Also isn't apiResult a non-null field?", "author": "cpmeister", "createdAt": "2020-04-03T00:24:40Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty()\n+                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n+                : \"\";\n+\n+        if (e != null) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n+                        getString(super.getMessage()));\n+            } else {\n+                message = getString(super.getMessage());\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return (e != null) && (e.getClass() == ShellyApiException.class);\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = e != null ? e.getClass() : null;\n+        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n+                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public boolean isHttpAccessUnauthorized() {\n+        return apiResult != null ? apiResult.isHttpAccessUnauthorized() : false;\n+    }\n+\n+    public boolean isUnknownHost() {\n+        return (e != null) && (e.getClass() == MalformedURLException.class);\n+    }\n+\n+    public boolean isMalformedURL() {\n+        return (e != null) && (e.getClass() == UnknownHostException.class);\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public ShellyApiResult getApiResult() {\n+        return apiResult != null ? apiResult : new ShellyApiResult();\n+    }", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNTkzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403435939", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-04T07:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2OTk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDUxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670514", "bodyText": "Can this be made final? Making this final would make some of your null checks satisfy the null checker.", "author": "cpmeister", "createdAt": "2020-04-03T00:26:40Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNTU5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403435590", "bodyText": "re-factored", "author": "markus7017", "createdAt": "2020-04-04T07:02:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDYzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670631", "bodyText": "You can remove this.", "author": "cpmeister", "createdAt": "2020-04-03T00:27:06Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty()\n+                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n+                : \"\";\n+\n+        if (e != null) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n+                        getString(super.getMessage()));\n+            } else {\n+                message = getString(super.getMessage());\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return (e != null) && (e.getClass() == ShellyApiException.class);\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = e != null ? e.getClass() : null;\n+        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n+                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    @SuppressWarnings(\"null\")", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNTYwNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403435604", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-04T07:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDcyNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670724", "bodyText": "The null check isn't needed here.", "author": "cpmeister", "createdAt": "2020-04-03T00:27:24Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private @Nullable Exception e = null;\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+\n+    public ShellyApiException() {\n+        super();\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result) {\n+        apiResult = result;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return getString(super.getMessage());\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty()\n+                ? MessageFormat.format(\", result = '{0}'\", apiResult.response)\n+                : \"\";\n+\n+        if (e != null) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"API Timeout or device unreachable ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = MessageFormat.format(\"{0} {1}\", getString(super.getClass().toString()),\n+                        getString(super.getMessage()));\n+            } else {\n+                message = getString(super.getMessage());\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return (e != null) && (e.getClass() == ShellyApiException.class);\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = e != null ? e.getClass() : null;\n+        return (apiResult.httpCode == -1) || (e != null) && (extype != null)\n+                && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public boolean isHttpAccessUnauthorized() {\n+        return apiResult != null ? apiResult.isHttpAccessUnauthorized() : false;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436005", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-04T07:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDgyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402670826", "bodyText": "needed?", "author": "cpmeister", "createdAt": "2020-04-03T00:27:47Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java", "diffHunk": "@@ -333,21 +445,34 @@\n         public ShellySettingsWiFiNetwork wifiSta1;\n         // public ShellySettingsMqtt mqtt; // not used for now\n         // public ShellySettingsSntp sntp; // not used for now\n+        public ShellySettingsCoiot coiot; // Firmware 1.6+\n         public ShellySettingsLogin login;\n         @SerializedName(\"pin_code\")\n         public String pinCode;\n         @SerializedName(\"coiot_execute_enable\")\n         public Boolean coiotExecuteEnable;\n         public String name;\n+        public Boolean discoverable; // FW 1.6+\n         public String fw;\n         @SerializedName(\"build_info\")\n         ShellySettingsBuildInfo buildInfo;\n         ShellyStatusCloud cloud;\n+        @SerializedName(\"sleep_mode\")\n+        public ShellySensorSleepMode sleepMode; // FW 1.6\n+\n         public String timezone;\n         public Double lat;\n         public Double lng;\n         public Boolean tzautodetect;\n         public String time;\n+        // @SerializedName(\"tz_utc_offset\")\n+        // public Integer tzUTCOoffset; // FW 1.6+\n+        // @SerializedName(\"tz_dst\")\n+        // public Boolean tzDdst; // FW 1.6+\n+        // @SerializedName(\"tz_dst_auto\")\n+        // public Boolean tzDstAuto; // FW 1.6+\n+        // public Long unixtime; // FW 1.6+", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MjE4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403442185", "bodyText": "Want to keep those, I want to make sure that the Java side matches the JSON at best as possible to see when new elements are included in a new firmware version", "author": "markus7017", "createdAt": "2020-04-04T08:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTI5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402671291", "bodyText": "You mention 3 sensors fields but there is only one sensor field in this class.", "author": "cpmeister", "createdAt": "2020-04-03T00:29:13Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java", "diffHunk": "@@ -612,20 +762,39 @@\n             public ShellyShortTemp sensor3;\n         }\n \n+        public static class ShellyExtHumidity {\n+            public static class ShellyShortHum {\n+                public Double hum; // Humidity reading of sensor 0, percent\n+            }\n+\n+            // Shelly 1/1PM have up to 3 sensors\n+            // for whatever reasons it's not an array, but 3 independent elements", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436154", "bodyText": "correct sensor1, sensor2, sensor3 as declared below\njust want to mention that I would expect a JSON array, but they added 3 values instead", "author": "markus7017", "createdAt": "2020-04-04T07:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MzA3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404273071", "bodyText": "I only see sensor1 declared...", "author": "cpmeister", "createdAt": "2020-04-06T17:42:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2NDM0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r406164340", "bodyText": "???\n            // Shelly 1/1PM have up to 3 sensors\n            // for whatever reasons it's not an array, but 3 independent elements\n            @SerializedName(\"0\")\n            public ShellyShortTemp sensor1;\n            @SerializedName(\"1\")\n            public ShellyShortTemp sensor2;\n            @SerializedName(\"2\")\n            public ShellyShortTemp sensor3;\n\nsensor1, sensor2, sensor3", "author": "markus7017", "createdAt": "2020-04-09T12:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTQ2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402671463", "bodyText": "If this is non-null why not make it primitive?", "author": "cpmeister", "createdAt": "2020-04-03T00:29:52Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiResult.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import static org.eclipse.jetty.http.HttpStatus.*;\n+import static org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+\n+/**\n+ * The {@link ShellyApiResult} wraps up the API result and provides some more information like url, http code, received\n+ * response etc.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiResult {\n+    public String url = \"\";\n+    public String method = \"\";\n+    public String response = \"\";\n+    public Integer httpCode = -1;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NDY1MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403684650", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T10:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTU5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402671594", "bodyText": "Why not a boolean?", "author": "cpmeister", "createdAt": "2020-04-03T00:30:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -38,14 +41,18 @@\n  */\n @NonNullByDefault\n public class ShellyDeviceProfile {\n+    public Boolean initialized = false; // true when initialized", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjMzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436333", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-04-04T07:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MTU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjExOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402672118", "bodyText": "Any reason to not include the cause exception?", "author": "cpmeister", "createdAt": "2020-04-03T00:32:16Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -83,75 +97,186 @@\n     public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n \n     @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+            Validate.notNull(settings, \"Converted device settings must not be null!\\nsettings=\" + json);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(\n+                    thingName + \": Unable to transform settings JSON e.toString, json='\" + json + \"'\");", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MjAyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403442021", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-04-04T08:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjQ2OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402672468", "bodyText": "Just to be consistent.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    isSensor = isHT | isFlood | isDW | isSmoke | isSense;\n          \n          \n            \n                    isSensor = isHT || isFlood || isDW || isSmoke || isSense;", "author": "cpmeister", "createdAt": "2020-04-03T00:33:20Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -83,75 +97,186 @@\n     public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n \n     @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+            Validate.notNull(settings, \"Converted device settings must not be null!\\nsettings=\" + json);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(\n+                    thingName + \": Unable to transform settings JSON e.toString, json='\" + json + \"'\");\n+        }\n \n         // General settings\n-        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n-        profile.mac = getString(profile.settings.device.mac);\n-        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n-                ? profile.settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n-        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n-        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n-        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n-                : \"\";\n-        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n-        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n-        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n-\n-        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n-        profile.hasLed = profile.isPlugS;\n-        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n-        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        profile.isLight = profile.isBulb\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n-        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n-        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.isSensor = profile.isSense || profile.isSmoke\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-\n-        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n-        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n-            profile.numRelays = 0;\n-        }\n-        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n-        profile.numRollers = getInteger(profile.settings.device.numRollers);\n-\n-        profile.isEMeter = profile.settings.emeters != null;\n-        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n-                : getInteger(profile.settings.device.numEMeters);\n-        if ((profile.numMeters == 0) && profile.isLight) {\n+        deviceType = ShellyUtils.getString(settings.device.type);\n+        mac = getString(settings.device.mac);\n+        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n+                ? settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n+        mode = getString(settings.mode) != null ? getString(settings.mode).toLowerCase() : \"\";\n+        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n+        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n+        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n+        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n+        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n+        discoverable = (settings.discoverable == null) || settings.discoverable;\n+\n+        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n+        if ((numRelays > 0) && (settings.relays == null)) {\n+            numRelays = 0;\n+        }\n+        hasRelays = (numRelays > 0) || isDimmer;\n+        numRollers = getInteger(settings.device.numRollers);\n+\n+        isEMeter = settings.emeters != null;\n+        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n+        if ((numMeters == 0) && isLight) {\n             // RGBW2 doesn't report, but has one\n-            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n+            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n+        }\n+        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+\n+        if (settings.sleepMode != null) {\n+            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\")\n+                    ? settings.sleepMode.period * 60 + 15 // minutes + 15s\n+                    : settings.sleepMode.period * 3600 + 60; // hours + 60s\n+        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n+            updatePeriod = settings.coiot.updatePeriod + 15; // usually 15+15s\n+        }\n+\n+        supportsButtonUrls = settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n+                || settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n+                || settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n+        supportsOutUrls = settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n+        supportsPushUrls = settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n+        supportsRollerUrls = settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n+        supportsSensorUrls = settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+\n+        initialized = true;\n+        return this;\n+    }\n+\n+    public Boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void initFromThingType(String name) {\n+        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n+        if (thingType.isEmpty()) {\n+            return;\n         }\n-        profile.hasMeter = (profile.numMeters > 0);\n \n-        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n-        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n-        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n-        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n-        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n+\n+        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n+        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n+        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n+        hasLed = isPlugS;\n+        isLight = isBulb || isDuo || isRGBW2;\n+        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n+        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n+\n+        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n+        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n+        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n+        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n+        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n+        isSensor = isHT | isFlood | isDW | isSmoke | isSense;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjQ0NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436444", "bodyText": "fixed, good catch :-)", "author": "markus7017", "createdAt": "2020-04-04T07:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NDgxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402674810", "bodyText": "This seems like an inappropriate use of a Scanner. Why not use IOUtils.toString(request.getInputStream()) instead?", "author": "cpmeister", "createdAt": "2020-04-03T00:42:10Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -132,33 +130,9 @@ protected void service(@Nullable HttpServletRequest request, @Nullable HttpServl\n         }\n     }\n \n-    @SuppressWarnings(\"resource\")\n+    @SuppressWarnings({ \"resource\", \"null\" })\n     private String inputStreamToString(@Nullable HttpServletRequest request) throws IOException {\n-        @SuppressWarnings(\"null\")\n-        Scanner scanner = new Scanner(request.getInputStream()).useDelimiter(\"\\\\A\");\n+        final Scanner scanner = new Scanner(request.getInputStream()).useDelimiter(\"\\\\A\");\n         return scanner.hasNext() ? scanner.next() : \"\";", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NDgwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403684801", "bodyText": "replaced by your code", "author": "markus7017", "createdAt": "2020-04-05T10:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NDgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NTczMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402675733", "bodyText": "why bother catching it if you are just going to throw it?", "author": "cpmeister", "createdAt": "2020-04-03T00:45:16Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -465,71 +443,110 @@ private void setEventUrls(Integer index) throws IOException {\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(\n-                        thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(\"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        try {\n+            apiResult = innerRequest(HttpMethod.GET, uri);\n+        } catch (ShellyApiException e) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(\n-                            thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n+                if (e.isTimeout() && profile.isSensor) {\n+                    // Sensor in sleep mode\n+                    throw e;\n+                }\n+                if (e.isTimeout()) {\n+                    timeoutErrors++; // count the retries\n+                    logger.debug(\"{}: {}, #{}\u00a0retry\", thingName, e.toString(), timeoutErrors);\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++; // recoverd\n+                    logger.debug(\"{}: API timeout #{}/{} recovered\", thingName, timeoutErrors, timeoutsRecovered);\n                 } else {\n-                    throw new IOException(\n-                            thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                    throw e;\n                 }\n+            } catch (ShellyApiException e2) {\n+                throw e2;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjU1OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436558", "bodyText": "fixed, there was some code before", "author": "markus7017", "createdAt": "2020-04-04T07:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NTczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzEyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402677126", "bodyText": "Can you give an option to support https for the callback or does shelly not support it?", "author": "cpmeister", "createdAt": "2020-04-03T00:50:24Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -465,71 +443,110 @@ private void setEventUrls(Integer index) throws IOException {\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(\n-                        thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(\"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        try {\n+            apiResult = innerRequest(HttpMethod.GET, uri);\n+        } catch (ShellyApiException e) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(\n-                            thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n+                if (e.isTimeout() && profile.isSensor) {\n+                    // Sensor in sleep mode\n+                    throw e;\n+                }\n+                if (e.isTimeout()) {\n+                    timeoutErrors++; // count the retries\n+                    logger.debug(\"{}: {}, #{}\u00a0retry\", thingName, e.toString(), timeoutErrors);\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++; // recoverd\n+                    logger.debug(\"{}: API timeout #{}/{} recovered\", thingName, timeoutErrors, timeoutsRecovered);\n                 } else {\n-                    throw new IOException(\n-                            thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                    throw e;\n                 }\n+            } catch (ShellyApiException e2) {\n+                throw e2;\n             }\n         }\n-        return result;\n+        return apiResult.response;\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    @SuppressWarnings(\"null\")\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n+            }\n+            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n+            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+\n+            // Do request and get response\n+            ContentResponse contentResponse = request.send();\n+            apiResult = new ShellyApiResult(contentResponse);\n+            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n+\n+            // validate response, API errors are reported as Json\n+            logger.trace(\"HTTP Response: {}\", response);\n+            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n+                throw new ShellyApiException(apiResult);\n+            }\n+            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n+                throw new ShellyApiException(\"Unexpected response: \" + response);\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n+            throw new ShellyApiException(apiResult, e);\n         }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+        return apiResult;\n+    }\n+\n+    public String getControlUrlPrefix(Integer id) {\n+        Validate.notNull(profile);\n+        String uri = \"\";\n+        if (profile.isLight || profile.isDimmer) {\n+            if (profile.isDuo || profile.isDimmer) {\n+                // Duo + Dimmer\n+                uri = SHELLY_URL_CONTROL_LIGHT;\n+            } else {\n+                // Bulb + RGBW2\n+                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n+            }\n+        } else {\n+            // Roller, Relay\n+            uri = SHELLY_URL_CONTROL_RELEAY;\n         }\n+        uri = uri + \"/\" + id.toString();\n+        logger.trace(\"{}: Control URL prefix = {}\", thingName, uri);\n+        return uri;\n+    }\n+\n+    public static String buildSetEventUrl(String localIp, String localPort, String deviceName, Integer index,\n+            String deviceType, String urlParm) throws ShellyApiException {\n+        return SHELLY_URL_SETTINGS + \"/\" + deviceType + \"/\" + index + \"?\" + urlParm + \"=\"\n+                + buildCallbackUrl(localIp, localPort, deviceName, index, deviceType, urlParm);\n+    }\n \n-        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n-        return httpResponse;\n+    private static String buildCallbackUrl(String localIp, String localPort, String deviceName, Integer index,\n+            String type, String parameter) throws ShellyApiException {\n+        String url = \"http://\" + localIp + \":\" + localPort + SHELLY_CALLBACK_URI + \"/\" + deviceName + \"/\" + type + \"/\"", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjU5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436596", "bodyText": "No, the devices don't support https for resource constraints", "author": "markus7017", "createdAt": "2020-04-04T07:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzQyMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402677423", "bodyText": "Can this NPE be prevented or do you have to catch it?", "author": "cpmeister", "createdAt": "2020-04-03T00:51:27Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -288,35 +300,32 @@ private void addSensor(CoIotDescrSen sen) {\n             } else {\n                 sensorMap.replace(sen.id, fixed);\n             }\n-        } catch (NullPointerException e) {\n+        } catch (NullPointerException e) { // depending on firmware release the Coap device description is buggy", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MTk5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403441991", "bodyText": "The Coap descriptions are somehow buggy, esp. with old firmware releases. I did my best to catch those and transform in the correct format, but I want to make sure that a malformed format doesn't breaks the processing.", "author": "markus7017", "createdAt": "2020-04-04T08:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3ODk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402678960", "bodyText": "orphan semicolon", "author": "cpmeister", "createdAt": "2020-04-03T00:57:17Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +93,78 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<String, Object>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            ;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjYyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403436628", "bodyText": "easy fix :-)", "author": "markus7017", "createdAt": "2020-04-04T07:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3ODk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402679227", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"{}: Exception {}\\n{}\", name, e.toString(), e.getStackTrace());\n          \n          \n            \n                                logger.debug(\"{}: Exception {}\", name, e.toString(), e);", "author": "cpmeister", "createdAt": "2020-04-03T00:58:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +93,78 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<String, Object>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            ;\n+\n             address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n                 logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n             logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n-            }\n-\n             // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+                ShellySettingsDevice devInfo = api.getDevInfo();\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", getString(devInfo.hostname), profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address, e.toString()));\n+                    logger.debug(\"{}: Exception {}\\n{}\", name, e.toString(), e.getStackTrace());", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MDc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403440773", "bodyText": "ok, removed all references to e.getStackTrace(), thanks for the heads-up", "author": "markus7017", "createdAt": "2020-04-04T08:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTQyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402679429", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to initialize - {} ({}), retrying later\\n{}\", name, getString(e),\n          \n          \n            \n                                    getString(e.getClass().toString()), e.getStackTrace());\n          \n          \n            \n                            logger.debug(\"{}: Unable to initialize - {} ({}), retrying later\", name, getString(e),\n          \n          \n            \n                                    getString(e.getClass().toString()), e);", "author": "cpmeister", "createdAt": "2020-04-03T00:59:04Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +93,78 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<String, Object>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n+            ;\n+\n             address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n             if (address == null) {\n                 logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n                 return null;\n             }\n             logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n-            }\n-\n             // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+                ShellySettingsDevice devInfo = api.getDevInfo();\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", getString(devInfo.hostname), profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address, e.toString()));\n+                    logger.debug(\"{}: Exception {}\\n{}\", name, e.toString(), e.getStackTrace());\n                 }\n+            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+                logger.debug(\"{}: Unable to initialize - {} ({}), retrying later\\n{}\", name, getString(e),\n+                        getString(e.getClass().toString()), e.getStackTrace());", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MTg3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403441875", "bodyText": "removed all references to e.getStackTrace()", "author": "markus7017", "createdAt": "2020-04-04T08:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTcyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402679729", "bodyText": "Don't call e.getStacktrace() as part of logging. Just use the exception as the last argument instead.\nSee other comments for examples.", "author": "cpmeister", "createdAt": "2020-04-03T01:00:11Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -162,13 +174,13 @@ public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n                 addProperty(properties, PROPERTY_DEV_TYPE, thingType);\n                 addProperty(properties, PROPERTY_DEV_MODE, mode);\n \n-                logger.debug(\"Adding Shelly thing, UID={}\", thingUID.getAsString());\n+                logger.debug(\"{}: Adding Shelly thing, UID={}\", name, thingUID.getAsString());\n                 return DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n                         .withLabel(name + \" - \" + address).withRepresentationProperty(name).build();\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"Device discovery failed for device {}, IP {}, service={}: {}\", name, address, name,\n-                    e.getMessage(), e);\n+        } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, getString(e)));\n+            logger.debug(\"{}: Exception {}\\n{}\", name, e.getClass(), e.getStackTrace());", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MTg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403441879", "bodyText": "removed all references to e.getStackTrace()", "author": "markus7017", "createdAt": "2020-04-04T08:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3OTcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MDAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402680005", "bodyText": "Any reason you can't use primitives instead?", "author": "cpmeister", "createdAt": "2020-04-03T01:01:08Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java", "diffHunk": "@@ -29,10 +28,34 @@\n  */\n @NonNullByDefault\n public class ShellyColorUtils {\n+    OnOffType power = OnOffType.OFF;\n+    String mode = \"\";\n+\n+    Integer red = 0;\n+    Integer green = 0;\n+    Integer blue = 0;\n+    Integer white = 0;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MjUwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403442500", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-04T08:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MDAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MDM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402680387", "bodyText": "Shouldn't the null checking been handled already by the static analyzer. Why do you need to check again? Or better question: why did you make the parameter non-null?", "author": "cpmeister", "createdAt": "2020-04-03T01:02:42Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java", "diffHunk": "@@ -172,8 +172,9 @@ public static PercentType toPercent(Integer value) {\n         return toPercent(value, 0, SHELLY_MAX_COLOR);\n     }\n \n-    public static PercentType toPercent(@Nullable Integer _value, Integer min, Integer max) {\n+    public static PercentType toPercent(Integer _value, Integer min, Integer max) {\n         Double range = max.doubleValue() - min.doubleValue();\n+        @SuppressWarnings(\"null\")\n         Double value = _value != null ? _value.doubleValue() : 0;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ0MjkyMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403442923", "bodyText": "change, see general notes below", "author": "markus7017", "createdAt": "2020-04-04T08:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTE2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402681167", "bodyText": "Was this removed intentionally?", "author": "cpmeister", "createdAt": "2020-04-03T01:05:50Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java", "diffHunk": "@@ -400,34 +415,25 @@ public boolean updateRelays(ShellySettingsStatus status) throws IOException {\n      * @param profile ShellyDeviceProfile\n      * @param status Last ShellySettingsStatus\n      *\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateDimmers(ShellySettingsStatus orgStatus) throws IOException {\n-        ShellyDeviceProfile profile = getProfile();\n-\n+    public boolean updateDimmers(ShellySettingsStatus orgStatus) throws ShellyApiException {\n         boolean updated = false;\n         if (profile.isDimmer) {\n-            Validate.notNull(orgStatus, \"orgStatus must not be null!\");\n-\n             // We need to fixup the returned Json: The dimmer returns light[] element, which is ok, but it doesn't have\n-            // the same structure as lights[] from Bulb and RGBW2. The tag gets replaced by dimmers[] so that Gson maps\n-            // to a different structure (ShellyShortLight).\n+            // the same structure as lights[] from Bulb,RGBW2 and Duo. The tag gets replaced by dimmers[] so that Gson\n+            // maps to a different structure (ShellyShortLight).\n             Gson gson = new Gson();\n             ShellySettingsStatus dstatus = gson.fromJson(ShellyApiJsonDTO.fixDimmerJson(orgStatus.json),\n                     ShellySettingsStatus.class);\n             Validate.notNull(dstatus.dimmers, \"dstatus.dimmers must not be null!\");\n-            Validate.notNull(dstatus.tmp, \"dstatus.tmp must not be null!\");\n \n             logger.trace(\"{}: Updating {}\u00a0dimmers(s)\", thingName, dstatus.dimmers.size());\n-\n             int l = 0;\n-            logger.trace(\"{}: Updating dimmers {}\", thingName, dstatus.dimmers.size());\n             for (ShellyShortLightStatus dimmer : dstatus.dimmers) {\n                 Integer r = l + 1;\n                 String groupName = profile.numRelays <= 1 ? CHANNEL_GROUP_DIMMER_CONTROL\n                         : CHANNEL_GROUP_DIMMER_CONTROL + r.toString();\n-                // updated |= updateChannel(groupName, CHANNEL_OUTPUT, getOnOff(dimmer.ison));", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NjMzMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403686330", "bodyText": "Could you please re-check, my code doesn't show this line - strange", "author": "markus7017", "createdAt": "2020-04-05T11:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2NTExMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r406165113", "bodyText": "ah', this was removed, because the Dimmer on/off is now moved in the general brightness handling (on/off is an integrated part of the UI control)", "author": "markus7017", "createdAt": "2020-04-09T12:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTc2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402681762", "bodyText": "Can these exceptions be prevented?", "author": "cpmeister", "createdAt": "2020-04-03T01:08:03Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }\n+                }\n+                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n+                        value.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException | NullPointerException e) {", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NjM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403686394", "bodyText": "catch NullPointerException removed", "author": "markus7017", "createdAt": "2020-04-05T11:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MTc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjEzOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682138", "bodyText": "Why not just use put every time?", "author": "cpmeister", "createdAt": "2020-04-03T01:09:24Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NjQ3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403686476", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjI4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682285", "bodyText": "Why bother checking if it contains? Just call remove to begin with.", "author": "cpmeister", "createdAt": "2020-04-03T01:09:56Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }\n+                }\n+                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n+                        value.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n+                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {\n+        return getValue(mkChannelId(group, channel));\n+    }\n+\n+    @Nullable\n+    public Object getValue(String channelId) {\n+        synchronized (channelData) {\n+            return channelData.get(channelId);\n+        }\n+    }\n+\n+    public void resetChannel(String channelId) {\n+        Validate.notNull(channelId);\n+        synchronized (channelData) {\n+            if (channelData.containsKey(channelId)) {\n+                channelData.remove(channelId);\n+            }", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NjU5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403686594", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjU3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682576", "bodyText": "All of your synchronization on this field is done only for single operations. Why not just make this a ConcurrentHashMap instead so you don't need to do synchronization around it?", "author": "cpmeister", "createdAt": "2020-04-03T01:10:59Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjgxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682811", "bodyText": "Also, you can make this field final.", "author": "cpmeister", "createdAt": "2020-04-03T01:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MzEzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403983133", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-06T10:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjczNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402682734", "bodyText": "No need to be wasteful.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    channelData = new HashMap<>();\n          \n          \n            \n                    channelData.clear();", "author": "cpmeister", "createdAt": "2020-04-03T01:11:36Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+        try {\n+            Object current = channelData.get(channelId);\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(value)) {\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, value);\n+                synchronized (channelData) {\n+                    if (current == null) {\n+                        channelData.put(channelId, value);\n+                    } else {\n+                        channelData.replace(channelId, value);\n+                    }\n+                }\n+                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n+                        value.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, value,\n+                    value.getClass().toString(), ShellyUtils.getString(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {\n+        return getValue(mkChannelId(group, channel));\n+    }\n+\n+    @Nullable\n+    public Object getValue(String channelId) {\n+        synchronized (channelData) {\n+            return channelData.get(channelId);\n+        }\n+    }\n+\n+    public void resetChannel(String channelId) {\n+        Validate.notNull(channelId);\n+        synchronized (channelData) {\n+            if (channelData.containsKey(channelId)) {\n+                channelData.remove(channelId);\n+            }\n+        }\n+\n+    }\n+\n+    public void clear() {\n+        channelData = new HashMap<>();", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NjcyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403686721", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:15:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MjczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MzQzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402683431", "bodyText": "Static analysis should have made these validation checks redundant.\nAlso, how is channelData supposed to be null here anyhow?", "author": "cpmeister", "createdAt": "2020-04-03T01:14:20Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.Validate;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private String thingName = \"\";\n+    private Map<String, Object> channelData = new HashMap<>();\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        this.thingName = thingHandler.thingName;\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    @SuppressWarnings(\"null\")\n+    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n+        Validate.notNull(channelData);\n+        Validate.notNull(channelId);\n+        Validate.notNull(value, \"updateChannel(): value must not be null!\");", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzk4MzI0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403983240", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-06T10:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MzQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4MzkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402683918", "bodyText": "Can these be made final?", "author": "cpmeister", "createdAt": "2020-04-03T01:16:20Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Locale;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.osgi.framework.Bundle;\n+\n+/**\n+ * {@link ShellyTranslationProvider} provides i18n message lookup\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyTranslationProvider {\n+\n+    private @Nullable Bundle bundle;\n+    private @Nullable TranslationProvider i18nProvider;\n+    private @Nullable LocaleProvider localeProvider;", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDExNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402684116", "bodyText": "getMessage is a more appropriate name for this method.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static String getString(Exception e) {\n          \n          \n            \n                public static String getMessage(Exception e) {", "author": "cpmeister", "createdAt": "2020-04-03T01:17:01Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java", "diffHunk": "@@ -55,6 +55,11 @@ public static String getString(@Nullable String value) {\n         return value != null ? value : \"\";\n     }\n \n+    public static String getString(Exception e) {", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NzAzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403687039", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDQ4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402684481", "bodyText": "Should you also pass the cause exception?", "author": "cpmeister", "createdAt": "2020-04-03T01:18:22Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyUtils.java", "diffHunk": "@@ -116,24 +121,11 @@ public static void validateRange(String name, Integer value, Integer min, Intege\n                 \"Value \" + name + \" is out of range (\" + min.toString() + \"-\" + max.toString() + \")\");\n     }\n \n-    public static String buildSetEventUrl(String localIp, String localPort, String deviceName, Integer index,\n-            String deviceType, String urlParm) throws IOException {\n-        return SHELLY_URL_SETTINGS + \"/\" + deviceType + \"/\" + index + \"?\" + urlParm + \"=\"\n-                + buildCallbackUrl(localIp, localPort, deviceName, index, deviceType, urlParm);\n-    }\n-\n-    public static String buildCallbackUrl(String localIp, String localPort, String deviceName, Integer index,\n-            String type, String parameter) throws IOException {\n-        String url = \"http://\" + localIp + \":\" + localPort + SHELLY_CALLBACK_URI + \"/\" + deviceName + \"/\" + type + \"/\"\n-                + index + \"?type=\" + StringUtils.substringBefore(parameter, \"_url\");\n-        return urlEncode(url);\n-    }\n-\n-    public static String urlEncode(String input) throws IOException {\n+    public static String urlEncode(String input) throws ShellyApiException {\n         try {\n             return URLEncoder.encode(input, StandardCharsets.UTF_8.toString());\n         } catch (UnsupportedEncodingException e) {\n-            throw new IOException(\n+            throw new ShellyApiException(\n                     \"Unsupported encoding format: \" + StandardCharsets.UTF_8.toString() + \", input=\" + input);", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NzI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403687283", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDcwNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402684704", "bodyText": "Field and variable names should be camelcase.", "author": "cpmeister", "createdAt": "2020-04-03T01:19:11Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Comparator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO implements Comparator<Object> {\n+    private class VersionTokenizer {\n+        private final String _versionString;\n+        private final int _length;\n+\n+        private int _position;\n+        private int _number;\n+        private String _suffix = \"\";", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NzU5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403687592", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:22:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402685281", "bodyText": "I disagree with a DTO class implementing Comparator and instead it should be either a lambda, an anonymous class, or a named nested class in this DTO.\nThe best suggestion I can give to to make VersionTokenizer implement Comparable<VersionTokenizer>", "author": "cpmeister", "createdAt": "2020-04-03T01:21:34Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Comparator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO implements Comparator<Object> {", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzOTA1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405339056", "bodyText": "How to do that? My Java skills are limited", "author": "markus7017", "createdAt": "2020-04-08T08:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyOTI4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407029289", "bodyText": "@cpmeister could you help here?", "author": "markus7017", "createdAt": "2020-04-11T07:16:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0OTg3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407149877", "bodyText": "Where is this class used as a comparator?", "author": "cpmeister", "createdAt": "2020-04-12T05:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNTEwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407235107", "bodyText": "I removed the comparator, ShellyBaseHandler directly calls .compare()", "author": "markus7017", "createdAt": "2020-04-12T18:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NjM3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r402686372", "bodyText": "This fix will allow you to remove the warning suppression for this method\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return version != null & (version.isEmpty() || version.contains(\"???\")\n          \n          \n            \n                            || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));\n          \n          \n            \n                    return version != null && (version.isEmpty() || version.contains(\"???\")\n          \n          \n            \n                            || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));", "author": "cpmeister", "createdAt": "2020-04-03T01:25:40Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Comparator;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO implements Comparator<Object> {\n+    private class VersionTokenizer {\n+        private final String _versionString;\n+        private final int _length;\n+\n+        private int _position;\n+        private int _number;\n+        private String _suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            _versionString = versionString;\n+            _length = versionString.length();\n+        }\n+\n+        public boolean MoveNext() {\n+            _number = 0;\n+            _suffix = \"\";\n+\n+            // No more characters\n+            if (_position >= _length) {\n+                return false;\n+            }\n+\n+            while (_position < _length) {\n+                char c = _versionString.charAt(_position);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                _number = _number * 10 + (c - '0');\n+                _position++;\n+            }\n+\n+            int suffixStart = _position;\n+\n+            while (_position < _length) {\n+                char c = _versionString.charAt(_position);\n+                if (c == '.') {\n+                    break;\n+                }\n+                _position++;\n+            }\n+\n+            _suffix = _versionString.substring(suffixStart, _position);\n+\n+            if (_position < _length) {\n+                _position++;\n+            }\n+\n+            return true;\n+        }\n+\n+        public int getNumber() {\n+            return _number;\n+        }\n+\n+        public String getSuffix() {\n+            return _suffix;\n+        }\n+    }\n+\n+    public boolean equals(String o1, String o2) {\n+        return compare(o1, o2) == 0;\n+    }\n+\n+    @Override\n+    public int compare(Object o1, Object o2) {\n+        String version1 = (String) o1;\n+        String version2 = (String) o2;\n+\n+        VersionTokenizer tokenizer1 = new VersionTokenizer(version1);\n+        VersionTokenizer tokenizer2 = new VersionTokenizer(version2);\n+\n+        int number1 = 0, number2 = 0;\n+        String suffix1 = \"\", suffix2 = \"\";\n+\n+        while (tokenizer1.MoveNext()) {\n+            if (!tokenizer2.MoveNext()) {\n+                do {\n+                    number1 = tokenizer1.getNumber();\n+                    suffix1 = tokenizer1.getSuffix();\n+                    if (number1 != 0 || suffix1.length() != 0) {\n+                        // Version one is longer than number two, and non-zero\n+                        return 1;\n+                    }\n+                } while (tokenizer1.MoveNext());\n+\n+                // Version one is longer than version two, but zero\n+                return 0;\n+            }\n+\n+            number1 = tokenizer1.getNumber();\n+            suffix1 = tokenizer1.getSuffix();\n+            number2 = tokenizer2.getNumber();\n+            suffix2 = tokenizer2.getSuffix();\n+\n+            if (number1 < number2) {\n+                // Number one is less than number two\n+                return -1;\n+            }\n+            if (number1 > number2) {\n+                // Number one is greater than number two\n+                return 1;\n+            }\n+\n+            boolean empty1 = suffix1.length() == 0;\n+            boolean empty2 = suffix2.length() == 0;\n+\n+            if (empty1 && empty2) {\n+                continue;\n+            } // No suffixes\n+            if (empty1) {\n+                return 1;\n+            } // First suffix is empty (1.2 > 1.2b)\n+            if (empty2) {\n+                return -1;\n+            } // Second suffix is empty (1.2a < 1.2)\n+\n+            // Lexical comparison of suffixes\n+            int result = suffix1.compareTo(suffix2);\n+            if (result != 0) {\n+                return result;\n+            }\n+\n+        }\n+        if (tokenizer2.MoveNext()) {\n+            do {\n+                number2 = tokenizer2.getNumber();\n+                suffix2 = tokenizer2.getSuffix();\n+                if (number2 != 0 || suffix2.length() != 0) {\n+                    // Version one is longer than version two, and non-zero\n+                    return -1;\n+                }\n+            } while (tokenizer2.MoveNext());\n+\n+            // Version two is longer than version one, but zero\n+            return 0;\n+        }\n+        return 0;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    public boolean checkBeta(@Nullable String version) {\n+        return version != null & (version.isEmpty() || version.contains(\"???\")\n+                || version.toLowerCase().contains(\"master\") || (version.toLowerCase().contains(\"-rc\")));", "originalCommit": "8a81322242a07dcd8a83a36897af17525a0b4ac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NzcxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r403687719", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-05T11:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NjM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDMwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404270307", "bodyText": "What would throw these errors? Are they preventable?", "author": "cpmeister", "createdAt": "2020-04-06T17:37:36Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -142,24 +152,23 @@ protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n+    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n+            Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n         for (ShellyDeviceListener listener : deviceListeners) {\n             try {\n-                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n+                if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n                     // event processed\n                     break;\n                 }\n-            } catch (NullPointerException e) {\n-                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n-                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n-                        e.getStackTrace());\n+            } catch (IllegalArgumentException | NullPointerException e) {", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwMjg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405302858", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-08T07:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MDMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTI4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404271289", "bodyText": "Can you give this field a better name than e? Also can you make it final?", "author": "cpmeister", "createdAt": "2020-04-06T17:39:08Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+    private static String EX_NONE = \"none\";\n+    private Exception e = new Exception(EX_NONE);", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzNDAzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405334035", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-08T08:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTQyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404271427", "bodyText": "Some of our build tools don't like EOF without a newline. So add a newline here.", "author": "cpmeister", "createdAt": "2020-04-06T17:39:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+    private static String EX_NONE = \"none\";\n+    private Exception e = new Exception(EX_NONE);\n+\n+    public ShellyApiException(Exception exception) {\n+        super(exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(String message) {\n+        super(message);\n+    }\n+\n+    public ShellyApiException(ShellyApiResult res) {\n+        super(EX_NONE);\n+        apiResult = res;\n+    }\n+\n+    public ShellyApiException(Exception exception, String message) {\n+        super(message, exception);\n+        e = exception;\n+    }\n+\n+    public ShellyApiException(ShellyApiResult result, Exception exception) {\n+        super(exception);\n+        apiResult = result;\n+        e = exception;\n+    }\n+\n+    @Override\n+    public String getMessage() {\n+        return isEmpty() ? \"\" : nonNullString(super.getMessage());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String message = super.getMessage();\n+        String url = !apiResult.url.isEmpty() ? MessageFormat.format(\"{0} {1} HTTP {2} {3}\", apiResult.method,\n+                apiResult.url, apiResult.httpCode, apiResult.httpReason) : \"\";\n+        String resultString = !apiResult.response.isEmpty() ? \", result =\" + apiResult.response : \"\";\n+\n+        if (!isEmpty()) {\n+            if (isUnknownHost()) {\n+                String[] string = message.split(\": \"); // java.net.UnknownHostException: api.rach.io\n+                return MessageFormat.format(\"Unable to connect to {0} (Unknown host / Network down / Low signal)\",\n+                        string[1]);\n+            } else if (isMalformedURL()) {\n+                return MessageFormat.format(\"Invalid URL: {0}\", url);\n+            } else if (isTimeout()) {\n+                return MessageFormat.format(\"Device unreachable or API Timeout ({0})\", url);\n+            } else {\n+                return MessageFormat.format(\"{0} ({1})\", e.toString(), message);\n+            }\n+        } else {\n+            if (isApiException()) {\n+                message = nonNullString(super.getClass().toString()) + \" - \" + getMessage();\n+            } else {\n+                message = getMessage();\n+            }\n+        }\n+\n+        return MessageFormat.format(\"{0} {1} {2}\", message, url, resultString);\n+    }\n+\n+    public boolean isApiException() {\n+        return e.getClass() == ShellyApiException.class;\n+    }\n+\n+    public boolean isTimeout() {\n+        Class<?> extype = !isEmpty() ? e.getClass() : null;\n+        return (apiResult.httpCode == -1)\n+                || (extype != null) && ((extype == TimeoutException.class) || (extype == ExecutionException.class)\n+                        || (extype == InterruptedException.class) || getMessage().toLowerCase().contains(\"timeout\"));\n+    }\n+\n+    public boolean isHttpAccessUnauthorized() {\n+        return apiResult.isHttpAccessUnauthorized();\n+    }\n+\n+    public boolean isUnknownHost() {\n+        return e.getClass() == MalformedURLException.class;\n+    }\n+\n+    public boolean isMalformedURL() {\n+        return e.getClass() == UnknownHostException.class;\n+    }\n+\n+    public ShellyApiResult getApiResult() {\n+        return apiResult;\n+    }\n+\n+    private boolean isEmpty() {\n+        return nonNullString(e.getMessage()).equals(EX_NONE);\n+    }\n+\n+    private static String nonNullString(@Nullable String s) {\n+        return s != null ? s : \"\";\n+    }\n+}", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwNTQ0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405305442", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T07:13:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3MTQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404276294", "bodyText": "This method used to be static, which made it a factory method, which was fine. You have made it non-static yet it still produces a ShellyDeviceProfile instance. Are you trying to make this into a builder pattern? Why not just make this a constructor then?", "author": "cpmeister", "createdAt": "2020-04-06T17:47:27Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -56,102 +62,213 @@\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n+    public Integer numRollers = 0; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n+    public Boolean isEMeter = false; // true for ShellyEM/EM3\n \n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isBulb = false; // true only if it is a Bulb\n+    public Boolean isDuo = false; // true only if it is a Duo\n+    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public Boolean hasLed = false; // true if battery device\n+\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isDW = false; // true of Door Window sensor\n \n-    public Map<String, String> irCodes = new HashMap<String, String>(); // Sense: list of stored IR codes\n+    public Integer minTemp = 0; // Bulb/Duo: Min Light Temp\n+    public Integer maxTemp = 0; // Bulb/Duo: Max Light Temp\n \n-    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n-    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n-    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n-    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n-    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+    public Integer updatePeriod = -1;\n \n-    @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n+\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwNjkxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405306916", "bodyText": "This allows me to have an initialization with the default constructor in ShellyBaseHandler to make it NonNull, any better idea?", "author": "markus7017", "createdAt": "2020-04-08T07:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1OTI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405659260", "bodyText": "Just have more than one constructor. A no-arg constructor and this one.", "author": "cpmeister", "createdAt": "2020-04-08T16:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY3MDg5OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405670898", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-08T16:53:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNjY1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407706654", "bodyText": "You still didn't resolve this one...", "author": "cpmeister", "createdAt": "2020-04-13T20:38:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NjI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzAxNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404277016", "bodyText": "If all these fields are non-null, why not make the fields primitive? Boolean -> boolean, Integer -> int", "author": "cpmeister", "createdAt": "2020-04-06T17:48:38Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -56,102 +62,213 @@\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n+    public Integer numRollers = 0; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n+    public Boolean isEMeter = false; // true for ShellyEM/EM3\n \n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isBulb = false; // true only if it is a Bulb\n+    public Boolean isDuo = false; // true only if it is a Duo\n+    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public Boolean hasLed = false; // true if battery device\n+\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isDW = false; // true of Door Window sensor", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwNzY0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405307647", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-08T07:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzgwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404277802", "bodyText": "Why is this code here? This code has nothing to do with device profile, why was it moved from ShellyThingCreator?", "author": "cpmeister", "createdAt": "2020-04-06T17:49:52Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -56,102 +62,213 @@\n \n     public Boolean hasRelays = false; // true if it has at least 1 power meter\n     public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n+    public Integer numRollers = 0; // number of Rollers, usually 1\n     public Boolean isRoller = false; // true for Shelly2 in roller mode\n     public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n     public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n+    public Boolean isEMeter = false; // true for ShellyEM/EM3\n \n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n     public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isBulb = false; // true only if it is a Bulb\n+    public Boolean isDuo = false; // true only if it is a Duo\n+    public Boolean isRGBW2 = false; // true only if it a a RGBW2\n     public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public Boolean hasLed = false; // true if battery device\n+\n     public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public Boolean hasBattery = false; // true if battery device\n+    public Boolean isSense = false; // true if thing is a Shelly Sense\n+    public Boolean isDW = false; // true of Door Window sensor\n \n-    public Map<String, String> irCodes = new HashMap<String, String>(); // Sense: list of stored IR codes\n+    public Integer minTemp = 0; // Bulb/Duo: Min Light Temp\n+    public Integer maxTemp = 0; // Bulb/Duo: Max Light Temp\n \n-    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n-    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n-    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n-    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n-    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+    public Integer updatePeriod = -1;\n \n-    @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n+\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    thingName + \": Unable to transform settings JSON \" + e.toString() + \", json='\" + json + \"'\");\n+        }\n \n         // General settings\n-        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n-        profile.mac = getString(profile.settings.device.mac);\n-        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n-                ? profile.settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n-        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n-        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n-        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n-                : \"\";\n-        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n-        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n-        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n-\n-        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n-        profile.hasLed = profile.isPlugS;\n-        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n-        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        profile.isLight = profile.isBulb\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n-        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n-        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.isSensor = profile.isSense || profile.isSmoke\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-\n-        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n-        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n-            profile.numRelays = 0;\n-        }\n-        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n-        profile.numRollers = getInteger(profile.settings.device.numRollers);\n-\n-        profile.isEMeter = profile.settings.emeters != null;\n-        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n-                : getInteger(profile.settings.device.numEMeters);\n-        if ((profile.numMeters == 0) && profile.isLight) {\n+        deviceType = ShellyUtils.getString(settings.device.type);\n+        mac = getString(settings.device.mac);\n+        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n+                ? settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n+        mode = !getString(settings.mode).isEmpty() ? getString(settings.mode).toLowerCase() : \"\";\n+        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n+        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n+        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n+        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n+        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n+        discoverable = (settings.discoverable == null) || settings.discoverable;\n+\n+        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n+        if ((numRelays > 0) && (settings.relays == null)) {\n+            numRelays = 0;\n+        }\n+        hasRelays = (numRelays > 0) || isDimmer;\n+        numRollers = getInteger(settings.device.numRollers);\n+\n+        isEMeter = settings.emeters != null;\n+        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n+        if ((numMeters == 0) && isLight) {\n             // RGBW2 doesn't report, but has one\n-            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n+            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n+        }\n+        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+\n+        if (settings.sleepMode != null) {\n+            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\")\n+                    ? settings.sleepMode.period * 60 + 15 // minutes + 15s\n+                    : settings.sleepMode.period * 3600 + 60; // hours + 60s\n+        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n+            updatePeriod = 2 * getInteger(settings.coiot.updatePeriod) + 5; // usually 2*15+5s=50sec\n         }\n-        profile.hasMeter = (profile.numMeters > 0);\n \n-        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n-        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n-        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n-        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n-        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+        initialized = true;\n+        return this;\n+    }\n+\n+    public boolean containsEventUrl(String eventType) {\n+        return containsEventUrl(settingsJson, eventType);\n+    }\n+\n+    public boolean containsEventUrl(String json, String eventType) {\n+        String settings = json.toLowerCase();\n+        return settings.contains((eventType + SHELLY_EVENTURL_SUFFIX).toLowerCase());\n+    }\n+\n+    public Boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void initFromThingType(String name) {\n+        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n+        if (thingType.isEmpty()) {\n+            return;\n+        }\n+\n+        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n+\n+        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n+        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n+        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n+        hasLed = isPlugS;\n+        isLight = isBulb || isDuo || isRGBW2;\n+        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n+        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n+\n+        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n+        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n+        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n+        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n+        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n+        isSensor = isHT || isFlood || isDW || isSmoke || isSense;\n+        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n+    }\n+\n+    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczNzE3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405737174", "bodyText": "moved to ShellyThingCreator", "author": "markus7017", "createdAt": "2020-04-08T18:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI3NzgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4MDc4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404280789", "bodyText": "This method is called by a library, and as such you have no idea if or how they will handle this exception getting thrown here. Instead you should just log it and return immediately.", "author": "cpmeister", "createdAt": "2020-04-06T17:54:42Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -54,40 +52,44 @@\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private @Nullable HttpService httpService;\n-    private @Nullable ShellyHandlerFactory handlerFactory;\n+    private final HttpService httpService;\n+    private final ShellyHandlerFactory handlerFactory;\n \n-    @SuppressWarnings(\"null\")\n     @Activate\n-    protected void activate(Map<String, Object> config) {\n+    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n+            Map<String, Object> config) {\n+        this.httpService = httpService;\n+        this.handlerFactory = handlerFactory;\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException e) {\n-            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n+            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n-    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        if (httpService != null) {\n-            httpService.unregister(SHELLY_CALLBACK_URI);\n-        }\n-        logger.debug(\"Shelly: CallbackServlet stopped\");\n+        httpService.unregister(SHELLY_CALLBACK_URI);\n+        logger.debug(\"ShellyEventServlet stopped\");\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException {\n-        String data = inputStreamToString(request);\n-        String path = request.getRequestURI().toLowerCase();\n+            throws ServletException, IOException, IllegalArgumentException {\n+        String data = \"\";\n+        String path = \"\";\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n+        if ((request == null) || (resp == null)) {\n+            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyNDc1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405324753", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T07:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4MDc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4ODE2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404288161", "bodyText": "The formula in your comment above doesn't match the formula you used here. Which is wrong?\nAlso, I would suggest taking advantage of the units framework conversion capabilities so you don't have to handle it yourself.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                : (status.tmp.value + 32) * 0.5556;\n          \n          \n            \n                                : Units.CELSIUS.getConverterTo(Units.FAHRENHEIT).convert(status.tmp.value);", "author": "cpmeister", "createdAt": "2020-04-06T18:07:05Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -109,84 +118,77 @@ public ShellyDeviceProfile getDeviceProfile(String thingType) throws IOException\n         return profile;\n     }\n \n+    public boolean isInitialized() {\n+        return profile.initialized;\n+    }\n+\n     /**\n      * Get generic device settings/status. Json returned from API will be mapped to a Gson object\n      *\n      * @return Device settings/status as ShellySettingsStatus object\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    public ShellySettingsStatus getStatus() throws IOException {\n+    public ShellySettingsStatus getStatus() throws ShellyApiException {\n         String json = request(SHELLY_URL_STATUS);\n         ShellySettingsStatus status = gson.fromJson(json, ShellySettingsStatus.class);\n-        Validate.notNull(status);\n         status.json = json;\n         return status;\n     }\n \n-    @Nullable\n-    public ShellyStatusRelay getRelayStatus(Integer relayIndex) throws IOException {\n-        String result = request(SHELLY_URL_STATUS_RELEAY + \"/\" + relayIndex.toString());\n-        return gson.fromJson(result, ShellyStatusRelay.class);\n+    public ShellyStatusRelay getRelayStatus(Integer relayIndex) throws ShellyApiException {\n+        return callApi(SHELLY_URL_STATUS_RELEAY + \"/\" + relayIndex.toString(), ShellyStatusRelay.class);\n     }\n \n-    @SuppressWarnings(\"null\")\n-    public void setRelayTurn(Integer relayIndex, String turnMode) throws IOException {\n-        Validate.notNull(profile);\n-        request((!profile.isDimmer ? SHELLY_URL_CONTROL_RELEAY : SHELLY_URL_CONTROL_LIGHT) + \"/\" + relayIndex.toString()\n-                + \"?\" + SHELLY_LIGHT_TURN + \"=\" + turnMode.toLowerCase());\n+    public void setRelayTurn(Integer id, String turnMode) throws ShellyApiException {\n+        request(getControlUrlPrefix(id) + \"?\" + SHELLY_LIGHT_TURN + \"=\" + turnMode.toLowerCase());\n     }\n \n-    public void setDimmerBrightness(Integer relayIndex, Integer brightness, boolean autoOn) throws IOException {\n-        if (autoOn) {\n-            request(SHELLY_URL_CONTROL_LIGHT + \"/\" + relayIndex.toString() + \"?\" + SHELLY_LIGHT_TURN + \"=\"\n-                    + SHELLY_API_ON + \"&brightness=\" + brightness.toString());\n-        } else {\n-            request(SHELLY_URL_CONTROL_LIGHT + \"/\" + relayIndex.toString() + \"?\" + \"&brightness=\"\n-                    + brightness.toString());\n-        }\n+    public void setBrightness(Integer id, Integer brightness, boolean autoOn) throws ShellyApiException {\n+        String turn = autoOn ? SHELLY_LIGHT_TURN + \"=\" + SHELLY_API_ON + \"&\" : \"\";\n+        request(getControlUrlPrefix(id) + \"?\" + turn + \"brightness=\" + brightness.toString());\n     }\n \n-    @Nullable\n-    public ShellyControlRoller getRollerStatus(Integer rollerIndex) throws IOException {\n-        String result = request(SHELLY_URL_CONTROL_ROLLER + \"/\" + rollerIndex.toString() + \"/pos\");\n-        return gson.fromJson(result, ShellyControlRoller.class);\n+    public ShellyControlRoller getRollerStatus(Integer rollerIndex) throws ShellyApiException {\n+        String uri = SHELLY_URL_CONTROL_ROLLER + \"/\" + rollerIndex.toString() + \"/pos\";\n+        return callApi(uri, ShellyControlRoller.class);\n     }\n \n-    public void setRollerTurn(Integer relayIndex, String turnMode) throws IOException {\n+    public void setRollerTurn(Integer relayIndex, String turnMode) throws ShellyApiException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?go=\" + turnMode);\n     }\n \n-    public void setRollerPos(Integer relayIndex, Integer position) throws IOException {\n+    public void setRollerPos(Integer relayIndex, Integer position) throws ShellyApiException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?go=to_pos&roller_pos=\"\n                 + position.toString());\n     }\n \n-    public void setRollerTimer(Integer relayIndex, Integer timer) throws IOException {\n+    public void setRollerTimer(Integer relayIndex, Integer timer) throws ShellyApiException {\n         request(SHELLY_URL_CONTROL_ROLLER + \"/\" + relayIndex.toString() + \"?timer=\" + timer.toString());\n     }\n \n-    @Nullable\n-    public ShellyShortLightStatus getLightStatus(Integer index) throws IOException {\n-        String result = request(SHELLY_URL_STATUS_LIGHT + \"/\" + index.toString());\n-        return gson.fromJson(result, ShellyShortLightStatus.class);\n+    public ShellyShortLightStatus getLightStatus(Integer index) throws ShellyApiException {\n+        String uri = SHELLY_URL_STATUS_LIGHT + \"/\" + index.toString();\n+        return callApi(uri, ShellyShortLightStatus.class);\n     }\n \n-    @SuppressWarnings(\"null\")\n-    public ShellyStatusSensor getSensorStatus() throws IOException {\n-        Validate.notNull(profile);\n-        ShellyStatusSensor status = gson.fromJson(request(SHELLY_URL_STATUS), ShellyStatusSensor.class);\n+    public ShellyStatusSensor getSensorStatus() throws ShellyApiException {\n+        ShellyStatusSensor status = callApi(SHELLY_URL_STATUS, ShellyStatusSensor.class);\n         if (profile.isSense) {\n-            // complete reported data\n-            status.tmp.tC = status.tmp.units.equals(SHELLY_TEMP_CELSIUS) ? status.tmp.value : 0;\n-            status.tmp.tF = status.tmp.units.equals(SHELLY_TEMP_FAHRENHEIT) ? status.tmp.value : 0;\n+            // complete reported data, map C to F or vice versa: C=(F - 32) * 0.5556;\n+            status.tmp.tC = status.tmp.units.equals(SHELLY_TEMP_CELSIUS) ? status.tmp.value\n+                    : status.tmp.value / 0.5556 + 32;\n+            status.tmp.tF = status.tmp.units.equals(SHELLY_TEMP_FAHRENHEIT) ? status.tmp.value\n+                    : (status.tmp.value + 32) * 0.5556;", "originalCommit": "42ce66ea5f896972d0fb50348c33726756339bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNDU5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405724591", "bodyText": "Units nor SIUnits provide the unit type FAHRENHEIT\nI added 2 functions to ShellyUtils and corrected the formulas", "author": "markus7017", "createdAt": "2020-04-08T18:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4ODE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1NzE0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405757140", "bodyText": "My bad, they can be found in ImperialUnits", "author": "cpmeister", "createdAt": "2020-04-08T19:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4ODE2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2ODk3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r406168977", "bodyText": "ok, changed", "author": "markus7017", "createdAt": "2020-04-09T12:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI4ODE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NDcyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404384729", "bodyText": "You should double check that IOUtils isn't using the system default charset, if it is using the default then you should specify it yourself here instead. The default charset can vary from system to system.", "author": "cpmeister", "createdAt": "2020-04-06T20:59:41Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -54,40 +52,44 @@\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private @Nullable HttpService httpService;\n-    private @Nullable ShellyHandlerFactory handlerFactory;\n+    private final HttpService httpService;\n+    private final ShellyHandlerFactory handlerFactory;\n \n-    @SuppressWarnings(\"null\")\n     @Activate\n-    protected void activate(Map<String, Object> config) {\n+    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n+            Map<String, Object> config) {\n+        this.httpService = httpService;\n+        this.handlerFactory = handlerFactory;\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException e) {\n-            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n+            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n-    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        if (httpService != null) {\n-            httpService.unregister(SHELLY_CALLBACK_URI);\n-        }\n-        logger.debug(\"Shelly: CallbackServlet stopped\");\n+        httpService.unregister(SHELLY_CALLBACK_URI);\n+        logger.debug(\"ShellyEventServlet stopped\");\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException {\n-        String data = inputStreamToString(request);\n-        String path = request.getRequestURI().toLowerCase();\n+            throws ServletException, IOException, IllegalArgumentException {\n+        String data = \"\";\n+        String path = \"\";\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n+        if ((request == null) || (resp == null)) {\n+            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");\n+        }\n+\n         try {\n+            path = request.getRequestURI().toLowerCase();\n+            data = IOUtils.toString(request.getInputStream());", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNjYxMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405726613", "bodyText": "I changed it to             data = IOUtils.toString(request.getInputStream(), \"UTF-8\");", "author": "markus7017", "createdAt": "2020-04-08T18:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NDcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NTUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404385526", "bodyText": "Why is this a field?", "author": "cpmeister", "createdAt": "2020-04-06T21:01:12Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -64,31 +70,31 @@\n public class ShellyCoapHandler implements ShellyCoapListener {\n     private final Logger logger = LoggerFactory.getLogger(ShellyCoapHandler.class);\n \n-    private final ShellyBaseHandler thingHandler;\n-    private final ShellyThingConfiguration config;\n-    private final GsonBuilder gsonBuilder;\n+    private final ShellyBaseHandler th;\n+    private ShellyThingConfiguration config = new ShellyThingConfiguration();\n+    private final GsonBuilder gsonBuilder = new GsonBuilder();", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjM0MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404386340", "bodyText": "It was better when this field was named thingHandler.", "author": "cpmeister", "createdAt": "2020-04-06T21:02:44Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -64,31 +70,31 @@\n public class ShellyCoapHandler implements ShellyCoapListener {\n     private final Logger logger = LoggerFactory.getLogger(ShellyCoapHandler.class);\n \n-    private final ShellyBaseHandler thingHandler;\n-    private final ShellyThingConfiguration config;\n-    private final GsonBuilder gsonBuilder;\n+    private final ShellyBaseHandler th;\n+    private ShellyThingConfiguration config = new ShellyThingConfiguration();\n+    private final GsonBuilder gsonBuilder = new GsonBuilder();\n     private final Gson gson;\n     private String thingName;\n+    private boolean discovering = false;\n \n-    private @Nullable ShellyCoapServer coapServer;\n+    private final ShellyCoapServer coapServer;\n     private @Nullable CoapClient statusClient;\n-    private @Nullable Request reqDescription;\n-    private @Nullable Request reqStatus;\n+    private Request reqDescription = new Request(Code.GET, Type.CON);;\n+    private Request reqStatus = new Request(Code.GET, Type.CON);\n \n     private int lastSerial = -1;\n+    private Double lastBrightness = -1.0;\n     private String lastPayload = \"\";\n     private Map<String, CoIotDescrBlk> blockMap = new HashMap<>();\n     private Map<String, CoIotDescrSen> sensorMap = new HashMap<>();\n \n-    public ShellyCoapHandler(ShellyThingConfiguration config, ShellyBaseHandler thingHandler,\n-            @Nullable ShellyCoapServer coapServer) {\n-        Validate.notNull(coapServer);\n-        this.thingHandler = thingHandler;\n+    private static final byte[] EMPTY_BYTE = new byte[0];\n+\n+    public ShellyCoapHandler(ShellyBaseHandler th, ShellyCoapServer coapServer) {\n+        this.th = th;", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4NDY2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405684662", "bodyText": "that causes a lot of line breaks, because statements getting longer = harder to read", "author": "markus7017", "createdAt": "2020-04-08T17:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1ODMxNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405758317", "bodyText": "A poorly named variable makes code much harder to read than longer statements.", "author": "cpmeister", "createdAt": "2020-04-08T19:21:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3Mzg1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r406173854", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-09T12:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4ODQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404388456", "bodyText": "I assume that sensorMap is a LinkedHashMap or an immutable map otherwise this id generation can get very inconsistent.", "author": "cpmeister", "createdAt": "2020-04-06T21:06:55Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -698,48 +822,60 @@ private void resetSerial() {\n      * @param sensorId The id from the sensor update\n      * @return Index of found entry (+1 will be the suffix for the channel name) or null if sensorId is not found\n      */\n-    @SuppressWarnings(\"null\")\n-    @Nullable\n-    private Integer getInputId(String sensorId) {\n-        Integer idx = 0;\n+    private int getSensorNumber(String sensorName, String sensorId) {\n+        int idx = 0;\n         for (Map.Entry<String, CoIotDescrSen> se : sensorMap.entrySet()) {\n-            @Nullable\n             CoIotDescrSen sen = se.getValue();\n-            if (sen.id.equalsIgnoreCase(\"Input\")) {\n+            if (sen.desc.equalsIgnoreCase(sensorName)) {\n                 idx++; // iterate from input1..2..n\n             }\n-            if (sen.id.equalsIgnoreCase(sensorId)) {\n+            if (sen.id.equalsIgnoreCase(sensorId) && blockMap.containsKey(sen.links)) {\n                 CoIotDescrBlk blk = blockMap.get(sen.links);\n-                if ((blk != null) && StringUtils.substring(blk.desc, 5).equalsIgnoreCase(\"Relay\")) {\n+                if (StringUtils.substring(blk.desc, 5).equalsIgnoreCase(\"Relay\")) {\n                     idx = Integer.parseInt(StringUtils.substringAfter(blk.desc, \"Relay\"));\n                 }\n-                logger.trace(\"{}:    map to input{} channel\", thingName, idx);\n+                logger.trace(\"{}:    map sensor {}{} to index {}\", thingName, sensorName, sensorId, idx);\n+                return idx;\n+            }\n+        }\n+        logger.debug(\"{}: sensorId {} not found in sensorMap!\", thingName, sensorId);\n+        return -1;\n+    }\n+\n+    private int getExtTempId(String sensorId) {\n+        int idx = 0;\n+        for (Map.Entry<String, CoIotDescrSen> se : sensorMap.entrySet()) {", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4NTIyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405685227", "bodyText": "changed to LinkedHashMap", "author": "markus7017", "createdAt": "2020-04-08T17:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4ODQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4ODkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404388918", "bodyText": "No need to create an Integer instance when you don't have to.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                sensor.id = new Integer(in.nextInt()).toString();\n          \n          \n            \n                                sensor.id = Integer.toString(in.nextInt());", "author": "cpmeister", "createdAt": "2020-04-06T21:07:51Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapJSonDTO.java", "diffHunk": "@@ -110,14 +120,13 @@ public CoIotGenericSensorList read(final JsonReader in) throws IOException {\n \n             in.beginObject();\n             String generic = in.nextName();\n-            Validate.notNull(generic, \"Invalid JSon format for CoIotSensorList\");\n             if (generic.equals(COIOT_TAG_GENERIC)) {\n                 in.beginArray();\n                 while (in.hasNext()) {\n                     in.beginArray();\n                     final CoIotSensor sensor = new CoIotSensor();\n                     in.nextInt(); // alway 0\n-                    sensor.index = new Integer(in.nextInt()).toString();\n+                    sensor.id = new Integer(in.nextInt()).toString();", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY4NzA4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405687087", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T17:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4ODkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NjIwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404396200", "bodyText": "Please make a local variable out of getThing().getStatus() so you can reuse it.", "author": "cpmeister", "createdAt": "2020-04-06T21:21:59Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -302,43 +303,38 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (NullPointerException | IOException e) {\n-            if (authorizationFailed(e.getMessage())) {\n+        } catch (ShellyApiException e) {\n+            ShellyApiResult res = e.getApiResult();\n+            if (isAuthorizationFailed(res)) {\n                 return;\n             }\n-            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n-                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n+            if (res.isNotCalibrtated()) {\n+                logger.warn(\"{}:{}\", thingName, messages.get(\"roller.calibrating\"));\n             } else {\n-                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n-                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n+                logger.info(\"{}: {}{}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n             }\n-        } finally {\n-            lockUpdates = false;\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: {}{}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n         }\n     }\n \n     /**\n      * Update device status and channels\n      */\n-    @SuppressWarnings(\"null\")\n-    protected void updateStatus() {\n+    protected void refreshStatus() {\n         try {\n             boolean updated = false;\n \n             skipUpdate++;\n-            if (lockUpdates) {\n-                logger.trace(\"{}: Update locked, try on next cycle\", thingName);\n-                return;\n-            }\n-\n-            if ((skipUpdate % refreshCount == 0) && (profile != null)\n+            if ((skipUpdate % refreshCount == 0) && (profile.isInitialized())\n                     && (getThing().getStatus() == ThingStatus.ONLINE)) {", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxODA3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405718072", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T18:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NjIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5Njk5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404396997", "bodyText": "This is already handled for you by the BaseThingHandler. So you don't need this method.", "author": "cpmeister", "createdAt": "2020-04-06T21:23:32Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -357,93 +353,119 @@ protected void updateStatus() {\n \n                 // map status to channels\n                 updated |= updateDeviceStatus(status);\n+                updated |= ShellyComponents.updateDeviceStatus(this, status);\n                 updated |= ShellyComponents.updateMeters(this, status);\n                 updated |= ShellyComponents.updateSensors(this, status);\n \n+                // All channels must be created after the first cycle\n+                channelsCreated = true;\n+\n                 if (scheduledUpdates <= 1) {\n                     fillDeviceStatus(status, updated);\n                 }\n             }\n-        } catch (IOException e) {\n+        } catch (ShellyApiException e) {\n             // http call failed: go offline except for battery devices, which might be in\n             // sleep mode. Once the next update is successful the device goes back online\n             String status = \"\";\n-            if (e.getMessage().contains(\"Timeout\")) {\n-                logger.debug(\"{}: Device is not reachable, update canceled ({} skips, {} scheduledUpdates)!\", thingName,\n-                        skipCount, scheduledUpdates);\n-                status = \"@text/offline.status-error-timeout\";\n-            } else if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                logger.debug(\"{}: Unable to access device, check credentials!\", thingName);\n-                status = \"@text/offline.conf-error-access-denied\";\n-            } else if (e.getMessage().contains(\"Not calibrated!\")) {\n-                logger.debug(\"{}: Roller is not calibrated! Use the Shelly App or Web UI to run calibration.\",\n-                        thingName);\n-                status = \"@text/offline.conf-error-not-calibrated\";\n+            ShellyApiResult res = e.getApiResult();\n+            if (e.isTimeout()) {\n+                if (!profile.hasBattery) { // ignore Timeouts for Sensors\n+                    status = \"offline.status-error-timeout\";\n+                }\n+            } else if (res.isHttpAccessUnauthorized()) {\n+                status = \"offline.conf-error-access-denied\";\n             } else {\n-                logger.debug(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n-                status = \"@text/offline.status-error-unexpected-api-result\";\n+                status = \"offline.status-error-unexpected-api-result\";\n             }\n-            if (!status.isEmpty() || (profile != null && !profile.isSensor)) {\n-                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, status);\n+\n+            if (!status.isEmpty()) {\n+                setThingOffline(ThingStatusDetail.COMMUNICATION_ERROR, status);\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.warn(\"{}: {}{}\", thingName, messages.get(\"statusupdate.failed\"), e.toString());\n         } finally {\n             if (scheduledUpdates > 0) {\n                 --scheduledUpdates;\n-                logger.debug(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n-            }\n-            if ((skipUpdate >= cacheCount) && !channelCache) {\n+                logger.trace(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n+            } else if ((skipUpdate >= cacheCount) && cache.isEnabled()) {\n                 logger.debug(\"{}: Enabling channel cache ({} updates / {}s)\", thingName, skipUpdate,\n                         cacheCount * UPDATE_STATUS_INTERVAL_SECONDS);\n-                channelCache = true;\n+                cache.enable();\n             }\n         }\n+    }\n+\n+    public boolean isThingOnline() {\n+        return getThing().getStatus() == ThingStatus.ONLINE;\n+    }\n+\n+    public boolean isThingOffline() {\n+        ThingStatus status = getThing().getStatus();\n+        return status == ThingStatus.OFFLINE || status == ThingStatus.UNKNOWN;\n+    }\n+\n+    public void setThingOnline() {\n+        if (!isThingOnline()) {\n+            setThingStatus(ThingStatus.ONLINE);\n+            requestUpdates(!profile.hasBattery ? 3 : 1, false); // request 3 updates in a row (during the first 2+3*3\n+                                                                // sec)\n+        }\n+    }\n+\n+    public void setThingOffline(ThingStatusDetail detail, String messageKey) {\n+        if (getThing().getStatus() != ThingStatus.OFFLINE) {\n+            setThingStatus(ThingStatus.OFFLINE, detail, messageKey);\n+            channelsCreated = false; // check for new channels after devices gets re-initialized (e.g. new\n+        }\n+    }\n \n+    public void setThingStatus(ThingStatus newStatus) {\n+        if (getThing().getStatus() != newStatus) {", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyMzA1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405723052", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-04-08T18:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5Njk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5OTgyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404399827", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Integer rindex = !deviceIndex.isEmpty() ? Integer.parseInt(deviceIndex) + 1 : -1;\n          \n          \n            \n                        int rindex = !deviceIndex.isEmpty() ? Integer.parseInt(deviceIndex) + 1 : -1;", "author": "cpmeister", "createdAt": "2020-04-06T21:28:58Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -482,22 +503,30 @@ public void postAlarm(String alarm, boolean force) {\n      * @param data the HTML input data\n      * @return true if event was processed\n      */\n-    @SuppressWarnings({ \"null\" })\n     @Override\n-    public boolean onEvent(String deviceName, String deviceIndex, String type, Map<String, String> parameters) {\n-        if (thingName.equalsIgnoreCase(deviceName) || config.deviceIp.equals(deviceName)) {\n+    public boolean onEvent(String ipAddress, String deviceName, String deviceIndex, String type,\n+            Map<String, @Nullable String> parameters) {\n+        if (thingName.equalsIgnoreCase(deviceName) || config.deviceIp.equals(ipAddress)) {\n             logger.debug(\"{}: Event received: class={}, index={}, parameters={}\", deviceName, type, deviceIndex,\n                     parameters.toString());\n-            boolean hasBattery = profile != null && profile.hasBattery ? true : false;\n-            if (profile == null) {\n+            Integer rindex = !deviceIndex.isEmpty() ? Integer.parseInt(deviceIndex) + 1 : -1;", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNDEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405724128", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T18:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5OTgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMjk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404402967", "bodyText": "All of these fields should be final and moved to the top of this class.", "author": "cpmeister", "createdAt": "2020-04-06T21:35:16Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.handler;\n+\n+import static org.openhab.binding.shelly.internal.ShellyBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyControlRoller;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsEMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsStatus;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusRelay;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusSensor;\n+import org.openhab.binding.shelly.internal.api.ShellyDeviceProfile;\n+import org.openhab.binding.shelly.internal.util.ShellyTranslationProvider;\n+\n+/**\n+ * The {@link ShellyChannelDefinitionsDTO} defines channel information for dynamically created channels. Those will be\n+ * added on the first thing status update\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelDefinitionsDTO {\n+\n+    private static final ChannelMap channelDefinitions = new ChannelMap();\n+\n+    private static String CHGR_METER = CHANNEL_GROUP_METER;\n+    private static String CHGR_SENSOR = CHANNEL_GROUP_SENSOR;\n+    private static String CHGR_BAT = CHANNEL_GROUP_BATTERY;\n+\n+    public ShellyChannelDefinitionsDTO(ShellyTranslationProvider m) {\n+        // Device: Internal Temp\n+        channelDefinitions\n+                // Device\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP, \"deviceTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_WAKEUP, \"sensorWakeup\",\n+                        ITEM_TYPE_STRING))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUWATTS, \"meterAccuWatts\",\n+                        ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUTOTAL, \"meterAccuTotal\",\n+                        ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCURETURNED, \"meterAccuReturned\",\n+                        ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_CHARGER, \"charger\", ITEM_TYPE_SWITCH))\n+\n+                // Power Meter\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_CURRENTWATTS, \"meterWatts\", ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_TOTALKWH, \"meterTotal\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN1, \"lastPower1\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN2, \"lastPower2\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_METER_LASTMIN3, \"lastPower3\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_LAST_UPDATE, \"lastUpdate\", ITEM_TYPE_DATETIME))\n+\n+                // EMeter\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_TOTALRET, \"meterReturned\", ITEM_TYPE_ENERGY))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_REACTWATTS, \"meterReactive\", ITEM_TYPE_POWER))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_VOLTAGE, \"meterVoltage\", ITEM_TYPE_VOLT))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_CURRENT, \"meterCurrent\", ITEM_TYPE_AMP))\n+                .add(new ShellyChannel(m, CHGR_METER, CHANNEL_EMETER_PFACTOR, \"meterPowerFactor\", ITEM_TYPE_NUMBER))\n+\n+                // Sensors\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_TEMP, \"sensorTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_HUM, \"sensorHumidity\", ITEM_TYPE_PERCENT))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_LUX, \"sensorLux\", ITEM_TYPE_LUX))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_ILLUM, \"sensorIllumination\", ITEM_TYPE_STRING))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_VIBRATION, \"sensorVibration\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_FLOOD, \"sensorFlood\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_SMOKE, \"sensorSmoke\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_STATE, \"sensorState\", ITEM_TYPE_CONTACT))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_MOTION, \"sensorMotion\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_SENSOR_ERROR, \"sensorError\", ITEM_TYPE_STRING))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_LAST_UPDATE, \"lastUpdate\", ITEM_TYPE_DATETIME))\n+\n+                // Addon with external sensors\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP1, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP2, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP3, \"sensorExtTemp\", ITEM_TYPE_TEMP))\n+                .add(new ShellyChannel(m, CHGR_SENSOR, CHANNEL_ESENDOR_HUMIDITY, \"sensorExtHum\", ITEM_TYPE_PERCENT))\n+\n+                // Battery\n+                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_LEVEL, \"system:battery-level\",\n+                        ITEM_TYPE_PERCENT))\n+                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_LOW, \"system:low-battery\", ITEM_TYPE_SWITCH))\n+                .add(new ShellyChannel(m, CHGR_BAT, CHANNEL_SENSOR_BAT_VOLT, \"batVoltage\", ITEM_TYPE_VOLT))\n+\n+        ;\n+    }\n+\n+    public static ShellyChannel getDefinition(String channelName) throws IllegalArgumentException {\n+        String group = StringUtils.substringBefore(channelName, \"#\");\n+        String channel = StringUtils.substringAfter(channelName, \"#\");\n+        if (group.contains(CHANNEL_GROUP_METER)) {\n+            group = CHANNEL_GROUP_METER; // map meter1..n to meter\n+        } else if (group.contains(CHANNEL_GROUP_RELAY_CONTROL)) {\n+            group = CHANNEL_GROUP_RELAY_CONTROL; // map meter1..n to meter\n+        }\n+        String channelId = group + \"#\" + channel;\n+        return channelDefinitions.get(channelId);\n+    }\n+\n+    /**\n+     * Auto-create relay channels depending on relay type/mode\n+     *\n+     * @return ArrayList<Channel> of channels to be added to the thing\n+     */\n+    public static Map<String, Channel> createDeviceChannels(final Thing thing, final ShellyDeviceProfile profile,\n+            final ShellySettingsStatus status) {\n+        Map<String, Channel> add = new LinkedHashMap<>();\n+        if (!profile.isSensor) {\n+            // Only some devices report the internal device temp\n+            addChannel(thing, add, (status.tmp != null) || (status.temperature != null), CHANNEL_GROUP_DEV_STATUS,\n+                    CHANNEL_DEVST_ITEMP);\n+\n+            // If device has more than 1 meter the channel accumulatedWatts receives the accumulated value\n+            boolean accuChannel = (((status.meters != null) && (status.meters.size() > 1) && (status.rollers == null))\n+                    || ((status.emeters != null && status.emeters.size() > 1)));\n+            addChannel(thing, add, accuChannel, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUWATTS);\n+            addChannel(thing, add, accuChannel, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ACCUTOTAL);\n+            addChannel(thing, add, accuChannel && (status.emeters != null), CHANNEL_GROUP_DEV_STATUS,\n+                    CHANNEL_DEVST_ACCURETURNED);\n+        }\n+        return add;\n+    }\n+\n+    /**\n+     * Auto-create relay channels depending on relay type/mode\n+     *\n+     * @return ArrayList<Channel> of channels to be added to the thing\n+     */\n+    public static Map<String, Channel> createRelayChannels(final Thing thing, final ShellyStatusRelay relays) {\n+        Map<String, Channel> add = new LinkedHashMap<>();\n+\n+        // Shelly 1/1PM Addon\n+        if (relays.extTemperature != null) {\n+            addChannel(thing, add, relays.extTemperature.sensor1 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP1);\n+            addChannel(thing, add, relays.extTemperature.sensor2 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP2);\n+            addChannel(thing, add, relays.extTemperature.sensor3 != null, CHGR_SENSOR, CHANNEL_ESENDOR_TEMP3);\n+        }\n+        if (relays.extHumidity != null) {\n+            addChannel(thing, add, relays.extHumidity.sensor1 != null, CHGR_SENSOR, CHANNEL_ESENDOR_HUMIDITY);\n+        }\n+        return add;\n+    }\n+\n+    public static Map<String, Channel> createRollerChannels(Thing thing, final ShellyControlRoller roller) {\n+        Map<String, Channel> add = new LinkedHashMap<>();\n+\n+        // No dynamic channels so far, maybe added in the future\n+\n+        return add;\n+    }\n+\n+    public static Map<String, Channel> createMeterChannels(Thing thing, final ShellySettingsMeter meter, String group) {\n+        Map<String, Channel> newChannels = new LinkedHashMap<>();\n+        addChannel(thing, newChannels, meter.power != null, group, CHANNEL_METER_CURRENTWATTS);\n+        addChannel(thing, newChannels, meter.total != null, group, CHANNEL_METER_TOTALKWH);\n+        if (meter.counters != null) {\n+            addChannel(thing, newChannels, meter.counters[0] != null, group, CHANNEL_METER_LASTMIN1);\n+            addChannel(thing, newChannels, meter.counters[1] != null, group, CHANNEL_METER_LASTMIN2);\n+            addChannel(thing, newChannels, meter.counters[2] != null, group, CHANNEL_METER_LASTMIN3);\n+        }\n+        addChannel(thing, newChannels, meter.timestamp != null, group, CHANNEL_LAST_UPDATE);\n+        return newChannels;\n+    }\n+\n+    public static Map<String, Channel> createEMeterChannels(final Thing thing, final ShellySettingsEMeter emeter,\n+            String group) {\n+        Map<String, Channel> newChannels = new LinkedHashMap<>();\n+        addChannel(thing, newChannels, emeter.power != null, group, CHANNEL_METER_CURRENTWATTS);\n+        addChannel(thing, newChannels, emeter.total != null, group, CHANNEL_METER_TOTALKWH);\n+        addChannel(thing, newChannels, emeter.totalReturned != null, group, CHANNEL_EMETER_TOTALRET);\n+        addChannel(thing, newChannels, emeter.reactive != null, group, CHANNEL_EMETER_REACTWATTS);\n+        addChannel(thing, newChannels, emeter.voltage != null, group, CHANNEL_EMETER_VOLTAGE);\n+        addChannel(thing, newChannels, emeter.current != null, group, CHANNEL_EMETER_CURRENT);\n+        addChannel(thing, newChannels, emeter.pf != null, group, CHANNEL_EMETER_PFACTOR);\n+        addChannel(thing, newChannels, true, group, CHANNEL_LAST_UPDATE);\n+        return newChannels;\n+    }\n+\n+    public static Map<String, Channel> createSensorChannels(final Thing thing, final ShellyStatusSensor sdata) {\n+        Map<String, Channel> newChannels = new LinkedHashMap<>();\n+        // Sensor data\n+        addChannel(thing, newChannels, sdata.tmp != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP);\n+        addChannel(thing, newChannels, sdata.hum != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_HUM);\n+        addChannel(thing, newChannels, sdata.lux != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_LUX);\n+        addChannel(thing, newChannels, sdata.accel != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_VIBRATION);\n+        addChannel(thing, newChannels, sdata.flood != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_FLOOD);\n+        addChannel(thing, newChannels, sdata.smoke != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_FLOOD);\n+        addChannel(thing, newChannels, sdata.lux != null && sdata.lux.illumination != null, CHANNEL_GROUP_SENSOR,\n+                CHANNEL_SENSOR_ILLUM);\n+        addChannel(thing, newChannels, sdata.contact != null && sdata.contact.state != null, CHANNEL_GROUP_SENSOR,\n+                CHANNEL_SENSOR_STATE);\n+        addChannel(thing, newChannels, sdata.motion != null && sdata.contact.state != null, CHANNEL_GROUP_SENSOR,\n+                CHANNEL_SENSOR_MOTION);\n+        addChannel(thing, newChannels, sdata.charger != null, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_CHARGER);\n+        addChannel(thing, newChannels, sdata.sensorError != null, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_ERROR);\n+        addChannel(thing, newChannels, true, CHANNEL_GROUP_SENSOR, CHANNEL_LAST_UPDATE);\n+        addChannel(thing, newChannels, sdata.actReasons != null, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_WAKEUP);\n+\n+        // Battery\n+        if (sdata.bat != null) {\n+            addChannel(thing, newChannels, sdata.bat.value != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LEVEL);\n+            addChannel(thing, newChannels, sdata.bat.value != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LOW);\n+            addChannel(thing, newChannels, sdata.bat.voltage != null, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_VOLT);\n+        }\n+        return newChannels;\n+    }\n+\n+    private static void addChannel(Thing thing, Map<String, Channel> newChannels, boolean supported, String group,\n+            String channelName) throws IllegalArgumentException {\n+        if (supported) {\n+            final String channelId = group + \"#\" + channelName;\n+            final ShellyChannel channelDef = getDefinition(channelId);\n+            final ChannelUID channelUID = new ChannelUID(thing.getUID(), channelId);\n+            final ChannelTypeUID channelTypeUID = channelDef.typeId.contains(\"system:\")\n+                    ? new ChannelTypeUID(channelDef.typeId)\n+                    : new ChannelTypeUID(BINDING_ID, channelDef.typeId);\n+\n+            // Channel channel = ChannelBuilder.create(channelUID, channelId).withType(channelTypeUID)\n+            // .withLabel(channelDef.label).withDescription(channelDef.description).build();\n+            Channel channel = ChannelBuilder.create(channelUID, channelDef.itemType).withType(channelTypeUID).build();\n+            newChannels.put(channelId, channel);\n+        }\n+    }\n+\n+    public static String ITEM_TYPE_NUMBER = \"Number\";\n+    public static String ITEM_TYPE_STRING = \"String\";\n+    public static String ITEM_TYPE_DATETIME = \"DateTime\";\n+    public static String ITEM_TYPE_TEMP = \"Number:Temperature\";\n+    public static String ITEM_TYPE_LUX = \"Number:Illuminance\";\n+    public static String ITEM_TYPE_POWER = \"Number:Power\";\n+    public static String ITEM_TYPE_ENERGY = \"Number:Energy\";\n+    public static String ITEM_TYPE_VOLT = \"Number:ElectricPotential\";\n+    public static String ITEM_TYPE_AMP = \"Number:ElectricPotential\";\n+    public static String ITEM_TYPE_PERCENT = \"Number:Dimensionless\";\n+    public static String ITEM_TYPE_SWITCH = \"Switch\";\n+    public static String ITEM_TYPE_CONTACT = \"Contact\";\n+\n+    public static String PREFIX_GROUP = \"definitions.shelly.group.\";\n+    public static String PREFIX_CHANNEL = \"channel-type.shelly.\";\n+    public static String SUFFIX_LABEL = \".label\";\n+    public static String SUFFIX_DESCR = \".description\";", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxNDUxNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405714517", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-08T18:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMjk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMzI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404403283", "bodyText": "Why are all these fields package private?", "author": "cpmeister", "createdAt": "2020-04-06T21:35:56Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyColorUtils.java", "diffHunk": "@@ -29,10 +28,34 @@\n  */\n @NonNullByDefault\n public class ShellyColorUtils {\n+    OnOffType power = OnOffType.OFF;\n+    String mode = \"\";\n+\n+    int red = 0;\n+    int green = 0;\n+    int blue = 0;\n+    int white = 0;\n+    PercentType percentRed = new PercentType(0);\n+    PercentType percentGreen = new PercentType(0);\n+    PercentType percentBlue = new PercentType(0);\n+    PercentType percentWhite = new PercentType(0);\n+\n+    int gain = 0;\n+    int brightness = 0;\n+    int temp = 0;\n+    int minTemp = 0;\n+    int maxTemp = 0;\n+    PercentType percentGain = new PercentType(0);\n+    PercentType percentBrightness = new PercentType(0);\n+    PercentType percentTemp = new PercentType(0);\n+    Integer effect = 0;", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzNTMzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405335336", "bodyText": "No, they are accessed in ShellyLightHandler", "author": "markus7017", "createdAt": "2020-04-08T08:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwMzI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNTkwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404405900", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        api.setRelayTurn(index, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n          \n          \n            \n                        api.setRelayTurn(index, command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);", "author": "cpmeister", "createdAt": "2020-04-06T21:41:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyRelayHandler.java", "diffHunk": "@@ -174,7 +164,7 @@ private void handleBrightness(Command command, Integer index) throws IOException\n         if (command instanceof OnOffType) { // Switch\n             logger.debug(\"Switch output {}\", command.toString());\n             api.setRelayTurn(index, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzNjQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405336403", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T08:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNTkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407266141", "bodyText": "You forgot to change this", "author": "cpmeister", "createdAt": "2020-04-12T23:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNTkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NDE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407664148", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-13T19:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNTkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNjk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r404406960", "bodyText": "Some of our build tools don't like EOF without a newline. So add a newline here.", "author": "cpmeister", "createdAt": "2020-04-06T21:43:44Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyTranslationProvider.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import java.util.Locale;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.osgi.framework.Bundle;\n+\n+/**\n+ * {@link ShellyTranslationProvider} provides i18n message lookup\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyTranslationProvider {\n+\n+    private final Bundle bundle;\n+    private final TranslationProvider i18nProvider;\n+    private final LocaleProvider localeProvider;\n+\n+    public ShellyTranslationProvider(Bundle bundle, TranslationProvider i18nProvider, LocaleProvider localeProvider) {\n+        this.bundle = bundle;\n+        this.i18nProvider = i18nProvider;\n+        this.localeProvider = localeProvider;\n+    }\n+\n+    public ShellyTranslationProvider(final ShellyTranslationProvider other) {\n+        this.bundle = other.bundle;\n+        this.i18nProvider = other.i18nProvider;\n+        this.localeProvider = other.localeProvider;\n+    }\n+\n+    public @Nullable String get(String key, @Nullable Object... arguments) {\n+        return getText(key.contains(\"@text/\") || key.contains(\".shelly.\") ? key : \"message.\" + key, arguments);\n+    }\n+\n+    public @Nullable String getText(String key, @Nullable Object... arguments) {\n+        Locale locale = localeProvider.getLocale();\n+        return i18nProvider.getText(bundle, key, getDefaultText(key), locale, arguments);\n+    }\n+\n+    public @Nullable String getDefaultText(String key) {\n+        return i18nProvider.getText(bundle, key, key, Locale.ENGLISH);\n+    }\n+}", "originalCommit": "a7ec663a0eaa84e50b049543da55ade8fd2a689f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzNjY1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r405336656", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-08T08:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNjk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0OTU5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407149595", "bodyText": "The EOF is still here.", "author": "cpmeister", "createdAt": "2020-04-12T05:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwNjk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2ODY3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r406868678", "bodyText": "What happened to this version?", "author": "cpmeister", "createdAt": "2020-04-10T17:49:25Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyBindingConstants.java", "diffHunk": "@@ -250,9 +250,8 @@\n     public static final String CHANNEL_BUTTON_TRIGGER = \"button\";\n \n     public static final String SERVICE_TYPE = \"_http._tcp.local.\";\n-    public static final String SHELLY_API_MIN_FWVERSION = \"v1.5.7\";// v1.5.2\n-    public static final String SHELLY_API_MIN_FWCOIOT_STD = \"v1.6\";// v1.5.2\n-    public static final String SHELLY_API_MIN_FWCOIOT_SENSOR = \"v1.7\";// v1.5.2", "originalCommit": "051f5eb2df1b08fed2ca04f6a2532ed74857829c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyODk4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407028989", "bodyText": "I don't know what's displayed here. This is the latest code:\n    public static final String SERVICE_TYPE = \"_http._tcp.local.\";\n    public static final String SHELLY_API_MIN_FWVERSION = \"v1.5.7\";// v1.5.7+\n    public static final String SHELLY_API_MIN_FWCOIOT = \"v1.6\";// v1.6.0+", "author": "markus7017", "createdAt": "2020-04-11T07:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg2ODY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407144012", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.trace(\"{}: convert {}% into {}/{} (factor={})\", thingName, colorPercent.toString(), value.toString(),\n          \n          \n            \n                    logger.trace(\"{}: convert {}% into {}/{} (factor={})\", thingName, colorPercent, value,", "author": "cpmeister", "createdAt": "2020-04-12T04:26:30Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java", "diffHunk": "@@ -513,8 +513,8 @@ private Integer getColorFromHSB(PercentType colorPercent) {\n \n     private Integer getColorFromHSB(PercentType colorPercent, Double factor) {\n         Double value = new Double(Math.round(colorPercent.doubleValue() * factor));\n-        logger.trace(\"convert {}% into {}/{} (factor={})\", colorPercent.toString(), value.toString(), value.intValue(),\n-                factor.toString());\n+        logger.trace(\"{}: convert {}% into {}/{} (factor={})\", thingName, colorPercent.toString(), value.toString(),", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMDQ3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407210478", "bodyText": "removed all toString() in logger statements in this file, will do step-by-step with the other files too", "author": "markus7017", "createdAt": "2020-04-12T15:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDk5OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407144998", "bodyText": "This won't actually break out early from the loop since you are using a lambda, you need to put this in a proper loop.", "author": "cpmeister", "createdAt": "2020-04-12T04:40:46Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -142,25 +152,21 @@ protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n+    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n+            Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n-        for (ShellyDeviceListener listener : deviceListeners) {\n-            try {\n-                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n-                    // event processed\n-                    break;\n-                }\n-            } catch (NullPointerException e) {\n-                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n-                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n-                        e.getStackTrace());\n-                // continue with next listener\n+        deviceListeners.forEach(listener -> {\n+            if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n+                // event processed\n+                return;", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMjc1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407212754", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T15:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NDk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145014", "bodyText": "needed?", "author": "cpmeister", "createdAt": "2020-04-12T04:40:59Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/ShellyHandlerFactory.java", "diffHunk": "@@ -142,25 +152,21 @@ protected synchronized void removeHandler(@NonNull ThingHandler thingHandler) {\n      * @param eventType Type of event, e.g. light\n      * @param parameters Input parameters from URL, e.g. on sensor reports\n      */\n-    public void onEvent(String deviceName, String componentIndex, String eventType, Map<String, String> parameters) {\n+    public void onEvent(String ipAddress, String deviceName, String componentIndex, String eventType,\n+            Map<String, String> parameters) {\n         logger.trace(\"Dispatch event to device handler {}\", deviceName);\n-        for (ShellyDeviceListener listener : deviceListeners) {\n-            try {\n-                if (listener.onEvent(deviceName, componentIndex, eventType, parameters)) {\n-                    // event processed\n-                    break;\n-                }\n-            } catch (NullPointerException e) {\n-                logger.debug(\"Unable to process callback: {} ({}), deviceName={}, type={}, index={}, parameters={}\\n{}\",\n-                        e.getMessage(), e.getClass(), deviceName, eventType, componentIndex, parameters.toString(),\n-                        e.getStackTrace());\n-                // continue with next listener\n+        deviceListeners.forEach(listener -> {\n+            if (listener.onEvent(ipAddress, deviceName, componentIndex, eventType, parameters)) {\n+                // event processed\n+                return;\n             }\n-        }\n+        });\n     }\n \n-    @Nullable\n     public ShellyBindingConfiguration getBindingConfig() {\n         return bindingConfig;\n     }\n+\n+    public void dispose() {\n+    }", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMDkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407210929", "bodyText": "no", "author": "markus7017", "createdAt": "2020-04-12T15:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTI3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145278", "bodyText": "Actually now that I think of it, why do you need this field anyway? Can't you just call getCause instead?", "author": "cpmeister", "createdAt": "2020-04-12T04:44:27Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiException.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.api;\n+\n+import java.net.MalformedURLException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link CarNetException} implements an extension to the standard Exception class. This allows to keep also the\n+ * result of the last API call (e.g. including the http status code in the message).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyApiException extends Exception {\n+    private static final long serialVersionUID = -5809459454769761821L;\n+\n+    private ShellyApiResult apiResult = new ShellyApiResult();\n+    private static String EX_NONE = \"none\";\n+    private Exception exception = new Exception(EX_NONE);", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNTU4OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407235588", "bodyText": "I don't think so.\nexception is the class causing the exception and ShellyApiException was constructed with. getClass() would return ShellyApiException, super. getClass() would return Exception, but I want to know which was the original exception type\ncorrect?", "author": "markus7017", "createdAt": "2020-04-12T18:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTIyMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407265222", "bodyText": "You can call getCause().getClass() to check the class. Just make sure to handle the case when getCause() returns null.", "author": "cpmeister", "createdAt": "2020-04-12T23:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3OTYwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408179601", "bodyText": "changed, needs to be tested", "author": "markus7017", "createdAt": "2020-04-14T14:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTI3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NTEzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408265131", "bodyText": "@cpmeister could you please review this change", "author": "markus7017", "createdAt": "2020-04-14T16:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTM0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145348", "bodyText": "Just to be consistent\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public final static String SHELLY_API_ILLUM_DARK = \"dark\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_TWILIGHT = \"twilight\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_BRIGHT = \"bright\";\n          \n          \n            \n                public final static String SHELLY_API_DWSTATE_OPEN = \"open\";\n          \n          \n            \n                public final static String SHELLY_API_DWSTATE_CLOSE = \"close\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_DARK = \"dark\";\n          \n          \n            \n                public final static String SHELLY_API_ILLUM_TWILIGHT = \"twilight\";\n          \n          \n            \n                public static final String SHELLY_API_ILLUM_BRIGHT = \"bright\";\n          \n          \n            \n                public static final String SHELLY_API_DWSTATE_OPEN = \"open\";\n          \n          \n            \n                public static final String SHELLY_API_DWSTATE_CLOSE = \"close\";", "author": "cpmeister", "createdAt": "2020-04-12T04:45:28Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyApiJsonDTO.java", "diffHunk": "@@ -22,15 +22,166 @@\n  * @author Markus Michels - Initial contribution\n  */\n public class ShellyApiJsonDTO {\n+    public static final String SHELLY_NULL_URL = \"null\";\n+    public static final String SHELLY_URL_DEVINFO = \"/shelly\";\n+    public static final String SHELLY_URL_STATUS = \"/status\";\n+    public static final String SHELLY_URL_SETTINGS = \"/settings\";\n+    public static final String SHELLY_URL_SETTINGS_AP = \"/settings/ap\";\n+    public static final String SHELLY_URL_SETTINGS_STA = \"/settings/sta\";\n+    public static final String SHELLY_URL_SETTINGS_LOGIN = \"/settings/sta\";\n+    public static final String SHELLY_URL_SETTINGS_CLOUD = \"/settings/cloud\";\n+    public static final String SHELLY_URL_LIST_IR = \"/ir/list\";\n+    public static final String SHELLY_URL_SEND_IR = \"/ir/emit\";\n+\n+    public static final String SHELLY_URL_SETTINGS_RELAY = \"/settings/relay\";\n+    public static final String SHELLY_URL_STATUS_RELEAY = \"/status/relay\";\n+    public static final String SHELLY_URL_CONTROL_RELEAY = \"/relay\";\n+\n+    public static final String SHELLY_URL_SETTINGS_EMETER = \"/settings/emeter\";\n+    public static final String SHELLY_URL_STATUS_EMETER = \"/emeter\";\n+    public static final String SHELLY_URL_DATA_EMETER = \"/emeter/{0}/em_data.csv\";\n+\n+    public static final String SHELLY_URL_CONTROL_ROLLER = \"/roller\";\n+    public static final String SHELLY_URL_SETTINGS_ROLLER = \"/settings/roller\";\n+\n+    public static final String SHELLY_URL_SETTINGS_LIGHT = \"/settings/light\";\n+    public static final String SHELLY_URL_STATUS_LIGHT = \"/light\";\n+    public static final String SHELLY_URL_CONTROL_LIGHT = \"/light\";\n+\n+    public static final String SHELLY_URL_SETTINGS_DIMMER = \"/settings/light\";\n+\n+    //\n+    // Action URLs according to the device type\n+    //\n+    public static final String SHELLY_EVENTURL_SUFFIX = \"_url\";\n+\n+    // Relay\n+    public static final String SHELLY_EVENT_BTN_ON = \"btn_on\";\n+    public static final String SHELLY_EVENT_BTN_OFF = \"btn_off\";\n+    public static final String SHELLY_EVENT_OUT_ON = \"out_on\";\n+    public static final String SHELLY_EVENT_OUT_OFF = \"out_off\";\n+    public static final String SHELLY_EVENT_SHORTPUSH = \"shortpush\";\n+    public static final String SHELLY_EVENT_LONGPUSH = \"longpush\";\n+\n+    // Dimmer\n+    public static final String SHELLY_EVENT_BTN1_ON = \"btn1_on\";\n+    public static final String SHELLY_EVENT_BTN1_OFF = \"btn1_off\";\n+    public static final String SHELLY_EVENT_BTN2_ON = \"btn2_on\";\n+    public static final String SHELLY_EVENT_BTN2_OFF = \"btn2_off\";\n+    public static final String SHELLY_EVENT_SHORTPUSH1 = \"btn1_shortpush\";\n+    public static final String SHELLY_EVENT_LONGPUSH1 = \"btn1_longpush\";\n+    public static final String SHELLY_EVENT_SHORTPUSH2 = \"btn2_shortpush\";\n+    public static final String SHELLY_EVENT_LONGPUSH2 = \"btn2_longpush\";\n+\n+    // Roller\n+    public static final String SHELLY_EVENT_ROLLER_OPEN = \"roller_open\";\n+    public static final String SHELLY_EVENT_ROLLER_CLOSE = \"roller_close\";\n+    public static final String SHELLY_EVENT_ROLLER_STOP = \"roller_stop\";\n+\n+    // Sensors\n+    public static final String SHELLY_EVENT_SENSORREPORT = \"report\";\n+    public static final String SHELLY_EVENT_DARK = \"dark\";\n+    public static final String SHELLY_EVENT_TWILIGHT = \"twilight\";\n+    public static final String SHELLY_EVENT_FLOOD_DETECTED = \"flood_detected\";\n+    public static final String SHELLY_EVENT_FLOOD_GONE = \"flood_gone\";\n+\n+    //\n+    // API values\n+    //\n+    public static final String SHELLY_BTNT_MOMENTARY = \"momentary\";\n+    public static final String SHELLY_BTNT_TOGGLE = \"toggle\";\n+    public static final String SHELLY_BTNT_EDGE = \"edge\";\n+    public static final String SHELLY_BTNT_DETACHED = \"detached\";\n+    public static final String SHELLY_STATE_LAST = \"last\";\n+    public static final String SHELLY_STATE_STOP = \"stop\";\n+    public static final String SHELLY_INP_MODE_OPENCLOSE = \"openclose\";\n+    public static final String SHELLY_OBSTMODE_DISABLED = \"disabled\";\n+    public static final String SHELLY_SAFETYM_WHILEOPENING = \"while_opening\";\n+    public static final String SHELLY_ALWD_TRIGGER_NONE = \"none\";\n+    public static final String SHELLY_ALWD_ROLLER_TURN_OPEN = \"open\";\n+    public static final String SHELLY_ALWD_ROLLER_TURN_CLOSE = \"close\";\n+    public static final String SHELLY_ALWD_ROLLER_TURN_STOP = \"stop\";\n+\n+    // API Error Codes\n+    public static final String SHELLY_APIERR_UNAUTHORIZED = \"Unauthorized\";\n+    public static final String SHELLY_APIERR_TIMEOUT = \"Timeout\";\n+    public static final String SHELLY_APIERR_NOT_CALIBRATED = \"Not calibrated!\";\n+\n+    // API device types / properties\n+    public static final String SHELLY_CLASS_RELAY = \"relay\"; // Relay: relay mode\n+    public static final String SHELLY_CLASS_ROLLER = \"roller\"; // Relay: roller mode\n+    public static final String SHELLY_CLASS_LIGHT = \"light\"; // Bulb: color mode\n \n     public static final String SHELLY_API_ON = \"on\";\n     public static final String SHELLY_API_OFF = \"off\";\n     public static final String SHELLY_API_TRUE = \"true\";\n     public static final String SHELLY_API_FALSE = \"false\";\n \n-    public static final String SHELLY_CLASS_RELAY = \"relay\"; // Relay: relay mode\n-    public static final String SHELLY_CLASS_ROLLER = \"roller\"; // Relay: roller mode\n-    public static final String SHELLY_CLASS_LIGHT = \"light\"; // Bulb: color mode\n+    public static final String SHELLY_API_MODE = \"mode\";\n+    public static final String SHELLY_MODE_RELAY = \"relay\"; // Relay: relay mode\n+    public static final String SHELLY_MODE_ROLLER = \"roller\"; // Relay: roller mode\n+    public static final String SHELLY_MODE_COLOR = \"color\"; // Bulb/RGBW2: color mode\n+    public static final String SHELLY_MODE_WHITE = \"white\"; // Bulb/RGBW2: white mode\n+\n+    public static final String SHELLY_LED_STATUS_DISABLE = \"led_status_disable\";\n+    public static final String SHELLY_LED_POWER_DISABLE = \"led_power_disable\";\n+\n+    public static final String SHELLY_API_STOPR_NORMAL = \"normal\";\n+    public static final String SHELLY_API_STOPR_SAFETYSW = \"safety_switch\";\n+    public static final String SHELLY_API_STOPR_OBSTACLE = \"obstacle\";\n+\n+    public static final String SHELLY_TIMER_AUTOON = \"auto_on\";\n+    public static final String SHELLY_TIMER_AUTOOFF = \"auto_off\";\n+    public static final String SHELLY_TIMER_ACTIVE = \"has_timer\";\n+\n+    public static final String SHELLY_LIGHT_TURN = \"turn\";\n+    public static final String SHELLY_LIGHT_DEFSTATE = \"def_state\";\n+    public static final String SHELLY_LIGHTTIMER = \"timer\";\n+\n+    public static final String SHELLY_COLOR_RED = \"red\";\n+    public static final String SHELLY_COLOR_BLUE = \"blue\";\n+    public static final String SHELLY_COLOR_GREEN = \"green\";\n+    public static final String SHELLY_COLOR_YELLOW = \"yellow\";\n+    public static final String SHELLY_COLOR_WHITE = \"white\";\n+    public static final String SHELLY_COLOR_GAIN = \"gain\";\n+    public static final String SHELLY_COLOR_BRIGHTNESS = \"brightness\";\n+    public static final String SHELLY_COLOR_TEMP = \"temp\";\n+    public static final String SHELLY_COLOR_EFFECT = \"effect\";\n+\n+    public static final int SHELLY_MIN_ROLLER_POS = 0;\n+    public static final int SHELLY_MAX_ROLLER_POS = 100;\n+    public static final int SHELLY_MIN_BRIGHTNESS = 0;\n+    public static final int SHELLY_MAX_BRIGHTNESS = 100;\n+    public static final int SHELLY_MIN_GAIN = 0;\n+    public static final int SHELLY_MAX_GAIN = 100;\n+    public static final int SHELLY_MIN_COLOR = 0;\n+    public static final int SHELLY_MAX_COLOR = 255;\n+    public static final int SHELLY_DIM_STEPSIZE = 10;\n+\n+    // color temperature: 3000 = warm, 4750 = white, 6565 = cold; gain: 0..100\n+    public static final int MIN_COLOR_TEMP_BULB = 3000;\n+    public static final int MAX_COLOR_TEMP_BULB = 6500;\n+    public static final int MIN_COLOR_TEMP_DUO = 2700;\n+    public static final int MAX_COLOR_TEMP_DUO = 6500;\n+    public static final int COLOR_TEMP_RANGE_BULB = MAX_COLOR_TEMP_DUO - MIN_COLOR_TEMP_DUO;\n+    public static final int COLOR_TEMP_RANGE_DUO = MAX_COLOR_TEMP_DUO - MIN_COLOR_TEMP_DUO;\n+    public static final double MIN_BRIGHTNESS = 0.0;\n+    public static final double MAX_BRIGHTNESS = 100.0;\n+    public static final double SATURATION_FACTOR = 2.55;\n+    public static final double GAIN_FACTOR = SHELLY_MAX_GAIN / 100;\n+    public static final double BRIGHTNESS_FACTOR = SHELLY_MAX_BRIGHTNESS / 100;\n+\n+    // Door/Window\n+    public final static String SHELLY_API_ILLUM_DARK = \"dark\";\n+    public final static String SHELLY_API_ILLUM_TWILIGHT = \"twilight\";\n+    public final static String SHELLY_API_ILLUM_BRIGHT = \"bright\";\n+    public final static String SHELLY_API_DWSTATE_OPEN = \"open\";\n+    public final static String SHELLY_API_DWSTATE_CLOSE = \"close\";", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyNjE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407226154", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T17:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTgyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145825", "bodyText": "You said you moved it to ShellyThingCreator but the code is still here...", "author": "cpmeister", "createdAt": "2020-04-12T04:50:58Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyDeviceProfile.java", "diffHunk": "@@ -54,104 +60,216 @@\n     public String fwVersion = \"\";\n     public String fwDate = \"\";\n \n-    public Boolean hasRelays = false; // true if it has at least 1 power meter\n-    public Integer numRelays = 0; // number of relays/outputs\n-    public Integer numRollers = 9; // number of Rollers, usually 1\n-    public Boolean isRoller = false; // true for Shelly2 in roller mode\n-    public Boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n-\n-    public Boolean hasMeter = false; // true if it has at least 1 power meter\n-    public Integer numMeters = 0;\n-    public Boolean isEMeter = false; // true for ShellyEM\n-\n-    public Boolean hasBattery = false; // true if battery device\n-    public Boolean hasLed = false; // true if battery device\n-    public Boolean isPlugS = false; // true if it is a Shelly Plug S\n-    public Boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n-    public Boolean isBulb = false; // true pnly if it is a Bulb\n-    public Boolean isSense = false; // true if thing is a Shelly Sense\n-    public Boolean inColor = false; // true if bulb/rgbw2 is in color mode\n-    public Boolean isSensor = false; // true for HT & Smoke\n-    public Boolean isSmoke = false; // true for Smoke\n+    public boolean hasRelays = false; // true if it has at least 1 power meter\n+    public int numRelays = 0; // number of relays/outputs\n+    public int numRollers = 0; // number of Rollers, usually 1\n+    public boolean isRoller = false; // true for Shelly2 in roller mode\n+    public boolean isDimmer = false; // true for a Shelly Dimmer (SHDM-1)\n+    public boolean isPlugS = false; // true if it is a Shelly Plug S\n \n-    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n+    public int numMeters = 0;\n+    public boolean isEMeter = false; // true for ShellyEM/EM3\n+\n+    public boolean isLight = false; // true if it is a Shelly Bulb/RGBW2\n+    public boolean isBulb = false; // true only if it is a Bulb\n+    public boolean isDuo = false; // true only if it is a Duo\n+    public boolean isRGBW2 = false; // true only if it a a RGBW2\n+    public boolean inColor = false; // true if bulb/rgbw2 is in color mode\n+    public boolean hasLed = false; // true if battery device\n+\n+    public boolean isSensor = false; // true for HT & Smoke\n+    public boolean hasBattery = false; // true if battery device\n+    public boolean isSense = false; // true if thing is a Shelly Sense\n+    public boolean isDW = false; // true of Door Window sensor\n \n-    public Boolean supportsButtonUrls = false; // true if the btn_xxx urls are supported\n-    public Boolean supportsOutUrls = false; // true if the out_xxx urls are supported\n-    public Boolean supportsPushUrls = false; // true if sensor report_url is supported\n-    public Boolean supportsRollerUrls = false; // true if the roller_xxx urls are supported\n-    public Boolean supportsSensorUrls = false; // true if sensor report_url is supported\n+    public int minTemp = 0; // Bulb/Duo: Min Light Temp\n+    public int maxTemp = 0; // Bulb/Duo: Max Light Temp\n+\n+    public int updatePeriod = -1;\n+\n+    public Map<String, String> irCodes = new HashMap<>(); // Sense: list of stored IR codes\n \n-    @SuppressWarnings(\"null\")\n-    public static ShellyDeviceProfile initialize(String thingType, String json) {\n+    public ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n         Gson gson = new Gson();\n \n-        ShellyDeviceProfile profile = new ShellyDeviceProfile();\n-        Validate.notNull(profile);\n+        initialized = false;\n \n-        profile.settingsJson = json;\n-        profile.settings = gson.fromJson(json, ShellySettingsGlobal.class);\n-        Validate.notNull(profile.settings, \"converted device settings must not be null!\");\n+        try {\n+            initFromThingType(thingType);\n+            settingsJson = json;\n+            settings = gson.fromJson(json, ShellySettingsGlobal.class);\n+        } catch (IllegalArgumentException | JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    thingName + \": Unable to transform settings JSON \" + e.toString() + \", json='\" + json + \"'\");\n+        }\n \n         // General settings\n-        profile.deviceType = ShellyUtils.getString(profile.settings.device.type);\n-        profile.mac = getString(profile.settings.device.mac);\n-        profile.hostname = profile.settings.device.hostname != null && !profile.settings.device.hostname.isEmpty()\n-                ? profile.settings.device.hostname.toLowerCase()\n-                : \"shelly-\" + profile.mac.toUpperCase().substring(6, 11);\n-        profile.mode = getString(profile.settings.mode) != null ? getString(profile.settings.mode).toLowerCase() : \"\";\n-        profile.hwRev = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.hwRevision) : \"\";\n-        profile.hwBatchId = profile.settings.hwinfo != null ? getString(profile.settings.hwinfo.batchId.toString())\n-                : \"\";\n-        profile.fwDate = getString(StringUtils.substringBefore(profile.settings.fw, \"/\"));\n-        profile.fwVersion = getString(StringUtils.substringBetween(profile.settings.fw, \"/\", \"@\"));\n-        profile.fwId = getString(StringUtils.substringAfter(profile.settings.fw, \"@\"));\n-\n-        profile.isRoller = profile.mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n-        profile.isPlugS = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS.getId());\n-        profile.hasLed = profile.isPlugS;\n-        profile.isBulb = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYBULB.getId());\n-        profile.isDimmer = profile.deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n-        profile.isLight = profile.isBulb\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_COLOR.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYRGBW2_WHITE.getId());\n-        profile.inColor = profile.isLight && profile.mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n-\n-        profile.isSmoke = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId());\n-        profile.isSense = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.isSensor = profile.isSense || profile.isSmoke\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-        profile.hasBattery = thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYHT.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSMOKE.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYFLOOD.getId())\n-                || thingType.equalsIgnoreCase(ShellyBindingConstants.THING_TYPE_SHELLYSENSE.getId());\n-\n-        profile.numRelays = !profile.isLight ? getInteger(profile.settings.device.numOutputs) : 0;\n-        if ((profile.numRelays > 0) && (profile.settings.relays == null)) {\n-            profile.numRelays = 0;\n-        }\n-        profile.hasRelays = (profile.numRelays > 0) || profile.isDimmer;\n-        profile.numRollers = getInteger(profile.settings.device.numRollers);\n-\n-        profile.isEMeter = profile.settings.emeters != null;\n-        profile.numMeters = !profile.isEMeter ? getInteger(profile.settings.device.numMeters)\n-                : getInteger(profile.settings.device.numEMeters);\n-        if ((profile.numMeters == 0) && profile.isLight) {\n+        deviceType = ShellyUtils.getString(settings.device.type);\n+        mac = getString(settings.device.mac);\n+        hostname = settings.device.hostname != null && !settings.device.hostname.isEmpty()\n+                ? settings.device.hostname.toLowerCase()\n+                : \"shelly-\" + mac.toUpperCase().substring(6, 11);\n+        mode = !getString(settings.mode).isEmpty() ? getString(settings.mode).toLowerCase() : \"\";\n+        hwRev = settings.hwinfo != null ? getString(settings.hwinfo.hwRevision) : \"\";\n+        hwBatchId = settings.hwinfo != null ? getString(settings.hwinfo.batchId.toString()) : \"\";\n+        fwDate = getString(StringUtils.substringBefore(settings.fw, \"/\"));\n+        fwVersion = getString(StringUtils.substringBetween(settings.fw, \"/\", \"@\"));\n+        fwId = getString(StringUtils.substringAfter(settings.fw, \"@\"));\n+        discoverable = (settings.discoverable == null) || settings.discoverable;\n+\n+        inColor = isLight && mode.equalsIgnoreCase(SHELLY_MODE_COLOR);\n+\n+        numRelays = !isLight ? getInteger(settings.device.numOutputs) : 0;\n+        if ((numRelays > 0) && (settings.relays == null)) {\n+            numRelays = 0;\n+        }\n+        hasRelays = (numRelays > 0) || isDimmer;\n+        numRollers = getInteger(settings.device.numRollers);\n+\n+        isEMeter = settings.emeters != null;\n+        numMeters = !isEMeter ? getInteger(settings.device.numMeters) : getInteger(settings.device.numEMeters);\n+        if ((numMeters == 0) && isLight) {\n             // RGBW2 doesn't report, but has one\n-            profile.numMeters = profile.inColor ? 1 : getInteger(profile.settings.device.numOutputs);\n+            numMeters = inColor ? 1 : getInteger(settings.device.numOutputs);\n+        }\n+        isDimmer = deviceType.equalsIgnoreCase(SHELLYDT_DIMMER);\n+        isRoller = mode.equalsIgnoreCase(SHELLY_MODE_ROLLER);\n+\n+        if (settings.sleepMode != null) {\n+            updatePeriod = getString(settings.sleepMode.unit).equalsIgnoreCase(\"m\") ? settings.sleepMode.period * 60 // minutes\n+                    : settings.sleepMode.period * 3600; // hours\n+        } else if ((settings.coiot != null) && (settings.coiot.updatePeriod != null)) {\n+            updatePeriod = 2 * getInteger(settings.coiot.updatePeriod) + 5; // usually 2*15+5s=50sec\n+        } else {\n+            updatePeriod = 2 * 15 + 5; // Default acc. CoIoT Spec\n         }\n-        profile.hasMeter = (profile.numMeters > 0);\n \n-        profile.supportsButtonUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)\n-                || profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN2_ON);\n-        profile.supportsOutUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_OUT_ON);\n-        profile.supportsPushUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_SHORT_PUSH);\n-        profile.supportsRollerUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_ROLLER_OPEN);\n-        profile.supportsSensorUrls = profile.settingsJson.contains(SHELLY_API_EVENTURL_REPORT);\n+        initialized = true;\n+        return this;\n+    }\n+\n+    public boolean containsEventUrl(String eventType) {\n+        return containsEventUrl(settingsJson, eventType);\n+    }\n+\n+    public boolean containsEventUrl(String json, String eventType) {\n+        String settings = json.toLowerCase();\n+        return settings.contains((eventType + SHELLY_EVENTURL_SUFFIX).toLowerCase());\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    public void initFromThingType(String name) {\n+        String thingType = (name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name).toLowerCase().trim();\n+        if (thingType.isEmpty()) {\n+            return;\n+        }\n+\n+        isPlugS = thingType.equals(ShellyBindingConstants.THING_TYPE_SHELLYPLUGS_STR);\n+\n+        isBulb = thingType.equals(THING_TYPE_SHELLYBULB_STR);\n+        isDuo = thingType.equals(THING_TYPE_SHELLYDUO_STR) || thingType.equals(THING_TYPE_SHELLYVINTAGE_STR);\n+        isRGBW2 = thingType.startsWith(THING_TYPE_SHELLYRGBW2_PREFIX);\n+        hasLed = isPlugS;\n+        isLight = isBulb || isDuo || isRGBW2;\n+        minTemp = isBulb ? MIN_COLOR_TEMP_BULB : MIN_COLOR_TEMP_DUO;\n+        maxTemp = isBulb ? MAX_COLOR_TEMP_BULB : MAX_COLOR_TEMP_DUO;\n+\n+        boolean isHT = thingType.equals(THING_TYPE_SHELLYHT_STR);\n+        boolean isFlood = thingType.equals(THING_TYPE_SHELLYFLOOD_STR);\n+        boolean isSmoke = thingType.equals(THING_TYPE_SHELLYSMOKE_STR);\n+        isDW = thingType.equals(THING_TYPE_SHELLYDOORWIN_STR);\n+        isSense = thingType.equals(THING_TYPE_SHELLYSENSE_STR);\n+        isSensor = isHT || isFlood || isDW || isSmoke || isSense;\n+        hasBattery = isHT || isFlood || isDW || isSmoke; // we assume that Sense is connected to the charger\n+    }\n+\n+    public static ThingUID getThingUID(String serviceName, String mode, boolean unknown) {", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyODI1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407228259", "bodyText": "hmm, was pretty sure,\u00b4, but it was still there\nnow removed", "author": "markus7017", "createdAt": "2020-04-12T17:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTkyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407145928", "bodyText": "You said you removed this...", "author": "cpmeister", "createdAt": "2020-04-12T04:52:09Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -54,40 +52,44 @@\n     private static final long serialVersionUID = 549582869577534569L;\n     private final Logger logger = LoggerFactory.getLogger(ShellyEventServlet.class);\n \n-    private @Nullable HttpService httpService;\n-    private @Nullable ShellyHandlerFactory handlerFactory;\n+    private final HttpService httpService;\n+    private final ShellyHandlerFactory handlerFactory;\n \n-    @SuppressWarnings(\"null\")\n     @Activate\n-    protected void activate(Map<String, Object> config) {\n+    public ShellyEventServlet(@Reference HttpService httpService, @Reference ShellyHandlerFactory handlerFactory,\n+            Map<String, Object> config) {\n+        this.httpService = httpService;\n+        this.handlerFactory = handlerFactory;\n         try {\n             httpService.registerServlet(SHELLY_CALLBACK_URI, this, null, httpService.createDefaultHttpContext());\n-            logger.debug(\"Shelly: CallbackServlet started at '{}'\", SHELLY_CALLBACK_URI);\n-        } catch (NamespaceException | ServletException e) {\n-            logger.warn(\"Shelly: Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n+            logger.debug(\"ShellyEventServlet started at '{}'\", SHELLY_CALLBACK_URI);\n+        } catch (NamespaceException | ServletException | IllegalArgumentException e) {\n+            logger.warn(\"Could not start CallbackServlet: {} ({})\", e.getMessage(), e.getClass());\n         }\n     }\n \n     @Deactivate\n-    @SuppressWarnings(\"null\")\n     protected void deactivate() {\n-        if (httpService != null) {\n-            httpService.unregister(SHELLY_CALLBACK_URI);\n-        }\n-        logger.debug(\"Shelly: CallbackServlet stopped\");\n+        httpService.unregister(SHELLY_CALLBACK_URI);\n+        logger.debug(\"ShellyEventServlet stopped\");\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n     protected void service(@Nullable HttpServletRequest request, @Nullable HttpServletResponse resp)\n-            throws ServletException, IOException {\n-        String data = inputStreamToString(request);\n-        String path = request.getRequestURI().toLowerCase();\n+            throws ServletException, IOException, IllegalArgumentException {\n+        String data = \"\";\n+        String path = \"\";\n         String deviceName = \"\";\n         String index = \"\";\n         String type = \"\";\n \n+        if ((request == null) || (resp == null)) {\n+            throw new IllegalArgumentException(\"Servlet: request or resp must not be null!\");", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNjMzOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407716338", "bodyText": "Are you forgetting to change this or ignoring it?", "author": "cpmeister", "createdAt": "2020-04-13T20:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MDYwOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408180608", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T14:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjEyNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146124", "bodyText": "Can you make this final?", "author": "cpmeister", "createdAt": "2020-04-12T04:54:14Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -53,51 +59,58 @@\n  */\n @NonNullByDefault\n public class ShellyHttpApi {\n+    public static final String HTTP_HEADER_AUTH = \"Authorization\";\n+    public static final String HTTP_AUTH_TYPE_BASIC = \"Basic\";\n+    public static final String CONTENT_TYPE_XML = \"text/xml; charset=UTF-8\";\n+    public static final String CONTENT_TYPE_JSON = \"application/json\";\n+\n     private final Logger logger = LoggerFactory.getLogger(ShellyHttpApi.class);\n-    private final ShellyThingConfiguration config;\n-    private final String thingName = \"\";\n+    private HttpClient httpClient;", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMDA4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407230087", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T17:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjI2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146269", "bodyText": "So you never retry battery devices?", "author": "cpmeister", "createdAt": "2020-04-12T04:56:49Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMDI2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407230269", "bodyText": "no, they go to sleep after reporting the data\nthe next release will include a watchdog to monitor that they wake at least once within the 12h rregular interval if nothing happens", "author": "markus7017", "createdAt": "2020-04-12T17:42:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjQ4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146487", "bodyText": "Since you don't need regex here you can use replace instead of replaceAll.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n          \n          \n            \n                        String response = contentResponse.getContentAsString().replace(\"\\t\", \"\").replace(\"\\r\\n\", \"\").trim();", "author": "cpmeister", "createdAt": "2020-04-12T04:59:14Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or\n+                    // API exception for non-battery device\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+                try {\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++;\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                } catch (ShellyApiException e2) {\n+                    if (retries <= 1) {\n+                        throw new ShellyApiException(e2);\n+                    }\n                 }\n             }\n         }\n-        return result;\n+        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n-        }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n+            }\n+            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n+            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+\n+            // Do request and get response\n+            ContentResponse contentResponse = request.send();\n+            apiResult = new ShellyApiResult(contentResponse);\n+            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMDQzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407230431", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T17:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjU1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146552", "bodyText": "You should specify a charset.", "author": "cpmeister", "createdAt": "2020-04-12T05:00:15Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or\n+                    // API exception for non-battery device\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+                try {\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++;\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                } catch (ShellyApiException e2) {\n+                    if (retries <= 1) {\n+                        throw new ShellyApiException(e2);\n+                    }\n                 }\n             }\n         }\n-        return result;\n+        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n-        }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTEyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231125", "bodyText": "changed, now using getBytes(StandardCharsets.UTF_8) and\npublic static final String CONTENT_TYPE_JSON = \"application/json; charset=UTF-8\";\nok?", "author": "markus7017", "createdAt": "2020-04-12T17:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjYwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407146602", "bodyText": "toString is called automatically\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    uri = uri + \"/\" + id.toString();\n          \n          \n            \n                    uri = uri + \"/\" + id;", "author": "cpmeister", "createdAt": "2020-04-12T05:01:28Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,216 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs, e.g. Dimmer\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, shotz/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if (!e.isTimeout() || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or\n+                    // API exception for non-battery device\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+                try {\n+                    apiResult = innerRequest(HttpMethod.GET, uri);\n+                    timeoutsRecovered++;\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                } catch (ShellyApiException e2) {\n+                    if (retries <= 1) {\n+                        throw new ShellyApiException(e2);\n+                    }\n                 }\n             }\n         }\n-        return result;\n+        throw new ShellyApiException(\"Inconsistent API result or Timeout\"); // successful\n     }\n \n-    private String innerRequest(String uri) throws IOException {\n-        String httpResponse = \"ERROR\";\n+    private ShellyApiResult innerRequest(HttpMethod method, String uri) throws ShellyApiException {\n+        Request request = null;\n         String url = \"http://\" + config.deviceIp + uri;\n-        logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+        ShellyApiResult apiResult = new ShellyApiResult(method.toString(), url);\n \n-        Properties headers = new Properties();\n-        if (!config.userId.isEmpty()) {\n-            String value = config.userId + \":\" + config.password;\n-            headers.put(HTTP_HEADER_AUTH,\n-                    HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n-        }\n+        try {\n+            request = httpClient.newRequest(url).method(method.toString()).timeout(SHELLY_API_TIMEOUT_MS,\n+                    TimeUnit.MILLISECONDS);\n \n-        httpResponse = HttpUtil.executeUrl(HttpMethod.GET, url, headers, null, \"\", SHELLY_API_TIMEOUT_MS);\n-        Validate.notNull(httpResponse, \"httpResponse must not be null\");\n-        // all api responses are returning the result in Json format. If we are getting\n-        // something else it must\n-        // be an error message, e.g. http result code\n-        if (httpResponse.contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-            throw new IOException(\n-                    APIERR_HTTP_401_UNAUTHORIZED + \", set/correct userid and password in the thing/binding config\");\n-        }\n-        if (!httpResponse.startsWith(\"{\") && !httpResponse.startsWith(\"[\")) {\n-            throw new IOException(\"Unexpected http response: \" + httpResponse);\n+            if (!config.userId.isEmpty()) {\n+                String value = config.userId + \":\" + config.password;\n+                request.header(HTTP_HEADER_AUTH,\n+                        HTTP_AUTH_TYPE_BASIC + \" \" + Base64.getEncoder().encodeToString(value.getBytes()));\n+            }\n+            request.header(HttpHeader.ACCEPT, CONTENT_TYPE_JSON);\n+            logger.trace(\"{}: HTTP GET for {}\", thingName, url);\n+\n+            // Do request and get response\n+            ContentResponse contentResponse = request.send();\n+            apiResult = new ShellyApiResult(contentResponse);\n+            String response = contentResponse.getContentAsString().replaceAll(\"\\t\", \"\").replaceAll(\"\\r\\n\", \"\").trim();\n+\n+            // validate response, API errors are reported as Json\n+            logger.trace(\"HTTP Response: {}\", response);\n+            if (contentResponse.getStatus() != HttpStatus.OK_200) {\n+                throw new ShellyApiException(apiResult);\n+            }\n+            if (response == null || response.isEmpty() || !response.startsWith(\"{\") && !response.startsWith(\"[\")) {\n+                throw new ShellyApiException(\"Unexpected response: \" + response);\n+            }\n+        } catch (ExecutionException | InterruptedException | TimeoutException | IllegalArgumentException e) {\n+            throw new ShellyApiException(apiResult, e);\n         }\n+        return apiResult;\n+    }\n \n-        logger.trace(\"HTTP response from {}: {}\", thingName, httpResponse);\n-        return httpResponse;\n+    public String getControlUrlPrefix(Integer id) {\n+        String uri = \"\";\n+        if (profile.isLight || profile.isDimmer) {\n+            if (profile.isDuo || profile.isDimmer) {\n+                // Duo + Dimmer\n+                uri = SHELLY_URL_CONTROL_LIGHT;\n+            } else {\n+                // Bulb + RGBW2\n+                uri = \"/\" + (profile.inColor ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n+            }\n+        } else {\n+            // Roller, Relay\n+            uri = SHELLY_URL_CONTROL_RELEAY;\n+        }\n+        uri = uri + \"/\" + id.toString();", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTE2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231162", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T17:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NjYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzAzNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147034", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-04-12T05:07:43Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -371,8 +363,39 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n                                 toQuantityType(s.value, DIGITS_PERCENT, SmartHomeUnits.PERCENT));\n                         break;\n                     case \"t\" /* Temperature */:\n-                        updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n-                                toQuantityType(s.value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                        Double value = getDouble(s.value);\n+                        switch (sen.desc.toLowerCase()) {\n+                            case \"temperature\":\n+                                if ((profile.settings.temperatureUnits != null)\n+                                        && profile.settings.temperatureUnits.equalsIgnoreCase(\"F\")) {\n+                                    value = ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS)\n+                                            .convert(getDouble(s.value)).doubleValue();\n+                                }\n+                                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n+                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                                break;\n+", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTM4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231380", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T17:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzEwNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147106", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-04-12T05:08:41Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -474,47 +538,46 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n                                 updateChannel(updates, CHANNEL_GROUP_COLOR_CONTROL, CHANNEL_COLOR_GAIN,\n                                         ShellyColorUtils.toPercent((int) s.value, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n                                 break;\n-                            case \"temp\":\n-                                updateChannel(updates, CHANNEL_GROUP_COLOR_CONTROL, CHANNEL_COLOR_TEMP, ShellyColorUtils\n-                                        .toPercent((int) s.value, MIN_COLOR_TEMPERATURE, MAX_COLOR_TEMPERATURE));\n-\n+                            case \"temp\": // Shelly Bulb\n+                            case \"colortemperature\": // Shelly Duo\n+                                updateChannel(updates,\n+                                        profile.inColor ? CHANNEL_GROUP_COLOR_CONTROL : CHANNEL_GROUP_WHITE_CONTROL,\n+                                        CHANNEL_COLOR_TEMP,\n+                                        ShellyColorUtils.toPercent((int) s.value, profile.minTemp, profile.maxTemp));\n                                 break;\n-\n                             default:\n                                 logger.debug(\"{}: Update for unknown sensor type {}/{} received\", thingName, sen.type,\n                                         sen.desc);\n                         }\n                         break;\n-\n                     default:\n                         logger.debug(\"{}: Sensor data for type {} not processed, value={}\", thingName, sen.type,\n                                 s.value);\n-                        break;\n                 }\n-            } else {\n-                logger.debug(\"{}: Update for unknown sensor[{}]: Dev={}, Index={}, Value={}\", thingName, i, devId,\n-                        s.index, s.value);\n+            } catch (IllegalArgumentException | NullPointerException | ArrayIndexOutOfBoundsException e) {\n+                // even the processing of one value failed we continue with the next one (sometimes this is caused by\n+                // buggy formats provided by the device\n+                logger.debug(\"{}: Unable to process data from sensor[{}]: Dev={}{}\", thingName, i, devId, e.toString());\n             }\n         }\n \n         if (!updates.isEmpty()) {\n+", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMjU0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407232546", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T18:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147557", "bodyText": "This log is a bit funky", "author": "cpmeister", "createdAt": "2020-04-12T05:14:23Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n+                    logger.debug(\"{}: Exception {}\", name, e.toString());\n                 }\n+            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+                logger.debug(\"{}: Unable to initialize, retrying later{}\", name, e.toString());", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNTY0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407235643", "bodyText": "message changed", "author": "markus7017", "createdAt": "2020-04-12T18:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzYxMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147613", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"{}: Exception {}\", name, e.toString());\n          \n          \n            \n                                logger.debug(\"{}: Exception {}\", name, e.getMessage());", "author": "cpmeister", "createdAt": "2020-04-12T05:15:13Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n+                    logger.debug(\"{}: Exception {}\", name, e.toString());", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTY3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231674", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T17:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzY0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147641", "bodyText": "info?", "author": "cpmeister", "createdAt": "2020-04-12T05:15:30Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n-                    thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n+                    thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNTcwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407235705", "bodyText": "yes, I want to inform the user. Mostly this requires the config of the credentials", "author": "markus7017", "createdAt": "2020-04-12T18:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4MDI3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407380277", "bodyText": "I removed the .info on an run-time exception and kept it for an API exception (e.g. unauthorized)", "author": "markus7017", "createdAt": "2020-04-13T08:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzcwNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147706", "bodyText": "info?", "author": "cpmeister", "createdAt": "2020-04-12T05:16:29Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +99,85 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n+            logger.debug(\n+                    \"Process serviceInfo from mDNS: domain={}, server={}, fqdn={}, hostaddress={},  Port={}, protocol={}, Properties={}\\n{}\",\n+                    service.getDomain(), service.getServer(), service.getQualifiedName(), service.getHostAddress(),\n+                    service.getPort(), service.getProtocol(), service.getPropertyNames().toString(),\n+                    service.getNiceTextString());\n+            address = service.getHostAddress();\n+            String thingType = name.contains(\"-\") ? StringUtils.substringBefore(name, \"-\") : name;\n             if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}\", name, address);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n-                thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+                thingUID = ShellyDeviceProfile.getThingUID(name, mode, false);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTcyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231728", "bodyText": "yes, show the info to the user - needs user action (config credentials)", "author": "markus7017", "createdAt": "2020-04-12T17:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Nzc0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147748", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Exception {}\", name, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Exception {}\", name, e.getMessage());", "author": "cpmeister", "createdAt": "2020-04-12T05:16:49Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -162,13 +187,14 @@ public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n                 addProperty(properties, PROPERTY_DEV_TYPE, thingType);\n                 addProperty(properties, PROPERTY_DEV_MODE, mode);\n \n-                logger.debug(\"Adding Shelly thing, UID={}\", thingUID.getAsString());\n+                logger.debug(\"{}: Adding Shelly thing, UID={}\", name, thingUID.getAsString());\n                 return DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n                         .withLabel(name + \" - \" + address).withRepresentationProperty(name).build();\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"Device discovery failed for device {}, IP {}, service={}: {}\", name, address, name,\n-                    e.getMessage(), e);\n+        } catch (IOException | IllegalArgumentException | NullPointerException e) { // maybe some format description was\n+                                                                                    // buggy\n+            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, ShellyUtils.getMessage(e)));\n+            logger.debug(\"{}: Exception {}\", name, e.toString());", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTgyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231821", "bodyText": "if I use getMessage8) I don't get the stack trace, that's what I'm looking for here", "author": "markus7017", "createdAt": "2020-04-12T17:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Nzc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzNDQ5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407234497", "bodyText": "why is\nlogger.debug(\"{}: Unable to initialize, retrying later: {}\", thingName, e);\n``\nresults in \n\n[ERROR] Code Analysis Tool has found:\n4 error(s)!\n9 warning(s)\n10 info(s)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[158]\nCount of placeholder(2) is not equal to count of parameter(1)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[325]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[392]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHand\n\nwhereas it gets accepted when I use e.toString(). AFAIK log4j has support for argument type Throwable", "author": "markus7017", "createdAt": "2020-04-12T18:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Nzc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MDc5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408180790", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T14:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Nzc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzgzNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147837", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-04-12T05:18:01Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyThingCreator.java", "diffHunk": "@@ -16,19 +16,16 @@\n import static org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.*;\n \n import org.apache.commons.lang.StringUtils;\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.smarthome.core.thing.ThingTypeUID;\n import org.eclipse.smarthome.core.thing.ThingUID;\n \n /**\n- * The {@link ShellyThingCreator} implements some helper functions for Thing creation (used by Discovery and Thing\n- * handler).\n+ * The {@link ShellyThingCreator} maps the device id into the thing type id\n  *\n  * @author Markus Michels - Initial contribution\n  */\n-@NonNullByDefault\n-public class ShellyThingCreator {\n \n+public class ShellyThingCreator {", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTkwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231902", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T17:56:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407147929", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Boolean autoCoIoT = false;\n          \n          \n            \n                private boolean autoCoIoT = false;", "author": "cpmeister", "createdAt": "2020-04-12T05:18:53Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -61,38 +68,39 @@\n @NonNullByDefault\n public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceListener {\n     protected final Logger logger = LoggerFactory.getLogger(ShellyBaseHandler.class);\n+    protected final ShellyChannelDefinitionsDTO channelDefinitions;\n \n     public String thingName = \"\";\n-    protected ShellyBindingConfiguration bindingConfig = new ShellyBindingConfiguration();\n+    public String thingType = \"\";\n+\n+    protected final ShellyHttpApi api;\n+    protected ShellyBindingConfiguration bindingConfig;\n     protected ShellyThingConfiguration config = new ShellyThingConfiguration();\n-    protected @Nullable ShellyHttpApi api;\n-    private @Nullable ShellyCoapHandler coap;\n-    protected @Nullable ShellyDeviceProfile profile;\n-    private final @Nullable ShellyCoapServer coapServer;\n+    protected ShellyDeviceProfile profile = new ShellyDeviceProfile(); // init empty profile to avoid NPE\n+    private final ShellyCoapHandler coap;\n+    private Boolean autoCoIoT = false;", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIzMTk3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407231971", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-12T17:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0NzkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODUwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407148500", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-04-12T05:27:08Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -517,55 +532,65 @@ public boolean onEvent(String deviceName, String deviceIndex, String type, Map<S\n \n                 // map some of the events to system defined button triggers\n                 String channel = \"\";\n+                String onoff = \"\";\n                 String payload = \"\";\n-                String event = type.contentEquals(EVENT_TYPE_SENSORDATA) ? SHELLY_EVENT_SENSORDATA\n-                        : parameters.get(\"type\");\n+                String parmType = getString(parameters.get(\"type\"));\n+                String event = !parmType.isEmpty() ? parmType : type;\n                 switch (event) {\n                     case SHELLY_EVENT_SHORTPUSH:\n-                        channel = CHANNEL_BUTTON_TRIGGER;\n-                        payload = CommonTriggerEvents.SHORT_PRESSED;\n-                        break;\n                     case SHELLY_EVENT_LONGPUSH:\n-                        channel = CHANNEL_BUTTON_TRIGGER;\n-                        payload = CommonTriggerEvents.LONG_PRESSED;\n+                        if (isButton) {\n+                            channel = CHANNEL_BUTTON_TRIGGER;\n+                            payload = event.equals(SHELLY_EVENT_SHORTPUSH) ? CommonTriggerEvents.SHORT_PRESSED\n+                                    : CommonTriggerEvents.LONG_PRESSED;\n+                        } else {\n+                            logger.debug(\"{}: Relay button is not in memontary or detached mode, ignore SHORT/LONGPUSH\",\n+                                    thingName);\n+                        }\n                         break;\n-\n                     case SHELLY_EVENT_ROLLER_OPEN:\n                     case SHELLY_EVENT_ROLLER_CLOSE:\n                     case SHELLY_EVENT_ROLLER_STOP:\n                         channel = CHANNEL_EVENT_TRIGGER;\n                         payload = event;\n                         break;\n-\n                     case SHELLY_EVENT_BTN_ON:\n-                        updateChannel(group, CHANNEL_INPUT, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_BTN_OFF:\n-                        updateChannel(group, CHANNEL_INPUT, OnOffType.OFF);\n+                        if (profile.isRGBW2) {\n+                            // RGBW2 has only one input, so not per channel\n+                            group = CHANNEL_GROUP_LIGHT_CONTROL;\n+                        }\n+                        onoff = CHANNEL_INPUT;\n                         break;\n                     case SHELLY_EVENT_BTN1_ON:\n-                        updateChannel(group, CHANNEL_INPUT1, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_BTN1_OFF:\n-                        updateChannel(group, CHANNEL_INPUT1, OnOffType.OFF);\n+                        onoff = CHANNEL_INPUT1;\n                         break;\n                     case SHELLY_EVENT_BTN2_ON:\n-                        updateChannel(group, CHANNEL_INPUT2, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_BTN2_OFF:\n-                        updateChannel(group, CHANNEL_INPUT2, OnOffType.OFF);\n+                        onoff = CHANNEL_INPUT2;\n                         break;\n                     case SHELLY_EVENT_OUT_ON:\n-                        updateChannel(group, CHANNEL_OUTPUT, OnOffType.ON);\n-                        break;\n                     case SHELLY_EVENT_OUT_OFF:\n-                        updateChannel(group, CHANNEL_OUTPUT, OnOffType.OFF);\n+                        onoff = CHANNEL_OUTPUT;\n+                        break;\n+                    case SHELLY_EVENT_SENSORREPORT:\n+                        // process sensor with next refresh\n+                        break;\n+                    case SHELLY_EVENT_FLOOD_DETECTED:\n+                    case SHELLY_EVENT_FLOOD_GONE:\n+                        updateChannel(group, CHANNEL_SENSOR_FLOOD,\n+                                event.equalsIgnoreCase(SHELLY_EVENT_FLOOD_DETECTED) ? OnOffType.ON : OnOffType.OFF);\n                         break;\n \n                     default:\n                         // trigger will be provided by input/output channel or sensor channels\n                 }\n \n+                if (!onoff.isEmpty()) {\n+                    updateChannel(group, onoff, event.toLowerCase().contains(\"_on\") ? OnOffType.ON : OnOffType.OFF);\n+", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMDg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407210868", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T15:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODcyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407148728", "bodyText": "Optional isn't really a very good choice in this case. It was better when it was a nullable field.", "author": "cpmeister", "createdAt": "2020-04-12T05:29:41Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -61,38 +68,39 @@\n @NonNullByDefault\n public class ShellyBaseHandler extends BaseThingHandler implements ShellyDeviceListener {\n     protected final Logger logger = LoggerFactory.getLogger(ShellyBaseHandler.class);\n+    protected final ShellyChannelDefinitionsDTO channelDefinitions;\n \n     public String thingName = \"\";\n-    protected ShellyBindingConfiguration bindingConfig = new ShellyBindingConfiguration();\n+    public String thingType = \"\";\n+\n+    protected final ShellyHttpApi api;\n+    protected ShellyBindingConfiguration bindingConfig;\n     protected ShellyThingConfiguration config = new ShellyThingConfiguration();\n-    protected @Nullable ShellyHttpApi api;\n-    private @Nullable ShellyCoapHandler coap;\n-    protected @Nullable ShellyDeviceProfile profile;\n-    private final @Nullable ShellyCoapServer coapServer;\n+    protected ShellyDeviceProfile profile = new ShellyDeviceProfile(); // init empty profile to avoid NPE\n+    private final ShellyCoapHandler coap;\n+    private Boolean autoCoIoT = false;\n     protected boolean lockUpdates = false;\n \n-    @SuppressWarnings(\"unused\")\n-    private long lastUpdateTs = 0;\n+    private final ShellyTranslationProvider messages;\n+    private boolean channelsCreated = false;\n+\n     private long lastUptime = 0;\n     private long lastAlarmTs = 0;\n-    private Integer lastTimeoutErros = -1;\n+    private long lastTimeoutErros = -1;\n \n-    private @Nullable ScheduledFuture<?> statusJob;\n-    private int skipUpdate = 0;\n+    private Optional<ScheduledFuture<?>> statusJob = Optional.empty();", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMjE5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407212195", "bodyText": "change reverted\nwhy?", "author": "markus7017", "createdAt": "2020-04-12T15:16:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODcyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407265053", "bodyText": "Using nullables for future fields is an unofficial openhab coding standard. We are just trying to make all the bindings consistent.", "author": "cpmeister", "createdAt": "2020-04-12T23:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODcyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM3OTc4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407379782", "bodyText": "aha", "author": "markus7017", "createdAt": "2020-04-13T08:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODg2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407148863", "bodyText": "please make these final", "author": "cpmeister", "createdAt": "2020-04-12T05:31:41Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyChannelDefinitionsDTO.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.handler;\n+\n+import static org.openhab.binding.shelly.internal.ShellyBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyControlRoller;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsEMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsMeter;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellySettingsStatus;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusRelay;\n+import org.openhab.binding.shelly.internal.api.ShellyApiJsonDTO.ShellyStatusSensor;\n+import org.openhab.binding.shelly.internal.api.ShellyDeviceProfile;\n+import org.openhab.binding.shelly.internal.util.ShellyTranslationProvider;\n+\n+/**\n+ * The {@link ShellyChannelDefinitionsDTO} defines channel information for dynamically created channels. Those will be\n+ * added on the first thing status update\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelDefinitionsDTO {\n+\n+    private static final ChannelMap channelDefinitions = new ChannelMap();\n+\n+    private static final String CHGR_METER = CHANNEL_GROUP_METER;\n+    private static final String CHGR_SENSOR = CHANNEL_GROUP_SENSOR;\n+    private static final String CHGR_BAT = CHANNEL_GROUP_BATTERY;\n+\n+    public static final String ITEM_TYPE_NUMBER = \"Number\";\n+    public static final String ITEM_TYPE_STRING = \"String\";\n+    public static final String ITEM_TYPE_DATETIME = \"DateTime\";\n+    public static final String ITEM_TYPE_TEMP = \"Number:Temperature\";\n+    public static final String ITEM_TYPE_LUX = \"Number:Illuminance\";\n+    public static final String ITEM_TYPE_POWER = \"Number:Power\";\n+    public static final String ITEM_TYPE_ENERGY = \"Number:Energy\";\n+    public static final String ITEM_TYPE_VOLT = \"Number:ElectricPotential\";\n+    public static final String ITEM_TYPE_AMP = \"Number:ElectricPotential\";\n+    public static final String ITEM_TYPE_PERCENT = \"Number:Dimensionless\";\n+    public static final String ITEM_TYPE_SWITCH = \"Switch\";\n+    public static final String ITEM_TYPE_CONTACT = \"Contact\";\n+\n+    public static String PREFIX_GROUP = \"definitions.shelly.group.\";\n+    public static String PREFIX_CHANNEL = \"channel-type.shelly.\";\n+    public static String SUFFIX_LABEL = \".label\";\n+    public static String SUFFIX_DESCR = \".description\";", "originalCommit": "d1a54fedc2a0696db425872653084325ed15e0b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIxMjMxMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407212312", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-12T15:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0ODg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTkwNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407265906", "bodyText": "If you want the stack trace, the proper way to do it is like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}: {}\", thingName, i, devId,\n          \n          \n            \n                                    e.toString());\n          \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}:\", thingName, i, devId,\n          \n          \n            \n                                    e);", "author": "cpmeister", "createdAt": "2020-04-12T23:29:49Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -557,12 +554,12 @@ private void handleStatusUpdate(String devId, String payload, int serial) {\n             } catch (IllegalArgumentException | NullPointerException | ArrayIndexOutOfBoundsException e) {\n                 // even the processing of one value failed we continue with the next one (sometimes this is caused by\n                 // buggy formats provided by the device\n-                logger.debug(\"{}: Unable to process data from sensor[{}]: Dev={}{}\", thingName, i, devId, e.toString());\n+                logger.debug(\"{}: Unable to process data from sensor[{}], devId={}: {}\", thingName, i, devId,\n+                        e.toString());", "originalCommit": "a3e8c7be0049a752c350a7658df11de459feda54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM3OTA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407379086", "bodyText": "that's what I tried, but doesn't work, the code checker reports in incorrect number of arguments even if the statement has the correct number of args\nexample:\nERROR] Code Analysis Tool has found:\n4 error(s)!\n9 warning(s)\n10 info(s)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[158]\nCount of placeholder(2) is not equal to count of parameter(1)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[325]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[392]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHand", "author": "markus7017", "createdAt": "2020-04-13T08:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMDU1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407720554", "bodyText": "This change is correct.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}: {}\", thingName, i, devId,\n          \n          \n            \n                                    e.toString());\n          \n          \n            \n                            logger.debug(\"{}: Unable to process data from sensor[{}], devId={}:\", thingName, i, devId,\n          \n          \n            \n                                    e);", "author": "cpmeister", "createdAt": "2020-04-13T21:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MDk4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408180987", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T14:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NTkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407266002", "bodyText": "same here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"{}: {}\", name, e.toString());\n          \n          \n            \n                                logger.debug(\"{}:\", name, e);", "author": "cpmeister", "createdAt": "2020-04-12T23:31:12Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -174,7 +173,7 @@ public DiscoveryResult createResult(final ServiceInfo service) {\n                     thingUID = ShellyDeviceProfile.getThingUID(name, mode, true);\n                 } else {\n                     logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n-                    logger.debug(\"{}: Exception {}\", name, e.toString());\n+                    logger.debug(\"{}: {}\", name, e.toString());", "originalCommit": "a3e8c7be0049a752c350a7658df11de459feda54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4MzExMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407383111", "bodyText": "that's what I tried, but doesn't work, the code checker reports in incorrect number of arguments even if the statement has the correct number of args\nexample:\nERROR] Code Analysis Tool has found:\n4 error(s)!\n9 warning(s)\n10 info(s)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[158]\nCount of placeholder(2) is not equal to count of parameter(1)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[325]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHandler.java:[392]\nCount of placeholder(3) is not equal to count of parameter(2)\n[ERROR] org.openhab.binding.shelly.internal.handler.ShellyBaseHand", "author": "markus7017", "createdAt": "2020-04-13T08:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzNzQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407637417", "bodyText": "You should notice that when adding an exception as the last argument you don't include a {} for it in the log format string.\nNotice that the code analysis didn't complain about line 171 \ud83d\ude04", "author": "cpmeister", "createdAt": "2020-04-13T18:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2NDc3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408264774", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-14T16:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407266015", "bodyText": "and here\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Exception on processing serviceInfo '{}': {}\", name, service.getNiceTextString(),\n          \n          \n            \n                                e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Exception on processing serviceInfo '{}': \", name, service.getNiceTextString(),\n          \n          \n            \n                                e);", "author": "cpmeister", "createdAt": "2020-04-12T23:31:31Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -193,8 +192,9 @@ public DiscoveryResult createResult(final ServiceInfo service) {\n             }\n         } catch (IOException | IllegalArgumentException | NullPointerException e) { // maybe some format description was\n                                                                                     // buggy\n-            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, ShellyUtils.getMessage(e)));\n-            logger.debug(\"{}: Exception {}\", name, e.toString());\n+            logger.info(\"{}\", messages.get(\"discovery.failed\", name, address, e.getMessage()));\n+            logger.debug(\"{}: Exception on processing serviceInfo '{}': {}\", name, service.getNiceTextString(),\n+                    e.toString());", "originalCommit": "a3e8c7be0049a752c350a7658df11de459feda54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4MTE1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408181159", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T14:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI2NjAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407717466", "bodyText": "remove blank line", "author": "cpmeister", "createdAt": "2020-04-13T20:58:58Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +347,218 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n+        String type = \"\";\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, short/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_BTN_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_SHORTPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_LONGPUSH, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_RELAY, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        } else if (profile.isLight) {\n+            // Duo, Bulb\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n+        }\n+    }\n+\n+    private void setEventUrl(String eventType, boolean enabled) throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            // Sensors add the type=xx to report_url themself, so we need to ommit here\n+            String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + eventType + urlParm;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n-                }\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, String eventType, boolean enabled)\n+            throws ShellyApiException {\n+        if (profile.containsEventUrl(eventType)) {\n+            String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                    + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+            String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+            String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+            if (!enabled && !profile.settingsJson.contains(test)) {\n+                // Don't set URL to null when the current one doesn't point to this OH\n+                // Don't interfer a 3rd party App\n+                return;\n             }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+            test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+            if (!profile.settingsJson.contains(test)) {\n+                // Current Action URL is != new URL\n+                logger.debug(\"{}: Set URL for type {} to {}\", thingName, eventType, newUrl);\n+                request(SHELLY_URL_SETTINGS + \"/\" + deviceClass + \"/\" + index + \"?\" + mkEventUrl(eventType) + \"=\"\n+                        + urlEncode(newUrl));\n             }\n         }\n     }\n \n+    private static String mkEventUrl(String eventType) {\n+        return eventType + SHELLY_EVENTURL_SUFFIX;\n+    }\n+\n     /**\n      * Submit GET request and return response, check for invalid responses\n      *\n      * @param uri: URI (e.g. \"/settings\")\n      */\n-    private String request(String uri) throws IOException {\n-        String result = \"\";\n-        boolean retry = false;\n+    public <T> T callApi(String uri, Class<T> classOfT) throws ShellyApiException {\n+        String json = \"Invalid API result\";\n         try {\n-            result = innerRequest(uri);\n-        } catch (IOException e) {\n-            String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-            if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                    || e.getMessage().contains(\"Connection reset\")) {\n-                logger.debug(\"{}: Shelly API timeout ({}), retry\", thingName, type);\n-                timeoutErrors++;\n-                retry = true;\n-            } else {\n-                throw new IOException(thingName + \": Shelly API call failed (\" + type + \"), uri=\" + uri);\n-            }\n+            json = request(uri);\n+            return gson.fromJson(json, classOfT);\n+        } catch (JsonSyntaxException e) {\n+            throw new ShellyApiException(e,\n+                    \"Unable to convert JSON to class \" + classOfT.getClass() + \", JSON=\" + json);\n         }\n-        if (retry && !profile.hasBattery) {\n+    }\n+\n+    private String request(String uri) throws ShellyApiException {\n+        ShellyApiResult apiResult = new ShellyApiResult();\n+        int retries = 3;\n+        boolean timeout = false;\n+        while (retries > 0) {\n             try {\n-                // retry to recover\n-                result = innerRequest(uri);\n-                timeoutsRecovered++;\n-                logger.debug(\"Shelly API timeout recovered\");\n-            } catch (IOException e) {\n-                String type = StringUtils.substringAfterLast(e.getCause().toString(), \".\");\n-                if (e.getMessage().contains(\"Timeout\") || type.toLowerCase().contains(\"timeout\")\n-                        || e.getMessage().contains(\"Connection reset\")) {\n-                    throw new IOException(thingName + \": Shelly API timeout (\" + type + \"), uri=\" + uri);\n-                } else {\n-                    throw new IOException(thingName + \": Shelly API call failed: \" + type + \", uri=\" + uri);\n+                apiResult = innerRequest(HttpMethod.GET, uri);\n+                if (timeout) {\n+                    logger.debug(\"{}: API timeout #{}/{} recovered ({})\", thingName, timeoutErrors, timeoutsRecovered,\n+                            apiResult.getUrl());\n+                    timeoutsRecovered++;\n                 }\n+                return apiResult.response; // successful\n+            } catch (ShellyApiException e) {\n+                retries--;\n+                if ((!e.isTimeout() && !apiResult.isHttpServerError()) || profile.hasBattery || (retries == 0)) {\n+                    // Sensor in sleep mode or API exception for non-battery device or retry counter expired\n+                    throw e; // non-timeout exception\n+                }\n+\n+                timeout = true;\n+                timeoutErrors++; // count the retries\n+                logger.debug(\"{}: {},\u00a0retry #{}\", thingName, e.toString(), timeoutErrors);\n+", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3NjkxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408076914", "bodyText": "In general I don't ignore your recommendations/requirements :-)\nFSInternetRadioDiscoveryParticipant was wrong in this repo here, so I removed the file, but the comment stays somehow. Not sure how to handle that.\n.classpath\nMy code doesn't show\n<classpathentry kind=\"src\" output=\"target/test-classes\" path=\"src/test/java\">\t\t\n \t\t<attributes>\t\t\n \t\t\t<attribute name=\"test\" value=\"true\"/>\t\t\n \t\t\t<attribute name=\"optional\" value=\"true\"/>\t\t\n \t\t\t<attribute name=\"maven.pomderived\" value=\"true\"/>\t\t\n \t\t</attributes>\t\t\n \t</classpathentry>\n\nMy code shows\npublic ShellyDeviceProfile initialize(String thingType, String json) throws ShellyApiException {\n\n(initialize () is not static). Are you checking the latest version?\nI need to have several stages of the initialization\n\nthe empty constructor when ShellyBaseHandler is constructed\ninitializeFromThing(): a basic initialization, which just sets some properties based on the thing type. A full initialization needs information from the device, but a sensor is usually in sleep mode when the binding starts. A wakeup causes a CoAP message and those basic parameters are enough to handle channel updates from that message and set the thing online.\ninitialize() is called when the device has been successfully access by REST API the first time. This allows to verify the firmware, initialize number of relays, meters etc. and refresh the channels. This is the standard procedure for non-battery devices and inclusion of a sensor (when REST API is available)\nI don't want to change things here, it was hard to figure out the different scenarios and how to handle them.\n\nempty line was removed", "author": "markus7017", "createdAt": "2020-04-14T11:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxNzQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxODg3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407718872", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: CoAP Exception {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: CoAP Exception\", thingName, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:01:41Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -97,31 +103,38 @@ public ShellyCoapHandler(ShellyThingConfiguration config, ShellyBaseHandler thin\n     /*\n      * Initialize Coap access, send discovery packet and start Status server\n      */\n-    @SuppressWarnings(\"null\")\n-    public void start() {\n+    public void start(String thingName, ShellyThingConfiguration config) throws ShellyApiException {\n+        if (isStarted()) {\n+            logger.trace(\"{}: CoAP Listener was already started\", thingName);\n+            return;\n+        }\n         try {\n+            this.thingName = thingName;\n+            this.config = config;\n+\n             reqDescription = sendRequest(reqDescription, config.deviceIp, COLOIT_URI_DEVDESC, Type.CON);\n \n-            if (statusClient == null) {\n-                coapServer.init(config.localIp);\n-                coapServer.addListener(this);\n+            if (!isStarted()) {\n+                logger.debug(\"{}: Starting CoAP Listener\", thingName);\n+                reqDescription = sendRequest(reqDescription, config.deviceIp, COLOIT_URI_DEVDESC, Type.CON);\n \n+                coapServer.start(config.localIp, this);\n                 statusClient = new CoapClient(completeUrl(config.deviceIp, COLOIT_URI_DEVSTATUS))\n                         .setTimeout((long) SHELLY_API_TIMEOUT_MS).useNONs().setEndpoint(coapServer.getEndpoint());\n-\n-                coapServer.start();\n             }\n-        } catch (IOException e) {\n-            logger.warn(\"{}: Unable to start CoIoT: {}\", thingName, e.getMessage());\n-        } catch (NullPointerException e) {\n-            logger.debug(\"{}: Coap Exception: {} ({})\\n{}\", thingName, e.getMessage(), e.getClass(), e.getStackTrace());\n+        } catch (UnknownHostException e) {\n+            ShellyApiException ea = new ShellyApiException(e);\n+            logger.debug(\"{}: CoAP Exception {}\", thingName, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzODgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408038815", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T10:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxODg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTQwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407719409", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to process CoIoT Message for payload={}{}\", thingName, payload, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to process CoIoT Message for payload={}\", thingName, payload, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:02:38Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -211,40 +218,33 @@ public void processResponse(@Nullable Response response) {\n                         response.getPayloadString());\n             }\n \n-            if (reqStatus == null) {\n-                /*\n-                 * Observe Status Updates\n-                 */\n+            if (!discovering) {\n+                // Observe Status Updates\n                 reqStatus = sendRequest(reqStatus, config.deviceIp, COLOIT_URI_DEVSTATUS, Type.NON);\n+                discovering = true;\n             }\n-        } catch (NullPointerException | IOException e) {\n-            logger.debug(\"{}: Unable to process CoIoT Message: {} ({}); payload={}\\n{}\", thingName, e.getMessage(),\n-                    e.getClass(), payload, e.getStackTrace());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to process CoIoT Message for payload={}{}\", thingName, payload, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzODg4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408038887", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T10:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTY3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407719674", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to decode sensor definition -> skip {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to decode sensor definition -> skip\", thingName, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:03:09Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -288,35 +288,30 @@ private void addSensor(CoIotDescrSen sen) {\n             } else {\n                 sensorMap.replace(sen.id, fixed);\n             }\n-        } catch (NullPointerException e) {\n-            logger.debug(\"{}:    Unable to decode sensor definition -> skip ({})\\n{}\", thingName, e.getMessage(),\n-                    e.getStackTrace());\n+        } catch (NullPointerException e) { // depending on firmware release the Coap device description is buggy\n+            logger.debug(\"{}: Unable to decode sensor definition -> skip {}\", thingName, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1NjQ3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408056471", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:13:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxOTY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzU5NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407723594", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param sen Semsor description\n          \n          \n            \n                 * @param sen Sensor description", "author": "cpmeister", "createdAt": "2020-04-13T21:10:59Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -523,28 +581,77 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n         lastPayload = payload;\n     }\n \n-    private boolean updateChannel(Map<String, State> updates, String group, String channel, State value) {\n-        State v = (State) thingHandler.getChannelValue(group, channel);\n-        if ((v != null) && v.equals(value)) {\n-            return false;\n+    private void updatePower(ShellyDeviceProfile profile, Map<String, State> updates, Integer id, CoIotDescrSen sen,\n+            CoIotSensor s, List<CoIotSensor> allUpdates) {\n+        String group = \"\";\n+        String channel = CHANNEL_BRIGHTNESS;\n+        String checkL = \"\"; // RGBW-white uses 4 different Power, Brightness, VSwitch values\n+        if (profile.isLight || profile.isDimmer) {\n+            if (profile.isBulb || profile.inColor) {\n+                group = CHANNEL_GROUP_LIGHT_CONTROL;\n+                channel = CHANNEL_LIGHT_POWER;\n+            } else if (profile.isDuo) {\n+                group = CHANNEL_GROUP_WHITE_CONTROL;\n+            } else if (profile.isDimmer) {\n+                group = CHANNEL_GROUP_RELAY_CONTROL;\n+            } else if (profile.isRGBW2) {\n+                group = CHANNEL_GROUP_LIGHT_CHANNEL + id;\n+                checkL = String.valueOf(id.intValue() - 1); // id is 1-based, L is 0-based\n+                logger.trace(\"{}: updatePower() for L={}\", thingName, checkL);\n+            }\n+\n+            // We need to update brigthtess and on/off state at the same time to avoid \"flipping brightness slider\" in\n+            // the UI\n+            Double brightness = -1.0;\n+            Double power = -1.0;\n+            for (CoIotSensor update : allUpdates) {\n+                CoIotDescrSen d = fixDescription(sensorMap.get(update.id));\n+                if (!checkL.isEmpty() && !d.links.equals(checkL)) {\n+                    // continue until we find the correct one\n+                    continue;\n+                }\n+                if (d.desc.equalsIgnoreCase(\"brightness\")) {\n+                    brightness = new Double(update.value);\n+                } else if (d.desc.equalsIgnoreCase(\"output\") || d.desc.equalsIgnoreCase(\"state\")) {\n+                    power = new Double(update.value);\n+                }\n+            }\n+            if (power != -1) {\n+                updateChannel(updates, group, channel + \"$Switch\", power == 1 ? OnOffType.ON : OnOffType.OFF);\n+            }\n+            if (brightness != -1) {\n+                updateChannel(updates, group, channel + \"$Value\",\n+                        toQuantityType(power == 1 ? brightness : 0, DIGITS_NONE, SmartHomeUnits.PERCENT));\n+            }\n+        } else if (profile.hasRelays) {\n+            group = profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL : CHANNEL_GROUP_RELAY_CONTROL + id;\n+            updateChannel(updates, group, CHANNEL_OUTPUT, s.value == 1 ? OnOffType.ON : OnOffType.OFF);\n+        } else if (profile.isSensor) {\n+            // Sensor state\n+            if (profile.isDW) { // Door Window has item type Contact\n+                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_STATE,\n+                        s.value != 0 ? OpenClosedType.OPEN : OpenClosedType.CLOSED);\n+            } else {\n+                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_STATE,\n+                        s.value == 1 ? OnOffType.ON : OnOffType.OFF);\n+            }\n         }\n-        logger.trace(\"{}: Updating channel {}.{} from CoIoT, new value={}\", thingName, group, channel, value);\n+    }\n+\n+    private boolean updateChannel(Map<String, State> updates, String group, String channel, State value) {\n         updates.put(mkChannelId(group, channel), value);\n         return true;\n \n     }\n \n     /**\n-     * Work around to fix inconsistent sensor types and description\n-     * Shelly not uses always the same coding for sen.T and sen.D - this helps to unify the format and simplifies\n-     * processing\n+     * Work around to fix inconsistent sensor types and description. Shelly not uses always the same coding for sen.T\n+     * and sen.D - this helps to unify the format and simplifies processing\n      *\n-     * @param sen\n+     * @param sen Semsor description", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNTIzNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407725237", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"{}: Unable to initialize, retrying later: {}\", name, e.toString());\n          \n          \n            \n                            logger.debug(\"{}: Unable to initialize, retrying later:\", name, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:14:13Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/discovery/ShellyDiscoveryParticipant.java", "diffHunk": "@@ -70,89 +96,82 @@ public String getServiceType() {\n     }\n \n     /**\n-     * Called at the service activation.\n+     * Process updates to Binding Config\n      *\n      * @param componentContext\n      */\n-    @SuppressWarnings(\"null\")\n-    @Activate\n-    protected void activate(ComponentContext componentContext) {\n-        logger.debug(\"Shelly Discovery service activated\");\n-        Validate.notNull(componentContext);\n-        Validate.notNull(bindingConfig);\n-        bindingConfig.updateFromProperties(componentContext.getProperties());\n-    }\n-\n     @Modified\n-    @SuppressWarnings(\"null\")\n-    protected void modified(ComponentContext componentContext) {\n+    protected void modified(final ComponentContext componentContext) {\n         logger.debug(\"Shelly Binding Configuration refreshed\");\n         bindingConfig.updateFromProperties(componentContext.getProperties());\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Nullable\n     @Override\n-    public DiscoveryResult createResult(@Nullable ServiceInfo service) {\n-        Validate.notNull(bindingConfig);\n-        if ((service == null) || !service.getName().startsWith(\"shelly\")) {\n+    public DiscoveryResult createResult(final ServiceInfo service) {\n+        String name = service.getName().toLowerCase(); // Duao: Name starts with\" Shelly\" rather than \"shelly\"\n+        if (!name.startsWith(\"shelly\")) {\n             return null;\n         }\n \n         String address = \"\";\n-        String name = \"\";\n-        String mode = \"\";\n-        String model = \"unknown\";\n-        String thingType = \"\";\n-        ThingUID thingUID = null;\n-        ShellyDeviceProfile profile = null;\n-        Map<String, Object> properties = new HashMap<>();\n-\n         try {\n+            String mode = \"\";\n+            String model = \"unknown\";\n+            ThingUID thingUID = null;\n+            ShellyDeviceProfile profile = null;\n+            Map<String, Object> properties = new TreeMap<>();\n+\n             name = service.getName().toLowerCase();\n-            address = StringUtils.substringBetween(service.toString(), \"/\", \":80\");\n-            if (address == null) {\n-                logger.debug(\"Shelly device {} discovered with empty IP address\", name);\n+            address = service.getHostAddress();\n+            if ((address == null) || address.isEmpty()) {\n+                logger.trace(\"{}: Shelly device discovered with empty IP address (service-name={})\", name,\n+                        service.toString());\n                 return null;\n             }\n-            logger.debug(\"Shelly device discovered: IP-Adress={}, name={}\", address, name);\n+            String thingType = service.getQualifiedName().contains(SERVICE_TYPE) && name.contains(\"-\")\n+                    ? StringUtils.substringBefore(name, \"-\")\n+                    : name;\n+            logger.debug(\"{}: Shelly device discovered: IP-Adress={}, type={}\", name, address, thingType);\n \n-            ShellyThingConfiguration config = new ShellyThingConfiguration();\n-            if (handlerFactory != null) {\n-                bindingConfig = handlerFactory.getBindingConfig();\n+            // Get device settings\n+            Configuration serviceConfig = configurationAdmin.getConfiguration(\"binding.shelly\");\n+            if (serviceConfig.getProperties() != null) {\n+                bindingConfig.updateFromProperties(serviceConfig.getProperties());\n             }\n \n-            // Get device settings\n-            Validate.notNull(bindingConfig);\n+            ShellyThingConfiguration config = new ShellyThingConfiguration();\n             config.deviceIp = address;\n             config.userId = bindingConfig.defaultUserId;\n             config.password = bindingConfig.defaultPassword;\n-            ShellyHttpApi api = new ShellyHttpApi(config);\n \n             try {\n+                ShellyHttpApi api = new ShellyHttpApi(name, config, httpClient);\n+\n                 profile = api.getDeviceProfile(thingType);\n-                Validate.notNull(profile);\n-                logger.debug(\"Shelly settings : {}\", profile.settingsJson);\n-                Validate.notNull(profile, \"Unable to get device profile: \");\n-                model = profile.settings.device.type;\n+                logger.debug(\"{}: Shelly settings : {}\", name, profile.settingsJson);\n+                model = getString(profile.settings.device.type);\n                 mode = profile.mode;\n \n                 properties = ShellyBaseHandler.fillDeviceProperties(profile);\n-                logger.trace(\"name={}, thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n+                logger.trace(\"{}: thingType={}, deviceType={}, mode={}\", name, thingType, profile.deviceType,\n                         mode.isEmpty() ? \"<standard>\" : mode);\n \n                 // get thing type from device name\n                 thingUID = ShellyThingCreator.getThingUID(name, mode, false);\n-            } catch (IOException e) {\n-                if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                    logger.warn(\"Device {} ({}) reported 'Access defined' (userid/password mismatch).\", name, address);\n+            } catch (ShellyApiException e) {\n+                ShellyApiResult result = e.getApiResult();\n+                if (result.isHttpAccessUnauthorized()) {\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.protected\", address));\n \n                     // create shellyunknown thing - will be changed during thing initialization with valid credentials\n                     thingUID = ShellyThingCreator.getThingUID(name, mode, true);\n                 } else {\n-                    logger.warn(\"Device discovery failed for device {}, IP {}: {} ({})\\n{}\", name, address,\n-                            e.getMessage(), e.getClass(), e.getStackTrace());\n+                    logger.info(\"{}: {}\", name, messages.get(\"discovery.failed\", address));\n+                    logger.debug(\"{}: {}\", name, e.toString());\n                 }\n+            } catch (IllegalArgumentException | NullPointerException e) { // maybe some format description was buggy\n+                logger.debug(\"{}: Unable to initialize, retrying later: {}\", name, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2MzczNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408063737", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:28:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNTIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjQzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407726436", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n          \n          \n            \n                                    e.toString());\n          \n          \n            \n                            logger.info(\"{}: {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n          \n          \n            \n                                    e);", "author": "cpmeister", "createdAt": "2020-04-13T21:16:36Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -302,26 +312,26 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (NullPointerException | IOException e) {\n-            if (authorizationFailed(e.getMessage())) {\n+        } catch (ShellyApiException e) {\n+            ShellyApiResult res = e.getApiResult();\n+            if (isAuthorizationFailed(res)) {\n                 return;\n             }\n-            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n-                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n+            if (res.isNotCalibrtated()) {\n+                logger.warn(\"{}: {}\", thingName, messages.get(\"roller.calibrating\"));\n             } else {\n-                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n-                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n+                logger.info(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n+                        e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2Mzg2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408063867", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407726610", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());\n          \n          \n            \n                        logger.debug(\"{}: {}\", thingName, messages.get(\"command.failed\", command, channelUID), e);", "author": "cpmeister", "createdAt": "2020-04-13T21:16:55Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -302,26 +312,26 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n             if (update) {\n                 requestUpdates(1, false);\n             }\n-        } catch (NullPointerException | IOException e) {\n-            if (authorizationFailed(e.getMessage())) {\n+        } catch (ShellyApiException e) {\n+            ShellyApiResult res = e.getApiResult();\n+            if (isAuthorizationFailed(res)) {\n                 return;\n             }\n-            if (e.getMessage().contains(APIERR_NOT_CALIBRATED)) {\n-                logger.warn(\"Device is not calibrated, use Shelly App to perform initial roller calibration.\");\n+            if (res.isNotCalibrtated()) {\n+                logger.warn(\"{}: {}\", thingName, messages.get(\"roller.calibrating\"));\n             } else {\n-                logger.warn(\"{} ERROR: Unable to process command for channel {}: {} ({})\\nStack Trace: {}\", thingName,\n-                        channelUID.toString(), e.getMessage(), e.getClass(), e.getStackTrace());\n+                logger.info(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID),\n+                        e.toString());\n             }\n-        } finally {\n-            lockUpdates = false;\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: {} - {}\", thingName, messages.get(\"command.failed\", command, channelUID), e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2ODA0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408068048", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407726815", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"{}: {}{}\", thingName, messages.get(\"statusupdate.failed\"), e.toString());\n          \n          \n            \n                        logger.warn(\"{}: {}\", thingName, messages.get(\"statusupdate.failed\"), e);", "author": "cpmeister", "createdAt": "2020-04-13T21:17:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -350,100 +359,104 @@ protected void updateStatus() {\n                 ShellySettingsStatus status = api.getStatus();\n \n                 // If status update was successful the thing must be online\n-                if (getThing().getStatus() != ThingStatus.ONLINE) {\n-                    logger.debug(\"{}: Thing {} is now online\", thingName, getThing().getLabel());\n-                    updateStatus(ThingStatus.ONLINE); // if API call was successful the thing must be online\n-                }\n+                setThingOnline();\n \n                 // map status to channels\n                 updated |= updateDeviceStatus(status);\n+                updated |= ShellyComponents.updateDeviceStatus(this, status);\n                 updated |= ShellyComponents.updateMeters(this, status);\n                 updated |= ShellyComponents.updateSensors(this, status);\n \n+                // All channels must be created after the first cycle\n+                channelsCreated = true;\n+\n                 if (scheduledUpdates <= 1) {\n                     fillDeviceStatus(status, updated);\n                 }\n             }\n-        } catch (IOException e) {\n+        } catch (ShellyApiException e) {\n             // http call failed: go offline except for battery devices, which might be in\n             // sleep mode. Once the next update is successful the device goes back online\n             String status = \"\";\n-            if (e.getMessage().contains(\"Timeout\")) {\n-                logger.debug(\"{}: Device is not reachable, update canceled ({} skips, {} scheduledUpdates)!\", thingName,\n-                        skipCount, scheduledUpdates);\n-                status = \"@text/offline.status-error-timeout\";\n-            } else if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                logger.debug(\"{}: Unable to access device, check credentials!\", thingName);\n-                status = \"@text/offline.conf-error-access-denied\";\n-            } else if (e.getMessage().contains(\"Not calibrated!\")) {\n-                logger.debug(\"{}: Roller is not calibrated! Use the Shelly App or Web UI to run calibration.\",\n-                        thingName);\n-                status = \"@text/offline.conf-error-not-calibrated\";\n+            ShellyApiResult res = e.getApiResult();\n+            if (e.isTimeout()) {\n+                status = \"offline.status-error-timeout\";\n+            } else if (res.isHttpAccessUnauthorized()) {\n+                status = \"offline.conf-error-access-denied\";\n             } else {\n-                logger.debug(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n-                status = \"@text/offline.status-error-unexpected-api-result\";\n+                status = \"offline.status-error-unexpected-api-result\";\n             }\n-            if (!status.isEmpty() || (profile != null && !profile.isSensor)) {\n-                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, status);\n+\n+            if (!status.isEmpty()) {\n+                setThingOffline(ThingStatusDetail.COMMUNICATION_ERROR, status);\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.warn(\"{}: {}{}\", thingName, messages.get(\"statusupdate.failed\"), e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2NjE0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408066142", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyNjgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTk4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407729980", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        statusJob = scheduler.scheduleWithFixedDelay(this::refreshStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,\n          \n          \n            \n                        this.statusJob = scheduler.scheduleWithFixedDelay(this::refreshStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,", "author": "cpmeister", "createdAt": "2020-04-13T21:23:47Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -641,15 +699,20 @@ private void changeThingType(String thingType, String mode) {\n         }\n     }\n \n+    @Override\n+    public void thingUpdated(Thing thing) {\n+        logger.debug(\"{}: Channel definitions updated.\", thingName);\n+        super.thingUpdated(thing);\n+    }\n+\n     /**\n      * Start the background updates\n      */\n     @SuppressWarnings(\"null\")\n     protected void startUpdateJob() {\n         if ((statusJob == null) || statusJob.isCancelled()) {\n-            statusJob = scheduler.scheduleWithFixedDelay(this::updateStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,\n+            statusJob = scheduler.scheduleWithFixedDelay(this::refreshStatus, 2, UPDATE_STATUS_INTERVAL_SECONDS,", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2Njc1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408066757", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyOTk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMDI4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407730283", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @SuppressWarnings(\"null\")\n          \n          \n            \n                protected void startUpdateJob() {\n          \n          \n            \n                    if ((statusJob == null) || statusJob.isCancelled()) {\n          \n          \n            \n                protected void startUpdateJob() {\n          \n          \n            \n                    ScheduledFuture<?> statusJob = this.statusJob;\n          \n          \n            \n                    if ((statusJob == null) || statusJob.isCancelled()) {", "author": "cpmeister", "createdAt": "2020-04-13T21:24:26Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -641,15 +699,20 @@ private void changeThingType(String thingType, String mode) {\n         }\n     }\n \n+    @Override\n+    public void thingUpdated(Thing thing) {\n+        logger.debug(\"{}: Channel definitions updated.\", thingName);\n+        super.thingUpdated(thing);\n+    }\n+\n     /**\n      * Start the background updates\n      */\n     @SuppressWarnings(\"null\")\n     protected void startUpdateJob() {\n         if ((statusJob == null) || statusJob.isCancelled()) {", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2NzA1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408067057", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMDI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMDU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407730557", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                public Object getChannelValue(String group, String channel) {\n          \n          \n            \n                public @Nullable Object getChannelValue(String group, String channel) {", "author": "cpmeister", "createdAt": "2020-04-13T21:25:02Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -704,53 +767,67 @@ public boolean updateInputs(String groupName, ShellySettingsStatus status, int i\n                 updated |= updateChannel(groupName, CHANNEL_INPUT + \"2\", getOnOff(state2.input));\n             } else {\n                 ShellyInputState state = status.inputs.get(index);\n-                logger.trace(\"{}: Updating input[{}] with {}\", thingName, index, getOnOff(state.input));\n                 updated |= updateChannel(groupName, CHANNEL_INPUT, getOnOff(state.input));\n             }\n         }\n         return updated;\n     }\n \n+    public void publishState(String channelId, State value) {\n+        updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value, boolean force) {\n+        return (channelId.contains(\"$\") || isLinked(channelId)) && cache.updateChannel(channelId, value, force);\n+    }\n+\n+    @Nullable\n+    public Object getChannelValue(String group, String channel) {", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2NzE1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408067152", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMDU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMTQ2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407731461", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to update channel definitions: {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to update channel definitions:\", thingName, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:26:54Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -704,53 +767,67 @@ public boolean updateInputs(String groupName, ShellySettingsStatus status, int i\n                 updated |= updateChannel(groupName, CHANNEL_INPUT + \"2\", getOnOff(state2.input));\n             } else {\n                 ShellyInputState state = status.inputs.get(index);\n-                logger.trace(\"{}: Updating input[{}] with {}\", thingName, index, getOnOff(state.input));\n                 updated |= updateChannel(groupName, CHANNEL_INPUT, getOnOff(state.input));\n             }\n         }\n         return updated;\n     }\n \n+    public void publishState(String channelId, State value) {\n+        updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value, boolean force) {\n+        return (channelId.contains(\"$\") || isLinked(channelId)) && cache.updateChannel(channelId, value, force);\n+    }\n+\n+    @Nullable\n+    public Object getChannelValue(String group, String channel) {\n+        return cache.getValue(group, channel);\n+    }\n+\n     /**\n-     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n-     * messing up the log with those updates)\n+     * Update Thing's channels according to available status information from the API\n      *\n-     * @param channelId Channel id\n-     * @param value Value (State)\n-     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n-     * @return true, if successful\n+     * @param thingHandler\n      */\n-    @SuppressWarnings(\"null\")\n-    public boolean updateChannel(String channelId, State value, Boolean forceUpdate) {\n-        Validate.notNull(channelData);\n-        Validate.notNull(channelId);\n-        Validate.notNull(value, \"updateChannel(): value must not be null!\");\n+    protected void updateChannelDefinitions(Map<String, Channel> dynChannels) {\n+        if (channelsCreated) {\n+            return; // already done\n+        }\n+\n         try {\n-            Object current = channelData.get(channelId);\n-            // logger.trace(\"{}: Predict channel {}.{} to become {} (type {}).\", thingName,\n-            // group, channel, value, value.getClass());\n-            if (!channelCache || forceUpdate || (current == null) || !current.equals(value)) {\n-                // For channels that support multiple types (like brightness) a suffix is added\n-                // this gets removed to get the channelId for updateState\n-                updateState(channelId.contains(\"$\") ? StringUtils.substringBefore(channelId, \"$\") : channelId, value);\n-                if (current == null) {\n-                    channelData.put(channelId, value);\n-                } else {\n-                    channelData.replace(channelId, value);\n+            // Get subset of those channels that currently do not exist\n+            List<Channel> existingChannels = getThing().getChannels();\n+            for (Channel channel : existingChannels) {\n+                String id = channel.getUID().getId();\n+                if (dynChannels.containsKey(id)) {\n+                    dynChannels.remove(id);\n                 }\n-                logger.trace(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, value,\n-                        value.getClass());\n-                return true;\n             }\n-        } catch (NullPointerException e) {\n-            logger.debug(\"Unable to update channel {}.{} with {} (type {}): {} ({})\", thingName, channelId, value,\n-                    value.getClass(), e.getMessage(), e.getClass());\n+\n+            if (!dynChannels.isEmpty()) {\n+                logger.debug(\"{}: Updating channel definitions, {} channels\", thingName, dynChannels.size());\n+                ThingBuilder thingBuilder = editThing();\n+                for (Map.Entry<String, Channel> channel : dynChannels.entrySet()) {\n+                    Channel c = channel.getValue();\n+                    logger.debug(\"{}: Adding channel {}\", thingName, c.getUID().getId());\n+                    thingBuilder.withChannel(c);\n+                }\n+                updateThing(thingBuilder.build());\n+                logger.debug(\"{}: Channel definitions updated\", thingName);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel definitions: {}\", thingName, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2NzI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408067260", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMTQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjEzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407732131", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (statusJob != null) {\n          \n          \n            \n                        statusJob.cancel(true);\n          \n          \n            \n                        statusJob = null;\n          \n          \n            \n                    ScheduledFuture<?> statusJob = this.statusJob;\n          \n          \n            \n                    if (statusJob != null) {\n          \n          \n            \n                        statusJob.cancel(true);\n          \n          \n            \n                        this.statusJob = null;", "author": "cpmeister", "createdAt": "2020-04-13T21:28:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -865,94 +943,70 @@ public String getProperty(String key) {\n      * @param ForceRefresh true=force refresh before returning, false=return without\n      *            refresh\n      * @return ShellyDeviceProfile instance\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    @Nullable\n-    public ShellyDeviceProfile getProfile(boolean forceRefresh) throws IOException {\n+    public ShellyDeviceProfile getProfile(boolean forceRefresh) throws ShellyApiException {\n         try {\n             refreshSettings |= forceRefresh;\n             if (refreshSettings) {\n-                logger.debug(\"{}: Refresh settings\", thingName);\n-                profile = api.getDeviceProfile(getThing().getThingTypeUID().getId());\n+                profile = api.getDeviceProfile(thingType);\n+                if (!isThingOnline()) {\n+                    logger.debug(\"{}:Device profile re-initialized (thingType={})\", thingName, thingType);\n+                }\n             }\n         } finally {\n             refreshSettings = false;\n         }\n         return profile;\n     }\n \n-    @Nullable\n     public ShellyDeviceProfile getProfile() {\n         return profile;\n     }\n \n-    @Nullable\n     protected ShellyHttpApi getShellyApi() {\n         return api;\n     }\n \n-    @Nullable\n     protected ShellyDeviceProfile getDeviceProfile() {\n         return profile;\n     }\n \n-    /**\n-     * Get a value from the Channel Cache\n-     *\n-     * @param group Channel Group\n-     * @param channel Channel Name\n-     * @return the data from that channel\n-     */\n-    @Nullable\n-    public Object getChannelValue(String group, String channel) {\n-        String key = mkChannelId(group, channel);\n-        return channelData.get(key);\n-    }\n-\n     public void triggerChannel(String group, String channel, String payload) {\n         triggerChannel(mkChannelId(group, channel), payload);\n     }\n \n+    public void stop() {\n+        logger.debug(\"{}: Shutting down\", thingName);\n+        if (statusJob != null) {\n+            statusJob.cancel(true);\n+            statusJob = null;", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2Nzc1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408067757", "bodyText": "changed and understood why :-)", "author": "markus7017", "createdAt": "2020-04-14T11:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMjEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMzczNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407733734", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Unable to handle command: {}\", thingName, e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Unable to handle command:\", thingName, e);", "author": "cpmeister", "createdAt": "2020-04-13T21:31:46Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyLightHandler.java", "diffHunk": "@@ -74,160 +76,167 @@ public void initialize() {\n         super.initialize();\n     }\n \n-    @SuppressWarnings(\"null\")\n     @Override\n-    public boolean handleDeviceCommand(ChannelUID channelUID, Command command) throws IOException {\n-        String groupName = channelUID.getGroupId();\n-        Integer lightId = getLightIdFromGroup(groupName);\n-        logger.trace(\"{}: Execute command {} on channel {}, lightId={}\", thingName, command.toString(),\n-                channelUID.getAsString(), lightId);\n-\n-        Validate.notNull(profile, \"DeviceProfile must not be null, thing not initialized\");\n-        Validate.notNull(api, \"handleCommand(): api must not be null!\");\n-        ShellyColorUtils oldCol = getCurrentColors(lightId);\n-        Validate.notNull(oldCol, \"oldCol must not be null\");\n-        oldCol.mode = profile.mode;\n-        ShellyColorUtils col = new ShellyColorUtils(oldCol);\n-        Validate.notNull(oldCol, \"copy of oldCol must not be null\");\n-\n-        boolean update = true;\n-        switch (channelUID.getIdWithoutGroup()) {\n-            default: // non-bulb commands will be handled by the generic handler\n-                return false;\n-\n-            case CHANNEL_LIGHT_POWER:\n-                logger.debug(\"{}: Switch light {}\", thingName, command.toString());\n-                Validate.isTrue(command instanceof OnOffType, \"Invalid value for power (ON or OFF): {}\",\n-                        command.toString());\n-                api.setLightParm(lightId, SHELLY_LIGHT_TURN,\n-                        (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n-                col.power = (OnOffType) command;\n-                update = (OnOffType) command == OnOffType.ON;\n-                break;\n-            case CHANNEL_LIGHT_COLOR_MODE:\n-                logger.debug(\"{}: Select color mode {}\", thingName, command.toString());\n-                Validate.isTrue(command instanceof OnOffType,\n-                        \"Invalid value for color mode (ON or OFF): \" + command.toString());\n-                col.setMode((OnOffType) command == OnOffType.ON ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n-                break;\n-            case CHANNEL_COLOR_PICKER:\n-                logger.debug(\"{}: Update colors from color picker\", thingName);\n-                update = handleColorPicker(profile, lightId, col, command);\n-                break;\n-            case CHANNEL_COLOR_FULL:\n-                logger.debug(\"{}: Set colors to {}\", thingName, command.toString());\n-                handleFullColor(col, command);\n-                break;\n-            case CHANNEL_COLOR_RED:\n-                col.setRed(setColor(lightId, SHELLY_COLOR_RED, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_GREEN:\n-                col.setGreen(setColor(lightId, SHELLY_COLOR_GREEN, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_BLUE:\n-                col.setBlue(setColor(lightId, SHELLY_COLOR_BLUE, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_WHITE:\n-                col.setWhite(setColor(lightId, SHELLY_COLOR_WHITE, command, SHELLY_MAX_COLOR));\n-                break;\n-            case CHANNEL_COLOR_GAIN:\n-                col.setGain(setColor(lightId, SHELLY_COLOR_GAIN, command, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n-                break;\n-            case CHANNEL_BRIGHTNESS: // only in white mode\n-                Integer value = -1;\n-                if (command instanceof OnOffType) { // Switch\n-                    logger.debug(\"Switch light {}\", command.toString());\n-                    api.setRelayTurn(lightId, (OnOffType) command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n-                    requestUpdates(1, false);\n-                    break;\n-                }\n+    public boolean handleDeviceCommand(ChannelUID channelUID, Command command) throws IllegalArgumentException {\n+        String groupName = getString(channelUID.getGroupId());\n+        if (groupName.isEmpty()) {\n+            throw new IllegalArgumentException(\"Empty groupName\");\n+        }\n \n-                if (command instanceof PercentType) {\n-                    Float percent = ((PercentType) command).floatValue();\n-                    value = percent.intValue(); // 0..100% = 0..100\n-                    logger.debug(\"{}: Set brightness to {}%/{}\", thingName, percent, value);\n-                } else if (command instanceof DecimalType) {\n-                    value = ((DecimalType) command).intValue();\n-                    logger.debug(\"{}: Set brightness to {} (Integer)\", thingName, value);\n-                }\n-                if (value == 0) {\n-                    logger.debug(\"{}: Brightness=0 -> switch light OFF\", thingName);\n-                    api.setRelayTurn(lightId, SHELLY_API_OFF);\n+        int lightId = getLightIdFromGroup(groupName);\n+        logger.trace(\"{}: Execute command {} on channel {}, lightId={}\", thingName, command, channelUID.getAsString(),\n+                lightId);\n+\n+        try {\n+            ShellyColorUtils oldCol = getCurrentColors(lightId);\n+            oldCol.mode = profile.mode;\n+            ShellyColorUtils col = new ShellyColorUtils(oldCol);\n+\n+            boolean update = true;\n+            switch (channelUID.getIdWithoutGroup()) {\n+                default: // non-bulb commands will be handled by the generic handler\n+                    return false;\n+\n+                case CHANNEL_LIGHT_POWER:\n+                    logger.debug(\"{}: Switch light {}\", thingName, command);\n+                    api.setLightParm(lightId, SHELLY_LIGHT_TURN,\n+                            command == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n+                    col.power = (OnOffType) command;\n                     requestUpdates(1, false);\n+                    update = false;\n                     break;\n-                }\n+                case CHANNEL_LIGHT_COLOR_MODE:\n+                    logger.debug(\"{}: Select color mode {}\", thingName, command);\n+                    col.setMode((OnOffType) command == OnOffType.ON ? SHELLY_MODE_COLOR : SHELLY_MODE_WHITE);\n+                    break;\n+                case CHANNEL_COLOR_PICKER:\n+                    logger.debug(\"{}: Update colors from color picker\", thingName);\n+                    update = handleColorPicker(profile, lightId, col, command);\n+                    break;\n+                case CHANNEL_COLOR_FULL:\n+                    logger.debug(\"{}: Set colors to {}\", thingName, command);\n+                    handleFullColor(col, command);\n+                    break;\n+                case CHANNEL_COLOR_RED:\n+                    col.setRed(setColor(lightId, SHELLY_COLOR_RED, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_GREEN:\n+                    col.setGreen(setColor(lightId, SHELLY_COLOR_GREEN, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_BLUE:\n+                    col.setBlue(setColor(lightId, SHELLY_COLOR_BLUE, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_WHITE:\n+                    col.setWhite(setColor(lightId, SHELLY_COLOR_WHITE, command, SHELLY_MAX_COLOR));\n+                    break;\n+                case CHANNEL_COLOR_GAIN:\n+                    col.setGain(setColor(lightId, SHELLY_COLOR_GAIN, command, SHELLY_MIN_GAIN, SHELLY_MAX_GAIN));\n+                    break;\n+                case CHANNEL_BRIGHTNESS: // only in white mode\n+                    if (profile.inColor && !profile.isBulb) {\n+                        logger.debug(\"{}: Not in white mode, brightness not available\", thingName);\n+                        break;\n+                    }\n \n-                if (command instanceof IncreaseDecreaseType) {\n-                    ShellyShortLightStatus light = api.getLightStatus(lightId);\n-                    Validate.notNull(light, \"Unable to get Light status for brightness\");\n+                    int value = -1;\n+                    if (command instanceof OnOffType) { // Switch\n+                        logger.debug(\"{}: Switch light {}\", thingName, command);\n+                        ShellyShortLightStatus light = api.getLightStatus(lightId);\n+                        col.brightness = light.brightness;\n+                        col.power = (OnOffType) command;\n+                        api.setRelayTurn(lightId, col.power == OnOffType.ON ? SHELLY_API_ON : SHELLY_API_OFF);\n+                        // updateChannel(CHANNEL_COLOR_WHITE, CHANNEL_BRIGHTNESS + \"$Switch\", col.power);\n+                        updateChannel(CHANNEL_COLOR_WHITE, CHANNEL_BRIGHTNESS + \"$Value\",\n+                                toQuantityType(new Double(col.power == OnOffType.ON ? col.brightness : 0), DIGITS_NONE,\n+                                        SmartHomeUnits.PERCENT));\n+                        update = false;\n+                        break;\n+                    }\n \n-                    if (((IncreaseDecreaseType) command).equals(IncreaseDecreaseType.INCREASE)) {\n-                        value = Math.min(light.brightness + DIM_STEPSIZE, 100);\n+                    if (command instanceof PercentType) {\n+                        Float percent = ((PercentType) command).floatValue();\n+                        value = percent.intValue(); // 0..100% = 0..100\n+                        logger.debug(\"{}: Set brightness to {}%/{}\", thingName, percent, value);\n+                    } else if (command instanceof DecimalType) {\n+                        value = ((DecimalType) command).intValue();\n+                        logger.debug(\"{}: Set brightness to {} (Integer)\", thingName, value);\n+                    }\n+                    if (value == 0) {\n+                        logger.debug(\"{}: Brightness=0 -> switch light OFF\", thingName);\n+                        api.setRelayTurn(lightId, SHELLY_API_OFF);\n+                        update = false;\n                     } else {\n-                        value = Math.max(light.brightness - DIM_STEPSIZE, 0);\n+\n+                        if (command instanceof IncreaseDecreaseType) {\n+                            ShellyShortLightStatus light = api.getLightStatus(lightId);\n+                            if (((IncreaseDecreaseType) command).equals(IncreaseDecreaseType.INCREASE)) {\n+                                value = Math.min(light.brightness + DIM_STEPSIZE, 100);\n+                            } else {\n+                                value = Math.max(light.brightness - DIM_STEPSIZE, 0);\n+                            }\n+                            logger.trace(\"{}: Change brightness from {} to {}\", thingName, light.brightness, value);\n+                        }\n+\n+                        validateRange(\"brightness\", value, 0, 100);\n+                        logger.debug(\"{}: Changing brightness from {} to {}\", thingName, oldCol.brightness, value);\n+                        col.setBrightness(value);\n                     }\n-                    logger.trace(\"{}: Change brightness from {} to {}\", thingName, light.brightness, value);\n-                }\n+                    updateChannel(CHANNEL_GROUP_LIGHT_CONTROL, CHANNEL_LIGHT_POWER,\n+                            value > 0 ? OnOffType.ON : OnOffType.OFF);\n+                    break;\n \n-                validateRange(\"brightness\", value, 0, 100);\n-                logger.debug(\"{}: Set brightness to\", value);\n-                col.setBrightness(value);\n-                break;\n-\n-            case CHANNEL_COLOR_TEMP:\n-                Integer temp = -1;\n-                if (command instanceof PercentType) {\n-                    logger.debug(\"{}: Set color temp to {}%\", thingName, ((PercentType) command).floatValue());\n-                    Float percent = ((PercentType) command).floatValue() / 100;\n-                    temp = new DecimalType(\n-                            MIN_COLOR_TEMPERATURE + ((MAX_COLOR_TEMPERATURE - MIN_COLOR_TEMPERATURE)) * percent)\n-                                    .intValue();\n-                    logger.debug(\"{}: Converted color-temp {}% to {}K (from Percent to Integer)\", thingName, percent,\n-                            temp);\n-                } else if (command instanceof DecimalType) {\n-                    temp = ((DecimalType) command).intValue();\n-                    logger.debug(\"{}: Set color temp to {}K (Integer)\", thingName, temp);\n-                }\n-                validateRange(CHANNEL_COLOR_TEMP, temp, MIN_COLOR_TEMPERATURE, MAX_COLOR_TEMPERATURE);\n-                col.setTemp(temp);\n-                break;\n-\n-            case CHANNEL_COLOR_EFFECT:\n-                Integer effect = ((DecimalType) command).intValue();\n-                logger.debug(\"{}: Set color effect to {}\", thingName, effect);\n-                validateRange(\"effect\", effect, SHELLY_MIN_EFFECT, SHELLY_MAX_EFFECT);\n-                col.setEffect(effect.intValue());\n-                break;\n-        }\n+                case CHANNEL_COLOR_TEMP:\n+                    Integer temp = -1;\n+                    if (command instanceof PercentType) {\n+                        logger.debug(\"{}: Set color temp to {}%\", thingName, ((PercentType) command).floatValue());\n+                        Float percent = ((PercentType) command).floatValue() / 100;\n+                        temp = new DecimalType(col.minTemp + ((col.maxTemp - col.minTemp)) * percent).intValue();\n+                        logger.debug(\"{}: Converted color-temp {}% to {}K (from Percent to Integer)\", thingName,\n+                                percent, temp);\n+                    } else if (command instanceof DecimalType) {\n+                        temp = ((DecimalType) command).intValue();\n+                        logger.debug(\"{}: Set color temp to {}K (Integer)\", thingName, temp);\n+                    }\n+                    validateRange(CHANNEL_COLOR_TEMP, temp, col.minTemp, col.maxTemp);\n+                    col.setTemp(temp);\n+                    col.brightness = -1;\n+                    break;\n \n-        if (update) {\n-            // check for switching color mode\n-            if (profile.isBulb && !col.mode.isEmpty() && !col.mode.equals(oldCol.mode)) {\n-                logger.debug(\"{}: Color mode changed from {} to {}, set new mode\", thingName, oldCol.mode, col.mode);\n-                api.setLightMode(col.mode);\n+                case CHANNEL_COLOR_EFFECT:\n+                    Integer effect = ((DecimalType) command).intValue();\n+                    logger.debug(\"{}: Set color effect to {}\", thingName, effect);\n+                    validateRange(\"effect\", effect, SHELLY_MIN_EFFECT, SHELLY_MAX_EFFECT);\n+                    col.setEffect(effect.intValue());\n             }\n \n-            // send changed colors to the device\n-            sendColors(profile, lightId, oldCol, col, config.brightnessAutoOn);\n-        }\n-\n-        return true;\n+            if (update) {\n+                // check for switching color mode\n+                if (profile.isBulb && !col.mode.isEmpty() && !col.mode.equals(oldCol.mode)) {\n+                    logger.debug(\"{}: Color mode changed from {} to {}, set new mode\", thingName, oldCol.mode,\n+                            col.mode);\n+                    api.setLightMode(col.mode);\n+                }\n \n+                // send changed colors to the device\n+                sendColors(profile, lightId, oldCol, col, config.brightnessAutoOn);\n+            }\n+            return true;\n+        } catch (ShellyApiException | IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to handle command: {}\", thingName, e.toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA2NzkwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408067907", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczMzczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTcyNw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407735727", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n          \n          \n            \n                                newValue.getClass(), ShellyUtils.getMessage(e), e.getClass());", "author": "cpmeister", "createdAt": "2020-04-13T21:35:57Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n+    private String thingName = \"\";\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        setThingName(thingHandler.thingName);\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n+        try {\n+            State current = null;\n+            if (channelData.containsKey(channelId)) {\n+                current = channelData.get(channelId);\n+            }\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n+                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n+                    return false; // special case for OnOffType\n+                }\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, newValue);\n+                if (current == null) {\n+                    channelData.put(channelId, newValue);\n+                } else {\n+                    channelData.replace(channelId, newValue);\n+                }\n+                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n+                        newValue.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n+                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzOTUzMw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408039533", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T10:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTg4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407735889", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                public Object getValue(String channelId) {\n          \n          \n            \n                public @Nullable State getValue(String channelId) {", "author": "cpmeister", "createdAt": "2020-04-13T21:36:18Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n+    private String thingName = \"\";\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        setThingName(thingHandler.thingName);\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n+        try {\n+            State current = null;\n+            if (channelData.containsKey(channelId)) {\n+                current = channelData.get(channelId);\n+            }\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n+                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n+                    return false; // special case for OnOffType\n+                }\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, newValue);\n+                if (current == null) {\n+                    channelData.put(channelId, newValue);\n+                } else {\n+                    channelData.replace(channelId, newValue);\n+                }\n+                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n+                        newValue.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n+                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {\n+        return getValue(mkChannelId(group, channel));\n+    }\n+\n+    @Nullable\n+    public Object getValue(String channelId) {", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1MTkxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408051918", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3NzIwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408077202", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTk4NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407735984", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                public Object getValue(String group, String channel) {\n          \n          \n            \n                public @Nullable State getValue(String group, String channel) {\n          \n      \n    \n    \n  \n\nIn addition would it be possible to get rid of the nullable return value by returning UndefType.NULL instead?", "author": "cpmeister", "createdAt": "2020-04-13T21:36:32Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyChannelCache.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.shelly.internal.util;\n+\n+import static org.openhab.binding.shelly.internal.util.ShellyUtils.mkChannelId;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.shelly.internal.handler.ShellyBaseHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ShellyChannelCache} implements a caching layer for channel updates.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyChannelCache {\n+    private final Logger logger = LoggerFactory.getLogger(ShellyChannelCache.class);\n+\n+    private final ShellyBaseHandler thingHandler;\n+    private final Map<String, State> channelData = new ConcurrentHashMap<>();\n+    private String thingName = \"\";\n+    private boolean enabled = false;\n+\n+    public ShellyChannelCache(ShellyBaseHandler thingHandler) {\n+        this.thingHandler = thingHandler;\n+        setThingName(thingHandler.thingName);\n+    }\n+\n+    public void setThingName(String thingName) {\n+        this.thingName = thingName;\n+    }\n+\n+    public boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public void enable() {\n+        enabled = true;\n+    }\n+\n+    public void disable() {\n+        enabled = false;\n+    }\n+\n+    /**\n+     * Update one channel. Use Channel Cache to avoid unnecessary updates (and avoid\n+     * messing up the log with those updates)\n+     *\n+     * @param channelId Channel id\n+     * @param value Value (State)\n+     * @param forceUpdate true: ignore cached data, force update; false check cache of changed data\n+     * @return true, if successful\n+     */\n+    public boolean updateChannel(String channelId, State newValue, Boolean forceUpdate) {\n+        try {\n+            State current = null;\n+            if (channelData.containsKey(channelId)) {\n+                current = channelData.get(channelId);\n+            }\n+            if (!enabled || forceUpdate || (current == null) || !current.equals(newValue)) {\n+                if ((current != null) && current.getClass().isEnum() && (current == newValue)) {\n+                    return false; // special case for OnOffType\n+                }\n+                // For channels that support multiple types (like brightness) a suffix is added\n+                // this gets removed to get the channelId for updateState\n+                thingHandler.publishState(channelId, newValue);\n+                if (current == null) {\n+                    channelData.put(channelId, newValue);\n+                } else {\n+                    channelData.replace(channelId, newValue);\n+                }\n+                logger.debug(\"{}: Channel {} updated with {} (type {}).\", thingName, channelId, newValue,\n+                        newValue.getClass());\n+                return true;\n+            }\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Unable to update channel {} with {} (type {}): {} ({})\", thingName, channelId, newValue,\n+                    newValue.getClass().toString(), ShellyUtils.getMessage(e), e.getClass().toString());\n+        }\n+        return false;\n+    }\n+\n+    public boolean updateChannel(String group, String channel, State value) {\n+        return updateChannel(mkChannelId(group, channel), value, false);\n+    }\n+\n+    public boolean updateChannel(String channelId, State value) {\n+        return updateChannel(channelId, value, false);\n+    }\n+\n+    /**\n+     * Get a value from the Channel Cache\n+     *\n+     * @param group Channel Group\n+     * @param channel Channel Name\n+     * @return the data from that channel\n+     */\n+    @Nullable\n+    public Object getValue(String group, String channel) {", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1NjEyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408056129", "bodyText": "yep, changed", "author": "markus7017", "createdAt": "2020-04-14T11:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3NzY1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408077655", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3ODQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408078454", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczNTk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczODAyNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407738024", "bodyText": "Why couldn't you just do this?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public int compare(Object o1, Object o2) {\n          \n          \n            \n                    String version1 = (String) o1;\n          \n          \n            \n                    String version2 = (String) o2;\n          \n          \n            \n                public int compare(String version1, String version2) {", "author": "cpmeister", "createdAt": "2020-04-13T21:41:03Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO {\n+    private class VersionTokenizer {\n+        private final String versionString;\n+        private final int length;\n+\n+        private int position;\n+        private int number;\n+        private String suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            this.versionString = versionString;\n+            length = versionString.length();\n+        }\n+\n+        private boolean MoveNext() {\n+            number = 0;\n+            suffix = \"\";\n+\n+            // No more characters\n+            if (position >= length) {\n+                return false;\n+            }\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                number = number * 10 + (c - '0');\n+                position++;\n+            }\n+\n+            int suffixStart = position;\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c == '.') {\n+                    break;\n+                }\n+                position++;\n+            }\n+\n+            suffix = versionString.substring(suffixStart, position);\n+\n+            if (position < length) {\n+                position++;\n+            }\n+\n+            return true;\n+        }\n+\n+        private int getNumber() {\n+            return number;\n+        }\n+\n+        private String getSuffix() {\n+            return suffix;\n+        }\n+    }\n+\n+    public boolean equals(String o1, String o2) {\n+        return compare(o1, o2) == 0;\n+    }\n+\n+    public int compare(Object o1, Object o2) {\n+        String version1 = (String) o1;\n+        String version2 = (String) o2;", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1MzA0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408053041", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-14T11:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczODAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3ODE5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408078196", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczODAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3ODUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408078502", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczODAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczOTE4MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r407739180", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private boolean MoveNext() {\n          \n          \n            \n                    private boolean moveNext() {", "author": "cpmeister", "createdAt": "2020-04-13T21:43:39Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO {\n+    private class VersionTokenizer {\n+        private final String versionString;\n+        private final int length;\n+\n+        private int position;\n+        private int number;\n+        private String suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            this.versionString = versionString;\n+            length = versionString.length();\n+        }\n+\n+        private boolean MoveNext() {", "originalCommit": "3557dbbda1155bacea7289de274e96dd402287cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1MzMzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408053339", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-14T11:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczOTE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3ODMxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408078319", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczOTE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3ODU4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r408078586", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-14T11:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzczOTE4MA=="}], "type": "inlineReview"}, {"oid": "ea3c676f9f60a737b94db41273eca5de525e9132", "url": "https://github.com/openhab/openhab-addons/commit/ea3c676f9f60a737b94db41273eca5de525e9132", "message": "[sensebox] Added German translations (#7384)\n\n* Added German translations\r\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-04-17T05:51:13Z", "type": "forcePushed"}, {"oid": "b4f93244dafd48fcc45c89c612bc7fd90ce338b6", "url": "https://github.com/openhab/openhab-addons/commit/b4f93244dafd48fcc45c89c612bc7fd90ce338b6", "message": "Re-checkin based on latest PR review status\n\nSigned-off-by: Markus Michels <markus7017@gmail.com> (github: markus7017)", "committedDate": "2020-04-17T12:36:41Z", "type": "commit"}, {"oid": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "url": "https://github.com/openhab/openhab-addons/commit/0f8b13e2ef4c7b4ec0f58a02905581c384709218", "message": "delete obsolete files from 2.5.2 version\n\nSigned-off-by: Markus Michels <markus7017@gmail.com> (github: markus7017)", "committedDate": "2020-04-17T12:38:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NDE4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410384189", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (tokenizer2.moveNext()) {\n          \n          \n            \n                        do {\n          \n          \n            \n                            number2 = tokenizer2.getNumber();\n          \n          \n            \n                            suffix2 = tokenizer2.getSuffix();\n          \n          \n            \n                            if (number2 != 0 || suffix2.length() != 0) {\n          \n          \n            \n                                // Version one is longer than version two, and non-zero\n          \n          \n            \n                                return -1;\n          \n          \n            \n                            }\n          \n          \n            \n                        } while (tokenizer2.moveNext());\n          \n          \n            \n            \n          \n          \n            \n                        // Version two is longer than version one, but zero\n          \n          \n            \n                        return 0;\n          \n          \n            \n                    }\n          \n          \n            \n                    return 0;\n          \n          \n            \n                    while (tokenizer2.moveNext()) {\n          \n          \n            \n                            number2 = tokenizer2.getNumber();\n          \n          \n            \n                            suffix2 = tokenizer2.getSuffix();\n          \n          \n            \n                            if (number2 != 0 || suffix2.length() != 0) {\n          \n          \n            \n                                // Version one is longer than version two, and non-zero\n          \n          \n            \n                                return -1;\n          \n          \n            \n                            }\n          \n          \n            \n                    }\n          \n          \n            \n                    // Version two is longer than version one, but zero\n          \n          \n            \n                    return 0;", "author": "cpmeister", "createdAt": "2020-04-17T18:01:16Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/util/ShellyVersionDTO.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.shelly.internal.util;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * {@link ShellyVersionDTO} compares 2 version strings.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ShellyVersionDTO {\n+    private class VersionTokenizer {\n+        private final String versionString;\n+        private final int length;\n+\n+        private int position;\n+        private int number;\n+        private String suffix = \"\";\n+\n+        public VersionTokenizer(@Nullable String versionString) {\n+            if (versionString == null) {\n+                throw new IllegalArgumentException(\"versionString is null\");\n+            }\n+\n+            this.versionString = versionString;\n+            length = versionString.length();\n+        }\n+\n+        private boolean moveNext() {\n+            number = 0;\n+            suffix = \"\";\n+\n+            // No more characters\n+            if (position >= length) {\n+                return false;\n+            }\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c < '0' || c > '9') {\n+                    break;\n+                }\n+                number = number * 10 + (c - '0');\n+                position++;\n+            }\n+\n+            int suffixStart = position;\n+\n+            while (position < length) {\n+                char c = versionString.charAt(position);\n+                if (c == '.') {\n+                    break;\n+                }\n+                position++;\n+            }\n+\n+            suffix = versionString.substring(suffixStart, position);\n+\n+            if (position < length) {\n+                position++;\n+            }\n+\n+            return true;\n+        }\n+\n+        private int getNumber() {\n+            return number;\n+        }\n+\n+        private String getSuffix() {\n+            return suffix;\n+        }\n+    }\n+\n+    public boolean equals(String s1, String s2) {\n+        return compare(s1, s2) == 0;\n+    }\n+\n+    public int compare(String version1, String version2) {\n+        VersionTokenizer tokenizer1 = new VersionTokenizer(version1);\n+        VersionTokenizer tokenizer2 = new VersionTokenizer(version2);\n+\n+        int number1 = 0, number2 = 0;\n+        String suffix1 = \"\", suffix2 = \"\";\n+\n+        while (tokenizer1.moveNext()) {\n+            if (!tokenizer2.moveNext()) {\n+                do {\n+                    number1 = tokenizer1.getNumber();\n+                    suffix1 = tokenizer1.getSuffix();\n+                    if (number1 != 0 || suffix1.length() != 0) {\n+                        // Version one is longer than number two, and non-zero\n+                        return 1;\n+                    }\n+                } while (tokenizer1.moveNext());\n+\n+                // Version one is longer than version two, but zero\n+                return 0;\n+            }\n+\n+            number1 = tokenizer1.getNumber();\n+            suffix1 = tokenizer1.getSuffix();\n+            number2 = tokenizer2.getNumber();\n+            suffix2 = tokenizer2.getSuffix();\n+\n+            if (number1 < number2) {\n+                // Number one is less than number two\n+                return -1;\n+            }\n+            if (number1 > number2) {\n+                // Number one is greater than number two\n+                return 1;\n+            }\n+\n+            boolean empty1 = suffix1.length() == 0;\n+            boolean empty2 = suffix2.length() == 0;\n+\n+            if (empty1 && empty2) {\n+                continue;\n+            } // No suffixes\n+            if (empty1) {\n+                return 1;\n+            } // First suffix is empty (1.2 > 1.2b)\n+            if (empty2) {\n+                return -1;\n+            } // Second suffix is empty (1.2a < 1.2)\n+\n+            // Lexical comparison of suffixes\n+            int result = suffix1.compareTo(suffix2);\n+            if (result != 0) {\n+                return result;\n+            }\n+\n+        }\n+        if (tokenizer2.moveNext()) {\n+            do {\n+                number2 = tokenizer2.getNumber();\n+                suffix2 = tokenizer2.getSuffix();\n+                if (number2 != 0 || suffix2.length() != 0) {\n+                    // Version one is longer than version two, and non-zero\n+                    return -1;\n+                }\n+            } while (tokenizer2.moveNext());\n+\n+            // Version two is longer than version one, but zero\n+            return 0;\n+        }\n+        return 0;", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1NTgwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410655801", "bodyText": "changed, test open", "author": "markus7017", "createdAt": "2020-04-18T06:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4NDE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMTE1MA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410421150", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Exception processing callback: {path={}, data='{}'; index={}, type={}, parameters={}{}\",\n          \n          \n            \n                                deviceName, path, data, index, type, request.getParameterMap().toString(), e.toString());\n          \n          \n            \n                        logger.debug(\"{}: Exception processing callback: {path={}, data='{}'; index={}, type={}, parameters={}\",\n          \n          \n            \n                                deviceName, path, data, index, type, request.getParameterMap().toString(), e);", "author": "cpmeister", "createdAt": "2020-04-17T19:15:50Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyEventServlet.java", "diffHunk": "@@ -113,52 +116,20 @@ protected void service(@Nullable HttpServletRequest request, @Nullable HttpServl\n                 index = \"\";\n                 type = StringUtils.substringAfterLast(path, \"/\").toLowerCase();\n             }\n-            logger.trace(\"Process event of type type={} for device {}, index={}\", type, deviceName, index);\n-            Map<String, String> parms = new HashMap<>();\n+            logger.trace(\"{}: Process event of type type={}, index={}\", deviceName, type, index);\n+            Map<String, String> parms = new TreeMap<>();\n+\n             for (Map.Entry<String, String[]> p : parameters.entrySet()) {\n                 parms.put(p.getKey(), p.getValue()[0]);\n \n             }\n-            handlerFactory.onEvent(deviceName, index, type, parms);\n-\n-        } catch (NullPointerException e) {\n-            logger.debug(\n-                    \"ERROR: Exception processing callback: {} ({}), path={}, data='{}'; deviceName={}, index={}, type={}, parameters={}\\n{}\",\n-                    e.getMessage(), e.getClass(), path, data, deviceName, index, type,\n-                    request.getParameterMap().toString(), e.getStackTrace());\n+            handlerFactory.onEvent(ipAddress, deviceName, index, type, parms);\n+        } catch (IllegalArgumentException e) {\n+            logger.debug(\"{}: Exception processing callback: {path={}, data='{}'; index={}, type={}, parameters={}{}\",\n+                    deviceName, path, data, index, type, request.getParameterMap().toString(), e.toString());", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1NjA1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410656057", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-18T06:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMTE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTk0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410425947", "bodyText": "It would be more concise if you changed your setEventUrl method to accept multiple event types\nprivate void setEventUrl(String deviceClass, Integer index, boolean enabled, String... eventTypes){\n    for(String eventType : eventTypes){\n        if (profile.containsEventUrl(eventType)) {\n        ...\n        }\n    }\n}\n\nThat way you can call it like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n          \n          \n            \n            \n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n          \n          \n            \n            \n          \n          \n            \n                        // Relay output\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsButton, SHELLY_EVENT_BTN1_ON, SHELLY_EVENT_BTN1_OFF, SHELLY_EVENT_BTN2_ON, SHELLY_EVENT_BTN2_OFF);\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH1, SHELLY_EVENT_LONGPUSH1, SHELLY_EVENT_SHORTPUSH2, SHELLY_EVENT_LONGPUSH2);\n          \n          \n            \n            \n          \n          \n            \n                        // Relay output\n          \n          \n            \n                        setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);", "author": "cpmeister", "createdAt": "2020-04-17T19:26:16Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,221 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(SHELLY_EVENT_SENSORREPORT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_DARK, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_TWILIGHT, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_DETECTED, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_FLOOD_GONE, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_CLOSE, config.eventsSensorReport);\n+            setEventUrl(SHELLY_EVENT_VIBRATION, config.eventsSensorReport);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n+        String type = \"\";\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_OPEN, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_CLOSE, config.eventsRoller);\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, SHELLY_EVENT_ROLLER_STOP, config.eventsRoller);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN1_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH1, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH1, config.eventsPush);\n+\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_ON, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_BTN2_OFF, config.eventsButton);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_SHORTPUSH2, config.eventsPush);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_LONGPUSH2, config.eventsPush);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_ON, config.eventsSwitch);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, SHELLY_EVENT_OUT_OFF, config.eventsSwitch);", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1NjM1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410656357", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-18T06:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyNTk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTAyNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410429024", "bodyText": "I don't know what kind of processing goes on behind response.getSourceContext().getPeerAddress() and response.getPayloadString(). But to be safe you should probably make sure those are only called when necessary.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: CoIoT Message from {} (MID={}): {}\", thingName,\n          \n          \n            \n                                response.getSourceContext().getPeerAddress(), response.getMID(), response.getPayloadString());\n          \n          \n            \n                        if(logger.isDebugEnabled()){\n          \n          \n            \n                            logger.debug(\"{}: CoIoT Message from {} (MID={}): {}\", thingName,\n          \n          \n            \n                                    response.getSourceContext().getPeerAddress(), response.getMID(), response.getPayloadString());\n          \n          \n            \n                        }", "author": "cpmeister", "createdAt": "2020-04-17T19:33:14Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -141,8 +158,8 @@ public void processResponse(@Nullable Response response) {\n         // int validity = 0;\n         int serial = 0;\n         try {\n-            logger.debug(\"{}: CoIoT Message from {}: {}\", thingName, response.getSourceContext().getPeerAddress(),\n-                    response.toString());\n+            logger.debug(\"{}: CoIoT Message from {} (MID={}): {}\", thingName,\n+                    response.getSourceContext().getPeerAddress(), response.getMID(), response.getPayloadString());", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1NjY4OA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410656688", "bodyText": "those are just picking some attributes of the message\nchanged", "author": "markus7017", "createdAt": "2020-04-18T06:30:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTQ3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410429473", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        case \"external temperature f\": // Shelly 1/1PM externa\u00f6 temp sensors\n          \n          \n            \n                                        case \"external temperature f\": // Shelly 1/1PM external temp sensors", "author": "cpmeister", "createdAt": "2020-04-17T19:34:08Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -329,50 +332,84 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n \n         // Parse Json,\n         CoIotGenericSensorList list = gson.fromJson(payload, CoIotGenericSensorList.class);\n-        Validate.notNull(list, \"sensor list must not be empty!\");\n-        Map<String, State> updates = new HashMap<>();\n-\n         if (list.generic == null) {\n-            logger.debug(\"{}: Sensor list is empty! Payload: {}\", devId, payload);\n+            logger.debug(\"{}: Sensor list has invalid format! Payload: {}\", devId, payload);\n             return;\n         }\n+        List<CoIotSensor> sensorUpdates = list.generic;\n \n-        Validate.notNull(thingHandler, \"thingHandler must not be null!\");\n         ShellyDeviceProfile profile = thingHandler.getProfile();\n-        if (profile == null) {\n-            logger.debug(\"{}: Thing not initialized yet, skip update (ID={})\", thingName, devId);\n-            thingHandler.requestUpdates(1, true);\n-            return;\n-        }\n-\n-        logger.debug(\"{}: {}\u00a0status updates received\", thingName, new Integer(list.generic.size()).toString());\n-        for (int i = 0; i < list.generic.size(); i++) {\n-            CoIotSensor s = list.generic.get(i);\n-            CoIotDescrSen sen = sensorMap.get(s.index);\n-            if (sen != null) {\n-                // find matching sensor definition from device description, use the Link ID as\n-                // index\n-                Validate.notNull(sen.links != null, \"Coap: sen.L must not be null!\");\n+        Map<String, State> updates = new TreeMap<String, State>();\n+        logger.debug(\"{}: {}\u00a0CoAP sensor updates received\", thingName, sensorUpdates.size());\n+        for (int i = 0; i < sensorUpdates.size(); i++) {\n+            try {\n+                CoIotSensor s = sensorUpdates.get(i);\n+                if (!sensorMap.containsKey(s.id)) {\n+                    logger.debug(\"{}: Invalid index in sensor description: {}\", thingName, i);\n+                    continue;\n+                }\n+                CoIotDescrSen sen = sensorMap.get(s.id);\n+                // find matching sensor definition from device description, use the Link ID as index\n                 sen = fixDescription(sen);\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Invalid CoAP description: sen.links({}\", thingName, getString(sen.links));\n+                    continue;\n+                }\n+\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Unable to find BLK for link {} from sen.id={}\", thingName, sen.links, sen.id);\n+                    continue;\n+                }\n                 CoIotDescrBlk element = blockMap.get(sen.links);\n-                logger.debug(\"{}:  Sensor value[{}]: Index={}, Value={} ({}, Type={}, Range={}, Link={}: {})\",\n-                        thingName, i, s.index, s.value, sen.desc, sen.type, sen.range, sen.links,\n-                        element != null ? element.desc : \"n/a\");\n+                logger.trace(\"{}:  Sensor value[{}]: id={}, Value={} ({}, Type={}, Range={}, Link={}: {})\", thingName,\n+                        i, s.id, s.value, sen.desc, sen.type, sen.range, sen.links, element.desc);\n \n                 // Process status information and convert into channel updates\n-                String type = (element != null ? element.desc : \"\").toLowerCase();\n                 Integer rIndex = Integer.parseInt(sen.links) + 1;\n                 String rGroup = profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL\n                         : CHANNEL_GROUP_RELAY_CONTROL + rIndex;\n \n-                switch (sen.type.toLowerCase()) /* CoIoT_STypes.valueOf(sen.T) */ {\n+                switch (sen.type.toLowerCase()) {\n                     case \"b\" /* BatteryLevel */:\n                         updateChannel(updates, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LEVEL,\n                                 toQuantityType(s.value, DIGITS_PERCENT, SmartHomeUnits.PERCENT));\n                         break;\n                     case \"t\" /* Temperature */:\n-                        updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n-                                toQuantityType(s.value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                        Double value = getDouble(s.value);\n+                        switch (sen.desc.toLowerCase()) {\n+                            case \"temperature\": // Sensor Temp\n+                                if (getString(profile.settings.temperatureUnits)\n+                                        .equalsIgnoreCase(SHELLY_TEMP_FAHRENHEIT)) {\n+                                    value = ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS)\n+                                            .convert(getDouble(s.value)).doubleValue();\n+                                }\n+                                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n+                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                                break;\n+                            case \"temperature f\": // Device Temp -> ignore (we use C only)\n+                                break;\n+                            case \"temperature c\": // Device Tem\u00fc in C\n+                                // Device temperature\n+                                updateChannel(updates, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP,\n+                                        toQuantityType(value, DIGITS_NONE, SIUnits.CELSIUS));\n+                                break;\n+                            case \"external temperature f\": // Shelly 1/1PM externa\u00f6 temp sensors", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY2ODQ3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410668477", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-18T08:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTUyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410429525", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        case \"external temperature c\": // Shelly 1/1PM externa\u00f6 temp sensors\n          \n          \n            \n                                        case \"external temperature c\": // Shelly 1/1PM external temp sensors", "author": "cpmeister", "createdAt": "2020-04-17T19:34:17Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapHandler.java", "diffHunk": "@@ -329,50 +332,84 @@ private void handleStatusUpdate(String devId, String payload, int serial) throws\n \n         // Parse Json,\n         CoIotGenericSensorList list = gson.fromJson(payload, CoIotGenericSensorList.class);\n-        Validate.notNull(list, \"sensor list must not be empty!\");\n-        Map<String, State> updates = new HashMap<>();\n-\n         if (list.generic == null) {\n-            logger.debug(\"{}: Sensor list is empty! Payload: {}\", devId, payload);\n+            logger.debug(\"{}: Sensor list has invalid format! Payload: {}\", devId, payload);\n             return;\n         }\n+        List<CoIotSensor> sensorUpdates = list.generic;\n \n-        Validate.notNull(thingHandler, \"thingHandler must not be null!\");\n         ShellyDeviceProfile profile = thingHandler.getProfile();\n-        if (profile == null) {\n-            logger.debug(\"{}: Thing not initialized yet, skip update (ID={})\", thingName, devId);\n-            thingHandler.requestUpdates(1, true);\n-            return;\n-        }\n-\n-        logger.debug(\"{}: {}\u00a0status updates received\", thingName, new Integer(list.generic.size()).toString());\n-        for (int i = 0; i < list.generic.size(); i++) {\n-            CoIotSensor s = list.generic.get(i);\n-            CoIotDescrSen sen = sensorMap.get(s.index);\n-            if (sen != null) {\n-                // find matching sensor definition from device description, use the Link ID as\n-                // index\n-                Validate.notNull(sen.links != null, \"Coap: sen.L must not be null!\");\n+        Map<String, State> updates = new TreeMap<String, State>();\n+        logger.debug(\"{}: {}\u00a0CoAP sensor updates received\", thingName, sensorUpdates.size());\n+        for (int i = 0; i < sensorUpdates.size(); i++) {\n+            try {\n+                CoIotSensor s = sensorUpdates.get(i);\n+                if (!sensorMap.containsKey(s.id)) {\n+                    logger.debug(\"{}: Invalid index in sensor description: {}\", thingName, i);\n+                    continue;\n+                }\n+                CoIotDescrSen sen = sensorMap.get(s.id);\n+                // find matching sensor definition from device description, use the Link ID as index\n                 sen = fixDescription(sen);\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Invalid CoAP description: sen.links({}\", thingName, getString(sen.links));\n+                    continue;\n+                }\n+\n+                if (!blockMap.containsKey(sen.links)) {\n+                    logger.debug(\"{}: Unable to find BLK for link {} from sen.id={}\", thingName, sen.links, sen.id);\n+                    continue;\n+                }\n                 CoIotDescrBlk element = blockMap.get(sen.links);\n-                logger.debug(\"{}:  Sensor value[{}]: Index={}, Value={} ({}, Type={}, Range={}, Link={}: {})\",\n-                        thingName, i, s.index, s.value, sen.desc, sen.type, sen.range, sen.links,\n-                        element != null ? element.desc : \"n/a\");\n+                logger.trace(\"{}:  Sensor value[{}]: id={}, Value={} ({}, Type={}, Range={}, Link={}: {})\", thingName,\n+                        i, s.id, s.value, sen.desc, sen.type, sen.range, sen.links, element.desc);\n \n                 // Process status information and convert into channel updates\n-                String type = (element != null ? element.desc : \"\").toLowerCase();\n                 Integer rIndex = Integer.parseInt(sen.links) + 1;\n                 String rGroup = profile.numRelays <= 1 ? CHANNEL_GROUP_RELAY_CONTROL\n                         : CHANNEL_GROUP_RELAY_CONTROL + rIndex;\n \n-                switch (sen.type.toLowerCase()) /* CoIoT_STypes.valueOf(sen.T) */ {\n+                switch (sen.type.toLowerCase()) {\n                     case \"b\" /* BatteryLevel */:\n                         updateChannel(updates, CHANNEL_GROUP_BATTERY, CHANNEL_SENSOR_BAT_LEVEL,\n                                 toQuantityType(s.value, DIGITS_PERCENT, SmartHomeUnits.PERCENT));\n                         break;\n                     case \"t\" /* Temperature */:\n-                        updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n-                                toQuantityType(s.value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                        Double value = getDouble(s.value);\n+                        switch (sen.desc.toLowerCase()) {\n+                            case \"temperature\": // Sensor Temp\n+                                if (getString(profile.settings.temperatureUnits)\n+                                        .equalsIgnoreCase(SHELLY_TEMP_FAHRENHEIT)) {\n+                                    value = ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS)\n+                                            .convert(getDouble(s.value)).doubleValue();\n+                                }\n+                                updateChannel(updates, CHANNEL_GROUP_SENSOR, CHANNEL_SENSOR_TEMP,\n+                                        toQuantityType(value, DIGITS_TEMP, SIUnits.CELSIUS));\n+                                break;\n+                            case \"temperature f\": // Device Temp -> ignore (we use C only)\n+                                break;\n+                            case \"temperature c\": // Device Tem\u00fc in C\n+                                // Device temperature\n+                                updateChannel(updates, CHANNEL_GROUP_DEV_STATUS, CHANNEL_DEVST_ITEMP,\n+                                        toQuantityType(value, DIGITS_NONE, SIUnits.CELSIUS));\n+                                break;\n+                            case \"external temperature f\": // Shelly 1/1PM externa\u00f6 temp sensors\n+                                // ignore F, we use C only\n+                                break;\n+                            case \"external temperature c\": // Shelly 1/1PM externa\u00f6 temp sensors", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1Njc0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410656743", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-04-18T06:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyOTUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTE4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410431181", "bodyText": "shouldn't this be synchronized too?", "author": "cpmeister", "createdAt": "2020-04-17T19:37:57Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/coap/ShellyCoapServer.java", "diffHunk": "@@ -140,20 +122,25 @@ public CoapEndpoint getEndpoint() {\n     /**\n      * Cancel pending requests and shutdown the client\n      */\n-    @SuppressWarnings(\"null\")\n-    public void stop() {\n+    public void stop(ShellyCoapListener listener) {\n+        coapListeners.remove(listener);\n+        if (coapListeners.isEmpty()) {\n+            stop();\n+        }\n+    }\n+\n+    private void stop() {", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1Nzg5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410657897", "bodyText": "I added synchronized to addSensor() and stop()", "author": "markus7017", "createdAt": "2020-04-18T06:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMDIxMA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410710210", "bodyText": "You made start() synchronized which doesn't set the started field to true until the very end. But in this stop() method you are checking it at the very start, unsychronized. What I'm worried about is if start() and stop() are called concurrently that your stop() will exit early thinking that things aren't started when in fact the start() method simply has finished executing yet. Making the stop() method synchronized would prevent this from happening.", "author": "cpmeister", "createdAt": "2020-04-18T15:12:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxMDU5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410710596", "bodyText": "Also, shouldn't this method set started to false?", "author": "cpmeister", "createdAt": "2020-04-18T15:15:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0ODUxNA==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410748514", "bodyText": "done", "author": "markus7017", "createdAt": "2020-04-18T20:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMTE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMjc2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410432765", "bodyText": "You shouldn't log this, thing status changes are already logged for you.", "author": "cpmeister", "createdAt": "2020-04-17T19:41:21Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/handler/ShellyBaseHandler.java", "diffHunk": "@@ -350,100 +360,113 @@ protected void updateStatus() {\n                 ShellySettingsStatus status = api.getStatus();\n \n                 // If status update was successful the thing must be online\n-                if (getThing().getStatus() != ThingStatus.ONLINE) {\n-                    logger.debug(\"{}: Thing {} is now online\", thingName, getThing().getLabel());\n-                    updateStatus(ThingStatus.ONLINE); // if API call was successful the thing must be online\n-                }\n+                setThingOnline();\n \n                 // map status to channels\n                 updated |= updateDeviceStatus(status);\n+                updated |= ShellyComponents.updateDeviceStatus(this, status);\n                 updated |= ShellyComponents.updateMeters(this, status);\n                 updated |= ShellyComponents.updateSensors(this, status);\n \n+                // All channels must be created after the first cycle\n+                channelsCreated = true;\n+\n                 if (scheduledUpdates <= 1) {\n                     fillDeviceStatus(status, updated);\n                 }\n             }\n-        } catch (IOException e) {\n+        } catch (ShellyApiException e) {\n             // http call failed: go offline except for battery devices, which might be in\n             // sleep mode. Once the next update is successful the device goes back online\n             String status = \"\";\n-            if (e.getMessage().contains(\"Timeout\")) {\n-                logger.debug(\"{}: Device is not reachable, update canceled ({} skips, {} scheduledUpdates)!\", thingName,\n-                        skipCount, scheduledUpdates);\n-                status = \"@text/offline.status-error-timeout\";\n-            } else if (e.getMessage().contains(APIERR_HTTP_401_UNAUTHORIZED)) {\n-                logger.debug(\"{}: Unable to access device, check credentials!\", thingName);\n-                status = \"@text/offline.conf-error-access-denied\";\n-            } else if (e.getMessage().contains(\"Not calibrated!\")) {\n-                logger.debug(\"{}: Roller is not calibrated! Use the Shelly App or Web UI to run calibration.\",\n-                        thingName);\n-                status = \"@text/offline.conf-error-not-calibrated\";\n+            ShellyApiResult res = e.getApiResult();\n+            if (e.isTimeout()) {\n+                logger.debug(\"{}: Ignore API Timeout, retry later\", thingName);\n+                // next release will implement a watchdog here\n+                // status = \"offline.status-error-timeout\";\n+            } else if (res.isHttpAccessUnauthorized()) {\n+                status = \"offline.conf-error-access-denied\";\n+            } else if (e.IsJSONException()) {\n+                status = \"offline.status-error-unexpected-api-result\";\n+                logger.debug(\"{}: Unable to parse API response: {}; json={}\", thingName, res.getUrl(), res.response, e);\n             } else {\n-                logger.debug(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n-                status = \"@text/offline.status-error-unexpected-api-result\";\n+                status = \"offline.status-error-unexpected-api-result\";\n+                logger.debug(\"{}: Unexpected API result: {}\", thingName, res.response, e);\n             }\n-            if (!status.isEmpty() || (profile != null && !profile.isSensor)) {\n-                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, status);\n+\n+            if (!status.isEmpty()) {\n+                setThingOffline(ThingStatusDetail.COMMUNICATION_ERROR, status);\n             }\n-        } catch (NullPointerException e) {\n-            logger.warn(\"{}: Unable to update status: {} ({})\", thingName, e.getMessage(), e.getClass());\n+        } catch (IllegalArgumentException | NullPointerException e) {\n+            logger.debug(\"{}: Unable to refresh status: {}\", thingName, messages.get(\"statusupdate.failed\"), e);\n         } finally {\n             if (scheduledUpdates > 0) {\n                 --scheduledUpdates;\n-                logger.debug(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n-            }\n-            if ((skipUpdate >= cacheCount) && !channelCache) {\n+                logger.trace(\"{}: {} more updates requested\", thingName, scheduledUpdates);\n+            } else if ((skipUpdate >= cacheCount) && !cache.isEnabled()) {\n                 logger.debug(\"{}: Enabling channel cache ({} updates / {}s)\", thingName, skipUpdate,\n                         cacheCount * UPDATE_STATUS_INTERVAL_SECONDS);\n-                channelCache = true;\n+                cache.enable();\n             }\n         }\n+    }\n+\n+    public boolean isThingOnline() {\n+        return getThing().getStatus() == ThingStatus.ONLINE;\n+    }\n+\n+    public boolean isThingOffline() {\n+        return getThing().getStatus() == ThingStatus.OFFLINE;\n+    }\n+\n+    public void setThingOnline() {\n+        if (!isThingOnline()) {\n+            updateStatus(ThingStatus.ONLINE);\n \n+            // request 3 updates in a row (during the first 2+3*3 sec)\n+            requestUpdates(!profile.hasBattery ? 3 : 1, channelsCreated == false);\n+        }\n+    }\n+\n+    public void setThingOffline(ThingStatusDetail detail, String messageKey) {\n+        if (!isThingOffline()) {\n+            logger.info(\"{}: Thing goes OFFLINE: {}\", thingName, messages.get(messageKey));", "originalCommit": "0f8b13e2ef4c7b4ec0f58a02905581c384709218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY1Njk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410656957", "bodyText": "I need the thingName, this provides an easy way to extract messages relevant for one thing from the big openhab.log", "author": "markus7017", "createdAt": "2020-04-18T06:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzMjc2NQ=="}], "type": "inlineReview"}, {"oid": "a01f1148c8e74a4abcc1b7036224da00db917577", "url": "https://github.com/openhab/openhab-addons/commit/a01f1148c8e74a4abcc1b7036224da00db917577", "message": "More changes from review (functional change to version detection and\nsetting action urls)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-04-18T08:29:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwODg2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410708866", "bodyText": "You forgot to change this\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                return;\n          \n          \n            \n                                continue;", "author": "cpmeister", "createdAt": "2020-04-18T15:02:23Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,210 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(config.eventsSensorReport, SHELLY_EVENT_SENSORREPORT, SHELLY_EVENT_DARK, SHELLY_EVENT_TWILIGHT,\n+                    SHELLY_EVENT_FLOOD_DETECTED, SHELLY_EVENT_FLOOD_GONE, SHELLY_EVENT_CLOSE, SHELLY_EVENT_VIBRATION);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n-            }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, config.eventsRoller, SHELLY_EVENT_ROLLER_OPEN, SHELLY_EVENT_ROLLER_CLOSE,\n+                    SHELLY_EVENT_ROLLER_STOP);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsButton, SHELLY_EVENT_BTN1_ON, SHELLY_EVENT_BTN1_OFF,\n+                    SHELLY_EVENT_BTN2_ON, SHELLY_EVENT_BTN2_OFF);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH1, SHELLY_EVENT_LONGPUSH1,\n+                    SHELLY_EVENT_SHORTPUSH2, SHELLY_EVENT_LONGPUSH2);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, short/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsButton, SHELLY_EVENT_BTN_ON, SHELLY_EVENT_BTN_OFF);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH, SHELLY_EVENT_LONGPUSH);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.isLight) {\n+            // Duo, Bulb\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        }\n+    }\n+\n+    private void setEventUrl(boolean enabled, String... eventTypes) throws ShellyApiException {\n+        for (String eventType : eventTypes) {\n+            if (profile.containsEventUrl(eventType)) {\n+                // Sensors add the type=xx to report_url themself, so we need to ommit here\n+                String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+                String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                        + profile.thingName + \"/\" + eventType + urlParm;\n+                String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+                String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+                if (!enabled && !profile.settingsJson.contains(test)) {\n+                    // Don't set URL to null when the current one doesn't point to this OH\n+                    // Don't interfere with a 3rd party App\n+                    return;", "originalCommit": "a01f1148c8e74a4abcc1b7036224da00db917577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxOTMxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410719315", "bodyText": "good catch, thanks", "author": "markus7017", "createdAt": "2020-04-18T16:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwODg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwOTAxMg==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410709012", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    return;\n          \n          \n            \n                                    continue;", "author": "cpmeister", "createdAt": "2020-04-18T15:03:17Z", "path": "bundles/org.openhab.binding.shelly/src/main/java/org/openhab/binding/shelly/internal/api/ShellyHttpApi.java", "diffHunk": "@@ -379,154 +348,210 @@ private void setRelayEvents() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setDimmerEvents() throws IOException {\n-        Validate.notNull(profile);\n+    private void setDimmerEvents() throws ShellyApiException {\n         if (profile.settings.dimmers != null) {\n             for (int i = 0; i < profile.settings.dimmers.size(); i++) {\n                 setEventUrls(i);\n             }\n+        } else if (profile.isLight) {\n+            setEventUrls(0);\n         }\n     }\n \n     /**\n-     * Set event URL for HT (report_url)\n+     * Set sensor Action URLs\n      *\n-     * @param deviceName\n-     * @throws IOException\n+     * @throws ShellyApiException\n      */\n-    @SuppressWarnings(\"null\")\n-    private void setSensorEventUrls() throws IOException {\n-        Validate.notNull(profile);\n-        if (profile.supportsSensorUrls && config.eventsSensorReport) {\n-            logger.debug(\"Check/set Sensor Reporting URL\");\n-            String eventUrl = \"http://\" + config.localIp + \":\" + config.httpPort.toString() + SHELLY_CALLBACK_URI + \"/\"\n-                    + profile.thingName + \"/\" + EVENT_TYPE_SENSORDATA;\n-            request(SHELLY_URL_SETTINGS + \"?\" + SHELLY_API_EVENTURL_REPORT + \"=\" + urlEncode(eventUrl));\n+    private void setSensorEventUrls() throws ShellyApiException, ShellyApiException {\n+        if (profile.isSensor) {\n+            logger.debug(\"{}: Set Sensor Reporting URL\", thingName);\n+            setEventUrl(config.eventsSensorReport, SHELLY_EVENT_SENSORREPORT, SHELLY_EVENT_DARK, SHELLY_EVENT_TWILIGHT,\n+                    SHELLY_EVENT_FLOOD_DETECTED, SHELLY_EVENT_FLOOD_GONE, SHELLY_EVENT_CLOSE, SHELLY_EVENT_VIBRATION);\n         }\n     }\n \n-    @SuppressWarnings(\"null\")\n-    private void setEventUrls(Integer index) throws IOException {\n-        Validate.notNull(profile);\n-        String lip = config.localIp;\n-        String localPort = config.httpPort.toString();\n-        String deviceName = profile.thingName;\n+    /**\n+     * Set/delete Relay/Roller/Dimmer Action URLs\n+     *\n+     * @param index Device Index (0-based)\n+     * @throws ShellyApiException\n+     */\n+    private void setEventUrls(Integer index) throws ShellyApiException {\n         if (profile.isRoller) {\n-            if (profile.supportsRollerUrls) {\n-                logger.debug(\"Set Roller event urls\");\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_OPEN));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_CLOSE));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_ROLLER,\n-                        SHELLY_API_EVENTURL_ROLLER_STOP));\n-            }\n-        } else {\n-            if (profile.supportsButtonUrls && config.eventsButton) {\n-                if (profile.settingsJson.contains(SHELLY_API_EVENTURL_BTN1_ON)) {\n-                    // 2 set of URLs, e.g. Dimmer\n-                    logger.debug(\"Set Dimmer event urls\");\n-\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN1_OFF));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_LIGHT,\n-                            SHELLY_API_EVENTURL_BTN2_OFF));\n-                } else {\n-                    // Standard relays: btn_xxx URLs\n-                    logger.debug(\"Set Relay event urls\");\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_ON));\n-                    request(buildSetEventUrl(lip, localPort, deviceName, index, EVENT_TYPE_RELAY,\n-                            SHELLY_API_EVENTURL_BTN_OFF));\n+            setEventUrl(EVENT_TYPE_ROLLER, 0, config.eventsRoller, SHELLY_EVENT_ROLLER_OPEN, SHELLY_EVENT_ROLLER_CLOSE,\n+                    SHELLY_EVENT_ROLLER_STOP);\n+        } else if (profile.isDimmer) {\n+            // 2 set of URLs\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsButton, SHELLY_EVENT_BTN1_ON, SHELLY_EVENT_BTN1_OFF,\n+                    SHELLY_EVENT_BTN2_ON, SHELLY_EVENT_BTN2_OFF);\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH1, SHELLY_EVENT_LONGPUSH1,\n+                    SHELLY_EVENT_SHORTPUSH2, SHELLY_EVENT_LONGPUSH2);\n+\n+            // Relay output\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.hasRelays) {\n+            // Standard relays: btn_xxx, out_xxx, short/longpush URLs\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsButton, SHELLY_EVENT_BTN_ON, SHELLY_EVENT_BTN_OFF);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsPush, SHELLY_EVENT_SHORTPUSH, SHELLY_EVENT_LONGPUSH);\n+            setEventUrl(EVENT_TYPE_RELAY, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        } else if (profile.isLight) {\n+            // Duo, Bulb\n+            setEventUrl(EVENT_TYPE_LIGHT, index, config.eventsSwitch, SHELLY_EVENT_OUT_ON, SHELLY_EVENT_OUT_OFF);\n+        }\n+    }\n+\n+    private void setEventUrl(boolean enabled, String... eventTypes) throws ShellyApiException {\n+        for (String eventType : eventTypes) {\n+            if (profile.containsEventUrl(eventType)) {\n+                // Sensors add the type=xx to report_url themself, so we need to ommit here\n+                String urlParm = !eventType.equalsIgnoreCase(SHELLY_EVENT_SENSORREPORT) ? \"?type=\" + eventType : \"\";\n+                String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                        + profile.thingName + \"/\" + eventType + urlParm;\n+                String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+                String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + newUrl + \"\\\"\";\n+                if (!enabled && !profile.settingsJson.contains(test)) {\n+                    // Don't set URL to null when the current one doesn't point to this OH\n+                    // Don't interfere with a 3rd party App\n+                    return;\n+                }\n+                if (!profile.settingsJson.contains(test)) {\n+                    // Current Action URL is != new URL\n+                    request(SHELLY_URL_SETTINGS + \"?\" + mkEventUrl(eventType) + \"=\" + urlEncode(newUrl));\n                 }\n             }\n-            if (profile.supportsOutUrls && config.eventsSwitch) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_ON));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_OUT_OFF));\n-            }\n-            if (profile.supportsPushUrls && config.eventsPush) {\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_SHORT_PUSH));\n-                request(buildSetEventUrl(lip, localPort, deviceName, index,\n-                        profile.isDimmer ? EVENT_TYPE_LIGHT : EVENT_TYPE_RELAY, SHELLY_API_EVENTURL_LONG_PUSH));\n+        }\n+    }\n+\n+    private void setEventUrl(String deviceClass, Integer index, boolean enabled, String... eventTypes)\n+            throws ShellyApiException {\n+        for (String eventType : eventTypes) {\n+            if (profile.containsEventUrl(eventType)) {\n+                if (profile.containsEventUrl(eventType)) {\n+                    String callBackUrl = \"http://\" + config.localIp + \":\" + config.localPort + SHELLY_CALLBACK_URI + \"/\"\n+                            + profile.thingName + \"/\" + deviceClass + \"/\" + index + \"?type=\" + eventType;\n+                    String newUrl = enabled ? callBackUrl : SHELLY_NULL_URL;\n+                    String test = \"\\\"\" + mkEventUrl(eventType) + \"\\\":\\\"\" + callBackUrl + \"\\\"\";\n+                    if (!enabled && !profile.settingsJson.contains(test)) {\n+                        // Don't set URL to null when the current one doesn't point to this OH\n+                        // Don't interfere with a 3rd party App\n+                        return;", "originalCommit": "a01f1148c8e74a4abcc1b7036224da00db917577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcxOTMxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6985#discussion_r410719311", "bodyText": "good catch, thanks", "author": "markus7017", "createdAt": "2020-04-18T16:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDcwOTAxMg=="}], "type": "inlineReview"}, {"oid": "91cc31f87382af1c14776d2abb07f329c183d9f6", "url": "https://github.com/openhab/openhab-addons/commit/91cc31f87382af1c14776d2abb07f329c183d9f6", "message": "change fixed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-04-18T16:30:57Z", "type": "commit"}, {"oid": "a60d58e444374efd2752e20d213886e0e50a7330", "url": "https://github.com/openhab/openhab-addons/commit/a60d58e444374efd2752e20d213886e0e50a7330", "message": "synchronize start()\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-04-18T20:31:46Z", "type": "commit"}, {"oid": "a11489005e446da3c7f7886065a3a5d42a4acc72", "url": "https://github.com/openhab/openhab-addons/commit/a11489005e446da3c7f7886065a3a5d42a4acc72", "message": "synchronized added to start/stop\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-04-18T20:45:52Z", "type": "commit"}]}