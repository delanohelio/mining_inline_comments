{"pr_number": 7768, "pr_title": "[tacmi] Initial push of OpenHAB 2 ported tacmi binding", "pr_createdAt": "2020-05-24T10:36:04Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7768", "timeline": [{"oid": "20d8d39df532ff9f8287aa6780f4a38a9fa05389", "url": "https://github.com/openhab/openhab-addons/commit/20d8d39df532ff9f8287aa6780f4a38a9fa05389", "message": "[tacmi] initial WIP-Checkin of the \"Schema API Page\" variant", "committedDate": "2020-08-02T13:57:05Z", "type": "forcePushed"}, {"oid": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "url": "https://github.com/openhab/openhab-addons/commit/066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "message": "[tacmi] added initial documentation for the new API Page thing\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-08-02T18:09:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyNzgwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464627808", "bodyText": "The GitHub user name is not necessary here, as it is contained in CODEOWNERS.", "author": "fwolter", "createdAt": "2020-08-03T19:51:40Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiBindingConstants.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+\n+/**\n+ * The {@link TACmiBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyODk4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464628987", "bodyText": "Annotating inner classes is not necessary. There is a bug in the checkstyle rules, which causes a false positive here.", "author": "fwolter", "createdAt": "2020-08-03T19:54:11Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyOTM0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464629346", "bodyText": "When creating a thread, it should be marked as daemon, to let the JVM exit, even if this thread is still running for some reason: Thread.setDaemon(true)", "author": "fwolter", "createdAt": "2020-08-03T19:54:54Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyOTkwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464629900", "bodyText": "Annotating local variables is not necessary, as the compiler is intelligent enough here.", "author": "fwolter", "createdAt": "2020-08-03T19:56:06Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyOTk4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464629989", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be warn.", "author": "fwolter", "createdAt": "2020-08-03T19:56:20Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMDIyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464630221", "bodyText": "Logging to info should be used rarely. This could be debug or trace. Same for below.", "author": "fwolter", "createdAt": "2020-08-03T19:56:54Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMDMxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464630313", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-08-03T19:57:09Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMDc4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464630780", "bodyText": "Can this message be replaced by using the debugger? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging Same for below", "author": "fwolter", "createdAt": "2020-08-03T19:58:10Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMTM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464631353", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2020-08-03T19:59:30Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMjcyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464632723", "bodyText": "For periodic tasks, the OH scheduler should be used to save resources and for simplicity. See https://www.openhab.org/docs/developer/bindings/#polling-for-a-state", "author": "fwolter", "createdAt": "2020-08-03T20:02:29Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMjgzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464632834", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-08-03T20:02:46Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzMzMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464633314", "bodyText": "You could remove this log message, as it's already logged by the framework via updateStatus().", "author": "fwolter", "createdAt": "2020-08-03T20:03:57Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            logger.error(\"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: {}\", e.getMessage());", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNDQzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464634434", "bodyText": "I can't find this issue. Can you provide a link?", "author": "fwolter", "createdAt": "2020-08-03T20:06:16Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            logger.error(\"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        // workaround for issue #92: getHandler() returns NULL after\n+        // configuration update. :", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI3MjIzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r465272233", "bodyText": "currently I'm not sure where this comment is from. I might have it copied accidentally with some other code. Maybe we just drop it.", "author": "marvkis", "createdAt": "2020-08-04T19:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNDQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNDY5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464634697", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-08-03T20:06:50Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            logger.error(\"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        // workaround for issue #92: getHandler() returns NULL after\n+        // configuration update. :\n+        getThing().setHandler(this);\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread();\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        MonitorThread monitorNN = new MonitorThread();\n+        monitorNN.start();\n+        this.monitor = monitorNN;\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            logger.debug(\"Refresh command received.\");\n+            /*\n+             * for (Device device : devices) device.refreshStatus();\n+             */", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNDg0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464634842", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-08-03T20:07:10Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            logger.error(\"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        // workaround for issue #92: getHandler() returns NULL after\n+        // configuration update. :\n+        getThing().setHandler(this);\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread();\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        MonitorThread monitorNN = new MonitorThread();\n+        monitorNN.start();\n+        this.monitor = monitorNN;\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            logger.debug(\"Refresh command received.\");\n+            /*\n+             * for (Device device : devices) device.refreshStatus();\n+             */\n+            for (final TACmiHandler cmi : registeredCMIs) {\n+                cmi.handleCommand(channelUID, command);\n+            }\n+        } else {\n+            logger.warn(\"No bridge commands defined.\");\n+        }\n+    }\n+\n+    protected void registerCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.add(handler);\n+    }\n+\n+    protected void unregisterCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.remove(handler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Handler disposed.\");", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNTI0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464635247", "bodyText": "You might want to specify a timeout as a parameter to join(), in case the thread blocks for some reason.", "author": "fwolter", "createdAt": "2020-08-03T20:08:05Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable MonitorThread monitor;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    @NonNullByDefault\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                @Nullable\n+                final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+                if (coeSocket == null) {\n+                    logger.error(\"coeSocket is NULL - Reader disabled!\");\n+                    return;\n+                }\n+                while (!isInterrupted()) {\n+                    final byte[] receiveData = new byte[14];\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.info(\"Receive timeout on CoE socket, retrying ...\");\n+                        // updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        // \"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    try {\n+                        final byte[] data = receivePacket.getData();\n+                        Message message;\n+                        if (data[1] > 0 && data[1] < 9) {\n+                            logger.debug(\"Processing analog message\");\n+                            message = new AnalogMessage(data);\n+                        } else if (data[1] == 0 || data[1] == 9) {\n+                            logger.debug(\"Processing digital message\");\n+                            message = new DigitalMessage(data);\n+                        } else {\n+                            logger.debug(\"Invalid message received\");\n+                            continue;\n+                        }\n+                        logger.debug(\"{}\", message.toString());\n+\n+                        final InetAddress remoteAddress = receivePacket.getAddress();\n+                        final int node = message.canNode;\n+                        boolean found = false;\n+                        for (final TACmiHandler cmi : registeredCMIs) {\n+                            if (cmi.isFor(remoteAddress, node)) {\n+                                cmi.handleCoE(message);\n+                                found = true;\n+                            }\n+                        }\n+                        if (!found)\n+                            logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                    remoteAddress, node);\n+                    } catch (final Exception t) {\n+                        logger.error(\"Error processing data: {}\", t.getMessage(), t);\n+                    }\n+                }\n+                logger.debug(\"ReceiveThread exiting.\");\n+            } catch (final Exception t) {\n+                if (isInterrupted())\n+                    return;\n+                logger.error(\"Fatal error processing data: {}\", t.getMessage(), t);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Error processing data: \" + t.getMessage());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Thread which periodically polls status of the bridge.\n+     */\n+    @NonNullByDefault\n+    private class MonitorThread extends Thread {\n+\n+        MonitorThread() {\n+            super(\"tacmi TA C.M.I. CoE MonitorThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!isInterrupted()) {\n+                try {\n+                    synchronized (this) {\n+                        this.wait(1000);\n+                    }\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        cmi.monitor();\n+                    }\n+                } catch (final InterruptedException e) {\n+                    // we got interrupted\n+                    break;\n+                }\n+            }\n+            logger.debug(\"MonitorThread exiting.\");\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing TA C.M.I. CoE bridge handler\");\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            logger.error(\"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: {}\", e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        // workaround for issue #92: getHandler() returns NULL after\n+        // configuration update. :\n+        getThing().setHandler(this);\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread();\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        MonitorThread monitorNN = new MonitorThread();\n+        monitorNN.start();\n+        this.monitor = monitorNN;\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            logger.debug(\"Refresh command received.\");\n+            /*\n+             * for (Device device : devices) device.refreshStatus();\n+             */\n+            for (final TACmiHandler cmi : registeredCMIs) {\n+                cmi.handleCommand(channelUID, command);\n+            }\n+        } else {\n+            logger.warn(\"No bridge commands defined.\");\n+        }\n+    }\n+\n+    protected void registerCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.add(handler);\n+    }\n+\n+    protected void unregisterCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.remove(handler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Handler disposed.\");\n+        @Nullable\n+        MonitorThread monitor = this.monitor;\n+        if (monitor != null) {\n+            monitor.interrupt();\n+            try {\n+                monitor.join();\n+            } catch (final InterruptedException e) {\n+                logger.info(\"Unexpected interrupt in monitor.join(): {}\", e.getMessage(), e);\n+            }\n+            this.monitor = null;\n+        }\n+        @Nullable\n+        ReceiveThread receiveThread = this.receiveThread;\n+        if (receiveThread != null)\n+            receiveThread.interrupt(); // just interrupt it so when the socketException throws it's flagged as\n+                                       // interrupted.\n+\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock != null && !sock.isClosed()) {\n+            sock.close();\n+            this.coeSocket = null;\n+        }\n+        if (receiveThread != null) {\n+            receiveThread.interrupt();\n+            try {\n+                receiveThread.join();", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNTkyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464635923", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-08-03T20:09:30Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNjIxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464636216", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-08-03T20:10:05Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNjMzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464636337", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-08-03T20:10:20Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNjY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464636683", "bodyText": "initialize() should return fast. You can do this in a OH scheduler task. See above.", "author": "fwolter", "createdAt": "2020-08-03T20:11:06Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNjk5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464636999", "bodyText": "See above. Same for the others.", "author": "fwolter", "createdAt": "2020-08-03T20:11:48Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzNzE3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464637173", "bodyText": "See above. Same for the others.", "author": "fwolter", "createdAt": "2020-08-03T20:12:11Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODAzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464638030", "bodyText": "What's your intention by storing the cache on disk and not in RAM? As many OH instances run on raspberrys with SD cards, this could impact the flash's lifetime. OH provides classes to store cache in RAM.", "author": "fwolter", "createdAt": "2020-08-03T20:14:18Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MzAyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r465283028", "bodyText": "I tried to solve a 'startup' gap between the two architectures of OH and the TA System: TA transfers always a set of 4 or 16 channel states (depending weather we have analog values or switch states) in one message, so the binding has to have the states of the 'neighboring' channels available when one channel gets updated. Is there an other way to restore / read 'previous' values during startup?", "author": "marvkis", "createdAt": "2020-08-04T19:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzODY1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r466638656", "bodyText": "I'm not aware any binding stores the state of its Things persistently on disk. Isn't the state of the Things outdated if OH has been switched off for some time?\nThe normal way is to react to a RefreshType command. This will be issued on startup by the OH core to the binding, to signal the binding it should poll the current state from its Things.", "author": "fwolter", "createdAt": "2020-08-06T19:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzAyNjAyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r467026027", "bodyText": "Hi,\nOkay, it might be good to explain my whole user-story to get a better idea why i persisted the data.\nFirst of all, we have two flow directions for data: One that delivers data from TA -> OH, and one that sends data from OH to TA.\nIn my scenario I need the direction OH -> TA:\nI have some old 'legacy' hardware/equipment in my heating system that is connected to OH. So OH knows states that need to be delivered to the TA system, as the TA hast to work with it. Also the old 'legacy' stuff doesn't have possibility to poll states, I have to wait for them to be updated. There are values that are updated very frequently (on a per-second basis) but others are only updated every 15 minutes.\nIn OH I've configured MAPDB as persistence service, so after a restart it comes up with the last values. That's fine.\nIn OH there are also rules for each of the required 'legacy' item that whenever it gets updated/changed, the new value is sent to the TA output channel. This also works as expected.\nThe problem is the way the values have to be transferred to the TA:\nEvery time a value is transferred to the TA, there package will include at least 4 values. So I also have to send the current / last values from the 3 neighboring channels. The plugin saves the last values from the neighboring things, as long as there is a value.\nAnd now the problem is: the incoming values have very different update intervals. Some values are updated quite often, others not - but when I want to send an Update to TA for the frequent channel I also have to send the values of the non-so-frequent values. So I have to find a solution to get the current / last values of these neighboring channels. Even if the last known value is a bit older it usually is much better then sending just 0 to the TA is it would cause totally wrong assumptions / calculations on the TA site.\nSo what I need here during startup of the plugin is to find a way to get some useful initial state - either the last values known (why i'm currently persisting it) or to read the current value of the linked 'item' from OH. Like the RefreshType, but the other way around - the binding sens a RefreshType to the OH Core to get the last known value from the linked Item. Is there such a mechanism available? Or any other hint?", "author": "marvkis", "createdAt": "2020-08-07T13:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA1Mjc5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r467052797", "bodyText": "I understood that legacy values cannot be polled and you cannot set single values, but must update several values at once. And you don't know the states of the other values after OH started.\nI'm sorry for this design and I understand why you chose persisting the values. Unfortunately I don't have any better idea at the moment...\nIn the last paragraph, I guess you refer to using mapdb. Honestly I'm not sure if you can get access from within a binding to mapdb. If so, that would be a nicer way, instead introducing a custom persistence. However, it might be a good idea to continue this discussion in the development forum.", "author": "fwolter", "createdAt": "2020-08-07T13:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzODAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTk3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464639976", "bodyText": "Can you cache received values and provide those?", "author": "fwolter", "createdAt": "2020-08-03T20:18:35Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");\n+    }\n+\n+    private PodData getPodData(final PodIdentifier pi) {\n+        PodData pd = this.podDatas.get(pi);\n+        if (pd == null) {\n+            pd = new PodData(pi.podId, pi.messageType);\n+            if (pi.outgoing) {\n+                pd.message = pd.messageType == MessageType.A ? new AnalogMessage((byte) this.node, pi.podId)\n+                        : new DigitalMessage((byte) this.node, pi.podId);\n+            }\n+            this.podDatas.put(pi, pd);\n+        }\n+        return pd;\n+    }\n+\n+    private byte getPodId(final MessageType messageType, final int output) {\n+        assert output >= 1 && output <= 32; // range 1-32\n+        // pod ID's: 0 & 9 for digital states, 1-8 for analog values\n+        if (messageType == MessageType.A)\n+            return (byte) (((output - 1) / 4) + 1);\n+        return (byte) (((output - 1) / 16) == 0 ? 0 : 9);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // this is not supported - we cannot pull states...", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4NDgxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r465284812", "bodyText": "Yes, this would be possible. But from my observations theses Refresh-Messages only occur during startup when we don't have data received from the TA equipment. TA only sends data periodically or on change, but there is no known way of polling current values.", "author": "marvkis", "createdAt": "2020-08-04T19:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYzOTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTI2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464641265", "bodyText": "Can you use speaking variable names when using them over a larger amount of code lines?", "author": "fwolter", "createdAt": "2020-08-03T20:21:25Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");\n+    }\n+\n+    private PodData getPodData(final PodIdentifier pi) {\n+        PodData pd = this.podDatas.get(pi);\n+        if (pd == null) {\n+            pd = new PodData(pi.podId, pi.messageType);\n+            if (pi.outgoing) {\n+                pd.message = pd.messageType == MessageType.A ? new AnalogMessage((byte) this.node, pi.podId)\n+                        : new DigitalMessage((byte) this.node, pi.podId);\n+            }\n+            this.podDatas.put(pi, pd);\n+        }\n+        return pd;\n+    }\n+\n+    private byte getPodId(final MessageType messageType, final int output) {\n+        assert output >= 1 && output <= 32; // range 1-32\n+        // pod ID's: 0 & 9 for digital states, 1-8 for analog values\n+        if (messageType == MessageType.A)\n+            return (byte) (((output - 1) / 4) + 1);\n+        return (byte) (((output - 1) / 16) == 0 ? 0 : 9);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // this is not supported - we cannot pull states...\n+            return;\n+        }\n+        final TACmiChannelConfiguration cc = this.channelConfigByUID.get(channelUID);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTc4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464641789", "bodyText": "It seems a bit unreasonable to log the stack trace when the network fails.", "author": "fwolter", "createdAt": "2020-08-03T20:22:32Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");\n+    }\n+\n+    private PodData getPodData(final PodIdentifier pi) {\n+        PodData pd = this.podDatas.get(pi);\n+        if (pd == null) {\n+            pd = new PodData(pi.podId, pi.messageType);\n+            if (pi.outgoing) {\n+                pd.message = pd.messageType == MessageType.A ? new AnalogMessage((byte) this.node, pi.podId)\n+                        : new DigitalMessage((byte) this.node, pi.podId);\n+            }\n+            this.podDatas.put(pi, pd);\n+        }\n+        return pd;\n+    }\n+\n+    private byte getPodId(final MessageType messageType, final int output) {\n+        assert output >= 1 && output <= 32; // range 1-32\n+        // pod ID's: 0 & 9 for digital states, 1-8 for analog values\n+        if (messageType == MessageType.A)\n+            return (byte) (((output - 1) / 4) + 1);\n+        return (byte) (((output - 1) / 16) == 0 ? 0 : 9);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // this is not supported - we cannot pull states...\n+            return;\n+        }\n+        final TACmiChannelConfiguration cc = this.channelConfigByUID.get(channelUID);\n+        if (cc == null) {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+        final Channel channel = thing.getChannel(channelUID);\n+        if (channel == null)\n+            return;\n+        MessageType mt;\n+        if ((TACmiBindingConstants.CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.D;\n+        } else if ((TACmiBindingConstants.CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.A;\n+        } else {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+\n+        final byte podId = getPodId(mt, cc.output);\n+        PodData pd = getPodData(new PodIdentifier(mt, podId, true));\n+        @Nullable\n+        Message message = pd.message;\n+        if (message == null) {\n+            logger.error(\"Internal error - BUG - no outgoing message for command '{}' on Channel {} \", command,\n+                    channelUID);\n+            return;\n+        }\n+        boolean modified;\n+        switch (mt) {\n+            case D:\n+                final boolean state = OnOffType.ON.equals(command) ? true : false;\n+                modified = ((DigitalMessage) message).setPortState((cc.output - 1) % 16, state);\n+                break;\n+            case A:\n+                final TACmiMeasureType measureType = TACmiMeasureType\n+                        .values()[((TACmiChannelConfigurationAnalog) cc).type];\n+                final DecimalType dt = (DecimalType) command;\n+                final double val = dt.doubleValue() * measureType.getOffset();\n+                modified = message.setValue((cc.output - 1) % 4, (short) val, measureType.ordinal());\n+                break;\n+            default:\n+                logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+                return;\n+        }\n+        if (modified) {\n+            pd.dirty = true; // flag as dirty\n+            try {\n+                @Nullable\n+                final TACmiCoEBridgeHandler br = this.bridge;\n+                @Nullable\n+                final InetAddress cmia = this.cmiAddress;\n+                if (br != null && cmia != null) {\n+                    br.sendData(message.getRaw(), cmia);\n+                    pd.lastSent = System.currentTimeMillis();\n+                }\n+                // we also update the local state after we successfully sent out the command\n+                updateState(channel.getUID(), (State) command);\n+            } catch (final IOException e) {\n+                logger.warn(\"Error sending message: {}: {}\", e.getClass().getName(), e.getMessage(), e);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MTk5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464641995", "bodyText": "Super destructors should be called at the end of the concrete destructor.", "author": "fwolter", "createdAt": "2020-08-03T20:22:57Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");\n+    }\n+\n+    private PodData getPodData(final PodIdentifier pi) {\n+        PodData pd = this.podDatas.get(pi);\n+        if (pd == null) {\n+            pd = new PodData(pi.podId, pi.messageType);\n+            if (pi.outgoing) {\n+                pd.message = pd.messageType == MessageType.A ? new AnalogMessage((byte) this.node, pi.podId)\n+                        : new DigitalMessage((byte) this.node, pi.podId);\n+            }\n+            this.podDatas.put(pi, pd);\n+        }\n+        return pd;\n+    }\n+\n+    private byte getPodId(final MessageType messageType, final int output) {\n+        assert output >= 1 && output <= 32; // range 1-32\n+        // pod ID's: 0 & 9 for digital states, 1-8 for analog values\n+        if (messageType == MessageType.A)\n+            return (byte) (((output - 1) / 4) + 1);\n+        return (byte) (((output - 1) / 16) == 0 ? 0 : 9);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // this is not supported - we cannot pull states...\n+            return;\n+        }\n+        final TACmiChannelConfiguration cc = this.channelConfigByUID.get(channelUID);\n+        if (cc == null) {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+        final Channel channel = thing.getChannel(channelUID);\n+        if (channel == null)\n+            return;\n+        MessageType mt;\n+        if ((TACmiBindingConstants.CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.D;\n+        } else if ((TACmiBindingConstants.CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.A;\n+        } else {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+\n+        final byte podId = getPodId(mt, cc.output);\n+        PodData pd = getPodData(new PodIdentifier(mt, podId, true));\n+        @Nullable\n+        Message message = pd.message;\n+        if (message == null) {\n+            logger.error(\"Internal error - BUG - no outgoing message for command '{}' on Channel {} \", command,\n+                    channelUID);\n+            return;\n+        }\n+        boolean modified;\n+        switch (mt) {\n+            case D:\n+                final boolean state = OnOffType.ON.equals(command) ? true : false;\n+                modified = ((DigitalMessage) message).setPortState((cc.output - 1) % 16, state);\n+                break;\n+            case A:\n+                final TACmiMeasureType measureType = TACmiMeasureType\n+                        .values()[((TACmiChannelConfigurationAnalog) cc).type];\n+                final DecimalType dt = (DecimalType) command;\n+                final double val = dt.doubleValue() * measureType.getOffset();\n+                modified = message.setValue((cc.output - 1) % 4, (short) val, measureType.ordinal());\n+                break;\n+            default:\n+                logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+                return;\n+        }\n+        if (modified) {\n+            pd.dirty = true; // flag as dirty\n+            try {\n+                @Nullable\n+                final TACmiCoEBridgeHandler br = this.bridge;\n+                @Nullable\n+                final InetAddress cmia = this.cmiAddress;\n+                if (br != null && cmia != null) {\n+                    br.sendData(message.getRaw(), cmia);\n+                    pd.lastSent = System.currentTimeMillis();\n+                }\n+                // we also update the local state after we successfully sent out the command\n+                updateState(channel.getUID(), (State) command);\n+            } catch (final IOException e) {\n+                logger.warn(\"Error sending message: {}: {}\", e.getClass().getName(), e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MjY2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464642669", "bodyText": "See above.", "author": "fwolter", "createdAt": "2020-08-03T20:24:25Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,337 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.openhab.binding.tacmi.internal.podData.PodData;\n+import org.openhab.binding.tacmi.internal.podData.PodIdentifier;\n+import org.openhab.binding.tacmi.internal.stateCache.StateCacheUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final String STATE_CACHE_BASE = ConfigConstants.getUserDataFolder() + File.separator\n+            + TACmiBindingConstants.BINDING_ID + File.separator;\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    // state persistance (requred as multiple states are sent at once so we need all\n+    // current states after startup)\n+    private @Nullable StateCacheUtils stateCacheUtils;\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            logger.error(\"Failed to get IP of CMI from configuration\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI from configuration\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            try {\n+                final ChannelTypeUID ct = chann.getChannelTypeUID();\n+                final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+                final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+                // for the analog out channel we have the measurement type. for the input\n+                // channel we take it from the C.M.I.\n+                final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                        ? TACmiChannelConfigurationAnalog.class\n+                        : TACmiChannelConfiguration.class;\n+                final TACmiChannelConfiguration cc = chann.getConfiguration().as(ccClass);\n+                this.channelConfigByUID.put(chann.getUID(), cc);\n+                final MessageType messageType = analog ? MessageType.A : MessageType.D;\n+                final byte podId = this.getPodId(messageType, cc.output);\n+                final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+                // initialzie podData\n+                getPodData(pi);\n+            } catch (final Exception e) {\n+                logger.error(\"Failed to collect data for Channel {}: {}\", chann.getUID(), e.getMessage(), e);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Failed to collect data for Channel \" + chann.getUID() + \": \" + e.getMessage());\n+                return;\n+            }\n+\n+        }\n+\n+        // this automatically restores persisted states...\n+        this.stateCacheUtils = new StateCacheUtils(\n+                new File(STATE_CACHE_BASE + getThing().getUID().getAsString().replace(':', '_') + \".json\"),\n+                this.podDatas.values());\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");\n+    }\n+\n+    private PodData getPodData(final PodIdentifier pi) {\n+        PodData pd = this.podDatas.get(pi);\n+        if (pd == null) {\n+            pd = new PodData(pi.podId, pi.messageType);\n+            if (pi.outgoing) {\n+                pd.message = pd.messageType == MessageType.A ? new AnalogMessage((byte) this.node, pi.podId)\n+                        : new DigitalMessage((byte) this.node, pi.podId);\n+            }\n+            this.podDatas.put(pi, pd);\n+        }\n+        return pd;\n+    }\n+\n+    private byte getPodId(final MessageType messageType, final int output) {\n+        assert output >= 1 && output <= 32; // range 1-32\n+        // pod ID's: 0 & 9 for digital states, 1-8 for analog values\n+        if (messageType == MessageType.A)\n+            return (byte) (((output - 1) / 4) + 1);\n+        return (byte) (((output - 1) / 16) == 0 ? 0 : 9);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // this is not supported - we cannot pull states...\n+            return;\n+        }\n+        final TACmiChannelConfiguration cc = this.channelConfigByUID.get(channelUID);\n+        if (cc == null) {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+        final Channel channel = thing.getChannel(channelUID);\n+        if (channel == null)\n+            return;\n+        MessageType mt;\n+        if ((TACmiBindingConstants.CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.D;\n+        } else if ((TACmiBindingConstants.CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(channel.getChannelTypeUID()))) {\n+            mt = MessageType.A;\n+        } else {\n+            logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+            return;\n+        }\n+\n+        final byte podId = getPodId(mt, cc.output);\n+        PodData pd = getPodData(new PodIdentifier(mt, podId, true));\n+        @Nullable\n+        Message message = pd.message;\n+        if (message == null) {\n+            logger.error(\"Internal error - BUG - no outgoing message for command '{}' on Channel {} \", command,\n+                    channelUID);\n+            return;\n+        }\n+        boolean modified;\n+        switch (mt) {\n+            case D:\n+                final boolean state = OnOffType.ON.equals(command) ? true : false;\n+                modified = ((DigitalMessage) message).setPortState((cc.output - 1) % 16, state);\n+                break;\n+            case A:\n+                final TACmiMeasureType measureType = TACmiMeasureType\n+                        .values()[((TACmiChannelConfigurationAnalog) cc).type];\n+                final DecimalType dt = (DecimalType) command;\n+                final double val = dt.doubleValue() * measureType.getOffset();\n+                modified = message.setValue((cc.output - 1) % 4, (short) val, measureType.ordinal());\n+                break;\n+            default:\n+                logger.warn(\"Recived unhandled command '{}' on Channel {} \", command, channelUID);\n+                return;\n+        }\n+        if (modified) {\n+            pd.dirty = true; // flag as dirty\n+            try {\n+                @Nullable\n+                final TACmiCoEBridgeHandler br = this.bridge;\n+                @Nullable\n+                final InetAddress cmia = this.cmiAddress;\n+                if (br != null && cmia != null) {\n+                    br.sendData(message.getRaw(), cmia);\n+                    pd.lastSent = System.currentTimeMillis();\n+                }\n+                // we also update the local state after we successfully sent out the command\n+                updateState(channel.getUID(), (State) command);\n+            } catch (final IOException e) {\n+                logger.warn(\"Error sending message: {}: {}\", e.getClass().getName(), e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        super.dispose();\n+        final TACmiCoEBridgeHandler br = this.bridge;\n+        if (br != null)\n+            br.unregisterCMI(this);\n+        @Nullable\n+        final StateCacheUtils scu = this.stateCacheUtils;\n+        if (scu != null)\n+            scu.persistStates(podDatas.values());\n+    }\n+\n+    public boolean isFor(final InetAddress remoteAddress, final int node) {\n+        @Nullable\n+        final InetAddress cmia = this.cmiAddress;\n+        if (cmia == null)\n+            return false;\n+        return this.node == node && cmia.equals(remoteAddress);\n+    }\n+\n+    public void handleCoE(final Message message) {\n+        final ChannelTypeUID channelType = message.getType() == MessageType.D\n+                ? TACmiBindingConstants.CHANNEL_TYPE_COE_DIGITAL_IN_UID\n+                : TACmiBindingConstants.CHANNEL_TYPE_COE_ANALOG_IN_UID;\n+        if (!this.online) {\n+            updateStatus(ThingStatus.ONLINE);\n+            this.online = true;\n+        }\n+        this.lastMessageRecvTS = System.currentTimeMillis();\n+        for (final Channel channel : thing.getChannels()) {\n+            if (!(channelType.equals(channel.getChannelTypeUID())))\n+                continue;\n+            final int output = ((Number) channel.getConfiguration().get(TACmiBindingConstants.CHANNEL_CONFIG_OUTPUT))\n+                    .intValue();\n+            if (!message.hasPortnumber(output))\n+                continue;\n+\n+            if (message.getType() == MessageType.A) {\n+                final AnalogValue value = ((AnalogMessage) message).getAnalogValue(output);\n+                logger.debug(\"Updating item {} / {} with state {}\", channel.getUID(), channel.getLabel(), value.value);\n+                updateState(channel.getUID(), new DecimalType(value.value));\n+            } else {\n+                final boolean state = ((DigitalMessage) message).getPortState(output);\n+                logger.debug(\"Updating item {} / {} with state {}\", channel.getUID(), channel.getLabel(), state);\n+                updateState(channel.getUID(), state ? OnOffType.ON : OnOffType.OFF);\n+            }\n+        }\n+    }\n+\n+    public void monitor() {\n+        final long refTs = System.currentTimeMillis();\n+        if (online && refTs - this.lastMessageRecvTS > 900000) {\n+            // 30 sec no data - set thing to offline..\n+            this.online = false;\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"No update from C.M.I. for 15 min\");\n+        }\n+        for (final PodData pd : this.podDatas.values()) {\n+            if (pd == null) // Nullable check complains when this is missing...\n+                continue;\n+            @Nullable\n+            Message message = pd.message;\n+            if (message != null && refTs - pd.lastSent > 300000) {\n+                // reset every 300 secs...\n+                try {\n+                    @Nullable\n+                    final TACmiCoEBridgeHandler br = this.bridge;\n+                    @Nullable\n+                    final InetAddress cmia = this.cmiAddress;\n+                    if (br != null && cmia != null) {\n+                        br.sendData(message.getRaw(), cmia);\n+                        pd.lastSent = System.currentTimeMillis();\n+                    }\n+                } catch (final IOException e) {\n+                    logger.warn(\"Error sending message: {}: {}\", e.getClass().getName(), e.getMessage(), e);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Mjk5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464642997", "bodyText": "Since we want to get rid of Apache Commons, can you replace this with native Java code? See #7722.", "author": "fwolter", "createdAt": "2020-08-03T20:25:05Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiMeasureType.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This enum holds all the different measures and states available to be\n+ * retrieved by the TACmi binding, including the scale factors needed to convert the received values to the real\n+ * numbers.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Wolfgang Klimt - improvements\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+public enum TACmiMeasureType {\n+    NONE(0, 1),\n+    TEMPERATURE(1, 10),\n+    UNKNOWN2(2, 1),\n+    UNKNOWN3(3, 1),\n+    SECONDS(4, 1),\n+    UNKNOWN5(5, 1),\n+    UNKNOWN6(6, 1),\n+    UNKNOWN7(7, 1),\n+    UNKNOWN8(8, 1),\n+    UNKNOWN9(9, 1),\n+    KILOWATT(10, 100),\n+    KILOWATTHOURS(11, 10),\n+    MEGAWATTHOURS(12, 1),\n+    UNKNOWN13(13, 1),\n+    UNKNOWN14(14, 1),\n+    UNKNOWN15(15, 1),\n+    UNKNOWN16(16, 1),\n+    UNKNOWN17(17, 1),\n+    UNKNOWN18(18, 1),\n+    UNKNOWN19(19, 1),\n+    UNKNOWN20(20, 1),\n+    UNKNOWN21(21, 1),\n+\n+    UNSUPPORTED(-1, 1);\n+\n+    private int typeval;\n+    private int offset;\n+\n+    private static final Logger logger = LoggerFactory.getLogger(TACmiMeasureType.class);\n+\n+    private TACmiMeasureType(int typeval, int offset) {\n+        this.typeval = typeval;\n+        this.offset = offset;\n+    }\n+\n+    public int getTypeValue() {\n+        return typeval;\n+    }\n+\n+    public int getOffset() {\n+        return offset;\n+    }\n+\n+    /**\n+     * Return the measure type for the specified name.\n+     *\n+     * @param measure\n+     * @return\n+     */\n+    public static TACmiMeasureType fromString(String measure) {\n+        if (!StringUtils.isEmpty(measure)) {", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0MzQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464643419", "bodyText": "Is there a reason why the authors in this class are listed twice?", "author": "fwolter", "createdAt": "2020-08-03T20:26:00Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/AnalogMessage.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+\n+/**\n+ * Format of analog messages is as follows:\n+ *    1        2      3       4       5       6        7      8       9       10     11     12     13      14\n+ *    0        1      2       3       4       5        6      7       8        9     10     11     12      13\n+ * canNode 1|2|3|4 1.lower 1.upper 2.lower 2.upper 3.lower 3.upper 4.lower 4.upper 1.type 2.type 3.type 4.type\n+ *\n+ * possible values for type according to the documentation are 1 to 21.\n+ *\n+ * The documentation says for the types:\n+ *\n+ * 1: Degree Celsius\n+ * 2: Watts per square meter\n+ * 3: liters per hour\n+ * 4: seconds\n+ * 5: minutes\n+ * 6: liters per pulse\n+ * 7: Kelvin\n+ * 8: Percent\n+ * 9: Kilowatt\n+ * 10: Megawatthours\n+ * 11: Kilowatthours\n+ * 12: Volt\n+ * 13: Milliampere\n+ * 14: hours\n+ * 15: days\n+ * 16: pulses\n+ * 17: Kiloohm\n+ * 18: Kilometers per hour\n+ * 19: Hertz\n+ * 20: liters per minute\n+ * 21: bar\n+ *\n+ * However, reality shows that the documentation is partly not accurate. An UVR1611 device uses:\n+ *\n+ * 1: Degree Celsius\n+ * 4: Seconds\n+ * 10: Kilowatt\n+ * 11: Megawatthours\n+ * 12: Kilowatthours\n+ *\n+ * so we don't rely on the documentation.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Wolfgang Klimt - improvements\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ * @see TACmiMeasureType.java", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDIwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464644208", "bodyText": "Loggers should only be final, not static. See https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "fwolter", "createdAt": "2020-08-03T20:27:48Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/AnalogValue.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.tacmi.internal.TACmiMeasureType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class handles analog values as used in the analog message.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Wolfgang Klimt\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public final class AnalogValue {\n+    public double value;\n+    public TACmiMeasureType measureType;\n+\n+    private static Logger logger = LoggerFactory.getLogger(AnalogValue.class);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDQ4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464644483", "bodyText": "Can this message be replaced by using the debugger?", "author": "fwolter", "createdAt": "2020-08-03T20:28:25Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/DigitalMessage.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+\n+/**\n+ * This class can be used to decode the digital values received in a messag and\n+ * also to create a new DigitalMessage used to send ON/OFF to an digital CAN\n+ * Input port\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public final class DigitalMessage extends Message {\n+\n+    public DigitalMessage(byte[] raw) {\n+        super(raw);\n+    }\n+\n+    /**\n+     * Create a new message to be sent to the CMI. It is only supported to use the\n+     * first port for each CAN node. This is due to the fact that all digital port\n+     * for the specific CAN node are send within a single message.\n+     */\n+    public DigitalMessage(byte canNode, byte podNr) {\n+        super(canNode, podNr);\n+        logger.debug(\"DigitalMessage: canNode: {}, podNumber: {}\", this.canNode, this.podNumber);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDc2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464644769", "bodyText": "Loggers should be private.", "author": "fwolter", "createdAt": "2020-08-03T20:29:02Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/Message.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Base message class handling generic functions.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public abstract class Message {\n+\n+    protected final static Logger logger = LoggerFactory.getLogger(Message.class);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDk4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464644986", "bodyText": "What's the purpose of this method?", "author": "fwolter", "createdAt": "2020-08-03T20:29:29Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/Message.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Base message class handling generic functions.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public abstract class Message {\n+\n+    protected final static Logger logger = LoggerFactory.getLogger(Message.class);\n+\n+    /**\n+     * ByteBuffer that stores the content of the message.\n+     */\n+    private ByteBuffer buffer;\n+\n+    /**\n+     * CAN Node number used in the message\n+     */\n+    public byte canNode;\n+\n+    /**\n+     * POD number used in the message\n+     */\n+    public byte podNumber;\n+\n+    /**\n+     * Initialize from the bytes of a received message\n+     *\n+     * @param raw\n+     */\n+    public Message(byte[] raw) {\n+        this.buffer = ByteBuffer.wrap(raw);\n+        this.buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        this.canNode = buffer.get(0);\n+        this.podNumber = buffer.get(1);\n+    }\n+\n+    /**\n+     * Used to create a new message with the specified CAN node and POD number\n+     *\n+     * @param canNode\n+     * @param podNumber\n+     */\n+    public Message(int canNode, int podNumber) {\n+        this.buffer = ByteBuffer.allocate(14);\n+        this.buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        setCanNode(canNode);\n+        setPodNumber(podNumber);\n+    }\n+\n+    public abstract void debug(Logger logger);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NjM5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r465296395", "bodyText": "good question. Is from the original binding. Might be stale - I already removed a bunch of stale methods. Will dig into it...", "author": "marvkis", "createdAt": "2020-08-04T19:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NDk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NTM1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464645359", "bodyText": "Can you write these out?", "author": "fwolter", "createdAt": "2020-08-03T20:30:14Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/MessageType.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+/**\n+ * This enumeration represents the different message types provided by the C.M.I COE protocol.\n+ * \n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+public enum MessageType {\n+    A,\n+    D", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NTU2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464645564", "bodyText": "Enums should also be annotated with @NonNullByDefault.", "author": "fwolter", "createdAt": "2020-08-03T20:30:40Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/MessageType.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+/**\n+ * This enumeration represents the different message types provided by the C.M.I COE protocol.\n+ * \n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner (marvkis) - Ported to OpenHAB2\n+ */\n+public enum MessageType {", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NjEyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464646126", "bodyText": "Enum values should be all upper case.", "author": "fwolter", "createdAt": "2020-08-03T20:31:52Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        Init,", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NjUxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464646518", "bodyText": "Can you please annotate this class with @NonNullByDefault?", "author": "fwolter", "createdAt": "2020-08-03T20:32:42Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5MjU2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r465292564", "bodyText": "I didn't get it to work. Maybe you could give me a pointer into the right direction: There are callback-Methods with maps, like this method:\n    public void handleStandaloneElement(final @Nullable String elementName,\n            final @Nullable Map<String, @Nullable String> attributes, final boolean minimized, final int line, final int col)\n            throws ParseException {\n\nWhen I activate the @NonNullByDefault I get error messages like\n\nIllegal redefinition of parameter attributes, inherited method from AbstractSimpleMarkupHandler declares this parameter as 'Map<String,String>' (mismatching null constraints)\n\nWhen I get this solved I would love adding the @NonNullByDefault annotation", "author": "marvkis", "createdAt": "2020-08-04T19:51:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0NjUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Njc4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464646789", "bodyText": "@NonNull is not necessary when annotating the class with @NonNullByDefault.", "author": "fwolter", "createdAt": "2020-08-03T20:33:18Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        Init,\n+        DataEntry\n+    }\n+\n+    static enum FieldType {\n+        Unknown,\n+        ReadOnly,\n+        FormValue,\n+        Button,\n+        Ignore\n+    }\n+\n+    static enum ButtonValue {\n+        Unknown,\n+        On,\n+        Off\n+    }\n+\n+    private @NonNull ParserState parserState = ParserState.Init;", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Nzc0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464647745", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-08-03T20:35:07Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        Init,\n+        DataEntry\n+    }\n+\n+    static enum FieldType {\n+        Unknown,\n+        ReadOnly,\n+        FormValue,\n+        Button,\n+        Ignore\n+    }\n+\n+    static enum ButtonValue {\n+        Unknown,\n+        On,\n+        Off\n+    }\n+\n+    private @NonNull ParserState parserState = ParserState.Init;\n+    private @NonNull TACmiSchemaHandler taCmiSchemaHandler;\n+    private @NonNull TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private @NonNull FieldType fieldType = FieldType.Unknown;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private @NonNull ButtonValue buttonValue = ButtonValue.Unknown;\n+    private @NonNull Map<@NonNull String, @Nullable ApiPageEntry> entries;\n+    private @NonNull Set<@NonNull String> seenNames = new HashSet<>();\n+    private @NonNull List<@NonNull Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(@NonNull TACmiSchemaHandler taCmiSchemaHandler,\n+            @NonNull Map<String, @Nullable ApiPageEntry> entries,\n+            @NonNull TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.Init;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.Init) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.Init && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DataEntry;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.ReadOnly;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.Unknown;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FormValue;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.Button;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.Off;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.On;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.Ignore;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DataEntry && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.Init;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.ReadOnly || this.fieldType == FieldType.FormValue) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.Button) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.Ignore) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DataEntry) {\n+            // logger.debug(\"Text {}:{}: {}\", line, col, new String(buffer, offset, len));", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Nzg4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464647882", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-08-03T20:35:24Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        Init,\n+        DataEntry\n+    }\n+\n+    static enum FieldType {\n+        Unknown,\n+        ReadOnly,\n+        FormValue,\n+        Button,\n+        Ignore\n+    }\n+\n+    static enum ButtonValue {\n+        Unknown,\n+        On,\n+        Off\n+    }\n+\n+    private @NonNull ParserState parserState = ParserState.Init;\n+    private @NonNull TACmiSchemaHandler taCmiSchemaHandler;\n+    private @NonNull TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private @NonNull FieldType fieldType = FieldType.Unknown;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private @NonNull ButtonValue buttonValue = ButtonValue.Unknown;\n+    private @NonNull Map<@NonNull String, @Nullable ApiPageEntry> entries;\n+    private @NonNull Set<@NonNull String> seenNames = new HashSet<>();\n+    private @NonNull List<@NonNull Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(@NonNull TACmiSchemaHandler taCmiSchemaHandler,\n+            @NonNull Map<String, @Nullable ApiPageEntry> entries,\n+            @NonNull TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.Init;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.Init) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.Init && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DataEntry;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.ReadOnly;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.Unknown;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FormValue;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.Button;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.Off;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.On;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.Ignore;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DataEntry && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.Init;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.ReadOnly || this.fieldType == FieldType.FormValue) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.Button) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.Ignore) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DataEntry) {\n+            // logger.debug(\"Text {}:{}: {}\", line, col, new String(buffer, offset, len));\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.Init && len == 1 && buffer[offset] == '\\n') {\n+            // single newline - ignore/drop it...\n+        } else {\n+            logger.info(\"Unexpected Text {}:{}: ({}) {} \", line, col, len, new String(buffer, offset, len));\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        // this.taCmiSchemaHandler.thingUpdated(thing);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0ODQ3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464648472", "bodyText": "Apache Commons. Same for below.", "author": "fwolter", "createdAt": "2020-08-03T20:36:37Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        Init,\n+        DataEntry\n+    }\n+\n+    static enum FieldType {\n+        Unknown,\n+        ReadOnly,\n+        FormValue,\n+        Button,\n+        Ignore\n+    }\n+\n+    static enum ButtonValue {\n+        Unknown,\n+        On,\n+        Off\n+    }\n+\n+    private @NonNull ParserState parserState = ParserState.Init;\n+    private @NonNull TACmiSchemaHandler taCmiSchemaHandler;\n+    private @NonNull TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private @NonNull FieldType fieldType = FieldType.Unknown;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private @NonNull ButtonValue buttonValue = ButtonValue.Unknown;\n+    private @NonNull Map<@NonNull String, @Nullable ApiPageEntry> entries;\n+    private @NonNull Set<@NonNull String> seenNames = new HashSet<>();\n+    private @NonNull List<@NonNull Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(@NonNull TACmiSchemaHandler taCmiSchemaHandler,\n+            @NonNull Map<String, @Nullable ApiPageEntry> entries,\n+            @NonNull TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.Init;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.Init) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.Init && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DataEntry;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.ReadOnly;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.Unknown;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FormValue;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.Button;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.Off;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.On;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.Ignore;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DataEntry && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.Init;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.ReadOnly || this.fieldType == FieldType.FormValue) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.Button) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.Ignore) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DataEntry && this.fieldType == FieldType.Button\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DataEntry) {\n+            // logger.debug(\"Text {}:{}: {}\", line, col, new String(buffer, offset, len));\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.Init && len == 1 && buffer[offset] == '\\n') {\n+            // single newline - ignore/drop it...\n+        } else {\n+            logger.info(\"Unexpected Text {}:{}: ({}) {} \", line, col, len, new String(buffer, offset, len));\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        // this.taCmiSchemaHandler.thingUpdated(thing);\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently not retrieveable..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case Button:\n+                type = Type.SwitchButton;\n+                state = this.buttonValue == ButtonValue.On ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case ReadOnly:\n+            case FormValue:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.ReadOnly || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.ReadOnlySwitch;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SwitchForm;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        BigDecimal bd = new BigDecimal(valParts[0]);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.info(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.ReadOnly || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.ReadOnlyNumeric;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NumericForm;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.ReadOnly || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.ReadOnlyState;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.StateForm;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case Unknown:\n+            case Ignore:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FormValue) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser());\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final Exception ex) {\n+                    logger.error(\"Error loading API Scheme: {} \", ex.getMessage(), ex);\n+                }\n+            }\n+            if (channel == null) {\n+                logger.info(\"Creating / updating channel {} of type {} for '{}'\", shortName, channelType, description);\n+                this.configChanged = true;\n+                ChannelUID channelUID = new ChannelUID(this.taCmiSchemaHandler.getThing().getUID(), shortName);\n+                ChannelBuilder channelBuilder = ChannelBuilder.create(channelUID, channelType);\n+                channelBuilder.withLabel(description);\n+                if (ctuid != null) {\n+                    channelBuilder.withType(ctuid);\n+                } else if (cx2e != null) {\n+                    StateDescriptionFragmentBuilder sdb = StateDescriptionFragmentBuilder.create()\n+                            .withReadOnly(type.readOnly);\n+                    String itemType;\n+                    switch (cx2e.optionType) {\n+                        case Number:\n+                            itemType = \"Number\";\n+                            String min = cx2e.options.get(ChangerX2Entry.NUMBER_MIN);\n+                            if (StringUtils.isNotBlank(min)) {", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTQ1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464649458", "bodyText": "See above. and below.", "author": "fwolter", "createdAt": "2020-08-03T20:38:44Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ChangerX2Entry.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link ChangerX2Entry} class contains mapping information for a changerX2 entry of\n+ * the API page element\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ChangerX2Entry {\n+\n+    public static final String NUMBER_MIN = \"min\";\n+    public static final String NUMBER_MAX = \"max\";\n+    public static final String NUMBER_STEP = \"step\";\n+\n+    static enum OptionType {\n+        Number,", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTg0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464649849", "bodyText": "See above. Annotation.", "author": "fwolter", "createdAt": "2020-08-03T20:39:32Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ChangerX2Parser.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.schema.ChangerX2Entry.OptionType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'changerx2' page from the CMI and\n+ * maps it to the results\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ChangerX2Parser extends AbstractSimpleMarkupHandler {", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDE5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464650194", "bodyText": "Apache Commons", "author": "fwolter", "createdAt": "2020-08-03T20:40:17Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ChangerX2Parser.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.schema.ChangerX2Entry.OptionType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'changerx2' page from the CMI and\n+ * maps it to the results\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+public class ChangerX2Parser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangerX2Parser.class);\n+\n+    static enum ParserState {\n+        Init,\n+        Input,\n+        InputData,\n+        Select,\n+        SelectOption,\n+        Unknown\n+    }\n+\n+    private @Nullable String curOptionId;\n+    private @NonNull ParserState parserState = ParserState.Init;\n+    private @Nullable String address;\n+    private @Nullable String addressFieldName;\n+    private @Nullable String optionFieldName;\n+    private @Nullable OptionType optionType;\n+    private @Nullable StringBuilder curOptionValue;\n+    private @NonNull Map<@NonNull String, @Nullable String> options;\n+\n+    public ChangerX2Parser() {\n+        super();\n+        this.options = new LinkedHashMap<>();\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.Init;\n+        this.options.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.Init) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    public void handleStandaloneElement(final String elementName, final Map<String, String> attributes,\n+            final boolean minimized, final int line, final int col) throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    public void handleOpenElement(final String elementName, final Map<String, String> attributes, final int line,\n+            final int col) throws ParseException {\n+\n+        String id = attributes == null ? null : attributes.get(\"id\");\n+\n+        if (this.parserState == ParserState.Init && \"input\".equals(elementName) && \"changeadr\".equals(id)) {\n+            this.parserState = ParserState.Input;\n+            if (attributes == null) {\n+                this.address = null;\n+                this.addressFieldName = null;\n+            } else {\n+                this.addressFieldName = attributes.get(\"name\");\n+                this.address = attributes.get(\"value\");\n+            }\n+        } else if ((this.parserState == ParserState.Init || this.parserState == ParserState.Input)\n+                && \"select\".equals(elementName)) {\n+            this.parserState = ParserState.Select;\n+            this.optionFieldName = attributes == null ? null : attributes.get(\"name\");\n+        } else if ((this.parserState == ParserState.Init || this.parserState == ParserState.Input)\n+                && \"br\".equals(elementName)) {\n+            // ignored\n+        } else if ((this.parserState == ParserState.Init || this.parserState == ParserState.Input)\n+                && \"input\".equals(elementName) && \"changeto\".equals(id)) {\n+            this.parserState = ParserState.InputData;\n+            if (attributes != null) {\n+                this.optionFieldName = attributes.get(\"name\");\n+                String type = attributes.get(\"type\");\n+                if (\"number\".equals(type)) {\n+                    this.optionType = OptionType.Number;\n+                    // we transfer the limits from the input elemnt...\n+                    this.options.put(ChangerX2Entry.NUMBER_MIN, attributes.get(ChangerX2Entry.NUMBER_MIN));\n+                    this.options.put(ChangerX2Entry.NUMBER_MAX, attributes.get(ChangerX2Entry.NUMBER_MAX));\n+                    this.options.put(ChangerX2Entry.NUMBER_STEP, attributes.get(ChangerX2Entry.NUMBER_STEP));\n+                } else {\n+                    logger.warn(\"Unhandled input field in {}:{}: {}\", line, col, attributes);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.Select && \"option\".equals(elementName)) {\n+            this.parserState = ParserState.SelectOption;\n+            this.optionType = OptionType.Select;\n+            this.curOptionValue = new StringBuilder();\n+            this.curOptionId = attributes == null ? null : attributes.get(\"value\");\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.Input && \"input\".equals(elementName)) {\n+            this.parserState = ParserState.Init;\n+        } else if (this.parserState == ParserState.Select && \"select\".equals(elementName)) {\n+            this.parserState = ParserState.Init;\n+        } else if (this.parserState == ParserState.SelectOption && \"option\".equals(elementName)) {\n+            this.parserState = ParserState.Select;\n+            StringBuilder sb = this.curOptionValue;\n+            String value = sb != null && sb.length() > 0 ? sb.toString().trim() : null;\n+            this.curOptionValue = null;\n+            String id = this.curOptionId;\n+            this.curOptionId = null;\n+            if (value != null) {\n+                if (id == null || !StringUtils.isNotBlank(id)) {", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464650437", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-08-03T20:40:48Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDg4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464650882", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-08-03T20:41:44Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MTAzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464651034", "bodyText": "Apache Commons. Same for below.", "author": "fwolter", "createdAt": "2020-08-03T20:42:04Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MTE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464651141", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-08-03T20:42:19Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MTc3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464651778", "bodyText": "This should be scheduleWithFixedDelay. See https://www.openhab.org/docs/developer/guidelines.html#e-runtime-behavior Point 2.", "author": "fwolter", "createdAt": "2020-08-03T20:43:40Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        this.scheduledFuture = scheduler.scheduleAtFixedRate(() -> refreshData(), config.pollInterval,", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MjUwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464652500", "bodyText": "Can you decrease the timeout to e.g. 10 sec., as it will block the OH scheduler thread pool and will throw an exception after 15 sec.", "author": "fwolter", "createdAt": "2020-08-03T20:45:04Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        this.scheduledFuture = scheduler.scheduleAtFixedRate(() -> refreshData(), config.pollInterval,\n+                config.pollInterval, TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(30000, TimeUnit.MILLISECONDS);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MzAyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464653026", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-08-03T20:46:12Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        this.scheduledFuture = scheduler.scheduleAtFixedRate(() -> refreshData(), config.pollInterval,\n+                config.pollInterval, TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(30000, TimeUnit.MILLISECONDS);\n+        req.header(HttpHeader.ACCEPT_LANGUAGE, \"en\"); // we want the on/off states in english\n+        final String ah = this.authHeader;\n+        if (ah != null) {\n+            req.header(HttpHeader.AUTHORIZATION, ah);\n+        }\n+        return req;\n+    }\n+\n+    protected <PP extends AbstractSimpleMarkupHandler> PP parsePage(URI uri, PP pp)\n+            throws ParseException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse response = prepareRequest(uri).send();\n+\n+        String responseString = null;\n+        if (StringUtil.isBlank(response.getEncoding())) {\n+            responseString = new String(response.getContent(), StandardCharsets.UTF_8);\n+        } else {\n+            responseString = response.getContentAsString();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Response body was: {} \", responseString);\n+        }\n+\n+        final ISimpleMarkupParser parser = new SimpleMarkupParser(this.noRestrictions);\n+        parser.parse(responseString, pp);\n+        return pp;\n+    }\n+\n+    private void refreshData() {\n+        URI schemaApiPage = this.schemaApiPage;\n+        if (schemaApiPage == null) {\n+            return;\n+        }\n+        try {\n+            final ApiPageParser pp = parsePage(schemaApiPage,\n+                    new ApiPageParser(this, entries, this.channelTypeProvider));\n+\n+            if (pp.isConfigChanged()) {\n+                // we have to update our channels...\n+                final List<Channel> channels = pp.getChannels();\n+                final ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+            }\n+            if (!this.online) {\n+                updateStatus(ThingStatus.ONLINE);\n+                this.online = true;\n+            }\n+        } catch (final InterruptedException e) {\n+            // plugin shutdown is in progress\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n+            this.online = false;\n+        } catch (final Exception e) {", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MzA5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464653091", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-08-03T20:46:21Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        this.scheduledFuture = scheduler.scheduleAtFixedRate(() -> refreshData(), config.pollInterval,\n+                config.pollInterval, TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(30000, TimeUnit.MILLISECONDS);\n+        req.header(HttpHeader.ACCEPT_LANGUAGE, \"en\"); // we want the on/off states in english\n+        final String ah = this.authHeader;\n+        if (ah != null) {\n+            req.header(HttpHeader.AUTHORIZATION, ah);\n+        }\n+        return req;\n+    }\n+\n+    protected <PP extends AbstractSimpleMarkupHandler> PP parsePage(URI uri, PP pp)\n+            throws ParseException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse response = prepareRequest(uri).send();\n+\n+        String responseString = null;\n+        if (StringUtil.isBlank(response.getEncoding())) {\n+            responseString = new String(response.getContent(), StandardCharsets.UTF_8);\n+        } else {\n+            responseString = response.getContentAsString();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Response body was: {} \", responseString);\n+        }\n+\n+        final ISimpleMarkupParser parser = new SimpleMarkupParser(this.noRestrictions);\n+        parser.parse(responseString, pp);\n+        return pp;\n+    }\n+\n+    private void refreshData() {\n+        URI schemaApiPage = this.schemaApiPage;\n+        if (schemaApiPage == null) {\n+            return;\n+        }\n+        try {\n+            final ApiPageParser pp = parsePage(schemaApiPage,\n+                    new ApiPageParser(this, entries, this.channelTypeProvider));\n+\n+            if (pp.isConfigChanged()) {\n+                // we have to update our channels...\n+                final List<Channel> channels = pp.getChannels();\n+                final ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+            }\n+            if (!this.online) {\n+                updateStatus(ThingStatus.ONLINE);\n+                this.online = true;\n+            }\n+        } catch (final InterruptedException e) {\n+            // plugin shutdown is in progress\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n+            this.online = false;\n+        } catch (final Exception e) {\n+            logger.error(\"Error loading API Scheme: {} \", e.getMessage(), e);", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MzM3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r464653376", "bodyText": "This can be done with OH's cache classes.", "author": "fwolter", "createdAt": "2020-08-03T20:46:54Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.TACmiHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner (marvkis) - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    // private @Nullable InetAddress cmiAddress;\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (StringUtil.isBlank(config.host)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.username)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.password)) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        // set cmiAddress from configuration\n+        // cmiAddress = (String) configuration.get(\"cmiAddress\");\n+        /*\n+         * try { cmiAddress = InetAddress.getByName(config.host); } catch (final\n+         * UnknownHostException e1) {\n+         * logger.error(\"Failed to get IP of C.M.I. from configuration\");\n+         * updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+         * \"Failed to get IP of C.M.I. from configuration\"); return; }\n+         */\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        this.scheduledFuture = scheduler.scheduleAtFixedRate(() -> refreshData(), config.pollInterval,\n+                config.pollInterval, TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(30000, TimeUnit.MILLISECONDS);\n+        req.header(HttpHeader.ACCEPT_LANGUAGE, \"en\"); // we want the on/off states in english\n+        final String ah = this.authHeader;\n+        if (ah != null) {\n+            req.header(HttpHeader.AUTHORIZATION, ah);\n+        }\n+        return req;\n+    }\n+\n+    protected <PP extends AbstractSimpleMarkupHandler> PP parsePage(URI uri, PP pp)\n+            throws ParseException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse response = prepareRequest(uri).send();\n+\n+        String responseString = null;\n+        if (StringUtil.isBlank(response.getEncoding())) {\n+            responseString = new String(response.getContent(), StandardCharsets.UTF_8);\n+        } else {\n+            responseString = response.getContentAsString();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Response body was: {} \", responseString);\n+        }\n+\n+        final ISimpleMarkupParser parser = new SimpleMarkupParser(this.noRestrictions);\n+        parser.parse(responseString, pp);\n+        return pp;\n+    }\n+\n+    private void refreshData() {\n+        URI schemaApiPage = this.schemaApiPage;\n+        if (schemaApiPage == null) {\n+            return;\n+        }\n+        try {\n+            final ApiPageParser pp = parsePage(schemaApiPage,\n+                    new ApiPageParser(this, entries, this.channelTypeProvider));\n+\n+            if (pp.isConfigChanged()) {\n+                // we have to update our channels...\n+                final List<Channel> channels = pp.getChannels();\n+                final ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+            }\n+            if (!this.online) {\n+                updateStatus(ThingStatus.ONLINE);\n+                this.online = true;\n+            }\n+        } catch (final InterruptedException e) {\n+            // plugin shutdown is in progress\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n+            this.online = false;\n+        } catch (final Exception e) {\n+            logger.error(\"Error loading API Scheme: {} \", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Error: \" + e.getMessage());\n+            this.online = false;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // TODO how to debounce this? we could trigger refreshData() but during startup\n+            // this issues lots of requests... :-/", "originalCommit": "066f08d7b0bfc8e96596aa0f4ad61cb79d3771e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5Mzg0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r465293846", "bodyText": "Okay, I definitively have to have a look on the cache classes. I'm not aware of them.", "author": "marvkis", "createdAt": "2020-08-04T19:54:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MzM3Ng=="}], "type": "inlineReview"}, {"oid": "16574f01b7741b841f909d5587c3b7ede905aee6", "url": "https://github.com/openhab/openhab-addons/commit/16574f01b7741b841f909d5587c3b7ede905aee6", "message": "[tacmi] Applied requested changes from code review - final changes\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-08-09T15:36:32Z", "type": "forcePushed"}, {"oid": "a8d9a30941fc3c40a9c47402546360fa7bdb6f66", "url": "https://github.com/openhab/openhab-addons/commit/a8d9a30941fc3c40a9c47402546360fa7bdb6f66", "message": "[tacmi] Initial push of OpenHAB 2 ported tacmi binding\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:57Z", "type": "commit"}, {"oid": "eb8ee35abafee339d844b7c917ff9ce7b99653ca", "url": "https://github.com/openhab/openhab-addons/commit/eb8ee35abafee339d844b7c917ff9ce7b99653ca", "message": "[tacmi] fixed travis errors & added some @NonNullByDefault\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:57Z", "type": "commit"}, {"oid": "fe7360d26a2c357cae3548c186b72a03aa48cc03", "url": "https://github.com/openhab/openhab-addons/commit/fe7360d26a2c357cae3548c186b72a03aa48cc03", "message": "[tacmi] fixed further travis errors & warnings, especially Null handling stuff...\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:58Z", "type": "commit"}, {"oid": "f4977fc39c09766bb2f9036df578ee66d53a5f5a", "url": "https://github.com/openhab/openhab-addons/commit/f4977fc39c09766bb2f9036df578ee66d53a5f5a", "message": "[tacmi] fixed further travis errors & warnings, especially Null handling stuff...\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:58Z", "type": "commit"}, {"oid": "882889d4d4e25e420f5136dc867bae3e52d2f58c", "url": "https://github.com/openhab/openhab-addons/commit/882889d4d4e25e420f5136dc867bae3e52d2f58c", "message": "[tacmi] fixed a XML identing issue causing travis to fail..\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:58Z", "type": "commit"}, {"oid": "d8dc115317627e463bfdec6a2510c99ea0c557f6", "url": "https://github.com/openhab/openhab-addons/commit/d8dc115317627e463bfdec6a2510c99ea0c557f6", "message": "[tacmi] executed `mvn spotless:apply` to fix formatting issues\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:58Z", "type": "commit"}, {"oid": "1f84759065021e87eeee9a6ae5b4594744303a0b", "url": "https://github.com/openhab/openhab-addons/commit/1f84759065021e87eeee9a6ae5b4594744303a0b", "message": "[tacmi] initial WIP-Checkin of the \"Schema API Page\" variant\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:58Z", "type": "commit"}, {"oid": "60c69f29c8dc7b05e2287017bc9b6019257198b3", "url": "https://github.com/openhab/openhab-addons/commit/60c69f29c8dc7b05e2287017bc9b6019257198b3", "message": "[tacmi] added initial documentation for the new API Page thing\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:58Z", "type": "commit"}, {"oid": "882c6fdefdd282518f491334a006b4f61cba2f92", "url": "https://github.com/openhab/openhab-addons/commit/882c6fdefdd282518f491334a006b4f61cba2f92", "message": "[tacmi] Apply suggestions from code review\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:59Z", "type": "commit"}, {"oid": "92171cd76e71650ec1adaed3e40484ca6a6017b4", "url": "https://github.com/openhab/openhab-addons/commit/92171cd76e71650ec1adaed3e40484ca6a6017b4", "message": "[tacmi] ApiPageParser - added new unit 'Hz'\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:59Z", "type": "commit"}, {"oid": "d1c13cb7ae0d82ed9070b0a699fa4a04c26a9d22", "url": "https://github.com/openhab/openhab-addons/commit/d1c13cb7ae0d82ed9070b0a699fa4a04c26a9d22", "message": "[tacmi] Applied requested changes from code review - stright forward changes\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:59Z", "type": "commit"}, {"oid": "ed8e26a5a922251c062620780230d6a324cbfb87", "url": "https://github.com/openhab/openhab-addons/commit/ed8e26a5a922251c062620780230d6a324cbfb87", "message": "[tacmi] Applied requested changes from code review - RefreshType for TACmiSchemaHandler\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:59Z", "type": "commit"}, {"oid": "079a9169e19bd914980c52057ecb09dd7aa9de5f", "url": "https://github.com/openhab/openhab-addons/commit/079a9169e19bd914980c52057ecb09dd7aa9de5f", "message": "[tacmi] CoE communication: added thing config parameter 'persistInterval' to configure behavour of the integrated persistence service\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:57:59Z", "type": "commit"}, {"oid": "040bd741d2f9f9e2f922971f1bed10c06b025709", "url": "https://github.com/openhab/openhab-addons/commit/040bd741d2f9f9e2f922971f1bed10c06b025709", "message": "[tacmi] Applied requested changes from code review - final changes\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:58:00Z", "type": "commit"}, {"oid": "b9498632c0ed5b79289539b564e50d0aedef1e9f", "url": "https://github.com/openhab/openhab-addons/commit/b9498632c0ed5b79289539b564e50d0aedef1e9f", "message": "[tacmi] Made @NonNullByDefault with ApiPageParser & ChangerX2Parser\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:58:00Z", "type": "commit"}, {"oid": "9e2d5854ea4c494b00d5ad7f68bd2ca1d3a479a3", "url": "https://github.com/openhab/openhab-addons/commit/9e2d5854ea4c494b00d5ad7f68bd2ca1d3a479a3", "message": "[tacmi] schema thing: improved logging in ChangerX2Parser and suppressed some irrelevant loggings during startup\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:58:00Z", "type": "commit"}, {"oid": "68d8f04e21c7770385cb074eb106492b372aded2", "url": "https://github.com/openhab/openhab-addons/commit/68d8f04e21c7770385cb074eb106492b372aded2", "message": "[tacmi] CoE thing: removed persistence layer; channel configuration property for setting initial values for channel initialization; prevent sending of pod's having uninitialized values; some refactoring of coe related classes to .../tacmi/internal/coe/ to have a clear separation between schema and coe thing's\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:58:00Z", "type": "commit"}, {"oid": "40a6d5f04f6bb9240f49287f8fc19790016ae5b9", "url": "https://github.com/openhab/openhab-addons/commit/40a6d5f04f6bb9240f49287f8fc19790016ae5b9", "message": "[tacmi] Schema thing: Initial support for older pre-X2 devices\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:58:00Z", "type": "commit"}, {"oid": "ddb472c601270370b7dc9c2d8041477833ec9337", "url": "https://github.com/openhab/openhab-addons/commit/ddb472c601270370b7dc9c2d8041477833ec9337", "message": "[tacmi] Improved documentation\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T20:58:01Z", "type": "commit"}, {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "url": "https://github.com/openhab/openhab-addons/commit/d9bc1bd3fe058ae23694227ffb55051df030e9ab", "message": "[tacmi] upgraded to 2.5.9 and applied latest spotless rules\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T21:00:03Z", "type": "commit"}, {"oid": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "url": "https://github.com/openhab/openhab-addons/commit/d9bc1bd3fe058ae23694227ffb55051df030e9ab", "message": "[tacmi] upgraded to 2.5.9 and applied latest spotless rules\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-05T21:00:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzM2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484097369", "bodyText": "There's a new thread naming scheme. See #8216\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n          \n          \n            \n                        super(\"tacmi TA C.M.I. CoE ReceiveThread\");", "author": "fwolter", "createdAt": "2020-09-06T17:55:20Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzQ0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484097449", "bodyText": "Logging to info should be used rarely. This could be debug.", "author": "fwolter", "createdAt": "2020-09-06T17:56:21Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+            if (coeSocket == null) {\n+                logger.warn(\"coeSocket is NULL - Reader disabled!\");\n+                return;\n+            }\n+            while (!isInterrupted()) {\n+                final byte[] receiveData = new byte[14];\n+\n+                try {\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.trace(\"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    final byte[] data = receivePacket.getData();\n+                    Message message;\n+                    if (data[1] > 0 && data[1] < 9) {\n+                        message = new AnalogMessage(data);\n+                    } else if (data[1] == 0 || data[1] == 9) {\n+                        message = new DigitalMessage(data);\n+                    } else {\n+                        logger.debug(\"Invalid message received\");\n+                        continue;\n+                    }\n+                    logger.debug(\"{}\", message.toString());\n+\n+                    final InetAddress remoteAddress = receivePacket.getAddress();\n+                    final int node = message.canNode;\n+                    boolean found = false;\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        if (cmi.isFor(remoteAddress, node)) {\n+                            cmi.handleCoE(message);\n+                            found = true;\n+                        }\n+                    }\n+                    if (!found) {\n+                        logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\", remoteAddress,", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzYyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484097624", "bodyText": "No harm in canceling a task that is already cancelled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (timeoutCheckFuture != null && !timeoutCheckFuture.isCancelled()) {\n          \n          \n            \n                    if (timeoutCheckFuture != null) {", "author": "fwolter", "createdAt": "2020-09-06T17:58:07Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+            if (coeSocket == null) {\n+                logger.warn(\"coeSocket is NULL - Reader disabled!\");\n+                return;\n+            }\n+            while (!isInterrupted()) {\n+                final byte[] receiveData = new byte[14];\n+\n+                try {\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.trace(\"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    final byte[] data = receivePacket.getData();\n+                    Message message;\n+                    if (data[1] > 0 && data[1] < 9) {\n+                        message = new AnalogMessage(data);\n+                    } else if (data[1] == 0 || data[1] == 9) {\n+                        message = new DigitalMessage(data);\n+                    } else {\n+                        logger.debug(\"Invalid message received\");\n+                        continue;\n+                    }\n+                    logger.debug(\"{}\", message.toString());\n+\n+                    final InetAddress remoteAddress = receivePacket.getAddress();\n+                    final int node = message.canNode;\n+                    boolean found = false;\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        if (cmi.isFor(remoteAddress, node)) {\n+                            cmi.handleCoE(message);\n+                            found = true;\n+                        }\n+                    }\n+                    if (!found) {\n+                        logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\", remoteAddress,\n+                                node);\n+                    }\n+                } catch (final IOException e) {\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Error processing data: \" + e.getMessage());\n+\n+                } catch (RuntimeException e) {\n+                    // we catch runtime exceptions here to prevent the receiving thread to stop accidentally if\n+                    // something like a IllegalStateException or NumberFormatExceptions are thrown. This indicates a bug\n+                    // or a situation / setup I'm not thinking of ;)\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    logger.error(\"Error processing data: {}\", e.getMessage(), e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Periodically check for timeouts on the registered / active CoE channels\n+     */\n+    private void checkForTimeouts() {\n+        for (final TACmiHandler cmi : registeredCMIs) {\n+            cmi.checkForTimeout();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            // logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread();\n+        reciveThreadNN.setDaemon(true);\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        ScheduledFuture<?> timeoutCheckFuture = this.timeoutCheckFuture;\n+        if (timeoutCheckFuture == null || timeoutCheckFuture.isCancelled()) {\n+            this.timeoutCheckFuture = scheduler.scheduleWithFixedDelay(this::checkForTimeouts, 1, 1, TimeUnit.SECONDS);\n+        }\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // just forward it to the registered handlers...\n+            for (final TACmiHandler cmi : registeredCMIs) {\n+                cmi.handleCommand(channelUID, command);\n+            }\n+        } else {\n+            logger.warn(\"No bridge commands defined.\");\n+        }\n+    }\n+\n+    protected void registerCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.add(handler);\n+    }\n+\n+    protected void unregisterCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.remove(handler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        // clean up the timeout check\n+        ScheduledFuture<?> timeoutCheckFuture = this.timeoutCheckFuture;\n+        if (timeoutCheckFuture != null && !timeoutCheckFuture.isCancelled()) {", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5NzY3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484097676", "bodyText": "Logging to info", "author": "fwolter", "createdAt": "2020-09-06T17:58:58Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread() {\n+            super(\"tacmi TA C.M.I. CoE ReceiveThread\");\n+        }\n+\n+        @Override\n+        public void run() {\n+            final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+            if (coeSocket == null) {\n+                logger.warn(\"coeSocket is NULL - Reader disabled!\");\n+                return;\n+            }\n+            while (!isInterrupted()) {\n+                final byte[] receiveData = new byte[14];\n+\n+                try {\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.trace(\"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    final byte[] data = receivePacket.getData();\n+                    Message message;\n+                    if (data[1] > 0 && data[1] < 9) {\n+                        message = new AnalogMessage(data);\n+                    } else if (data[1] == 0 || data[1] == 9) {\n+                        message = new DigitalMessage(data);\n+                    } else {\n+                        logger.debug(\"Invalid message received\");\n+                        continue;\n+                    }\n+                    logger.debug(\"{}\", message.toString());\n+\n+                    final InetAddress remoteAddress = receivePacket.getAddress();\n+                    final int node = message.canNode;\n+                    boolean found = false;\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        if (cmi.isFor(remoteAddress, node)) {\n+                            cmi.handleCoE(message);\n+                            found = true;\n+                        }\n+                    }\n+                    if (!found) {\n+                        logger.info(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\", remoteAddress,\n+                                node);\n+                    }\n+                } catch (final IOException e) {\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Error processing data: \" + e.getMessage());\n+\n+                } catch (RuntimeException e) {\n+                    // we catch runtime exceptions here to prevent the receiving thread to stop accidentally if\n+                    // something like a IllegalStateException or NumberFormatExceptions are thrown. This indicates a bug\n+                    // or a situation / setup I'm not thinking of ;)\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    logger.error(\"Error processing data: {}\", e.getMessage(), e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Periodically check for timeouts on the registered / active CoE channels\n+     */\n+    private void checkForTimeouts() {\n+        for (final TACmiHandler cmi : registeredCMIs) {\n+            cmi.checkForTimeout();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            // logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread();\n+        reciveThreadNN.setDaemon(true);\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        ScheduledFuture<?> timeoutCheckFuture = this.timeoutCheckFuture;\n+        if (timeoutCheckFuture == null || timeoutCheckFuture.isCancelled()) {\n+            this.timeoutCheckFuture = scheduler.scheduleWithFixedDelay(this::checkForTimeouts, 1, 1, TimeUnit.SECONDS);\n+        }\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // just forward it to the registered handlers...\n+            for (final TACmiHandler cmi : registeredCMIs) {\n+                cmi.handleCommand(channelUID, command);\n+            }\n+        } else {\n+            logger.warn(\"No bridge commands defined.\");\n+        }\n+    }\n+\n+    protected void registerCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.add(handler);\n+    }\n+\n+    protected void unregisterCMI(final TACmiHandler handler) {\n+        this.registeredCMIs.remove(handler);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        // clean up the timeout check\n+        ScheduledFuture<?> timeoutCheckFuture = this.timeoutCheckFuture;\n+        if (timeoutCheckFuture != null && !timeoutCheckFuture.isCancelled()) {\n+            timeoutCheckFuture.cancel(true);\n+            this.timeoutCheckFuture = null;\n+        }\n+\n+        // clean up the receive thread\n+        ReceiveThread receiveThread = this.receiveThread;\n+        if (receiveThread != null) {\n+            receiveThread.interrupt(); // just interrupt it so when the socketException throws it's flagged as\n+                                       // interrupted.\n+        }\n+\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock != null && !sock.isClosed()) {\n+            sock.close();\n+            this.coeSocket = null;\n+        }\n+        if (receiveThread != null) {\n+            receiveThread.interrupt();\n+            try {\n+                // it should join quite quick as we already closed the socket which should have the receiver thread\n+                // caused to stop.\n+                receiveThread.join(250);\n+            } catch (final InterruptedException e) {\n+                logger.info(\"Unexpected interrupt in receiveThread.join(): {}\", e.getMessage(), e);", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5Nzk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484097952", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return (portNumber - 1) / 4 == podNumber - 1 ? true : false;\n          \n          \n            \n                    return (portNumber - 1) / 4 == podNumber - 1;", "author": "fwolter", "createdAt": "2020-09-06T18:01:33Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/message/AnalogMessage.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.message;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Format of analog messages is as follows:\n+ * 1 2 3 4 5 6 7 8 9 10 11 12 13 14\n+ * 0 1 2 3 4 5 6 7 8 9 10 11 12 13\n+ * canNode 1|2|3|4 1.lower 1.upper 2.lower 2.upper 3.lower 3.upper 4.lower 4.upper 1.type 2.type 3.type 4.type\n+ *\n+ * possible values for type according to the documentation are 1 to 21.\n+ *\n+ * The documentation says for the types:\n+ *\n+ * 1: Degree Celsius\n+ * 2: Watts per square meter\n+ * 3: liters per hour\n+ * 4: seconds\n+ * 5: minutes\n+ * 6: liters per pulse\n+ * 7: Kelvin\n+ * 8: Percent\n+ * 9: Kilowatt\n+ * 10: Megawatthours\n+ * 11: Kilowatthours\n+ * 12: Volt\n+ * 13: Milliampere\n+ * 14: hours\n+ * 15: days\n+ * 16: pulses\n+ * 17: Kiloohm\n+ * 18: Kilometers per hour\n+ * 19: Hertz\n+ * 20: liters per minute\n+ * 21: bar\n+ *\n+ * However, reality shows that the documentation is partly not accurate. An UVR1611 device uses:\n+ *\n+ * 1: Degree Celsius\n+ * 4: Seconds\n+ * 10: Kilowatt\n+ * 11: Megawatthours\n+ * 12: Kilowatthours\n+ *\n+ * so we don't rely on the documentation.\n+ *\n+ * This class can be used to decode the analog values received in a message and\n+ * also to create a new AnalogMessage used to send analog values to an analog\n+ * CAN Input port. Creation of new message is not implemented so far.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Wolfgang Klimt - improvements\n+ * @author Christian Niessner - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public final class AnalogMessage extends Message {\n+\n+    /**\n+     * Used to parse the data received from the CMI.\n+     *\n+     * @param raw\n+     */\n+    public AnalogMessage(byte[] raw) {\n+        super(raw);\n+    }\n+\n+    /**\n+     * Create a new message to be sent to the CMI. It is only supported to use\n+     * the first port for each podNumber.\n+     */\n+    public AnalogMessage(byte canNode, byte podNumber) {\n+        super(canNode, podNumber);\n+    }\n+\n+    /**\n+     * Get the value for the specified port number.\n+     *\n+     * @param portNumber\n+     * @return\n+     */\n+    public AnalogValue getAnalogValue(int portNumber) {\n+        // Get the internal index for portNumber within the message\n+        int idx = (portNumber - 1) % 4;\n+        AnalogValue value = new AnalogValue(this.getValue(idx), getMeasureType(idx));\n+        return value;\n+    }\n+\n+    /**\n+     * Check if message contains a value for the specified port number. It\n+     * doesn't matter though if the port has a value of 0.\n+     *\n+     * @param portNumber\n+     * @return\n+     */\n+    @Override\n+    public boolean hasPortnumber(int portNumber) {\n+        return (portNumber - 1) / 4 == podNumber - 1 ? true : false;", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODA4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098082", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-09-06T18:02:51Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODA5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098092", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-09-06T18:03:05Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODExNg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098116", "bodyText": "See above and below", "author": "fwolter", "createdAt": "2020-09-06T18:03:23Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODI3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098271", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2020-09-06T18:05:04Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.IGNORE) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DATA_ENTRY) {\n+            // we append it to our current value\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.INIT && ((len == 1 && buffer[offset] == '\\n')\n+                || (len == 2 && buffer[offset] == '\\r' && buffer[offset + 1] == '\\n'))) {\n+            // single newline - ignore/drop it...\n+        } else {\n+            String msg = new String(buffer, offset, len).replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n+            logger.info(\"Unexpected Text {}:{}: ParserState: {} ({}) `{}`\", line, col, parserState, len, msg);\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently cannot be retrieved..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case BUTTON:\n+                type = Type.SWITCH_BUTTON;\n+                state = this.buttonValue == ButtonValue.ON ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case READ_ONLY:\n+            case FORM_VALUE:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.READ_ONLY_SWITCH;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SWITCH_FORM;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        // It seems for some wired cases the C.M.I. uses different decimal separators for\n+                        // different device types. It seems all 'new' X2-Devices use a dot as separator,\n+                        // for the older pre-X2 devices (i.e. the UVR 1611) we get a comma. So we\n+                        // we replace all ',' with '.' to check if it's a valid number...\n+                        String val = valParts[0].replace(',', '.');\n+                        BigDecimal bd = new BigDecimal(val);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"Hz\".equals(valParts[1])) {\n+                                channelType = \"Number:Frequency\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.HERTZ);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.debug(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.READ_ONLY_NUMERIC;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NUMERIC_FORM;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.READ_ONLY_STATE;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.STATE_FORM;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case UNKNOWN:\n+            case IGNORE:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FORM_VALUE) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser(shortName));\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final Exception ex) {", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODMyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098321", "bodyText": "A parsing error shouldn't be logged as error. This could be warn.", "author": "fwolter", "createdAt": "2020-09-06T18:05:32Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.IGNORE) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DATA_ENTRY) {\n+            // we append it to our current value\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.INIT && ((len == 1 && buffer[offset] == '\\n')\n+                || (len == 2 && buffer[offset] == '\\r' && buffer[offset + 1] == '\\n'))) {\n+            // single newline - ignore/drop it...\n+        } else {\n+            String msg = new String(buffer, offset, len).replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n+            logger.info(\"Unexpected Text {}:{}: ParserState: {} ({}) `{}`\", line, col, parserState, len, msg);\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently cannot be retrieved..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case BUTTON:\n+                type = Type.SWITCH_BUTTON;\n+                state = this.buttonValue == ButtonValue.ON ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case READ_ONLY:\n+            case FORM_VALUE:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.READ_ONLY_SWITCH;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SWITCH_FORM;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        // It seems for some wired cases the C.M.I. uses different decimal separators for\n+                        // different device types. It seems all 'new' X2-Devices use a dot as separator,\n+                        // for the older pre-X2 devices (i.e. the UVR 1611) we get a comma. So we\n+                        // we replace all ',' with '.' to check if it's a valid number...\n+                        String val = valParts[0].replace(',', '.');\n+                        BigDecimal bd = new BigDecimal(val);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"Hz\".equals(valParts[1])) {\n+                                channelType = \"Number:Frequency\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.HERTZ);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.debug(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.READ_ONLY_NUMERIC;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NUMERIC_FORM;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.READ_ONLY_STATE;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.STATE_FORM;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case UNKNOWN:\n+            case IGNORE:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FORM_VALUE) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser(shortName));\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final Exception ex) {\n+                    logger.error(\"Error loading API Scheme: {} \", ex.getMessage(), ex);", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODM1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098355", "bodyText": "Can this be removed?", "author": "fwolter", "createdAt": "2020-09-06T18:05:52Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,491 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.info(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.info(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.IGNORE) {\n+                    // ignore\n+                } else {\n+                    logger.info(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.info(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.info(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.info(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DATA_ENTRY) {\n+            // we append it to our current value\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.INIT && ((len == 1 && buffer[offset] == '\\n')\n+                || (len == 2 && buffer[offset] == '\\r' && buffer[offset + 1] == '\\n'))) {\n+            // single newline - ignore/drop it...\n+        } else {\n+            String msg = new String(buffer, offset, len).replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n+            logger.info(\"Unexpected Text {}:{}: ParserState: {} ({}) `{}`\", line, col, parserState, len, msg);\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.info(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently cannot be retrieved..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case BUTTON:\n+                type = Type.SWITCH_BUTTON;\n+                state = this.buttonValue == ButtonValue.ON ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case READ_ONLY:\n+            case FORM_VALUE:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.READ_ONLY_SWITCH;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SWITCH_FORM;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        // It seems for some wired cases the C.M.I. uses different decimal separators for\n+                        // different device types. It seems all 'new' X2-Devices use a dot as separator,\n+                        // for the older pre-X2 devices (i.e. the UVR 1611) we get a comma. So we\n+                        // we replace all ',' with '.' to check if it's a valid number...\n+                        String val = valParts[0].replace(',', '.');\n+                        BigDecimal bd = new BigDecimal(val);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"Hz\".equals(valParts[1])) {\n+                                channelType = \"Number:Frequency\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.HERTZ);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.debug(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.READ_ONLY_NUMERIC;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NUMERIC_FORM;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.READ_ONLY_STATE;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.STATE_FORM;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case UNKNOWN:\n+            case IGNORE:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FORM_VALUE) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser(shortName));\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final Exception ex) {\n+                    logger.error(\"Error loading API Scheme: {} \", ex.getMessage(), ex);\n+                }\n+            }\n+            if (channel == null) {\n+                logger.info(\"Creating / updating channel {} of type {} for '{}'\", shortName, channelType, description);\n+                this.configChanged = true;\n+                ChannelUID channelUID = new ChannelUID(this.taCmiSchemaHandler.getThing().getUID(), shortName);\n+                ChannelBuilder channelBuilder = ChannelBuilder.create(channelUID, channelType);\n+                channelBuilder.withLabel(description);\n+                if (ctuid != null) {\n+                    channelBuilder.withType(ctuid);\n+                } else if (cx2e != null) {\n+                    StateDescriptionFragmentBuilder sdb = StateDescriptionFragmentBuilder.create()\n+                            .withReadOnly(type.readOnly);\n+                    String itemType;\n+                    switch (cx2e.optionType) {\n+                        case NUMBER:\n+                            itemType = \"Number\";\n+                            String min = cx2e.options.get(ChangerX2Entry.NUMBER_MIN);\n+                            if (min != null && !min.trim().isEmpty()) {\n+                                sdb.withMinimum(new BigDecimal(min));\n+                            }\n+                            String max = cx2e.options.get(ChangerX2Entry.NUMBER_MAX);\n+                            if (max != null && !max.trim().isEmpty()) {\n+                                sdb.withMaximum(new BigDecimal(max));\n+                            }\n+                            String step = cx2e.options.get(ChangerX2Entry.NUMBER_STEP);\n+                            if (step != null && !step.trim().isEmpty()) {\n+                                sdb.withStep(new BigDecimal(step));\n+                            }\n+                            break;\n+                        case SELECT:\n+                            itemType = \"String\";\n+                            for (Entry<String, @Nullable String> entry : cx2e.options.entrySet()) {\n+                                String val = entry.getValue();\n+                                if (val != null) {\n+                                    sdb.withOption(new StateOption(val, entry.getKey()));\n+                                }\n+                            }\n+                            break;\n+                        default:\n+                            throw new IllegalStateException();\n+                    }\n+                    ChannelType ct = ChannelTypeBuilder\n+                            .state(new ChannelTypeUID(TACmiBindingConstants.BINDING_ID, shortName), shortName, itemType)\n+                            .withDescription(\"Auto-created for \" + shortName)\n+                            .withStateDescription(sdb.build().toStateDescription())\n+                            // .withCategory(\"CategoryName\") can we do something useful ?", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODM4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098385", "bodyText": "See above and below", "author": "fwolter", "createdAt": "2020-09-06T18:06:18Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ChangerX2Parser.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.schema.ChangerX2Entry.OptionType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'changerx2' page from the CMI and\n+ * maps it to the results\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ChangerX2Parser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangerX2Parser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        INPUT,\n+        INPUT_DATA,\n+        SELECT,\n+        SELECT_OPTION,\n+        UNKNOWN\n+    }\n+\n+    private final String channelName;\n+    private @Nullable String curOptionId;\n+    private ParserState parserState = ParserState.INIT;\n+    private @Nullable String address;\n+    private @Nullable String addressFieldName;\n+    private @Nullable String optionFieldName;\n+    private @Nullable OptionType optionType;\n+    private @Nullable StringBuilder curOptionValue;\n+    private Map<String, @Nullable String> options;\n+\n+    public ChangerX2Parser(String channelName) {\n+        super();\n+        this.options = new LinkedHashMap<>();\n+        this.channelName = channelName;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.options.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final String elementName, final Map<String, String> attributes,\n+            final boolean minimized, final int line, final int col) throws ParseException {\n+\n+        logger.info(\"Error parsing options for {}: Unexpected StandaloneElement in {}{}: {} [{}]\", channelName, line,", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODU1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098554", "bodyText": "Protocol errors shouldn't be logged to error. This could be warn. Also it seems unreasonable to log the stack trace when the network fails.", "author": "fwolter", "createdAt": "2020-09-06T18:08:20Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiSchemaHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (config.host.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (config.username.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (config.password.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        // we want to trigger the initial refresh 'at once'\n+        this.scheduledFuture = scheduler.scheduleWithFixedDelay(this::refreshData, 0, config.pollInterval,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(10000, TimeUnit.MILLISECONDS);\n+        req.header(HttpHeader.ACCEPT_LANGUAGE, \"en\"); // we want the on/off states in english\n+        final String ah = this.authHeader;\n+        if (ah != null) {\n+            req.header(HttpHeader.AUTHORIZATION, ah);\n+        }\n+        return req;\n+    }\n+\n+    protected <PP extends AbstractSimpleMarkupHandler> PP parsePage(URI uri, PP pp)\n+            throws ParseException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse response = prepareRequest(uri).send();\n+\n+        String responseString = null;\n+        String encoding = response.getEncoding();\n+        if (encoding == null || encoding.trim().isEmpty()) {\n+            // the C.M.I. dosn't sometime return a valid encoding - but it defaults to UTF-8 instead of ISO...\n+            responseString = new String(response.getContent(), StandardCharsets.UTF_8);\n+        } else {\n+            responseString = response.getContentAsString();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Response body was: {} \", responseString);\n+        }\n+\n+        final ISimpleMarkupParser parser = new SimpleMarkupParser(this.noRestrictions);\n+        parser.parse(responseString, pp);\n+        return pp;\n+    }\n+\n+    private void refreshData() {\n+        URI schemaApiPage = this.schemaApiPage;\n+        if (schemaApiPage == null) {\n+            return;\n+        }\n+        try {\n+            final ApiPageParser pp = parsePage(schemaApiPage,\n+                    new ApiPageParser(this, entries, this.channelTypeProvider));\n+\n+            if (pp.isConfigChanged()) {\n+                // we have to update our channels...\n+                final List<Channel> channels = pp.getChannels();\n+                final ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+            }\n+            if (!this.online) {\n+                updateStatus(ThingStatus.ONLINE);\n+                this.online = true;\n+            }\n+        } catch (final InterruptedException e) {\n+            // binding shutdown is in progress\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n+            this.online = false;\n+        } catch (final ParseException | TimeoutException | ExecutionException | RuntimeException e) {\n+            // we need the stack trace here to get an idea what happened when this happens to somebody and we try to\n+            // troubleshoot this\n+            logger.debug(\"Error loading API Scheme: {} \", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Error: \" + e.getMessage());\n+            this.online = false;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        final ApiPageEntry e = this.entries.get(channelUID.getId());\n+        if (command instanceof RefreshType) {\n+            if (e == null) {\n+                // This might be a race condition between the 'initial' poll / fetch not finished yet or the channel\n+                // might have been deleted in between. When the initial poll is still in progress, it will send an\n+                // update for the channel as soon as we have the data. If the channel got deleted, there is nothing we\n+                // can do.\n+                return;\n+            }\n+            // we have our ApiPageEntry which also holds our last known state - just update it.\n+            updateState(channelUID, e.getLastState());\n+            return;\n+        }\n+        if (e == null) {\n+            logger.warn(\"Got command for unknown channel {}: {}\", channelUID, command);\n+            return;\n+        }\n+        final Request reqUpdate;\n+        switch (e.type) {\n+            case SWITCH_BUTTON:\n+                reqUpdate = prepareRequest(buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + e.address + \"&changetox2=\"\n+                        + (command == OnOffType.ON ? \"1\" : \"0\")));\n+                reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                break;\n+            case SWITCH_FORM:\n+                ChangerX2Entry cx2e = e.changerX2Entry;\n+                if (cx2e != null) {\n+                    reqUpdate = prepareRequest(buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + cx2e.address\n+                            + \"&changetox2=\" + (command == OnOffType.ON ? \"1\" : \"0\")));\n+                    reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                } else {\n+                    logger.warn(\"Got command for uninitalized channel {}: {}\", channelUID, command);\n+                    return;\n+                }\n+                break;\n+            case STATE_FORM:\n+                ChangerX2Entry cx2sf = e.changerX2Entry;\n+                if (cx2sf != null) {\n+                    String val = cx2sf.options.get(((StringType) command).toFullString());\n+                    if (val != null) {\n+                        reqUpdate = prepareRequest(\n+                                buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + cx2sf.address + \"&changetox2=\" + val));\n+                        reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                    } else {\n+                        logger.warn(\"Got unknown form command {} for channel {}; Valid commands are: {}\", command,\n+                                channelUID, cx2sf.options.keySet());\n+                        return;\n+                    }\n+                } else {\n+                    logger.warn(\"Got command for uninitalized channel {}: {}\", channelUID, command);\n+                    return;\n+                }\n+                break;\n+            case READ_ONLY_NUMERIC:\n+            case READ_ONLY_STATE:\n+            case READ_ONLY_SWITCH:\n+                logger.warn(\"Got command for ReadOnly channel {}: {}\", channelUID, command);\n+                return;\n+            default:\n+                logger.warn(\"Got command for unhandled type {} channel {}: {}\", e.type, channelUID, command);\n+                return;\n+        }\n+        try {\n+            ContentResponse res = reqUpdate.send();\n+            if (res.getStatus() == 200) {\n+                // update ok, we update the state\n+                e.setLastState((State) command);\n+                updateState(channelUID, (State) command);\n+            } else {\n+                logger.error(\"Error sending update for {} = {}: {} {}\", channelUID, command, res.getStatus(),\n+                        res.getReason());\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException ex) {\n+            logger.error(\"Error sending update for {} = {}: {}\", channelUID, command, ex.getMessage(), ex);", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5ODYzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484098637", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "author": "fwolter", "createdAt": "2020-09-06T18:09:20Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiSchemaHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (config.host.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (config.username.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (config.password.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+\n+        this.authHeader = \"Basic \"\n+                + B64Code.encode(config.username + \":\" + config.password, StandardCharsets.ISO_8859_1);\n+\n+        final String serverBase = \"http://\" + config.host + \"/\";\n+        this.serverBase = serverBase;\n+        this.schemaApiPage = buildUri(\"schematic_files/\" + config.schemaId + \".cgi\");\n+\n+        refreshData();\n+        if (config.pollInterval <= 0) {\n+            config.pollInterval = 10;\n+        }\n+        // we want to trigger the initial refresh 'at once'\n+        this.scheduledFuture = scheduler.scheduleWithFixedDelay(this::refreshData, 0, config.pollInterval,\n+                TimeUnit.SECONDS);\n+    }\n+\n+    protected URI buildUri(String path) {\n+        return URI.create(serverBase + path);\n+    }\n+\n+    private Request prepareRequest(final URI uri) {\n+        final Request req = httpClient.newRequest(uri).method(HttpMethod.GET).timeout(10000, TimeUnit.MILLISECONDS);\n+        req.header(HttpHeader.ACCEPT_LANGUAGE, \"en\"); // we want the on/off states in english\n+        final String ah = this.authHeader;\n+        if (ah != null) {\n+            req.header(HttpHeader.AUTHORIZATION, ah);\n+        }\n+        return req;\n+    }\n+\n+    protected <PP extends AbstractSimpleMarkupHandler> PP parsePage(URI uri, PP pp)\n+            throws ParseException, InterruptedException, TimeoutException, ExecutionException {\n+        final ContentResponse response = prepareRequest(uri).send();\n+\n+        String responseString = null;\n+        String encoding = response.getEncoding();\n+        if (encoding == null || encoding.trim().isEmpty()) {\n+            // the C.M.I. dosn't sometime return a valid encoding - but it defaults to UTF-8 instead of ISO...\n+            responseString = new String(response.getContent(), StandardCharsets.UTF_8);\n+        } else {\n+            responseString = response.getContentAsString();\n+        }\n+\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Response body was: {} \", responseString);\n+        }\n+\n+        final ISimpleMarkupParser parser = new SimpleMarkupParser(this.noRestrictions);\n+        parser.parse(responseString, pp);\n+        return pp;\n+    }\n+\n+    private void refreshData() {\n+        URI schemaApiPage = this.schemaApiPage;\n+        if (schemaApiPage == null) {\n+            return;\n+        }\n+        try {\n+            final ApiPageParser pp = parsePage(schemaApiPage,\n+                    new ApiPageParser(this, entries, this.channelTypeProvider));\n+\n+            if (pp.isConfigChanged()) {\n+                // we have to update our channels...\n+                final List<Channel> channels = pp.getChannels();\n+                final ThingBuilder thingBuilder = editThing();\n+                thingBuilder.withChannels(channels);\n+                updateThing(thingBuilder.build());\n+            }\n+            if (!this.online) {\n+                updateStatus(ThingStatus.ONLINE);\n+                this.online = true;\n+            }\n+        } catch (final InterruptedException e) {\n+            // binding shutdown is in progress\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n+            this.online = false;\n+        } catch (final ParseException | TimeoutException | ExecutionException | RuntimeException e) {\n+            // we need the stack trace here to get an idea what happened when this happens to somebody and we try to\n+            // troubleshoot this\n+            logger.debug(\"Error loading API Scheme: {} \", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Error: \" + e.getMessage());\n+            this.online = false;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        final ApiPageEntry e = this.entries.get(channelUID.getId());\n+        if (command instanceof RefreshType) {\n+            if (e == null) {\n+                // This might be a race condition between the 'initial' poll / fetch not finished yet or the channel\n+                // might have been deleted in between. When the initial poll is still in progress, it will send an\n+                // update for the channel as soon as we have the data. If the channel got deleted, there is nothing we\n+                // can do.\n+                return;\n+            }\n+            // we have our ApiPageEntry which also holds our last known state - just update it.\n+            updateState(channelUID, e.getLastState());\n+            return;\n+        }\n+        if (e == null) {\n+            logger.warn(\"Got command for unknown channel {}: {}\", channelUID, command);\n+            return;\n+        }\n+        final Request reqUpdate;\n+        switch (e.type) {\n+            case SWITCH_BUTTON:\n+                reqUpdate = prepareRequest(buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + e.address + \"&changetox2=\"\n+                        + (command == OnOffType.ON ? \"1\" : \"0\")));\n+                reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                break;\n+            case SWITCH_FORM:\n+                ChangerX2Entry cx2e = e.changerX2Entry;\n+                if (cx2e != null) {\n+                    reqUpdate = prepareRequest(buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + cx2e.address\n+                            + \"&changetox2=\" + (command == OnOffType.ON ? \"1\" : \"0\")));\n+                    reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                } else {\n+                    logger.warn(\"Got command for uninitalized channel {}: {}\", channelUID, command);\n+                    return;\n+                }\n+                break;\n+            case STATE_FORM:\n+                ChangerX2Entry cx2sf = e.changerX2Entry;\n+                if (cx2sf != null) {\n+                    String val = cx2sf.options.get(((StringType) command).toFullString());\n+                    if (val != null) {\n+                        reqUpdate = prepareRequest(\n+                                buildUri(\"INCLUDE/change.cgi?changeadrx2=\" + cx2sf.address + \"&changetox2=\" + val));\n+                        reqUpdate.header(HttpHeader.REFERER, this.serverBase + \"schema.html\"); // required...\n+                    } else {\n+                        logger.warn(\"Got unknown form command {} for channel {}; Valid commands are: {}\", command,\n+                                channelUID, cx2sf.options.keySet());\n+                        return;\n+                    }\n+                } else {\n+                    logger.warn(\"Got command for uninitalized channel {}: {}\", channelUID, command);\n+                    return;\n+                }\n+                break;\n+            case READ_ONLY_NUMERIC:\n+            case READ_ONLY_STATE:\n+            case READ_ONLY_SWITCH:\n+                logger.warn(\"Got command for ReadOnly channel {}: {}\", channelUID, command);\n+                return;\n+            default:\n+                logger.warn(\"Got command for unhandled type {} channel {}: {}\", e.type, channelUID, command);\n+                return;\n+        }\n+        try {\n+            ContentResponse res = reqUpdate.send();\n+            if (res.getStatus() == 200) {\n+                // update ok, we update the state\n+                e.setLastState((State) command);\n+                updateState(channelUID, (State) command);\n+            } else {\n+                logger.error(\"Error sending update for {} = {}: {} {}\", channelUID, command, res.getStatus(),\n+                        res.getReason());\n+            }\n+        } catch (InterruptedException | TimeoutException | ExecutionException ex) {\n+            logger.error(\"Error sending update for {} = {}: {}\", channelUID, command, ex.getMessage(), ex);\n+        }\n+    }\n+\n+    // make it accessible for ApiPageParser\n+    @Override\n+    protected void updateState(final ChannelUID channelUID, final State state) {\n+        super.updateState(channelUID, state);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> scheduledFuture = this.scheduledFuture;\n+        if (scheduledFuture != null) {\n+            try {\n+                scheduledFuture.cancel(true);\n+                this.scheduledFuture = null;\n+            } catch (final Exception e) {", "originalCommit": "d9bc1bd3fe058ae23694227ffb55051df030e9ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyMjUyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484322529", "bodyText": "The name should not contain your binding name, but the string \"binding\".", "author": "fwolter", "createdAt": "2020-09-07T09:49:47Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread(String threadName) {\n+            super(threadName);\n+        }\n+\n+        @Override\n+        public void run() {\n+            final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+            if (coeSocket == null) {\n+                logger.warn(\"coeSocket is NULL - Reader disabled!\");\n+                return;\n+            }\n+            while (!isInterrupted()) {\n+                final byte[] receiveData = new byte[14];\n+\n+                try {\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.trace(\"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    final byte[] data = receivePacket.getData();\n+                    Message message;\n+                    if (data[1] > 0 && data[1] < 9) {\n+                        message = new AnalogMessage(data);\n+                    } else if (data[1] == 0 || data[1] == 9) {\n+                        message = new DigitalMessage(data);\n+                    } else {\n+                        logger.debug(\"Invalid message received\");\n+                        continue;\n+                    }\n+                    logger.debug(\"{}\", message.toString());\n+\n+                    final InetAddress remoteAddress = receivePacket.getAddress();\n+                    final int node = message.canNode;\n+                    boolean found = false;\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        if (cmi.isFor(remoteAddress, node)) {\n+                            cmi.handleCoE(message);\n+                            found = true;\n+                        }\n+                    }\n+                    if (!found) {\n+                        logger.debug(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                remoteAddress, node);\n+                    }\n+                } catch (final IOException e) {\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Error processing data: \" + e.getMessage());\n+\n+                } catch (RuntimeException e) {\n+                    // we catch runtime exceptions here to prevent the receiving thread to stop accidentally if\n+                    // something like a IllegalStateException or NumberFormatExceptions are thrown. This indicates a bug\n+                    // or a situation / setup I'm not thinking of ;)\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    logger.error(\"Error processing data: {}\", e.getMessage(), e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Periodically check for timeouts on the registered / active CoE channels\n+     */\n+    private void checkForTimeouts() {\n+        for (final TACmiHandler cmi : registeredCMIs) {\n+            cmi.checkForTimeout();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            // logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread(\n+                \"OH-\" + TACmiBindingConstants.BINDING_ID + \"-\" + getThing().getUID().getAsString());", "originalCommit": "fce64ebcc62e0e611dbd041f09bff65fc887d5dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1NTM4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484555386", "bodyText": "fixed...", "author": "marvkis", "createdAt": "2020-09-07T19:52:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyMjUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyMjkzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484322933", "bodyText": "One left", "author": "fwolter", "createdAt": "2020-09-07T09:50:25Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,492 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.debug(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.debug(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.debug(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.debug(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.IGNORE) {\n+                    // ignore\n+                } else {\n+                    logger.debug(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.debug(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.debug(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.debug(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DATA_ENTRY) {\n+            // we append it to our current value\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.INIT && ((len == 1 && buffer[offset] == '\\n')\n+                || (len == 2 && buffer[offset] == '\\r' && buffer[offset + 1] == '\\n'))) {\n+            // single newline - ignore/drop it...\n+        } else {\n+            String msg = new String(buffer, offset, len).replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n+            logger.debug(\"Unexpected Text {}:{}: ParserState: {} ({}) `{}`\", line, col, parserState, len, msg);\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.debug(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.debug(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently cannot be retrieved..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case BUTTON:\n+                type = Type.SWITCH_BUTTON;\n+                state = this.buttonValue == ButtonValue.ON ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case READ_ONLY:\n+            case FORM_VALUE:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.READ_ONLY_SWITCH;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SWITCH_FORM;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        // It seems for some wired cases the C.M.I. uses different decimal separators for\n+                        // different device types. It seems all 'new' X2-Devices use a dot as separator,\n+                        // for the older pre-X2 devices (i.e. the UVR 1611) we get a comma. So we\n+                        // we replace all ',' with '.' to check if it's a valid number...\n+                        String val = valParts[0].replace(',', '.');\n+                        BigDecimal bd = new BigDecimal(val);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"Hz\".equals(valParts[1])) {\n+                                channelType = \"Number:Frequency\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.HERTZ);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.debug(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.READ_ONLY_NUMERIC;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NUMERIC_FORM;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.READ_ONLY_STATE;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.STATE_FORM;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case UNKNOWN:\n+            case IGNORE:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FORM_VALUE) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser(shortName));\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final ParseException | InterruptedException | TimeoutException | ExecutionException ex) {\n+                    logger.warn(\"Error loading API Scheme: {} \", ex.getMessage(), ex);\n+                }\n+            }\n+            if (channel == null) {\n+                logger.info(\"Creating / updating channel {} of type {} for '{}'\", shortName, channelType, description);", "originalCommit": "fce64ebcc62e0e611dbd041f09bff65fc887d5dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1NTExNg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484555116", "bodyText": "I left this as info intentionally as this log only shows up when there was a configuration change on TA side that triggers channel updates on OH side. Set it to debug now.", "author": "marvkis", "createdAt": "2020-09-07T19:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyMjkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyNDU4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484324582", "bodyText": "Can you remove logging the stack trace when the network fails?", "author": "fwolter", "createdAt": "2020-09-07T09:53:18Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ApiPageParser.java", "diffHunk": "@@ -0,0 +1,492 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.math.BigDecimal;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateDescriptionFragmentBuilder;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.openhab.binding.tacmi.internal.schema.ApiPageEntry.Type;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'API' schema page from the CMI and\n+ * maps it to our channels\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ApiPageParser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ApiPageParser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        DATA_ENTRY\n+    }\n+\n+    static enum FieldType {\n+        UNKNOWN,\n+        READ_ONLY,\n+        FORM_VALUE,\n+        BUTTON,\n+        IGNORE\n+    }\n+\n+    static enum ButtonValue {\n+        UNKNOWN,\n+        ON,\n+        OFF\n+    }\n+\n+    private ParserState parserState = ParserState.INIT;\n+    private TACmiSchemaHandler taCmiSchemaHandler;\n+    private TACmiChannelTypeProvider channelTypeProvider;\n+    private boolean configChanged = false;\n+    private FieldType fieldType = FieldType.UNKNOWN;\n+    private @Nullable String id;\n+    private @Nullable String address;\n+    private @Nullable StringBuilder value;\n+    private ButtonValue buttonValue = ButtonValue.UNKNOWN;\n+    private Map<String, @Nullable ApiPageEntry> entries;\n+    private Set<String> seenNames = new HashSet<>();\n+    private List<Channel> channels = new ArrayList<>();\n+\n+    public ApiPageParser(TACmiSchemaHandler taCmiSchemaHandler, Map<String, @Nullable ApiPageEntry> entries,\n+            TACmiChannelTypeProvider channelTypeProvider) {\n+        super();\n+        this.taCmiSchemaHandler = taCmiSchemaHandler;\n+        this.entries = entries;\n+        this.channelTypeProvider = channelTypeProvider;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.seenNames.clear();\n+        this.channels.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleStandaloneElement(final @Nullable String elementName,\n+            final @Nullable Map<String, String> attributes, final boolean minimized, final int line, final int col)\n+            throws ParseException {\n+\n+        logger.debug(\"Unexpected StandaloneElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})\n+    public void handleOpenElement(final @Nullable String elementName, final @Nullable Map<String, String> attributes,\n+            final int line, final int col) throws ParseException {\n+\n+        if (this.parserState == ParserState.INIT && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.DATA_ENTRY;\n+            String classFlags;\n+            if (attributes == null) {\n+                classFlags = null;\n+                this.id = null;\n+                this.address = null;\n+            } else {\n+                this.id = attributes.get(\"id\");\n+                this.address = attributes.get(\"adresse\");\n+                classFlags = attributes.get(\"class\");\n+            }\n+            this.fieldType = FieldType.READ_ONLY;\n+            this.value = new StringBuilder();\n+            this.buttonValue = ButtonValue.UNKNOWN;\n+            if (classFlags != null && StringUtil.isNotBlank(classFlags)) {\n+                String[] classFlagList = classFlags.split(\"[ \\n\\r]\");\n+                for (String classFlag : classFlagList) {\n+                    if (\"changex2\".equals(classFlag)) {\n+                        this.fieldType = FieldType.FORM_VALUE;\n+                    } else if (\"buttonx2\".equals(classFlag) || \"taster\".equals(classFlag)) {\n+                        this.fieldType = FieldType.BUTTON;\n+                    } else if (\"visible0\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.OFF;\n+                    } else if (\"visible1\".equals(classFlag)) {\n+                        this.buttonValue = ButtonValue.ON;\n+                    } else if (\"durchsichtig\".equals(classFlag)) { // link\n+                        this.fieldType = FieldType.IGNORE;\n+                    } else if (\"bord\".equals(classFlag)) { // special button style - not of our interest...\n+                    } else {\n+                        logger.debug(\"Unhanndled class in {}:{}:{}: '{}' \", id, line, col, classFlag);\n+                    }\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.debug(\"Unexpected OpenElement in {}:{}: {} [{}]\", line, col, elementName, attributes);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState == ParserState.DATA_ENTRY && \"div\".equals(elementName)) {\n+            this.parserState = ParserState.INIT;\n+            StringBuilder sb = this.value;\n+            this.value = null;\n+            if (sb != null) {\n+                while (sb.length() > 0 && sb.charAt(0) == ' ') {\n+                    sb = sb.delete(0, 0);\n+                }\n+                if (this.fieldType == FieldType.READ_ONLY || this.fieldType == FieldType.FORM_VALUE) {\n+                    int lids = sb.lastIndexOf(\":\");\n+                    int fsp = sb.indexOf(\" \");\n+                    if (fsp < 0 || lids < 0 || fsp > lids) {\n+                        logger.debug(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sb);\n+                    } else {\n+                        String shortName = sb.substring(0, fsp).trim();\n+                        String description = sb.substring(fsp + 1, lids).trim();\n+                        String value = sb.substring(lids + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, value);\n+                    }\n+                } else if (this.fieldType == FieldType.BUTTON) {\n+                    String sbt = sb.toString().trim().replaceAll(\"[\\r\\n ]+\", \" \");\n+                    int fsp = sbt.indexOf(\" \");\n+\n+                    if (fsp < 0) {\n+                        logger.debug(\"Invalid format for setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType,\n+                                sbt);\n+                    } else {\n+                        String shortName = sbt.substring(0, fsp).trim();\n+                        String description = sbt.substring(fsp + 1).trim();\n+                        getApiPageEntry(id, line, col, shortName, description, this.buttonValue);\n+                    }\n+                } else if (this.fieldType == FieldType.IGNORE) {\n+                    // ignore\n+                } else {\n+                    logger.debug(\"Unhandled setting {}:{}:{} [{}] : {}\", id, line, col, this.fieldType, sb);\n+                }\n+            }\n+        } else if (this.parserState == ParserState.DATA_ENTRY && this.fieldType == FieldType.BUTTON\n+                && \"span\".equals(elementName)) {\n+            // ignored...\n+        } else {\n+            logger.debug(\"Unexpected CloseElement in {}:{}: {}\", line, col, elementName);\n+        }\n+    }\n+\n+    @Override\n+    public void handleAutoCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected AutoCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleUnmatchedCloseElement(final @Nullable String elementName, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected UnmatchedCloseElement in {}:{}: {}\", line, col, elementName);\n+    }\n+\n+    @Override\n+    public void handleDocType(final @Nullable String elementName, final @Nullable String publicId,\n+            final @Nullable String systemId, final @Nullable String internalSubset, final int line, final int col)\n+            throws ParseException {\n+        logger.debug(\"Unexpected DocType in {}:{}: {}/{}/{}/{}\", line, col, elementName, publicId, systemId,\n+                internalSubset);\n+    }\n+\n+    @Override\n+    public void handleComment(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.debug(\"Unexpected comment in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleCDATASection(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+        logger.debug(\"Unexpected CDATA in {}:{}: {}\", line, col, new String(buffer, offset, len));\n+    }\n+\n+    @Override\n+    public void handleText(final char @Nullable [] buffer, final int offset, final int len, final int line,\n+            final int col) throws ParseException {\n+\n+        if (buffer == null) {\n+            return;\n+        }\n+\n+        if (this.parserState == ParserState.DATA_ENTRY) {\n+            // we append it to our current value\n+            StringBuilder sb = this.value;\n+            if (sb != null) {\n+                sb.append(buffer, offset, len);\n+            }\n+        } else if (this.parserState == ParserState.INIT && ((len == 1 && buffer[offset] == '\\n')\n+                || (len == 2 && buffer[offset] == '\\r' && buffer[offset + 1] == '\\n'))) {\n+            // single newline - ignore/drop it...\n+        } else {\n+            String msg = new String(buffer, offset, len).replace(\"\\n\", \"\\\\n\").replace(\"\\r\", \"\\\\r\");\n+            logger.debug(\"Unexpected Text {}:{}: ParserState: {} ({}) `{}`\", line, col, parserState, len, msg);\n+        }\n+    }\n+\n+    @Override\n+    public void handleXmlDeclaration(final @Nullable String version, final @Nullable String encoding,\n+            final @Nullable String standalone, final int line, final int col) throws ParseException {\n+        logger.debug(\"Unexpected XML Declaration {}:{}: {} {} {}\", line, col, version, encoding, standalone);\n+    }\n+\n+    @Override\n+    public void handleProcessingInstruction(final @Nullable String target, final @Nullable String content,\n+            final int line, final int col) throws ParseException {\n+        logger.debug(\"Unexpected ProcessingInstruction {}:{}: {} {}\", line, col, target, content);\n+    }\n+\n+    private void getApiPageEntry(@Nullable String id2, int line, int col, String shortName, String description,\n+            Object value) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Found parameter {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", id, line, col, this.fieldType, shortName,\n+                    description, value);\n+        }\n+        if (!this.seenNames.add(shortName)) {\n+            logger.warn(\"Found duplicate parameter '{}' in {}:{}:{} [{}] : {} \\\"{}\\\" = {}\", shortName, id, line, col,\n+                    this.fieldType, shortName, description, value);\n+            return;\n+        }\n+\n+        if (value instanceof String && ((String) value).contains(\"can_busy\")) {\n+            return; // special state to indicate value currently cannot be retrieved..\n+        }\n+        ApiPageEntry.Type type;\n+        State state;\n+        String channelType;\n+        ChannelTypeUID ctuid;\n+        switch (this.fieldType) {\n+            case BUTTON:\n+                type = Type.SWITCH_BUTTON;\n+                state = this.buttonValue == ButtonValue.ON ? OnOffType.ON : OnOffType.OFF;\n+                ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                channelType = \"Switch\";\n+                break;\n+            case READ_ONLY:\n+            case FORM_VALUE:\n+                String vs = (String) value;\n+                boolean isOn = \"ON\".equals(vs) || \"EIN\".equals(vs); // C.M.I. mixes up languages...\n+                if (isOn || \"OFF\".equals(vs) || \"AUS\".equals(vs)) {\n+                    channelType = \"Switch\";\n+                    state = isOn ? OnOffType.ON : OnOffType.OFF;\n+                    if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RO_UID;\n+                        type = Type.READ_ONLY_SWITCH;\n+                    } else {\n+                        ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_SWITCH_RW_UID;\n+                        type = Type.SWITCH_FORM;\n+                    }\n+                } else {\n+                    try {\n+                        // check if we have a numeric value (either with or without unit)\n+                        String[] valParts = vs.split(\" \");\n+                        // It seems for some wired cases the C.M.I. uses different decimal separators for\n+                        // different device types. It seems all 'new' X2-Devices use a dot as separator,\n+                        // for the older pre-X2 devices (i.e. the UVR 1611) we get a comma. So we\n+                        // we replace all ',' with '.' to check if it's a valid number...\n+                        String val = valParts[0].replace(',', '.');\n+                        BigDecimal bd = new BigDecimal(val);\n+                        if (valParts.length == 2) {\n+                            if (\"\u00b0C\".equals(valParts[1])) {\n+                                channelType = \"Number:Temperature\";\n+                                state = new QuantityType<>(bd, SIUnits.CELSIUS);\n+                            } else if (\"%\".equals(valParts[1])) {\n+                                channelType = \"Number:Percent\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.PERCENT);\n+                            } else if (\"Imp\".equals(valParts[1])) {\n+                                // impulses - no idea how to map this to something useful here?\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                            } else if (\"V\".equals(valParts[1])) {\n+                                channelType = \"Number:Voltage\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.VOLT);\n+                            } else if (\"A\".equals(valParts[1])) {\n+                                channelType = \"Number:Current\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.AMPERE);\n+                            } else if (\"Hz\".equals(valParts[1])) {\n+                                channelType = \"Number:Frequency\";\n+                                state = new QuantityType<>(bd, SmartHomeUnits.HERTZ);\n+                            } else if (\"kW\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.WATT);\n+                            } else if (\"kWh\".equals(valParts[1])) {\n+                                channelType = \"Number:Power\";\n+                                bd = bd.multiply(new BigDecimal(1000));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.KILOWATT_HOUR);\n+                            } else if (\"l/h\".equals(valParts[1])) {\n+                                channelType = \"Number:Volume\";\n+                                bd = bd.divide(new BigDecimal(60));\n+                                state = new QuantityType<>(bd, SmartHomeUnits.LITRE_PER_MINUTE);\n+                            } else {\n+                                channelType = \"Number\";\n+                                state = new DecimalType(bd);\n+                                logger.debug(\"Unhandled UoM for channel {} of type {} for '{}': {}\", shortName,\n+                                        channelType, description, valParts[1]);\n+                            }\n+                        } else {\n+                            channelType = \"Number\";\n+                            state = new DecimalType(bd);\n+                        }\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_NUMERIC_RO_UID;\n+                            type = Type.READ_ONLY_NUMERIC;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.NUMERIC_FORM;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // not a number...\n+                        channelType = \"String\";\n+                        if (this.fieldType == FieldType.READ_ONLY || this.address == null) {\n+                            ctuid = TACmiBindingConstants.CHANNEL_TYPE_SCHEME_STATE_RO_UID;\n+                            type = Type.READ_ONLY_STATE;\n+                        } else {\n+                            ctuid = null;\n+                            type = Type.STATE_FORM;\n+                        }\n+                        state = new StringType(vs);\n+                    }\n+                }\n+                break;\n+            case UNKNOWN:\n+            case IGNORE:\n+                return;\n+            default:\n+                // should't happen but we have to add default for the compiler...\n+                return;\n+        }\n+        ApiPageEntry e = this.entries.get(shortName);\n+        if (e == null || e.type != type || !channelType.equals(e.channel.getAcceptedItemType())) {\n+            @Nullable\n+            Channel channel = this.taCmiSchemaHandler.getThing().getChannel(shortName);\n+            @Nullable\n+            ChangerX2Entry cx2e = null;\n+            if (this.fieldType == FieldType.FORM_VALUE) {\n+                try {\n+                    URI uri = this.taCmiSchemaHandler.buildUri(\"INCLUDE/changerx2.cgi?sadrx2=\" + address);\n+                    final ChangerX2Parser pp = this.taCmiSchemaHandler.parsePage(uri, new ChangerX2Parser(shortName));\n+                    cx2e = pp.getParsedEntry();\n+                } catch (final ParseException | InterruptedException | TimeoutException | ExecutionException ex) {\n+                    logger.warn(\"Error loading API Scheme: {} \", ex.getMessage(), ex);", "originalCommit": "fce64ebcc62e0e611dbd041f09bff65fc887d5dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1NTM3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r484555377", "bodyText": "I've separated the exception to network related problems which are logged without stack trace and parsing exceptions with stack trace. Is this okay? (applied / aligned on two occurrences)", "author": "marvkis", "createdAt": "2020-09-07T19:52:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyNDU4Mg=="}], "type": "inlineReview"}, {"oid": "ddf0e815f62324e12c8c713346660adfe713c715", "url": "https://github.com/openhab/openhab-addons/commit/ddf0e815f62324e12c8c713346660adfe713c715", "message": "[tacmi] Additional changes from code review: Thread name, logging & exception improvements\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-07T19:48:13Z", "type": "forcePushed"}, {"oid": "14893ca381e80f2640ec4474540d9939b2be687f", "url": "https://github.com/openhab/openhab-addons/commit/14893ca381e80f2640ec4474540d9939b2be687f", "message": "[tacmi] Apply suggestions from code review\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-07T19:53:18Z", "type": "commit"}, {"oid": "62894236718867a81a91bf41cc959e7b4f87ea44", "url": "https://github.com/openhab/openhab-addons/commit/62894236718867a81a91bf41cc959e7b4f87ea44", "message": "[tacmi] Additional changes from code review: Thread name, reduced logging output, Exception handling\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-07T19:53:22Z", "type": "commit"}, {"oid": "5f5bbed3ae12730ac573fd71acfae486012a6a35", "url": "https://github.com/openhab/openhab-addons/commit/5f5bbed3ae12730ac573fd71acfae486012a6a35", "message": "[tacmi] Additional changes from code review: Thread name, logging & exception improvements\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-07T19:53:22Z", "type": "commit"}, {"oid": "5f5bbed3ae12730ac573fd71acfae486012a6a35", "url": "https://github.com/openhab/openhab-addons/commit/5f5bbed3ae12730ac573fd71acfae486012a6a35", "message": "[tacmi] Additional changes from code review: Thread name, logging & exception improvements\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-07T19:53:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwMzQwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485103404", "bodyText": "You don't need to log this, as updateStatus() already does it.", "author": "fwolter", "createdAt": "2020-09-08T18:05:17Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -185,10 +185,12 @@ private void refreshData() {\n             // binding shutdown is in progress\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE);\n             this.online = false;\n-        } catch (final ParseException | TimeoutException | ExecutionException | RuntimeException e) {\n-            // we need the stack trace here to get an idea what happened when this happens to somebody and we try to\n-            // troubleshoot this\n-            logger.debug(\"Error loading API Scheme: {} \", e.getMessage(), e);\n+        } catch (final ParseException | RuntimeException e) {\n+            logger.warn(\"Error parsing API Scheme: {} \", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.HANDLER_INITIALIZING_ERROR, \"Error: \" + e.getMessage());\n+            this.online = false;\n+        } catch (final TimeoutException | ExecutionException e) {\n+            logger.warn(\"Error loading API Scheme: {} \", e.getMessage());", "originalCommit": "5f5bbed3ae12730ac573fd71acfae486012a6a35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4OTU5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485189598", "bodyText": "Damn, I didn't learn it. Sorry bothering you with this again... Having the logs from updateStatus() I changed the level to debug for the parser errors so when the stack trace is needed the user has to enable debug logging...", "author": "marvkis", "createdAt": "2020-09-08T20:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwMzQwNA=="}], "type": "inlineReview"}, {"oid": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "url": "https://github.com/openhab/openhab-addons/commit/c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "message": "[tacmi] Reduced logging output...\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-08T20:43:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NzE5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485497195", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = { TACmiChannelTypeProvider.class, ChannelTypeProvider.class }, immediate = true)\n          \n          \n            \n            @Component(service = { TACmiChannelTypeProvider.class, ChannelTypeProvider.class })", "author": "Hilbrand", "createdAt": "2020-09-09T10:09:53Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiChannelTypeProvider.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.type.ChannelType;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeProvider;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * Provides all ChannelTypes for the schema binding...\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { TACmiChannelTypeProvider.class, ChannelTypeProvider.class }, immediate = true)", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NzUxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485497517", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HttpClient httpClient;\n          \n          \n            \n                private TACmiChannelTypeProvider channelTypeProvider;\n          \n          \n            \n                private final HttpClient httpClient;\n          \n          \n            \n                private final TACmiChannelTypeProvider channelTypeProvider;", "author": "Hilbrand", "createdAt": "2020-09-09T10:10:26Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiHandlerFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.tacmi.internal.coe.TACmiCoEBridgeHandler;\n+import org.openhab.binding.tacmi.internal.coe.TACmiHandler;\n+import org.openhab.binding.tacmi.internal.schema.TACmiSchemaHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link TACmiHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.tacmi\", service = ThingHandlerFactory.class)\n+public class TACmiHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.unmodifiableSet(\n+            Stream.of(THING_TYPE_CMI, THING_TYPE_COE_BRIDGE, THING_TYPE_CMI_SCHEMA).collect(Collectors.toSet()));\n+\n+    private HttpClient httpClient;\n+    private TACmiChannelTypeProvider channelTypeProvider;", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5ODEwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485498101", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int typeval;\n          \n          \n            \n                private int offset;\n          \n          \n            \n                private final int typeval;\n          \n          \n            \n                private final int offset;", "author": "Hilbrand", "createdAt": "2020-09-09T10:11:29Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/TACmiMeasureType.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This enum holds all the different measures and states available to be\n+ * retrieved by the TACmi binding, including the scale factors needed to convert the received values to the real\n+ * numbers.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Wolfgang Klimt - improvements\n+ * @author Christian Niessner - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public enum TACmiMeasureType {\n+    NONE(0, 1),\n+    TEMPERATURE(1, 10),\n+    UNKNOWN2(2, 1),\n+    UNKNOWN3(3, 1),\n+    SECONDS(4, 1),\n+    UNKNOWN5(5, 1),\n+    UNKNOWN6(6, 1),\n+    UNKNOWN7(7, 1),\n+    UNKNOWN8(8, 1),\n+    UNKNOWN9(9, 1),\n+    KILOWATT(10, 100),\n+    KILOWATTHOURS(11, 10),\n+    MEGAWATTHOURS(12, 1),\n+    UNKNOWN13(13, 1),\n+    UNKNOWN14(14, 1),\n+    UNKNOWN15(15, 1),\n+    UNKNOWN16(16, 1),\n+    UNKNOWN17(17, 1),\n+    UNKNOWN18(18, 1),\n+    UNKNOWN19(19, 1),\n+    UNKNOWN20(20, 1),\n+    UNKNOWN21(21, 1),\n+\n+    UNSUPPORTED(-1, 1);\n+\n+    private int typeval;\n+    private int offset;", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5OTY4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485499680", "bodyText": "You can directly return here, and remove the local variable allInitialized:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            allInitialized = false;\n          \n          \n            \n                            return false;", "author": "Hilbrand", "createdAt": "2020-09-09T10:14:16Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodDataOutgoing.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class carries all relevant data for the POD\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PodDataOutgoing extends PodData {\n+\n+    protected long lastSent;\n+    protected final ChannelUID[] channeUIDs;\n+    protected final boolean[] initialized;\n+    private boolean allValuesInitialized;\n+\n+    /**\n+     * Create new AnalogValue with specified value and type\n+     */\n+    public PodDataOutgoing(PodIdentifier pi, byte node) {\n+        super(pi, node);\n+        boolean analog = pi.messageType == MessageType.ANALOG;\n+        int valueCount = analog ? 4 : 16;\n+        this.channeUIDs = new ChannelUID[valueCount];\n+        this.initialized = new boolean[valueCount];\n+        this.allValuesInitialized = false;\n+        this.message = analog ? new AnalogMessage(node, pi.podId) : new DigitalMessage(node, pi.podId);\n+        this.lastSent = System.currentTimeMillis();\n+    }\n+\n+    /**\n+     * checks if all (in use) values have been set to a value - used to prevent sending of unintended values via CoE\n+     */\n+    public boolean isAllValuesInitialized() {\n+        if (this.allValuesInitialized) {\n+            return true;\n+        }\n+        boolean allInitialized = true;\n+        for (int idx = 0; idx < this.initialized.length; idx++) {\n+            if (this.channeUIDs[idx] != null && !this.initialized[idx]) {\n+                allInitialized = false;", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMDYwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485500604", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int coePort = 5441;\n          \n          \n            \n                private static final int COE_PORT = 5441;", "author": "Hilbrand", "createdAt": "2020-09-09T10:16:02Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMTgxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485501810", "bodyText": "Probably most of the warn logs should be debug:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"No bridge commands defined.\");\n          \n          \n            \n                        logger.debug(\"No bridge commands defined.\");\n          \n      \n    \n    \n  \n\nSee https://www.openhab.org/docs/developer/guidelines.html#f-logging", "author": "Hilbrand", "createdAt": "2020-09-09T10:18:27Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiCoEBridgeHandler.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link TACmiCoEBridgeHandler} is the handler for a smarthomatic Bridge and\n+ * connects it to the framework. All {@link TACmiHandler}s use the\n+ * {@link TACmiCoEBridgeHandler} to execute the actual commands.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiCoEBridgeHandler extends BaseBridgeHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiCoEBridgeHandler.class);\n+\n+    /**\n+     * Port the C.M.I. uses for COE-Communication - this cannot be changed.\n+     */\n+    private static final int coePort = 5441;\n+\n+    /**\n+     * Connection socket\n+     */\n+    private @Nullable DatagramSocket coeSocket = null;\n+\n+    private @Nullable ReceiveThread receiveThread;\n+\n+    private @Nullable ScheduledFuture<?> timeoutCheckFuture;\n+\n+    private final Collection<TACmiHandler> registeredCMIs = new HashSet<>();\n+\n+    public TACmiCoEBridgeHandler(final Bridge br) {\n+        super(br);\n+    }\n+\n+    /**\n+     * Thread which receives all data from the bridge.\n+     */\n+    private class ReceiveThread extends Thread {\n+        private final Logger logger = LoggerFactory.getLogger(ReceiveThread.class);\n+\n+        ReceiveThread(String threadName) {\n+            super(threadName);\n+        }\n+\n+        @Override\n+        public void run() {\n+            final DatagramSocket coeSocket = TACmiCoEBridgeHandler.this.coeSocket;\n+            if (coeSocket == null) {\n+                logger.warn(\"coeSocket is NULL - Reader disabled!\");\n+                return;\n+            }\n+            while (!isInterrupted()) {\n+                final byte[] receiveData = new byte[14];\n+\n+                try {\n+                    final DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                    try {\n+                        coeSocket.receive(receivePacket);\n+                    } catch (final SocketTimeoutException te) {\n+                        logger.trace(\"Receive timeout on CoE socket, retrying ...\");\n+                        continue;\n+                    }\n+\n+                    final byte[] data = receivePacket.getData();\n+                    Message message;\n+                    if (data[1] > 0 && data[1] < 9) {\n+                        message = new AnalogMessage(data);\n+                    } else if (data[1] == 0 || data[1] == 9) {\n+                        message = new DigitalMessage(data);\n+                    } else {\n+                        logger.debug(\"Invalid message received\");\n+                        continue;\n+                    }\n+                    logger.debug(\"{}\", message.toString());\n+\n+                    final InetAddress remoteAddress = receivePacket.getAddress();\n+                    final int node = message.canNode;\n+                    boolean found = false;\n+                    for (final TACmiHandler cmi : registeredCMIs) {\n+                        if (cmi.isFor(remoteAddress, node)) {\n+                            cmi.handleCoE(message);\n+                            found = true;\n+                        }\n+                    }\n+                    if (!found) {\n+                        logger.debug(\"Received CoE-Packet from {} Node {} and we don't have a Thing for!\",\n+                                remoteAddress, node);\n+                    }\n+                } catch (final IOException e) {\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Error processing data: \" + e.getMessage());\n+\n+                } catch (RuntimeException e) {\n+                    // we catch runtime exceptions here to prevent the receiving thread to stop accidentally if\n+                    // something like a IllegalStateException or NumberFormatExceptions are thrown. This indicates a bug\n+                    // or a situation / setup I'm not thinking of ;)\n+                    if (isInterrupted()) {\n+                        return;\n+                    }\n+                    logger.error(\"Error processing data: {}\", e.getMessage(), e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Periodically check for timeouts on the registered / active CoE channels\n+     */\n+    private void checkForTimeouts() {\n+        for (final TACmiHandler cmi : registeredCMIs) {\n+            cmi.checkForTimeout();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        try {\n+            final DatagramSocket coeSocket = new DatagramSocket(coePort);\n+            coeSocket.setBroadcast(true);\n+            coeSocket.setSoTimeout(330000); // 300 sec is default resent-time; so we wait 330 secs\n+            this.coeSocket = coeSocket;\n+        } catch (final SocketException e) {\n+            // logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to create UDP-Socket for C.M.I. CoE bridge. Reason: \" + e.getMessage());\n+            return;\n+        }\n+\n+        ReceiveThread reciveThreadNN = new ReceiveThread(\"OH-binding-\" + getThing().getUID().getAsString());\n+        reciveThreadNN.setDaemon(true);\n+        reciveThreadNN.start();\n+        this.receiveThread = reciveThreadNN;\n+\n+        ScheduledFuture<?> timeoutCheckFuture = this.timeoutCheckFuture;\n+        if (timeoutCheckFuture == null || timeoutCheckFuture.isCancelled()) {\n+            this.timeoutCheckFuture = scheduler.scheduleWithFixedDelay(this::checkForTimeouts, 1, 1, TimeUnit.SECONDS);\n+        }\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void sendData(final byte[] pkt, final @Nullable InetAddress cmiAddress) throws IOException {\n+        final DatagramPacket packet = new DatagramPacket(pkt, pkt.length, cmiAddress, coePort);\n+        @Nullable\n+        DatagramSocket sock = this.coeSocket;\n+        if (sock == null) {\n+            throw new IOException(\"Socket is closed!\");\n+        }\n+        sock.send(packet);\n+    }\n+\n+    @Override\n+    public void handleCommand(final ChannelUID channelUID, final Command command) {\n+        if (command instanceof RefreshType) {\n+            // just forward it to the registered handlers...\n+            for (final TACmiHandler cmi : registeredCMIs) {\n+                cmi.handleCommand(channelUID, command);\n+            }\n+        } else {\n+            logger.warn(\"No bridge commands defined.\");", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwMjM5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485502397", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                protected Message message;\n          \n          \n            \n                protected @Nullable Message message;", "author": "Hilbrand", "createdAt": "2020-09-09T10:19:30Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodData.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class carries all relevant data for the POD\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PodData {\n+    protected final byte podId;\n+    protected final MessageType messageType;\n+    @Nullable\n+    protected Message message;", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTk4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485591987", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!(o instanceof PodIdentifier))\n          \n          \n            \n                        return false;\n          \n          \n            \n                    if (!(o instanceof PodIdentifier)) {\n          \n          \n            \n                        return false;\n          \n          \n            \n                    }", "author": "Hilbrand", "createdAt": "2020-09-09T13:01:11Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodIdentifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class defines a key for POD identification\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class PodIdentifier {\n+    public final MessageType messageType;\n+    public final byte podId;\n+    public final boolean outgoing;\n+\n+    /**\n+     * Create new AnalogValue with specified value and type\n+     */\n+    public PodIdentifier(MessageType messageType, byte podId, boolean outgoing) {\n+        this.messageType = messageType;\n+        if (podId < 0)\n+            throw new ArrayIndexOutOfBoundsException(podId);\n+        switch (messageType) {\n+            case ANALOG:\n+                if (podId < 1 || podId > 8)\n+                    throw new ArrayIndexOutOfBoundsException(podId);\n+                break;\n+            case DIGITAL:\n+                if (podId != 0 && podId != 9)\n+                    throw new ArrayIndexOutOfBoundsException(podId);\n+                break;\n+        }\n+        this.podId = podId;\n+        this.outgoing = outgoing;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return (this.messageType.ordinal() << 8) | podId | (outgoing ? 0x10000 : 0);\n+    }\n+\n+    @Override\n+    public boolean equals(@Nullable Object o) {\n+        if (!(o instanceof PodIdentifier))\n+            return false;", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjIzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485592238", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (podId < 0)\n          \n          \n            \n                        throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                    if (podId < 0) {\n          \n          \n            \n                        throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                    }", "author": "Hilbrand", "createdAt": "2020-09-09T13:01:33Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodIdentifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class defines a key for POD identification\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class PodIdentifier {\n+    public final MessageType messageType;\n+    public final byte podId;\n+    public final boolean outgoing;\n+\n+    /**\n+     * Create new AnalogValue with specified value and type\n+     */\n+    public PodIdentifier(MessageType messageType, byte podId, boolean outgoing) {\n+        this.messageType = messageType;\n+        if (podId < 0)\n+            throw new ArrayIndexOutOfBoundsException(podId);", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjQwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485592403", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (podId < 1 || podId > 8)\n          \n          \n            \n                                throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                            if (podId < 1 || podId > 8) {\n          \n          \n            \n                                throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                            }", "author": "Hilbrand", "createdAt": "2020-09-09T13:01:48Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodIdentifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class defines a key for POD identification\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class PodIdentifier {\n+    public final MessageType messageType;\n+    public final byte podId;\n+    public final boolean outgoing;\n+\n+    /**\n+     * Create new AnalogValue with specified value and type\n+     */\n+    public PodIdentifier(MessageType messageType, byte podId, boolean outgoing) {\n+        this.messageType = messageType;\n+        if (podId < 0)\n+            throw new ArrayIndexOutOfBoundsException(podId);\n+        switch (messageType) {\n+            case ANALOG:\n+                if (podId < 1 || podId > 8)\n+                    throw new ArrayIndexOutOfBoundsException(podId);", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjUxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485592519", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (podId != 0 && podId != 9)\n          \n          \n            \n                                throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                            if (podId != 0 && podId != 9) {\n          \n          \n            \n                                throw new ArrayIndexOutOfBoundsException(podId);\n          \n          \n            \n                            }", "author": "Hilbrand", "createdAt": "2020-09-09T13:02:00Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/PodIdentifier.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+\n+/**\n+ * This class defines a key for POD identification\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public final class PodIdentifier {\n+    public final MessageType messageType;\n+    public final byte podId;\n+    public final boolean outgoing;\n+\n+    /**\n+     * Create new AnalogValue with specified value and type\n+     */\n+    public PodIdentifier(MessageType messageType, byte podId, boolean outgoing) {\n+        this.messageType = messageType;\n+        if (podId < 0)\n+            throw new ArrayIndexOutOfBoundsException(podId);\n+        switch (messageType) {\n+            case ANALOG:\n+                if (podId < 1 || podId > 8)\n+                    throw new ArrayIndexOutOfBoundsException(podId);\n+                break;\n+            case DIGITAL:\n+                if (podId != 0 && podId != 9)\n+                    throw new ArrayIndexOutOfBoundsException(podId);", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5NTIwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485595207", "bodyText": "It should be either UNKNOWN or ONLINE with CONFIGURATION_PENDING See allowed combinations: https://www.openhab.org/docs/concepts/things.html#status-details", "author": "Hilbrand", "createdAt": "2020-09-09T13:05:54Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiMeasureType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+        this.online = false;\n+\n+        scheduler.execute(this::initializeDetached);\n+    }\n+\n+    private void initializeDetached() {\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            // message logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI for '\" + config.host + \"'\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        this.podDatas.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            final ChannelTypeUID ct = chann.getChannelTypeUID();\n+            final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                    || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+            final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                    || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+            // for the analog out channel we have the measurement type. for the input\n+            // channel we take it from the C.M.I.\n+            final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                    ? TACmiChannelConfigurationAnalog.class\n+                    : TACmiChannelConfigurationDigital.class;\n+            final TACmiChannelConfiguration channelConfig = chann.getConfiguration().as(ccClass);\n+            this.channelConfigByUID.put(chann.getUID(), channelConfig);\n+            final MessageType messageType = analog ? MessageType.ANALOG : MessageType.DIGITAL;\n+            final byte podId = this.getPodId(messageType, channelConfig.output);\n+            final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+            // initialize podData\n+            PodData pd = this.getPodData(pi);\n+            if (outgoing) {\n+                int outputIdx = getOutputIndex(channelConfig.output, analog);\n+                PodDataOutgoing podDataOutgoing = (PodDataOutgoing) pd;\n+                // we have to track value state for all outgoing channels to ensure we have valid values for all\n+                // channels in use before we send a message to the C.M.I. otherwise it could trigger some strange things\n+                // on TA side...\n+                boolean set = false;\n+                if (analog) {\n+                    TACmiChannelConfigurationAnalog ca = (TACmiChannelConfigurationAnalog) channelConfig;\n+                    Double initialValue = ca.initialValue;\n+                    if (initialValue != null) {\n+                        final TACmiMeasureType measureType = TACmiMeasureType.values()[ca.type];\n+                        final double val = initialValue.doubleValue() * measureType.getOffset();\n+                        @Nullable\n+                        Message message = pd.message;\n+                        if (message != null) {\n+                            // shouldn't happen, just in case...\n+                            message.setValue(outputIdx, (short) val, measureType.ordinal());\n+                            set = true;\n+                        }\n+                    }\n+                } else {\n+                    // digital...\n+                    TACmiChannelConfigurationDigital ca = (TACmiChannelConfigurationDigital) channelConfig;\n+                    Boolean initialValue = ca.initialValue;\n+                    if (initialValue != null) {\n+                        @Nullable\n+                        DigitalMessage message = (DigitalMessage) pd.message;\n+                        if (message != null) {\n+                            // shouldn't happen, just in case...\n+                            message.setPortState(outputIdx, initialValue);\n+                            set = true;\n+                        }\n+                    }\n+                }\n+                podDataOutgoing.channeUIDs[outputIdx] = chann.getUID();\n+                podDataOutgoing.initialized[outputIdx] = set;\n+            }\n+        }\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n+            return;\n+        }\n+        bridge.registerCMI(this);\n+        this.bridge = bridge;\n+\n+        // we set it to offline - will be set to online as soon as we start receiving\n+        // data...\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for data from the C.M.I.\");", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NDQ4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485864485", "bodyText": "Hi. I have set it to \"UNKNOWN\" there and improved the 'state machine' to have clean transitions to ONLINE or OFFLINE depending oh the situation. Did this in this commit.", "author": "marvkis", "createdAt": "2020-09-09T19:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5NTIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5NTc3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485595772", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"No Bridge configured!\");\n          \n      \n    \n    \n  \n\nSee https://www.openhab.org/docs/concepts/things.html#status-details", "author": "Hilbrand", "createdAt": "2020-09-09T13:06:45Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiMeasureType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n+        this.online = false;\n+\n+        scheduler.execute(this::initializeDetached);\n+    }\n+\n+    private void initializeDetached() {\n+        final TACmiConfiguration config = getConfigAs(TACmiConfiguration.class);\n+\n+        if (config.host == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        try {\n+            cmiAddress = InetAddress.getByName(config.host);\n+        } catch (final UnknownHostException e1) {\n+            // message logged by framework via updateStatus\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to get IP of CMI for '\" + config.host + \"'\");\n+            return;\n+        }\n+\n+        this.node = config.node;\n+\n+        // initialize lookup maps...\n+        this.channelConfigByUID.clear();\n+        this.podDatas.clear();\n+        for (final Channel chann : getThing().getChannels()) {\n+            final ChannelTypeUID ct = chann.getChannelTypeUID();\n+            final boolean analog = CHANNEL_TYPE_COE_ANALOG_IN_UID.equals(ct)\n+                    || CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct);\n+            final boolean outgoing = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                    || CHANNEL_TYPE_COE_DIGITAL_OUT_UID.equals(ct);\n+            // for the analog out channel we have the measurement type. for the input\n+            // channel we take it from the C.M.I.\n+            final Class<? extends TACmiChannelConfiguration> ccClass = CHANNEL_TYPE_COE_ANALOG_OUT_UID.equals(ct)\n+                    ? TACmiChannelConfigurationAnalog.class\n+                    : TACmiChannelConfigurationDigital.class;\n+            final TACmiChannelConfiguration channelConfig = chann.getConfiguration().as(ccClass);\n+            this.channelConfigByUID.put(chann.getUID(), channelConfig);\n+            final MessageType messageType = analog ? MessageType.ANALOG : MessageType.DIGITAL;\n+            final byte podId = this.getPodId(messageType, channelConfig.output);\n+            final PodIdentifier pi = new PodIdentifier(messageType, podId, outgoing);\n+            // initialize podData\n+            PodData pd = this.getPodData(pi);\n+            if (outgoing) {\n+                int outputIdx = getOutputIndex(channelConfig.output, analog);\n+                PodDataOutgoing podDataOutgoing = (PodDataOutgoing) pd;\n+                // we have to track value state for all outgoing channels to ensure we have valid values for all\n+                // channels in use before we send a message to the C.M.I. otherwise it could trigger some strange things\n+                // on TA side...\n+                boolean set = false;\n+                if (analog) {\n+                    TACmiChannelConfigurationAnalog ca = (TACmiChannelConfigurationAnalog) channelConfig;\n+                    Double initialValue = ca.initialValue;\n+                    if (initialValue != null) {\n+                        final TACmiMeasureType measureType = TACmiMeasureType.values()[ca.type];\n+                        final double val = initialValue.doubleValue() * measureType.getOffset();\n+                        @Nullable\n+                        Message message = pd.message;\n+                        if (message != null) {\n+                            // shouldn't happen, just in case...\n+                            message.setValue(outputIdx, (short) val, measureType.ordinal());\n+                            set = true;\n+                        }\n+                    }\n+                } else {\n+                    // digital...\n+                    TACmiChannelConfigurationDigital ca = (TACmiChannelConfigurationDigital) channelConfig;\n+                    Boolean initialValue = ca.initialValue;\n+                    if (initialValue != null) {\n+                        @Nullable\n+                        DigitalMessage message = (DigitalMessage) pd.message;\n+                        if (message != null) {\n+                            // shouldn't happen, just in case...\n+                            message.setPortState(outputIdx, initialValue);\n+                            set = true;\n+                        }\n+                    }\n+                }\n+                podDataOutgoing.channeUIDs[outputIdx] = chann.getUID();\n+                podDataOutgoing.initialized[outputIdx] = set;\n+            }\n+        }\n+\n+        final Bridge br = getBridge();\n+        final TACmiCoEBridgeHandler bridge = br == null ? null : (TACmiCoEBridgeHandler) br.getHandler();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED, \"No Bridge configured!\");", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5Nzg0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485597846", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n          \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN);", "author": "Hilbrand", "createdAt": "2020-09-09T13:09:48Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/coe/TACmiHandler.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.coe;\n+\n+import static org.openhab.binding.tacmi.internal.TACmiBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiBindingConstants;\n+import org.openhab.binding.tacmi.internal.TACmiMeasureType;\n+import org.openhab.binding.tacmi.internal.message.AnalogMessage;\n+import org.openhab.binding.tacmi.internal.message.AnalogValue;\n+import org.openhab.binding.tacmi.internal.message.DigitalMessage;\n+import org.openhab.binding.tacmi.internal.message.Message;\n+import org.openhab.binding.tacmi.internal.message.MessageType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Timo Wendt - Initial contribution\n+ * @author Christian Niessner - Ported to OpenHAB2\n+ */\n+@NonNullByDefault\n+public class TACmiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiHandler.class);\n+\n+    private final Map<@Nullable PodIdentifier, @Nullable PodData> podDatas = new HashMap<>();\n+    private final Map<@Nullable ChannelUID, @Nullable TACmiChannelConfiguration> channelConfigByUID = new HashMap<>();\n+\n+    private @Nullable TACmiCoEBridgeHandler bridge;\n+    private long lastMessageRecvTS; // last received message timestamp\n+    private boolean online; // online status shadow\n+\n+    /**\n+     * the C.M.I.'s address\n+     */\n+    private @Nullable InetAddress cmiAddress;\n+\n+    /**\n+     * the CoE CAN-Node we representing\n+     */\n+    private int node;\n+\n+    public TACmiHandler(final Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY4Mjg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485682858", "bodyText": "NonNullByDefault should normally not be set on methods.", "author": "Hilbrand", "createdAt": "2020-09-09T15:01:08Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/ChangerX2Parser.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.tacmi.internal.schema.ChangerX2Entry.OptionType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link ApiPageParser} class parses the 'changerx2' page from the CMI and\n+ * maps it to the results\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ChangerX2Parser extends AbstractSimpleMarkupHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ChangerX2Parser.class);\n+\n+    static enum ParserState {\n+        INIT,\n+        INPUT,\n+        INPUT_DATA,\n+        SELECT,\n+        SELECT_OPTION,\n+        UNKNOWN\n+    }\n+\n+    private final String channelName;\n+    private @Nullable String curOptionId;\n+    private ParserState parserState = ParserState.INIT;\n+    private @Nullable String address;\n+    private @Nullable String addressFieldName;\n+    private @Nullable String optionFieldName;\n+    private @Nullable OptionType optionType;\n+    private @Nullable StringBuilder curOptionValue;\n+    private Map<String, @Nullable String> options;\n+\n+    public ChangerX2Parser(String channelName) {\n+        super();\n+        this.options = new LinkedHashMap<>();\n+        this.channelName = channelName;\n+    }\n+\n+    @Override\n+    public void handleDocumentStart(final long startTimeNanos, final int line, final int col) throws ParseException {\n+        this.parserState = ParserState.INIT;\n+        this.options.clear();\n+    }\n+\n+    @Override\n+    public void handleDocumentEnd(final long endTimeNanos, final long totalTimeNanos, final int line, final int col)\n+            throws ParseException {\n+        if (this.parserState != ParserState.INIT) {\n+            logger.debug(\"Parserstate == Init expected, but is {}\", this.parserState);\n+        }\n+    }\n+\n+    @Override\n+    @NonNullByDefault({})", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg3Mjk5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485872997", "bodyText": "We had trouble finding a proper way to annotate the Map<> in the (inherited) method definition properly with @Nullable - all our testes ended with errors like \"Illegal redefinition of parameter attributes, inherited method from AbstractSimpleMarkupHandler declares this parameter as 'Map<String,String>' (mismatching null constraints)\". When you review the discussion here in the PR it was quite a topic. Key comments on this are here and here. If you have a better idea to solve this just enlighten me ;)", "author": "marvkis", "createdAt": "2020-09-09T19:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY4Mjg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg5MDkwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485890900", "bodyText": "Regarding the map I suspect it might need to be some combination of Nullable placed somewhere:\n@Nullable Map<@Nullable String, @Nullable String>", "author": "Hilbrand", "createdAt": "2020-09-09T20:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY4Mjg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg5NzMzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485897335", "bodyText": "I tried quite every variant making sense, but I wasn't able to get it working. This is for the variant you suggested:\n\nWhen compiling on the command line with mvn it shows the same error...", "author": "marvkis", "createdAt": "2020-09-09T20:18:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY4Mjg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY4NzIwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7768#discussion_r485687208", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);\n          \n          \n            \n                    updateStatus(ThingStatus.UNKOWN);", "author": "Hilbrand", "createdAt": "2020-09-09T15:07:03Z", "path": "bundles/org.openhab.binding.tacmi/src/main/java/org/openhab/binding/tacmi/internal/schema/TACmiSchemaHandler.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.tacmi.internal.schema;\n+\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.attoparser.ParseException;\n+import org.attoparser.config.ParseConfiguration;\n+import org.attoparser.config.ParseConfiguration.ElementBalancing;\n+import org.attoparser.config.ParseConfiguration.UniqueRootElementPresence;\n+import org.attoparser.simple.AbstractSimpleMarkupHandler;\n+import org.attoparser.simple.ISimpleMarkupParser;\n+import org.attoparser.simple.SimpleMarkupParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpHeader;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.util.B64Code;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.builder.ThingBuilder;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.tacmi.internal.TACmiChannelTypeProvider;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link TACmiSchemaHandler} is responsible for handling commands, which are sent\n+ * to one of the channels.\n+ *\n+ * @author Christian Niessner - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TACmiSchemaHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(TACmiSchemaHandler.class);\n+\n+    private final HttpClient httpClient;\n+    private final TACmiChannelTypeProvider channelTypeProvider;\n+    private final Map<String, @Nullable ApiPageEntry> entries = new HashMap<>();\n+    private boolean online;\n+    private @Nullable String serverBase;\n+    private @Nullable URI schemaApiPage;\n+    private @Nullable String authHeader;\n+    private @Nullable ScheduledFuture<?> scheduledFuture;\n+    private final ParseConfiguration noRestrictions;\n+\n+    public TACmiSchemaHandler(final Thing thing, final HttpClient httpClient,\n+            final TACmiChannelTypeProvider channelTypeProvider) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.channelTypeProvider = channelTypeProvider;\n+\n+        // the default configuration for the parser\n+        this.noRestrictions = ParseConfiguration.xmlConfiguration();\n+        this.noRestrictions.setElementBalancing(ElementBalancing.NO_BALANCING);\n+        this.noRestrictions.setNoUnmatchedCloseElementsRequired(false);\n+        this.noRestrictions.setUniqueAttributesInElementRequired(false);\n+        this.noRestrictions.setXmlWellFormedAttributeValuesRequired(false);\n+        this.noRestrictions.setUniqueRootElementPresence(UniqueRootElementPresence.NOT_VALIDATED);\n+        this.noRestrictions.getPrologParseConfiguration().setValidateProlog(false);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        final TACmiSchemaConfiguration config = getConfigAs(TACmiSchemaConfiguration.class);\n+\n+        if (config.host.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No host configured!\");\n+            return;\n+        }\n+        if (config.username.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No username configured!\");\n+            return;\n+        }\n+        if (config.password.trim().isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No password configured!\");\n+            return;\n+        }\n+        this.online = false;\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING);", "originalCommit": "c79ed2a922804c354cc8771550dad2bd9f2d4e9e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6f5f9a1c66f08d3464d6c2a753ebbf10ce494f90", "url": "https://github.com/openhab/openhab-addons/commit/6f5f9a1c66f08d3464d6c2a753ebbf10ce494f90", "message": "[tacmi] Apply suggestions from code review: code formatting and some framework usage cleanups\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-09T19:29:42Z", "type": "commit"}, {"oid": "222858f140a0dd9cda93655077aae946d0ea0e86", "url": "https://github.com/openhab/openhab-addons/commit/222858f140a0dd9cda93655077aae946d0ea0e86", "message": "[tacmi] TACmiHandler - improved thing states and transitions\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-09T19:30:04Z", "type": "commit"}, {"oid": "92eb6cfdea9f8402d194087bb091295fe684121d", "url": "https://github.com/openhab/openhab-addons/commit/92eb6cfdea9f8402d194087bb091295fe684121d", "message": "[tacmi] Additional cleanups & improvements from review\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-09T19:30:04Z", "type": "commit"}, {"oid": "92eb6cfdea9f8402d194087bb091295fe684121d", "url": "https://github.com/openhab/openhab-addons/commit/92eb6cfdea9f8402d194087bb091295fe684121d", "message": "[tacmi] Additional cleanups & improvements from review\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-09T19:30:04Z", "type": "forcePushed"}, {"oid": "cd25457ac913a7324ee110588cb2b122581ed27a", "url": "https://github.com/openhab/openhab-addons/commit/cd25457ac913a7324ee110588cb2b122581ed27a", "message": "[tacmi] logging: changed some more loggings from warn to debug\n\nSigned-off-by: Christian Niessner <github-marvkis@christian-niessner.de>", "committedDate": "2020-09-09T20:25:33Z", "type": "commit"}]}