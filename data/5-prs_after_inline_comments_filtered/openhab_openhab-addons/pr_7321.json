{"pr_number": 7321, "pr_title": "[smhi] Smhi binding initial contribution", "pr_createdAt": "2020-04-08T07:02:24Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7321", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0NTYyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428245623", "bodyText": "You seem to have a more recent branch \"smhi\" in your personal repo in which this code formatting issue is fixed. Which branch do you want to get merged?", "author": "fwolter", "createdAt": "2020-05-20T19:06:48Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Map;\n+\n+\n+/**\n+ * A class containing a forecast for a specific point in time.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Forecast implements Comparable<Forecast> {\n+    protected ZonedDateTime validTime;\n+    private Map<String, @Nullable BigDecimal> parameters;\n+\n+    public Forecast(ZonedDateTime validTime, Map<String, @Nullable BigDecimal> parameters) {\n+        this.validTime = validTime;\n+        this.parameters = parameters;\n+    }\n+\n+    public ZonedDateTime getValidTime() {\n+        return validTime;\n+    }\n+\n+    public Map<String, @Nullable BigDecimal> getParameters() {\n+        return parameters;\n+    }\n+\n+    public @Nullable BigDecimal getParameter(String parameter) { return parameters.get(parameter); }", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUwNjY0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428506649", "bodyText": "I made a separate pr-branch so I could squash all commits when making the pr, but still keep the commit history in my own branch. Perhaps there is a better way to do this? I've then continued to make some improvements in the other branch (applied spotless, which is probably what solved this). Can pull them in here as well.", "author": "pacive", "createdAt": "2020-05-21T08:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0NTYyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0ODAzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428748039", "bodyText": "You should definitly push them here, that they get merged, too.", "author": "fwolter", "createdAt": "2020-05-21T15:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0NTYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0Njg5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428246897", "bodyText": "I think it's better practise to write the explicit classes. See Eclipse \"organize imports\".", "author": "fwolter", "createdAt": "2020-05-20T19:08:59Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import com.google.gson.*;", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUxMTIyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428511226", "bodyText": "Intellij automatically switches to a wildcard import when there's several (more than 3 i think) imports from the same package. Can change it to be more explicit.", "author": "pacive", "createdAt": "2020-05-21T08:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0Njg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0ODcxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428748716", "bodyText": "Ok, read some discussions about that. I'm wondering what the other reviewers will say.", "author": "fwolter", "createdAt": "2020-05-21T15:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0Njg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0Njk2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428246964", "bodyText": "See above.", "author": "fwolter", "createdAt": "2020-05-20T19:09:05Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import com.google.gson.*;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.*;", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0ODgzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428248839", "bodyText": "You could have had some fun with Java streams here. Next time...", "author": "fwolter", "createdAt": "2020-05-20T19:12:27Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import com.google.gson.*;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * Class with static methods for parsing json strings returned from Smhi\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Parser {\n+\n+    private static JsonParser parser = new JsonParser();\n+\n+    /**\n+     * Parse a json string received from Smhi containing forecasts.\n+     * @param json A json string\n+     * @return A {@link TimeSeries} object\n+     */\n+    public static TimeSeries parseTimeSeries(String json) {\n+        ZonedDateTime referenceTime;\n+        List<Forecast> forecasts = new ArrayList<>();\n+        JsonObject object = parser.parse(json).getAsJsonObject();\n+\n+        referenceTime = parseApprovedTime(json);\n+        JsonArray timeSeries = object.get(\"timeSeries\").getAsJsonArray();\n+\n+        timeSeries.forEach(element -> {\n+            forecasts.add(parseForecast(element.getAsJsonObject()));\n+        });\n+\n+        forecasts.sort(Comparator.naturalOrder());", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU0MTExNA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428541114", "bodyText": "I definitely need to read up more on streams, but when I experimented a bit here it seems that gson JsonArray doesn't support the stream() method. Is there another way to use it with an arbitrary \u00ccterable<>(which is whatJsonArray` implements)?", "author": "pacive", "createdAt": "2020-05-21T09:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0ODgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0OTIwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428749204", "bodyText": "You can do Stream.of(timeSeries) to get a stream. Then, you may want to use map().", "author": "fwolter", "createdAt": "2020-05-21T15:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0ODgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA2NDMyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r429064327", "bodyText": "Didn't work with Stream.of() but thanks to Stack Overflow I found you need to go via StreamSupport.stream(timeSeries.spliterator(), false)", "author": "pacive", "createdAt": "2020-05-22T06:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0ODgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MDEyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428250126", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-20T19:14:44Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU0MTk5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428541994", "bodyText": "This is not the same as the others since it's a static import of the binding constants. I don't need to import them individually, do I?", "author": "pacive", "createdAt": "2020-05-21T09:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MDEyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0OTczMg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428749732", "bodyText": "You are totally right. Please ignore my comment.", "author": "fwolter", "createdAt": "2020-05-21T15:57:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MDEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MjY5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428252693", "bodyText": "Throwing an unchecked Exception from a binding is evil. You should handle the error appropriately and log it with log.warn().", "author": "fwolter", "createdAt": "2020-05-20T19:19:33Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * Class for handling http requests to Smhi's API and return values.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiConnector.class);\n+\n+    private static final String ACCEPT = \"application/json\";\n+\n+    private final HttpClient httpClient;\n+\n+    public SmhiConnector(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Get the reference time (the time when the forecast starts) of the latest published forecast\n+     * @return A {@link ZonedDateTime} with the time of the latest forecast.\n+     */\n+    public ZonedDateTime getReferenceTime() {\n+        logger.debug(\"Fetching reference time\");\n+        Request req = httpClient.newRequest(APPROVED_TIME_URL);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwNDEzNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r429204135", "bodyText": "Didn't know about checked vs unchecked exceptions, thanks for enlightening me :). Would altering SmhiException to extend Exception instead of RuntimeException be better?", "author": "pacive", "createdAt": "2020-05-22T11:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MjY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMyNzU5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r429327590", "bodyText": "That would be a checked Exception, then. So, yes, this would be better!", "author": "fwolter", "createdAt": "2020-05-22T15:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MjY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MzAxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428253017", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-20T19:20:04Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * Class for handling http requests to Smhi's API and return values.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiConnector.class);\n+\n+    private static final String ACCEPT = \"application/json\";\n+\n+    private final HttpClient httpClient;\n+\n+    public SmhiConnector(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Get the reference time (the time when the forecast starts) of the latest published forecast\n+     * @return A {@link ZonedDateTime} with the time of the latest forecast.\n+     */\n+    public ZonedDateTime getReferenceTime() {\n+        logger.debug(\"Fetching reference time\");\n+        Request req = httpClient.newRequest(APPROVED_TIME_URL);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();\n+        }\n+        return Parser.parseApprovedTime(resp.getContentAsString());\n+    }\n+\n+    /**\n+     * Get a forecast for the specified WGS84 coordinates.\n+     * @param lat Latitude\n+     * @param lon Longitude\n+     * @return A {@link TimeSeries} object containing the published forecasts.\n+     */\n+    public TimeSeries getForecast(double lat, double lon) {\n+        logger.debug(\"Fetching new forecast\");\n+        String url = String.format(POINT_FORECAST_URL, lon, lat);\n+        Request req = httpClient.newRequest(url);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1Mzk0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428253948", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-20T19:21:47Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1NDAzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428254038", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-20T19:21:57Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwOTI2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428609260", "bodyText": "Also for binding constants", "author": "pacive", "createdAt": "2020-05-21T12:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1NDAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1NTc1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428255751", "bodyText": "This timer is not canceled when the addon is disposed. Although this is a one-shot, it's good practise to cancel it explicitly.", "author": "fwolter", "createdAt": "2020-05-20T19:25:19Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1OTAwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428259009", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Start polling wor updated weather forecast.\n          \n          \n            \n                 * Start polling for updated weather forecast.", "author": "fwolter", "createdAt": "2020-05-20T19:31:43Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        //Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling wor updated weather forecast.", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NDQzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428264439", "bodyText": "It's bad practise to throw unchecked Exceptions on expected errors, because the compiler do not forces you (or any other developer) to handle the error when using getForecast(). Better throw a custom exception (e.g. SmhiException, extending Exception.", "author": "fwolter", "createdAt": "2020-05-20T19:42:21Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        //Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling wor updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast;\n+            try {\n+                forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+            } catch (NoSuchElementException e) {", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU2Nzk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428567978", "bodyText": "I thought this was the most appropriate exception to throw, since it's what's being thrown by Iterator.next() when there are no more elements (which is basically what happens here if the time is too far off). Will change to return null instead of throwing an exception and check for that instead.", "author": "pacive", "createdAt": "2020-05-21T10:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc1MzQxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428753416", "bodyText": "NoSuchElementException is an unchecked Exception, which should only raise if there is a bug in your code. Returning null is ok, IMHO. You could also return Optional<Forecast>. And if there is no Forecast available, you return Optional.empty().", "author": "fwolter", "createdAt": "2020-05-21T16:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NDQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2Njk4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428266986", "bodyText": "What type of exception are you catching here? If you want to catch a RuntimeException, you should catch for the exact type.", "author": "fwolter", "createdAt": "2020-05-20T19:47:20Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        //Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling wor updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast;\n+            try {\n+                forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+            } catch (NoSuchElementException e) {\n+                logger.info(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+                continue;\n+            }\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        try {\n+            if (isItNewHour()) {\n+                currentHour = calculateCurrentHour();\n+                currentDay = calculateCurrentDay();\n+                // Update channels with cached forecasts - just shift an hour forward\n+                TimeSeries forecast = cachedTimeSeries;\n+                if (forecast != null) {\n+                    updateChannels(forecast);\n+                }\n+                hasLatestForecast = false;\n+            }\n+            if (!hasLatestForecast && isForecastUpdated()) {\n+                getUpdatedForecast();\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Something went wrong: \", e);", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU1MDk1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428550956", "bodyText": "This was to catch the exceptions thrown by getReferenceTime() and getForecast(), but thought I would make sure to not miss anything. Have caught these in other methods now though, so might be able to remove this now. Will require some testing to make sure nothing breaks.", "author": "pacive", "createdAt": "2020-05-21T09:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2Njk4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc1NTEwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428755104", "bodyText": "Here you see the disadvantage about unchecked Exceptions. If you would throw a checked Exception, the compiler would complain if you miss to catch the Exception here.", "author": "fwolter", "createdAt": "2020-05-21T16:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2Njk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NzY3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428267677", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-20T19:48:42Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandlerFactory.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwOTUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428609503", "bodyText": "Constants", "author": "pacive", "createdAt": "2020-05-21T12:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NzY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NzkxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428267915", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-20T19:49:10Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/TimeSeries.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.time.ZonedDateTime;\n+import java.util.*;", "originalCommit": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a80922a250de450769a356fc3c1fd94d12d29f45", "url": "https://github.com/openhab/openhab-addons/commit/a80922a250de450769a356fc3c1fd94d12d29f45", "message": "Initial contribution\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-05-22T13:19:09Z", "type": "commit"}, {"oid": "3d937511f2336a2696f2c2e7c9a0ef4a057fa870", "url": "https://github.com/openhab/openhab-addons/commit/3d937511f2336a2696f2c2e7c9a0ef4a057fa870", "message": "Apply spotless check\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-05-22T13:19:10Z", "type": "commit"}, {"oid": "3c2bfdbf4f1c72dd1e84b9b152dc95ca6459bbd1", "url": "https://github.com/openhab/openhab-addons/commit/3c2bfdbf4f1c72dd1e84b9b152dc95ca6459bbd1", "message": "Bump OH version\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-05-22T13:19:10Z", "type": "commit"}, {"oid": "ce5756e4ae27d15f94c2dafaa1b6bb42ed468e5e", "url": "https://github.com/openhab/openhab-addons/commit/ce5756e4ae27d15f94c2dafaa1b6bb42ed468e5e", "message": "Use explicit imports\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-05-22T13:19:10Z", "type": "commit"}, {"oid": "9dc268556a10edf32791015ba499006820297240", "url": "https://github.com/openhab/openhab-addons/commit/9dc268556a10edf32791015ba499006820297240", "message": "Changes requested in code review\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-05-23T07:13:38Z", "type": "commit"}, {"oid": "9dc268556a10edf32791015ba499006820297240", "url": "https://github.com/openhab/openhab-addons/commit/9dc268556a10edf32791015ba499006820297240", "message": "Changes requested in code review\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-05-23T07:13:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2NzAxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r430067018", "bodyText": "You should pass the exception to SmhiException to be able to produce an appropriate error message. Or log it here.", "author": "fwolter", "createdAt": "2020-05-25T20:27:50Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for handling http requests to Smhi's API and return values.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiConnector.class);\n+\n+    private static final String ACCEPT = \"application/json\";\n+\n+    private final HttpClient httpClient;\n+\n+    public SmhiConnector(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Get the reference time (the time when the forecast starts) of the latest published forecast\n+     * \n+     * @return A {@link ZonedDateTime} with the time of the latest forecast.\n+     */\n+    public ZonedDateTime getReferenceTime() throws SmhiException {\n+        logger.debug(\"Fetching reference time\");\n+        Request req = httpClient.newRequest(APPROVED_TIME_URL);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();", "originalCommit": "9dc268556a10edf32791015ba499006820297240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2NzE1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r430067150", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-25T20:28:33Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for handling http requests to Smhi's API and return values.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiConnector.class);\n+\n+    private static final String ACCEPT = \"application/json\";\n+\n+    private final HttpClient httpClient;\n+\n+    public SmhiConnector(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Get the reference time (the time when the forecast starts) of the latest published forecast\n+     * \n+     * @return A {@link ZonedDateTime} with the time of the latest forecast.\n+     */\n+    public ZonedDateTime getReferenceTime() throws SmhiException {\n+        logger.debug(\"Fetching reference time\");\n+        Request req = httpClient.newRequest(APPROVED_TIME_URL);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();\n+        }\n+        return Parser.parseApprovedTime(resp.getContentAsString());\n+    }\n+\n+    /**\n+     * Get a forecast for the specified WGS84 coordinates.\n+     * \n+     * @param lat Latitude\n+     * @param lon Longitude\n+     * @return A {@link TimeSeries} object containing the published forecasts.\n+     */\n+    public TimeSeries getForecast(double lat, double lon) throws SmhiException {\n+        logger.debug(\"Fetching new forecast\");\n+        String url = String.format(POINT_FORECAST_URL, lon, lat);\n+        Request req = httpClient.newRequest(url);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();", "originalCommit": "9dc268556a10edf32791015ba499006820297240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2ODcxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r430068711", "bodyText": "You should make this Nullable. I have seen handleCommand() to be invoked asynchronously, before initialize() has been finished.", "author": "fwolter", "createdAt": "2020-05-25T20:36:26Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;", "originalCommit": "9dc268556a10edf32791015ba499006820297240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "65efd486a19e3a24ccfbabf095f9396774621e30", "url": "https://github.com/openhab/openhab-addons/commit/65efd486a19e3a24ccfbabf095f9396774621e30", "message": "Capitalize labels\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-05-26T16:30:55Z", "type": "commit"}, {"oid": "04caeadd78674cdd127b76897a0e145f91cf5066", "url": "https://github.com/openhab/openhab-addons/commit/04caeadd78674cdd127b76897a0e145f91cf5066", "message": "Improve exceptions\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-05-26T16:31:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4ODI0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r432088242", "bodyText": "When using these constructers, getCause() will return null and throw a NPE in SmhiHandler.java:306. Since these constructors are not used, I would remove them.", "author": "fwolter", "createdAt": "2020-05-28T19:58:22Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiException.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiException extends Exception {\n+\n+    private static final long serialVersionUID = 516565331L;\n+\n+    public SmhiException() {\n+        super();\n+    }\n+\n+    public SmhiException(String message) {\n+        super(message);\n+    }", "originalCommit": "04caeadd78674cdd127b76897a0e145f91cf5066", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "096d8f47028e888178d56b371172a883987d73c9", "url": "https://github.com/openhab/openhab-addons/commit/096d8f47028e888178d56b371172a883987d73c9", "message": "Remove unused constructors from SmhiException\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-05-29T15:25:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5ODQyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437798420", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected ZonedDateTime validTime;\n          \n          \n            \n                private Map<String, @Nullable BigDecimal> parameters;\n          \n          \n            \n                protected final ZonedDateTime validTime;\n          \n          \n            \n                private final Map<String, @Nullable BigDecimal> parameters;", "author": "cpmeister", "createdAt": "2020-06-10T00:44:21Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A class containing a forecast for a specific point in time.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Forecast implements Comparable<Forecast> {\n+    protected ZonedDateTime validTime;\n+    private Map<String, @Nullable BigDecimal> parameters;", "originalCommit": "096d8f47028e888178d56b371172a883987d73c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMzUxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437803518", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-06-10T01:04:16Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link SmhiConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+public class SmhiConfiguration {", "originalCommit": "096d8f47028e888178d56b371172a883987d73c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMzc0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437803747", "bodyText": "A canceled future is considered done.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n          \n          \n            \n                            if (localRef == null || localRef.isDone()) {", "author": "cpmeister", "createdAt": "2020-06-10T01:05:14Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {", "originalCommit": "096d8f47028e888178d56b371172a883987d73c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwNjIyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437806222", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Iterator<Forecast> iterator = forecasts.iterator();\n          \n          \n            \n            \n          \n          \n            \n                    while (iterator.hasNext()) {\n          \n          \n            \n                        Forecast forecast = iterator.next();\n          \n          \n            \n                        if (forecast.getValidTime().compareTo(startTime.plusHours(hourOffset)) >= 0) {\n          \n          \n            \n                            return forecast;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return null;\n          \n          \n            \n                    for(Forecast forecast : forecasts){\n          \n          \n            \n                        if (forecast.getValidTime().compareTo(startTime.plusHours(hourOffset)) >= 0) {\n          \n          \n            \n                            return forecast;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return null;", "author": "cpmeister", "createdAt": "2020-06-10T01:15:28Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/TimeSeries.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import java.time.ZonedDateTime;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Spliterator;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A collection class with utility methods to retrieve forecasts pertaining to a specified time.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TimeSeries implements Iterable<Forecast> {\n+\n+    private ZonedDateTime referenceTime;\n+    private List<Forecast> forecasts;\n+\n+    public TimeSeries(ZonedDateTime referenceTime, List<Forecast> forecasts) {\n+        this.referenceTime = referenceTime;\n+        this.forecasts = forecasts;\n+    }\n+\n+    public ZonedDateTime getReferenceTime() {\n+        return referenceTime;\n+    }\n+\n+    /**\n+     * Retrieves the first {@link Forecast} that is equal to or after offset time (from now).\n+     *\n+     * @param hourOffset number of hours after now.\n+     * @return\n+     */\n+    public @Nullable Forecast getForecast(int hourOffset) {\n+        return getForecast(ZonedDateTime.now(), hourOffset);\n+    }\n+\n+    /**\n+     * Retrieves the first {@link Forecast} that is equal to or after the offset time (from startTime).\n+     *\n+     * @param hourOffset number of hours after now.\n+     * @return\n+     */\n+    public @Nullable Forecast getForecast(ZonedDateTime startTime, int hourOffset) {\n+        if (hourOffset < 0) {\n+            throw new IllegalArgumentException(\"Offset must be at least 0\");\n+        }\n+\n+        Iterator<Forecast> iterator = forecasts.iterator();\n+\n+        while (iterator.hasNext()) {\n+            Forecast forecast = iterator.next();\n+            if (forecast.getValidTime().compareTo(startTime.plusHours(hourOffset)) >= 0) {\n+                return forecast;\n+            }\n+        }\n+        return null;", "originalCommit": "096d8f47028e888178d56b371172a883987d73c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxMDUzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437810536", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n          \n          \n            \n                            logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));", "author": "cpmeister", "createdAt": "2020-06-10T01:32:13Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.info(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));", "originalCommit": "096d8f47028e888178d56b371172a883987d73c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxMTM3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437811379", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n          \n          \n            \n                        if (localRef == null || localRef.isDone()) {", "author": "cpmeister", "createdAt": "2020-06-10T01:35:32Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {", "originalCommit": "096d8f47028e888178d56b371172a883987d73c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b5407cc720a4f0039e1f90d78be584523242eb19", "url": "https://github.com/openhab/openhab-addons/commit/b5407cc720a4f0039e1f90d78be584523242eb19", "message": "Changes requested in review + clear some warnings\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-06-10T12:42:14Z", "type": "commit"}, {"oid": "9d865653ef2800a9eedf242941937164aefaa069", "url": "https://github.com/openhab/openhab-addons/commit/9d865653ef2800a9eedf242941937164aefaa069", "message": "Implement UoM\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-06-10T12:42:34Z", "type": "commit"}, {"oid": "086a20070bdf370b51d38471f065dda2cb862ded", "url": "https://github.com/openhab/openhab-addons/commit/086a20070bdf370b51d38471f065dda2cb862ded", "message": "Update README after adding UoM\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-06-11T17:08:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2MjAyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439662028", "bodyText": "I think you are incorrectly trying to map the percent unit to be in the 0.0-1.0 range instead of the 0-100 range.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final BigDecimal OCTAS_TO_PERCENT = BigDecimal.valueOf(0.08);\n          \n          \n            \n                public static final BigDecimal OCTAS_TO_PERCENT = BigDecimal.valueOf(8);", "author": "cpmeister", "createdAt": "2020-06-12T22:10:53Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiBindingConstants.java", "diffHunk": "@@ -67,4 +68,6 @@\n     public static final String APPROVED_TIME_URL = BASE_URL + \"/api/category/pmp3g/version/2/approvedtime.json\";\n     public static final String POINT_FORECAST_URL = BASE_URL\n             + \"/api/category/pmp3g/version/2/geotype/point/lon/%.6f/lat/%.6f/data.json\";\n+\n+    public static final BigDecimal OCTAS_TO_PERCENT = BigDecimal.valueOf(0.08);", "originalCommit": "9d865653ef2800a9eedf242941937164aefaa069", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODE5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439708195", "bodyText": "No, e.g. 5/8 = 0.625, 5/0.08 = 62.5. 62.5 Is the number I want, right?", "author": "pacive", "createdAt": "2020-06-13T04:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2MjAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxMDEzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439710139", "bodyText": "Now that I think about it though, it might be more clear to just multiply by 12.5 instead.", "author": "pacive", "createdAt": "2020-06-13T05:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2MjAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NDc4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439664789", "bodyText": "Please refactor this to its own method so that handleCommand and initialize can both use it.", "author": "cpmeister", "createdAt": "2020-06-12T22:21:31Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }", "originalCommit": "086a20070bdf370b51d38471f065dda2cb862ded", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NTMzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439665330", "bodyText": "Any reason this is protected rather than private?", "author": "cpmeister", "createdAt": "2020-06-12T22:23:42Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A class containing a forecast for a specific point in time.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Forecast implements Comparable<Forecast> {\n+    protected final ZonedDateTime validTime;", "originalCommit": "086a20070bdf370b51d38471f065dda2cb862ded", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODcyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439708728", "bodyText": "I (apparently mistakenly) thought protected was to enable instances to see each other's fields (in the compareTo method), but seems I got it mixed up with Ruby's access modifiers.", "author": "pacive", "createdAt": "2020-06-13T04:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NTMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NTUyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439665526", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                public List<Integer> hourlyForecasts;\n          \n          \n            \n                @Nullable\n          \n          \n            \n                public List<Integer> dailyForecasts;\n          \n          \n            \n                public @Nullable List<Integer> hourlyForecasts;\n          \n          \n            \n                public @Nullable List<Integer> dailyForecasts;", "author": "cpmeister", "createdAt": "2020-06-12T22:24:36Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConfiguration.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link SmhiConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConfiguration {\n+    public double latitude;\n+    public double longitude;\n+    @Nullable\n+    public List<Integer> hourlyForecasts;\n+    @Nullable\n+    public List<Integer> dailyForecasts;", "originalCommit": "086a20070bdf370b51d38471f065dda2cb862ded", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NTgxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439665815", "bodyText": "You can get around the null checking issues by just initializing your config to a default instance.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SmhiConfiguration config;\n          \n          \n            \n                private SmhiConfiguration config = new SmhiConfiguration();", "author": "cpmeister", "createdAt": "2020-06-12T22:25:49Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;", "originalCommit": "086a20070bdf370b51d38471f065dda2cb862ded", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2Njk2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439666962", "bodyText": "Don't most of these channels have units now?", "author": "cpmeister", "createdAt": "2020-06-12T22:30:44Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+            } else {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(Channel channel, @Nullable BigDecimal value) {\n+        String id = channel.getUID().getIdWithoutGroup();\n+        State newState = UnDefType.NULL;\n+\n+        if (value != null) {\n+            switch (id) {\n+                case PRESSURE:\n+                    newState = new QuantityType<>(value, MetricPrefix.HECTO(SIUnits.PASCAL));\n+                    break;\n+                case TEMPERATURE:\n+                    newState = new QuantityType<>(value, SIUnits.CELSIUS);\n+                    break;\n+                case VISIBILITY:\n+                    newState = new QuantityType<>(value, MetricPrefix.KILO(SIUnits.METRE));\n+                    break;\n+                case WIND_DIRECTION:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.DEGREE_ANGLE);\n+                    break;\n+                case WIND_SPEED:\n+                case GUST:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.METRE_PER_SECOND);\n+                    break;\n+                case RELATIVE_HUMIDITY:\n+                case THUNDER_PROBABILITY:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    break;\n+                case PERCENT_FROZEN:\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (value.intValue() == -9) {\n+                        newState = UnDefType.UNDEF;\n+                    } else {\n+                        newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    }\n+                    break;\n+                case HIGH_CLOUD_COVER:\n+                case MEDIUM_CLOUD_COVER:\n+                case LOW_CLOUD_COVER:\n+                case TOTAL_CLOUD_COVER:\n+                    newState = new QuantityType<>(value.divide(OCTAS_TO_PERCENT), SmartHomeUnits.PERCENT);\n+                    break;\n+                case PRECIPITATION_MAX:\n+                case PRECIPITATION_MEAN:\n+                case PRECIPITATION_MEDIAN:\n+                case PRECIPITATION_MIN:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.MILLIMETRE_PER_HOUR);\n+                    break;\n+                default:\n+                    newState = new DecimalType(value);\n+            }\n+        }\n+\n+        updateState(channel.getUID(), newState);\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        if (isItNewHour()) {\n+            currentHour = calculateCurrentHour();\n+            currentDay = calculateCurrentDay();\n+            // Update channels with cached forecasts - just shift an hour forward\n+            TimeSeries forecast = cachedTimeSeries;\n+            if (forecast != null) {\n+                updateChannels(forecast);\n+            }\n+            hasLatestForecast = false;\n+        }\n+        if (!hasLatestForecast && isForecastUpdated()) {\n+            getUpdatedForecast();\n+        }\n+    }\n+\n+    /**\n+     * Checks if it is a new hour.\n+     * \n+     * @return true if the current time is more than one hour after currentHour, otherwise false.\n+     */\n+    private boolean isItNewHour() {\n+        return ZonedDateTime.now().minusHours(1).isAfter(currentHour);\n+    }\n+\n+    /**\n+     * Call Smhi's endpoint to check for the time of the last forecast, to see if a new one is available.\n+     * \n+     * @return true if the time of the latest forecast is equal to or after currentHour, otherwise false\n+     */\n+    private boolean isForecastUpdated() {\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                referenceTime = apiConnection.getReferenceTime();\n+            } catch (SmhiException e) {\n+                return false;\n+            }\n+            return referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Fetches latest forecast from Smhi, update channels and check if it was published in the current hour.\n+     * If it is, set flag to indicate we have the latest forecast.\n+     */\n+    private void getUpdatedForecast() {\n+        TimeSeries forecast;\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                forecast = apiConnection.getForecast(config.latitude, config.longitude);\n+            } catch (SmhiException e) {\n+                logger.warn(\"Failed to get new forecast: {}\", e.getCause().getMessage());\n+                return;\n+            }\n+            referenceTime = forecast.getReferenceTime();\n+            updateChannels(forecast);\n+            if (referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour)) {\n+                hasLatestForecast = true;\n+            }\n+            cachedTimeSeries = forecast;\n+        }\n+    }\n+\n+    /**\n+     * Get the current time rounded down to hour\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even hour\n+     */\n+    private ZonedDateTime calculateCurrentHour() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        int h = now.getHour();\n+        return ZonedDateTime.of(y, m, d, h, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Get the current time rounded down to day\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even day.\n+     */\n+    private ZonedDateTime calculateCurrentDay() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        return ZonedDateTime.of(y, m, d, 0, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Creates channels based on selections in thing configuration\n+     * \n+     * @return\n+     */\n+    private List<Channel> createChannels() {\n+        List<Channel> channels = new ArrayList<>();\n+\n+        // There's currently a bug in PaperUI that can cause options to be added more than one time\n+        // to the list. Convert to a sorted set to work around this.\n+        // See https://github.com/openhab/openhab-webui/issues/212\n+        Set<Integer> hours = new TreeSet<>();\n+        Set<Integer> days = new TreeSet<>();\n+        if (config.hourlyForecasts != null) {\n+            hours.addAll(config.hourlyForecasts);\n+        }\n+        if (config.dailyForecasts != null) {\n+            days.addAll(config.dailyForecasts);\n+        }\n+\n+        for (int i : hours) {\n+            ChannelGroupUID groupUID = new ChannelGroupUID(thing.getUID(), \"hour_\" + i);\n+            CHANNEL_IDS.forEach(id -> {\n+                ChannelUID channelUID = new ChannelUID(groupUID, id);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Number\")", "originalCommit": "086a20070bdf370b51d38471f065dda2cb862ded", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxMDAyOA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439710028", "bodyText": "The units are working even though it's defined just as \"Number\". Do I have to hardcode all Item types here as well? Is there an easier way to just create a channel from a channel-type defined in xml? All info is already defined there, so seems unnecessary to define it again here, but the ChannelBuilder constructor requires this.", "author": "pacive", "createdAt": "2020-06-13T05:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2Njk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxMzE4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439713186", "bodyText": "Not sure myself. But after looking at the core code it seems like you can just set the itemType to null. If the core was coded sensibly it would look at the ChannelType's itemType in the case that the Channel's itemType was missing. I think that would be one way to avoid redefining the itemtypes if it works.", "author": "cpmeister", "createdAt": "2020-06-13T06:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2Njk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjM3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439716379", "bodyText": "Thanks, will try and test it out!", "author": "pacive", "createdAt": "2020-06-13T07:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2Njk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyMDM3Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439720377", "bodyText": "Didn't work. The acceptedItemType property remained null, giving no hint to the UI what item type to use. Had to do it the harder way instead.", "author": "pacive", "createdAt": "2020-06-13T08:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2Njk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NzA5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439667096", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-06-12T22:31:16Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+            } else {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(Channel channel, @Nullable BigDecimal value) {\n+        String id = channel.getUID().getIdWithoutGroup();\n+        State newState = UnDefType.NULL;\n+\n+        if (value != null) {\n+            switch (id) {\n+                case PRESSURE:\n+                    newState = new QuantityType<>(value, MetricPrefix.HECTO(SIUnits.PASCAL));\n+                    break;\n+                case TEMPERATURE:\n+                    newState = new QuantityType<>(value, SIUnits.CELSIUS);\n+                    break;\n+                case VISIBILITY:\n+                    newState = new QuantityType<>(value, MetricPrefix.KILO(SIUnits.METRE));\n+                    break;\n+                case WIND_DIRECTION:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.DEGREE_ANGLE);\n+                    break;\n+                case WIND_SPEED:\n+                case GUST:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.METRE_PER_SECOND);\n+                    break;\n+                case RELATIVE_HUMIDITY:\n+                case THUNDER_PROBABILITY:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    break;\n+                case PERCENT_FROZEN:\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (value.intValue() == -9) {\n+                        newState = UnDefType.UNDEF;\n+                    } else {\n+                        newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    }\n+                    break;\n+                case HIGH_CLOUD_COVER:\n+                case MEDIUM_CLOUD_COVER:\n+                case LOW_CLOUD_COVER:\n+                case TOTAL_CLOUD_COVER:\n+                    newState = new QuantityType<>(value.divide(OCTAS_TO_PERCENT), SmartHomeUnits.PERCENT);\n+                    break;\n+                case PRECIPITATION_MAX:\n+                case PRECIPITATION_MEAN:\n+                case PRECIPITATION_MEDIAN:\n+                case PRECIPITATION_MIN:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.MILLIMETRE_PER_HOUR);\n+                    break;\n+                default:\n+                    newState = new DecimalType(value);\n+            }\n+        }\n+\n+        updateState(channel.getUID(), newState);\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        if (isItNewHour()) {\n+            currentHour = calculateCurrentHour();\n+            currentDay = calculateCurrentDay();\n+            // Update channels with cached forecasts - just shift an hour forward\n+            TimeSeries forecast = cachedTimeSeries;\n+            if (forecast != null) {\n+                updateChannels(forecast);\n+            }\n+            hasLatestForecast = false;\n+        }\n+        if (!hasLatestForecast && isForecastUpdated()) {\n+            getUpdatedForecast();\n+        }\n+    }\n+\n+    /**\n+     * Checks if it is a new hour.\n+     * \n+     * @return true if the current time is more than one hour after currentHour, otherwise false.\n+     */\n+    private boolean isItNewHour() {\n+        return ZonedDateTime.now().minusHours(1).isAfter(currentHour);\n+    }\n+\n+    /**\n+     * Call Smhi's endpoint to check for the time of the last forecast, to see if a new one is available.\n+     * \n+     * @return true if the time of the latest forecast is equal to or after currentHour, otherwise false\n+     */\n+    private boolean isForecastUpdated() {\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                referenceTime = apiConnection.getReferenceTime();\n+            } catch (SmhiException e) {\n+                return false;\n+            }\n+            return referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Fetches latest forecast from Smhi, update channels and check if it was published in the current hour.\n+     * If it is, set flag to indicate we have the latest forecast.\n+     */\n+    private void getUpdatedForecast() {\n+        TimeSeries forecast;\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                forecast = apiConnection.getForecast(config.latitude, config.longitude);\n+            } catch (SmhiException e) {\n+                logger.warn(\"Failed to get new forecast: {}\", e.getCause().getMessage());\n+                return;\n+            }\n+            referenceTime = forecast.getReferenceTime();\n+            updateChannels(forecast);\n+            if (referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour)) {\n+                hasLatestForecast = true;\n+            }\n+            cachedTimeSeries = forecast;\n+        }\n+    }\n+\n+    /**\n+     * Get the current time rounded down to hour\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even hour\n+     */\n+    private ZonedDateTime calculateCurrentHour() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        int h = now.getHour();\n+        return ZonedDateTime.of(y, m, d, h, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Get the current time rounded down to day\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even day.\n+     */\n+    private ZonedDateTime calculateCurrentDay() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        return ZonedDateTime.of(y, m, d, 0, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Creates channels based on selections in thing configuration\n+     * \n+     * @return\n+     */\n+    private List<Channel> createChannels() {\n+        List<Channel> channels = new ArrayList<>();\n+\n+        // There's currently a bug in PaperUI that can cause options to be added more than one time\n+        // to the list. Convert to a sorted set to work around this.\n+        // See https://github.com/openhab/openhab-webui/issues/212\n+        Set<Integer> hours = new TreeSet<>();\n+        Set<Integer> days = new TreeSet<>();\n+        if (config.hourlyForecasts != null) {\n+            hours.addAll(config.hourlyForecasts);\n+        }\n+        if (config.dailyForecasts != null) {\n+            days.addAll(config.dailyForecasts);\n+        }\n+\n+        for (int i : hours) {\n+            ChannelGroupUID groupUID = new ChannelGroupUID(thing.getUID(), \"hour_\" + i);\n+            CHANNEL_IDS.forEach(id -> {\n+                ChannelUID channelUID = new ChannelUID(groupUID, id);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Number\")\n+                        .withType(new ChannelTypeUID(BINDING_ID, id)).build();\n+                channels.add(channel);\n+            });\n+        }\n+\n+        for (int i : days) {\n+            ChannelGroupUID groupUID = new ChannelGroupUID(thing.getUID(), \"day_\" + i);\n+            CHANNEL_IDS.forEach(id -> {\n+                ChannelUID channelUID = new ChannelUID(groupUID, id);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Number\")", "originalCommit": "086a20070bdf370b51d38471f065dda2cb862ded", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ed3fd124c73419ecdd9ff70cdde11d957c70a76c", "url": "https://github.com/openhab/openhab-addons/commit/ed3fd124c73419ecdd9ff70cdde11d957c70a76c", "message": "Improvements and refactoring after code review\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-06-13T08:16:36Z", "type": "commit"}, {"oid": "44a1568fbd70b4fdf0dd0febfc9fd34e070ce3d6", "url": "https://github.com/openhab/openhab-addons/commit/44a1568fbd70b4fdf0dd0febfc9fd34e070ce3d6", "message": "Improve handling of error responses from server\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-06-13T08:56:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MDgwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439760806", "bodyText": "You can omit the call to super() here since it is already implied.", "author": "cpmeister", "createdAt": "2020-06-13T18:54:44Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/PointOutOfBoundsException.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PointOutOfBoundsException extends Exception {\n+\n+    private static final long serialVersionUID = 546566512L;\n+\n+    public PointOutOfBoundsException() {\n+        super();", "originalCommit": "44a1568fbd70b4fdf0dd0febfc9fd34e070ce3d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MTAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439761005", "bodyText": "This should never be null now so it should be ok to remove the @NonNullByDefault({}) unless you had another reason to keep it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SmhiConfiguration config = new SmhiConfiguration();\n          \n          \n            \n                private SmhiConfiguration config = new SmhiConfiguration();", "author": "cpmeister", "createdAt": "2020-06-13T18:57:24Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,458 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config = new SmhiConfiguration();", "originalCommit": "44a1568fbd70b4fdf0dd0febfc9fd34e070ce3d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40", "url": "https://github.com/openhab/openhab-addons/commit/cb7c5c1bac986eaf75640cd37d7b9c9221123e40", "message": "Minor tweaks and fixes\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-06-14T11:23:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855005", "bodyText": "I would always prefer longer more descriptive names, what is a parObj", "author": "martinvw", "createdAt": "2020-06-14T18:17:14Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Class with static methods for parsing json strings returned from Smhi\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Parser {\n+\n+    private static JsonParser parser = new JsonParser();\n+\n+    /**\n+     * Parse a json string received from Smhi containing forecasts.\n+     *\n+     * @param json A json string\n+     * @return A {@link TimeSeries} object\n+     */\n+    public static TimeSeries parseTimeSeries(String json) {\n+        ZonedDateTime referenceTime;\n+        JsonObject object = parser.parse(json).getAsJsonObject();\n+\n+        referenceTime = parseApprovedTime(json);\n+        JsonArray timeSeries = object.get(\"timeSeries\").getAsJsonArray();\n+\n+        List<Forecast> forecasts = StreamSupport.stream(timeSeries.spliterator(), false)\n+                        .map(element -> parseForecast(element.getAsJsonObject()))\n+                        .sorted(Comparator.naturalOrder())\n+                        .collect(Collectors.toList());\n+\n+        return new TimeSeries(referenceTime, forecasts);\n+    }\n+\n+    /**\n+     * Parse a json string containing the approved time and reference time of the latest forecast\n+     *\n+     * @param json A json string\n+     * @return {@link ZonedDateTime} of the reference time\n+     */\n+    public static ZonedDateTime parseApprovedTime(String json) {\n+        JsonObject timeObj = parser.parse(json).getAsJsonObject();\n+\n+        return ZonedDateTime.parse(timeObj.get(\"referenceTime\").getAsString());\n+    }\n+\n+    /**\n+     * Parse a single forecast, i.e. a forecast for a specific time.\n+     *\n+     * @param object\n+     * @return\n+     */\n+    private static Forecast parseForecast(JsonObject object) {\n+        ZonedDateTime validTime = ZonedDateTime.parse(object.get(\"validTime\").getAsString());\n+        Map<String, @Nullable BigDecimal> parameters = new HashMap<>();\n+\n+        JsonArray par = object.get(\"parameters\").getAsJsonArray();\n+\n+        par.forEach(element -> {\n+            JsonObject parObj = element.getAsJsonObject();", "originalCommit": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTA4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855084", "bodyText": "This constructor would still be there if you remove this code, the same result less code.", "author": "martinvw", "createdAt": "2020-06-14T18:18:20Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/PointOutOfBoundsException.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PointOutOfBoundsException extends Exception {\n+\n+    private static final long serialVersionUID = 546566512L;\n+\n+    public PointOutOfBoundsException() {", "originalCommit": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTExMA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855110", "bodyText": "It seems that the base url could include /api/category/pmp3g/version/2/", "author": "martinvw", "createdAt": "2020-06-14T18:18:53Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiBindingConstants.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link SmhiBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiBindingConstants {\n+\n+    public static final String BINDING_ID = \"smhi\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_FORECAST = new ThingTypeUID(BINDING_ID, \"forecast\");\n+\n+    // Smhi's ids for parameters, also used as channel ids\n+    public static final String PRESSURE = \"msl\";\n+    public static final String TEMPERATURE = \"t\";\n+    public static final String VISIBILITY = \"vis\";\n+    public static final String WIND_DIRECTION = \"wd\";\n+    public static final String WIND_SPEED = \"ws\";\n+    public static final String RELATIVE_HUMIDITY = \"r\";\n+    public static final String THUNDER_PROBABILITY = \"tstm\";\n+    public static final String TOTAL_CLOUD_COVER = \"tcc_mean\";\n+    public static final String LOW_CLOUD_COVER = \"lcc_mean\";\n+    public static final String MEDIUM_CLOUD_COVER = \"mcc_mean\";\n+    public static final String HIGH_CLOUD_COVER = \"hcc_mean\";\n+    public static final String GUST = \"gust\";\n+    public static final String PRECIPITATION_MIN = \"pmin\";\n+    public static final String PRECIPITATION_MAX = \"pmax\";\n+    public static final String PRECIPITATION_MEAN = \"pmean\";\n+    public static final String PRECIPITATION_MEDIAN = \"pmedian\";\n+    public static final String PERCENT_FROZEN = \"spp\";\n+    public static final String PRECIPITATION_CATEGORY = \"pcat\";\n+    public static final String WEATHER_SYMBOL = \"wsymb2\";\n+\n+    public static final List<String> CHANNEL_IDS = Collections\n+            .unmodifiableList(Stream\n+                    .of(PRESSURE, TEMPERATURE, VISIBILITY, WIND_DIRECTION, WIND_SPEED, RELATIVE_HUMIDITY,\n+                            THUNDER_PROBABILITY, TOTAL_CLOUD_COVER, LOW_CLOUD_COVER, MEDIUM_CLOUD_COVER,\n+                            HIGH_CLOUD_COVER, GUST, PRECIPITATION_MIN, PRECIPITATION_MAX, PRECIPITATION_MEAN,\n+                            PRECIPITATION_MEDIAN, PERCENT_FROZEN, PRECIPITATION_CATEGORY, WEATHER_SYMBOL)\n+                    .collect(Collectors.toList()));\n+\n+    public static final String BASE_URL = \"https://opendata-download-metfcst.smhi.se\";", "originalCommit": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTM1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855353", "bodyText": "This warning sounds very familiar does the framework issue the same warning?", "author": "martinvw", "createdAt": "2020-06-14T18:21:22Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",", "originalCommit": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MDUxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439860519", "bodyText": "The code in the method is in part copied from BaseThingHandler, I wanted most of the same functionality but skip the dispose()/initialize() part and handle that differently. Is there a better way to achieve this?", "author": "pacive", "createdAt": "2020-06-14T19:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0Njg1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r440746854", "bodyText": "Why do you need to override the method it seems that you still perform most of the re-initialization anyway?", "author": "martinvw", "createdAt": "2020-06-16T10:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgyNjk4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r440826989", "bodyText": "You're right, i'll remove the method and just let it be handled in the default way.", "author": "pacive", "createdAt": "2020-06-16T12:55:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTQyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855426", "bodyText": "How many hours are in a day, does it really include hour 0 and 24? That is 25 data points, just checking :-)", "author": "martinvw", "createdAt": "2020-06-14T18:22:24Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {", "originalCommit": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MDk0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439860940", "bodyText": "Hour 0 is the current hour, and then you can add channels for the next hour (1) up to 24 hours from now :)", "author": "pacive", "createdAt": "2020-06-14T19:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTU0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855546", "bodyText": "You are doing a small calculation in you debug statement, I don't know how often this path is executed, but people without debug logging still do the calculation each time. You could guard it with logger.isDebugEnabled()", "author": "martinvw", "createdAt": "2020-06-14T18:24:03Z", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));", "originalCommit": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MzU4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r440293589", "bodyText": "Is it just the integer calculation you're concerned about or the plusHours() as well? I could do the calculation separately and use it both for timeSeries.getForecast() and the debug statement (would look better DRY-wise). Anyway, this logging statement shouldn't appear more than once an hour at most.", "author": "pacive", "createdAt": "2020-06-15T16:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTU0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1NzA2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r440357061", "bodyText": "Especially the plusHours because that is kinda black box, the integer calculation should be done in a single CPU tick :-)\nGiven its frequency it's not problematic", "author": "martinvw", "createdAt": "2020-06-15T18:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTU0Ng=="}], "type": "inlineReview"}, {"oid": "8b310ebce5c937274cbddeeab492cae2b65ac757", "url": "https://github.com/openhab/openhab-addons/commit/8b310ebce5c937274cbddeeab492cae2b65ac757", "message": "Improve handling of server error responses + code review changes\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-06-15T16:33:42Z", "type": "commit"}, {"oid": "a65498389ac424b387b21b82ccc7f07aa864006b", "url": "https://github.com/openhab/openhab-addons/commit/a65498389ac424b387b21b82ccc7f07aa864006b", "message": "Remove handleConfigurationUpdate method\n\nSigned-off-by: Anders Alfredsson <andersb86@gmail.com>", "committedDate": "2020-06-16T13:09:23Z", "type": "commit"}]}