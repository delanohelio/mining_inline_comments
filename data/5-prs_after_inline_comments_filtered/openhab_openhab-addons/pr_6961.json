{"pr_number": 6961, "pr_title": "[paradoxalarm] Encryption support, partition commands support and refactoring", "pr_createdAt": "2020-02-04T17:02:48Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/6961", "timeline": [{"oid": "368dbb8f43ee3ee7e4d1e153b79f32b9fe64b18c", "url": "https://github.com/openhab/openhab-addons/commit/368dbb8f43ee3ee7e4d1e153b79f32b9fe64b18c", "message": "Fix wrong payload sent for odd partitions + test for it\n\n* The fix for wrongly calculated payload for odd partitions (1,3,5,7)\n* Unit test for the same\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-02-12T17:13:36Z", "type": "forcePushed"}, {"oid": "135bc3255dc4a98db0c85086440bb78b0d72a624", "url": "https://github.com/openhab/openhab-addons/commit/135bc3255dc4a98db0c85086440bb78b0d72a624", "message": "Fix wrong payload sent for odd partitions + test for it\n\n* The fix for wrongly calculated payload for odd partitions (1,3,5,7)\n* Unit test for the same\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-02-12T17:30:28Z", "type": "forcePushed"}, {"oid": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548", "url": "https://github.com/openhab/openhab-addons/commit/6fd49a9aac2e0d157aebd5276b6ff38a0f703548", "message": "Refactoring and fixes\n\n* Refactored two panel channels names\n* Fixed issue where channel was renamed before but not everywhere in the\ncode\n* Fixed potential issue caused by wrongly used brackets in\nAbstractParser which may cause issue due to operations priority\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-02-27T17:02:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1MDM4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389350387", "bodyText": "What sense does it make to pass a password and not use it?", "author": "J-N-K", "createdAt": "2020-03-08T09:12:23Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/AbstractCommunicator.java", "diffHunk": "@@ -60,10 +53,11 @@\n \n     private boolean isOnline;\n \n-    public AbstractCommunicator(String ipAddress, int tcpPort, ScheduledExecutorService scheduler)\n+    public AbstractCommunicator(String ipAddress, int tcpPort, String password, ScheduledExecutorService scheduler)", "originalCommit": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1MDYwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389350607", "bodyText": "How can it be that the receiver is null? And is this an error state? If so, please log something.", "author": "J-N-K", "createdAt": "2020-03-08T09:15:19Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/AbstractCommunicator.java", "diffHunk": "@@ -141,111 +139,43 @@ protected void receivePacket() {\n             int readBytes = rx.read(result);\n             if (readBytes > 0 && result[1] > 0 && result[1] + 16 < 256) {\n                 logger.trace(\"Successfully read valid packet from Rx\");\n-                retryCounter = 0;\n                 IRequest request = syncQueue.poll();\n-                byte[] bytesData = Arrays.copyOfRange(result, 0, result[1] + 16);\n-                IResponse response = new Response(request, bytesData);\n-                handleReceivedPacket(response);\n+                byte[] bytesData = Arrays.copyOfRange(result, 0, readBytes);\n+                IResponse response = new Response(request, bytesData, isEncrypted());\n+\n+                if (response.getPayload() == null || response.getHeader() == null) {\n+                    handleWrongPacket(result, request);\n+                }\n+\n+                IResponseReceiver responseReceiver = request.getResponseReceiver();\n+                if (responseReceiver != null) {\n+                    responseReceiver.receiveResponse(response, this);\n+                }", "originalCommit": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2ODk0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389368941", "bodyText": "It's possible when we create PartitionCommandRequest. In this case there is no response from the system so receiver is null in this case. When it's null we also don't want to continue reading. Is that fine?", "author": "theater", "createdAt": "2020-03-08T13:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1MDYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NDc0OA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389354748", "bodyText": "Why is this check not needed anymore?", "author": "J-N-K", "createdAt": "2020-03-08T10:13:17Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/EvoCommunicator.java", "diffHunk": "@@ -314,26 +326,30 @@ private void initializeEpromData() {\n         private int tcpPort = 10000;\r\n         private String pcPassword = \"0000\";\r\n \r\n+        private boolean useEncryption;\r\n+\r\n         EvoCommunicatorBuilder(PanelType panelType) {\r\n             this.panelType = panelType;\r\n         }\r\n \r\n         @Override\r\n         public IParadoxCommunicator build() {\r\n-            if (panelType != PanelType.EVO48 && panelType != PanelType.EVO96 && panelType != PanelType.EVO192) {\r", "originalCommit": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2OTg3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389369879", "bodyText": "Because I've extracted this check outside in the ParadoxBuilderFactory and this check is duplicating the other one.\nThere is a switch/case in ParadoxBuilderFactory which has default clause that will throw ParadoxRuntimeException if panel type is not supported.", "author": "theater", "createdAt": "2020-03-08T13:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NDc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NTE1OA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389355158", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"Payload should not not be null or empty !\");\n          \n          \n            \n                        throw new IllegalArgumentException(\"Payload should not be null or empty !\");", "author": "J-N-K", "createdAt": "2020-03-08T10:19:31Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not not be null or empty !\");", "originalCommit": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NTg1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389355859", "bodyText": "Why not use HexUtils.bytestoHex  from the core?", "author": "J-N-K", "createdAt": "2020-03-08T10:30:05Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/util/ParadoxUtil.java", "diffHunk": "@@ -54,27 +56,54 @@ public static void printPacket(String description, byte[] array) {\n         }\r\n     }\r\n \r\n-    private static void printByteArray(String description, byte[] array, int length) {\r\n-        if (description != null && !description.isEmpty()) {\r\n-            logger.trace(\"{}\", description);\r\n+    public static void printByteArray(String description, byte[] array) {\r\n+        if (array == null) {\r\n+            logger.trace(\"Array is null\");\r\n+            return;\r\n         }\r\n-        int countBytes = 0;\r\n-        String result = \"\";\r\n-        for (int index = 0; index < length; index++) {\r\n-            countBytes++;\r\n-            String st = String.format(\"0x%02X,\\t\", array[index]);\r\n-            result += st;\r\n-            if (countBytes > 7) {\r\n-                logger.trace(result);\r\n-                countBytes = 0;\r\n-                result = \"\";\r\n-                continue;\r\n-            }\r\n+        printByteArray(description, array, array.length);\r\n+    }\r\n+\r\n+    public static void printByteArray(String description, byte[] array, int length) {\r\n+        if (!logger.isTraceEnabled()) {\r\n+            return;\r\n         }\r\n+\r\n+        String result = byteArrayToString(array, length);\r\n         if (!result.isEmpty()) {\r\n-            logger.trace(result);\r\n+            logger.trace(\"{}\", description + SPACE_DELIMITER + result);\r\n         }\r\n+    }\r\n \r\n+    public static String byteArrayToString(byte[] array) {\r\n+        return byteArrayToString(array, array.length);\r\n+    }\r\n+\r\n+    /**\r\n+     *\r\n+     * Returns passed array as HEX string. On every 8 bytes we put space for better readability. Example 16\r\n+     * bytes array output: AA47000263000000 03EE00EEEEEEB727\r\n+     *\r\n+     * @param array\r\n+     * @param length\r\n+     * @return String\r\n+     */\r\n+    public static String byteArrayToString(byte[] array, int length) {\r", "originalCommit": "6fd49a9aac2e0d157aebd5276b6ff38a0f703548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM3MDQ4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r389370483", "bodyText": "When packet is encrypted, Paradox is adding 0xEE to the payload to every 16, 32, 48, 64, etc bytes. In the header there is a field which defines the actual payload length. I'd like to be able to print only the actual length for debugging purposes in TRACE level. By providing length, I cut the array to the length passed as an argument. Also I split on every 8 bytes by adding a space which is not possible in HexUtils, for easier reading. I guess if I do pre-processing I could use HexUtils without the every 8 bytes space functionality though...", "author": "theater", "createdAt": "2020-03-08T13:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1NTg1OQ=="}], "type": "inlineReview"}, {"oid": "372996f4f068f3fc11b5c95e97dd281411887d83", "url": "https://github.com/openhab/openhab-addons/commit/372996f4f068f3fc11b5c95e97dd281411887d83", "message": "Changes based on JNK's review #1\n\n* Remove leftover unnecessary parameter password from\nAbstractCommunicator\n* Remove required=false wherever we have default values in thing\ndefinitions.\n* Fix exception message in EncryptionHandler\n* Clean up imports in Response.java\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-03-10T17:12:03Z", "type": "forcePushed"}, {"oid": "da6e378ec528d5669c07fda967a32cdd58d11180", "url": "https://github.com/openhab/openhab-addons/commit/da6e378ec528d5669c07fda967a32cdd58d11180", "message": "Spotless:apply on all files in paradoxalarm folder\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-05-06T15:04:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2ODI0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r428868243", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static byte[] copyArray(int[] input) {\n          \n          \n            \n                public static byte[] toByteArray(int[] input) {", "author": "cpmeister", "createdAt": "2020-05-21T19:33:27Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/util/ParadoxUtil.java", "diffHunk": "@@ -131,4 +161,69 @@ public static byte getLowNibble(byte value) {\n         }\n         return result;\n     }\n+\n+    /**\n+     * This method fills array with 0xEE based on rate.\n+     * Example: If input array length is 5 and rate is 8 the array will be extended with 3 more bytes filled with 0xEE\n+     *\n+     * @param inputArray\n+     * @param rate\n+     * @return byte[]\n+     */\n+    public static byte[] extendArray(byte[] inputArray, int rate) {\n+        if (inputArray == null || inputArray.length % rate == 0) {\n+            return inputArray;\n+        }\n+\n+        final int newLength = inputArray.length + (rate - inputArray.length % rate);\n+        byte[] result = new byte[newLength];\n+        for (int i = 0; i < result.length; i++) {\n+            if (i < inputArray.length) {\n+                result[i] = inputArray[i];\n+            } else {\n+                result[i] = (byte) 0xEE;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns bytes from string with standard US_ASCII standard charset to ensure everywhere in the binding we use same\n+     * charset.\n+     *\n+     * @param str\n+     * @return byte[]\n+     *\n+     */\n+    public static byte[] getBytesFromString(String str) {\n+        if (str == null) {\n+            throw new IllegalArgumentException(\"String must not be null !\");\n+        }\n+\n+        return str.getBytes(StandardCharsets.US_ASCII);\n+    }\n+\n+    public static int[] copyArray(byte[] input) {\n+        if (input == null) {\n+            throw new IllegalArgumentException(\"Input array must not be null\");\n+        }\n+        int[] result = new int[input.length];\n+        for (int i = 0; i < input.length; i++) {\n+            result[i] = input[i] & 0xFF;\n+        }\n+\n+        return result;\n+    }\n+\n+    public static byte[] copyArray(int[] input) {", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2ODI5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r428868293", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static int[] copyArray(byte[] input) {\n          \n          \n            \n                public static int[] toIntArray(byte[] input) {", "author": "cpmeister", "createdAt": "2020-05-21T19:33:35Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/util/ParadoxUtil.java", "diffHunk": "@@ -131,4 +161,69 @@ public static byte getLowNibble(byte value) {\n         }\n         return result;\n     }\n+\n+    /**\n+     * This method fills array with 0xEE based on rate.\n+     * Example: If input array length is 5 and rate is 8 the array will be extended with 3 more bytes filled with 0xEE\n+     *\n+     * @param inputArray\n+     * @param rate\n+     * @return byte[]\n+     */\n+    public static byte[] extendArray(byte[] inputArray, int rate) {\n+        if (inputArray == null || inputArray.length % rate == 0) {\n+            return inputArray;\n+        }\n+\n+        final int newLength = inputArray.length + (rate - inputArray.length % rate);\n+        byte[] result = new byte[newLength];\n+        for (int i = 0; i < result.length; i++) {\n+            if (i < inputArray.length) {\n+                result[i] = inputArray[i];\n+            } else {\n+                result[i] = (byte) 0xEE;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns bytes from string with standard US_ASCII standard charset to ensure everywhere in the binding we use same\n+     * charset.\n+     *\n+     * @param str\n+     * @return byte[]\n+     *\n+     */\n+    public static byte[] getBytesFromString(String str) {\n+        if (str == null) {\n+            throw new IllegalArgumentException(\"String must not be null !\");\n+        }\n+\n+        return str.getBytes(StandardCharsets.US_ASCII);\n+    }\n+\n+    public static int[] copyArray(byte[] input) {", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0MTc1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r428941752", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-05-21T22:05:36Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/PartitionCommand.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.messages;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PartitionCommand} Enum representing the possible commands for a partition with the respective integer\n+ * values that are sent as nibbles in the packet.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ */\n+public enum PartitionCommand {", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0MjA5OA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r428942098", "bodyText": "I prefer static final", "author": "cpmeister", "createdAt": "2020-05-21T22:06:31Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/MemoryRequestPayload.java", "diffHunk": "@@ -22,16 +22,16 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * The {@link EpromRequestPayload} Abstract class which contains common logic used in RAM and EPROM payload generation\n+ * The {@link MemoryRequestPayload} Abstract class which contains common logic used in RAM and EPROM payload generation\n  * classes.\n  *\n  * @author Konstantin Polihronov - Initial contribution\n  */\n-public abstract class MemoryRequestPayload implements IPPacketPayload {\n+public abstract class MemoryRequestPayload implements IPayload {\n \n     private final Logger logger = LoggerFactory.getLogger(MemoryRequestPayload.class);\n \n-    private static final short MESSAGE_START = (short) ((0x50 << 8) | 0x08);\n+    private final static short MESSAGE_START = (short) ((0x50 << 8) | 0x08);", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNTAxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429005015", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-05-22T02:00:39Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNTc2OA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429005768", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for (int r = 1; r < rounds; r++) {\n          \n          \n            \n                            sBox(a, s);\n          \n          \n            \n                            shiftRow(a, 0);\n          \n          \n            \n                            mixColumn(a);\n          \n          \n            \n                            keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n          \n          \n            \n                        }\n          \n          \n            \n                        sBox(a, s);\n          \n          \n            \n                        shiftRow(a, 0);\n          \n          \n            \n                        keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n          \n          \n            \n                        for (int r = 1; r <= rounds; r++) {\n          \n          \n            \n                            sBox(a, s);\n          \n          \n            \n                            shiftRow(a, 0);\n          \n          \n            \n                            if(r != rounds){\n          \n          \n            \n                                mixColumn(a);\n          \n          \n            \n                            }\n          \n          \n            \n                            keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n          \n          \n            \n                        }", "author": "cpmeister", "createdAt": "2020-05-22T02:04:27Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjcwNg==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429542706", "bodyText": "Thanks for pointing that out. Seeing it now it seems obvious :(\nWill fix it asap.", "author": "theater", "createdAt": "2020-05-23T12:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNTc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAwNjI1OA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429006258", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n          \n          \n            \n                        sBox(a, si);\n          \n          \n            \n                        shiftRow(a, 1);\n          \n          \n            \n            \n          \n          \n            \n                        for (int r = rounds - 1; r > 0; r--) {\n          \n          \n            \n                            keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n          \n          \n            \n                            invMixColumn(a);\n          \n          \n            \n                            sBox(a, si);\n          \n          \n            \n                            shiftRow(a, 1);\n          \n          \n            \n                        }\n          \n          \n            \n                        for (int r = rounds; r > 0; r--) {\n          \n          \n            \n                            keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n          \n          \n            \n                            if(r != rounds){\n          \n          \n            \n                                invMixColumn(a);\n          \n          \n            \n                            }\n          \n          \n            \n                            sBox(a, si);\n          \n          \n            \n                            shiftRow(a, 1);\n          \n          \n            \n                        }", "author": "cpmeister", "createdAt": "2020-05-22T02:06:33Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMTAxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429011015", "bodyText": "The final assignment q = z serves no useful purpose here since the method returns the next line. This code is wrong. I suspect this code is somehow not arranged correctly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (c == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        s = q;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (b == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        q = z;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (b == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        q = z;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (c == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        s = q;\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nThat said, this is very convoluted for something that can be written much simpler.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (c == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        s = q;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (b == 0) {\n          \n          \n            \n                        s = z;\n          \n          \n            \n                    } else {\n          \n          \n            \n                        q = z;\n          \n          \n            \n                    }\n          \n          \n            \n                    if (b == 0 | c == 0) {\n          \n          \n            \n                        return 0;\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-05-22T02:28:08Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;\n+        s = lTable[c] + lTable[b];\n+        s %= 255;\n+        /* Get the antilog */\n+        s = aTable[s];\n+        /*\n+         * Now, we have some fancy code that returns 0 if either\n+         * a or b are zero; we write the code this way so that the\n+         * code will (hopefully) run at a constant speed in order to\n+         * minimize the risk of timing attacks\n+         */\n+        q = s;\n+        if (c == 0) {\n+            s = z;\n+        } else {\n+            s = q;\n+        }\n+        if (b == 0) {\n+            s = z;\n+        } else {\n+            q = z;\n+        }", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MzU1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429543557", "bodyText": "Absolutely. Refactored that in a simmilar to the suggested way. Thanks !", "author": "theater", "createdAt": "2020-05-23T12:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMTAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMTM2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429011365", "bodyText": "get rid of this variable and use literals instead.", "author": "cpmeister", "createdAt": "2020-05-22T02:29:56Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMjY0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429012646", "bodyText": "This class is not thread safe, and as such you should not provide a singleton instance for it.", "author": "cpmeister", "createdAt": "2020-05-22T02:35:38Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzOTMyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429539326", "bodyText": "If I make the instance initialized as per NonNullByDefault statically and do the only updater, i.e. updateKey() method synchronized can we consider the class thread safe? Based on the logic we set the key twice, once in the very beginning of the communication and second - after the initial response is received with the key provided by the system. I personally don't expect anything to change the instance at any other point in time. All the rest is manipulation on input using this key. If I'm thinking in the wrong direction, could you elaborate a bit more?", "author": "theater", "createdAt": "2020-05-23T11:53:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMjY0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3OTYyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r430779626", "bodyText": "The main thing I am worried about is that updateKey will get called while some encryption process is going on. It would be better if instead of making this class a singleton you can make this class readonly and do your updateKey logic in the constructor. Code that wants to change the encryption key would need to construct a new instance of this class.\nIf this class was immutable I would have no problem with you making it a singleton, the problem is that this class holds state. As a general principle singleton class should not be mutable, too many problems can arise otherwise.\nYour two options left are to either make this class immutable and pass in the key in the constructor, or allow this class to be mutable with optional thread-safety.", "author": "cpmeister", "createdAt": "2020-05-27T00:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMjY0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NTk2OA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r430985968", "bodyText": "I understand the concern. I will try to make the class immutable even though it's completely safe to leave it as it is because 1. the logon sequence is always a sequence of sending one byte and receiving one response byte for this request and 2. you cannot have more than one connection to the Paradox system (it's forbidden from the other end).\nThe sequence is something like this:\nUpdate the key in the singleton instance with the password provided.\nCreate first packet with payload the initial key (the password).\nEncrypt the packet with initial key.\nReceive the response\nDecrypt the response with the initial key\nExtract the new key from the first response\nUpdate the key in the encryption handler\nContinue the logon process by building, encrypting and sending the second packet from the sequence.\nThe only danger is if we have a lifecycle issue with bridge handler, i.e. if we have two active bridge handlers at the same time. Then the key can be modified in non-desired way but in this case many other things will go wrong anyway...", "author": "theater", "createdAt": "2020-05-27T09:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMjY0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4NTYzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432285631", "bodyText": "OK I looked a bit in the code. What do you think about this approach:\nChanging the private constructor to always receive the key. In the updateKey method we create a new instance with proper key, expand the key and whatever is necessary, assign it to the static singleton field and return the instance back from updateKey method.\nWith this approach whichever thread received the previous instance will be able to finish it's job with old state while the new jobs will run with the new instance.\nI'd really like to use singleton because I don't want to create encryption instances on every packet as it may become expensive overhead to always generate the key, etc...\nWhat do you think?", "author": "theater", "createdAt": "2020-05-29T06:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMjY0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ3MzA3NA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432473074", "bodyText": "... or the other way would be to ensure that in each method I get the reference to the field mutable field at the start and then continue with the local variable until the end of the method execution I guess... I've pushed the first version. Please let me know which one would you prefer.", "author": "theater", "createdAt": "2020-05-29T13:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMjY0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0NjYyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432646629", "bodyText": "I think what you pushed is satisfactory.", "author": "cpmeister", "createdAt": "2020-05-29T17:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMjY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMzIzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429013231", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void mixColumn(int[] a) {\n          \n          \n            \n                private static void mixColumn(int[] a) {", "author": "cpmeister", "createdAt": "2020-05-22T02:38:00Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;\n+        s = lTable[c] + lTable[b];\n+        s %= 255;\n+        /* Get the antilog */\n+        s = aTable[s];\n+        /*\n+         * Now, we have some fancy code that returns 0 if either\n+         * a or b are zero; we write the code this way so that the\n+         * code will (hopefully) run at a constant speed in order to\n+         * minimize the risk of timing attacks\n+         */\n+        q = s;\n+        if (c == 0) {\n+            s = z;\n+        } else {\n+            s = q;\n+        }\n+        if (b == 0) {\n+            s = z;\n+        } else {\n+            q = z;\n+        }\n+        return s;\n+    }\n+\n+    private void generateTables() {\n+        int a = 1;\n+        int d;\n+        for (int index = 0; index < 255; index++) {\n+            aTable[index] = a & 0xFF;\n+            /* Multiply by three */\n+            d = (a & 0x80) & 0xFF;\n+            a <<= 1;\n+            if (d == 0x80) {\n+                a ^= 0x1b;\n+                a &= 0xFF;\n+            }\n+            a ^= aTable[index];\n+            a &= 0xFF;\n+            /* Set the log table value */\n+            lTable[aTable[index]] = index & 0xFF;\n+        }\n+        aTable[255] = aTable[0];\n+        lTable[0] = 0;\n+    }\n+\n+    private void sBox(int[] a, int[] box) {\n+        for (int i = 0; i < 16; i++) {\n+            a[i] = box[a[i]];\n+        }\n+    }\n+\n+    private void mixColumn(int[] a) {", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzOTU0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429539543", "bodyText": "In general this comment applies to all changes of methods in handler to static. What is the benefit of making static use of methods? I would rather prefer to encapsulate the key inside a singleton instance of the class and call these methods in non-static way. Maybe it relates ot the use of singleton pattern... Probably we can discuss that in the other thread related to the usage of singleton.", "author": "theater", "createdAt": "2020-05-23T11:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMzIzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NzQwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r430777409", "bodyText": "The main benefits are architectural, the performance improvements are very minimal. It isn't really a hard requirement, more of a suggestion.", "author": "cpmeister", "createdAt": "2020-05-27T00:21:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMzIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMzMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429013318", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void sBox(int[] a, int[] box) {\n          \n          \n            \n                private static void sBox(int[] a, int[] box) {", "author": "cpmeister", "createdAt": "2020-05-22T02:38:16Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;\n+        s = lTable[c] + lTable[b];\n+        s %= 255;\n+        /* Get the antilog */\n+        s = aTable[s];\n+        /*\n+         * Now, we have some fancy code that returns 0 if either\n+         * a or b are zero; we write the code this way so that the\n+         * code will (hopefully) run at a constant speed in order to\n+         * minimize the risk of timing attacks\n+         */\n+        q = s;\n+        if (c == 0) {\n+            s = z;\n+        } else {\n+            s = q;\n+        }\n+        if (b == 0) {\n+            s = z;\n+        } else {\n+            q = z;\n+        }\n+        return s;\n+    }\n+\n+    private void generateTables() {\n+        int a = 1;\n+        int d;\n+        for (int index = 0; index < 255; index++) {\n+            aTable[index] = a & 0xFF;\n+            /* Multiply by three */\n+            d = (a & 0x80) & 0xFF;\n+            a <<= 1;\n+            if (d == 0x80) {\n+                a ^= 0x1b;\n+                a &= 0xFF;\n+            }\n+            a ^= aTable[index];\n+            a &= 0xFF;\n+            /* Set the log table value */\n+            lTable[aTable[index]] = index & 0xFF;\n+        }\n+        aTable[255] = aTable[0];\n+        lTable[0] = 0;\n+    }\n+\n+    private void sBox(int[] a, int[] box) {", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMzY2OA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429013668", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void shiftRow(int[] a, int d) {\n          \n          \n            \n                private static void shiftRow(int[] a, int d) {", "author": "cpmeister", "createdAt": "2020-05-22T02:39:50Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;\n+        s = lTable[c] + lTable[b];\n+        s %= 255;\n+        /* Get the antilog */\n+        s = aTable[s];\n+        /*\n+         * Now, we have some fancy code that returns 0 if either\n+         * a or b are zero; we write the code this way so that the\n+         * code will (hopefully) run at a constant speed in order to\n+         * minimize the risk of timing attacks\n+         */\n+        q = s;\n+        if (c == 0) {\n+            s = z;\n+        } else {\n+            s = q;\n+        }\n+        if (b == 0) {\n+            s = z;\n+        } else {\n+            q = z;\n+        }\n+        return s;\n+    }\n+\n+    private void generateTables() {\n+        int a = 1;\n+        int d;\n+        for (int index = 0; index < 255; index++) {\n+            aTable[index] = a & 0xFF;\n+            /* Multiply by three */\n+            d = (a & 0x80) & 0xFF;\n+            a <<= 1;\n+            if (d == 0x80) {\n+                a ^= 0x1b;\n+                a &= 0xFF;\n+            }\n+            a ^= aTable[index];\n+            a &= 0xFF;\n+            /* Set the log table value */\n+            lTable[aTable[index]] = index & 0xFF;\n+        }\n+        aTable[255] = aTable[0];\n+        lTable[0] = 0;\n+    }\n+\n+    private void sBox(int[] a, int[] box) {\n+        for (int i = 0; i < 16; i++) {\n+            a[i] = box[a[i]];\n+        }\n+    }\n+\n+    private void mixColumn(int[] a) {\n+        final int[] xtimetbl = EncryptionHandlerConstants.XTIMETABLE;\n+\n+        int[] b = new int[] { 0, 0, 0, 0 };\n+        for (int j = 0; j < 4; j++) {\n+            int tmp = a[j] ^ a[j + 4] ^ a[j + 8] ^ a[j + 12];\n+            for (int i = 0; i < 4; i++) {\n+                b[i] = a[i * 4 + j];\n+            }\n+            b[0] ^= xtimetbl[a[j] ^ a[j + 4]] ^ tmp;\n+            b[1] ^= xtimetbl[a[j + 4] ^ a[j + 8]] ^ tmp;\n+            b[2] ^= xtimetbl[a[j + 8] ^ a[j + 12]] ^ tmp;\n+            b[3] ^= xtimetbl[a[j + 12] ^ a[j]] ^ tmp;\n+\n+            for (int i = 0; i < 4; i++) {\n+                a[i * 4 + j] = b[i];\n+            }\n+        }\n+    }\n+\n+    private void invMixColumn(int[] a) {\n+        int[][] b = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };\n+        for (int j = 0; j < 4; j++) {\n+            for (int i = 0; i < 4; i++) {\n+                b[i][j] = gmul(0xe, a[i * 4 + j]) ^ gmul(0xb, a[((i + 1) % 4) * 4 + j])\n+                        ^ gmul(0xd, a[((i + 2) % 4) * 4 + j]) ^ gmul(0x9, a[((i + 3) % 4) * 4 + j]);\n+            }\n+        }\n+\n+        for (int j = 0; j < 4; j++) {\n+            for (int i = 0; i < 4; i++) {\n+                a[i * 4 + j] = b[i][j];\n+            }\n+        }\n+    }\n+\n+    private void shiftRow(int[] a, int d) {", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxMzc5MA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429013790", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void keyAddition(int[] a, int[] rk) {\n          \n          \n            \n                private static void keyAddition(int[] a, int[] rk) {", "author": "cpmeister", "createdAt": "2020-05-22T02:40:15Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {\n+        byte[] byteArray = new byte[keyBytes.length];\n+        for (int i = 0; i < keyBytes.length; i++) {\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\n+        }\n+\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\n+        return expandedArray;\n+    }\n+\n+    public void updateKey(byte[] newKey) {\n+        expandedKey = new int[KEY_LENGTH];\n+        expandKey(newKey);\n+    }\n+\n+    private void expandKey(byte[] input) {\n+        // fill array to 32th byte with 0xEE\n+        byte[] filledArray = fillArray(input);\n+\n+        int[] temp = { 0, 0, 0, 0 };\n+        for (int i = 0; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\n+            }\n+        }\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        for (int i = 8; i < 60; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\n+            }\n+\n+            if (i % 8 == 0) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+                int tmp = temp[0];\n+\n+                for (int j = 1; j < 4; j++) {\n+                    temp[j - 1] = temp[j];\n+                }\n+\n+                temp[3] = tmp;\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n+            } else if (i % 8 == 4) {\n+                for (int j = 0; j < 4; j++) {\n+                    temp[j] = s[temp[j]];\n+                }\n+            }\n+\n+            for (int j = 0; j < 4; j++) {\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\n+            }\n+        }\n+    }\n+\n+    private int gmul(int c, int b) {\n+        int s;\n+        int q;\n+        int z = 0;\n+        s = lTable[c] + lTable[b];\n+        s %= 255;\n+        /* Get the antilog */\n+        s = aTable[s];\n+        /*\n+         * Now, we have some fancy code that returns 0 if either\n+         * a or b are zero; we write the code this way so that the\n+         * code will (hopefully) run at a constant speed in order to\n+         * minimize the risk of timing attacks\n+         */\n+        q = s;\n+        if (c == 0) {\n+            s = z;\n+        } else {\n+            s = q;\n+        }\n+        if (b == 0) {\n+            s = z;\n+        } else {\n+            q = z;\n+        }\n+        return s;\n+    }\n+\n+    private void generateTables() {\n+        int a = 1;\n+        int d;\n+        for (int index = 0; index < 255; index++) {\n+            aTable[index] = a & 0xFF;\n+            /* Multiply by three */\n+            d = (a & 0x80) & 0xFF;\n+            a <<= 1;\n+            if (d == 0x80) {\n+                a ^= 0x1b;\n+                a &= 0xFF;\n+            }\n+            a ^= aTable[index];\n+            a &= 0xFF;\n+            /* Set the log table value */\n+            lTable[aTable[index]] = index & 0xFF;\n+        }\n+        aTable[255] = aTable[0];\n+        lTable[0] = 0;\n+    }\n+\n+    private void sBox(int[] a, int[] box) {\n+        for (int i = 0; i < 16; i++) {\n+            a[i] = box[a[i]];\n+        }\n+    }\n+\n+    private void mixColumn(int[] a) {\n+        final int[] xtimetbl = EncryptionHandlerConstants.XTIMETABLE;\n+\n+        int[] b = new int[] { 0, 0, 0, 0 };\n+        for (int j = 0; j < 4; j++) {\n+            int tmp = a[j] ^ a[j + 4] ^ a[j + 8] ^ a[j + 12];\n+            for (int i = 0; i < 4; i++) {\n+                b[i] = a[i * 4 + j];\n+            }\n+            b[0] ^= xtimetbl[a[j] ^ a[j + 4]] ^ tmp;\n+            b[1] ^= xtimetbl[a[j + 4] ^ a[j + 8]] ^ tmp;\n+            b[2] ^= xtimetbl[a[j + 8] ^ a[j + 12]] ^ tmp;\n+            b[3] ^= xtimetbl[a[j + 12] ^ a[j]] ^ tmp;\n+\n+            for (int i = 0; i < 4; i++) {\n+                a[i * 4 + j] = b[i];\n+            }\n+        }\n+    }\n+\n+    private void invMixColumn(int[] a) {\n+        int[][] b = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };\n+        for (int j = 0; j < 4; j++) {\n+            for (int i = 0; i < 4; i++) {\n+                b[i][j] = gmul(0xe, a[i * 4 + j]) ^ gmul(0xb, a[((i + 1) % 4) * 4 + j])\n+                        ^ gmul(0xd, a[((i + 2) % 4) * 4 + j]) ^ gmul(0x9, a[((i + 3) % 4) * 4 + j]);\n+            }\n+        }\n+\n+        for (int j = 0; j < 4; j++) {\n+            for (int i = 0; i < 4; i++) {\n+                a[i * 4 + j] = b[i][j];\n+            }\n+        }\n+    }\n+\n+    private void shiftRow(int[] a, int d) {\n+        int[] tmpArray = new int[] { 0, 0, 0, 0 };\n+        for (int i = 1; i < 4; i++) {\n+            for (int j = 0; j < 4; j++) {\n+                int[][][] shifts = EncryptionHandlerConstants.SHIFTS;\n+                int index = i * 4 + (j + shifts[0][i][d]) % 4;\n+                tmpArray[j] = a[index];\n+            }\n+            for (int j = 0; j < 4; j++) {\n+                a[i * 4 + j] = tmpArray[j];\n+            }\n+        }\n+    }\n+\n+    private void keyAddition(int[] a, int[] rk) {", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNDAyNg==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429014026", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte[] fillArray(byte[] keyBytes) {\n          \n          \n            \n                private static byte[] fillArray(byte[] keyBytes) {", "author": "cpmeister", "createdAt": "2020-05-22T02:41:15Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {\n+        ParadoxUtil.printByteArray(description, array, array.length);\n+    }\n+\n+    private byte[] fillArray(byte[] keyBytes) {", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNDE4OA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429014188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void printArray(String description, byte[] array) {\n          \n          \n            \n                private static void printArray(String description, byte[] array) {", "author": "cpmeister", "createdAt": "2020-05-22T02:41:59Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }\n+\n+    public static EncryptionHandler getInstance() {\n+        if (instance == null) {\n+            synchronized (EncryptionHandler.class) {\n+                instance = new EncryptionHandler();\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    public byte[] encrypt(byte[] payload) {\n+        if (payload == null) {\n+            throw new IllegalArgumentException(\"Payload should not be null or empty !\");\n+        }\n+\n+        if (payload.length % 16 != 0) {\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\n+            printArray(\"Array had to be extended:\", payload);\n+            logger.trace(\"New payload length={}\", payload.length);\n+        }\n+\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] s = EncryptionHandlerConstants.S;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\n+\n+            for (int r = 1; r < rounds; r++) {\n+                sBox(a, s);\n+                shiftRow(a, 0);\n+                mixColumn(a);\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+            }\n+            sBox(a, s);\n+            shiftRow(a, 0);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Encrypted array\", result);\n+        return result;\n+    }\n+\n+    public byte[] decrypt(byte[] payload) {\n+        int[] payloadAsIntArray = ParadoxUtil.copyArray(payload);\n+\n+        final int[] si = EncryptionHandlerConstants.Si;\n+        byte[] result = new byte[0];\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 16 * rounds, (rounds + 1) * 16));\n+            sBox(a, si);\n+            shiftRow(a, 1);\n+\n+            for (int r = rounds - 1; r > 0; r--) {\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\n+                invMixColumn(a);\n+                sBox(a, si);\n+                shiftRow(a, 1);\n+            }\n+\n+            keyAddition(a, expandedKey);\n+\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.copyArray(a));\n+        }\n+\n+        printArray(\"Decrypted array\", result);\n+        return result;\n+    }\n+\n+    private void printArray(String description, byte[] array) {", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNDczOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429014739", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int[] lTable = new int[TABLE_SIZE];\n          \n          \n            \n                private int[] aTable = new int[TABLE_SIZE];\n          \n          \n            \n                private static int[] lTable = new int[TABLE_SIZE];\n          \n          \n            \n                private static int[] aTable = new int[TABLE_SIZE];\n          \n          \n            \n                \n          \n          \n            \n                static{\n          \n          \n            \n                    generateTables();\n          \n          \n            \n                }", "author": "cpmeister", "createdAt": "2020-05-22T02:44:19Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNTI1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429015255", "bodyText": "If you initialize the tables statically, you can remove this constructor.", "author": "cpmeister", "createdAt": "2020-05-22T02:46:31Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\n+ *      python</a>\n+ */\n+public class EncryptionHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\n+\n+    private static final int KEY_ARRAY_LENGTH = 32;\n+    private static final int TABLE_SIZE = 256;\n+    private static final int KEY_LENGTH = 240;\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\n+\n+    private static EncryptionHandler instance;\n+\n+    private int[] lTable = new int[TABLE_SIZE];\n+    private int[] aTable = new int[TABLE_SIZE];\n+\n+    private int[] expandedKey = new int[KEY_LENGTH];\n+\n+    private EncryptionHandler() {\n+        generateTables();\n+    }", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNTc0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429015742", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-05-22T02:48:37Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/IResponseReceiver.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication;\n+\n+/**\n+ * The {@link IResponseReceiver} Used to pass parsed responses from Paradox to original senders of the requests for\n+ * further processing.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ */\n+public interface IResponseReceiver {", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAxNjYwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r429016609", "bodyText": "Yeah, I'm not going to heed that. If you are trying to avoid IP issues it is best to change a much as possible.", "author": "cpmeister", "createdAt": "2020-05-22T02:52:35Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+import java.util.Arrays;\n+\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\n+ *\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\n+ *\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\n+ * The first response contains the key that will be used for the rest of communication.\n+ *\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\n+ * it as it is.", "originalCommit": "da6e378ec528d5669c07fda967a32cdd58d11180", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ae8309737c847d5d7e8c0d26e531295bca179e4d", "url": "https://github.com/openhab/openhab-addons/commit/ae8309737c847d5d7e8c0d26e531295bca179e4d", "message": "Spotless:apply on all files in paradoxalarm folder\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-05-22T13:36:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4ODY3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r430788678", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (i % 8 == 0) {\n          \n          \n            \n                            for (int j = 0; j < 4; j++) {\n          \n          \n            \n                                temp[j] = s[temp[j]];\n          \n          \n            \n                            }\n          \n          \n            \n                            int tmp = temp[0];\n          \n          \n            \n            \n          \n          \n            \n                            for (int j = 1; j < 4; j++) {\n          \n          \n            \n                                temp[j - 1] = temp[j];\n          \n          \n            \n                            }\n          \n          \n            \n            \n          \n          \n            \n                            temp[3] = tmp;\n          \n          \n            \n                            temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n          \n          \n            \n                        } else if (i % 8 == 4) {\n          \n          \n            \n                            for (int j = 0; j < 4; j++) {\n          \n          \n            \n                                temp[j] = s[temp[j]];\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        if (i % 4 == 0) {\n          \n          \n            \n                            for (int j = 0; j < 4; j++) {\n          \n          \n            \n                                temp[j] = s[temp[j]];\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                        if (i % 8 == 0) {\n          \n          \n            \n                            int tmp = temp[0];\n          \n          \n            \n            \n          \n          \n            \n                            for (int j = 1; j < 4; j++) {\n          \n          \n            \n                                temp[j - 1] = temp[j];\n          \n          \n            \n                            }\n          \n          \n            \n            \n          \n          \n            \n                            temp[3] = tmp;\n          \n          \n            \n                            temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\n          \n          \n            \n                        }", "author": "cpmeister", "createdAt": "2020-05-27T01:04:01Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+\r\n+    private static EncryptionHandler instance = new EncryptionHandler();\r\n+\r\n+    private int[] lTable = new int[TABLE_SIZE];\r\n+    private int[] aTable = new int[TABLE_SIZE];\r\n+\r\n+    private int[] expandedKey = new int[KEY_LENGTH];\r\n+\r\n+    private EncryptionHandler() {\r\n+        generateTables();\r\n+    }\r\n+\r\n+    public static EncryptionHandler getInstance() {\r\n+        return instance;\r\n+    }\r\n+\r\n+    public byte[] encrypt(byte[] payload) {\r\n+        if (payload.length % 16 != 0) {\r\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\r\n+            printArray(\"Array had to be extended:\", payload);\r\n+            logger.trace(\"New payload length={}\", payload.length);\r\n+        }\r\n+\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\r\n+\r\n+            for (int r = 1; r <= rounds; r++) {\r\n+                sBox(a, s);\r\n+                shiftRow(a, 0);\r\n+                if (r != rounds) {\r\n+                    mixColumn(a);\r\n+                }\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+            }\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Encrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    public byte[] decrypt(byte[] payload) {\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] si = EncryptionHandlerConstants.Si;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+\r\n+            for (int r = rounds; r > 0; r--) {\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+                if (r != rounds) {\r\n+                    invMixColumn(a);\r\n+                }\r\n+                sBox(a, si);\r\n+                shiftRow(a, 1);\r\n+            }\r\n+\r\n+            keyAddition(a, expandedKey);\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Decrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    private void printArray(String description, byte[] array) {\r\n+        ParadoxUtil.printByteArray(description, array, array.length);\r\n+    }\r\n+\r\n+    private byte[] fillArray(byte[] keyBytes) {\r\n+        byte[] byteArray = new byte[keyBytes.length];\r\n+        for (int i = 0; i < keyBytes.length; i++) {\r\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\r\n+        }\r\n+\r\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\r\n+        return expandedArray;\r\n+    }\r\n+\r\n+    public synchronized void updateKey(byte[] newKey) {\r\n+        expandedKey = new int[KEY_LENGTH];\r\n+        expandKey(newKey);\r\n+    }\r\n+\r\n+    private void expandKey(byte[] input) {\r\n+        // fill array to 32th byte with 0xEE\r\n+        byte[] filledArray = fillArray(input);\r\n+\r\n+        int[] temp = { 0, 0, 0, 0 };\r\n+        for (int i = 0; i < 4; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\r\n+            }\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\r\n+            }\r\n+        }\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        for (int i = 8; i < 60; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\r\n+            }\r\n+\r\n+            if (i % 8 == 0) {\r\n+                for (int j = 0; j < 4; j++) {\r\n+                    temp[j] = s[temp[j]];\r\n+                }\r\n+                int tmp = temp[0];\r\n+\r\n+                for (int j = 1; j < 4; j++) {\r\n+                    temp[j - 1] = temp[j];\r\n+                }\r\n+\r\n+                temp[3] = tmp;\r\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\r\n+            } else if (i % 8 == 4) {\r\n+                for (int j = 0; j < 4; j++) {\r\n+                    temp[j] = s[temp[j]];\r\n+                }\r\n+            }\r", "originalCommit": "99cb016a9532ba274c680455edb02fbd0021fcde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDEyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r430790128", "bodyText": "Why not just use a ByteBuffer here instead? You are already using one to append the payloadLength. Another option is to wrap your ByteArrayOutputStream in a DataOutputStream and use that to append short values and the like.", "author": "cpmeister", "createdAt": "2020-05-27T01:09:48Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/ParadoxIPPacket.java", "diffHunk": "@@ -26,173 +26,128 @@\n  *\n  * @author Konstantin Polihronov - Initial contribution\n  */\n-public class ParadoxIPPacket implements IPPacketPayload {\n+public class ParadoxIPPacket implements IPPacket {\n \n     public static final byte[] EMPTY_PAYLOAD = new byte[0];\n \n-    /**\n-     * Start of header - always 0xAA\n-     */\n-    private byte startOfHeader = (byte) 0xAA;\n-\n-    /**\n-     * Payload length - 2 bytes (LL HH)\n-     */\n-    private short payloadLength = 0;\n-\n-    /**\n-     * \"Message Type: 0x01: IP responses 0x02: Serial/pass through cmd response\n-     * 0x03: IP requests 0x04: Serial/pass through cmd requests\"\n-     */\n-    private byte messageType = 0x03;\n-\n-    /**\n-     * \"IP Encryption 0x08: Disabled 0x09: Enabled\"\n-     */\n-    private byte encryption = 0x08;\n-    private byte command = 0;\n-    private byte subCommand = 0;\n-    private byte unknown0 = 0x0A;\n-\n-    /**\n-     * Padding bytes to fill the header to 16 bytes with 0xEE.\n-     */\n-    private long theRest = 0xEEEEEEEEEEEEEEEEl;\n+    private PacketHeader header;\n     private byte[] payload;\n-    private boolean isChecksumRequired;\n \n-    public ParadoxIPPacket(IPPacketPayload payload) {\n-        this(payload.getBytes(), true);\n-    }\n-\n-    public ParadoxIPPacket(String payload, boolean isChecksumRequired) {\n-        this(payload.getBytes(StandardCharsets.US_ASCII), isChecksumRequired);\n+    public ParadoxIPPacket(byte[] bytes) {\n+        this(bytes, true);\n     }\n \n+    @SuppressWarnings(\"null\")\n     public ParadoxIPPacket(byte[] payload, boolean isChecksumRequired) {\n-        this.isChecksumRequired = isChecksumRequired;\n-\n-        if (payload == null) {\n-            this.payload = new byte[0];\n-            this.payloadLength = 0;\n-        } else {\n-            this.payload = payload;\n-            this.payloadLength = (short) payload.length;\n+        this.payload = payload != null ? payload : new byte[0];\n+        if (isChecksumRequired) {\n+            payload[payload.length - 1] = ParadoxUtil.calculateChecksum(payload);\n         }\n-\n-        // TODO: Figure out how to fill up to 16, 32, 48, etc sizes with 0xEE\n-        // if (payload.length < 16) {\n-        // this.payload = extendPayload(16, payload);\n-        // } else {\n-        // }\n+        short payloadLength = (short) (payload != null ? payload.length : 0);\n+        header = new PacketHeader(payloadLength);\n     }\n \n     @Override\n     public byte[] getBytes() {\n         try {\n             ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n \n-            outputStream.write(startOfHeader);\n-            outputStream.write(ByteBuffer.allocate(Short.SIZE / Byte.SIZE).order(ByteOrder.LITTLE_ENDIAN)\n-                    .putShort(payloadLength).array());\n-            outputStream.write(messageType);\n-            outputStream.write(encryption);\n-            outputStream.write(command);\n-            outputStream.write(subCommand);\n-            outputStream.write(unknown0);\n-            outputStream.write(ByteBuffer.allocate(Long.SIZE / Byte.SIZE).putLong(theRest).array());\n+            outputStream.write(header.getBytes());\n             outputStream.write(payload);\n             byte[] byteArray = outputStream.toByteArray();\n \n-            if (isChecksumRequired) {\n-                byteArray[byteArray.length - 1] = ParadoxUtil.calculateChecksum(payload);\n-            }\n-\n             return byteArray;\n         } catch (IOException e) {\n             throw new ParadoxRuntimeException(\"Unable to create byte array stream.\", e);\n         }\n     }\n \n-    public byte getStartOfHeader() {\n-        return startOfHeader;\n-    }\n-\n-    public ParadoxIPPacket setStartOfHeader(byte startOfHeader) {\n-        this.startOfHeader = startOfHeader;\n-        return this;\n-    }\n-\n-    public short getPayloadLength() {\n-        return payloadLength;\n-    }\n-\n-    public ParadoxIPPacket setPayloadLength(short payloadLength) {\n-        this.payloadLength = payloadLength;\n-        return this;\n-    }\n-\n-    public byte getMessageType() {\n-        return messageType;\n-    }\n-\n-    public ParadoxIPPacket setMessageType(byte messageType) {\n-        this.messageType = messageType;\n+    public ParadoxIPPacket setCommand(HeaderCommand command) {\n+        header.command = command.getValue();\n         return this;\n     }\n \n     public ParadoxIPPacket setMessageType(HeaderMessageType messageType) {\n-        this.messageType = messageType.getValue();\n+        header.messageType = messageType.getValue();\n         return this;\n     }\n \n-    public byte getEncryption() {\n-        return encryption;\n-    }\n-\n-    public ParadoxIPPacket setEncryption(byte encryption) {\n-        this.encryption = encryption;\n+    public ParadoxIPPacket setUnknown0(byte unknownByteValue) {\n+        header.unknown0 = unknownByteValue;\n         return this;\n     }\n \n-    public byte getCommand() {\n-        return command;\n-    }\n-\n-    public ParadoxIPPacket setCommand(HeaderCommand command) {\n-        this.command = command.getValue();\n-        return this;\n-    }\n-\n-    public ParadoxIPPacket setCommand(byte command) {\n-        this.command = command;\n-        return this;\n+    @Override\n+    public PacketHeader getHeader() {\n+        return header;\n     }\n \n-    public byte getSubCommand() {\n-        return subCommand;\n+    @Override\n+    public byte[] getPayload() {\n+        return payload;\n     }\n \n-    public ParadoxIPPacket setSubCommand(byte subCommand) {\n-        this.subCommand = subCommand;\n-        return this;\n+    @Override\n+    public void encrypt() {\n+        EncryptionHandler encryptionHandler = EncryptionHandler.getInstance();\n+        payload = encryptionHandler.encrypt(payload);\n+        header.encryption = 0x09;\n     }\n \n-    public byte getUnknown0() {\n-        return unknown0;\n+    @Override\n+    public String toString() {\n+        return \"ParadoxIPPacket [\" + ParadoxUtil.byteArrayToString(getBytes()) + \"]\";\n     }\n \n-    public ParadoxIPPacket setUnknown0(byte unknown0) {\n-        this.unknown0 = unknown0;\n-        return this;\n-    }\n+    public class PacketHeader {\n \n-    public long getTheRest() {\n-        return theRest;\n-    }\n+        public PacketHeader(short payloadLength) {\n+            this.payloadLength = payloadLength;\n+        }\n \n-    public ParadoxIPPacket setTheRest(long theRest) {\n-        this.theRest = theRest;\n-        return this;\n+        /**\n+         * Start of header - always 0xAA\n+         */\n+        private byte startOfHeader = (byte) 0xAA;\n+\n+        /**\n+         * Payload length - 2 bytes (LL HH)\n+         */\n+        private short payloadLength = 0;\n+\n+        /**\n+         * \"Message Type: 0x01: IP responses 0x02: Serial/pass through cmd response\n+         * 0x03: IP requests 0x04: Serial/pass through cmd requests\"\n+         */\n+        private byte messageType = 0x03;\n+\n+        /**\n+         * \"IP Encryption 0x08: Disabled 0x09: Enabled\"\n+         */\n+        private byte encryption = 0x08;\n+        private byte command = 0;\n+        private byte subCommand = 0;\n+        private byte unknown0 = 0x00;\n+        private byte unknown1 = 0x01;\n+\n+        public byte[] getBytes() {\n+            try {\n+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();", "originalCommit": "99cb016a9532ba274c680455edb02fbd0021fcde", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzNzcyOA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r431037728", "bodyText": "Hi, as I never used bytebuffer before I've just checked when it's used and some examples.\nIs this example that I've created correct usage of the ByteBuffer?\n  ByteBuffer buf = ByteBuffer.wrap(header.getBytes()); buf.put(payload); return buf.array();\nThe code becomes way simpler and I like it much more but I'm not sure if it's OK to return the backing array or I should create a new one here (clone of the backing array). I guess it's fine to return it as it's used only here...", "author": "theater", "createdAt": "2020-05-27T11:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0MTQ0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r431041442", "bodyText": "Just saw another example in stackoverflow which looks more correct, i.e. this one. To me this should be the right way as probably the backing array may be longer than the actual bytes in the buffer... What do you think? ByteBuffer buf = ... byte[] arr = new byte[buf.remaining()]; buf.get(arr);", "author": "theater", "createdAt": "2020-05-27T11:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzNzY3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r431437678", "bodyText": "The safest route would be:\nbyte[] bufferArray = new byte[BUFFERLENGTH];\nByteButter buf = ByteBuffer.wrap(bufferArray);\n...\nbuf.put(...);\nbuf.put(...);\n...\nreturn bufferArray;\n\nYou just need to make sure that you know the exact size of byte array you need ahead of time.", "author": "cpmeister", "createdAt": "2020-05-27T20:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDU4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r430790586", "bodyText": "Make sure to cancel this delayed future when the handler is disposed", "author": "cpmeister", "createdAt": "2020-05-27T01:11:26Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/handlers/EntityBaseHandler.java", "diffHunk": "@@ -44,32 +46,51 @@ public EntityBaseHandler(Thing thing) {\n \n     @Override\n     public void initialize() {\n-        logger.debug(\"Start initializing. {}\", thing.getLabel());\n+        logger.trace(\"Start initializing. {}\", thing.getUID());\n         updateStatus(ThingStatus.UNKNOWN);\n \n         config = getConfigAs(EntityConfiguration.class);\n \n+        timeStamp = System.currentTimeMillis();\n         scheduler.schedule(this::initializeDelayed, INITIAL_DELAY_SECONDS, TimeUnit.SECONDS);\n     }\n \n     private void initializeDelayed() {\n-        logger.trace(\"Start initializeDelayed() in {}\", getThing().getUID());\n+        logger.debug(\"Start initializeDelayed() in {}\", getThing().getUID());\n         ParadoxPanel panel = ParadoxPanel.getInstance();\n-        if (!panel.isPanelSupported()) {\n+        // Asynchronous update not yet done\n+        if (panel.getPanelInformation() == null) {\n+            // Retry until reach MAX_WAIT_TIME\n+            if (System.currentTimeMillis() - timeStamp <= MAX_WAIT_TIME_MILLIS) {\n+                logger.debug(\"Panel information is null. Scheduling initializeDelayed() to be executed again in {} sec\",\n+                        INITIAL_DELAY_SECONDS);\n+                scheduler.schedule(this::initializeDelayed, INITIAL_DELAY_SECONDS, TimeUnit.SECONDS);", "originalCommit": "99cb016a9532ba274c680455edb02fbd0021fcde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3e773f2dda059bf04500bc0e6b54881701bb6619", "url": "https://github.com/openhab/openhab-addons/commit/3e773f2dda059bf04500bc0e6b54881701bb6619", "message": "Encryption support flattened and rebased\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-05-27T09:47:35Z", "type": "commit"}, {"oid": "f11ba9e391fc01ec542c301254d186c559f9a9ee", "url": "https://github.com/openhab/openhab-addons/commit/f11ba9e391fc01ec542c301254d186c559f9a9ee", "message": "Spotless:apply on all files in paradoxalarm folder\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-05-27T09:47:38Z", "type": "commit"}, {"oid": "8d3eff46fc23b4fe9b193b9dc6715cf750a94e03", "url": "https://github.com/openhab/openhab-addons/commit/8d3eff46fc23b4fe9b193b9dc6715cf750a94e03", "message": "Cosmetic changes based on cpmeisters feedback #1\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-05-27T09:50:11Z", "type": "commit"}, {"oid": "6048188deefb3fc67767b8d94b0d40ba12cce95e", "url": "https://github.com/openhab/openhab-addons/commit/6048188deefb3fc67767b8d94b0d40ba12cce95e", "message": "Changes based on cpmeister's review #2\n\n* Refactored encrypt and decrypt methods to get rid of duplicate code\noutside of for loops handling the border cases.\n* Refactored the gmul method to be much more easier to read and much\nmore clear what it does.\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-05-27T09:50:14Z", "type": "commit"}, {"oid": "1299283cb4c20eb849f52e84e7bafc05159cb308", "url": "https://github.com/openhab/openhab-addons/commit/1299283cb4c20eb849f52e84e7bafc05159cb308", "message": "Changes based on cpmeister's review #3\n\n* Resolve conflicts in pom.xml\n* Requested changes in expandKey method\n* Added disposal of futures in EntityBaseHandler in dispose() method\n* Usage of ByteBuffer instead of ByteArrayOutputStream in getBytes()\nmethods of ParadoxIPPacket, CommandPayload and MemoryRequestPayload\nclasses\n* Added tests for checking the getBytes functionality of changed classes\n* Added test of encryption handler which checks against a particular\nexpected result\n\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-05-28T16:44:00Z", "type": "commit"}, {"oid": "1299283cb4c20eb849f52e84e7bafc05159cb308", "url": "https://github.com/openhab/openhab-addons/commit/1299283cb4c20eb849f52e84e7bafc05159cb308", "message": "Changes based on cpmeister's review #3\n\n* Resolve conflicts in pom.xml\n* Requested changes in expandKey method\n* Added disposal of futures in EntityBaseHandler in dispose() method\n* Usage of ByteBuffer instead of ByteArrayOutputStream in getBytes()\nmethods of ParadoxIPPacket, CommandPayload and MemoryRequestPayload\nclasses\n* Added tests for checking the getBytes functionality of changed classes\n* Added test of encryption handler which checks against a particular\nexpected result\n\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-05-28T16:44:00Z", "type": "forcePushed"}, {"oid": "641bedb6d154710b8a7dca1201a5aed0d6c7bd19", "url": "https://github.com/openhab/openhab-addons/commit/641bedb6d154710b8a7dca1201a5aed0d6c7bd19", "message": "Make EncryptionHandler instance immutable\n\n* Make encryption handler instance to always get created when the key is\nupdated\n* Changed aTable and lTable to be static and all necessary methods used\nin table generation to be also static\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-05-29T13:12:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2OTQ2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432069469", "bodyText": "No harm in cancelling something that is already done.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (delayedSchedule != null && !delayedSchedule.isCancelled() && !delayedSchedule.isDone()) {\n          \n          \n            \n                    if (delayedSchedule != null) {", "author": "cpmeister", "createdAt": "2020-05-28T19:28:40Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/handlers/EntityBaseHandler.java", "diffHunk": "@@ -94,6 +96,15 @@ public void handleCommand(ChannelUID channelUID, Command command) {\n         }\n     }\n \n+    @Override\n+    public void dispose() {\n+        if (delayedSchedule != null && !delayedSchedule.isCancelled() && !delayedSchedule.isDone()) {", "originalCommit": "1299283cb4c20eb849f52e84e7bafc05159cb308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MDMwNw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432070307", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int partitionNumber;\n          \n          \n            \n                private PartitionCommand command;\n          \n          \n            \n                private final int partitionNumber;\n          \n          \n            \n                private final PartitionCommand command;", "author": "cpmeister", "createdAt": "2020-05-28T19:30:17Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/CommandPayload.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.messages;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * The {@link CommandPayload} Class that structures the payload for partition commands.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ */\n+public class CommandPayload implements IPayload {\n+\n+    private static final int BYTES_LENGTH = 15;\n+\n+    private final byte MESSAGE_START = 0x40;\n+    private final byte PAYLOAD_SIZE = 0x0f;\n+    private final byte[] EMPTY_FOUR_BYTES = { 0, 0, 0, 0 };\n+    private final byte CHECKSUM = 0;\n+\n+    private int partitionNumber;\n+    private PartitionCommand command;", "originalCommit": "1299283cb4c20eb849f52e84e7bafc05159cb308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MDU5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432070593", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int address;\n          \n          \n            \n                private byte bytesToRead;\n          \n          \n            \n                private final int address;\n          \n          \n            \n                private final byte bytesToRead;", "author": "cpmeister", "createdAt": "2020-05-28T19:30:52Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/MemoryRequestPayload.java", "diffHunk": "@@ -1,88 +1,78 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.paradoxalarm.internal.communication.messages;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-\n-import org.openhab.binding.paradoxalarm.internal.exceptions.ParadoxException;\n-import org.openhab.binding.paradoxalarm.internal.exceptions.ParadoxRuntimeException;\n-import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link EpromRequestPayload} Abstract class which contains common logic used in RAM and EPROM payload generation\n- * classes.\n- *\n- * @author Konstantin Polihronov - Initial contribution\n- */\n-public abstract class MemoryRequestPayload implements IPPacketPayload {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MemoryRequestPayload.class);\n-\n-    private static final short MESSAGE_START = (short) ((0x50 << 8) | 0x08);\n-\n-    private int address;\n-    private byte bytesToRead;\n-\n-    public MemoryRequestPayload(int address, byte bytesToRead) throws ParadoxException {\n-        if (bytesToRead < 1 || bytesToRead > 64) {\n-            throw new ParadoxException(\"Invalid bytes to read. Valid values are 1 to 64.\");\n-        }\n-\n-        this.address = address;\n-        this.bytesToRead = bytesToRead;\n-\n-        logTraceHexFormatted(\"MessageStart: {}\", MESSAGE_START);\n-    }\n-\n-    protected abstract byte calculateControlByte();\n-\n-    @Override\n-    public byte[] getBytes() {\n-        try {\n-            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-\n-            outputStream.write(ParadoxUtil.shortToByteArray(MESSAGE_START));\n-            outputStream.write(calculateControlByte());\n-            outputStream.write((byte) 0x00);\n-\n-            outputStream.write(ParadoxUtil.shortToByteArray((short) address));\n-\n-            outputStream.write(bytesToRead);\n-\n-            // The bellow 0x00 is dummy which will be overwritten by the checksum\n-            outputStream.write(0x00);\n-            byte[] byteArray = outputStream.toByteArray();\n-\n-            return byteArray;\n-        } catch (IOException e) {\n-            throw new ParadoxRuntimeException(\"Unable to create byte array stream.\", e);\n-        }\n-    }\n-\n-    protected int getAddress() {\n-        return address;\n-    }\n-\n-    protected void logTraceHexFormatted(String text, int address) {\n-        logTraceOptional(text, \"0x%02X,\\t\", address);\n-    }\n-\n-    private void logTraceOptional(String text, String format, int address) {\n-        if (logger.isTraceEnabled()) {\n-            logger.trace(\"Address: {}\", String.format(format, address));\n-        }\n-    }\n-}\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.messages;\r\n+\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+\r\n+import org.openhab.binding.paradoxalarm.internal.exceptions.ParadoxException;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * The {@link MemoryRequestPayload} Abstract class which contains common logic used in RAM and EPROM payload generation\r\n+ * classes.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ */\r\n+public abstract class MemoryRequestPayload implements IPayload {\r\n+\r\n+    private static final int BUFFER_LENGTH = 8;\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(MemoryRequestPayload.class);\r\n+\r\n+    private static final short MESSAGE_START = (short) ((0x50 << 8) | 0x08);\r\n+\r\n+    private int address;\r\n+    private byte bytesToRead;\r", "originalCommit": "1299283cb4c20eb849f52e84e7bafc05159cb308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MDkzMg==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432070932", "bodyText": "Please add @NonNullByDefault", "author": "cpmeister", "createdAt": "2020-05-28T19:31:32Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandlerConstants.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\n+\n+/**\n+ *\n+ * Constant\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ *\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\n+ */\n+public class EncryptionHandlerConstants {", "originalCommit": "1299283cb4c20eb849f52e84e7bafc05159cb308", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxMDkzOA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432710938", "bodyText": "Instead of copying ranges of the expandedKey every time, you should just change this method to accept range parameters.", "author": "cpmeister", "createdAt": "2020-05-29T20:07:53Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+\r\n+    private static int[] lTable = new int[TABLE_SIZE];\r\n+    private static int[] aTable = new int[TABLE_SIZE];\r\n+\r\n+    private static EncryptionHandler instance = new EncryptionHandler(new byte[] {});\r\n+    static {\r\n+        generateTables();\r\n+    }\r\n+\r\n+    private int[] expandedKey = new int[KEY_LENGTH];\r\n+\r\n+    private EncryptionHandler(byte[] newKey) {\r\n+        if (newKey.length > 0) {\r\n+            expandKey(newKey);\r\n+        }\r\n+    }\r\n+\r\n+    public static EncryptionHandler getInstance() {\r\n+        return instance;\r\n+    }\r\n+\r\n+    public byte[] encrypt(byte[] payload) {\r\n+        if (payload.length % 16 != 0) {\r\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\r\n+            printArray(\"Array had to be extended:\", payload);\r\n+            logger.trace(\"New payload length={}\", payload.length);\r\n+        }\r\n+\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\r\n+\r\n+            for (int r = 1; r <= rounds; r++) {\r\n+                sBox(a, s);\r\n+                shiftRow(a, 0);\r\n+                if (r != rounds) {\r\n+                    mixColumn(a);\r\n+                }\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+            }\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Encrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    public byte[] decrypt(byte[] payload) {\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] si = EncryptionHandlerConstants.Si;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+\r\n+            for (int r = rounds; r > 0; r--) {\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+                if (r != rounds) {\r\n+                    invMixColumn(a);\r\n+                }\r\n+                sBox(a, si);\r\n+                shiftRow(a, 1);\r\n+            }\r\n+\r\n+            keyAddition(a, expandedKey);\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Decrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    private void printArray(String description, byte[] array) {\r\n+        ParadoxUtil.printByteArray(description, array, array.length);\r\n+    }\r\n+\r\n+    private byte[] fillArray(byte[] keyBytes) {\r\n+        byte[] byteArray = new byte[keyBytes.length];\r\n+        for (int i = 0; i < keyBytes.length; i++) {\r\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\r\n+        }\r\n+\r\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\r\n+        return expandedArray;\r\n+    }\r\n+\r\n+    public synchronized EncryptionHandler updateKey(byte[] newKey) {\r\n+        instance = new EncryptionHandler(newKey);\r\n+        return instance;\r\n+    }\r\n+\r\n+    private void expandKey(byte[] input) {\r\n+        // fill array to 32th byte with 0xEE\r\n+        byte[] filledArray = fillArray(input);\r\n+\r\n+        int[] temp = { 0, 0, 0, 0 };\r\n+        for (int i = 0; i < 4; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\r\n+            }\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\r\n+            }\r\n+        }\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        for (int i = 8; i < 60; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\r\n+            }\r\n+\r\n+            if (i % 4 == 0) {\r\n+                for (int j = 0; j < 4; j++) {\r\n+                    temp[j] = s[temp[j]];\r\n+                }\r\n+            }\r\n+\r\n+            if (i % 8 == 0) {\r\n+                int tmp = temp[0];\r\n+\r\n+                for (int j = 1; j < 4; j++) {\r\n+                    temp[j - 1] = temp[j];\r\n+                }\r\n+\r\n+                temp[3] = tmp;\r\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\r\n+            }\r\n+\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\r\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private int gmul(int c, int b) {\r\n+        int s = lTable[c] + lTable[b];\r\n+        s %= 255;\r\n+        s = aTable[s];\r\n+        if (b == 0 || c == 0) {\r\n+            s = 0;\r\n+        }\r\n+        return s;\r\n+    }\r\n+\r\n+    private static void generateTables() {\r\n+        int a = 1;\r\n+        int d;\r\n+        for (int index = 0; index < 255; index++) {\r\n+            aTable[index] = a & 0xFF;\r\n+            /* Multiply by three */\r\n+            d = (a & 0x80) & 0xFF;\r\n+            a <<= 1;\r\n+            if (d == 0x80) {\r\n+                a ^= 0x1b;\r\n+                a &= 0xFF;\r\n+            }\r\n+            a ^= aTable[index];\r\n+            a &= 0xFF;\r\n+            /* Set the log table value */\r\n+            lTable[aTable[index]] = index & 0xFF;\r\n+        }\r\n+        aTable[255] = aTable[0];\r\n+        lTable[0] = 0;\r\n+    }\r\n+\r\n+    private void sBox(int[] a, int[] box) {\r\n+        for (int i = 0; i < 16; i++) {\r\n+            a[i] = box[a[i]];\r\n+        }\r\n+    }\r\n+\r\n+    private void mixColumn(int[] a) {\r\n+        final int[] xtimetbl = EncryptionHandlerConstants.XTIMETABLE;\r\n+\r\n+        int[] b = new int[] { 0, 0, 0, 0 };\r\n+        for (int j = 0; j < 4; j++) {\r\n+            int tmp = a[j] ^ a[j + 4] ^ a[j + 8] ^ a[j + 12];\r\n+            for (int i = 0; i < 4; i++) {\r\n+                b[i] = a[i * 4 + j];\r\n+            }\r\n+            b[0] ^= xtimetbl[a[j] ^ a[j + 4]] ^ tmp;\r\n+            b[1] ^= xtimetbl[a[j + 4] ^ a[j + 8]] ^ tmp;\r\n+            b[2] ^= xtimetbl[a[j + 8] ^ a[j + 12]] ^ tmp;\r\n+            b[3] ^= xtimetbl[a[j + 12] ^ a[j]] ^ tmp;\r\n+\r\n+            for (int i = 0; i < 4; i++) {\r\n+                a[i * 4 + j] = b[i];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void invMixColumn(int[] a) {\r\n+        int[][] b = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };\r\n+        for (int j = 0; j < 4; j++) {\r\n+            for (int i = 0; i < 4; i++) {\r\n+                b[i][j] = gmul(0xe, a[i * 4 + j]) ^ gmul(0xb, a[((i + 1) % 4) * 4 + j])\r\n+                        ^ gmul(0xd, a[((i + 2) % 4) * 4 + j]) ^ gmul(0x9, a[((i + 3) % 4) * 4 + j]);\r\n+            }\r\n+        }\r\n+\r\n+        for (int j = 0; j < 4; j++) {\r\n+            for (int i = 0; i < 4; i++) {\r\n+                a[i * 4 + j] = b[i][j];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void shiftRow(int[] a, int d) {\r\n+        int[] tmpArray = new int[] { 0, 0, 0, 0 };\r\n+        for (int i = 1; i < 4; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                int[][][] shifts = EncryptionHandlerConstants.SHIFTS;\r\n+                int index = i * 4 + (j + shifts[0][i][d]) % 4;\r\n+                tmpArray[j] = a[index];\r\n+            }\r\n+            for (int j = 0; j < 4; j++) {\r\n+                a[i * 4 + j] = tmpArray[j];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private void keyAddition(int[] a, int[] rk) {\r", "originalCommit": "641bedb6d154710b8a7dca1201a5aed0d6c7bd19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0NDUzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432944539", "bodyText": "Thanks for noticing that. Actually it seems that only the startIndex is sufficient as all the rest relies on 16 int arrays per addition.", "author": "theater", "createdAt": "2020-05-31T12:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxMDkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxMzA3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432713073", "bodyText": "Is rounds a constant?", "author": "cpmeister", "createdAt": "2020-05-29T20:12:54Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+\r\n+    private static int[] lTable = new int[TABLE_SIZE];\r\n+    private static int[] aTable = new int[TABLE_SIZE];\r\n+\r\n+    private static EncryptionHandler instance = new EncryptionHandler(new byte[] {});\r\n+    static {\r\n+        generateTables();\r\n+    }\r\n+\r\n+    private int[] expandedKey = new int[KEY_LENGTH];\r\n+\r\n+    private EncryptionHandler(byte[] newKey) {\r\n+        if (newKey.length > 0) {\r\n+            expandKey(newKey);\r\n+        }\r\n+    }\r\n+\r\n+    public static EncryptionHandler getInstance() {\r\n+        return instance;\r\n+    }\r\n+\r\n+    public byte[] encrypt(byte[] payload) {\r\n+        if (payload.length % 16 != 0) {\r\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\r\n+            printArray(\"Array had to be extended:\", payload);\r\n+            logger.trace(\"New payload length={}\", payload.length);\r\n+        }\r\n+\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r", "originalCommit": "641bedb6d154710b8a7dca1201a5aed0d6c7bd19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0MTIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432941236", "bodyText": "hm... seems so... extracted it as constant.", "author": "theater", "createdAt": "2020-05-31T12:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxMzA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxNTYxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432715615", "bodyText": "Please move this method to below the static{..} clause.", "author": "cpmeister", "createdAt": "2020-05-29T20:19:06Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+\r\n+    private static int[] lTable = new int[TABLE_SIZE];\r\n+    private static int[] aTable = new int[TABLE_SIZE];\r\n+\r\n+    private static EncryptionHandler instance = new EncryptionHandler(new byte[] {});\r\n+    static {\r\n+        generateTables();\r\n+    }\r\n+\r\n+    private int[] expandedKey = new int[KEY_LENGTH];\r\n+\r\n+    private EncryptionHandler(byte[] newKey) {\r\n+        if (newKey.length > 0) {\r\n+            expandKey(newKey);\r\n+        }\r\n+    }\r\n+\r\n+    public static EncryptionHandler getInstance() {\r\n+        return instance;\r\n+    }\r\n+\r\n+    public byte[] encrypt(byte[] payload) {\r\n+        if (payload.length % 16 != 0) {\r\n+            payload = ParadoxUtil.extendArray(payload, PAYLOAD_RATE_LENGTH);\r\n+            printArray(\"Array had to be extended:\", payload);\r\n+            logger.trace(\"New payload length={}\", payload.length);\r\n+        }\r\n+\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+            keyAddition(a, Arrays.copyOfRange(expandedKey, 0, 16));\r\n+\r\n+            for (int r = 1; r <= rounds; r++) {\r\n+                sBox(a, s);\r\n+                shiftRow(a, 0);\r\n+                if (r != rounds) {\r\n+                    mixColumn(a);\r\n+                }\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+            }\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Encrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    public byte[] decrypt(byte[] payload) {\r\n+        int[] payloadAsIntArray = ParadoxUtil.toIntArray(payload);\r\n+\r\n+        final int[] si = EncryptionHandlerConstants.Si;\r\n+        byte[] result = new byte[0];\r\n+        for (int i = 0, rounds = 14; i < payloadAsIntArray.length / 16; i++) {\r\n+            int[] a = Arrays.copyOfRange(payloadAsIntArray, i * 16, (i + 1) * 16);\r\n+\r\n+            for (int r = rounds; r > 0; r--) {\r\n+                keyAddition(a, Arrays.copyOfRange(expandedKey, r * 16, (r + 1) * 16));\r\n+                if (r != rounds) {\r\n+                    invMixColumn(a);\r\n+                }\r\n+                sBox(a, si);\r\n+                shiftRow(a, 1);\r\n+            }\r\n+\r\n+            keyAddition(a, expandedKey);\r\n+\r\n+            result = ParadoxUtil.mergeByteArrays(result, ParadoxUtil.toByteArray(a));\r\n+        }\r\n+\r\n+        printArray(\"Decrypted array\", result);\r\n+        return result;\r\n+    }\r\n+\r\n+    private void printArray(String description, byte[] array) {\r\n+        ParadoxUtil.printByteArray(description, array, array.length);\r\n+    }\r\n+\r\n+    private byte[] fillArray(byte[] keyBytes) {\r\n+        byte[] byteArray = new byte[keyBytes.length];\r\n+        for (int i = 0; i < keyBytes.length; i++) {\r\n+            byteArray[i] = (byte) (keyBytes[i] & 0xFF);\r\n+        }\r\n+\r\n+        byte[] expandedArray = ParadoxUtil.extendArray(byteArray, KEY_ARRAY_LENGTH);\r\n+        return expandedArray;\r\n+    }\r\n+\r\n+    public synchronized EncryptionHandler updateKey(byte[] newKey) {\r\n+        instance = new EncryptionHandler(newKey);\r\n+        return instance;\r\n+    }\r\n+\r\n+    private void expandKey(byte[] input) {\r\n+        // fill array to 32th byte with 0xEE\r\n+        byte[] filledArray = fillArray(input);\r\n+\r\n+        int[] temp = { 0, 0, 0, 0 };\r\n+        for (int i = 0; i < 4; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i] = filledArray[i * 4 + j] & 0xFF;\r\n+            }\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[j * 4 + i + 16] = filledArray[i * 4 + j + 16] & 0xFF;\r\n+            }\r\n+        }\r\n+\r\n+        final int[] s = EncryptionHandlerConstants.S;\r\n+        for (int i = 8; i < 60; i++) {\r\n+            for (int j = 0; j < 4; j++) {\r\n+                temp[j] = expandedKey[(((i - 1) & 0xfc) << 2) + ((i - 1) & 0x03) + j * 4];\r\n+            }\r\n+\r\n+            if (i % 4 == 0) {\r\n+                for (int j = 0; j < 4; j++) {\r\n+                    temp[j] = s[temp[j]];\r\n+                }\r\n+            }\r\n+\r\n+            if (i % 8 == 0) {\r\n+                int tmp = temp[0];\r\n+\r\n+                for (int j = 1; j < 4; j++) {\r\n+                    temp[j - 1] = temp[j];\r\n+                }\r\n+\r\n+                temp[3] = tmp;\r\n+                temp[0] ^= EncryptionHandlerConstants.RCON[(i / 8 - 1)];\r\n+            }\r\n+\r\n+            for (int j = 0; j < 4; j++) {\r\n+                expandedKey[((i & 0xfc) << 2) + (i & 0x03)\r\n+                        + j * 4] = expandedKey[(((i - 8) & 0xfc) << 2) + ((i - 8) & 0x03) + j * 4] ^ temp[j];\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    private int gmul(int c, int b) {\r\n+        int s = lTable[c] + lTable[b];\r\n+        s %= 255;\r\n+        s = aTable[s];\r\n+        if (b == 0 || c == 0) {\r\n+            s = 0;\r\n+        }\r\n+        return s;\r\n+    }\r\n+\r\n+    private static void generateTables() {\r", "originalCommit": "641bedb6d154710b8a7dca1201a5aed0d6c7bd19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNDUzNg==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432814536", "bodyText": "These should be QuantityType", "author": "cpmeister", "createdAt": "2020-05-30T06:05:17Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/handlers/ParadoxPanelHandler.java", "diffHunk": "@@ -50,6 +57,11 @@ protected void updateEntity() {\n             updateProperty(PANEL_APPLICATION_VERSION_PROPERTY_NAME,\n                     panelInformation.getApplicationVersion().toString());\n             updateProperty(PANEL_BOOTLOADER_VERSION_PROPERTY_NAME, panelInformation.getBootLoaderVersion().toString());\n+\n+            updateState(PANEL_TIME, new DateTimeType(panel.getPanelTime()));\n+            updateState(PANEL_INPUT_VOLTAGE, new DecimalType(panel.getVdcLevel()));\n+            updateState(PANEL_BOARD_VOLTAGE, new DecimalType(panel.getDcLevel()));\n+            updateState(PANEL_BATTERY_VOLTAGE, new DecimalType(panel.getBatteryLevel()));", "originalCommit": "641bedb6d154710b8a7dca1201a5aed0d6c7bd19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "525342c2adcdab5afc19b4180beffa6ab2d99c15", "url": "https://github.com/openhab/openhab-addons/commit/525342c2adcdab5afc19b4180beffa6ab2d99c15", "message": "Changes based on cpmeister's review #4\n\n* Make fields in payload classes final\n* Add nonnullbydefault to EncryptionHandlerConstants class\n* Change voltage types from DecimalType to QuantityType in\nParadoxPanelHandler\n* Remove unnecessary checks for delayed jobs\n* Move static generateTables() method on top\n* Extract ROUNDS from encrypt and decrypt methods as constant\n* Refactor keyAddition method to use startIndex instead of copy ranges\neverytime\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-05-31T12:56:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MzMwMA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432973300", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static int[] lTable = new int[TABLE_SIZE];\n          \n          \n            \n                private static int[] aTable = new int[TABLE_SIZE];\n          \n          \n            \n                private static final int[] lTable = new int[TABLE_SIZE];\n          \n          \n            \n                private static final int[] aTable = new int[TABLE_SIZE];", "author": "cpmeister", "createdAt": "2020-05-31T18:46:31Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+    private static final int ROUNDS = 14;\r\n+\r\n+    private static int[] lTable = new int[TABLE_SIZE];\r\n+    private static int[] aTable = new int[TABLE_SIZE];\r", "originalCommit": "525342c2adcdab5afc19b4180beffa6ab2d99c15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MzQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432973437", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private int[] expandedKey = new int[KEY_LENGTH];\n          \n          \n            \n                private final int[] expandedKey = new int[KEY_LENGTH];", "author": "cpmeister", "createdAt": "2020-05-31T18:48:23Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/crypto/EncryptionHandler.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.paradoxalarm.internal.communication.crypto;\r\n+\r\n+import java.util.Arrays;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.openhab.binding.paradoxalarm.internal.util.ParadoxUtil;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+/**\r\n+ * This class is used to encrypt and decrypt communication from/to Paradox system. Singleton pattern.\r\n+ *\r\n+ * Paradox encryption is using Rijndael 256-key expansion alghoritm.\r\n+ * When key is changed the updateKey(byte[]) method needs to be called in front.\r\n+ * Encrypt and Decrypt methods use the expandedKey field to do their job.\r\n+ *\r\n+ * The first packet sent to Paradox is the IP150 password as bytes, extended to 32 bytes with 0xEE.\r\n+ * The first response contains the key that will be used for the rest of communication.\r\n+ *\r\n+ * Most of the coding is copy from Python / rewrite in Java from second link of jpbaracca's PAI repository. Probably\r\n+ * some of the variables can be named better but I don't understand this code in it's full scope so I preferred to keep\r\n+ * it as it is.\r\n+ *\r\n+ * @author Konstantin Polihronov - Initial contribution\r\n+ *\r\n+ * @see <a href=https://www.samiam.org/key-schedule.html>Sam Trendholme's page about AES</a>\r\n+ * @see <a href=https://github.com/ParadoxAlarmInterface/pai>Github of jpbaracca's work - ParadoxAlarmInterface in\r\n+ *      python</a>\r\n+ */\r\n+@NonNullByDefault\r\n+public class EncryptionHandler {\r\n+\r\n+    private final Logger logger = LoggerFactory.getLogger(EncryptionHandler.class);\r\n+\r\n+    private static final int KEY_ARRAY_LENGTH = 32;\r\n+    private static final int TABLE_SIZE = 256;\r\n+    private static final int KEY_LENGTH = 240;\r\n+    private static final int PAYLOAD_RATE_LENGTH = 16;\r\n+    private static final int ROUNDS = 14;\r\n+\r\n+    private static int[] lTable = new int[TABLE_SIZE];\r\n+    private static int[] aTable = new int[TABLE_SIZE];\r\n+\r\n+    private static EncryptionHandler instance = new EncryptionHandler(new byte[] {});\r\n+    static {\r\n+        generateTables();\r\n+    }\r\n+\r\n+    private static void generateTables() {\r\n+        int a = 1;\r\n+        int d;\r\n+        for (int index = 0; index < 255; index++) {\r\n+            aTable[index] = a & 0xFF;\r\n+            /* Multiply by three */\r\n+            d = (a & 0x80) & 0xFF;\r\n+            a <<= 1;\r\n+            if (d == 0x80) {\r\n+                a ^= 0x1b;\r\n+                a &= 0xFF;\r\n+            }\r\n+            a ^= aTable[index];\r\n+            a &= 0xFF;\r\n+            /* Set the log table value */\r\n+            lTable[aTable[index]] = index & 0xFF;\r\n+        }\r\n+        aTable[255] = aTable[0];\r\n+        lTable[0] = 0;\r\n+    }\r\n+\r\n+    private int[] expandedKey = new int[KEY_LENGTH];\r", "originalCommit": "525342c2adcdab5afc19b4180beffa6ab2d99c15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MzUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432973503", "bodyText": "How hard would it be to add @NonNullByDefault to all of these Payload classes?", "author": "cpmeister", "createdAt": "2020-05-31T18:49:40Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/messages/CommandPayload.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.paradoxalarm.internal.communication.messages;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * The {@link CommandPayload} Class that structures the payload for partition commands.\n+ *\n+ * @author Konstantin Polihronov - Initial contribution\n+ */\n+public class CommandPayload implements IPayload {", "originalCommit": "525342c2adcdab5afc19b4180beffa6ab2d99c15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA2NzU3OA==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r433067578", "bodyText": "Done. Not hard at all. I've added it to the enums also. Does it make sense for them?", "author": "theater", "createdAt": "2020-06-01T06:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MzUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM2OTUyMw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r433369523", "bodyText": "For all new bindings @NonNullByDefault is required for all non-DTO classes. Existing bindings are only required to add @NonNullByDefault to new classes added to them, and even then, only if it doesn't cause an excessive amount of additional changes to a PR since we don't want to punish new contributors with trying to fix/refactor old to code to adhere to the new policy.", "author": "cpmeister", "createdAt": "2020-06-01T17:09:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3MzUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3Mzk3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432973972", "bodyText": "use it or lose it", "author": "cpmeister", "createdAt": "2020-05-31T18:55:39Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/CommunicationState.java", "diffHunk": "@@ -126,17 +142,17 @@ protected void runPhase(IParadoxInitialLoginCommunicator communicator, Object...\n             logger.debug(\"Phase {}\", this);\n             byte[] message4 = new byte[37];\n             message4[0] = 0x72;\n+            // message4[message4.length - 1] = 0x72;", "originalCommit": "525342c2adcdab5afc19b4180beffa6ab2d99c15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NDExNw==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r432974117", "bodyText": "I'd really prefer if ParadoxPanel wasn't a singleton. But you are also free to keep it singleton since it was has already been grandfathered in.", "author": "cpmeister", "createdAt": "2020-05-31T18:57:24Z", "path": "bundles/org.openhab.binding.paradoxalarm/src/main/java/org/openhab/binding/paradoxalarm/internal/communication/CommunicationState.java", "diffHunk": "@@ -351,8 +366,10 @@ protected CommunicationState nextState() {\n \n         @Override\n         protected void runPhase(IParadoxInitialLoginCommunicator communicator, Object... args) {\n-            communicator.close();\n-            communicator.setOnline(false);\n+            if (communicator != null) {\n+                communicator.close();\n+            }\n+            ParadoxPanel.getInstance().dispose();", "originalCommit": "525342c2adcdab5afc19b4180beffa6ab2d99c15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1ODMzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/6961#discussion_r433058331", "bodyText": "For now I will leave it singleton. I will put the request in consideration for the next feature update as it may require some refactoring...", "author": "theater", "createdAt": "2020-06-01T06:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk3NDExNw=="}], "type": "inlineReview"}, {"oid": "26abd91393572b83bf2a0f4d131305d9d980b1b2", "url": "https://github.com/openhab/openhab-addons/commit/26abd91393572b83bf2a0f4d131305d9d980b1b2", "message": "Changes based on cpmeister's review #5\n\n* Add NonNullByDefault to payload, constants and commands classes\n* Change voltage types in README\n* Add new line to pom.xml\n* Make lTable, aTable and expandedKey fields in EncryptionHandler final\n* mvn spotless:apply again to the code\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-06-01T06:40:24Z", "type": "commit"}, {"oid": "4b8094dc006eea73b52290c24cb57487553579c6", "url": "https://github.com/openhab/openhab-addons/commit/4b8094dc006eea73b52290c24cb57487553579c6", "message": "Update unit type in panel.xml with parametrized value\n\nSigned-off-by: Konstantin Polihronov <polychronov@gmail.com>", "committedDate": "2020-06-02T06:42:11Z", "type": "commit"}]}