{"pr_number": 7864, "pr_title": "[magentatv] Initial contribution (aka EntertainTV)", "pr_createdAt": "2020-06-05T19:10:13Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7864", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NTE1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439055151", "bodyText": "What is this supposed to be doing?", "author": "cpmeister", "createdAt": "2020-06-11T20:32:17Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVHandlerFactory.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.net.HttpServiceUtil;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.magentatv.internal.handler.MagentaTVHandler;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVPoweroffListener;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class, MagentaTVHandlerFactory.class }, configurationPid = \"binding.\"\n+        + BINDING_ID)\n+public class MagentaTVHandlerFactory extends BaseThingHandlerFactory {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandlerFactory.class);\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RECEIVER);\n+\n+    private final MagentaTVPoweroffListener upnpListener;\n+    private final MagentaTVNetwork network = new MagentaTVNetwork();\n+    private boolean servletInitialized = false;\n+\n+    protected class MagentaTVDevice {\n+        protected String udn = \"\";\n+        protected String mac = \"\";\n+        protected String deviceId = \"\";\n+        protected String ipAddress = \"\";\n+        protected Map<String, String> properties = new HashMap<>();\n+        protected @Nullable MagentaTVHandler thingHandler;\n+    }\n+\n+    private final Map<String, MagentaTVDevice> deviceList = new HashMap<String, MagentaTVDevice>();\n+\n+    /**\n+     * Activate the bundle: save properties\n+     *\n+     * @param componentContext\n+     * @param configProperties set of properties from cfg (use same names as in\n+     *            thing config)\n+     */\n+\n+    @Activate\n+    public MagentaTVHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            ComponentContext componentContext, Map<String, String> configProperties) throws IOException {\n+        super.activate(componentContext);\n+\n+        try {\n+            logger.debug(\"Initialize network access\");\n+            System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n+            String lip = networkAddressService.getPrimaryIpv4HostAddress();\n+            Integer port = HttpServiceUtil.getHttpServicePort(componentContext.getBundleContext());\n+            if (port == -1) {\n+                port = 8080;\n+            }\n+            network.initLocalNet(lip != null ? lip : \"\", port.toString());\n+        } catch (MagentaTVException e) {\n+            logger.warn(\"Initialization failed: {}\", e.toString());\n+        }\n+        upnpListener = new MagentaTVPoweroffListener(this, network.getLocalInterface());\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (!upnpListener.isStarted()) {\n+            upnpListener.start();\n+        }\n+\n+        logger.debug(\"Create thing type {}\", thing.getThingTypeUID().getAsString());\n+        if (THING_TYPE_RECEIVER.equals(thingTypeUID)) {\n+            return new MagentaTVHandler(this, thing, network);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Remove handler of things.\n+     */\n+    @Override\n+    protected synchronized void removeHandler(ThingHandler thingHandler) {\n+        if (thingHandler instanceof MagentaTVHandler) {\n+        }\n+    }", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyODA5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439228097", "bodyText": "left-over, removed", "author": "markus7017", "createdAt": "2020-06-12T06:20:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NTE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NjUwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439056501", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    .withProperties(properties).withRepresentationProperty(mac).build();\n          \n          \n            \n                                    .withProperties(properties).withRepresentationProperty(PROPERTY_MAC_ADDRESS).build();", "author": "cpmeister", "createdAt": "2020-06-11T20:35:08Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/discovery/MagentaTVDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.discovery;\n+\n+import static org.eclipse.smarthome.core.thing.Thing.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.upnp.UpnpDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.jupnp.model.meta.RemoteDevice;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVDiscoveryParticipant} is responsible for discovering new\n+ * and removed MagentaTV receivers. It uses the central UpnpDiscoveryService.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = UpnpDiscoveryParticipant.class, immediate = true)\n+public class MagentaTVDiscoveryParticipant implements UpnpDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(THING_TYPE_RECEIVER);\n+    }\n+\n+    /**\n+     * New discovered result.\n+     */\n+    @Override\n+    public @Nullable DiscoveryResult createResult(RemoteDevice device) {\n+        DiscoveryResult result = null;\n+        try {\n+            logger.trace(\"Device discovered: {} - {}\", device.getDetails().getManufacturerDetails().getManufacturer(),\n+                    device.getDetails().getModelDetails().getModelName());\n+\n+            ThingUID uid = getThingUID(device);\n+            if (uid != null) {\n+                logger.debug(\"Discovered an MagentaTV Media Receiver {}, UDN: {}, Model {}.{}\",\n+                        device.getDetails().getFriendlyName(), device.getIdentity().getUdn().getIdentifierString(),\n+                        device.getDetails().getModelDetails().getModelName(),\n+                        device.getDetails().getModelDetails().getModelNumber());\n+\n+                Map<String, Object> properties = new TreeMap<>();\n+                String descriptorURL = device.getIdentity().getDescriptorURL().toString();\n+                String port = StringUtils.substringBefore(StringUtils.substringAfterLast(descriptorURL, \":\"), \"/\");\n+                String hex = device.getIdentity().getUdn().getIdentifierString()\n+                        .substring(device.getIdentity().getUdn().getIdentifierString().length() - 12);\n+                String mac = hex.substring(0, 2) + \":\" + hex.substring(2, 4) + \":\" + hex.substring(4, 6) + \":\"\n+                        + hex.substring(6, 8) + \":\" + hex.substring(8, 10) + \":\" + hex.substring(10, 12);\n+                properties.put(PROPERTY_VENDOR,\n+                        VENDOR + \"(\" + device.getDetails().getManufacturerDetails().getManufacturer() + \")\");\n+                properties.put(PROPERTY_MODEL_ID, device.getDetails().getModelDetails().getModelName().toUpperCase());\n+                properties.put(PROPERTY_HARDWARE_VERSION, device.getDetails().getModelDetails().getModelNumber());\n+                properties.put(PROPERTY_MAC_ADDRESS, mac);\n+                properties.put(PROPERTY_UDN, device.getIdentity().getUdn().getIdentifierString().toUpperCase());\n+                properties.put(PROPERTY_IP, StringUtils.substringBetween(descriptorURL, \"http://\", \":\"));\n+                properties.put(PROPERTY_PORT, port);\n+                properties.put(PROPERTY_DESC_URL, StringUtils.substringAfterLast(descriptorURL, \":\" + port));\n+\n+                logger.debug(\"Create Thing for device {} with UDN {}, Model{}\", device.getDetails().getFriendlyName(),\n+                        device.getIdentity().getUdn().getIdentifierString(),\n+                        device.getDetails().getModelDetails().getModelName());\n+                result = DiscoveryResultBuilder.create(uid).withLabel(device.getDetails().getFriendlyName())\n+                        .withProperties(properties).withRepresentationProperty(mac).build();", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyODMwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439228304", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-06-12T06:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NjUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NzMyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439057325", "bodyText": "Please cache device.getDetails().getManufacturerDetails().getManufacturer() in a local variable.", "author": "cpmeister", "createdAt": "2020-06-11T20:36:57Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/discovery/MagentaTVDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.discovery;\n+\n+import static org.eclipse.smarthome.core.thing.Thing.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.upnp.UpnpDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.jupnp.model.meta.RemoteDevice;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVDiscoveryParticipant} is responsible for discovering new\n+ * and removed MagentaTV receivers. It uses the central UpnpDiscoveryService.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = UpnpDiscoveryParticipant.class, immediate = true)\n+public class MagentaTVDiscoveryParticipant implements UpnpDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(THING_TYPE_RECEIVER);\n+    }\n+\n+    /**\n+     * New discovered result.\n+     */\n+    @Override\n+    public @Nullable DiscoveryResult createResult(RemoteDevice device) {\n+        DiscoveryResult result = null;\n+        try {\n+            logger.trace(\"Device discovered: {} - {}\", device.getDetails().getManufacturerDetails().getManufacturer(),\n+                    device.getDetails().getModelDetails().getModelName());\n+\n+            ThingUID uid = getThingUID(device);\n+            if (uid != null) {\n+                logger.debug(\"Discovered an MagentaTV Media Receiver {}, UDN: {}, Model {}.{}\",\n+                        device.getDetails().getFriendlyName(), device.getIdentity().getUdn().getIdentifierString(),\n+                        device.getDetails().getModelDetails().getModelName(),\n+                        device.getDetails().getModelDetails().getModelNumber());\n+\n+                Map<String, Object> properties = new TreeMap<>();\n+                String descriptorURL = device.getIdentity().getDescriptorURL().toString();\n+                String port = StringUtils.substringBefore(StringUtils.substringAfterLast(descriptorURL, \":\"), \"/\");\n+                String hex = device.getIdentity().getUdn().getIdentifierString()\n+                        .substring(device.getIdentity().getUdn().getIdentifierString().length() - 12);\n+                String mac = hex.substring(0, 2) + \":\" + hex.substring(2, 4) + \":\" + hex.substring(4, 6) + \":\"\n+                        + hex.substring(6, 8) + \":\" + hex.substring(8, 10) + \":\" + hex.substring(10, 12);\n+                properties.put(PROPERTY_VENDOR,\n+                        VENDOR + \"(\" + device.getDetails().getManufacturerDetails().getManufacturer() + \")\");\n+                properties.put(PROPERTY_MODEL_ID, device.getDetails().getModelDetails().getModelName().toUpperCase());\n+                properties.put(PROPERTY_HARDWARE_VERSION, device.getDetails().getModelDetails().getModelNumber());\n+                properties.put(PROPERTY_MAC_ADDRESS, mac);\n+                properties.put(PROPERTY_UDN, device.getIdentity().getUdn().getIdentifierString().toUpperCase());\n+                properties.put(PROPERTY_IP, StringUtils.substringBetween(descriptorURL, \"http://\", \":\"));\n+                properties.put(PROPERTY_PORT, port);\n+                properties.put(PROPERTY_DESC_URL, StringUtils.substringAfterLast(descriptorURL, \":\" + port));\n+\n+                logger.debug(\"Create Thing for device {} with UDN {}, Model{}\", device.getDetails().getFriendlyName(),\n+                        device.getIdentity().getUdn().getIdentifierString(),\n+                        device.getDetails().getModelDetails().getModelName());\n+                result = DiscoveryResultBuilder.create(uid).withLabel(device.getDetails().getFriendlyName())\n+                        .withProperties(properties).withRepresentationProperty(mac).build();\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Unable to create thing for device {}/{} - {}\", device.getDetails().getFriendlyName(),\n+                    device.getIdentity().getUdn().getIdentifierString(), e.getMessage());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the UID for a device\n+     */\n+    @Override\n+    public @Nullable ThingUID getThingUID(@Nullable RemoteDevice device) {\n+        if (device != null) {\n+            if (device.getDetails().getManufacturerDetails().getManufacturer() != null) {", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNDEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439234103", "bodyText": "refactored", "author": "markus7017", "createdAt": "2020-06-12T06:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NzUzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439057536", "bodyText": "please cache device.getDetails().getModelDetails().getModelName() in a local variable", "author": "cpmeister", "createdAt": "2020-06-11T20:37:22Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/discovery/MagentaTVDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.discovery;\n+\n+import static org.eclipse.smarthome.core.thing.Thing.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.upnp.UpnpDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.jupnp.model.meta.RemoteDevice;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVDiscoveryParticipant} is responsible for discovering new\n+ * and removed MagentaTV receivers. It uses the central UpnpDiscoveryService.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = UpnpDiscoveryParticipant.class, immediate = true)\n+public class MagentaTVDiscoveryParticipant implements UpnpDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(THING_TYPE_RECEIVER);\n+    }\n+\n+    /**\n+     * New discovered result.\n+     */\n+    @Override\n+    public @Nullable DiscoveryResult createResult(RemoteDevice device) {\n+        DiscoveryResult result = null;\n+        try {\n+            logger.trace(\"Device discovered: {} - {}\", device.getDetails().getManufacturerDetails().getManufacturer(),\n+                    device.getDetails().getModelDetails().getModelName());\n+\n+            ThingUID uid = getThingUID(device);\n+            if (uid != null) {\n+                logger.debug(\"Discovered an MagentaTV Media Receiver {}, UDN: {}, Model {}.{}\",\n+                        device.getDetails().getFriendlyName(), device.getIdentity().getUdn().getIdentifierString(),\n+                        device.getDetails().getModelDetails().getModelName(),\n+                        device.getDetails().getModelDetails().getModelNumber());\n+\n+                Map<String, Object> properties = new TreeMap<>();\n+                String descriptorURL = device.getIdentity().getDescriptorURL().toString();\n+                String port = StringUtils.substringBefore(StringUtils.substringAfterLast(descriptorURL, \":\"), \"/\");\n+                String hex = device.getIdentity().getUdn().getIdentifierString()\n+                        .substring(device.getIdentity().getUdn().getIdentifierString().length() - 12);\n+                String mac = hex.substring(0, 2) + \":\" + hex.substring(2, 4) + \":\" + hex.substring(4, 6) + \":\"\n+                        + hex.substring(6, 8) + \":\" + hex.substring(8, 10) + \":\" + hex.substring(10, 12);\n+                properties.put(PROPERTY_VENDOR,\n+                        VENDOR + \"(\" + device.getDetails().getManufacturerDetails().getManufacturer() + \")\");\n+                properties.put(PROPERTY_MODEL_ID, device.getDetails().getModelDetails().getModelName().toUpperCase());\n+                properties.put(PROPERTY_HARDWARE_VERSION, device.getDetails().getModelDetails().getModelNumber());\n+                properties.put(PROPERTY_MAC_ADDRESS, mac);\n+                properties.put(PROPERTY_UDN, device.getIdentity().getUdn().getIdentifierString().toUpperCase());\n+                properties.put(PROPERTY_IP, StringUtils.substringBetween(descriptorURL, \"http://\", \":\"));\n+                properties.put(PROPERTY_PORT, port);\n+                properties.put(PROPERTY_DESC_URL, StringUtils.substringAfterLast(descriptorURL, \":\" + port));\n+\n+                logger.debug(\"Create Thing for device {} with UDN {}, Model{}\", device.getDetails().getFriendlyName(),\n+                        device.getIdentity().getUdn().getIdentifierString(),\n+                        device.getDetails().getModelDetails().getModelName());\n+                result = DiscoveryResultBuilder.create(uid).withLabel(device.getDetails().getFriendlyName())\n+                        .withProperties(properties).withRepresentationProperty(mac).build();\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Unable to create thing for device {}/{} - {}\", device.getDetails().getFriendlyName(),\n+                    device.getIdentity().getUdn().getIdentifierString(), e.getMessage());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the UID for a device\n+     */\n+    @Override\n+    public @Nullable ThingUID getThingUID(@Nullable RemoteDevice device) {\n+        if (device != null) {\n+            if (device.getDetails().getManufacturerDetails().getManufacturer() != null) {\n+                String manufacturer = device.getDetails().getManufacturerDetails().getManufacturer().toUpperCase();\n+                if (manufacturer.contains(OEM_VENDOR)) {\n+                    if (device.getDetails().getModelDetails().getModelName() != null) {", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyODcyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439228724", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-12T06:22:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NzUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1OTQ2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439059462", "bodyText": "You should list all of your configuration properties as fields in this class instead of storing them in a map. BaseHandler subclasses can call getConfigAs(MagentaTVConfiguration.class) to retrieve an instance of this configuration class that has all your config fields populated for you automatically.", "author": "cpmeister", "createdAt": "2020-06-11T20:41:22Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVConfiguration.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.eclipse.smarthome.core.thing.Thing.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link MagentaTVConfiguration} contains the thing config (updated at\n+ * runtime).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVConfiguration {\n+    private Map<String, String> properties = new TreeMap<>();", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NDQ4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r441074486", "bodyText": "completely refactored", "author": "markus7017", "createdAt": "2020-06-16T18:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1OTQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1OTg0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439059843", "bodyText": "fix typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void deviceDiscoverd(Map<String, String> discoveryProperties) {\n          \n          \n            \n                public void deviceDiscovered(Map<String, String> discoveryProperties) {", "author": "cpmeister", "createdAt": "2020-06-11T20:42:12Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVHandlerFactory.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.net.HttpServiceUtil;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.magentatv.internal.handler.MagentaTVHandler;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVPoweroffListener;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class, MagentaTVHandlerFactory.class }, configurationPid = \"binding.\"\n+        + BINDING_ID)\n+public class MagentaTVHandlerFactory extends BaseThingHandlerFactory {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandlerFactory.class);\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RECEIVER);\n+\n+    private final MagentaTVPoweroffListener upnpListener;\n+    private final MagentaTVNetwork network = new MagentaTVNetwork();\n+    private boolean servletInitialized = false;\n+\n+    protected class MagentaTVDevice {\n+        protected String udn = \"\";\n+        protected String mac = \"\";\n+        protected String deviceId = \"\";\n+        protected String ipAddress = \"\";\n+        protected Map<String, String> properties = new HashMap<>();\n+        protected @Nullable MagentaTVHandler thingHandler;\n+    }\n+\n+    private final Map<String, MagentaTVDevice> deviceList = new HashMap<String, MagentaTVDevice>();\n+\n+    /**\n+     * Activate the bundle: save properties\n+     *\n+     * @param componentContext\n+     * @param configProperties set of properties from cfg (use same names as in\n+     *            thing config)\n+     */\n+\n+    @Activate\n+    public MagentaTVHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            ComponentContext componentContext, Map<String, String> configProperties) throws IOException {\n+        super.activate(componentContext);\n+\n+        try {\n+            logger.debug(\"Initialize network access\");\n+            System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n+            String lip = networkAddressService.getPrimaryIpv4HostAddress();\n+            Integer port = HttpServiceUtil.getHttpServicePort(componentContext.getBundleContext());\n+            if (port == -1) {\n+                port = 8080;\n+            }\n+            network.initLocalNet(lip != null ? lip : \"\", port.toString());\n+        } catch (MagentaTVException e) {\n+            logger.warn(\"Initialization failed: {}\", e.toString());\n+        }\n+        upnpListener = new MagentaTVPoweroffListener(this, network.getLocalInterface());\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (!upnpListener.isStarted()) {\n+            upnpListener.start();\n+        }\n+\n+        logger.debug(\"Create thing type {}\", thing.getThingTypeUID().getAsString());\n+        if (THING_TYPE_RECEIVER.equals(thingTypeUID)) {\n+            return new MagentaTVHandler(this, thing, network);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Remove handler of things.\n+     */\n+    @Override\n+    protected synchronized void removeHandler(ThingHandler thingHandler) {\n+        if (thingHandler instanceof MagentaTVHandler) {\n+        }\n+    }\n+\n+    /**\n+     * A device was discovered by UPnP. A new device gets inserted into the\n+     * deviceList table, otherwise the properties will be updated.\n+     *\n+     * @param discoveryProperties Properties discoverd by UPnP\n+     */\n+    public void deviceDiscoverd(Map<String, String> discoveryProperties) {", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNDQ2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439234460", "bodyText": "he-he, function was not used anyways", "author": "markus7017", "createdAt": "2020-06-12T06:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1OTg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NDU2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439064566", "bodyText": "Always pass along the cause exception if you throw another exception.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"Invalid hex digit in MAC address.\");\n          \n          \n            \n                        throw new IllegalArgumentException(\"Invalid hex digit in MAC address.\", e);", "author": "cpmeister", "createdAt": "2020-06-11T20:52:30Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/network/MagentaTVNetwork.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.network;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVNetwork} supplies network functions.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVNetwork {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVNetwork.class);\n+\n+    private String localIP = \"\";\n+    private String localPort = \"\";\n+    private String localMAC = \"\";\n+    private @Nullable NetworkInterface localInterface;\n+\n+    /**\n+     * Init local network interface, determine local IP and MAC address\n+     *\n+     * @param networkAddressService\n+     * @return\n+     */\n+    public void initLocalNet(String localIP, String localPort) throws MagentaTVException {\n+        try {\n+            if (localIP.isEmpty() || localIP.equals(\"0.0.0.0\") || localIP.equals(\"127.0.0.1\")) {\n+                throw new MagentaTVException(\"Unable to detect local IP address!\");\n+            }\n+            this.localPort = localPort;\n+            this.localIP = localIP;\n+\n+            // get MAC address\n+            InetAddress ip = InetAddress.getByName(localIP);\n+            localInterface = NetworkInterface.getByInetAddress(ip);\n+            if (localInterface != null) {\n+                byte[] mac = localInterface.getHardwareAddress();\n+                StringBuilder sb = new StringBuilder();\n+                for (int i = 0; i < mac.length; i++) {\n+                    sb.append(String.format(\"%02X%s\", mac[i], (i < mac.length - 1) ? \":\" : \"\"));\n+                }\n+                localMAC = sb.toString().toUpperCase();\n+                logger.debug(\"Local IP address={}, Local MAC address = {}\", localIP, localMAC);\n+                return;\n+            }\n+        } catch (UnknownHostException | SocketException e) {\n+            throw new MagentaTVException(e);\n+        }\n+\n+        throw new MagentaTVException(\n+                \"Unable to get local IP / MAC address, check network settings in openHAB system configuration!\");\n+    }\n+\n+    /**\n+     * Checks if client ip equals or is in range of ip networks provided by\n+     * semicolon separated list\n+     *\n+     * @param clientIp in numeric form like \"192.168.0.10\"\n+     * @param ipList like \"127.0.0.1;192.168.0.0/24;10.0.0.0/8\"\n+     * @return true if client ip from the list os ips and networks\n+     */\n+    public static boolean isIpInSubnet(String clientIp, String ipList) {\n+        if (ipList.isEmpty()) {\n+            // No ip address provided\n+            return true;\n+        }\n+        String[] subnetMasks = ipList.split(\";\");\n+        for (String subnetMask : subnetMasks) {\n+            subnetMask = subnetMask.trim();\n+            if (clientIp.equals(subnetMask)) {\n+                return true;\n+            }\n+            if (subnetMask.contains(\"/\")) {\n+                if (new SubnetUtils(subnetMask).getInfo().isInRange(clientIp)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Nullable\n+    public NetworkInterface getLocalInterface() {\n+        return localInterface;\n+    }\n+\n+    public String getLocalIP() {\n+        return localIP;\n+    }\n+\n+    public String getLocalPort() {\n+        return localPort;\n+    }\n+\n+    public String getLocalMAC() {\n+        return localMAC;\n+    }\n+\n+    public static final int WOL_PORT = 9;\n+\n+    /**\n+     * Send a Waker-on-LAN packet\n+     *\n+     * @param ipAddr destination ip\n+     * @param macAddress destination MAC address\n+     * @throws MagentaTVException\n+     */\n+    public void sendWakeOnLAN(String ipAddr, String macAddress) throws MagentaTVException {\n+        try {\n+            byte[] macBytes = getMacBytes(macAddress);\n+            byte[] bytes = new byte[6 + 16 * macBytes.length];\n+            for (int i = 0; i < 6; i++) {\n+                bytes[i] = (byte) 0xff;\n+            }\n+            for (int i = 6; i < bytes.length; i += macBytes.length) {\n+                System.arraycopy(macBytes, 0, bytes, i, macBytes.length);\n+            }\n+\n+            InetAddress address = InetAddress.getByName(ipAddr);\n+            DatagramPacket packet = new DatagramPacket(bytes, bytes.length, address, WOL_PORT);\n+            DatagramSocket socket = new DatagramSocket();\n+            socket.send(packet);\n+            socket.close();\n+\n+            logger.debug(\"Wake-on-LAN packet sent to {} / {}\", ipAddr, macAddress);\n+        } catch (IOException e) {\n+            throw new MagentaTVException(e, \"Unable to send Wake-on-LAN packet to {} / {}\", ipAddr, macAddress);\n+        }\n+\n+    }\n+\n+    /**\n+     * Convert MAC address from string to byte array\n+     *\n+     * @param macStr MAC address as string\n+     * @return MAC address as byte array\n+     * @throws IllegalArgumentException\n+     */\n+    private static byte[] getMacBytes(String macStr) throws IllegalArgumentException {\n+        byte[] bytes = new byte[6];\n+        String[] hex = macStr.split(\"(\\\\:|\\\\-)\");\n+        if (hex.length != 6) {\n+            throw new IllegalArgumentException(\"Invalid MAC address.\");\n+        }\n+        try {\n+            for (int i = 0; i < 6; i++) {\n+                bytes[i] = (byte) Integer.parseInt(hex[i], 16);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"Invalid hex digit in MAC address.\");", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNjAxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439236010", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-12T06:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NDU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439065417", "bodyText": "use it or lose it.", "author": "cpmeister", "createdAt": "2020-06-11T20:54:29Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/network/MagentaTVHttp.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.network;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.text.MessageFormat;\n+import java.util.Properties;\n+\n+import javax.ws.rs.HttpMethod;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHttp} supplies network functions.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHttp {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHttp.class);\n+\n+    public String httpGet(String host, String urlBase, String urlParameters) throws MagentaTVException {\n+        String url = \"\";\n+        String response = \"\";\n+        try {\n+            url = !urlParameters.isEmpty() ? urlBase + \"?\" + urlParameters : urlBase;\n+            Properties httpHeader = new Properties();\n+            httpHeader.setProperty(HEADER_USER_AGENT, USER_AGENT);\n+            httpHeader.setProperty(HEADER_HOST, host);\n+            httpHeader.setProperty(HEADER_ACCEPT, \"*/*\");\n+            response = HttpUtil.executeUrl(HttpMethod.GET, url, httpHeader, null, null, NETWORK_TIMEOUT_MS);\n+            logger.trace(\"GET {}\u00a0- Response={}\", url, response);\n+            return response;\n+        } catch (IOException e) {\n+            throw new MagentaTVException(e, \"HTTP GET {0} failed: {1}\", url, response);\n+        }\n+    }\n+\n+    /**\n+     * Given a URL and a set parameters, send a HTTP POST request to the URL\n+     * location created by the URL and parameters.\n+     *\n+     * @param url The URL to send a POST request to.\n+     * @param urlParameters List of parameters to use in the URL for the POST\n+     *            request. Null if no parameters.\n+     * @param soapAction Header attribute for SOAP ACTION: xxx\n+     * @param connection Header attribut for CONNECTION: xxx\n+     * @return String contents of the response for the POST request.\n+     * @throws MagentaTVException\n+     */\n+    public String httpPOST(String host, String url, String postData, String soapAction, String connection)\n+            throws MagentaTVException {\n+        String httpResponse = \"\";\n+        try {\n+            Properties httpHeader = new Properties();\n+            httpHeader.setProperty(HEADER_CONTENT_TYPE, CONTENT_TYPE_XML);\n+            httpHeader.setProperty(HEADER_ACCEPT, \"\");\n+            httpHeader.setProperty(HEADER_USER_AGENT, USER_AGENT);\n+            httpHeader.setProperty(HEADER_HOST, host);\n+            if (!soapAction.isEmpty()) {\n+                httpHeader.setProperty(HEADER_SOAPACTION, soapAction);\n+            }\n+            if (!connection.isEmpty()) {\n+                httpHeader.setProperty(HEADER_CONNECTION, connection);\n+            }\n+\n+            logger.trace(\"POST {}\u00a0- SoapAction={}, Data = {}\", url, postData, soapAction);\n+            InputStream dataStream = new ByteArrayInputStream(\n+                    postData.getBytes(Charset.forName(StandardCharsets.UTF_8.name())));\n+            httpResponse = HttpUtil.executeUrl(HttpMethod.POST, url, httpHeader, dataStream, null, NETWORK_TIMEOUT_MS);\n+            logger.trace(\"POST {}\u00a0- Response = {}\", url, httpResponse);\n+            return httpResponse;\n+        } catch (IOException e) {\n+            throw new MagentaTVException(e, \"HTTP POST {0} failed, response={1}\", url, httpResponse);\n+        }\n+    }\n+\n+    /**\n+     * Send raw TCP data (SUBSCRIBE command)\n+     *\n+     * @param remoteIp receiver's IP\n+     * @param remotePort destination port\n+     * @param data data to send\n+     * @return received response\n+     * @throws IOException\n+     */\n+    public String sendData(String remoteIp, String remotePort, String data) throws MagentaTVException {\n+        String response = \"\";\n+        String errorMessage = \"\";\n+\n+        try (Socket socket = new Socket()) {\n+            // logger.trace(\"Sending data to {}:{}: {}\", remoteIp, remotePort, data);\n+            ;", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNjg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439236848", "bodyText": "loosed :-)", "author": "markus7017", "createdAt": "2020-06-12T06:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTYwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439065609", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                postData.getBytes(Charset.forName(StandardCharsets.UTF_8.name())));\n          \n          \n            \n                                postData.getBytes(StandardCharsets.UTF_8));", "author": "cpmeister", "createdAt": "2020-06-11T20:54:57Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/network/MagentaTVHttp.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.network;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.text.MessageFormat;\n+import java.util.Properties;\n+\n+import javax.ws.rs.HttpMethod;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHttp} supplies network functions.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHttp {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHttp.class);\n+\n+    public String httpGet(String host, String urlBase, String urlParameters) throws MagentaTVException {\n+        String url = \"\";\n+        String response = \"\";\n+        try {\n+            url = !urlParameters.isEmpty() ? urlBase + \"?\" + urlParameters : urlBase;\n+            Properties httpHeader = new Properties();\n+            httpHeader.setProperty(HEADER_USER_AGENT, USER_AGENT);\n+            httpHeader.setProperty(HEADER_HOST, host);\n+            httpHeader.setProperty(HEADER_ACCEPT, \"*/*\");\n+            response = HttpUtil.executeUrl(HttpMethod.GET, url, httpHeader, null, null, NETWORK_TIMEOUT_MS);\n+            logger.trace(\"GET {}\u00a0- Response={}\", url, response);\n+            return response;\n+        } catch (IOException e) {\n+            throw new MagentaTVException(e, \"HTTP GET {0} failed: {1}\", url, response);\n+        }\n+    }\n+\n+    /**\n+     * Given a URL and a set parameters, send a HTTP POST request to the URL\n+     * location created by the URL and parameters.\n+     *\n+     * @param url The URL to send a POST request to.\n+     * @param urlParameters List of parameters to use in the URL for the POST\n+     *            request. Null if no parameters.\n+     * @param soapAction Header attribute for SOAP ACTION: xxx\n+     * @param connection Header attribut for CONNECTION: xxx\n+     * @return String contents of the response for the POST request.\n+     * @throws MagentaTVException\n+     */\n+    public String httpPOST(String host, String url, String postData, String soapAction, String connection)\n+            throws MagentaTVException {\n+        String httpResponse = \"\";\n+        try {\n+            Properties httpHeader = new Properties();\n+            httpHeader.setProperty(HEADER_CONTENT_TYPE, CONTENT_TYPE_XML);\n+            httpHeader.setProperty(HEADER_ACCEPT, \"\");\n+            httpHeader.setProperty(HEADER_USER_AGENT, USER_AGENT);\n+            httpHeader.setProperty(HEADER_HOST, host);\n+            if (!soapAction.isEmpty()) {\n+                httpHeader.setProperty(HEADER_SOAPACTION, soapAction);\n+            }\n+            if (!connection.isEmpty()) {\n+                httpHeader.setProperty(HEADER_CONNECTION, connection);\n+            }\n+\n+            logger.trace(\"POST {}\u00a0- SoapAction={}, Data = {}\", url, postData, soapAction);\n+            InputStream dataStream = new ByteArrayInputStream(\n+                    postData.getBytes(Charset.forName(StandardCharsets.UTF_8.name())));", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyOTg5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439229895", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-06-12T06:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2ODM5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439068393", "bodyText": "Please use a StringBuilder here instead", "author": "cpmeister", "createdAt": "2020-06-11T21:00:49Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/network/MagentaTVHttp.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.network;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.text.MessageFormat;\n+import java.util.Properties;\n+\n+import javax.ws.rs.HttpMethod;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHttp} supplies network functions.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHttp {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHttp.class);\n+\n+    public String httpGet(String host, String urlBase, String urlParameters) throws MagentaTVException {\n+        String url = \"\";\n+        String response = \"\";\n+        try {\n+            url = !urlParameters.isEmpty() ? urlBase + \"?\" + urlParameters : urlBase;\n+            Properties httpHeader = new Properties();\n+            httpHeader.setProperty(HEADER_USER_AGENT, USER_AGENT);\n+            httpHeader.setProperty(HEADER_HOST, host);\n+            httpHeader.setProperty(HEADER_ACCEPT, \"*/*\");\n+            response = HttpUtil.executeUrl(HttpMethod.GET, url, httpHeader, null, null, NETWORK_TIMEOUT_MS);\n+            logger.trace(\"GET {}\u00a0- Response={}\", url, response);\n+            return response;\n+        } catch (IOException e) {\n+            throw new MagentaTVException(e, \"HTTP GET {0} failed: {1}\", url, response);\n+        }\n+    }\n+\n+    /**\n+     * Given a URL and a set parameters, send a HTTP POST request to the URL\n+     * location created by the URL and parameters.\n+     *\n+     * @param url The URL to send a POST request to.\n+     * @param urlParameters List of parameters to use in the URL for the POST\n+     *            request. Null if no parameters.\n+     * @param soapAction Header attribute for SOAP ACTION: xxx\n+     * @param connection Header attribut for CONNECTION: xxx\n+     * @return String contents of the response for the POST request.\n+     * @throws MagentaTVException\n+     */\n+    public String httpPOST(String host, String url, String postData, String soapAction, String connection)\n+            throws MagentaTVException {\n+        String httpResponse = \"\";\n+        try {\n+            Properties httpHeader = new Properties();\n+            httpHeader.setProperty(HEADER_CONTENT_TYPE, CONTENT_TYPE_XML);\n+            httpHeader.setProperty(HEADER_ACCEPT, \"\");\n+            httpHeader.setProperty(HEADER_USER_AGENT, USER_AGENT);\n+            httpHeader.setProperty(HEADER_HOST, host);\n+            if (!soapAction.isEmpty()) {\n+                httpHeader.setProperty(HEADER_SOAPACTION, soapAction);\n+            }\n+            if (!connection.isEmpty()) {\n+                httpHeader.setProperty(HEADER_CONNECTION, connection);\n+            }\n+\n+            logger.trace(\"POST {}\u00a0- SoapAction={}, Data = {}\", url, postData, soapAction);\n+            InputStream dataStream = new ByteArrayInputStream(\n+                    postData.getBytes(Charset.forName(StandardCharsets.UTF_8.name())));\n+            httpResponse = HttpUtil.executeUrl(HttpMethod.POST, url, httpHeader, dataStream, null, NETWORK_TIMEOUT_MS);\n+            logger.trace(\"POST {}\u00a0- Response = {}\", url, httpResponse);\n+            return httpResponse;\n+        } catch (IOException e) {\n+            throw new MagentaTVException(e, \"HTTP POST {0} failed, response={1}\", url, httpResponse);\n+        }\n+    }\n+\n+    /**\n+     * Send raw TCP data (SUBSCRIBE command)\n+     *\n+     * @param remoteIp receiver's IP\n+     * @param remotePort destination port\n+     * @param data data to send\n+     * @return received response\n+     * @throws IOException\n+     */\n+    public String sendData(String remoteIp, String remotePort, String data) throws MagentaTVException {\n+        String response = \"\";\n+        String errorMessage = \"\";\n+\n+        try (Socket socket = new Socket()) {\n+            // logger.trace(\"Sending data to {}:{}: {}\", remoteIp, remotePort, data);\n+            ;\n+            socket.setSoTimeout(NETWORK_TIMEOUT_MS); // set read timeout\n+            socket.connect(new InetSocketAddress(remoteIp, Integer.parseInt(remotePort)), NETWORK_TIMEOUT_MS);\n+\n+            OutputStream out = socket.getOutputStream();\n+            PrintStream ps = new PrintStream(out, true);\n+            ps.println(data);\n+\n+            InputStream in = socket.getInputStream();\n+            BufferedReader buff = new BufferedReader(new InputStreamReader(in));\n+\n+            // wait until somthing to read is available or socket I/O fails (IOException)\n+            String line = \"\";", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NDc3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r441074774", "bodyText": "could you give some guidance", "author": "markus7017", "createdAt": "2020-06-16T18:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2ODM5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE4MTc0NA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r475181744", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-08-23T07:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2ODM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2ODUyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439068529", "bodyText": "You should also specify the charset for your InputStreamReader", "author": "cpmeister", "createdAt": "2020-06-11T21:01:06Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/network/MagentaTVHttp.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.network;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.UnknownHostException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.text.MessageFormat;\n+import java.util.Properties;\n+\n+import javax.ws.rs.HttpMethod;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHttp} supplies network functions.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHttp {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHttp.class);\n+\n+    public String httpGet(String host, String urlBase, String urlParameters) throws MagentaTVException {\n+        String url = \"\";\n+        String response = \"\";\n+        try {\n+            url = !urlParameters.isEmpty() ? urlBase + \"?\" + urlParameters : urlBase;\n+            Properties httpHeader = new Properties();\n+            httpHeader.setProperty(HEADER_USER_AGENT, USER_AGENT);\n+            httpHeader.setProperty(HEADER_HOST, host);\n+            httpHeader.setProperty(HEADER_ACCEPT, \"*/*\");\n+            response = HttpUtil.executeUrl(HttpMethod.GET, url, httpHeader, null, null, NETWORK_TIMEOUT_MS);\n+            logger.trace(\"GET {}\u00a0- Response={}\", url, response);\n+            return response;\n+        } catch (IOException e) {\n+            throw new MagentaTVException(e, \"HTTP GET {0} failed: {1}\", url, response);\n+        }\n+    }\n+\n+    /**\n+     * Given a URL and a set parameters, send a HTTP POST request to the URL\n+     * location created by the URL and parameters.\n+     *\n+     * @param url The URL to send a POST request to.\n+     * @param urlParameters List of parameters to use in the URL for the POST\n+     *            request. Null if no parameters.\n+     * @param soapAction Header attribute for SOAP ACTION: xxx\n+     * @param connection Header attribut for CONNECTION: xxx\n+     * @return String contents of the response for the POST request.\n+     * @throws MagentaTVException\n+     */\n+    public String httpPOST(String host, String url, String postData, String soapAction, String connection)\n+            throws MagentaTVException {\n+        String httpResponse = \"\";\n+        try {\n+            Properties httpHeader = new Properties();\n+            httpHeader.setProperty(HEADER_CONTENT_TYPE, CONTENT_TYPE_XML);\n+            httpHeader.setProperty(HEADER_ACCEPT, \"\");\n+            httpHeader.setProperty(HEADER_USER_AGENT, USER_AGENT);\n+            httpHeader.setProperty(HEADER_HOST, host);\n+            if (!soapAction.isEmpty()) {\n+                httpHeader.setProperty(HEADER_SOAPACTION, soapAction);\n+            }\n+            if (!connection.isEmpty()) {\n+                httpHeader.setProperty(HEADER_CONNECTION, connection);\n+            }\n+\n+            logger.trace(\"POST {}\u00a0- SoapAction={}, Data = {}\", url, postData, soapAction);\n+            InputStream dataStream = new ByteArrayInputStream(\n+                    postData.getBytes(Charset.forName(StandardCharsets.UTF_8.name())));\n+            httpResponse = HttpUtil.executeUrl(HttpMethod.POST, url, httpHeader, dataStream, null, NETWORK_TIMEOUT_MS);\n+            logger.trace(\"POST {}\u00a0- Response = {}\", url, httpResponse);\n+            return httpResponse;\n+        } catch (IOException e) {\n+            throw new MagentaTVException(e, \"HTTP POST {0} failed, response={1}\", url, httpResponse);\n+        }\n+    }\n+\n+    /**\n+     * Send raw TCP data (SUBSCRIBE command)\n+     *\n+     * @param remoteIp receiver's IP\n+     * @param remotePort destination port\n+     * @param data data to send\n+     * @return received response\n+     * @throws IOException\n+     */\n+    public String sendData(String remoteIp, String remotePort, String data) throws MagentaTVException {\n+        String response = \"\";\n+        String errorMessage = \"\";\n+\n+        try (Socket socket = new Socket()) {\n+            // logger.trace(\"Sending data to {}:{}: {}\", remoteIp, remotePort, data);\n+            ;\n+            socket.setSoTimeout(NETWORK_TIMEOUT_MS); // set read timeout\n+            socket.connect(new InetSocketAddress(remoteIp, Integer.parseInt(remotePort)), NETWORK_TIMEOUT_MS);\n+\n+            OutputStream out = socket.getOutputStream();\n+            PrintStream ps = new PrintStream(out, true);\n+            ps.println(data);\n+\n+            InputStream in = socket.getInputStream();\n+            BufferedReader buff = new BufferedReader(new InputStreamReader(in));", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMDMyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439230326", "bodyText": "done", "author": "markus7017", "createdAt": "2020-06-12T06:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2ODUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2OTgxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439069818", "bodyText": "would this ever get called?", "author": "cpmeister", "createdAt": "2020-06-11T21:03:59Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,700 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVConfiguration;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final String EMPTY_CRED = \"***\";\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected final MagentaTVConfiguration thingConfig = new MagentaTVConfiguration();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : \"\";\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        thingConfig.fromProperties(getThing().getProperties());\n+        thingConfig.initializeConfig(getConfig().getProperties());\n+        thingId = thingConfig.getFriendlyName();\n+\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (thingConfig.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                thingConfig.setUDN(StringUtils.substringAfterLast(uid, \":\"));\n+            }\n+            if (thingConfig.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = StringUtils.substringAfterLast(thingConfig.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = StringUtils.substringAfterLast(thingConfig.getUDN(), \"-\");\n+                }\n+                thingConfig.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(thingConfig, network);\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = thingConfig.getAccountName();\n+            if (thingConfig.getUserID().isEmpty()\n+                    && (thingConfig.getAccountName().isEmpty() || account.equals(EMPTY_CRED))) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Missing credentials for login!\");\n+                return;\n+            }\n+\n+            logger.info(\"{}: Authenticate account {}\", thingId, account);\n+            thingConfig.updateConfig(control.getConfig().getProperties()); // get network parameters from control\n+            authenticateUser();\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if (!newAccount.equals(EMPTY_CRED)) {\n+                // new account info, need to renew userId\n+                thingConfig.setUserID(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+\n+        // initializeThing();\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails\n+            }\n+\n+            logger.debug(\"{}: Channel command for device {}: {} for channel {}\", thingId, thingConfig.getFriendlyName(),\n+                    command, channelUID.getId());\n+            switch (channelUID.getId()) {\n+                case CHANNEL_POWER: // toggle power\n+                    logger.debug(\"{}: Toggle power, new state={}\", thingId, command);\n+                    control.sendKey(\"POWER\");\n+                    break;\n+                case CHANNEL_PLAYER:\n+                    logger.debug(\"{}: Player command: {}\", thingId, command);\n+                    if (command instanceof OnOffType) {\n+                        control.sendKey(\"POWER\");\n+                    } else if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            control.sendKey(\"PLAY\");\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            control.sendKey(\"PAUSE\");\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            control.sendKey(\"NEXTCH\");\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            control.sendKey(\"PREVCH\");\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                        if (command == RewindFastforwardType.FASTFORWARD) {\n+                            control.sendKey(\"FORWARD\");\n+                        } else if (command == RewindFastforwardType.REWIND) {\n+                            control.sendKey(\"REWIND\");\n+                        }\n+                    } else {\n+                        logger.debug(\"{}: Unknown media command: {}\", thingId, command);\n+                    }\n+                    break;\n+                case CHANNEL_CHANNEL:\n+                    String chan = command.toString();\n+                    control.selectChannel(chan);\n+                    break;\n+                case CHANNEL_MUTE:\n+                    if (command == OnOffType.ON) {\n+                        control.sendKey(\"MUTE\");\n+                    } else {\n+                        control.sendKey(\"VOLUP\");\n+                    }\n+                    break;\n+                case CHANNEL_KEY:\n+                    if (command.toString().equalsIgnoreCase(\"PAIR\")) { // special key to re-pair receiver (already done\n+                                                                       // above)\n+                        logger.debug(\"{}: PAIRing key received, reconnect receiver {}\", thingId, deviceName());\n+                    } else {\n+                        control.sendKey(command.toString());\n+                        mapKeyToMediateState(command.toString());\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"{}: Command {} for unknown channel {}\", thingId, command, channelUID.getAsString());\n+            }\n+        } catch (MagentaTVException e) {\n+            String errorMessage = MessageFormat.format(\"Channel operation failed (command={0}, value={1}): {2}\",\n+                    command, channelUID.getId(), e.toString());\n+            logger.debug(\"{}: {}\", thingId, errorMessage);\n+            setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+        }\n+    }\n+\n+    private void mapKeyToMediateState(String key) {\n+        State state = null;\n+        switch (key.toUpperCase()) {\n+            case \"PLAY\":\n+                state = PlayPauseType.PLAY;\n+                break;\n+            case \"PAUSE\":\n+                state = PlayPauseType.PAUSE;\n+                break;\n+            case \"FORWARD\":\n+                state = RewindFastforwardType.FASTFORWARD;\n+                break;\n+            case \"REWIND\":\n+                updateState(CHANNEL_PLAYER, RewindFastforwardType.REWIND);\n+                break;\n+        }\n+        if (state != null) {\n+            logger.debug(\"{}: Setting Player state to {}\", thingId, state);\n+            updateState(CHANNEL_PLAYER, state);\n+        }\n+    }\n+\n+    /**\n+     * Connect to the receiver\n+     *\n+     * @throws MagentaTVException something failed\n+     */\n+    protected void connectReceiver() throws MagentaTVException {\n+        if (control.checkDev()) {\n+            thingConfig.updateConfig(control.getConfig().getProperties()); // get description data\n+            updateThingProperties(thingConfig.getProperties());\n+            handlerFactory.registerDevice(thingConfig.getUDN(), thingConfig.getTerminalID(), thingConfig.getIpAddress(),\n+                    this);\n+            control.subscribeEventChannel();\n+            control.sendPairingRequest();\n+            updateThingProperties(thingConfig.getProperties());\n+\n+            // check for pairing timeout\n+            final int iRefresh = ++idRefresh;\n+            pairingWatchdogJob = scheduler.schedule(() -> {\n+                if (iRefresh == idRefresh) { // Make a best effort to not run multiple deferred refresh\n+                    if (thingConfig.getVerificationCode().isEmpty()) {\n+                        setOnlineState(ThingStatus.OFFLINE, \"Timeout on pairing request!\");\n+                    }\n+                }\n+            }, 15, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * If userID is empty and credentials are given the Telekom OAuth service is\n+     * used to query the userID\n+     *\n+     * @throws MagentaTVException\n+     */\n+    private void authenticateUser() throws MagentaTVException {\n+        String userId = thingConfig.getUserID();\n+        if (userId.isEmpty()) {\n+            // run OAuth authentication, this finally provides the userID\n+            userId = control.authenticateUser(thingConfig.getAccountName(), thingConfig.getAccountPassword());\n+\n+            // Update thing configuration (persistent) - remove credentials, add userID\n+            Configuration configuration = this.getConfig();\n+            configuration.remove(PROPERTY_ACCT_NAME);\n+            configuration.remove(PROPERTY_ACCT_PWD);\n+            configuration.remove(PROPERTY_USERID);\n+            configuration.put(PROPERTY_ACCT_NAME, EMPTY_CRED);\n+            configuration.put(PROPERTY_ACCT_PWD, EMPTY_CRED);\n+            configuration.put(PROPERTY_USERID, userId);\n+            this.updateConfiguration(configuration);\n+            thingConfig.setAccountName(EMPTY_CRED);\n+            thingConfig.setAccountPassword(EMPTY_CRED);\n+        } else {\n+            logger.debug(\"{}: Skip OAuth, use existing userID {}\", thingId, thingConfig.getUserID());\n+        }\n+        if (!userId.isEmpty()) {\n+            thingConfig.setUserID(userId);\n+        } else {\n+            logger.warn(\"{}: Unable to obtain userId from OAuth\", thingId);\n+        }\n+    }\n+\n+    /**\n+     * Update thing status\n+     *\n+     * @param mode new thing status\n+     * @return ON = power on, OFF=power off\n+     */\n+    public void setOnlineState(ThingStatus newStatus, String errorMessage) {\n+        ThingStatus status = this.getThing().getStatus();\n+        if (status != newStatus) {\n+            if (newStatus == ThingStatus.INITIALIZING) {\n+                logger.debug(\"{}: Invalid new thing state: {}\", thingId, newStatus);", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMDU2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439230564", "bodyText": "left-over", "author": "markus7017", "createdAt": "2020-06-12T06:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2OTgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MjA2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r439072065", "bodyText": "There is no need to call replace since the map still holds a reference to the dev object already. Java passes objects by reference, not by value.", "author": "cpmeister", "createdAt": "2020-06-11T21:09:14Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVHandlerFactory.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.net.HttpServiceUtil;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.magentatv.internal.handler.MagentaTVHandler;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVPoweroffListener;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class, MagentaTVHandlerFactory.class }, configurationPid = \"binding.\"\n+        + BINDING_ID)\n+public class MagentaTVHandlerFactory extends BaseThingHandlerFactory {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandlerFactory.class);\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RECEIVER);\n+\n+    private final MagentaTVPoweroffListener upnpListener;\n+    private final MagentaTVNetwork network = new MagentaTVNetwork();\n+    private boolean servletInitialized = false;\n+\n+    protected class MagentaTVDevice {\n+        protected String udn = \"\";\n+        protected String mac = \"\";\n+        protected String deviceId = \"\";\n+        protected String ipAddress = \"\";\n+        protected Map<String, String> properties = new HashMap<>();\n+        protected @Nullable MagentaTVHandler thingHandler;\n+    }\n+\n+    private final Map<String, MagentaTVDevice> deviceList = new HashMap<String, MagentaTVDevice>();\n+\n+    /**\n+     * Activate the bundle: save properties\n+     *\n+     * @param componentContext\n+     * @param configProperties set of properties from cfg (use same names as in\n+     *            thing config)\n+     */\n+\n+    @Activate\n+    public MagentaTVHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            ComponentContext componentContext, Map<String, String> configProperties) throws IOException {\n+        super.activate(componentContext);\n+\n+        try {\n+            logger.debug(\"Initialize network access\");\n+            System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n+            String lip = networkAddressService.getPrimaryIpv4HostAddress();\n+            Integer port = HttpServiceUtil.getHttpServicePort(componentContext.getBundleContext());\n+            if (port == -1) {\n+                port = 8080;\n+            }\n+            network.initLocalNet(lip != null ? lip : \"\", port.toString());\n+        } catch (MagentaTVException e) {\n+            logger.warn(\"Initialization failed: {}\", e.toString());\n+        }\n+        upnpListener = new MagentaTVPoweroffListener(this, network.getLocalInterface());\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (!upnpListener.isStarted()) {\n+            upnpListener.start();\n+        }\n+\n+        logger.debug(\"Create thing type {}\", thing.getThingTypeUID().getAsString());\n+        if (THING_TYPE_RECEIVER.equals(thingTypeUID)) {\n+            return new MagentaTVHandler(this, thing, network);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Remove handler of things.\n+     */\n+    @Override\n+    protected synchronized void removeHandler(ThingHandler thingHandler) {\n+        if (thingHandler instanceof MagentaTVHandler) {\n+        }\n+    }\n+\n+    /**\n+     * A device was discovered by UPnP. A new device gets inserted into the\n+     * deviceList table, otherwise the properties will be updated.\n+     *\n+     * @param discoveryProperties Properties discoverd by UPnP\n+     */\n+    public void deviceDiscoverd(Map<String, String> discoveryProperties) {\n+        if (!discoveryProperties.containsKey(PROPERTY_UDN)) {\n+            return;\n+        }\n+        String discoveredUDN = discoveryProperties.get(PROPERTY_UDN);\n+        discoveredUDN = discoveredUDN.toUpperCase();\n+        logger.trace(\"Discovered device with UDN {}\", discoveredUDN);\n+        try {\n+            MagentaTVDevice dev = null;\n+            synchronized (deviceList) {\n+                if (deviceList.containsKey(discoveredUDN)) {\n+                    dev = deviceList.get(discoveredUDN);\n+                    logger.trace(\"Known device with UDN {}, update properties\", discoveredUDN);\n+                    dev.properties = discoveryProperties;\n+                    deviceList.replace(discoveredUDN, dev);", "originalCommit": "2cfc59384a5b7c2bc4f63bfc76c9f1c0f8522163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NTc4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r441075787", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-06-16T18:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MjA2NQ=="}], "type": "inlineReview"}, {"oid": "1f16e72dda285102ef223873f5f603917105266b", "url": "https://github.com/openhab/openhab-addons/commit/1f16e72dda285102ef223873f5f603917105266b", "message": "various missing key codes added, review change (remove .replace)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-08-23T06:46:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0NDA5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r477544093", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // overwrite port returned by discovery (invaslid for this model)\n          \n          \n            \n                        // overwrite port returned by discovery (invalid for this model)", "author": "kaikreuzer", "createdAt": "2020-08-26T19:39:18Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/config/MagentaTVThingConfiguration.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.config;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link MagentaTVThingConfiguration} contains the thing config (updated at\n+ * runtime).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVThingConfiguration {\n+    public String modelId = MODEL_MR400; // MR model\n+    public String ipAddress = \"\"; // IP Address of the MR\n+    public String port = MR400_DEF_REMOTE_PORT; // Port of the remote service\n+    public String udn = \"\"; // UPnP UDN\n+    public String macAddress = \"\"; // Usually gets filled by the thing discovery (or set by .things file)\n+    public String accountName = \"\"; // Credentials: Account Name from Telekom Kundencenter (used for OAuth)\n+    public String accountPassword = \"\"; // Credentials: Account Password from Telekom Kundencenter (used for OAuth)\n+    public String userId = \"\"; // userId required for pairing (can be configured manually or gets auto-filled by the\n+                               // binding on successful OAuth. Value is persisted so OAuth nedds only to be redone when\n+                               // credentials change.\n+\n+    public void update(MagentaTVThingConfiguration newConfig) {\n+        modelId = newConfig.modelId;\n+        ipAddress = newConfig.ipAddress;\n+        port = newConfig.port;\n+        udn = newConfig.udn;\n+        macAddress = newConfig.macAddress;\n+        accountName = newConfig.accountName;\n+        accountPassword = newConfig.accountPassword;\n+        userId = newConfig.userId;\n+    }\n+\n+    public String getModel() {\n+        return modelId.toUpperCase();\n+    }\n+\n+    public boolean isMR400() {\n+        return modelId.equals(MODEL_MR400);\n+    }\n+\n+    public void setModel(String modelId) {\n+        this.modelId = modelId;\n+    }\n+\n+    /*\n+     * public void setHardwareVersion(String version) {\n+     *\n+     * setValue(PROPERTY_HARDWARE_VERSION, version);\n+     * }\n+     *\n+     * public String getFirmwareVersion() {\n+     * return getValue(PROPERTY_FIRMWARE_VERSION, \"\");\n+     * }\n+     *\n+     * public void setFirmwareVersion(String version) {\n+     * setValue(PROPERTY_FIRMWARE_VERSION, version);\n+     * }\n+     */\n+    public String getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(String port) {\n+        if (modelId.contains(MODEL_MR400) && port.equals(\"49153\")) {\n+            // overwrite port returned by discovery (invaslid for this model)", "originalCommit": "fa000cb26385a806717ae3f0f0260617d56464b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxNjM1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r477616358", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-08-26T22:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU0NDA5Mw=="}], "type": "inlineReview"}, {"oid": "65a81a908b9e469bd99a4c28fc8a3c8577514b53", "url": "https://github.com/openhab/openhab-addons/commit/65a81a908b9e469bd99a4c28fc8a3c8577514b53", "message": "apply review comment (use StringBuffer)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-08-26T20:40:26Z", "type": "forcePushed"}, {"oid": "dc4137992f66de854b7718f798841982170bc158", "url": "https://github.com/openhab/openhab-addons/commit/dc4137992f66de854b7718f798841982170bc158", "message": "Initial checkin based on latest codebase\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T08:14:03Z", "type": "commit"}, {"oid": "b2f66a29a4028c9386260db79f5467853022dbed", "url": "https://github.com/openhab/openhab-addons/commit/b2f66a29a4028c9386260db79f5467853022dbed", "message": "adapted to 2.5.6\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T08:14:03Z", "type": "commit"}, {"oid": "d20ef5dd6b771ca9c38c9be82bcc4bc55174522e", "url": "https://github.com/openhab/openhab-addons/commit/d20ef5dd6b771ca9c38c9be82bcc4bc55174522e", "message": "magentatv added to bundle's pom.xml and CODEOWNERS\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T08:14:03Z", "type": "commit"}, {"oid": "517c58c95b6b065fbe20158c19009f09bc37daed", "url": "https://github.com/openhab/openhab-addons/commit/517c58c95b6b065fbe20158c19009f09bc37daed", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T08:14:03Z", "type": "commit"}, {"oid": "999b403b453481e7eb89c9b4dc58708a0d22eb0a", "url": "https://github.com/openhab/openhab-addons/commit/999b403b453481e7eb89c9b4dc58708a0d22eb0a", "message": "Config management re-factored WIP\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T08:14:03Z", "type": "commit"}, {"oid": "2fb468c83b4fbd8d0793cf49e9b65c5df75a084b", "url": "https://github.com/openhab/openhab-addons/commit/2fb468c83b4fbd8d0793cf49e9b65c5df75a084b", "message": "various missing key codes added, review change (remove .replace)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T08:14:03Z", "type": "commit"}, {"oid": "cc00bcd41a0c20573dda91882b7df1f358999690", "url": "https://github.com/openhab/openhab-addons/commit/cc00bcd41a0c20573dda91882b7df1f358999690", "message": "apply review comment (use StringBuffer)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T08:14:03Z", "type": "commit"}, {"oid": "098cda6afffccdf2ecf163c7a098ca894ebd6810", "url": "https://github.com/openhab/openhab-addons/commit/098cda6afffccdf2ecf163c7a098ca894ebd6810", "message": "applied review comments\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T08:14:03Z", "type": "commit"}, {"oid": "098cda6afffccdf2ecf163c7a098ca894ebd6810", "url": "https://github.com/openhab/openhab-addons/commit/098cda6afffccdf2ecf163c7a098ca894ebd6810", "message": "applied review comments\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T08:14:03Z", "type": "forcePushed"}, {"oid": "c0f126336b730380ffb46b395feb768e79a65766", "url": "https://github.com/openhab/openhab-addons/commit/c0f126336b730380ffb46b395feb768e79a65766", "message": "start adding a console handler\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T16:21:01Z", "type": "commit"}, {"oid": "4369bcadaac1a5d3f169813b1a50d4c3c910e911", "url": "https://github.com/openhab/openhab-addons/commit/4369bcadaac1a5d3f169813b1a50d4c3c910e911", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T19:23:19Z", "type": "commit"}, {"oid": "12530973bcf0205919b461feac7c30b8cfbd2ce1", "url": "https://github.com/openhab/openhab-addons/commit/12530973bcf0205919b461feac7c30b8cfbd2ce1", "message": "Port is optional in thing config; Default for MR400: 49152, for all\nothers: 8081; gets auto-discovered when using UPnP\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-05T21:44:52Z", "type": "commit"}, {"oid": "4f21ef1c0b38383f07008f1f26850539efd6a43f", "url": "https://github.com/openhab/openhab-addons/commit/4f21ef1c0b38383f07008f1f26850539efd6a43f", "message": "Implemented new handling for generation of userId - by setting\ncredentials in thing config or generating the userId as console command\n(smarthome:magentatv login)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-06T11:03:35Z", "type": "commit"}, {"oid": "24ab87b393984666c2e12790c244d984956536fe", "url": "https://github.com/openhab/openhab-addons/commit/24ab87b393984666c2e12790c244d984956536fe", "message": "review changes applied; StringUtils replaced by native code\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-06T17:53:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNTMxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484115314", "bodyText": "With Tesla? \ud83d\ude06", "author": "kaikreuzer", "createdAt": "2020-09-06T21:22:28Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVConsoleHandler.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.BINDING_ID;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Console commands for interacting with the Tesla integration", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2NTQ5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484265493", "bodyText": "you catched me :-)\nchanged", "author": "markus7017", "createdAt": "2020-09-07T08:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNTMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNTQ2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484115464", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            \"Authenticates the login name and provides the technical User Id (userId parameter).\"));\n          \n          \n            \n                            \"Logs into the account with the provided credentials and retrieves the userId parameter.\"));", "author": "kaikreuzer", "createdAt": "2020-09-06T21:24:26Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVConsoleHandler.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.BINDING_ID;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Console commands for interacting with the Tesla integration\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ConsoleCommandExtension.class, immediate = true)\n+public class MagentaTVConsoleHandler extends AbstractConsoleCommandExtension {\n+\n+    private static final String CMD_LOGIN = \"login\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVConsoleHandler.class);\n+    private final MagentaTVOAuth oauth = new MagentaTVOAuth();\n+\n+    @Reference(cardinality = ReferenceCardinality.OPTIONAL)\n+    private @Nullable ClientBuilder injectedClientBuilder;\n+\n+    @Activate\n+    public MagentaTVConsoleHandler() {\n+        super(BINDING_ID, \"Interact with the \" + BINDING_ID + \" integration.\");\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case CMD_LOGIN:\n+                    if (args.length == 1) {\n+                        try {\n+                            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+                            console.print(\"Login Name (email): \");\n+                            String username = br.readLine();\n+                            console.print(\"Password: \");\n+                            String pwd = br.readLine();\n+                            console.println(\"Attempting login...\");\n+                            login(console, username, pwd);\n+                        } catch (IOException e) {\n+                            console.println(e.toString());\n+                        }\n+                    } else if (args.length == 3) {\n+                        login(console, args[1], args[2]);\n+                    } else {\n+                        printUsage(console);\n+                    }\n+                    break;\n+\n+                default:\n+                    console.println(\"Unknown command '\" + subCommand + \"'\");\n+                    printUsage(console);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(buildCommandUsage(CMD_LOGIN + \" [<login email>] [<password>]\",\n+                \"Authenticates the login name and provides the technical User Id (userId parameter).\"));", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI2NzI2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484267264", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-07T08:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNTQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNTU2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484115561", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"User Id for user {} is {}\", username, userId);\n          \n          \n            \n                        logger.info(\"userId for user {} is {}\", username, userId);", "author": "kaikreuzer", "createdAt": "2020-09-06T21:25:14Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVConsoleHandler.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.BINDING_ID;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Console commands for interacting with the Tesla integration\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ConsoleCommandExtension.class, immediate = true)\n+public class MagentaTVConsoleHandler extends AbstractConsoleCommandExtension {\n+\n+    private static final String CMD_LOGIN = \"login\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVConsoleHandler.class);\n+    private final MagentaTVOAuth oauth = new MagentaTVOAuth();\n+\n+    @Reference(cardinality = ReferenceCardinality.OPTIONAL)\n+    private @Nullable ClientBuilder injectedClientBuilder;\n+\n+    @Activate\n+    public MagentaTVConsoleHandler() {\n+        super(BINDING_ID, \"Interact with the \" + BINDING_ID + \" integration.\");\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case CMD_LOGIN:\n+                    if (args.length == 1) {\n+                        try {\n+                            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n+                            console.print(\"Login Name (email): \");\n+                            String username = br.readLine();\n+                            console.print(\"Password: \");\n+                            String pwd = br.readLine();\n+                            console.println(\"Attempting login...\");\n+                            login(console, username, pwd);\n+                        } catch (IOException e) {\n+                            console.println(e.toString());\n+                        }\n+                    } else if (args.length == 3) {\n+                        login(console, args[1], args[2]);\n+                    } else {\n+                        printUsage(console);\n+                    }\n+                    break;\n+\n+                default:\n+                    console.println(\"Unknown command '\" + subCommand + \"'\");\n+                    printUsage(console);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(buildCommandUsage(CMD_LOGIN + \" [<login email>] [<password>]\",\n+                \"Authenticates the login name and provides the technical User Id (userId parameter).\"));\n+    }\n+\n+    private void login(Console console, String username, String password) {\n+        try {\n+            logger.info(\"Performing OAuth for user {}\", username);\n+            String userId = oauth.getUserId(username, password);\n+            console.println(\"Login successful, returned userId is \" + userId);\n+            console.println(\"Edit thing configuration and copy this value to the field User Id (userId)\");\n+            logger.info(\"User Id for user {} is {}\", username, userId);", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI4MzAwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484283001", "bodyText": "just noted. The UI doesn't show a field \"User ID\" and the user is not aware that this parameter is named userId. So it doesn't make sense to talk about \"parameter userId\". From the user's point of view is also \"Account Name\" and not accountName. Therefore I'll use \"User ID\" for user doc/messages and userId for technical messages.", "author": "markus7017", "createdAt": "2020-09-07T08:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNTU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1MTgxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484551819", "bodyText": "it doesn't make sense to talk about \"parameter userId\".\n\nIt makes a lot of sense, because this is exactly what is documented as parameters.\nAlso note that the console command is meant for people doing textual configuration and the userId parameter is exactly what they are after.", "author": "kaikreuzer", "createdAt": "2020-09-07T19:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNTU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1OTAwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484559005", "bodyText": "For me the console command is for users who doesn't want to store credentials in the configuration.\nHow does a UI user understands that userId means the field User ID, which is the description for the parameter userId? This is not visible in the UI\nChanged the message to:\nLogin successful, returned User ID is xxxx\nEdit thing configuration and copy this value to the field User ID or use it as parameter userId for the textual configuration.\nok?", "author": "markus7017", "createdAt": "2020-09-07T20:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNTU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2Mjg1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484562858", "bodyText": "ok.", "author": "kaikreuzer", "createdAt": "2020-09-07T20:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNTU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNTkxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484115916", "bodyText": "Shouldn't you better return here and not create the upnpListener?\nMight also rather be an \"error\" as it probably can be assumed that the whole binding won't work, right?", "author": "kaikreuzer", "createdAt": "2020-09-06T21:29:16Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVHandlerFactory.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.substringAfterLast;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.net.HttpServiceUtil;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.magentatv.internal.handler.MagentaTVHandler;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVPoweroffListener;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class, MagentaTVHandlerFactory.class }, configurationPid = \"binding.\"\n+        + BINDING_ID)\n+public class MagentaTVHandlerFactory extends BaseThingHandlerFactory {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandlerFactory.class);\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RECEIVER);\n+\n+    private final MagentaTVPoweroffListener upnpListener;\n+    private final MagentaTVNetwork network = new MagentaTVNetwork();\n+    private boolean servletInitialized = false;\n+\n+    protected class MagentaTVDevice {\n+        protected String udn = \"\";\n+        protected String mac = \"\";\n+        protected String deviceId = \"\";\n+        protected String ipAddress = \"\";\n+        protected Map<String, String> properties = new HashMap<>();\n+        protected @Nullable MagentaTVHandler thingHandler;\n+    }\n+\n+    private final Map<String, MagentaTVDevice> deviceList = new HashMap<String, MagentaTVDevice>();\n+\n+    /**\n+     * Activate the bundle: save properties\n+     *\n+     * @param componentContext\n+     * @param configProperties set of properties from cfg (use same names as in\n+     *            thing config)\n+     */\n+\n+    @Activate\n+    public MagentaTVHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            ComponentContext componentContext, Map<String, String> configProperties) throws IOException {\n+        super.activate(componentContext);\n+\n+        try {\n+            logger.debug(\"Initialize network access\");\n+            System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n+            String lip = networkAddressService.getPrimaryIpv4HostAddress();\n+            Integer port = HttpServiceUtil.getHttpServicePort(componentContext.getBundleContext());\n+            if (port == -1) {\n+                port = 8080;\n+            }\n+            network.initLocalNet(lip != null ? lip : \"\", port.toString());\n+        } catch (MagentaTVException e) {\n+            logger.warn(\"Initialization failed: {}\", e.toString());", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMwNzMwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484307305", "bodyText": "yep, changed", "author": "markus7017", "createdAt": "2020-09-07T09:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNTkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzAzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484117038", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * We received the pairing resuled (by the Norify servlet)\n          \n          \n            \n                 * We received the pairing result (by the Notify servlet)", "author": "kaikreuzer", "createdAt": "2020-09-06T21:41:51Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVHandlerFactory.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.substringAfterLast;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.net.HttpServiceUtil;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.magentatv.internal.handler.MagentaTVHandler;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVPoweroffListener;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class, MagentaTVHandlerFactory.class }, configurationPid = \"binding.\"\n+        + BINDING_ID)\n+public class MagentaTVHandlerFactory extends BaseThingHandlerFactory {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandlerFactory.class);\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RECEIVER);\n+\n+    private final MagentaTVPoweroffListener upnpListener;\n+    private final MagentaTVNetwork network = new MagentaTVNetwork();\n+    private boolean servletInitialized = false;\n+\n+    protected class MagentaTVDevice {\n+        protected String udn = \"\";\n+        protected String mac = \"\";\n+        protected String deviceId = \"\";\n+        protected String ipAddress = \"\";\n+        protected Map<String, String> properties = new HashMap<>();\n+        protected @Nullable MagentaTVHandler thingHandler;\n+    }\n+\n+    private final Map<String, MagentaTVDevice> deviceList = new HashMap<String, MagentaTVDevice>();\n+\n+    /**\n+     * Activate the bundle: save properties\n+     *\n+     * @param componentContext\n+     * @param configProperties set of properties from cfg (use same names as in\n+     *            thing config)\n+     */\n+\n+    @Activate\n+    public MagentaTVHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            ComponentContext componentContext, Map<String, String> configProperties) throws IOException {\n+        super.activate(componentContext);\n+\n+        try {\n+            logger.debug(\"Initialize network access\");\n+            System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n+            String lip = networkAddressService.getPrimaryIpv4HostAddress();\n+            Integer port = HttpServiceUtil.getHttpServicePort(componentContext.getBundleContext());\n+            if (port == -1) {\n+                port = 8080;\n+            }\n+            network.initLocalNet(lip != null ? lip : \"\", port.toString());\n+        } catch (MagentaTVException e) {\n+            logger.warn(\"Initialization failed: {}\", e.toString());\n+        }\n+        upnpListener = new MagentaTVPoweroffListener(this, network.getLocalInterface());\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (!upnpListener.isStarted()) {\n+            upnpListener.start();\n+        }\n+\n+        logger.debug(\"Create thing type {}\", thing.getThingTypeUID().getAsString());\n+        if (THING_TYPE_RECEIVER.equals(thingTypeUID)) {\n+            return new MagentaTVHandler(this, thing, network);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Add a device to the device table\n+     *\n+     * @param udn UDN for the device\n+     * @param deviceId A unique device id\n+     * @param ipAddress IP address of the receiver\n+     * @param handler The corresponding thing handler\n+     */\n+    public void registerDevice(String udn, String deviceId, String ipAddress, MagentaTVHandler handler) {\n+        logger.trace(\"Register new device, UDN={}, deviceId={}, ipAddress={}\", udn, deviceId, ipAddress);\n+        addNewDevice(udn, deviceId, ipAddress, \"\", new TreeMap<String, String>(), handler);\n+    }\n+\n+    private void addNewDevice(String udn, String deviceId, String ipAddress, String macAddress,\n+            Map<String, String> discoveryProperties, @Nullable MagentaTVHandler handler) {\n+        String mac = \"\";\n+        if (macAddress.isEmpty()) { // build MAC from UDN\n+            mac = substringAfterLast(udn, \"-\");\n+        } else {\n+            mac = macAddress;\n+        }\n+\n+        boolean newDev = false;\n+        synchronized (deviceList) {\n+            MagentaTVDevice dev;\n+            if (deviceList.containsKey(udn.toUpperCase())) {\n+                dev = deviceList.get(udn.toUpperCase());\n+            } else {\n+                dev = new MagentaTVDevice();\n+                newDev = true;\n+            }\n+            dev.udn = udn.toUpperCase();\n+            dev.mac = mac.toUpperCase();\n+            if (!deviceId.isEmpty()) {\n+                dev.deviceId = deviceId.toUpperCase();\n+            }\n+            dev.ipAddress = ipAddress;\n+            dev.properties = discoveryProperties;\n+            dev.thingHandler = handler;\n+            if (newDev) {\n+                deviceList.put(dev.udn, dev);\n+            }\n+        }\n+        logger.debug(\"New device {}: (UDN={} ,deviceId={}, ipAddress={}, macAddress={}), now {} devices.\",\n+                newDev ? \"added\" : \"updated\", udn, deviceId, ipAddress, mac, deviceList.size());\n+    }\n+\n+    /**\n+     * Remove a device from the table\n+     *\n+     * @param deviceId\n+     */\n+    public void removeDevice(String deviceId) {\n+        MagentaTVDevice dev = lookupDevice(deviceId);\n+        if (dev != null) {\n+            synchronized (deviceList) {\n+                logger.trace(\"Device with UDN {}\u00a0removed from table, new site={}\", dev.udn, deviceList.size());\n+                deviceList.remove(dev.udn);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Lookup a device in the table by an id (this could be the UDN, the MAC\n+     * address, the IP address or a unique device ID)\n+     *\n+     * @param uniqueId\n+     * @return\n+     */\n+    private @Nullable MagentaTVDevice lookupDevice(String uniqueId) {\n+        MagentaTVDevice dev = null;\n+        logger.trace(\"Lookup device, uniqueId={}\", uniqueId);\n+        int i = 0;\n+        for (String key : deviceList.keySet()) {\n+            synchronized (deviceList) {\n+                if (deviceList.containsKey(key)) {\n+                    dev = deviceList.get(key);\n+                    logger.trace(\"Devies[{}]: deviceId={}, UDN={}, ipAddress={}, macAddress={}\", i++, dev.deviceId,\n+                            dev.udn, dev.ipAddress, dev.mac);\n+                    if (dev.udn.equalsIgnoreCase(uniqueId) || dev.ipAddress.equalsIgnoreCase(uniqueId)\n+                            || dev.deviceId.equalsIgnoreCase(uniqueId) || dev.mac.equalsIgnoreCase(uniqueId)) {\n+                        return dev;\n+                    }\n+                }\n+            }\n+        }\n+        logger.debug(\"Device with id {}\u00a0was not found in table ({} entries\", uniqueId, deviceList.size());\n+        return null;\n+    }\n+\n+    /**\n+     * returned the discovered properties\n+     *\n+     * @param udn Unique ID from UPnP discovery\n+     * @return property map with discovered properties\n+     */\n+    public @Nullable Map<String, String> getDiscoveredProperties(String udn) {\n+        if (deviceList.containsKey(udn.toUpperCase())) {\n+            MagentaTVDevice dev = deviceList.get(udn.toUpperCase());\n+            return dev.properties;\n+        }\n+        if (deviceList.size() > 0) {\n+            logger.debug(\"getDiscoveredProperties(): Unknown UDN: {}\", udn);\n+        }\n+        return null;\n+    }\n+\n+    public void setNotifyServletStatus(boolean newStatus) {\n+        logger.debug(\"NotifyServlet started\");\n+        servletInitialized = newStatus;\n+    }\n+\n+    public boolean getNotifyServletStatus() {\n+        return servletInitialized;\n+    }\n+\n+    /**\n+     * We received the pairing resuled (by the Norify servlet)", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMwOTAyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484309023", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-07T09:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzA2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484117062", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param pairingCode Pairng code computed by the receiver\n          \n          \n            \n                 * @param pairingCode Pairing code computed by the receiver", "author": "kaikreuzer", "createdAt": "2020-09-06T21:42:13Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVHandlerFactory.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.substringAfterLast;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.net.HttpServiceUtil;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.magentatv.internal.handler.MagentaTVHandler;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVPoweroffListener;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class, MagentaTVHandlerFactory.class }, configurationPid = \"binding.\"\n+        + BINDING_ID)\n+public class MagentaTVHandlerFactory extends BaseThingHandlerFactory {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandlerFactory.class);\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_RECEIVER);\n+\n+    private final MagentaTVPoweroffListener upnpListener;\n+    private final MagentaTVNetwork network = new MagentaTVNetwork();\n+    private boolean servletInitialized = false;\n+\n+    protected class MagentaTVDevice {\n+        protected String udn = \"\";\n+        protected String mac = \"\";\n+        protected String deviceId = \"\";\n+        protected String ipAddress = \"\";\n+        protected Map<String, String> properties = new HashMap<>();\n+        protected @Nullable MagentaTVHandler thingHandler;\n+    }\n+\n+    private final Map<String, MagentaTVDevice> deviceList = new HashMap<String, MagentaTVDevice>();\n+\n+    /**\n+     * Activate the bundle: save properties\n+     *\n+     * @param componentContext\n+     * @param configProperties set of properties from cfg (use same names as in\n+     *            thing config)\n+     */\n+\n+    @Activate\n+    public MagentaTVHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            ComponentContext componentContext, Map<String, String> configProperties) throws IOException {\n+        super.activate(componentContext);\n+\n+        try {\n+            logger.debug(\"Initialize network access\");\n+            System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n+            String lip = networkAddressService.getPrimaryIpv4HostAddress();\n+            Integer port = HttpServiceUtil.getHttpServicePort(componentContext.getBundleContext());\n+            if (port == -1) {\n+                port = 8080;\n+            }\n+            network.initLocalNet(lip != null ? lip : \"\", port.toString());\n+        } catch (MagentaTVException e) {\n+            logger.warn(\"Initialization failed: {}\", e.toString());\n+        }\n+        upnpListener = new MagentaTVPoweroffListener(this, network.getLocalInterface());\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (!upnpListener.isStarted()) {\n+            upnpListener.start();\n+        }\n+\n+        logger.debug(\"Create thing type {}\", thing.getThingTypeUID().getAsString());\n+        if (THING_TYPE_RECEIVER.equals(thingTypeUID)) {\n+            return new MagentaTVHandler(this, thing, network);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Add a device to the device table\n+     *\n+     * @param udn UDN for the device\n+     * @param deviceId A unique device id\n+     * @param ipAddress IP address of the receiver\n+     * @param handler The corresponding thing handler\n+     */\n+    public void registerDevice(String udn, String deviceId, String ipAddress, MagentaTVHandler handler) {\n+        logger.trace(\"Register new device, UDN={}, deviceId={}, ipAddress={}\", udn, deviceId, ipAddress);\n+        addNewDevice(udn, deviceId, ipAddress, \"\", new TreeMap<String, String>(), handler);\n+    }\n+\n+    private void addNewDevice(String udn, String deviceId, String ipAddress, String macAddress,\n+            Map<String, String> discoveryProperties, @Nullable MagentaTVHandler handler) {\n+        String mac = \"\";\n+        if (macAddress.isEmpty()) { // build MAC from UDN\n+            mac = substringAfterLast(udn, \"-\");\n+        } else {\n+            mac = macAddress;\n+        }\n+\n+        boolean newDev = false;\n+        synchronized (deviceList) {\n+            MagentaTVDevice dev;\n+            if (deviceList.containsKey(udn.toUpperCase())) {\n+                dev = deviceList.get(udn.toUpperCase());\n+            } else {\n+                dev = new MagentaTVDevice();\n+                newDev = true;\n+            }\n+            dev.udn = udn.toUpperCase();\n+            dev.mac = mac.toUpperCase();\n+            if (!deviceId.isEmpty()) {\n+                dev.deviceId = deviceId.toUpperCase();\n+            }\n+            dev.ipAddress = ipAddress;\n+            dev.properties = discoveryProperties;\n+            dev.thingHandler = handler;\n+            if (newDev) {\n+                deviceList.put(dev.udn, dev);\n+            }\n+        }\n+        logger.debug(\"New device {}: (UDN={} ,deviceId={}, ipAddress={}, macAddress={}), now {} devices.\",\n+                newDev ? \"added\" : \"updated\", udn, deviceId, ipAddress, mac, deviceList.size());\n+    }\n+\n+    /**\n+     * Remove a device from the table\n+     *\n+     * @param deviceId\n+     */\n+    public void removeDevice(String deviceId) {\n+        MagentaTVDevice dev = lookupDevice(deviceId);\n+        if (dev != null) {\n+            synchronized (deviceList) {\n+                logger.trace(\"Device with UDN {}\u00a0removed from table, new site={}\", dev.udn, deviceList.size());\n+                deviceList.remove(dev.udn);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Lookup a device in the table by an id (this could be the UDN, the MAC\n+     * address, the IP address or a unique device ID)\n+     *\n+     * @param uniqueId\n+     * @return\n+     */\n+    private @Nullable MagentaTVDevice lookupDevice(String uniqueId) {\n+        MagentaTVDevice dev = null;\n+        logger.trace(\"Lookup device, uniqueId={}\", uniqueId);\n+        int i = 0;\n+        for (String key : deviceList.keySet()) {\n+            synchronized (deviceList) {\n+                if (deviceList.containsKey(key)) {\n+                    dev = deviceList.get(key);\n+                    logger.trace(\"Devies[{}]: deviceId={}, UDN={}, ipAddress={}, macAddress={}\", i++, dev.deviceId,\n+                            dev.udn, dev.ipAddress, dev.mac);\n+                    if (dev.udn.equalsIgnoreCase(uniqueId) || dev.ipAddress.equalsIgnoreCase(uniqueId)\n+                            || dev.deviceId.equalsIgnoreCase(uniqueId) || dev.mac.equalsIgnoreCase(uniqueId)) {\n+                        return dev;\n+                    }\n+                }\n+            }\n+        }\n+        logger.debug(\"Device with id {}\u00a0was not found in table ({} entries\", uniqueId, deviceList.size());\n+        return null;\n+    }\n+\n+    /**\n+     * returned the discovered properties\n+     *\n+     * @param udn Unique ID from UPnP discovery\n+     * @return property map with discovered properties\n+     */\n+    public @Nullable Map<String, String> getDiscoveredProperties(String udn) {\n+        if (deviceList.containsKey(udn.toUpperCase())) {\n+            MagentaTVDevice dev = deviceList.get(udn.toUpperCase());\n+            return dev.properties;\n+        }\n+        if (deviceList.size() > 0) {\n+            logger.debug(\"getDiscoveredProperties(): Unknown UDN: {}\", udn);\n+        }\n+        return null;\n+    }\n+\n+    public void setNotifyServletStatus(boolean newStatus) {\n+        logger.debug(\"NotifyServlet started\");\n+        servletInitialized = newStatus;\n+    }\n+\n+    public boolean getNotifyServletStatus() {\n+        return servletInitialized;\n+    }\n+\n+    /**\n+     * We received the pairing resuled (by the Norify servlet)\n+     *\n+     * @param notifyDeviceId The unique device id pairing was initiated for\n+     * @param pairingCode Pairng code computed by the receiver", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMwOTYzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484309638", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-07T09:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzQwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484117408", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Send a Waker-on-LAN packet\n          \n          \n            \n                 * Send a Wake-on-LAN packet", "author": "kaikreuzer", "createdAt": "2020-09-06T21:46:37Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/network/MagentaTVNetwork.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.network;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVNetwork} supplies network functions.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVNetwork {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVNetwork.class);\n+\n+    private String localIP = \"\";\n+    private String localPort = \"\";\n+    private String localMAC = \"\";\n+    private @Nullable NetworkInterface localInterface;\n+\n+    /**\n+     * Init local network interface, determine local IP and MAC address\n+     *\n+     * @param networkAddressService\n+     * @return\n+     */\n+    public void initLocalNet(String localIP, String localPort) throws MagentaTVException {\n+        try {\n+            if (localIP.isEmpty() || localIP.equals(\"0.0.0.0\") || localIP.equals(\"127.0.0.1\")) {\n+                throw new MagentaTVException(\"Unable to detect local IP address!\");\n+            }\n+            this.localPort = localPort;\n+            this.localIP = localIP;\n+\n+            // get MAC address\n+            InetAddress ip = InetAddress.getByName(localIP);\n+            localInterface = NetworkInterface.getByInetAddress(ip);\n+            if (localInterface != null) {\n+                byte[] mac = localInterface.getHardwareAddress();\n+                StringBuilder sb = new StringBuilder();\n+                for (int i = 0; i < mac.length; i++) {\n+                    sb.append(String.format(\"%02X%s\", mac[i], (i < mac.length - 1) ? \":\" : \"\"));\n+                }\n+                localMAC = sb.toString().toUpperCase();\n+                logger.debug(\"Local IP address={}, Local MAC address = {}\", localIP, localMAC);\n+                return;\n+            }\n+        } catch (UnknownHostException | SocketException e) {\n+            throw new MagentaTVException(e);\n+        }\n+\n+        throw new MagentaTVException(\n+                \"Unable to get local IP / MAC address, check network settings in openHAB system configuration!\");\n+    }\n+\n+    /**\n+     * Checks if client ip equals or is in range of ip networks provided by\n+     * semicolon separated list\n+     *\n+     * @param clientIp in numeric form like \"192.168.0.10\"\n+     * @param ipList like \"127.0.0.1;192.168.0.0/24;10.0.0.0/8\"\n+     * @return true if client ip from the list os ips and networks\n+     */\n+    public static boolean isIpInSubnet(String clientIp, String ipList) {\n+        if (ipList.isEmpty()) {\n+            // No ip address provided\n+            return true;\n+        }\n+        String[] subnetMasks = ipList.split(\";\");\n+        for (String subnetMask : subnetMasks) {\n+            subnetMask = subnetMask.trim();\n+            if (clientIp.equals(subnetMask)) {\n+                return true;\n+            }\n+            if (subnetMask.contains(\"/\")) {\n+                if (new SubnetUtils(subnetMask).getInfo().isInRange(clientIp)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Nullable\n+    public NetworkInterface getLocalInterface() {\n+        return localInterface;\n+    }\n+\n+    public String getLocalIP() {\n+        return localIP;\n+    }\n+\n+    public String getLocalPort() {\n+        return localPort;\n+    }\n+\n+    public String getLocalMAC() {\n+        return localMAC;\n+    }\n+\n+    public static final int WOL_PORT = 9;\n+\n+    /**\n+     * Send a Waker-on-LAN packet", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxMDA4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484310083", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-07T09:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484117466", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.info(\"Servlet started at {}\", PAIRING_NOTIFY_URI);\n          \n          \n            \n                        logger.debug(\"Servlet started at {}\", PAIRING_NOTIFY_URI);", "author": "kaikreuzer", "createdAt": "2020-09-06T21:47:27Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/network/MagentaTVNotifyServlet.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.network;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.substringBetween;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Scanner;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Main OSGi service and HTTP servlet for MagentaTV NOTIFY.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HttpServlet.class, configurationPolicy = ConfigurationPolicy.OPTIONAL, immediate = true)\n+public class MagentaTVNotifyServlet extends HttpServlet {\n+    private static final long serialVersionUID = 2119809008606371618L;\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVNotifyServlet.class);\n+\n+    private final MagentaTVHandlerFactory handlerFactory;\n+\n+    @Activate\n+    public MagentaTVNotifyServlet(@Reference MagentaTVHandlerFactory handlerFactory, @Reference HttpService httpService,\n+            Map<String, Object> config) {\n+        this.handlerFactory = handlerFactory;\n+        try {\n+            httpService.registerServlet(PAIRING_NOTIFY_URI, this, null, httpService.createDefaultHttpContext());\n+            logger.info(\"Servlet started at {}\", PAIRING_NOTIFY_URI);", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxMDY0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484310648", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-07T09:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExNzQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODAzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484118030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * - perform Oath if userID is not configured and credentials are available\n          \n          \n            \n                 * - perform OAuth if userId is not configured and credentials are available", "author": "kaikreuzer", "createdAt": "2020-09-06T21:54:04Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxMTM3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484311370", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-07T09:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODE5Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484118192", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"{}: Authenticate account {}\", thingId, account);\n          \n          \n            \n                            logger.debug(\"{}: Authenticate account {}\", thingId, account);", "author": "kaikreuzer", "createdAt": "2020-09-06T21:55:29Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNDEwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484314103", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-07T09:35:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODMyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484118321", "bodyText": "Could you rename this to getUserId to be in-line with all other references?", "author": "kaikreuzer", "createdAt": "2020-09-06T21:57:10Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/config/MagentaTVThingConfiguration.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link MagentaTVThingConfiguration} contains the thing config (updated at\n+ * runtime).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVThingConfiguration {\n+    public String ipAddress = \"\"; // IP Address of the MR\n+    public String port = \"\"; // Port of the remote service\n+    public String udn = \"\"; // UPnP UDN\n+    public String macAddress = \"\"; // Usually gets filled by the thing discovery (or set by .things file)\n+    public String accountName = \"\"; // Credentials: Account Name from Telekom Kundencenter (used for OAuth)\n+    public String accountPassword = \"\"; // Credentials: Account Password from Telekom Kundencenter (used for OAuth)\n+    public String userId = \"\"; // userId required for pairing (can be configured manually or gets auto-filled by the\n+                               // binding on successful OAuth. Value is persisted so OAuth nedds only to be redone when\n+                               // credentials change.\n+\n+    public void update(MagentaTVThingConfiguration newConfig) {\n+        ipAddress = newConfig.ipAddress;\n+        port = newConfig.port;\n+        udn = newConfig.udn;\n+        macAddress = newConfig.macAddress;\n+        accountName = newConfig.accountName;\n+        accountPassword = newConfig.accountPassword;\n+        userId = newConfig.userId;\n+    }\n+\n+    public String getUDN() {\n+        return udn.toUpperCase();\n+    }\n+\n+    public void setUDN(String udn) {\n+        this.udn = udn;\n+    }\n+\n+    public String getIpAddress() {\n+        return ipAddress;\n+    }\n+\n+    public String getMacAddress() {\n+        return macAddress;\n+    }\n+\n+    public void setMacAddress(String macAddress) {\n+        this.macAddress = macAddress.toUpperCase();\n+    }\n+\n+    public String getAccountName() {\n+        return accountName;\n+    }\n+\n+    public void setAccountName(String accountName) {\n+        this.accountName = accountName;\n+    }\n+\n+    public String getAccountPassword() {\n+        return accountPassword;\n+    }\n+\n+    public void setAccountPassword(String accountPassword) {\n+        this.accountPassword = accountPassword;\n+    }\n+\n+    public String getUserID() {", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNDI0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484314248", "bodyText": "done", "author": "markus7017", "createdAt": "2020-09-07T09:35:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODMzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484118330", "bodyText": "Could you rename this to setUserId to be in-line with all other references?", "author": "kaikreuzer", "createdAt": "2020-09-06T21:57:20Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/config/MagentaTVThingConfiguration.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.config;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link MagentaTVThingConfiguration} contains the thing config (updated at\n+ * runtime).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVThingConfiguration {\n+    public String ipAddress = \"\"; // IP Address of the MR\n+    public String port = \"\"; // Port of the remote service\n+    public String udn = \"\"; // UPnP UDN\n+    public String macAddress = \"\"; // Usually gets filled by the thing discovery (or set by .things file)\n+    public String accountName = \"\"; // Credentials: Account Name from Telekom Kundencenter (used for OAuth)\n+    public String accountPassword = \"\"; // Credentials: Account Password from Telekom Kundencenter (used for OAuth)\n+    public String userId = \"\"; // userId required for pairing (can be configured manually or gets auto-filled by the\n+                               // binding on successful OAuth. Value is persisted so OAuth nedds only to be redone when\n+                               // credentials change.\n+\n+    public void update(MagentaTVThingConfiguration newConfig) {\n+        ipAddress = newConfig.ipAddress;\n+        port = newConfig.port;\n+        udn = newConfig.udn;\n+        macAddress = newConfig.macAddress;\n+        accountName = newConfig.accountName;\n+        accountPassword = newConfig.accountPassword;\n+        userId = newConfig.userId;\n+    }\n+\n+    public String getUDN() {\n+        return udn.toUpperCase();\n+    }\n+\n+    public void setUDN(String udn) {\n+        this.udn = udn;\n+    }\n+\n+    public String getIpAddress() {\n+        return ipAddress;\n+    }\n+\n+    public String getMacAddress() {\n+        return macAddress;\n+    }\n+\n+    public void setMacAddress(String macAddress) {\n+        this.macAddress = macAddress.toUpperCase();\n+    }\n+\n+    public String getAccountName() {\n+        return accountName;\n+    }\n+\n+    public void setAccountName(String accountName) {\n+        this.accountName = accountName;\n+    }\n+\n+    public String getAccountPassword() {\n+        return accountPassword;\n+    }\n+\n+    public void setAccountPassword(String accountPassword) {\n+        this.accountPassword = accountPassword;\n+    }\n+\n+    public String getUserID() {\n+        return userId;\n+    }\n+\n+    public void setUserID(String userId) {", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyNDM2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484324369", "bodyText": "done", "author": "markus7017", "createdAt": "2020-09-07T09:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODQzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484118430", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n          \n          \n            \n                            @Override\n          \n          \n            \n                            public void run() {\n          \n          \n            \n                                renewEventSubscription();\n          \n          \n            \n                            }\n          \n          \n            \n                        }, 2, 5, TimeUnit.MINUTES);\n          \n          \n            \n                        renewEventJob = scheduler.scheduleWithFixedDelay(() -> {\n          \n          \n            \n                                renewEventSubscription();\n          \n          \n            \n                        }, 2, 5, TimeUnit.MINUTES);", "author": "kaikreuzer", "createdAt": "2020-09-06T21:58:34Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);\n+                authenticateUser();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyNzkzMg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484327932", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-07T09:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODQ5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484118496", "bodyText": "can this be removed?", "author": "kaikreuzer", "createdAt": "2020-09-06T21:59:24Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);\n+                authenticateUser();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserID(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+\n+        // initializeThing();", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0NjgxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484346818", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-09-07T10:35:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODY1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484118653", "bodyText": "Can this be potentially long-running, e.g. when running in a timeout? The handleCommand method must not take more than 5 seconds to return.", "author": "kaikreuzer", "createdAt": "2020-09-06T22:00:53Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);\n+                authenticateUser();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserID(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+\n+        // initializeThing();\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMyODU1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484328551", "bodyText": "No, this is an asynchronous process, all good", "author": "markus7017", "createdAt": "2020-09-07T10:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1MjU2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484552561", "bodyText": "I am not convinced yet. The connectReceiver() method calls subscribeEventChannel() synchronously, which does a synchronous http.sendData(...)call.", "author": "kaikreuzer", "createdAt": "2020-09-07T19:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExODY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExOTA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484119069", "bodyText": "A handler must not get the handler factory injected - the dependency is only the other way round (the factory keeps track of its handlers).\nPlease check if you can refactor the code to cleanly decouple the classes. If required, you can think about introducing a \"Callback\" interface, which is passed in and which could be implemented by the factory, if there's no way around it.", "author": "kaikreuzer", "createdAt": "2020-09-06T22:05:58Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4ODQxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484488415", "bodyText": "I created a new service MagentaTVDeviceManager, review the change and let me know if that is ok", "author": "markus7017", "createdAt": "2020-09-07T15:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExOTA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1Mzk4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484553989", "bodyText": "Looks ok to me, thanks!", "author": "kaikreuzer", "createdAt": "2020-09-07T19:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExOTA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExOTE2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484119163", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"{}: Skip OAuth, use existing userID {}\", thingId, config.getUserID());\n          \n          \n            \n                        logger.debug(\"{}: Skip OAuth, use existing userId {}\", thingId, config.getUserID());", "author": "kaikreuzer", "createdAt": "2020-09-06T22:07:10Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);\n+                authenticateUser();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserID(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+\n+        // initializeThing();\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails\n+            }\n+\n+            logger.debug(\"{}: Channel command for device {}: {} for channel {}\", thingId, config.getFriendlyName(),\n+                    command, channelUID.getId());\n+            switch (channelUID.getId()) {\n+                case CHANNEL_POWER: // toggle power\n+                    logger.debug(\"{}: Toggle power, new state={}\", thingId, command);\n+                    control.sendKey(\"POWER\");\n+                    break;\n+                case CHANNEL_PLAYER:\n+                    logger.debug(\"{}: Player command: {}\", thingId, command);\n+                    if (command instanceof OnOffType) {\n+                        control.sendKey(\"POWER\");\n+                    } else if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            control.sendKey(\"PLAY\");\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            control.sendKey(\"PAUSE\");\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            control.sendKey(\"NEXTCH\");\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            control.sendKey(\"PREVCH\");\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                        if (command == RewindFastforwardType.FASTFORWARD) {\n+                            control.sendKey(\"FORWARD\");\n+                        } else if (command == RewindFastforwardType.REWIND) {\n+                            control.sendKey(\"REWIND\");\n+                        }\n+                    } else {\n+                        logger.debug(\"{}: Unknown media command: {}\", thingId, command);\n+                    }\n+                    break;\n+                case CHANNEL_CHANNEL:\n+                    String chan = command.toString();\n+                    control.selectChannel(chan);\n+                    break;\n+                case CHANNEL_MUTE:\n+                    if (command == OnOffType.ON) {\n+                        control.sendKey(\"MUTE\");\n+                    } else {\n+                        control.sendKey(\"VOLUP\");\n+                    }\n+                    break;\n+                case CHANNEL_KEY:\n+                    if (command.toString().equalsIgnoreCase(\"PAIR\")) { // special key to re-pair receiver (already done\n+                                                                       // above)\n+                        logger.debug(\"{}: PAIRing key received, reconnect receiver {}\", thingId, deviceName());\n+                    } else {\n+                        control.sendKey(command.toString());\n+                        mapKeyToMediateState(command.toString());\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"{}: Command {} for unknown channel {}\", thingId, command, channelUID.getAsString());\n+            }\n+        } catch (MagentaTVException e) {\n+            String errorMessage = MessageFormat.format(\"Channel operation failed (command={0}, value={1}): {2}\",\n+                    command, channelUID.getId(), e.toString());\n+            logger.debug(\"{}: {}\", thingId, errorMessage);\n+            setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+        }\n+    }\n+\n+    private void mapKeyToMediateState(String key) {\n+        State state = null;\n+        switch (key.toUpperCase()) {\n+            case \"PLAY\":\n+                state = PlayPauseType.PLAY;\n+                break;\n+            case \"PAUSE\":\n+                state = PlayPauseType.PAUSE;\n+                break;\n+            case \"FORWARD\":\n+                state = RewindFastforwardType.FASTFORWARD;\n+                break;\n+            case \"REWIND\":\n+                updateState(CHANNEL_PLAYER, RewindFastforwardType.REWIND);\n+                break;\n+        }\n+        if (state != null) {\n+            logger.debug(\"{}: Setting Player state to {}\", thingId, state);\n+            updateState(CHANNEL_PLAYER, state);\n+        }\n+    }\n+\n+    /**\n+     * Connect to the receiver\n+     *\n+     * @throws MagentaTVException something failed\n+     */\n+    protected void connectReceiver() throws MagentaTVException {\n+        if (control.checkDev()) {\n+            updateThingProperties();\n+            handlerFactory.registerDevice(config.getUDN(), config.getTerminalID(), config.getIpAddress(), this);\n+            control.subscribeEventChannel();\n+            control.sendPairingRequest();\n+\n+            // check for pairing timeout\n+            final int iRefresh = ++idRefresh;\n+            pairingWatchdogJob = scheduler.schedule(() -> {\n+                if (iRefresh == idRefresh) { // Make a best effort to not run multiple deferred refresh\n+                    if (config.getVerificationCode().isEmpty()) {\n+                        setOnlineState(ThingStatus.OFFLINE, \"Timeout on pairing request!\");\n+                    }\n+                }\n+            }, 15, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * If userID is empty and credentials are given the Telekom OAuth service is\n+     * used to query the userID\n+     *\n+     * @throws MagentaTVException\n+     */\n+    private void authenticateUser() throws MagentaTVException {\n+        String userId = config.getUserID();\n+        if (userId.isEmpty()) {\n+            // run OAuth authentication, this finally provides the userID\n+            userId = control.authenticateUser(config.getAccountName(), config.getAccountPassword());\n+\n+            // Update thing configuration (persistent) - remove credentials, add userID\n+            Configuration configuration = this.getConfig();\n+            configuration.remove(PROPERTY_ACCT_NAME);\n+            configuration.remove(PROPERTY_ACCT_PWD);\n+            configuration.remove(PROPERTY_USERID);\n+            configuration.put(PROPERTY_ACCT_NAME, \"\");\n+            configuration.put(PROPERTY_ACCT_PWD, \"\");\n+            configuration.put(PROPERTY_USERID, userId);\n+            this.updateConfiguration(configuration);\n+            config.setAccountName(\"\");\n+            config.setAccountPassword(\"\");\n+        } else {\n+            logger.debug(\"{}: Skip OAuth, use existing userID {}\", thingId, config.getUserID());", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMzMDQ0Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484330442", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-07T10:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExOTE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExOTI0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484119240", "bodyText": "Shouldn't this be called setOnlineStatus?", "author": "kaikreuzer", "createdAt": "2020-09-06T22:07:57Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);\n+                authenticateUser();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserID(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+\n+        // initializeThing();\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails\n+            }\n+\n+            logger.debug(\"{}: Channel command for device {}: {} for channel {}\", thingId, config.getFriendlyName(),\n+                    command, channelUID.getId());\n+            switch (channelUID.getId()) {\n+                case CHANNEL_POWER: // toggle power\n+                    logger.debug(\"{}: Toggle power, new state={}\", thingId, command);\n+                    control.sendKey(\"POWER\");\n+                    break;\n+                case CHANNEL_PLAYER:\n+                    logger.debug(\"{}: Player command: {}\", thingId, command);\n+                    if (command instanceof OnOffType) {\n+                        control.sendKey(\"POWER\");\n+                    } else if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            control.sendKey(\"PLAY\");\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            control.sendKey(\"PAUSE\");\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            control.sendKey(\"NEXTCH\");\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            control.sendKey(\"PREVCH\");\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                        if (command == RewindFastforwardType.FASTFORWARD) {\n+                            control.sendKey(\"FORWARD\");\n+                        } else if (command == RewindFastforwardType.REWIND) {\n+                            control.sendKey(\"REWIND\");\n+                        }\n+                    } else {\n+                        logger.debug(\"{}: Unknown media command: {}\", thingId, command);\n+                    }\n+                    break;\n+                case CHANNEL_CHANNEL:\n+                    String chan = command.toString();\n+                    control.selectChannel(chan);\n+                    break;\n+                case CHANNEL_MUTE:\n+                    if (command == OnOffType.ON) {\n+                        control.sendKey(\"MUTE\");\n+                    } else {\n+                        control.sendKey(\"VOLUP\");\n+                    }\n+                    break;\n+                case CHANNEL_KEY:\n+                    if (command.toString().equalsIgnoreCase(\"PAIR\")) { // special key to re-pair receiver (already done\n+                                                                       // above)\n+                        logger.debug(\"{}: PAIRing key received, reconnect receiver {}\", thingId, deviceName());\n+                    } else {\n+                        control.sendKey(command.toString());\n+                        mapKeyToMediateState(command.toString());\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"{}: Command {} for unknown channel {}\", thingId, command, channelUID.getAsString());\n+            }\n+        } catch (MagentaTVException e) {\n+            String errorMessage = MessageFormat.format(\"Channel operation failed (command={0}, value={1}): {2}\",\n+                    command, channelUID.getId(), e.toString());\n+            logger.debug(\"{}: {}\", thingId, errorMessage);\n+            setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+        }\n+    }\n+\n+    private void mapKeyToMediateState(String key) {\n+        State state = null;\n+        switch (key.toUpperCase()) {\n+            case \"PLAY\":\n+                state = PlayPauseType.PLAY;\n+                break;\n+            case \"PAUSE\":\n+                state = PlayPauseType.PAUSE;\n+                break;\n+            case \"FORWARD\":\n+                state = RewindFastforwardType.FASTFORWARD;\n+                break;\n+            case \"REWIND\":\n+                updateState(CHANNEL_PLAYER, RewindFastforwardType.REWIND);\n+                break;\n+        }\n+        if (state != null) {\n+            logger.debug(\"{}: Setting Player state to {}\", thingId, state);\n+            updateState(CHANNEL_PLAYER, state);\n+        }\n+    }\n+\n+    /**\n+     * Connect to the receiver\n+     *\n+     * @throws MagentaTVException something failed\n+     */\n+    protected void connectReceiver() throws MagentaTVException {\n+        if (control.checkDev()) {\n+            updateThingProperties();\n+            handlerFactory.registerDevice(config.getUDN(), config.getTerminalID(), config.getIpAddress(), this);\n+            control.subscribeEventChannel();\n+            control.sendPairingRequest();\n+\n+            // check for pairing timeout\n+            final int iRefresh = ++idRefresh;\n+            pairingWatchdogJob = scheduler.schedule(() -> {\n+                if (iRefresh == idRefresh) { // Make a best effort to not run multiple deferred refresh\n+                    if (config.getVerificationCode().isEmpty()) {\n+                        setOnlineState(ThingStatus.OFFLINE, \"Timeout on pairing request!\");\n+                    }\n+                }\n+            }, 15, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * If userID is empty and credentials are given the Telekom OAuth service is\n+     * used to query the userID\n+     *\n+     * @throws MagentaTVException\n+     */\n+    private void authenticateUser() throws MagentaTVException {\n+        String userId = config.getUserID();\n+        if (userId.isEmpty()) {\n+            // run OAuth authentication, this finally provides the userID\n+            userId = control.authenticateUser(config.getAccountName(), config.getAccountPassword());\n+\n+            // Update thing configuration (persistent) - remove credentials, add userID\n+            Configuration configuration = this.getConfig();\n+            configuration.remove(PROPERTY_ACCT_NAME);\n+            configuration.remove(PROPERTY_ACCT_PWD);\n+            configuration.remove(PROPERTY_USERID);\n+            configuration.put(PROPERTY_ACCT_NAME, \"\");\n+            configuration.put(PROPERTY_ACCT_PWD, \"\");\n+            configuration.put(PROPERTY_USERID, userId);\n+            this.updateConfiguration(configuration);\n+            config.setAccountName(\"\");\n+            config.setAccountPassword(\"\");\n+        } else {\n+            logger.debug(\"{}: Skip OAuth, use existing userID {}\", thingId, config.getUserID());\n+        }\n+        if (!userId.isEmpty()) {\n+            config.setUserID(userId);\n+        } else {\n+            logger.warn(\"{}: Unable to obtain userId from OAuth\", thingId);\n+        }\n+    }\n+\n+    /**\n+     * Update thing status\n+     *\n+     * @param mode new thing status\n+     * @return ON = power on, OFF=power off\n+     */\n+    public void setOnlineState(ThingStatus newStatus, String errorMessage) {", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0NjUyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484346524", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-07T10:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExOTI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExOTkzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484119936", "bodyText": "This looks weird to me. If \"Standby\" mode is selected, I would assume that the handler can be online (i.e. it is able to reach the receiver), while the power state is still OFF (i.e. it is in standby). Am I missing something?", "author": "kaikreuzer", "createdAt": "2020-09-06T22:15:16Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);\n+                authenticateUser();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserID(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+\n+        // initializeThing();\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails\n+            }\n+\n+            logger.debug(\"{}: Channel command for device {}: {} for channel {}\", thingId, config.getFriendlyName(),\n+                    command, channelUID.getId());\n+            switch (channelUID.getId()) {\n+                case CHANNEL_POWER: // toggle power\n+                    logger.debug(\"{}: Toggle power, new state={}\", thingId, command);\n+                    control.sendKey(\"POWER\");\n+                    break;\n+                case CHANNEL_PLAYER:\n+                    logger.debug(\"{}: Player command: {}\", thingId, command);\n+                    if (command instanceof OnOffType) {\n+                        control.sendKey(\"POWER\");\n+                    } else if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            control.sendKey(\"PLAY\");\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            control.sendKey(\"PAUSE\");\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            control.sendKey(\"NEXTCH\");\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            control.sendKey(\"PREVCH\");\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                        if (command == RewindFastforwardType.FASTFORWARD) {\n+                            control.sendKey(\"FORWARD\");\n+                        } else if (command == RewindFastforwardType.REWIND) {\n+                            control.sendKey(\"REWIND\");\n+                        }\n+                    } else {\n+                        logger.debug(\"{}: Unknown media command: {}\", thingId, command);\n+                    }\n+                    break;\n+                case CHANNEL_CHANNEL:\n+                    String chan = command.toString();\n+                    control.selectChannel(chan);\n+                    break;\n+                case CHANNEL_MUTE:\n+                    if (command == OnOffType.ON) {\n+                        control.sendKey(\"MUTE\");\n+                    } else {\n+                        control.sendKey(\"VOLUP\");\n+                    }\n+                    break;\n+                case CHANNEL_KEY:\n+                    if (command.toString().equalsIgnoreCase(\"PAIR\")) { // special key to re-pair receiver (already done\n+                                                                       // above)\n+                        logger.debug(\"{}: PAIRing key received, reconnect receiver {}\", thingId, deviceName());\n+                    } else {\n+                        control.sendKey(command.toString());\n+                        mapKeyToMediateState(command.toString());\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"{}: Command {} for unknown channel {}\", thingId, command, channelUID.getAsString());\n+            }\n+        } catch (MagentaTVException e) {\n+            String errorMessage = MessageFormat.format(\"Channel operation failed (command={0}, value={1}): {2}\",\n+                    command, channelUID.getId(), e.toString());\n+            logger.debug(\"{}: {}\", thingId, errorMessage);\n+            setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+        }\n+    }\n+\n+    private void mapKeyToMediateState(String key) {\n+        State state = null;\n+        switch (key.toUpperCase()) {\n+            case \"PLAY\":\n+                state = PlayPauseType.PLAY;\n+                break;\n+            case \"PAUSE\":\n+                state = PlayPauseType.PAUSE;\n+                break;\n+            case \"FORWARD\":\n+                state = RewindFastforwardType.FASTFORWARD;\n+                break;\n+            case \"REWIND\":\n+                updateState(CHANNEL_PLAYER, RewindFastforwardType.REWIND);\n+                break;\n+        }\n+        if (state != null) {\n+            logger.debug(\"{}: Setting Player state to {}\", thingId, state);\n+            updateState(CHANNEL_PLAYER, state);\n+        }\n+    }\n+\n+    /**\n+     * Connect to the receiver\n+     *\n+     * @throws MagentaTVException something failed\n+     */\n+    protected void connectReceiver() throws MagentaTVException {\n+        if (control.checkDev()) {\n+            updateThingProperties();\n+            handlerFactory.registerDevice(config.getUDN(), config.getTerminalID(), config.getIpAddress(), this);\n+            control.subscribeEventChannel();\n+            control.sendPairingRequest();\n+\n+            // check for pairing timeout\n+            final int iRefresh = ++idRefresh;\n+            pairingWatchdogJob = scheduler.schedule(() -> {\n+                if (iRefresh == idRefresh) { // Make a best effort to not run multiple deferred refresh\n+                    if (config.getVerificationCode().isEmpty()) {\n+                        setOnlineState(ThingStatus.OFFLINE, \"Timeout on pairing request!\");\n+                    }\n+                }\n+            }, 15, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * If userID is empty and credentials are given the Telekom OAuth service is\n+     * used to query the userID\n+     *\n+     * @throws MagentaTVException\n+     */\n+    private void authenticateUser() throws MagentaTVException {\n+        String userId = config.getUserID();\n+        if (userId.isEmpty()) {\n+            // run OAuth authentication, this finally provides the userID\n+            userId = control.authenticateUser(config.getAccountName(), config.getAccountPassword());\n+\n+            // Update thing configuration (persistent) - remove credentials, add userID\n+            Configuration configuration = this.getConfig();\n+            configuration.remove(PROPERTY_ACCT_NAME);\n+            configuration.remove(PROPERTY_ACCT_PWD);\n+            configuration.remove(PROPERTY_USERID);\n+            configuration.put(PROPERTY_ACCT_NAME, \"\");\n+            configuration.put(PROPERTY_ACCT_PWD, \"\");\n+            configuration.put(PROPERTY_USERID, userId);\n+            this.updateConfiguration(configuration);\n+            config.setAccountName(\"\");\n+            config.setAccountPassword(\"\");\n+        } else {\n+            logger.debug(\"{}: Skip OAuth, use existing userID {}\", thingId, config.getUserID());\n+        }\n+        if (!userId.isEmpty()) {\n+            config.setUserID(userId);\n+        } else {\n+            logger.warn(\"{}: Unable to obtain userId from OAuth\", thingId);\n+        }\n+    }\n+\n+    /**\n+     * Update thing status\n+     *\n+     * @param mode new thing status\n+     * @return ON = power on, OFF=power off\n+     */\n+    public void setOnlineState(ThingStatus newStatus, String errorMessage) {\n+        ThingStatus status = this.getThing().getStatus();\n+        if (status != newStatus) {\n+            if (newStatus == ThingStatus.ONLINE) {\n+                updateStatus(newStatus);\n+                updateState(CHANNEL_POWER, OnOffType.ON);", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0NTUwMw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484345503", "bodyText": "The MR400 doesn't send the SSDN message, so in most cases the receiver is off when communication breaks down (usually the receiver is connected with ethernet). I spend a lot of time trying to get a better status handling and this was the outcome. Maybe not perfect, but works on a daily basis pretty well.", "author": "markus7017", "createdAt": "2020-09-07T10:32:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDExOTkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDE2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484120169", "bodyText": "This should not be set here - if communication breaks down, it does not automatically mean that the receiver has been switched off.", "author": "kaikreuzer", "createdAt": "2020-09-06T22:17:56Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);\n+                authenticateUser();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserID(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+\n+        // initializeThing();\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails\n+            }\n+\n+            logger.debug(\"{}: Channel command for device {}: {} for channel {}\", thingId, config.getFriendlyName(),\n+                    command, channelUID.getId());\n+            switch (channelUID.getId()) {\n+                case CHANNEL_POWER: // toggle power\n+                    logger.debug(\"{}: Toggle power, new state={}\", thingId, command);\n+                    control.sendKey(\"POWER\");\n+                    break;\n+                case CHANNEL_PLAYER:\n+                    logger.debug(\"{}: Player command: {}\", thingId, command);\n+                    if (command instanceof OnOffType) {\n+                        control.sendKey(\"POWER\");\n+                    } else if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            control.sendKey(\"PLAY\");\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            control.sendKey(\"PAUSE\");\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            control.sendKey(\"NEXTCH\");\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            control.sendKey(\"PREVCH\");\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                        if (command == RewindFastforwardType.FASTFORWARD) {\n+                            control.sendKey(\"FORWARD\");\n+                        } else if (command == RewindFastforwardType.REWIND) {\n+                            control.sendKey(\"REWIND\");\n+                        }\n+                    } else {\n+                        logger.debug(\"{}: Unknown media command: {}\", thingId, command);\n+                    }\n+                    break;\n+                case CHANNEL_CHANNEL:\n+                    String chan = command.toString();\n+                    control.selectChannel(chan);\n+                    break;\n+                case CHANNEL_MUTE:\n+                    if (command == OnOffType.ON) {\n+                        control.sendKey(\"MUTE\");\n+                    } else {\n+                        control.sendKey(\"VOLUP\");\n+                    }\n+                    break;\n+                case CHANNEL_KEY:\n+                    if (command.toString().equalsIgnoreCase(\"PAIR\")) { // special key to re-pair receiver (already done\n+                                                                       // above)\n+                        logger.debug(\"{}: PAIRing key received, reconnect receiver {}\", thingId, deviceName());\n+                    } else {\n+                        control.sendKey(command.toString());\n+                        mapKeyToMediateState(command.toString());\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"{}: Command {} for unknown channel {}\", thingId, command, channelUID.getAsString());\n+            }\n+        } catch (MagentaTVException e) {\n+            String errorMessage = MessageFormat.format(\"Channel operation failed (command={0}, value={1}): {2}\",\n+                    command, channelUID.getId(), e.toString());\n+            logger.debug(\"{}: {}\", thingId, errorMessage);\n+            setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+        }\n+    }\n+\n+    private void mapKeyToMediateState(String key) {\n+        State state = null;\n+        switch (key.toUpperCase()) {\n+            case \"PLAY\":\n+                state = PlayPauseType.PLAY;\n+                break;\n+            case \"PAUSE\":\n+                state = PlayPauseType.PAUSE;\n+                break;\n+            case \"FORWARD\":\n+                state = RewindFastforwardType.FASTFORWARD;\n+                break;\n+            case \"REWIND\":\n+                updateState(CHANNEL_PLAYER, RewindFastforwardType.REWIND);\n+                break;\n+        }\n+        if (state != null) {\n+            logger.debug(\"{}: Setting Player state to {}\", thingId, state);\n+            updateState(CHANNEL_PLAYER, state);\n+        }\n+    }\n+\n+    /**\n+     * Connect to the receiver\n+     *\n+     * @throws MagentaTVException something failed\n+     */\n+    protected void connectReceiver() throws MagentaTVException {\n+        if (control.checkDev()) {\n+            updateThingProperties();\n+            handlerFactory.registerDevice(config.getUDN(), config.getTerminalID(), config.getIpAddress(), this);\n+            control.subscribeEventChannel();\n+            control.sendPairingRequest();\n+\n+            // check for pairing timeout\n+            final int iRefresh = ++idRefresh;\n+            pairingWatchdogJob = scheduler.schedule(() -> {\n+                if (iRefresh == idRefresh) { // Make a best effort to not run multiple deferred refresh\n+                    if (config.getVerificationCode().isEmpty()) {\n+                        setOnlineState(ThingStatus.OFFLINE, \"Timeout on pairing request!\");\n+                    }\n+                }\n+            }, 15, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * If userID is empty and credentials are given the Telekom OAuth service is\n+     * used to query the userID\n+     *\n+     * @throws MagentaTVException\n+     */\n+    private void authenticateUser() throws MagentaTVException {\n+        String userId = config.getUserID();\n+        if (userId.isEmpty()) {\n+            // run OAuth authentication, this finally provides the userID\n+            userId = control.authenticateUser(config.getAccountName(), config.getAccountPassword());\n+\n+            // Update thing configuration (persistent) - remove credentials, add userID\n+            Configuration configuration = this.getConfig();\n+            configuration.remove(PROPERTY_ACCT_NAME);\n+            configuration.remove(PROPERTY_ACCT_PWD);\n+            configuration.remove(PROPERTY_USERID);\n+            configuration.put(PROPERTY_ACCT_NAME, \"\");\n+            configuration.put(PROPERTY_ACCT_PWD, \"\");\n+            configuration.put(PROPERTY_USERID, userId);\n+            this.updateConfiguration(configuration);\n+            config.setAccountName(\"\");\n+            config.setAccountPassword(\"\");\n+        } else {\n+            logger.debug(\"{}: Skip OAuth, use existing userID {}\", thingId, config.getUserID());\n+        }\n+        if (!userId.isEmpty()) {\n+            config.setUserID(userId);\n+        } else {\n+            logger.warn(\"{}: Unable to obtain userId from OAuth\", thingId);\n+        }\n+    }\n+\n+    /**\n+     * Update thing status\n+     *\n+     * @param mode new thing status\n+     * @return ON = power on, OFF=power off\n+     */\n+    public void setOnlineState(ThingStatus newStatus, String errorMessage) {\n+        ThingStatus status = this.getThing().getStatus();\n+        if (status != newStatus) {\n+            if (newStatus == ThingStatus.ONLINE) {\n+                updateStatus(newStatus);\n+                updateState(CHANNEL_POWER, OnOffType.ON);\n+            } else {\n+                if (!errorMessage.isEmpty()) {\n+                    logger.debug(\"{}: Communication Error - {}, switch Thing offline\", thingId, errorMessage);\n+                    updateStatus(newStatus, ThingStatusDetail.COMMUNICATION_ERROR, errorMessage);\n+                } else {\n+                    updateStatus(newStatus);\n+                }\n+                updateState(CHANNEL_POWER, OnOffType.OFF);", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMzNjE1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484336155", "bodyText": "The MR400 doesn't send the SSDN message, so in most cases the receiver is off when communication breaks down (usually the receiver is connected with ethernet). I spend a lot of time trying to get a better status handling and this was the outcome. Maybe not perfect, but works on a daily basis pretty well.", "author": "markus7017", "createdAt": "2020-09-07T10:14:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1MjkwNw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484552907", "bodyText": "Well, let's keep it that way as an unusual exception, but don't tell anyone ;-)", "author": "kaikreuzer", "createdAt": "2020-09-07T19:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDI1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484120253", "bodyText": "here's a good moment to set the power state to ON.", "author": "kaikreuzer", "createdAt": "2020-09-06T22:19:19Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);\n+                authenticateUser();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserID(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+\n+        // initializeThing();\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails\n+            }\n+\n+            logger.debug(\"{}: Channel command for device {}: {} for channel {}\", thingId, config.getFriendlyName(),\n+                    command, channelUID.getId());\n+            switch (channelUID.getId()) {\n+                case CHANNEL_POWER: // toggle power\n+                    logger.debug(\"{}: Toggle power, new state={}\", thingId, command);\n+                    control.sendKey(\"POWER\");\n+                    break;\n+                case CHANNEL_PLAYER:\n+                    logger.debug(\"{}: Player command: {}\", thingId, command);\n+                    if (command instanceof OnOffType) {\n+                        control.sendKey(\"POWER\");\n+                    } else if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            control.sendKey(\"PLAY\");\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            control.sendKey(\"PAUSE\");\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            control.sendKey(\"NEXTCH\");\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            control.sendKey(\"PREVCH\");\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                        if (command == RewindFastforwardType.FASTFORWARD) {\n+                            control.sendKey(\"FORWARD\");\n+                        } else if (command == RewindFastforwardType.REWIND) {\n+                            control.sendKey(\"REWIND\");\n+                        }\n+                    } else {\n+                        logger.debug(\"{}: Unknown media command: {}\", thingId, command);\n+                    }\n+                    break;\n+                case CHANNEL_CHANNEL:\n+                    String chan = command.toString();\n+                    control.selectChannel(chan);\n+                    break;\n+                case CHANNEL_MUTE:\n+                    if (command == OnOffType.ON) {\n+                        control.sendKey(\"MUTE\");\n+                    } else {\n+                        control.sendKey(\"VOLUP\");\n+                    }\n+                    break;\n+                case CHANNEL_KEY:\n+                    if (command.toString().equalsIgnoreCase(\"PAIR\")) { // special key to re-pair receiver (already done\n+                                                                       // above)\n+                        logger.debug(\"{}: PAIRing key received, reconnect receiver {}\", thingId, deviceName());\n+                    } else {\n+                        control.sendKey(command.toString());\n+                        mapKeyToMediateState(command.toString());\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"{}: Command {} for unknown channel {}\", thingId, command, channelUID.getAsString());\n+            }\n+        } catch (MagentaTVException e) {\n+            String errorMessage = MessageFormat.format(\"Channel operation failed (command={0}, value={1}): {2}\",\n+                    command, channelUID.getId(), e.toString());\n+            logger.debug(\"{}: {}\", thingId, errorMessage);\n+            setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+        }\n+    }\n+\n+    private void mapKeyToMediateState(String key) {\n+        State state = null;\n+        switch (key.toUpperCase()) {\n+            case \"PLAY\":\n+                state = PlayPauseType.PLAY;\n+                break;\n+            case \"PAUSE\":\n+                state = PlayPauseType.PAUSE;\n+                break;\n+            case \"FORWARD\":\n+                state = RewindFastforwardType.FASTFORWARD;\n+                break;\n+            case \"REWIND\":\n+                updateState(CHANNEL_PLAYER, RewindFastforwardType.REWIND);\n+                break;\n+        }\n+        if (state != null) {\n+            logger.debug(\"{}: Setting Player state to {}\", thingId, state);\n+            updateState(CHANNEL_PLAYER, state);\n+        }\n+    }\n+\n+    /**\n+     * Connect to the receiver\n+     *\n+     * @throws MagentaTVException something failed\n+     */\n+    protected void connectReceiver() throws MagentaTVException {\n+        if (control.checkDev()) {\n+            updateThingProperties();\n+            handlerFactory.registerDevice(config.getUDN(), config.getTerminalID(), config.getIpAddress(), this);\n+            control.subscribeEventChannel();\n+            control.sendPairingRequest();\n+\n+            // check for pairing timeout\n+            final int iRefresh = ++idRefresh;\n+            pairingWatchdogJob = scheduler.schedule(() -> {\n+                if (iRefresh == idRefresh) { // Make a best effort to not run multiple deferred refresh\n+                    if (config.getVerificationCode().isEmpty()) {\n+                        setOnlineState(ThingStatus.OFFLINE, \"Timeout on pairing request!\");\n+                    }\n+                }\n+            }, 15, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * If userID is empty and credentials are given the Telekom OAuth service is\n+     * used to query the userID\n+     *\n+     * @throws MagentaTVException\n+     */\n+    private void authenticateUser() throws MagentaTVException {\n+        String userId = config.getUserID();\n+        if (userId.isEmpty()) {\n+            // run OAuth authentication, this finally provides the userID\n+            userId = control.authenticateUser(config.getAccountName(), config.getAccountPassword());\n+\n+            // Update thing configuration (persistent) - remove credentials, add userID\n+            Configuration configuration = this.getConfig();\n+            configuration.remove(PROPERTY_ACCT_NAME);\n+            configuration.remove(PROPERTY_ACCT_PWD);\n+            configuration.remove(PROPERTY_USERID);\n+            configuration.put(PROPERTY_ACCT_NAME, \"\");\n+            configuration.put(PROPERTY_ACCT_PWD, \"\");\n+            configuration.put(PROPERTY_USERID, userId);\n+            this.updateConfiguration(configuration);\n+            config.setAccountName(\"\");\n+            config.setAccountPassword(\"\");\n+        } else {\n+            logger.debug(\"{}: Skip OAuth, use existing userID {}\", thingId, config.getUserID());\n+        }\n+        if (!userId.isEmpty()) {\n+            config.setUserID(userId);\n+        } else {\n+            logger.warn(\"{}: Unable to obtain userId from OAuth\", thingId);\n+        }\n+    }\n+\n+    /**\n+     * Update thing status\n+     *\n+     * @param mode new thing status\n+     * @return ON = power on, OFF=power off\n+     */\n+    public void setOnlineState(ThingStatus newStatus, String errorMessage) {\n+        ThingStatus status = this.getThing().getStatus();\n+        if (status != newStatus) {\n+            if (newStatus == ThingStatus.ONLINE) {\n+                updateStatus(newStatus);\n+                updateState(CHANNEL_POWER, OnOffType.ON);\n+            } else {\n+                if (!errorMessage.isEmpty()) {\n+                    logger.debug(\"{}: Communication Error - {}, switch Thing offline\", thingId, errorMessage);\n+                    updateStatus(newStatus, ThingStatusDetail.COMMUNICATION_ERROR, errorMessage);\n+                } else {\n+                    updateStatus(newStatus);\n+                }\n+                updateState(CHANNEL_POWER, OnOffType.OFF);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A wakeup of the MR was detected (e.g. UPnP received)\n+     *\n+     * @throws MagentaTVException\n+     */\n+    @Override\n+    public void onWakeup(Map<String, String> discoveredProperties) throws MagentaTVException {\n+        if ((this.getThing().getStatus() == ThingStatus.OFFLINE) || config.getVerificationCode().isEmpty()) {\n+            // Device sent a UPnP discovery information, trigger to reconnect\n+            connectReceiver();\n+        } else {\n+            logger.debug(\"{}: Refesh device status for {} (UDN={}\", thingId, deviceName(), config.getUDN());\n+            setOnlineState(ThingStatus.ONLINE, \"\");", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMzNjYyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484336620", "bodyText": "that happens in setOnlineState()", "author": "markus7017", "createdAt": "2020-09-07T10:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1MzMwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484553301", "bodyText": "But here it would be much cleaner, since it is about sending state updates to channels and setOnlineStatus should be about setting the status of the Thing. Trying to reduce unexpected side-effects in methods here.", "author": "kaikreuzer", "createdAt": "2020-09-07T19:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDMxOA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484120318", "bodyText": "isn't here a break missing?", "author": "kaikreuzer", "createdAt": "2020-09-06T22:19:53Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);\n+                authenticateUser();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserID(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+\n+        // initializeThing();\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails\n+            }\n+\n+            logger.debug(\"{}: Channel command for device {}: {} for channel {}\", thingId, config.getFriendlyName(),\n+                    command, channelUID.getId());\n+            switch (channelUID.getId()) {\n+                case CHANNEL_POWER: // toggle power\n+                    logger.debug(\"{}: Toggle power, new state={}\", thingId, command);\n+                    control.sendKey(\"POWER\");\n+                    break;\n+                case CHANNEL_PLAYER:\n+                    logger.debug(\"{}: Player command: {}\", thingId, command);\n+                    if (command instanceof OnOffType) {\n+                        control.sendKey(\"POWER\");\n+                    } else if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            control.sendKey(\"PLAY\");\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            control.sendKey(\"PAUSE\");\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            control.sendKey(\"NEXTCH\");\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            control.sendKey(\"PREVCH\");\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                        if (command == RewindFastforwardType.FASTFORWARD) {\n+                            control.sendKey(\"FORWARD\");\n+                        } else if (command == RewindFastforwardType.REWIND) {\n+                            control.sendKey(\"REWIND\");\n+                        }\n+                    } else {\n+                        logger.debug(\"{}: Unknown media command: {}\", thingId, command);\n+                    }\n+                    break;\n+                case CHANNEL_CHANNEL:\n+                    String chan = command.toString();\n+                    control.selectChannel(chan);\n+                    break;\n+                case CHANNEL_MUTE:\n+                    if (command == OnOffType.ON) {\n+                        control.sendKey(\"MUTE\");\n+                    } else {\n+                        control.sendKey(\"VOLUP\");\n+                    }\n+                    break;\n+                case CHANNEL_KEY:\n+                    if (command.toString().equalsIgnoreCase(\"PAIR\")) { // special key to re-pair receiver (already done\n+                                                                       // above)\n+                        logger.debug(\"{}: PAIRing key received, reconnect receiver {}\", thingId, deviceName());\n+                    } else {\n+                        control.sendKey(command.toString());\n+                        mapKeyToMediateState(command.toString());\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"{}: Command {} for unknown channel {}\", thingId, command, channelUID.getAsString());\n+            }\n+        } catch (MagentaTVException e) {\n+            String errorMessage = MessageFormat.format(\"Channel operation failed (command={0}, value={1}): {2}\",\n+                    command, channelUID.getId(), e.toString());\n+            logger.debug(\"{}: {}\", thingId, errorMessage);\n+            setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+        }\n+    }\n+\n+    private void mapKeyToMediateState(String key) {\n+        State state = null;\n+        switch (key.toUpperCase()) {\n+            case \"PLAY\":\n+                state = PlayPauseType.PLAY;\n+                break;\n+            case \"PAUSE\":\n+                state = PlayPauseType.PAUSE;\n+                break;\n+            case \"FORWARD\":\n+                state = RewindFastforwardType.FASTFORWARD;\n+                break;\n+            case \"REWIND\":\n+                updateState(CHANNEL_PLAYER, RewindFastforwardType.REWIND);\n+                break;\n+        }\n+        if (state != null) {\n+            logger.debug(\"{}: Setting Player state to {}\", thingId, state);\n+            updateState(CHANNEL_PLAYER, state);\n+        }\n+    }\n+\n+    /**\n+     * Connect to the receiver\n+     *\n+     * @throws MagentaTVException something failed\n+     */\n+    protected void connectReceiver() throws MagentaTVException {\n+        if (control.checkDev()) {\n+            updateThingProperties();\n+            handlerFactory.registerDevice(config.getUDN(), config.getTerminalID(), config.getIpAddress(), this);\n+            control.subscribeEventChannel();\n+            control.sendPairingRequest();\n+\n+            // check for pairing timeout\n+            final int iRefresh = ++idRefresh;\n+            pairingWatchdogJob = scheduler.schedule(() -> {\n+                if (iRefresh == idRefresh) { // Make a best effort to not run multiple deferred refresh\n+                    if (config.getVerificationCode().isEmpty()) {\n+                        setOnlineState(ThingStatus.OFFLINE, \"Timeout on pairing request!\");\n+                    }\n+                }\n+            }, 15, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * If userID is empty and credentials are given the Telekom OAuth service is\n+     * used to query the userID\n+     *\n+     * @throws MagentaTVException\n+     */\n+    private void authenticateUser() throws MagentaTVException {\n+        String userId = config.getUserID();\n+        if (userId.isEmpty()) {\n+            // run OAuth authentication, this finally provides the userID\n+            userId = control.authenticateUser(config.getAccountName(), config.getAccountPassword());\n+\n+            // Update thing configuration (persistent) - remove credentials, add userID\n+            Configuration configuration = this.getConfig();\n+            configuration.remove(PROPERTY_ACCT_NAME);\n+            configuration.remove(PROPERTY_ACCT_PWD);\n+            configuration.remove(PROPERTY_USERID);\n+            configuration.put(PROPERTY_ACCT_NAME, \"\");\n+            configuration.put(PROPERTY_ACCT_PWD, \"\");\n+            configuration.put(PROPERTY_USERID, userId);\n+            this.updateConfiguration(configuration);\n+            config.setAccountName(\"\");\n+            config.setAccountPassword(\"\");\n+        } else {\n+            logger.debug(\"{}: Skip OAuth, use existing userID {}\", thingId, config.getUserID());\n+        }\n+        if (!userId.isEmpty()) {\n+            config.setUserID(userId);\n+        } else {\n+            logger.warn(\"{}: Unable to obtain userId from OAuth\", thingId);\n+        }\n+    }\n+\n+    /**\n+     * Update thing status\n+     *\n+     * @param mode new thing status\n+     * @return ON = power on, OFF=power off\n+     */\n+    public void setOnlineState(ThingStatus newStatus, String errorMessage) {\n+        ThingStatus status = this.getThing().getStatus();\n+        if (status != newStatus) {\n+            if (newStatus == ThingStatus.ONLINE) {\n+                updateStatus(newStatus);\n+                updateState(CHANNEL_POWER, OnOffType.ON);\n+            } else {\n+                if (!errorMessage.isEmpty()) {\n+                    logger.debug(\"{}: Communication Error - {}, switch Thing offline\", thingId, errorMessage);\n+                    updateStatus(newStatus, ThingStatusDetail.COMMUNICATION_ERROR, errorMessage);\n+                } else {\n+                    updateStatus(newStatus);\n+                }\n+                updateState(CHANNEL_POWER, OnOffType.OFF);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A wakeup of the MR was detected (e.g. UPnP received)\n+     *\n+     * @throws MagentaTVException\n+     */\n+    @Override\n+    public void onWakeup(Map<String, String> discoveredProperties) throws MagentaTVException {\n+        if ((this.getThing().getStatus() == ThingStatus.OFFLINE) || config.getVerificationCode().isEmpty()) {\n+            // Device sent a UPnP discovery information, trigger to reconnect\n+            connectReceiver();\n+        } else {\n+            logger.debug(\"{}: Refesh device status for {} (UDN={}\", thingId, deviceName(), config.getUDN());\n+            setOnlineState(ThingStatus.ONLINE, \"\");\n+        }\n+    }\n+\n+    /**\n+     * The pairing result has been received. The pairing code will be used to generate the verification code and\n+     * complete pairing with the MR. Finally if pairing was completed successful the thing status will change to ONLINE\n+     *\n+     * @param pairingCode pairing code received from MR (NOTIFY event data)\n+     * @throws MagentaTVException\n+     */\n+    @Override\n+    public void onPairingResult(String pairingCode) throws MagentaTVException {\n+        if (control.isInitialized()) {\n+            if (control.generateVerificationCode(pairingCode)) {\n+                config.setPairingCode(pairingCode);\n+                logger.debug(\n+                        \"{}: Pairing code received (UDN {}, terminalID {}, pairingCode={}, verificationCode={}, userID={})\",\n+                        thingId, config.getUDN(), config.getTerminalID(), config.getPairingCode(),\n+                        config.getVerificationCode(), config.getUserID());\n+\n+                // verify pairing completes the pairing process\n+                if (control.verifyPairing()) {\n+                    logger.debug(\"{}: Pairing completed for device {} ({}), Thing now ONLINE\", thingId,\n+                            config.getFriendlyName(), config.getTerminalID());\n+                    setOnlineState(ThingStatus.ONLINE, \"\");\n+                    cancelPairingCheck(); // stop timeout check\n+                }\n+            }\n+            updateThingProperties(); // persist pairing and verification code\n+        } else {\n+            logger.debug(\"{}: control not yet initialized!\", thingId);\n+        }\n+    }\n+\n+    @Override\n+    public void onMREvent(String jsonInput) {\n+        logger.trace(\"{}: Process MR event for device {}, json={}\", thingId, deviceName(), jsonInput);\n+        boolean flUpdatePower = false;\n+        String jsonEvent = fixEventJson(jsonInput);\n+        if (jsonEvent.contains(MR_EVENT_EIT_CHANGE)) {\n+            logger.debug(\"{}: EVENT_EIT_CHANGE event received.\", thingId);\n+\n+            MRProgramInfoEvent pinfo = gson.fromJson(jsonEvent, MRProgramInfoEvent.class);\n+            if (!pinfo.channelNum.isEmpty()) {\n+                logger.debug(\"{}: EVENT_EIT_CHANGE for channel {}/{}\", thingId, pinfo.channelNum, pinfo.channelCode);\n+                updateState(CHANNEL_CHANNEL, new DecimalType(pinfo.channelNum));\n+                updateState(CHANNEL_CHANNEL_CODE, new DecimalType(pinfo.channelCode));\n+            }\n+            if (pinfo.programInfo != null) {\n+                int i = 0;\n+                for (MRProgramStatus ps : pinfo.programInfo) {\n+                    if ((ps.startTime == null) || ps.startTime.isEmpty()) {\n+                        logger.debug(\"{}: EVENT_EIT_CHANGE: empty event data = {}\", thingId, jsonEvent);\n+                        continue; // empty program_info\n+                    }\n+                    updateState(CHANNEL_RUN_STATUS, new StringType(control.getRunStatus(ps.runningStatus)));\n+\n+                    if (ps.shortEvent != null) {\n+                        for (MRShortProgramInfo se : ps.shortEvent) {\n+                            if ((ps.startTime == null) || ps.startTime.isEmpty()) {\n+                                logger.debug(\"{}: EVENT_EIT_CHANGE: empty program info\", thingId);\n+                                continue;\n+                            }\n+                            // Convert UTC to local time\n+                            // 2018/11/04 21:45:00 -> \"2018-11-04T10:15:30.00Z\"\n+                            String tsLocal = ps.startTime.replace('/', '-').replace(\" \", \"T\") + \"Z\";\n+                            Instant timestamp = Instant.parse(tsLocal);\n+                            ZonedDateTime localTime = timestamp.atZone(ZoneId.of(\"Europe/Berlin\"));\n+                            tsLocal = substringBeforeLast(localTime.toString(), \"[\");\n+                            tsLocal = substringBefore(tsLocal.replace('-', '/').replace('T', ' '), \"+\");\n+\n+                            logger.debug(\"{}: Info for channel {} / {} - {} {}.{}, start time={}, duration={}\", thingId,\n+                                    pinfo.channelNum, pinfo.channelCode, control.getRunStatus(ps.runningStatus),\n+                                    se.eventName, se.textChar, tsLocal, ps.duration);\n+                            if (ps.runningStatus != EV_EITCHG_RUNNING_NOT_RUNNING) {\n+                                updateState(CHANNEL_PROG_TITLE, new StringType(se.eventName));\n+                                updateState(CHANNEL_PROG_TEXT, new StringType(se.textChar));\n+                                updateState(CHANNEL_PROG_START, new DateTimeType(localTime));\n+\n+                                try {\n+                                    DateFormat dateFormat = new SimpleDateFormat(\"HH:mm:ss\");\n+                                    dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+                                    Date date = dateFormat.parse(ps.duration);\n+                                    long minutes = date.getTime() / 1000L / 60l;\n+                                    updateState(CHANNEL_PROG_DURATION, toQuantityType(minutes, SmartHomeUnits.MINUTE));\n+                                } catch (ParseException e) {\n+                                    logger.debug(\"{}: Unable to parse programDuration: {}\", thingId, ps.duration);\n+                                }\n+\n+                                if (i++ == 0) {\n+                                    flUpdatePower = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        } else if (jsonEvent.contains(\"new_play_mode\")) {\n+            MRPayEvent event = gson.fromJson(jsonEvent, MRPayEvent.class);\n+            if (event.duration == null) {\n+                event.duration = -1;\n+            }\n+            if (event.playPostion == null) {\n+                event.playPostion = -1;\n+            }\n+            logger.debug(\"{}: STB event playContent: playMode={}, duration={}, playPosition={}\", thingId,\n+                    control.getPlayStatus(event.newPlayMode), event.duration, event.playPostion);\n+\n+            // If we get a playConfig event there MR must be online. However it also sends a\n+            // plyMode stop before powering off the device, so we filter this.\n+            if ((event.newPlayMode != EV_PLAYCHG_STOP) && this.isInitialized()) {\n+                flUpdatePower = true;\n+            }\n+            if (event.newPlayMode != -1) {\n+                String playMode = control.getPlayStatus(event.newPlayMode);\n+                updateState(CHANNEL_PLAY_MODE, new StringType(playMode));\n+                mapPlayModeToMediaControl(playMode);\n+            }\n+            if (event.duration > 0) {\n+                updateState(CHANNEL_PROG_DURATION, new StringType(event.duration.toString()));\n+            }\n+            if (event.playPostion != -1) {\n+                updateState(CHANNEL_PROG_POS, toQuantityType(event.playPostion / 6, SmartHomeUnits.MINUTE));\n+            }\n+        } else {\n+            logger.debug(\"{}: Unknown MR event, JSON={}\", thingId, jsonEvent);\n+        }\n+        if (flUpdatePower) {\n+            // We received a non-stopped event -> MR must be on\n+            updateState(CHANNEL_POWER, OnOffType.ON);\n+        }\n+    }\n+\n+    private void mapPlayModeToMediaControl(String playMode) {\n+        switch (playMode) {\n+            case \"playing\":\n+            case \"playing (MC)\":\n+            case \"playing (UC)\":\n+            case \"buffering\":\n+                logger.debug(\"{}: Setting Player state to PLAY\", thingId);\n+                updateState(CHANNEL_PLAYER, PlayPauseType.PLAY);", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMzNzA1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484337056", "bodyText": "yep, good catch", "author": "markus7017", "createdAt": "2020-09-07T10:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDM4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484120382", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // MR was powered off -> update pwoer status, reset items\n          \n          \n            \n                    // MR was powered off -> update power status, reset items", "author": "kaikreuzer", "createdAt": "2020-09-06T22:20:24Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);\n+                authenticateUser();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserID(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+\n+        // initializeThing();\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails\n+            }\n+\n+            logger.debug(\"{}: Channel command for device {}: {} for channel {}\", thingId, config.getFriendlyName(),\n+                    command, channelUID.getId());\n+            switch (channelUID.getId()) {\n+                case CHANNEL_POWER: // toggle power\n+                    logger.debug(\"{}: Toggle power, new state={}\", thingId, command);\n+                    control.sendKey(\"POWER\");\n+                    break;\n+                case CHANNEL_PLAYER:\n+                    logger.debug(\"{}: Player command: {}\", thingId, command);\n+                    if (command instanceof OnOffType) {\n+                        control.sendKey(\"POWER\");\n+                    } else if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            control.sendKey(\"PLAY\");\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            control.sendKey(\"PAUSE\");\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            control.sendKey(\"NEXTCH\");\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            control.sendKey(\"PREVCH\");\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                        if (command == RewindFastforwardType.FASTFORWARD) {\n+                            control.sendKey(\"FORWARD\");\n+                        } else if (command == RewindFastforwardType.REWIND) {\n+                            control.sendKey(\"REWIND\");\n+                        }\n+                    } else {\n+                        logger.debug(\"{}: Unknown media command: {}\", thingId, command);\n+                    }\n+                    break;\n+                case CHANNEL_CHANNEL:\n+                    String chan = command.toString();\n+                    control.selectChannel(chan);\n+                    break;\n+                case CHANNEL_MUTE:\n+                    if (command == OnOffType.ON) {\n+                        control.sendKey(\"MUTE\");\n+                    } else {\n+                        control.sendKey(\"VOLUP\");\n+                    }\n+                    break;\n+                case CHANNEL_KEY:\n+                    if (command.toString().equalsIgnoreCase(\"PAIR\")) { // special key to re-pair receiver (already done\n+                                                                       // above)\n+                        logger.debug(\"{}: PAIRing key received, reconnect receiver {}\", thingId, deviceName());\n+                    } else {\n+                        control.sendKey(command.toString());\n+                        mapKeyToMediateState(command.toString());\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"{}: Command {} for unknown channel {}\", thingId, command, channelUID.getAsString());\n+            }\n+        } catch (MagentaTVException e) {\n+            String errorMessage = MessageFormat.format(\"Channel operation failed (command={0}, value={1}): {2}\",\n+                    command, channelUID.getId(), e.toString());\n+            logger.debug(\"{}: {}\", thingId, errorMessage);\n+            setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+        }\n+    }\n+\n+    private void mapKeyToMediateState(String key) {\n+        State state = null;\n+        switch (key.toUpperCase()) {\n+            case \"PLAY\":\n+                state = PlayPauseType.PLAY;\n+                break;\n+            case \"PAUSE\":\n+                state = PlayPauseType.PAUSE;\n+                break;\n+            case \"FORWARD\":\n+                state = RewindFastforwardType.FASTFORWARD;\n+                break;\n+            case \"REWIND\":\n+                updateState(CHANNEL_PLAYER, RewindFastforwardType.REWIND);\n+                break;\n+        }\n+        if (state != null) {\n+            logger.debug(\"{}: Setting Player state to {}\", thingId, state);\n+            updateState(CHANNEL_PLAYER, state);\n+        }\n+    }\n+\n+    /**\n+     * Connect to the receiver\n+     *\n+     * @throws MagentaTVException something failed\n+     */\n+    protected void connectReceiver() throws MagentaTVException {\n+        if (control.checkDev()) {\n+            updateThingProperties();\n+            handlerFactory.registerDevice(config.getUDN(), config.getTerminalID(), config.getIpAddress(), this);\n+            control.subscribeEventChannel();\n+            control.sendPairingRequest();\n+\n+            // check for pairing timeout\n+            final int iRefresh = ++idRefresh;\n+            pairingWatchdogJob = scheduler.schedule(() -> {\n+                if (iRefresh == idRefresh) { // Make a best effort to not run multiple deferred refresh\n+                    if (config.getVerificationCode().isEmpty()) {\n+                        setOnlineState(ThingStatus.OFFLINE, \"Timeout on pairing request!\");\n+                    }\n+                }\n+            }, 15, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * If userID is empty and credentials are given the Telekom OAuth service is\n+     * used to query the userID\n+     *\n+     * @throws MagentaTVException\n+     */\n+    private void authenticateUser() throws MagentaTVException {\n+        String userId = config.getUserID();\n+        if (userId.isEmpty()) {\n+            // run OAuth authentication, this finally provides the userID\n+            userId = control.authenticateUser(config.getAccountName(), config.getAccountPassword());\n+\n+            // Update thing configuration (persistent) - remove credentials, add userID\n+            Configuration configuration = this.getConfig();\n+            configuration.remove(PROPERTY_ACCT_NAME);\n+            configuration.remove(PROPERTY_ACCT_PWD);\n+            configuration.remove(PROPERTY_USERID);\n+            configuration.put(PROPERTY_ACCT_NAME, \"\");\n+            configuration.put(PROPERTY_ACCT_PWD, \"\");\n+            configuration.put(PROPERTY_USERID, userId);\n+            this.updateConfiguration(configuration);\n+            config.setAccountName(\"\");\n+            config.setAccountPassword(\"\");\n+        } else {\n+            logger.debug(\"{}: Skip OAuth, use existing userID {}\", thingId, config.getUserID());\n+        }\n+        if (!userId.isEmpty()) {\n+            config.setUserID(userId);\n+        } else {\n+            logger.warn(\"{}: Unable to obtain userId from OAuth\", thingId);\n+        }\n+    }\n+\n+    /**\n+     * Update thing status\n+     *\n+     * @param mode new thing status\n+     * @return ON = power on, OFF=power off\n+     */\n+    public void setOnlineState(ThingStatus newStatus, String errorMessage) {\n+        ThingStatus status = this.getThing().getStatus();\n+        if (status != newStatus) {\n+            if (newStatus == ThingStatus.ONLINE) {\n+                updateStatus(newStatus);\n+                updateState(CHANNEL_POWER, OnOffType.ON);\n+            } else {\n+                if (!errorMessage.isEmpty()) {\n+                    logger.debug(\"{}: Communication Error - {}, switch Thing offline\", thingId, errorMessage);\n+                    updateStatus(newStatus, ThingStatusDetail.COMMUNICATION_ERROR, errorMessage);\n+                } else {\n+                    updateStatus(newStatus);\n+                }\n+                updateState(CHANNEL_POWER, OnOffType.OFF);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A wakeup of the MR was detected (e.g. UPnP received)\n+     *\n+     * @throws MagentaTVException\n+     */\n+    @Override\n+    public void onWakeup(Map<String, String> discoveredProperties) throws MagentaTVException {\n+        if ((this.getThing().getStatus() == ThingStatus.OFFLINE) || config.getVerificationCode().isEmpty()) {\n+            // Device sent a UPnP discovery information, trigger to reconnect\n+            connectReceiver();\n+        } else {\n+            logger.debug(\"{}: Refesh device status for {} (UDN={}\", thingId, deviceName(), config.getUDN());\n+            setOnlineState(ThingStatus.ONLINE, \"\");\n+        }\n+    }\n+\n+    /**\n+     * The pairing result has been received. The pairing code will be used to generate the verification code and\n+     * complete pairing with the MR. Finally if pairing was completed successful the thing status will change to ONLINE\n+     *\n+     * @param pairingCode pairing code received from MR (NOTIFY event data)\n+     * @throws MagentaTVException\n+     */\n+    @Override\n+    public void onPairingResult(String pairingCode) throws MagentaTVException {\n+        if (control.isInitialized()) {\n+            if (control.generateVerificationCode(pairingCode)) {\n+                config.setPairingCode(pairingCode);\n+                logger.debug(\n+                        \"{}: Pairing code received (UDN {}, terminalID {}, pairingCode={}, verificationCode={}, userID={})\",\n+                        thingId, config.getUDN(), config.getTerminalID(), config.getPairingCode(),\n+                        config.getVerificationCode(), config.getUserID());\n+\n+                // verify pairing completes the pairing process\n+                if (control.verifyPairing()) {\n+                    logger.debug(\"{}: Pairing completed for device {} ({}), Thing now ONLINE\", thingId,\n+                            config.getFriendlyName(), config.getTerminalID());\n+                    setOnlineState(ThingStatus.ONLINE, \"\");\n+                    cancelPairingCheck(); // stop timeout check\n+                }\n+            }\n+            updateThingProperties(); // persist pairing and verification code\n+        } else {\n+            logger.debug(\"{}: control not yet initialized!\", thingId);\n+        }\n+    }\n+\n+    @Override\n+    public void onMREvent(String jsonInput) {\n+        logger.trace(\"{}: Process MR event for device {}, json={}\", thingId, deviceName(), jsonInput);\n+        boolean flUpdatePower = false;\n+        String jsonEvent = fixEventJson(jsonInput);\n+        if (jsonEvent.contains(MR_EVENT_EIT_CHANGE)) {\n+            logger.debug(\"{}: EVENT_EIT_CHANGE event received.\", thingId);\n+\n+            MRProgramInfoEvent pinfo = gson.fromJson(jsonEvent, MRProgramInfoEvent.class);\n+            if (!pinfo.channelNum.isEmpty()) {\n+                logger.debug(\"{}: EVENT_EIT_CHANGE for channel {}/{}\", thingId, pinfo.channelNum, pinfo.channelCode);\n+                updateState(CHANNEL_CHANNEL, new DecimalType(pinfo.channelNum));\n+                updateState(CHANNEL_CHANNEL_CODE, new DecimalType(pinfo.channelCode));\n+            }\n+            if (pinfo.programInfo != null) {\n+                int i = 0;\n+                for (MRProgramStatus ps : pinfo.programInfo) {\n+                    if ((ps.startTime == null) || ps.startTime.isEmpty()) {\n+                        logger.debug(\"{}: EVENT_EIT_CHANGE: empty event data = {}\", thingId, jsonEvent);\n+                        continue; // empty program_info\n+                    }\n+                    updateState(CHANNEL_RUN_STATUS, new StringType(control.getRunStatus(ps.runningStatus)));\n+\n+                    if (ps.shortEvent != null) {\n+                        for (MRShortProgramInfo se : ps.shortEvent) {\n+                            if ((ps.startTime == null) || ps.startTime.isEmpty()) {\n+                                logger.debug(\"{}: EVENT_EIT_CHANGE: empty program info\", thingId);\n+                                continue;\n+                            }\n+                            // Convert UTC to local time\n+                            // 2018/11/04 21:45:00 -> \"2018-11-04T10:15:30.00Z\"\n+                            String tsLocal = ps.startTime.replace('/', '-').replace(\" \", \"T\") + \"Z\";\n+                            Instant timestamp = Instant.parse(tsLocal);\n+                            ZonedDateTime localTime = timestamp.atZone(ZoneId.of(\"Europe/Berlin\"));\n+                            tsLocal = substringBeforeLast(localTime.toString(), \"[\");\n+                            tsLocal = substringBefore(tsLocal.replace('-', '/').replace('T', ' '), \"+\");\n+\n+                            logger.debug(\"{}: Info for channel {} / {} - {} {}.{}, start time={}, duration={}\", thingId,\n+                                    pinfo.channelNum, pinfo.channelCode, control.getRunStatus(ps.runningStatus),\n+                                    se.eventName, se.textChar, tsLocal, ps.duration);\n+                            if (ps.runningStatus != EV_EITCHG_RUNNING_NOT_RUNNING) {\n+                                updateState(CHANNEL_PROG_TITLE, new StringType(se.eventName));\n+                                updateState(CHANNEL_PROG_TEXT, new StringType(se.textChar));\n+                                updateState(CHANNEL_PROG_START, new DateTimeType(localTime));\n+\n+                                try {\n+                                    DateFormat dateFormat = new SimpleDateFormat(\"HH:mm:ss\");\n+                                    dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+                                    Date date = dateFormat.parse(ps.duration);\n+                                    long minutes = date.getTime() / 1000L / 60l;\n+                                    updateState(CHANNEL_PROG_DURATION, toQuantityType(minutes, SmartHomeUnits.MINUTE));\n+                                } catch (ParseException e) {\n+                                    logger.debug(\"{}: Unable to parse programDuration: {}\", thingId, ps.duration);\n+                                }\n+\n+                                if (i++ == 0) {\n+                                    flUpdatePower = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        } else if (jsonEvent.contains(\"new_play_mode\")) {\n+            MRPayEvent event = gson.fromJson(jsonEvent, MRPayEvent.class);\n+            if (event.duration == null) {\n+                event.duration = -1;\n+            }\n+            if (event.playPostion == null) {\n+                event.playPostion = -1;\n+            }\n+            logger.debug(\"{}: STB event playContent: playMode={}, duration={}, playPosition={}\", thingId,\n+                    control.getPlayStatus(event.newPlayMode), event.duration, event.playPostion);\n+\n+            // If we get a playConfig event there MR must be online. However it also sends a\n+            // plyMode stop before powering off the device, so we filter this.\n+            if ((event.newPlayMode != EV_PLAYCHG_STOP) && this.isInitialized()) {\n+                flUpdatePower = true;\n+            }\n+            if (event.newPlayMode != -1) {\n+                String playMode = control.getPlayStatus(event.newPlayMode);\n+                updateState(CHANNEL_PLAY_MODE, new StringType(playMode));\n+                mapPlayModeToMediaControl(playMode);\n+            }\n+            if (event.duration > 0) {\n+                updateState(CHANNEL_PROG_DURATION, new StringType(event.duration.toString()));\n+            }\n+            if (event.playPostion != -1) {\n+                updateState(CHANNEL_PROG_POS, toQuantityType(event.playPostion / 6, SmartHomeUnits.MINUTE));\n+            }\n+        } else {\n+            logger.debug(\"{}: Unknown MR event, JSON={}\", thingId, jsonEvent);\n+        }\n+        if (flUpdatePower) {\n+            // We received a non-stopped event -> MR must be on\n+            updateState(CHANNEL_POWER, OnOffType.ON);\n+        }\n+    }\n+\n+    private void mapPlayModeToMediaControl(String playMode) {\n+        switch (playMode) {\n+            case \"playing\":\n+            case \"playing (MC)\":\n+            case \"playing (UC)\":\n+            case \"buffering\":\n+                logger.debug(\"{}: Setting Player state to PLAY\", thingId);\n+                updateState(CHANNEL_PLAYER, PlayPauseType.PLAY);\n+            case \"paused\":\n+            case \"stopped\":\n+                logger.debug(\"{}: Setting Player state to PAUSE\", thingId);\n+                updateState(CHANNEL_PLAYER, PlayPauseType.PAUSE);\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * When the MR powers off it send a UPnP message, which is catched by the binding.\n+     */\n+    @Override\n+    public void onPowerOff() throws MagentaTVException {\n+        logger.debug(\"{}: Power-Off received for device {}\", thingId, deviceName());\n+        // MR was powered off -> update pwoer status, reset items", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMzNzM5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484337397", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-09-07T10:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDQ0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484120441", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Check device status, if pairing\n          \n          \n            \n                 * events (if callbackUrl is configured)\n          \n          \n            \n                 * Check device status, if pairing events (if callbackUrl is configured)", "author": "kaikreuzer", "createdAt": "2020-09-06T22:21:03Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,692 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAutenhicateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVHandlerFactory handlerFactory;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVHandlerFactory handlerFactory, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.handlerFactory = handlerFactory;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAutenhicateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - perform Oath if userID is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserID().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                logger.info(\"{}: Authenticate account {}\", thingId, account);\n+                authenticateUser();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(new Runnable() {\n+                @Override\n+                public void run() {\n+                    renewEventSubscription();\n+                }\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserID(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+\n+        // initializeThing();\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails\n+            }\n+\n+            logger.debug(\"{}: Channel command for device {}: {} for channel {}\", thingId, config.getFriendlyName(),\n+                    command, channelUID.getId());\n+            switch (channelUID.getId()) {\n+                case CHANNEL_POWER: // toggle power\n+                    logger.debug(\"{}: Toggle power, new state={}\", thingId, command);\n+                    control.sendKey(\"POWER\");\n+                    break;\n+                case CHANNEL_PLAYER:\n+                    logger.debug(\"{}: Player command: {}\", thingId, command);\n+                    if (command instanceof OnOffType) {\n+                        control.sendKey(\"POWER\");\n+                    } else if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            control.sendKey(\"PLAY\");\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            control.sendKey(\"PAUSE\");\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            control.sendKey(\"NEXTCH\");\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            control.sendKey(\"PREVCH\");\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                        if (command == RewindFastforwardType.FASTFORWARD) {\n+                            control.sendKey(\"FORWARD\");\n+                        } else if (command == RewindFastforwardType.REWIND) {\n+                            control.sendKey(\"REWIND\");\n+                        }\n+                    } else {\n+                        logger.debug(\"{}: Unknown media command: {}\", thingId, command);\n+                    }\n+                    break;\n+                case CHANNEL_CHANNEL:\n+                    String chan = command.toString();\n+                    control.selectChannel(chan);\n+                    break;\n+                case CHANNEL_MUTE:\n+                    if (command == OnOffType.ON) {\n+                        control.sendKey(\"MUTE\");\n+                    } else {\n+                        control.sendKey(\"VOLUP\");\n+                    }\n+                    break;\n+                case CHANNEL_KEY:\n+                    if (command.toString().equalsIgnoreCase(\"PAIR\")) { // special key to re-pair receiver (already done\n+                                                                       // above)\n+                        logger.debug(\"{}: PAIRing key received, reconnect receiver {}\", thingId, deviceName());\n+                    } else {\n+                        control.sendKey(command.toString());\n+                        mapKeyToMediateState(command.toString());\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"{}: Command {} for unknown channel {}\", thingId, command, channelUID.getAsString());\n+            }\n+        } catch (MagentaTVException e) {\n+            String errorMessage = MessageFormat.format(\"Channel operation failed (command={0}, value={1}): {2}\",\n+                    command, channelUID.getId(), e.toString());\n+            logger.debug(\"{}: {}\", thingId, errorMessage);\n+            setOnlineState(ThingStatus.OFFLINE, errorMessage);\n+        }\n+    }\n+\n+    private void mapKeyToMediateState(String key) {\n+        State state = null;\n+        switch (key.toUpperCase()) {\n+            case \"PLAY\":\n+                state = PlayPauseType.PLAY;\n+                break;\n+            case \"PAUSE\":\n+                state = PlayPauseType.PAUSE;\n+                break;\n+            case \"FORWARD\":\n+                state = RewindFastforwardType.FASTFORWARD;\n+                break;\n+            case \"REWIND\":\n+                updateState(CHANNEL_PLAYER, RewindFastforwardType.REWIND);\n+                break;\n+        }\n+        if (state != null) {\n+            logger.debug(\"{}: Setting Player state to {}\", thingId, state);\n+            updateState(CHANNEL_PLAYER, state);\n+        }\n+    }\n+\n+    /**\n+     * Connect to the receiver\n+     *\n+     * @throws MagentaTVException something failed\n+     */\n+    protected void connectReceiver() throws MagentaTVException {\n+        if (control.checkDev()) {\n+            updateThingProperties();\n+            handlerFactory.registerDevice(config.getUDN(), config.getTerminalID(), config.getIpAddress(), this);\n+            control.subscribeEventChannel();\n+            control.sendPairingRequest();\n+\n+            // check for pairing timeout\n+            final int iRefresh = ++idRefresh;\n+            pairingWatchdogJob = scheduler.schedule(() -> {\n+                if (iRefresh == idRefresh) { // Make a best effort to not run multiple deferred refresh\n+                    if (config.getVerificationCode().isEmpty()) {\n+                        setOnlineState(ThingStatus.OFFLINE, \"Timeout on pairing request!\");\n+                    }\n+                }\n+            }, 15, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * If userID is empty and credentials are given the Telekom OAuth service is\n+     * used to query the userID\n+     *\n+     * @throws MagentaTVException\n+     */\n+    private void authenticateUser() throws MagentaTVException {\n+        String userId = config.getUserID();\n+        if (userId.isEmpty()) {\n+            // run OAuth authentication, this finally provides the userID\n+            userId = control.authenticateUser(config.getAccountName(), config.getAccountPassword());\n+\n+            // Update thing configuration (persistent) - remove credentials, add userID\n+            Configuration configuration = this.getConfig();\n+            configuration.remove(PROPERTY_ACCT_NAME);\n+            configuration.remove(PROPERTY_ACCT_PWD);\n+            configuration.remove(PROPERTY_USERID);\n+            configuration.put(PROPERTY_ACCT_NAME, \"\");\n+            configuration.put(PROPERTY_ACCT_PWD, \"\");\n+            configuration.put(PROPERTY_USERID, userId);\n+            this.updateConfiguration(configuration);\n+            config.setAccountName(\"\");\n+            config.setAccountPassword(\"\");\n+        } else {\n+            logger.debug(\"{}: Skip OAuth, use existing userID {}\", thingId, config.getUserID());\n+        }\n+        if (!userId.isEmpty()) {\n+            config.setUserID(userId);\n+        } else {\n+            logger.warn(\"{}: Unable to obtain userId from OAuth\", thingId);\n+        }\n+    }\n+\n+    /**\n+     * Update thing status\n+     *\n+     * @param mode new thing status\n+     * @return ON = power on, OFF=power off\n+     */\n+    public void setOnlineState(ThingStatus newStatus, String errorMessage) {\n+        ThingStatus status = this.getThing().getStatus();\n+        if (status != newStatus) {\n+            if (newStatus == ThingStatus.ONLINE) {\n+                updateStatus(newStatus);\n+                updateState(CHANNEL_POWER, OnOffType.ON);\n+            } else {\n+                if (!errorMessage.isEmpty()) {\n+                    logger.debug(\"{}: Communication Error - {}, switch Thing offline\", thingId, errorMessage);\n+                    updateStatus(newStatus, ThingStatusDetail.COMMUNICATION_ERROR, errorMessage);\n+                } else {\n+                    updateStatus(newStatus);\n+                }\n+                updateState(CHANNEL_POWER, OnOffType.OFF);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A wakeup of the MR was detected (e.g. UPnP received)\n+     *\n+     * @throws MagentaTVException\n+     */\n+    @Override\n+    public void onWakeup(Map<String, String> discoveredProperties) throws MagentaTVException {\n+        if ((this.getThing().getStatus() == ThingStatus.OFFLINE) || config.getVerificationCode().isEmpty()) {\n+            // Device sent a UPnP discovery information, trigger to reconnect\n+            connectReceiver();\n+        } else {\n+            logger.debug(\"{}: Refesh device status for {} (UDN={}\", thingId, deviceName(), config.getUDN());\n+            setOnlineState(ThingStatus.ONLINE, \"\");\n+        }\n+    }\n+\n+    /**\n+     * The pairing result has been received. The pairing code will be used to generate the verification code and\n+     * complete pairing with the MR. Finally if pairing was completed successful the thing status will change to ONLINE\n+     *\n+     * @param pairingCode pairing code received from MR (NOTIFY event data)\n+     * @throws MagentaTVException\n+     */\n+    @Override\n+    public void onPairingResult(String pairingCode) throws MagentaTVException {\n+        if (control.isInitialized()) {\n+            if (control.generateVerificationCode(pairingCode)) {\n+                config.setPairingCode(pairingCode);\n+                logger.debug(\n+                        \"{}: Pairing code received (UDN {}, terminalID {}, pairingCode={}, verificationCode={}, userID={})\",\n+                        thingId, config.getUDN(), config.getTerminalID(), config.getPairingCode(),\n+                        config.getVerificationCode(), config.getUserID());\n+\n+                // verify pairing completes the pairing process\n+                if (control.verifyPairing()) {\n+                    logger.debug(\"{}: Pairing completed for device {} ({}), Thing now ONLINE\", thingId,\n+                            config.getFriendlyName(), config.getTerminalID());\n+                    setOnlineState(ThingStatus.ONLINE, \"\");\n+                    cancelPairingCheck(); // stop timeout check\n+                }\n+            }\n+            updateThingProperties(); // persist pairing and verification code\n+        } else {\n+            logger.debug(\"{}: control not yet initialized!\", thingId);\n+        }\n+    }\n+\n+    @Override\n+    public void onMREvent(String jsonInput) {\n+        logger.trace(\"{}: Process MR event for device {}, json={}\", thingId, deviceName(), jsonInput);\n+        boolean flUpdatePower = false;\n+        String jsonEvent = fixEventJson(jsonInput);\n+        if (jsonEvent.contains(MR_EVENT_EIT_CHANGE)) {\n+            logger.debug(\"{}: EVENT_EIT_CHANGE event received.\", thingId);\n+\n+            MRProgramInfoEvent pinfo = gson.fromJson(jsonEvent, MRProgramInfoEvent.class);\n+            if (!pinfo.channelNum.isEmpty()) {\n+                logger.debug(\"{}: EVENT_EIT_CHANGE for channel {}/{}\", thingId, pinfo.channelNum, pinfo.channelCode);\n+                updateState(CHANNEL_CHANNEL, new DecimalType(pinfo.channelNum));\n+                updateState(CHANNEL_CHANNEL_CODE, new DecimalType(pinfo.channelCode));\n+            }\n+            if (pinfo.programInfo != null) {\n+                int i = 0;\n+                for (MRProgramStatus ps : pinfo.programInfo) {\n+                    if ((ps.startTime == null) || ps.startTime.isEmpty()) {\n+                        logger.debug(\"{}: EVENT_EIT_CHANGE: empty event data = {}\", thingId, jsonEvent);\n+                        continue; // empty program_info\n+                    }\n+                    updateState(CHANNEL_RUN_STATUS, new StringType(control.getRunStatus(ps.runningStatus)));\n+\n+                    if (ps.shortEvent != null) {\n+                        for (MRShortProgramInfo se : ps.shortEvent) {\n+                            if ((ps.startTime == null) || ps.startTime.isEmpty()) {\n+                                logger.debug(\"{}: EVENT_EIT_CHANGE: empty program info\", thingId);\n+                                continue;\n+                            }\n+                            // Convert UTC to local time\n+                            // 2018/11/04 21:45:00 -> \"2018-11-04T10:15:30.00Z\"\n+                            String tsLocal = ps.startTime.replace('/', '-').replace(\" \", \"T\") + \"Z\";\n+                            Instant timestamp = Instant.parse(tsLocal);\n+                            ZonedDateTime localTime = timestamp.atZone(ZoneId.of(\"Europe/Berlin\"));\n+                            tsLocal = substringBeforeLast(localTime.toString(), \"[\");\n+                            tsLocal = substringBefore(tsLocal.replace('-', '/').replace('T', ' '), \"+\");\n+\n+                            logger.debug(\"{}: Info for channel {} / {} - {} {}.{}, start time={}, duration={}\", thingId,\n+                                    pinfo.channelNum, pinfo.channelCode, control.getRunStatus(ps.runningStatus),\n+                                    se.eventName, se.textChar, tsLocal, ps.duration);\n+                            if (ps.runningStatus != EV_EITCHG_RUNNING_NOT_RUNNING) {\n+                                updateState(CHANNEL_PROG_TITLE, new StringType(se.eventName));\n+                                updateState(CHANNEL_PROG_TEXT, new StringType(se.textChar));\n+                                updateState(CHANNEL_PROG_START, new DateTimeType(localTime));\n+\n+                                try {\n+                                    DateFormat dateFormat = new SimpleDateFormat(\"HH:mm:ss\");\n+                                    dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+                                    Date date = dateFormat.parse(ps.duration);\n+                                    long minutes = date.getTime() / 1000L / 60l;\n+                                    updateState(CHANNEL_PROG_DURATION, toQuantityType(minutes, SmartHomeUnits.MINUTE));\n+                                } catch (ParseException e) {\n+                                    logger.debug(\"{}: Unable to parse programDuration: {}\", thingId, ps.duration);\n+                                }\n+\n+                                if (i++ == 0) {\n+                                    flUpdatePower = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        } else if (jsonEvent.contains(\"new_play_mode\")) {\n+            MRPayEvent event = gson.fromJson(jsonEvent, MRPayEvent.class);\n+            if (event.duration == null) {\n+                event.duration = -1;\n+            }\n+            if (event.playPostion == null) {\n+                event.playPostion = -1;\n+            }\n+            logger.debug(\"{}: STB event playContent: playMode={}, duration={}, playPosition={}\", thingId,\n+                    control.getPlayStatus(event.newPlayMode), event.duration, event.playPostion);\n+\n+            // If we get a playConfig event there MR must be online. However it also sends a\n+            // plyMode stop before powering off the device, so we filter this.\n+            if ((event.newPlayMode != EV_PLAYCHG_STOP) && this.isInitialized()) {\n+                flUpdatePower = true;\n+            }\n+            if (event.newPlayMode != -1) {\n+                String playMode = control.getPlayStatus(event.newPlayMode);\n+                updateState(CHANNEL_PLAY_MODE, new StringType(playMode));\n+                mapPlayModeToMediaControl(playMode);\n+            }\n+            if (event.duration > 0) {\n+                updateState(CHANNEL_PROG_DURATION, new StringType(event.duration.toString()));\n+            }\n+            if (event.playPostion != -1) {\n+                updateState(CHANNEL_PROG_POS, toQuantityType(event.playPostion / 6, SmartHomeUnits.MINUTE));\n+            }\n+        } else {\n+            logger.debug(\"{}: Unknown MR event, JSON={}\", thingId, jsonEvent);\n+        }\n+        if (flUpdatePower) {\n+            // We received a non-stopped event -> MR must be on\n+            updateState(CHANNEL_POWER, OnOffType.ON);\n+        }\n+    }\n+\n+    private void mapPlayModeToMediaControl(String playMode) {\n+        switch (playMode) {\n+            case \"playing\":\n+            case \"playing (MC)\":\n+            case \"playing (UC)\":\n+            case \"buffering\":\n+                logger.debug(\"{}: Setting Player state to PLAY\", thingId);\n+                updateState(CHANNEL_PLAYER, PlayPauseType.PLAY);\n+            case \"paused\":\n+            case \"stopped\":\n+                logger.debug(\"{}: Setting Player state to PAUSE\", thingId);\n+                updateState(CHANNEL_PLAYER, PlayPauseType.PAUSE);\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * When the MR powers off it send a UPnP message, which is catched by the binding.\n+     */\n+    @Override\n+    public void onPowerOff() throws MagentaTVException {\n+        logger.debug(\"{}: Power-Off received for device {}\", thingId, deviceName());\n+        // MR was powered off -> update pwoer status, reset items\n+        resetEventChannels();\n+    }\n+\n+    private void resetEventChannels() {\n+        updateState(CHANNEL_POWER, OnOffType.OFF);\n+        updateState(CHANNEL_PROG_TITLE, StringType.EMPTY);\n+        updateState(CHANNEL_PROG_TEXT, StringType.EMPTY);\n+        updateState(CHANNEL_PROG_START, StringType.EMPTY);\n+        updateState(CHANNEL_PROG_DURATION, ZERO);\n+        updateState(CHANNEL_PROG_POS, ZERO);\n+        updateState(CHANNEL_CHANNEL, ZERO);\n+        updateState(CHANNEL_CHANNEL_CODE, ZERO);\n+    }\n+\n+    private String fixEventJson(String jsonEvent) {\n+        // MR401: channel_num is a string -> ok\n+        // MR201: channel_num is an int -> fix JSON formatting to String\n+        if (jsonEvent.contains(MR_EVENT_CHAN_TAG) && !jsonEvent.contains(MR_EVENT_CHAN_TAG + \"\\\"\")) {\n+            // hack: reformat the JSON string to make it compatible with the GSON parsing\n+            logger.trace(\"{}: malformed JSON->fix channel_num\", thingId);\n+            String start = substringBefore(jsonEvent, MR_EVENT_CHAN_TAG); // up to \"channel_num\":\n+            String end = substringAfter(jsonEvent, MR_EVENT_CHAN_TAG); // behind \"channel_num\":\n+            String chan = substringBetween(jsonEvent, MR_EVENT_CHAN_TAG, \",\").trim();\n+            return start + \"\\\"channel_num\\\":\" + \"\\\"\" + chan + \"\\\"\" + end;\n+        }\n+        return jsonEvent;\n+    }\n+\n+    private boolean isOnline() {\n+        return this.getThing().getStatus() == ThingStatus.ONLINE;\n+    }\n+\n+    /**\n+     * Check device status, if pairing\n+     * events (if callbackUrl is configured)", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMzOTkxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484339914", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-07T10:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDUxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484120510", "bodyText": "please add JavaDoc on interface methods.", "author": "kaikreuzer", "createdAt": "2020-09-06T22:21:53Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVListener.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+\n+/**\n+ * The {@link MagentaTVListener} defines the interface to pass back the pairing\n+ * code to the listener class\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface MagentaTVListener {\n+    public void onPairingResult(String pairingCode) throws MagentaTVException;", "originalCommit": "24ab87b393984666c2e12790c244d984956536fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM0MjkxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484342914", "bodyText": "done", "author": "markus7017", "createdAt": "2020-09-07T10:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDEyMDUxMA=="}], "type": "inlineReview"}, {"oid": "147e74134dc08daf5b7ae3e8c9be54073c4f42e1", "url": "https://github.com/openhab/openhab-addons/commit/147e74134dc08daf5b7ae3e8c9be54073c4f42e1", "message": "fix substringBetween()\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-07T08:05:40Z", "type": "commit"}, {"oid": "42efadedaaa1ebc87b855642fda15442346186b1", "url": "https://github.com/openhab/openhab-addons/commit/42efadedaaa1ebc87b855642fda15442346186b1", "message": "review changes applied\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-07T10:43:43Z", "type": "commit"}, {"oid": "562a3aa50d07f07e42436fdb0677d91f30a391ef", "url": "https://github.com/openhab/openhab-addons/commit/562a3aa50d07f07e42436fdb0677d91f30a391ef", "message": "Move device table management to new service MagentaTVDeviceManager\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-07T15:15:47Z", "type": "commit"}, {"oid": "eb50ceb7cbea76ddf4a7412726a28b6b9d87c31a", "url": "https://github.com/openhab/openhab-addons/commit/eb50ceb7cbea76ddf4a7412726a28b6b9d87c31a", "message": "Sitem,ap example added to README\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-07T16:54:32Z", "type": "commit"}, {"oid": "08eb16a8c537114b18dbab20aeb9f4e2f1d08fc6", "url": "https://github.com/openhab/openhab-addons/commit/08eb16a8c537114b18dbab20aeb9f4e2f1d08fc6", "message": "Missing author tag added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-07T17:04:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1Mzg1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484553857", "bodyText": "Typo, should be OAuthAuthenticateResponse", "author": "kaikreuzer", "createdAt": "2020-09-07T19:44:23Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVGsonDTO.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.InstanceCreator;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link MagentaTVGsonDTO} class implements The MR returns event information every time the program changes. This\n+ * information is mapped to various Thing channels and also used to catch the power down event for MR400 (there is no\n+ * way to query power status). This class provides the mapping between event JSON and Java class using Gson.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+public class MagentaTVGsonDTO {\n+    /*\n+     * Program information event is send by the MR when a channel is changed.\n+     *\n+     * Sample data:\n+     * {\"type\":\"EVENT_EIT_CHANGE\",\"instance_id\":26,\"channel_code\":\"54\",\"channel_num\":\"11\",\"mediaId\":\"1221\",\n+     * \"program_info\": [ {\"start_time\":\"2018/10/14 10:21:59\",\"event_id\":\"9581\",\"duration\":\"00:26:47\",\n+     * \"free_CA_mode\":false,\"running_status\":4, \"short_event\": [{\"event_name\":\"Mysticons\",\"language_code\":\"DEU\",\n+     * \"text_char\":\"Die Mysticons...\" } ]},\n+     * {\"start_time\":\"2018/10/14 10:48:46\",\"event_id\":\"12204\",\"duration\":\"00:23:54\",\"free_CA_mode\":false,\n+     * \"running_status\":1, \"short_event\": [ {\"event_name\":\"Winx Club\",\"language_code\":\"DEU\", \"text_char\":\"Daphnes Eltern\n+     * veranstalten...!\" }]} ] }\n+     */\n+    // The following classes are used to map the JSON data into objects using GSon.\n+    public static class MRProgramInfoEvent {\n+        @SerializedName(\"type\")\n+        public String type = \"\";\n+        @SerializedName(\"instance_id\")\n+        public Integer instanceId = 0;\n+        @SerializedName(\"channel_code\")\n+        public String channelCode = \"\";\n+        @SerializedName(\"channel_num\")\n+        public String channelNum = \"\";\n+        @SerializedName(\"mediaId\")\n+        public String mediaId = \"\";\n+        @SerializedName(\"program_info\")\n+        public ArrayList<MRProgramStatus> programInfo = new ArrayList<>();\n+    }\n+\n+    public static class MRProgramInfoEventInstanceCreator implements InstanceCreator<MRProgramInfoEvent> {\n+        @Override\n+        public MRProgramInfoEvent createInstance(@Nullable Type type) {\n+            return new MRProgramInfoEvent();\n+        }\n+    }\n+\n+    public static class MRProgramStatus {\n+        @SerializedName(\"start_time\")\n+        public String startTime = \"\";\n+        @SerializedName(\"event_id\")\n+        public String eventId = \"\";\n+        @SerializedName(\"duration\")\n+        public String duration = \"\";\n+        @SerializedName(\"free_CA_mode\")\n+        public Boolean freeCAMmode = false;\n+        @SerializedName(\"running_status\")\n+        public Integer runningStatus = EV_EITCHG_RUNNING_NONE;\n+        @SerializedName(\"short_event\")\n+        public ArrayList<MRShortProgramInfo> shortEvent = new ArrayList<>();\n+    }\n+\n+    public static class MRProgramStatusInstanceCreator implements InstanceCreator<MRProgramStatus> {\n+        @Override\n+        public MRProgramStatus createInstance(@Nullable Type type) {\n+            return new MRProgramStatus();\n+        }\n+    }\n+\n+    public static class MRShortProgramInfo {\n+        @SerializedName(\"event_name\")\n+        public String eventName = \"\";\n+        @SerializedName(\"language_code\")\n+        public String languageCode = \"\";\n+        @SerializedName(\"text_char\")\n+        public String textChar = \"\";\n+    }\n+\n+    public static class MRShortProgramInfoInstanceCreator implements InstanceCreator<MRShortProgramInfo> {\n+        @Override\n+        public MRShortProgramInfo createInstance(@Nullable Type type) {\n+            return new MRShortProgramInfo();\n+        }\n+    }\n+\n+    /**\n+     * playStatus event format (JSON) playContent event, for details see\n+     * http://support.huawei.com/hedex/pages/DOC1100366313CEH0713H/01/DOC1100366313CEH0713H/01/resources/dsv_hdx_idp/DSV/en/en-us_topic_0094619231.html\n+     *\n+     * sample 1: {\"new_play_mode\":4,\"duration\":0,\"playBackState\":1,\"mediaType\":1,\"mediaCode\":\"3733\",\"playPostion\":0}\n+     * sample 2: {\"new_play_mode\":4, \"playBackState\":1,\"mediaType\":1,\"mediaCode\":\"3479\"}\n+     */\n+    public static class MRPayEvent {\n+        @SerializedName(\"new_play_mode\")\n+        public Integer newPlayMode = EV_PLAYCHG_STOP;\n+        public Integer duration = -1;\n+        public Integer playBackState = EV_PLAYCHG_STOP;\n+        public Integer mediaType = 0;\n+        public String mediaCode = \"\";\n+        public Integer playPostion = -1;\n+    }\n+\n+    public static class MRPayEventInstanceCreator implements InstanceCreator<MRPayEvent> {\n+        @Override\n+        public MRPayEvent createInstance(@Nullable Type type) {\n+            return new MRPayEvent();\n+        }\n+    }\n+\n+    /**\n+     * Deutsche Telekom uses a OAuth-based authentication to access the EPG portal.\n+     * The binding automates the login incl. OAuth authentication. This class helps mapping the response to a Java\n+     * object (using Gson)\n+     *\n+     * Sample response:\n+     * { \"enctytoken\":\"7FA9A6C05EDD873799392BBDDC5B7F34\",\"encryptiontype\":\"0002\",\n+     * \"platformcode\":\"0200\", \"epgurl\":\"http://appepmfk20005.prod.sngtv.t-online.de:33200\",\n+     * \"version\":\"MEM V200R008C15B070\", \"epghttpsurl\":\"https://appepmfk20005.prod.sngtv.t-online.de:33207\",\n+     * \"rootCerAddr\": \"http://appepmfk20005.prod.sngtv.t-online.de:33200/EPG/CA/iptv_ca.der\",\n+     * \"upgAddr4IPTV\":\"https://slbedifk11100.prod.sngtv.t-online.de:33428/EDS/jsp/upgrade.jsp\",\n+     * \"upgAddr4OTT\":\"https://slbedmfk11100.prod.sngtv.t-online.de:33428/EDS/jsp/upgrade.jsp,https://slbedmfk11100.prod.sngtv.t-online.de:33428/EDS/jsp/upgrade.jsp\",\n+     * \"sam3Para\": [\n+     * {\"key\":\"SAM3ServiceURL\",\"value\":\"https://accounts.login.idm.telekom.com\"},\n+     * {\"key\":\"OAuthClientSecret\",\"value\":\"21EAB062-C4EE-489C-BC80-6A65397F3F96\"},\n+     * {\"key\":\"OAuthScope\",\"value\":\"ngtvepg\"},\n+     * {\"key\":\"OAuthClientId\",\"value\":\"10LIVESAM30000004901NGTV0000000000000000\"} ]\n+     * }\n+     */\n+    public static class OauthCredentials {\n+        public String epghttpsurl = \"\";\n+        public ArrayList<OauthKeyValue> sam3Para = new ArrayList<OauthKeyValue>();\n+    }\n+\n+    public static class OauthCredentialsInstanceCreator implements InstanceCreator<OauthCredentials> {\n+        @Override\n+        public OauthCredentials createInstance(@Nullable Type type) {\n+            return new OauthCredentials();\n+        }\n+    }\n+\n+    public static class OauthKeyValue {\n+        public String key = \"\";\n+        public String value = \"\";\n+    }\n+\n+    public static class OAuthTokenResponse {\n+        @SerializedName(\"error_description\")\n+        public String errorDescription = \"\";\n+        public String error = \"\";\n+        @SerializedName(\"access_token\")\n+        public String accessToken = \"\";\n+    }\n+\n+    public static class OAuthTokenResponseInstanceCreator implements InstanceCreator<OAuthTokenResponse> {\n+        @Override\n+        public OAuthTokenResponse createInstance(@Nullable Type type) {\n+            return new OAuthTokenResponse();\n+        }\n+    }\n+\n+    public static class OAuthAutenhicateResponse {", "originalCommit": "08eb16a8c537114b18dbab20aeb9f4e2f1d08fc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2MDcxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484560717", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-09-07T20:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1Mzg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1Mzg5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484553893", "bodyText": "Typo, should be OAuthAuthenticateResponseInstanceCreator", "author": "kaikreuzer", "createdAt": "2020-09-07T19:44:37Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVGsonDTO.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.InstanceCreator;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@link MagentaTVGsonDTO} class implements The MR returns event information every time the program changes. This\n+ * information is mapped to various Thing channels and also used to catch the power down event for MR400 (there is no\n+ * way to query power status). This class provides the mapping between event JSON and Java class using Gson.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+public class MagentaTVGsonDTO {\n+    /*\n+     * Program information event is send by the MR when a channel is changed.\n+     *\n+     * Sample data:\n+     * {\"type\":\"EVENT_EIT_CHANGE\",\"instance_id\":26,\"channel_code\":\"54\",\"channel_num\":\"11\",\"mediaId\":\"1221\",\n+     * \"program_info\": [ {\"start_time\":\"2018/10/14 10:21:59\",\"event_id\":\"9581\",\"duration\":\"00:26:47\",\n+     * \"free_CA_mode\":false,\"running_status\":4, \"short_event\": [{\"event_name\":\"Mysticons\",\"language_code\":\"DEU\",\n+     * \"text_char\":\"Die Mysticons...\" } ]},\n+     * {\"start_time\":\"2018/10/14 10:48:46\",\"event_id\":\"12204\",\"duration\":\"00:23:54\",\"free_CA_mode\":false,\n+     * \"running_status\":1, \"short_event\": [ {\"event_name\":\"Winx Club\",\"language_code\":\"DEU\", \"text_char\":\"Daphnes Eltern\n+     * veranstalten...!\" }]} ] }\n+     */\n+    // The following classes are used to map the JSON data into objects using GSon.\n+    public static class MRProgramInfoEvent {\n+        @SerializedName(\"type\")\n+        public String type = \"\";\n+        @SerializedName(\"instance_id\")\n+        public Integer instanceId = 0;\n+        @SerializedName(\"channel_code\")\n+        public String channelCode = \"\";\n+        @SerializedName(\"channel_num\")\n+        public String channelNum = \"\";\n+        @SerializedName(\"mediaId\")\n+        public String mediaId = \"\";\n+        @SerializedName(\"program_info\")\n+        public ArrayList<MRProgramStatus> programInfo = new ArrayList<>();\n+    }\n+\n+    public static class MRProgramInfoEventInstanceCreator implements InstanceCreator<MRProgramInfoEvent> {\n+        @Override\n+        public MRProgramInfoEvent createInstance(@Nullable Type type) {\n+            return new MRProgramInfoEvent();\n+        }\n+    }\n+\n+    public static class MRProgramStatus {\n+        @SerializedName(\"start_time\")\n+        public String startTime = \"\";\n+        @SerializedName(\"event_id\")\n+        public String eventId = \"\";\n+        @SerializedName(\"duration\")\n+        public String duration = \"\";\n+        @SerializedName(\"free_CA_mode\")\n+        public Boolean freeCAMmode = false;\n+        @SerializedName(\"running_status\")\n+        public Integer runningStatus = EV_EITCHG_RUNNING_NONE;\n+        @SerializedName(\"short_event\")\n+        public ArrayList<MRShortProgramInfo> shortEvent = new ArrayList<>();\n+    }\n+\n+    public static class MRProgramStatusInstanceCreator implements InstanceCreator<MRProgramStatus> {\n+        @Override\n+        public MRProgramStatus createInstance(@Nullable Type type) {\n+            return new MRProgramStatus();\n+        }\n+    }\n+\n+    public static class MRShortProgramInfo {\n+        @SerializedName(\"event_name\")\n+        public String eventName = \"\";\n+        @SerializedName(\"language_code\")\n+        public String languageCode = \"\";\n+        @SerializedName(\"text_char\")\n+        public String textChar = \"\";\n+    }\n+\n+    public static class MRShortProgramInfoInstanceCreator implements InstanceCreator<MRShortProgramInfo> {\n+        @Override\n+        public MRShortProgramInfo createInstance(@Nullable Type type) {\n+            return new MRShortProgramInfo();\n+        }\n+    }\n+\n+    /**\n+     * playStatus event format (JSON) playContent event, for details see\n+     * http://support.huawei.com/hedex/pages/DOC1100366313CEH0713H/01/DOC1100366313CEH0713H/01/resources/dsv_hdx_idp/DSV/en/en-us_topic_0094619231.html\n+     *\n+     * sample 1: {\"new_play_mode\":4,\"duration\":0,\"playBackState\":1,\"mediaType\":1,\"mediaCode\":\"3733\",\"playPostion\":0}\n+     * sample 2: {\"new_play_mode\":4, \"playBackState\":1,\"mediaType\":1,\"mediaCode\":\"3479\"}\n+     */\n+    public static class MRPayEvent {\n+        @SerializedName(\"new_play_mode\")\n+        public Integer newPlayMode = EV_PLAYCHG_STOP;\n+        public Integer duration = -1;\n+        public Integer playBackState = EV_PLAYCHG_STOP;\n+        public Integer mediaType = 0;\n+        public String mediaCode = \"\";\n+        public Integer playPostion = -1;\n+    }\n+\n+    public static class MRPayEventInstanceCreator implements InstanceCreator<MRPayEvent> {\n+        @Override\n+        public MRPayEvent createInstance(@Nullable Type type) {\n+            return new MRPayEvent();\n+        }\n+    }\n+\n+    /**\n+     * Deutsche Telekom uses a OAuth-based authentication to access the EPG portal.\n+     * The binding automates the login incl. OAuth authentication. This class helps mapping the response to a Java\n+     * object (using Gson)\n+     *\n+     * Sample response:\n+     * { \"enctytoken\":\"7FA9A6C05EDD873799392BBDDC5B7F34\",\"encryptiontype\":\"0002\",\n+     * \"platformcode\":\"0200\", \"epgurl\":\"http://appepmfk20005.prod.sngtv.t-online.de:33200\",\n+     * \"version\":\"MEM V200R008C15B070\", \"epghttpsurl\":\"https://appepmfk20005.prod.sngtv.t-online.de:33207\",\n+     * \"rootCerAddr\": \"http://appepmfk20005.prod.sngtv.t-online.de:33200/EPG/CA/iptv_ca.der\",\n+     * \"upgAddr4IPTV\":\"https://slbedifk11100.prod.sngtv.t-online.de:33428/EDS/jsp/upgrade.jsp\",\n+     * \"upgAddr4OTT\":\"https://slbedmfk11100.prod.sngtv.t-online.de:33428/EDS/jsp/upgrade.jsp,https://slbedmfk11100.prod.sngtv.t-online.de:33428/EDS/jsp/upgrade.jsp\",\n+     * \"sam3Para\": [\n+     * {\"key\":\"SAM3ServiceURL\",\"value\":\"https://accounts.login.idm.telekom.com\"},\n+     * {\"key\":\"OAuthClientSecret\",\"value\":\"21EAB062-C4EE-489C-BC80-6A65397F3F96\"},\n+     * {\"key\":\"OAuthScope\",\"value\":\"ngtvepg\"},\n+     * {\"key\":\"OAuthClientId\",\"value\":\"10LIVESAM30000004901NGTV0000000000000000\"} ]\n+     * }\n+     */\n+    public static class OauthCredentials {\n+        public String epghttpsurl = \"\";\n+        public ArrayList<OauthKeyValue> sam3Para = new ArrayList<OauthKeyValue>();\n+    }\n+\n+    public static class OauthCredentialsInstanceCreator implements InstanceCreator<OauthCredentials> {\n+        @Override\n+        public OauthCredentials createInstance(@Nullable Type type) {\n+            return new OauthCredentials();\n+        }\n+    }\n+\n+    public static class OauthKeyValue {\n+        public String key = \"\";\n+        public String value = \"\";\n+    }\n+\n+    public static class OAuthTokenResponse {\n+        @SerializedName(\"error_description\")\n+        public String errorDescription = \"\";\n+        public String error = \"\";\n+        @SerializedName(\"access_token\")\n+        public String accessToken = \"\";\n+    }\n+\n+    public static class OAuthTokenResponseInstanceCreator implements InstanceCreator<OAuthTokenResponse> {\n+        @Override\n+        public OAuthTokenResponse createInstance(@Nullable Type type) {\n+            return new OAuthTokenResponse();\n+        }\n+    }\n+\n+    public static class OAuthAutenhicateResponse {\n+        public String retcode = \"\";\n+        public String desc = \"\";\n+        public String epgurl = \"\";\n+        public String userID = \"\";\n+    }\n+\n+    public static class OAuthAutenhicateResponseInstanceCreator implements InstanceCreator<OAuthAutenhicateResponse> {", "originalCommit": "08eb16a8c537114b18dbab20aeb9f4e2f1d08fc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2MDg2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r484560861", "bodyText": "fixed", "author": "markus7017", "createdAt": "2020-09-07T20:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU1Mzg5Mw=="}], "type": "inlineReview"}, {"oid": "88a55700b0b45b2b90c98859017e3e0ef22c2d99", "url": "https://github.com/openhab/openhab-addons/commit/88a55700b0b45b2b90c98859017e3e0ef22c2d99", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-07T20:31:00Z", "type": "commit"}, {"oid": "f915bf117c57dba81f30d633e5e027f97a3d5e35", "url": "https://github.com/openhab/openhab-addons/commit/f915bf117c57dba81f30d633e5e027f97a3d5e35", "message": "magentatv added to CODEOWNERS and pom.xml; NOTICE added to binding\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-09T20:09:24Z", "type": "commit"}, {"oid": "2ffd55936060aff091bd0436e209065099e0f545", "url": "https://github.com/openhab/openhab-addons/commit/2ffd55936060aff091bd0436e209065099e0f545", "message": "German translation of thing description added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-10T23:30:45Z", "type": "commit"}, {"oid": "0ad5261b5fdd8129e589874cd325069ac424a39d", "url": "https://github.com/openhab/openhab-addons/commit/0ad5261b5fdd8129e589874cd325069ac424a39d", "message": "spotless applied\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-11T08:58:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MDM3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487560376", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = ConsoleCommandExtension.class, immediate = true)\n          \n          \n            \n            @Component(service = ConsoleCommandExtension.class)", "author": "Hilbrand", "createdAt": "2020-09-13T18:20:18Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVConsoleHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.BINDING_ID;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Console commands for interacting with the MagentaTV binding\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ConsoleCommandExtension.class, immediate = true)", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MzE5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487883194", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T12:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MDM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MDU2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487560560", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = MagentaTVDeviceManager.class, immediate = true)\n          \n          \n            \n            @Component(service = MagentaTVDeviceManager.class)", "author": "Hilbrand", "createdAt": "2020-09-13T18:22:30Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVDeviceManager.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.substringAfterLast;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.magentatv.internal.handler.MagentaTVHandler;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVDeviceManager} class manages the device table (shared between HandlerFactory and Thing handlers).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MagentaTVDeviceManager.class, immediate = true)", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MjkyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487882923", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T12:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MDU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MDU4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487560586", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Map<String, MagentaTVDevice> deviceList = new HashMap<String, MagentaTVDevice>();\n          \n          \n            \n                private final Map<String, MagentaTVDevice> deviceList = new HashMap<>();", "author": "Hilbrand", "createdAt": "2020-09-13T18:22:47Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVDeviceManager.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.substringAfterLast;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.magentatv.internal.handler.MagentaTVHandler;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVDeviceManager} class manages the device table (shared between HandlerFactory and Thing handlers).\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = MagentaTVDeviceManager.class, immediate = true)\n+public class MagentaTVDeviceManager {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVDeviceManager.class);\n+\n+    protected class MagentaTVDevice {\n+        protected String udn = \"\";\n+        protected String mac = \"\";\n+        protected String deviceId = \"\";\n+        protected String ipAddress = \"\";\n+        protected Map<String, String> properties = new HashMap<>();\n+        protected @Nullable MagentaTVHandler thingHandler;\n+    }\n+\n+    private final Map<String, MagentaTVDevice> deviceList = new HashMap<String, MagentaTVDevice>();", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MzU4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487883588", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T12:46:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MDU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MTExNw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487561117", "bodyText": "If you add an excetion no need to add {} an use toString:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.warn(\"Initialization failed: {}\", e.toString());\n          \n          \n            \n                        logger.warn(\"Initialization failed: \", e);", "author": "Hilbrand", "createdAt": "2020-09-13T18:28:09Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVHandlerFactory.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.net.HttpServiceUtil;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.magentatv.internal.MagentaTVDeviceManager.MagentaTVDevice;\n+import org.openhab.binding.magentatv.internal.handler.MagentaTVHandler;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVPoweroffListener;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class, MagentaTVHandlerFactory.class }, configurationPid = \"binding.\"\n+        + BINDING_ID)\n+public class MagentaTVHandlerFactory extends BaseThingHandlerFactory {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandlerFactory.class);\n+\n+    private final MagentaTVNetwork network = new MagentaTVNetwork();\n+    private final MagentaTVDeviceManager manager;\n+    private @Nullable MagentaTVPoweroffListener upnpListener;\n+    private boolean servletInitialized = false;\n+\n+    /**\n+     * Activate the bundle: save properties\n+     *\n+     * @param componentContext\n+     * @param configProperties set of properties from cfg (use same names as in\n+     *            thing config)\n+     */\n+\n+    @Activate\n+    public MagentaTVHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            @Reference MagentaTVDeviceManager manager, ComponentContext componentContext,\n+            Map<String, String> configProperties) throws IOException {\n+        super.activate(componentContext);\n+        this.manager = manager;\n+\n+        try {\n+            logger.debug(\"Initialize network access\");\n+            System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n+            String lip = networkAddressService.getPrimaryIpv4HostAddress();\n+            Integer port = HttpServiceUtil.getHttpServicePort(componentContext.getBundleContext());\n+            if (port == -1) {\n+                port = 8080;\n+            }\n+            network.initLocalNet(lip != null ? lip : \"\", port.toString());\n+            upnpListener = new MagentaTVPoweroffListener(this, network.getLocalInterface());\n+        } catch (MagentaTVException e) {\n+            logger.warn(\"Initialization failed: {}\", e.toString());", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MzkyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487883925", "bodyText": "not changed\nI don't want to have the stack trace here, only the message", "author": "markus7017", "createdAt": "2020-09-14T12:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MTExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MTM4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487561381", "bodyText": "Maybe put it in the try above to auto close the stream when finished:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n          \n          \n            \n                                        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in)) {", "author": "Hilbrand", "createdAt": "2020-09-13T18:30:27Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVConsoleHandler.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.BINDING_ID;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.ws.rs.client.ClientBuilder;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Console commands for interacting with the MagentaTV binding\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ConsoleCommandExtension.class, immediate = true)\n+public class MagentaTVConsoleHandler extends AbstractConsoleCommandExtension {\n+\n+    private static final String CMD_LOGIN = \"login\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVConsoleHandler.class);\n+    private final MagentaTVOAuth oauth = new MagentaTVOAuth();\n+\n+    @Reference(cardinality = ReferenceCardinality.OPTIONAL)\n+    private @Nullable ClientBuilder injectedClientBuilder;\n+\n+    @Activate\n+    public MagentaTVConsoleHandler() {\n+        super(BINDING_ID, \"Interact with the \" + BINDING_ID + \" integration.\");\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length > 0) {\n+            String subCommand = args[0];\n+            switch (subCommand) {\n+                case CMD_LOGIN:\n+                    if (args.length == 1) {\n+                        try {\n+                            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5ODc1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488298755", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T23:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MTM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MTY5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487561690", "bodyText": "Maybe move the start start also only when an actual handler is returned.", "author": "Hilbrand", "createdAt": "2020-09-13T18:33:07Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/MagentaTVHandlerFactory.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.net.HttpServiceUtil;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.magentatv.internal.MagentaTVDeviceManager.MagentaTVDevice;\n+import org.openhab.binding.magentatv.internal.handler.MagentaTVHandler;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVPoweroffListener;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { ThingHandlerFactory.class, MagentaTVHandlerFactory.class }, configurationPid = \"binding.\"\n+        + BINDING_ID)\n+public class MagentaTVHandlerFactory extends BaseThingHandlerFactory {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandlerFactory.class);\n+\n+    private final MagentaTVNetwork network = new MagentaTVNetwork();\n+    private final MagentaTVDeviceManager manager;\n+    private @Nullable MagentaTVPoweroffListener upnpListener;\n+    private boolean servletInitialized = false;\n+\n+    /**\n+     * Activate the bundle: save properties\n+     *\n+     * @param componentContext\n+     * @param configProperties set of properties from cfg (use same names as in\n+     *            thing config)\n+     */\n+\n+    @Activate\n+    public MagentaTVHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            @Reference MagentaTVDeviceManager manager, ComponentContext componentContext,\n+            Map<String, String> configProperties) throws IOException {\n+        super.activate(componentContext);\n+        this.manager = manager;\n+\n+        try {\n+            logger.debug(\"Initialize network access\");\n+            System.setProperty(\"java.net.preferIPv4Stack\", \"true\");\n+            String lip = networkAddressService.getPrimaryIpv4HostAddress();\n+            Integer port = HttpServiceUtil.getHttpServicePort(componentContext.getBundleContext());\n+            if (port == -1) {\n+                port = 8080;\n+            }\n+            network.initLocalNet(lip != null ? lip : \"\", port.toString());\n+            upnpListener = new MagentaTVPoweroffListener(this, network.getLocalInterface());\n+        } catch (MagentaTVException e) {\n+            logger.warn(\"Initialization failed: {}\", e.toString());\n+        }\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (upnpListener != null) {\n+            upnpListener.start();", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5OTI2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488299267", "bodyText": "that seems overdriven, I would it leave as is", "author": "markus7017", "createdAt": "2020-09-14T23:49:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MTY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2Mjc4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487562788", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = UpnpDiscoveryParticipant.class, immediate = true)\n          \n          \n            \n            @Component(service = UpnpDiscoveryParticipant.class)", "author": "Hilbrand", "createdAt": "2020-09-13T18:43:50Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/discovery/MagentaTVDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.discovery;\n+\n+import static org.eclipse.smarthome.core.thing.Thing.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.upnp.UpnpDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.jupnp.model.meta.RemoteDevice;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVDiscoveryParticipant} is responsible for discovering new\n+ * and removed MagentaTV receivers. It uses the central UpnpDiscoveryService.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = UpnpDiscoveryParticipant.class, immediate = true)", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5OTQwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488299402", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T23:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2Mjc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2Mjg3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487562870", "bodyText": "Can you catch the specific exception here?", "author": "Hilbrand", "createdAt": "2020-09-13T18:44:40Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/discovery/MagentaTVDiscoveryParticipant.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.discovery;\n+\n+import static org.eclipse.smarthome.core.thing.Thing.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.upnp.UpnpDiscoveryParticipant;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.jupnp.model.meta.RemoteDevice;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVDiscoveryParticipant} is responsible for discovering new\n+ * and removed MagentaTV receivers. It uses the central UpnpDiscoveryService.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = UpnpDiscoveryParticipant.class, immediate = true)\n+public class MagentaTVDiscoveryParticipant implements UpnpDiscoveryParticipant {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVDiscoveryParticipant.class);\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypeUIDs() {\n+        return Collections.singleton(THING_TYPE_RECEIVER);\n+    }\n+\n+    /**\n+     * New discovered result.\n+     */\n+    @Override\n+    public @Nullable DiscoveryResult createResult(RemoteDevice device) {\n+        DiscoveryResult result = null;\n+        try {\n+            String modelName = getString(device.getDetails().getModelDetails().getModelName()).toUpperCase();\n+            String manufacturer = getString(device.getDetails().getManufacturerDetails().getManufacturer())\n+                    .toUpperCase();\n+            logger.trace(\"Device discovered: {} - {}\", manufacturer, modelName);\n+\n+            ThingUID uid = getThingUID(device);\n+            if (uid != null) {\n+                logger.debug(\"Discovered an MagentaTV Media Receiver {}, UDN: {}, Model {}.{}\",\n+                        device.getDetails().getFriendlyName(), device.getIdentity().getUdn().getIdentifierString(),\n+                        modelName, device.getDetails().getModelDetails().getModelNumber());\n+\n+                Map<String, Object> properties = new TreeMap<>();\n+                String descriptorURL = device.getIdentity().getDescriptorURL().toString();\n+                String port = substringBefore(substringAfterLast(descriptorURL, \":\"), \"/\");\n+                String hex = device.getIdentity().getUdn().getIdentifierString()\n+                        .substring(device.getIdentity().getUdn().getIdentifierString().length() - 12);\n+                String mac = hex.substring(0, 2) + \":\" + hex.substring(2, 4) + \":\" + hex.substring(4, 6) + \":\"\n+                        + hex.substring(6, 8) + \":\" + hex.substring(8, 10) + \":\" + hex.substring(10, 12);\n+                properties.put(PROPERTY_VENDOR, VENDOR + \"(\" + manufacturer + \")\");\n+                properties.put(PROPERTY_MODEL_ID, modelName);\n+                properties.put(PROPERTY_HARDWARE_VERSION, device.getDetails().getModelDetails().getModelNumber());\n+                properties.put(PROPERTY_MAC_ADDRESS, mac);\n+                properties.put(PROPERTY_UDN, device.getIdentity().getUdn().getIdentifierString().toUpperCase());\n+                properties.put(PROPERTY_IP, substringBetween(descriptorURL, \"http://\", \":\"));\n+                properties.put(PROPERTY_PORT, port);\n+                properties.put(PROPERTY_DESC_URL, substringAfterLast(descriptorURL, \":\" + port));\n+\n+                logger.debug(\"Create Thing for device {} with UDN {}, Model{}\", device.getDetails().getFriendlyName(),\n+                        device.getIdentity().getUdn().getIdentifierString(), modelName);\n+                result = DiscoveryResultBuilder.create(uid).withLabel(device.getDetails().getFriendlyName())\n+                        .withProperties(properties).withRepresentationProperty(PROPERTY_MAC_ADDRESS).build();\n+            }\n+        } catch (Exception e) {", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI5OTgzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488299834", "bodyText": "Is RuntimeException ok?", "author": "markus7017", "createdAt": "2020-09-14T23:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2Mjg3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU5Mjc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488592773", "bodyText": "yes. RuntimeException is ok.", "author": "Hilbrand", "createdAt": "2020-09-15T11:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2Mjg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2Mjk2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487562960", "bodyText": "It should be an uppercase name:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final static HashMap<String, String> keyMap = new HashMap<String, String>();\n          \n          \n            \n                private final static HashMap<String, String> KEY_MAP = new HashMap<>();\n          \n      \n    \n    \n  \n\nAlso you should initialize it in a static context:\nstatic {\n    KEY_MAP.put(\"POWER\", \"0x0100\");\n}", "author": "Hilbrand", "createdAt": "2020-09-13T18:45:12Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVControl.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.StringTokenizer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVHttp;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVControl} implements the control functions for the\n+ * receiver.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVControl {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVControl.class);\n+    private final static HashMap<String, String> keyMap = new HashMap<String, String>();", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDI2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488300267", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T23:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2Mjk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzE3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487563173", "bodyText": "Remove the extra brackets", "author": "Hilbrand", "createdAt": "2020-09-13T18:47:20Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVControl.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.StringTokenizer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVHttp;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVControl} implements the control functions for the\n+ * receiver.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVControl {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVControl.class);\n+    private final static HashMap<String, String> keyMap = new HashMap<String, String>();\n+\n+    private final MagentaTVNetwork network;\n+    private final MagentaTVHttp http = new MagentaTVHttp();\n+    private final MagentaTVOAuth oauth = new MagentaTVOAuth();\n+    private final MagentaTVDynamicConfig config;\n+    private boolean initialized = false;\n+    private String thingId = \"\";\n+\n+    public MagentaTVControl() {\n+        config = new MagentaTVDynamicConfig();\n+        network = new MagentaTVNetwork();\n+    }\n+\n+    public MagentaTVControl(MagentaTVDynamicConfig config, MagentaTVNetwork network) {\n+        thingId = config.getFriendlyName();\n+        this.network = network;\n+        this.config = config;\n+        this.config.setTerminalID(computeMD5(network.getLocalMAC().toUpperCase() + config.getUDN()));\n+        this.config.setLocalIP(network.getLocalIP());\n+        this.config.setLocalMAC(network.getLocalMAC());\n+        initializeKeyMap();\n+        initialized = true;\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Returns the thingConfig - the Control class adds various attributes of the\n+     * discovered device (like the MR model)\n+     *\n+     * @return thingConfig\n+     */\n+    public MagentaTVDynamicConfig getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Initiate OAuth authentication\n+     *\n+     * @param accountName T-Online user id\n+     * @param accountPassword T-Online password\n+     * @return true: successful, false: failed\n+     *\n+     * @throws MagentaTVException\n+     */\n+    public String getUserId(String accountName, String accountPassword) throws MagentaTVException {\n+        return oauth.getUserId(accountName, accountPassword);\n+    }\n+\n+    /**\n+     * Retries the device properties. This will result in an Exception if the device\n+     * is not connected.\n+     *\n+     * Response is returned in XMl format, e.g.:\n+     * <?xml version=\"1.0\"?> <root xmlns=\"urn:schemas-upnp-org:device-1-0\">\n+     * <specVersion><major>1</major><minor>0</minor></specVersion> <device>\n+     * <UDN>uuid:70dff25c-1bdf-5731-a283-XXXXXXXX</UDN>\n+     * <friendlyName>DMS_XXXXXXXXXXXX</friendlyName>\n+     * <deviceType>urn:schemas-upnp-org:device:tvdevice:1</deviceType>\n+     * <manufacturer>Zenterio</manufacturer> <modelName>MR401B</modelName>\n+     * <modelNumber>R01A5</modelNumber> <productVersionNumber>&quot; 334\n+     * &quot;</productVersionNumber> <productType>stb</productType>\n+     * <serialNumber></serialNumber> <X_wakeOnLan>0</X_wakeOnLan> <serviceList>\n+     * <service> <serviceType>urn:dial-multiscreen-org:service:dial:1</serviceType>\n+     * <serviceId>urn:dial-multiscreen-org:service:dial</serviceId> </service>\n+     * </serviceList> </device> </root>\n+     *\n+     * @return true: device is online, false: device is offline\n+     * @throws MagentaTVException\n+     */\n+    public boolean checkDev() throws MagentaTVException {\n+        logger.debug(\"{}: Check device {} ({}:{})\", thingId, config.getTerminalID(), config.getIpAddress(),\n+                config.getPort());\n+\n+        String url = MessageFormat.format(CHECKDEV_URI, config.getIpAddress(), config.getPort(),\n+                config.getDescriptionUrl());\n+        String result = http.httpGet(buildHost(), url, \"\");\n+        if (result.contains(\"<modelName>\")) {\n+            {", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDY5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488300690", "bodyText": "interesting, removed", "author": "markus7017", "createdAt": "2020-09-14T23:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzIxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487563212", "bodyText": "Redundant brackets", "author": "Hilbrand", "createdAt": "2020-09-13T18:47:46Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVControl.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.StringTokenizer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVHttp;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVControl} implements the control functions for the\n+ * receiver.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVControl {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVControl.class);\n+    private final static HashMap<String, String> keyMap = new HashMap<String, String>();\n+\n+    private final MagentaTVNetwork network;\n+    private final MagentaTVHttp http = new MagentaTVHttp();\n+    private final MagentaTVOAuth oauth = new MagentaTVOAuth();\n+    private final MagentaTVDynamicConfig config;\n+    private boolean initialized = false;\n+    private String thingId = \"\";\n+\n+    public MagentaTVControl() {\n+        config = new MagentaTVDynamicConfig();\n+        network = new MagentaTVNetwork();\n+    }\n+\n+    public MagentaTVControl(MagentaTVDynamicConfig config, MagentaTVNetwork network) {\n+        thingId = config.getFriendlyName();\n+        this.network = network;\n+        this.config = config;\n+        this.config.setTerminalID(computeMD5(network.getLocalMAC().toUpperCase() + config.getUDN()));\n+        this.config.setLocalIP(network.getLocalIP());\n+        this.config.setLocalMAC(network.getLocalMAC());\n+        initializeKeyMap();\n+        initialized = true;\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Returns the thingConfig - the Control class adds various attributes of the\n+     * discovered device (like the MR model)\n+     *\n+     * @return thingConfig\n+     */\n+    public MagentaTVDynamicConfig getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Initiate OAuth authentication\n+     *\n+     * @param accountName T-Online user id\n+     * @param accountPassword T-Online password\n+     * @return true: successful, false: failed\n+     *\n+     * @throws MagentaTVException\n+     */\n+    public String getUserId(String accountName, String accountPassword) throws MagentaTVException {\n+        return oauth.getUserId(accountName, accountPassword);\n+    }\n+\n+    /**\n+     * Retries the device properties. This will result in an Exception if the device\n+     * is not connected.\n+     *\n+     * Response is returned in XMl format, e.g.:\n+     * <?xml version=\"1.0\"?> <root xmlns=\"urn:schemas-upnp-org:device-1-0\">\n+     * <specVersion><major>1</major><minor>0</minor></specVersion> <device>\n+     * <UDN>uuid:70dff25c-1bdf-5731-a283-XXXXXXXX</UDN>\n+     * <friendlyName>DMS_XXXXXXXXXXXX</friendlyName>\n+     * <deviceType>urn:schemas-upnp-org:device:tvdevice:1</deviceType>\n+     * <manufacturer>Zenterio</manufacturer> <modelName>MR401B</modelName>\n+     * <modelNumber>R01A5</modelNumber> <productVersionNumber>&quot; 334\n+     * &quot;</productVersionNumber> <productType>stb</productType>\n+     * <serialNumber></serialNumber> <X_wakeOnLan>0</X_wakeOnLan> <serviceList>\n+     * <service> <serviceType>urn:dial-multiscreen-org:service:dial:1</serviceType>\n+     * <serviceId>urn:dial-multiscreen-org:service:dial</serviceId> </service>\n+     * </serviceList> </device> </root>\n+     *\n+     * @return true: device is online, false: device is offline\n+     * @throws MagentaTVException\n+     */\n+    public boolean checkDev() throws MagentaTVException {\n+        logger.debug(\"{}: Check device {} ({}:{})\", thingId, config.getTerminalID(), config.getIpAddress(),\n+                config.getPort());\n+\n+        String url = MessageFormat.format(CHECKDEV_URI, config.getIpAddress(), config.getPort(),\n+                config.getDescriptionUrl());\n+        String result = http.httpGet(buildHost(), url, \"\");\n+        if (result.contains(\"<modelName>\")) {\n+            {\n+                config.setModel(substringBetween(result, \"<modelName>\", \"</modelName>\"));\n+            }\n+        }\n+        if (result.contains(\"<modelNumber>\")) {\n+            {", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDczOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488300739", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-09-14T23:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzIzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487563234", "bodyText": "Redundant brackets", "author": "Hilbrand", "createdAt": "2020-09-13T18:47:53Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVControl.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.StringTokenizer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVHttp;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVControl} implements the control functions for the\n+ * receiver.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVControl {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVControl.class);\n+    private final static HashMap<String, String> keyMap = new HashMap<String, String>();\n+\n+    private final MagentaTVNetwork network;\n+    private final MagentaTVHttp http = new MagentaTVHttp();\n+    private final MagentaTVOAuth oauth = new MagentaTVOAuth();\n+    private final MagentaTVDynamicConfig config;\n+    private boolean initialized = false;\n+    private String thingId = \"\";\n+\n+    public MagentaTVControl() {\n+        config = new MagentaTVDynamicConfig();\n+        network = new MagentaTVNetwork();\n+    }\n+\n+    public MagentaTVControl(MagentaTVDynamicConfig config, MagentaTVNetwork network) {\n+        thingId = config.getFriendlyName();\n+        this.network = network;\n+        this.config = config;\n+        this.config.setTerminalID(computeMD5(network.getLocalMAC().toUpperCase() + config.getUDN()));\n+        this.config.setLocalIP(network.getLocalIP());\n+        this.config.setLocalMAC(network.getLocalMAC());\n+        initializeKeyMap();\n+        initialized = true;\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Returns the thingConfig - the Control class adds various attributes of the\n+     * discovered device (like the MR model)\n+     *\n+     * @return thingConfig\n+     */\n+    public MagentaTVDynamicConfig getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Initiate OAuth authentication\n+     *\n+     * @param accountName T-Online user id\n+     * @param accountPassword T-Online password\n+     * @return true: successful, false: failed\n+     *\n+     * @throws MagentaTVException\n+     */\n+    public String getUserId(String accountName, String accountPassword) throws MagentaTVException {\n+        return oauth.getUserId(accountName, accountPassword);\n+    }\n+\n+    /**\n+     * Retries the device properties. This will result in an Exception if the device\n+     * is not connected.\n+     *\n+     * Response is returned in XMl format, e.g.:\n+     * <?xml version=\"1.0\"?> <root xmlns=\"urn:schemas-upnp-org:device-1-0\">\n+     * <specVersion><major>1</major><minor>0</minor></specVersion> <device>\n+     * <UDN>uuid:70dff25c-1bdf-5731-a283-XXXXXXXX</UDN>\n+     * <friendlyName>DMS_XXXXXXXXXXXX</friendlyName>\n+     * <deviceType>urn:schemas-upnp-org:device:tvdevice:1</deviceType>\n+     * <manufacturer>Zenterio</manufacturer> <modelName>MR401B</modelName>\n+     * <modelNumber>R01A5</modelNumber> <productVersionNumber>&quot; 334\n+     * &quot;</productVersionNumber> <productType>stb</productType>\n+     * <serialNumber></serialNumber> <X_wakeOnLan>0</X_wakeOnLan> <serviceList>\n+     * <service> <serviceType>urn:dial-multiscreen-org:service:dial:1</serviceType>\n+     * <serviceId>urn:dial-multiscreen-org:service:dial</serviceId> </service>\n+     * </serviceList> </device> </root>\n+     *\n+     * @return true: device is online, false: device is offline\n+     * @throws MagentaTVException\n+     */\n+    public boolean checkDev() throws MagentaTVException {\n+        logger.debug(\"{}: Check device {} ({}:{})\", thingId, config.getTerminalID(), config.getIpAddress(),\n+                config.getPort());\n+\n+        String url = MessageFormat.format(CHECKDEV_URI, config.getIpAddress(), config.getPort(),\n+                config.getDescriptionUrl());\n+        String result = http.httpGet(buildHost(), url, \"\");\n+        if (result.contains(\"<modelName>\")) {\n+            {\n+                config.setModel(substringBetween(result, \"<modelName>\", \"</modelName>\"));\n+            }\n+        }\n+        if (result.contains(\"<modelNumber>\")) {\n+            {\n+                config.setHardwareVersion(substringBetween(result, \"<modelNumber>\", \"</modelNumber>\"));\n+            }\n+        }\n+        if (result.contains(\"<X_wakeOnLan>\")) {\n+            {\n+                String wol = substringBetween(result, \"<X_wakeOnLan>\", \"</X_wakeOnLan>\");\n+                config.setWakeOnLAN(wol);\n+                logger.debug(\"{}: Wake-on-LAN is {}\", thingId, wol.equals(\"0\") ? \"disabled\" : \"enabled\");\n+            }\n+        }\n+        if (result.contains(\"<productVersionNumber>\")) {\n+            {", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDc3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488300771", "bodyText": "removed", "author": "markus7017", "createdAt": "2020-09-14T23:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2Mzc1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487563758", "bodyText": "Better use a switch", "author": "Hilbrand", "createdAt": "2020-09-13T18:52:36Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVControl.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.StringTokenizer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVHttp;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVControl} implements the control functions for the\n+ * receiver.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVControl {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVControl.class);\n+    private final static HashMap<String, String> keyMap = new HashMap<String, String>();\n+\n+    private final MagentaTVNetwork network;\n+    private final MagentaTVHttp http = new MagentaTVHttp();\n+    private final MagentaTVOAuth oauth = new MagentaTVOAuth();\n+    private final MagentaTVDynamicConfig config;\n+    private boolean initialized = false;\n+    private String thingId = \"\";\n+\n+    public MagentaTVControl() {\n+        config = new MagentaTVDynamicConfig();\n+        network = new MagentaTVNetwork();\n+    }\n+\n+    public MagentaTVControl(MagentaTVDynamicConfig config, MagentaTVNetwork network) {\n+        thingId = config.getFriendlyName();\n+        this.network = network;\n+        this.config = config;\n+        this.config.setTerminalID(computeMD5(network.getLocalMAC().toUpperCase() + config.getUDN()));\n+        this.config.setLocalIP(network.getLocalIP());\n+        this.config.setLocalMAC(network.getLocalMAC());\n+        initializeKeyMap();\n+        initialized = true;\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Returns the thingConfig - the Control class adds various attributes of the\n+     * discovered device (like the MR model)\n+     *\n+     * @return thingConfig\n+     */\n+    public MagentaTVDynamicConfig getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Initiate OAuth authentication\n+     *\n+     * @param accountName T-Online user id\n+     * @param accountPassword T-Online password\n+     * @return true: successful, false: failed\n+     *\n+     * @throws MagentaTVException\n+     */\n+    public String getUserId(String accountName, String accountPassword) throws MagentaTVException {\n+        return oauth.getUserId(accountName, accountPassword);\n+    }\n+\n+    /**\n+     * Retries the device properties. This will result in an Exception if the device\n+     * is not connected.\n+     *\n+     * Response is returned in XMl format, e.g.:\n+     * <?xml version=\"1.0\"?> <root xmlns=\"urn:schemas-upnp-org:device-1-0\">\n+     * <specVersion><major>1</major><minor>0</minor></specVersion> <device>\n+     * <UDN>uuid:70dff25c-1bdf-5731-a283-XXXXXXXX</UDN>\n+     * <friendlyName>DMS_XXXXXXXXXXXX</friendlyName>\n+     * <deviceType>urn:schemas-upnp-org:device:tvdevice:1</deviceType>\n+     * <manufacturer>Zenterio</manufacturer> <modelName>MR401B</modelName>\n+     * <modelNumber>R01A5</modelNumber> <productVersionNumber>&quot; 334\n+     * &quot;</productVersionNumber> <productType>stb</productType>\n+     * <serialNumber></serialNumber> <X_wakeOnLan>0</X_wakeOnLan> <serviceList>\n+     * <service> <serviceType>urn:dial-multiscreen-org:service:dial:1</serviceType>\n+     * <serviceId>urn:dial-multiscreen-org:service:dial</serviceId> </service>\n+     * </serviceList> </device> </root>\n+     *\n+     * @return true: device is online, false: device is offline\n+     * @throws MagentaTVException\n+     */\n+    public boolean checkDev() throws MagentaTVException {\n+        logger.debug(\"{}: Check device {} ({}:{})\", thingId, config.getTerminalID(), config.getIpAddress(),\n+                config.getPort());\n+\n+        String url = MessageFormat.format(CHECKDEV_URI, config.getIpAddress(), config.getPort(),\n+                config.getDescriptionUrl());\n+        String result = http.httpGet(buildHost(), url, \"\");\n+        if (result.contains(\"<modelName>\")) {\n+            {\n+                config.setModel(substringBetween(result, \"<modelName>\", \"</modelName>\"));\n+            }\n+        }\n+        if (result.contains(\"<modelNumber>\")) {\n+            {\n+                config.setHardwareVersion(substringBetween(result, \"<modelNumber>\", \"</modelNumber>\"));\n+            }\n+        }\n+        if (result.contains(\"<X_wakeOnLan>\")) {\n+            {\n+                String wol = substringBetween(result, \"<X_wakeOnLan>\", \"</X_wakeOnLan>\");\n+                config.setWakeOnLAN(wol);\n+                logger.debug(\"{}: Wake-on-LAN is {}\", thingId, wol.equals(\"0\") ? \"disabled\" : \"enabled\");\n+            }\n+        }\n+        if (result.contains(\"<productVersionNumber>\")) {\n+            {\n+                String version;\n+                if (result.contains(\"<productVersionNumber>&quot; \")) {\n+                    version = substringBetween(result, \"<productVersionNumber>&quot; \",\n+                            \" &quot;</productVersionNumber>\");\n+                } else {\n+                    version = substringBetween(result, \"<productVersionNumber>\", \"</productVersionNumber>\");\n+                }\n+                config.setFirmwareVersion(version);\n+            }\n+        }\n+        if (result.contains(\"<friendlyName>\")) {\n+            String friendlyName = result.substring(result.indexOf(\"<friendlyName>\") + \"<friendlyName>\".length(),\n+                    result.indexOf(\"</friendlyName>\"));\n+            config.setFriendlyName(friendlyName);\n+        }\n+        if (result.contains(\"<UDN>uuid:\")) {\n+            String udn = result.substring(result.indexOf(\"<UDN>uuid:\") + \"<UDN>uuid:\".length(),\n+                    result.indexOf(\"</UDN>\"));\n+            if (config.getUDN().isEmpty()) {\n+                config.setUDN(udn);\n+            }\n+        }\n+        logger.trace(\"{}: Online status verified for device {}:{}, UDN={}\", thingId, config.getIpAddress(),\n+                config.getPort(), config.getUDN());\n+        return true;\n+    }\n+\n+    /**\n+     *\n+     * Sends a SUBSCRIBE request to the MR. This also defines the local callback url\n+     * used by the MR to return the pairing code and event information.\n+     *\n+     * Subscripbe to event channel a) receive the pairing code b) receive\n+     * programInfo and playStatus events after successful paring\n+     *\n+     * SUBSCRIBE /upnp/service/X-CTC_RemotePairing/Event HTTP/1.1\\r\\n HOST:\n+     * $remote_ip:$remote_port CALLBACK: <http://$local_ip:$local_port/>\\r\\n // NT:\n+     * upnp:event\\r\\n // TIMEOUT: Second-300\\r\\n // CONNECTION: close\\r\\n // \\r\\n\n+     *\n+     * @throws MagentaTVException\n+     */\n+    public void subscribeEventChannel() throws MagentaTVException {\n+        String sid = \"\";\n+        logger.debug(\"{}: Subscribe Event Channel (terminalID={}, {}:{}\", thingId, config.getTerminalID(),\n+                config.getIpAddress(), config.getPort());\n+        String subscribe = MessageFormat.format(PAIRING_SUBSCRIBE, config.getIpAddress(), config.getPort(),\n+                network.getLocalIP(), network.getLocalPort(), PAIRING_NOTIFY_URI, PAIRING_TIMEOUT_SEC);\n+        String response = http.sendData(config.getIpAddress(), config.getPort(), subscribe);\n+        if (!response.contains(\"200 OK\")) {\n+            response = substringBefore(response, \"SERVER\");\n+            throw new MagentaTVException(\"Unable to subscribe to pairing channel: \" + response);\n+        }\n+        if (!response.contains(NOTIFY_SID)) {\n+            throw new MagentaTVException(\"Unable to subscribe to pairing channel, SID missing: \" + response);\n+        }\n+\n+        StringTokenizer tokenizer = new StringTokenizer(response, \"\\r\\n\");\n+        while (tokenizer.hasMoreElements()) {\n+            String str = tokenizer.nextToken();\n+            if (!str.isEmpty()) {\n+                if (str.contains(NOTIFY_SID)) {\n+                    sid = str.substring(\"SID: uuid:\".length());\n+                    logger.debug(\"{}: SUBSCRIBE returned SID {}\", thingId, sid);\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Send Pairing Request to the Media Receiver. The method waits for the\n+     * response, but the pairing code will be received via the NOTIFY callback (see\n+     * NotifyServlet)\n+     *\n+     * XML format for Pairing Request: <s:Envelope\n+     * xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"\n+     * <s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\"> <s:Body>\\n\n+     * <u:X-pairingRequest\n+     * xmlns:u=\\\"urn:schemas-upnp-org:service:X-CTC_RemotePairing:1\\\">\\n\n+     * <pairingDeviceID>$pairingDeviceID</pairingDeviceID>\\n\n+     * <friendlyName>$friendlyName</friendlyName>\\n <userID>$userID</userID>\\n\n+     * </u:X-pairingRequest>\\n </s:Body> </s:Envelope>\n+     *\n+     * @returns true: pairing successful\n+     * @throws MagentaTVException\n+     */\n+    public boolean sendPairingRequest() throws MagentaTVException {\n+        logger.debug(\"{}: Send Pairing Request (deviceID={}, type={}, userID={})\", thingId, config.getTerminalID(),\n+                DEF_FRIENDLY_NAME, config.getUserId());\n+        resetPairing();\n+\n+        String soapBody = MessageFormat.format(PAIRING_SOAP_BODY, config.getTerminalID(), DEF_FRIENDLY_NAME,\n+                config.getUserId());\n+        String soapXml = MessageFormat.format(SOAP_ENVELOPE, soapBody);\n+        String response = http.httpPOST(buildHost(), buildReceiverUrl(PAIRING_CONTROL_URI), soapXml,\n+                PAIRING_SOAP_ACTION, CONNECTION_CLOSE);\n+\n+        // pairingCode will be received by the Servlet, is calls onPairingResult()\n+        // Exception if request failed (response code != HTTP_OK)\n+        if (!response.contains(\"X-pairingRequestResponse\") || !response.contains(\"<result>\")) {\n+            throw new MagentaTVException(\"Unexpected result for pairing response: \" + response);\n+        }\n+\n+        String result = substringBetween(response, \"<result>\", \"</result>\");\n+        if (!result.equals(\"0\")) {\n+            throw new MagentaTVException(\"Pairing failed, result=\" + result);\n+        }\n+\n+        logger.debug(\"{}: Pairing initiated (deviceID={}).\", thingId, config.getTerminalID());\n+        return true;\n+    }\n+\n+    /**\n+     * Calculates the verifificationCode to complete pairing. This will be triggered\n+     * as a result after receiving the pairing code provided by the MR. The\n+     * verification code is the MD5 hash of <Pairing Code><Terminal-ID><User ID>\n+     *\n+     * @param pairingCode Pairing code received from the MR\n+     * @return true: a new code has been generated, false: the code matches a\n+     *         previous pairing\n+     */\n+    public boolean generateVerificationCode(String pairingCode) {\n+        if (config.getPairingCode().equals(pairingCode) && !config.getVerificationCode().isEmpty()) {\n+            logger.debug(\"{}: Pairing code ({}) refreshed, verificationCode={}\", thingId, pairingCode,\n+                    config.getVerificationCode());\n+            return false;\n+        }\n+        config.setPairingCode(pairingCode);\n+        String md5Input = pairingCode + config.getTerminalID() + config.getUserId();\n+        config.setVerificationCode(computeMD5(md5Input).toUpperCase());\n+        logger.debug(\"{}: VerificationCode({}): Input={}, code={}\", thingId, config.getTerminalID(), md5Input,\n+                config.getVerificationCode());\n+        return true;\n+    }\n+\n+    /**\n+     * Send a pairing verification request to the receiver. This is important to\n+     * complete the pairing process. You should see a message like \"Connected to\n+     * openHAB\" on your TV screen.\n+     *\n+     * @return true: successful, false: a non-critical error occured, caller handles\n+     *         this\n+     * @throws MagentaTVException\n+     */\n+    public boolean verifyPairing() throws MagentaTVException {\n+        logger.debug(\"{}: Verify pairing (id={}, code={}\", thingId, config.getTerminalID(),\n+                config.getVerificationCode());\n+        String soapBody = MessageFormat.format(PAIRCHECK_SOAP_BODY, config.getTerminalID(),\n+                config.getVerificationCode());\n+        String soapXml = MessageFormat.format(SOAP_ENVELOPE, soapBody);\n+        String response = http.httpPOST(buildHost(), buildReceiverUrl(PAIRCHECK_URI), soapXml, PAIRCHECK_SOAP_ACTION,\n+                CONNECTION_CLOSE);\n+\n+        // Exception if request failed (response code != HTTP_OK)\n+        if (!response.contains(\"<pairingResult>\")) {\n+            throw new MagentaTVException(\"Unexpected result for pairing verification: \" + response);\n+        }\n+\n+        String result = getXmlValue(response, \"pairingResult\");\n+        if (!result.equals(\"0\")) {\n+            logger.debug(\"{}: Pairing failed or pairing no longer valid, result={}\", thingId, result);\n+            resetPairing();\n+            // let the caller decide how to proceed\n+            return false;\n+        }\n+\n+        if (!config.isMR400()) {\n+            String enable4K = getXmlValue(response, \"Enable4K\");\n+            String enableSAT = getXmlValue(response, \"EnableSAT\");\n+            logger.debug(\"{}: Features: Enable4K:{}, EnableSAT:{}\", thingId, enable4K, enableSAT);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     *\n+     * @return true if pairing is completed (verification code was generated)\n+     */\n+    public boolean isPaired() {\n+        // pairing was completed successful if we have the verification code\n+        return !config.getVerificationCode().isEmpty();\n+    }\n+\n+    /**\n+     * Reset pairing information (e.g. when verification failed)\n+     */\n+    public void resetPairing() {\n+        // pairing no longer valid\n+        config.setPairingCode(\"\");\n+        config.setVerificationCode(\"\");\n+    }\n+\n+    /**\n+     * Send key code to the MR (via SOAP request). A key code could be send by it's\n+     * code (0x.... notation) or with a symbolic namne, which will first be mapped\n+     * to the key code\n+     *\n+     * XML format for Send Key\n+     *\n+     * <s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"\n+     * s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\"> <s:Body>\\n\n+     * <u:X_CTC_RemoteKey\n+     * xmlns:u=\\\"urn:schemas-upnp-org:service:X-CTC_RemoteControl:1\\\">\\n\n+     * <InstanceID>0</InstanceID>\\n\n+     * <KeyCode>keyCode=$keyCode^$pairingDeviceID:$verificationCode^userID:$userID</KeyCode>\\n\n+     * </u:X_CTC_RemoteKey>\\n </s:Body></s:Envelope>\n+     *\n+     * @param keyName\n+     * @return true: successful, false: failed, e.g. unkown key code\n+     * @throws MagentaTVException\n+     */\n+    public boolean sendKey(String keyName) throws MagentaTVException {\n+        String keyCode = getKeyCode(keyName);\n+        logger.debug(\"{}: Send Key {}\u00a0(keyCode={}, tid={})\", thingId, keyName, keyCode, config.getTerminalID());\n+        if (keyCode.length() <= \"0x\".length()) {\n+            logger.debug(\"{}: Key {} is unkown!\", thingId, keyCode);\n+            return false;\n+        }\n+\n+        String soapBody = MessageFormat.format(SENDKEY_SOAP_BODY, keyCode, config.getTerminalID(),\n+                config.getVerificationCode(), config.getUserId());\n+        String soapXml = MessageFormat.format(SOAP_ENVELOPE, soapBody);\n+        logger.debug(\"{}: send keyCode={} to {}:{}\", thingId, keyCode, config.getIpAddress(), config.getPort());\n+        logger.trace(\"{}: sendKey terminalid={}, pairingCode={}, verificationCode={}, userId={}\", thingId,\n+                config.getTerminalID(), config.getPairingCode(), config.getVerificationCode(), config.getUserId());\n+        http.httpPOST(buildHost(), buildReceiverUrl(SENDKEY_URI), soapXml, SENDKEY_SOAP_ACTION, CONNECTION_CLOSE);\n+        // Exception if request failed (response code != HTTP_OK)\n+        // pairingCode will be received by the Servlet, is calls onPairingResult()\n+        return true;\n+    }\n+\n+    /**\n+     * Select channel for TV\n+     *\n+     * @param channel new channel (a sequence of numbers, which will be send one by one)\n+     * @return true:ok, false: failed\n+     */\n+    public boolean selectChannel(String channel) throws MagentaTVException {\n+        logger.debug(\"{}: Select channel {}\", thingId, channel);\n+        for (int i = 0; i < channel.length(); i++) {\n+            if (!sendKey(\"\" + channel.charAt(i))) {\n+                return false;\n+            }\n+            try {\n+                Thread.sleep(200);\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Get key code to send to receiver\n+     *\n+     * @param key Key for which to get the key code\n+     * @return\n+     */\n+    private String getKeyCode(String key) {\n+        if (key.contains(\"0x\")) {\n+            // direct key code\n+            return key;\n+        }\n+        if (keyMap.isEmpty()) {\n+            initializeKeyMap();\n+        }\n+        if (keyMap.containsKey(key)) {\n+            return keyMap.get(key);\n+        }\n+        return \"\";\n+    }\n+\n+    /**\n+     * Map playStatus code to string for a list of codes see\n+     * http://support.huawei.com/hedex/pages/DOC1100366313CEH0713H/01/DOC1100366313CEH0713H/01/resources/dsv_hdx_idp/DSV/en/en-us_topic_0094619231.html\n+     *\n+     * @param playStatus Integer code parsed form json (see EV_PLAYCHG_XXX)\n+     * @return playStatus as String\n+     */\n+    public String getPlayStatus(int playStatus) {\n+        if (playStatus == EV_PLAYCHG_PLAY) {", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMTU1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488301556", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T23:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2Mzc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzgwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487563801", "bodyText": "Same here, please use a switch", "author": "Hilbrand", "createdAt": "2020-09-13T18:52:59Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVControl.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.StringTokenizer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVHttp;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVControl} implements the control functions for the\n+ * receiver.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVControl {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVControl.class);\n+    private final static HashMap<String, String> keyMap = new HashMap<String, String>();\n+\n+    private final MagentaTVNetwork network;\n+    private final MagentaTVHttp http = new MagentaTVHttp();\n+    private final MagentaTVOAuth oauth = new MagentaTVOAuth();\n+    private final MagentaTVDynamicConfig config;\n+    private boolean initialized = false;\n+    private String thingId = \"\";\n+\n+    public MagentaTVControl() {\n+        config = new MagentaTVDynamicConfig();\n+        network = new MagentaTVNetwork();\n+    }\n+\n+    public MagentaTVControl(MagentaTVDynamicConfig config, MagentaTVNetwork network) {\n+        thingId = config.getFriendlyName();\n+        this.network = network;\n+        this.config = config;\n+        this.config.setTerminalID(computeMD5(network.getLocalMAC().toUpperCase() + config.getUDN()));\n+        this.config.setLocalIP(network.getLocalIP());\n+        this.config.setLocalMAC(network.getLocalMAC());\n+        initializeKeyMap();\n+        initialized = true;\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Returns the thingConfig - the Control class adds various attributes of the\n+     * discovered device (like the MR model)\n+     *\n+     * @return thingConfig\n+     */\n+    public MagentaTVDynamicConfig getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Initiate OAuth authentication\n+     *\n+     * @param accountName T-Online user id\n+     * @param accountPassword T-Online password\n+     * @return true: successful, false: failed\n+     *\n+     * @throws MagentaTVException\n+     */\n+    public String getUserId(String accountName, String accountPassword) throws MagentaTVException {\n+        return oauth.getUserId(accountName, accountPassword);\n+    }\n+\n+    /**\n+     * Retries the device properties. This will result in an Exception if the device\n+     * is not connected.\n+     *\n+     * Response is returned in XMl format, e.g.:\n+     * <?xml version=\"1.0\"?> <root xmlns=\"urn:schemas-upnp-org:device-1-0\">\n+     * <specVersion><major>1</major><minor>0</minor></specVersion> <device>\n+     * <UDN>uuid:70dff25c-1bdf-5731-a283-XXXXXXXX</UDN>\n+     * <friendlyName>DMS_XXXXXXXXXXXX</friendlyName>\n+     * <deviceType>urn:schemas-upnp-org:device:tvdevice:1</deviceType>\n+     * <manufacturer>Zenterio</manufacturer> <modelName>MR401B</modelName>\n+     * <modelNumber>R01A5</modelNumber> <productVersionNumber>&quot; 334\n+     * &quot;</productVersionNumber> <productType>stb</productType>\n+     * <serialNumber></serialNumber> <X_wakeOnLan>0</X_wakeOnLan> <serviceList>\n+     * <service> <serviceType>urn:dial-multiscreen-org:service:dial:1</serviceType>\n+     * <serviceId>urn:dial-multiscreen-org:service:dial</serviceId> </service>\n+     * </serviceList> </device> </root>\n+     *\n+     * @return true: device is online, false: device is offline\n+     * @throws MagentaTVException\n+     */\n+    public boolean checkDev() throws MagentaTVException {\n+        logger.debug(\"{}: Check device {} ({}:{})\", thingId, config.getTerminalID(), config.getIpAddress(),\n+                config.getPort());\n+\n+        String url = MessageFormat.format(CHECKDEV_URI, config.getIpAddress(), config.getPort(),\n+                config.getDescriptionUrl());\n+        String result = http.httpGet(buildHost(), url, \"\");\n+        if (result.contains(\"<modelName>\")) {\n+            {\n+                config.setModel(substringBetween(result, \"<modelName>\", \"</modelName>\"));\n+            }\n+        }\n+        if (result.contains(\"<modelNumber>\")) {\n+            {\n+                config.setHardwareVersion(substringBetween(result, \"<modelNumber>\", \"</modelNumber>\"));\n+            }\n+        }\n+        if (result.contains(\"<X_wakeOnLan>\")) {\n+            {\n+                String wol = substringBetween(result, \"<X_wakeOnLan>\", \"</X_wakeOnLan>\");\n+                config.setWakeOnLAN(wol);\n+                logger.debug(\"{}: Wake-on-LAN is {}\", thingId, wol.equals(\"0\") ? \"disabled\" : \"enabled\");\n+            }\n+        }\n+        if (result.contains(\"<productVersionNumber>\")) {\n+            {\n+                String version;\n+                if (result.contains(\"<productVersionNumber>&quot; \")) {\n+                    version = substringBetween(result, \"<productVersionNumber>&quot; \",\n+                            \" &quot;</productVersionNumber>\");\n+                } else {\n+                    version = substringBetween(result, \"<productVersionNumber>\", \"</productVersionNumber>\");\n+                }\n+                config.setFirmwareVersion(version);\n+            }\n+        }\n+        if (result.contains(\"<friendlyName>\")) {\n+            String friendlyName = result.substring(result.indexOf(\"<friendlyName>\") + \"<friendlyName>\".length(),\n+                    result.indexOf(\"</friendlyName>\"));\n+            config.setFriendlyName(friendlyName);\n+        }\n+        if (result.contains(\"<UDN>uuid:\")) {\n+            String udn = result.substring(result.indexOf(\"<UDN>uuid:\") + \"<UDN>uuid:\".length(),\n+                    result.indexOf(\"</UDN>\"));\n+            if (config.getUDN().isEmpty()) {\n+                config.setUDN(udn);\n+            }\n+        }\n+        logger.trace(\"{}: Online status verified for device {}:{}, UDN={}\", thingId, config.getIpAddress(),\n+                config.getPort(), config.getUDN());\n+        return true;\n+    }\n+\n+    /**\n+     *\n+     * Sends a SUBSCRIBE request to the MR. This also defines the local callback url\n+     * used by the MR to return the pairing code and event information.\n+     *\n+     * Subscripbe to event channel a) receive the pairing code b) receive\n+     * programInfo and playStatus events after successful paring\n+     *\n+     * SUBSCRIBE /upnp/service/X-CTC_RemotePairing/Event HTTP/1.1\\r\\n HOST:\n+     * $remote_ip:$remote_port CALLBACK: <http://$local_ip:$local_port/>\\r\\n // NT:\n+     * upnp:event\\r\\n // TIMEOUT: Second-300\\r\\n // CONNECTION: close\\r\\n // \\r\\n\n+     *\n+     * @throws MagentaTVException\n+     */\n+    public void subscribeEventChannel() throws MagentaTVException {\n+        String sid = \"\";\n+        logger.debug(\"{}: Subscribe Event Channel (terminalID={}, {}:{}\", thingId, config.getTerminalID(),\n+                config.getIpAddress(), config.getPort());\n+        String subscribe = MessageFormat.format(PAIRING_SUBSCRIBE, config.getIpAddress(), config.getPort(),\n+                network.getLocalIP(), network.getLocalPort(), PAIRING_NOTIFY_URI, PAIRING_TIMEOUT_SEC);\n+        String response = http.sendData(config.getIpAddress(), config.getPort(), subscribe);\n+        if (!response.contains(\"200 OK\")) {\n+            response = substringBefore(response, \"SERVER\");\n+            throw new MagentaTVException(\"Unable to subscribe to pairing channel: \" + response);\n+        }\n+        if (!response.contains(NOTIFY_SID)) {\n+            throw new MagentaTVException(\"Unable to subscribe to pairing channel, SID missing: \" + response);\n+        }\n+\n+        StringTokenizer tokenizer = new StringTokenizer(response, \"\\r\\n\");\n+        while (tokenizer.hasMoreElements()) {\n+            String str = tokenizer.nextToken();\n+            if (!str.isEmpty()) {\n+                if (str.contains(NOTIFY_SID)) {\n+                    sid = str.substring(\"SID: uuid:\".length());\n+                    logger.debug(\"{}: SUBSCRIBE returned SID {}\", thingId, sid);\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Send Pairing Request to the Media Receiver. The method waits for the\n+     * response, but the pairing code will be received via the NOTIFY callback (see\n+     * NotifyServlet)\n+     *\n+     * XML format for Pairing Request: <s:Envelope\n+     * xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"\n+     * <s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\"> <s:Body>\\n\n+     * <u:X-pairingRequest\n+     * xmlns:u=\\\"urn:schemas-upnp-org:service:X-CTC_RemotePairing:1\\\">\\n\n+     * <pairingDeviceID>$pairingDeviceID</pairingDeviceID>\\n\n+     * <friendlyName>$friendlyName</friendlyName>\\n <userID>$userID</userID>\\n\n+     * </u:X-pairingRequest>\\n </s:Body> </s:Envelope>\n+     *\n+     * @returns true: pairing successful\n+     * @throws MagentaTVException\n+     */\n+    public boolean sendPairingRequest() throws MagentaTVException {\n+        logger.debug(\"{}: Send Pairing Request (deviceID={}, type={}, userID={})\", thingId, config.getTerminalID(),\n+                DEF_FRIENDLY_NAME, config.getUserId());\n+        resetPairing();\n+\n+        String soapBody = MessageFormat.format(PAIRING_SOAP_BODY, config.getTerminalID(), DEF_FRIENDLY_NAME,\n+                config.getUserId());\n+        String soapXml = MessageFormat.format(SOAP_ENVELOPE, soapBody);\n+        String response = http.httpPOST(buildHost(), buildReceiverUrl(PAIRING_CONTROL_URI), soapXml,\n+                PAIRING_SOAP_ACTION, CONNECTION_CLOSE);\n+\n+        // pairingCode will be received by the Servlet, is calls onPairingResult()\n+        // Exception if request failed (response code != HTTP_OK)\n+        if (!response.contains(\"X-pairingRequestResponse\") || !response.contains(\"<result>\")) {\n+            throw new MagentaTVException(\"Unexpected result for pairing response: \" + response);\n+        }\n+\n+        String result = substringBetween(response, \"<result>\", \"</result>\");\n+        if (!result.equals(\"0\")) {\n+            throw new MagentaTVException(\"Pairing failed, result=\" + result);\n+        }\n+\n+        logger.debug(\"{}: Pairing initiated (deviceID={}).\", thingId, config.getTerminalID());\n+        return true;\n+    }\n+\n+    /**\n+     * Calculates the verifificationCode to complete pairing. This will be triggered\n+     * as a result after receiving the pairing code provided by the MR. The\n+     * verification code is the MD5 hash of <Pairing Code><Terminal-ID><User ID>\n+     *\n+     * @param pairingCode Pairing code received from the MR\n+     * @return true: a new code has been generated, false: the code matches a\n+     *         previous pairing\n+     */\n+    public boolean generateVerificationCode(String pairingCode) {\n+        if (config.getPairingCode().equals(pairingCode) && !config.getVerificationCode().isEmpty()) {\n+            logger.debug(\"{}: Pairing code ({}) refreshed, verificationCode={}\", thingId, pairingCode,\n+                    config.getVerificationCode());\n+            return false;\n+        }\n+        config.setPairingCode(pairingCode);\n+        String md5Input = pairingCode + config.getTerminalID() + config.getUserId();\n+        config.setVerificationCode(computeMD5(md5Input).toUpperCase());\n+        logger.debug(\"{}: VerificationCode({}): Input={}, code={}\", thingId, config.getTerminalID(), md5Input,\n+                config.getVerificationCode());\n+        return true;\n+    }\n+\n+    /**\n+     * Send a pairing verification request to the receiver. This is important to\n+     * complete the pairing process. You should see a message like \"Connected to\n+     * openHAB\" on your TV screen.\n+     *\n+     * @return true: successful, false: a non-critical error occured, caller handles\n+     *         this\n+     * @throws MagentaTVException\n+     */\n+    public boolean verifyPairing() throws MagentaTVException {\n+        logger.debug(\"{}: Verify pairing (id={}, code={}\", thingId, config.getTerminalID(),\n+                config.getVerificationCode());\n+        String soapBody = MessageFormat.format(PAIRCHECK_SOAP_BODY, config.getTerminalID(),\n+                config.getVerificationCode());\n+        String soapXml = MessageFormat.format(SOAP_ENVELOPE, soapBody);\n+        String response = http.httpPOST(buildHost(), buildReceiverUrl(PAIRCHECK_URI), soapXml, PAIRCHECK_SOAP_ACTION,\n+                CONNECTION_CLOSE);\n+\n+        // Exception if request failed (response code != HTTP_OK)\n+        if (!response.contains(\"<pairingResult>\")) {\n+            throw new MagentaTVException(\"Unexpected result for pairing verification: \" + response);\n+        }\n+\n+        String result = getXmlValue(response, \"pairingResult\");\n+        if (!result.equals(\"0\")) {\n+            logger.debug(\"{}: Pairing failed or pairing no longer valid, result={}\", thingId, result);\n+            resetPairing();\n+            // let the caller decide how to proceed\n+            return false;\n+        }\n+\n+        if (!config.isMR400()) {\n+            String enable4K = getXmlValue(response, \"Enable4K\");\n+            String enableSAT = getXmlValue(response, \"EnableSAT\");\n+            logger.debug(\"{}: Features: Enable4K:{}, EnableSAT:{}\", thingId, enable4K, enableSAT);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     *\n+     * @return true if pairing is completed (verification code was generated)\n+     */\n+    public boolean isPaired() {\n+        // pairing was completed successful if we have the verification code\n+        return !config.getVerificationCode().isEmpty();\n+    }\n+\n+    /**\n+     * Reset pairing information (e.g. when verification failed)\n+     */\n+    public void resetPairing() {\n+        // pairing no longer valid\n+        config.setPairingCode(\"\");\n+        config.setVerificationCode(\"\");\n+    }\n+\n+    /**\n+     * Send key code to the MR (via SOAP request). A key code could be send by it's\n+     * code (0x.... notation) or with a symbolic namne, which will first be mapped\n+     * to the key code\n+     *\n+     * XML format for Send Key\n+     *\n+     * <s:Envelope xmlns:s=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"\n+     * s:encodingStyle=\\\"http://schemas.xmlsoap.org/soap/encoding/\\\"> <s:Body>\\n\n+     * <u:X_CTC_RemoteKey\n+     * xmlns:u=\\\"urn:schemas-upnp-org:service:X-CTC_RemoteControl:1\\\">\\n\n+     * <InstanceID>0</InstanceID>\\n\n+     * <KeyCode>keyCode=$keyCode^$pairingDeviceID:$verificationCode^userID:$userID</KeyCode>\\n\n+     * </u:X_CTC_RemoteKey>\\n </s:Body></s:Envelope>\n+     *\n+     * @param keyName\n+     * @return true: successful, false: failed, e.g. unkown key code\n+     * @throws MagentaTVException\n+     */\n+    public boolean sendKey(String keyName) throws MagentaTVException {\n+        String keyCode = getKeyCode(keyName);\n+        logger.debug(\"{}: Send Key {}\u00a0(keyCode={}, tid={})\", thingId, keyName, keyCode, config.getTerminalID());\n+        if (keyCode.length() <= \"0x\".length()) {\n+            logger.debug(\"{}: Key {} is unkown!\", thingId, keyCode);\n+            return false;\n+        }\n+\n+        String soapBody = MessageFormat.format(SENDKEY_SOAP_BODY, keyCode, config.getTerminalID(),\n+                config.getVerificationCode(), config.getUserId());\n+        String soapXml = MessageFormat.format(SOAP_ENVELOPE, soapBody);\n+        logger.debug(\"{}: send keyCode={} to {}:{}\", thingId, keyCode, config.getIpAddress(), config.getPort());\n+        logger.trace(\"{}: sendKey terminalid={}, pairingCode={}, verificationCode={}, userId={}\", thingId,\n+                config.getTerminalID(), config.getPairingCode(), config.getVerificationCode(), config.getUserId());\n+        http.httpPOST(buildHost(), buildReceiverUrl(SENDKEY_URI), soapXml, SENDKEY_SOAP_ACTION, CONNECTION_CLOSE);\n+        // Exception if request failed (response code != HTTP_OK)\n+        // pairingCode will be received by the Servlet, is calls onPairingResult()\n+        return true;\n+    }\n+\n+    /**\n+     * Select channel for TV\n+     *\n+     * @param channel new channel (a sequence of numbers, which will be send one by one)\n+     * @return true:ok, false: failed\n+     */\n+    public boolean selectChannel(String channel) throws MagentaTVException {\n+        logger.debug(\"{}: Select channel {}\", thingId, channel);\n+        for (int i = 0; i < channel.length(); i++) {\n+            if (!sendKey(\"\" + channel.charAt(i))) {\n+                return false;\n+            }\n+            try {\n+                Thread.sleep(200);\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Get key code to send to receiver\n+     *\n+     * @param key Key for which to get the key code\n+     * @return\n+     */\n+    private String getKeyCode(String key) {\n+        if (key.contains(\"0x\")) {\n+            // direct key code\n+            return key;\n+        }\n+        if (keyMap.isEmpty()) {\n+            initializeKeyMap();\n+        }\n+        if (keyMap.containsKey(key)) {\n+            return keyMap.get(key);\n+        }\n+        return \"\";\n+    }\n+\n+    /**\n+     * Map playStatus code to string for a list of codes see\n+     * http://support.huawei.com/hedex/pages/DOC1100366313CEH0713H/01/DOC1100366313CEH0713H/01/resources/dsv_hdx_idp/DSV/en/en-us_topic_0094619231.html\n+     *\n+     * @param playStatus Integer code parsed form json (see EV_PLAYCHG_XXX)\n+     * @return playStatus as String\n+     */\n+    public String getPlayStatus(int playStatus) {\n+        if (playStatus == EV_PLAYCHG_PLAY) {\n+            return \"playing\";\n+        } else if (playStatus == EV_PLAYCHG_STOP) {\n+            return \"stopped\";\n+        } else if (playStatus == EV_PLAYCHG_PAUSE) {\n+            return \"paused\";\n+        } else if (playStatus == EV_PLAYCHG_TRICK) {\n+            return \"tricking\";\n+        } else if (playStatus == EV_PLAYCHG_MC_PLAY) {\n+            return \"playing (MC)\";\n+        } else if (playStatus == EV_PLAYCHG_UC_PLAY) {\n+            return \"playing (UC)\";\n+        } else if (playStatus == EV_PLAYCHG_BUFFERING) {\n+            return \"buffering\";\n+        } else {\n+            return Integer.toString(playStatus);\n+        }\n+    }\n+\n+    /**\n+     * Map runningStatus code to string for a list of codes see\n+     * http://support.huawei.com/hedex/pages/DOC1100366313CEH0713H/01/DOC1100366313CEH0713H/01/resources/dsv_hdx_idp/DSV/en/en-us_topic_0094619523.html\n+     *\n+     * @param runStatus Integer code parsed form json (see EV_EITCHG_RUNNING_XXX)\n+     * @return runningStatus as String\n+     */\n+    public String getRunStatus(int runStatus) {\n+        if (runStatus == EV_EITCHG_RUNNING_NOT_RUNNING) {", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMTkxMg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488301912", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T23:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2MzgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTA1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487565056", "bodyText": "You probably meant to break here?", "author": "Hilbrand", "createdAt": "2020-09-13T19:03:24Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVControl.java", "diffHunk": "@@ -0,0 +1,622 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.text.MessageFormat;\n+import java.util.HashMap;\n+import java.util.StringTokenizer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVHttp;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVOAuth;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVControl} implements the control functions for the\n+ * receiver.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVControl {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVControl.class);\n+    private final static HashMap<String, String> keyMap = new HashMap<String, String>();\n+\n+    private final MagentaTVNetwork network;\n+    private final MagentaTVHttp http = new MagentaTVHttp();\n+    private final MagentaTVOAuth oauth = new MagentaTVOAuth();\n+    private final MagentaTVDynamicConfig config;\n+    private boolean initialized = false;\n+    private String thingId = \"\";\n+\n+    public MagentaTVControl() {\n+        config = new MagentaTVDynamicConfig();\n+        network = new MagentaTVNetwork();\n+    }\n+\n+    public MagentaTVControl(MagentaTVDynamicConfig config, MagentaTVNetwork network) {\n+        thingId = config.getFriendlyName();\n+        this.network = network;\n+        this.config = config;\n+        this.config.setTerminalID(computeMD5(network.getLocalMAC().toUpperCase() + config.getUDN()));\n+        this.config.setLocalIP(network.getLocalIP());\n+        this.config.setLocalMAC(network.getLocalMAC());\n+        initializeKeyMap();\n+        initialized = true;\n+    }\n+\n+    public boolean isInitialized() {\n+        return initialized;\n+    }\n+\n+    /**\n+     * Returns the thingConfig - the Control class adds various attributes of the\n+     * discovered device (like the MR model)\n+     *\n+     * @return thingConfig\n+     */\n+    public MagentaTVDynamicConfig getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Initiate OAuth authentication\n+     *\n+     * @param accountName T-Online user id\n+     * @param accountPassword T-Online password\n+     * @return true: successful, false: failed\n+     *\n+     * @throws MagentaTVException\n+     */\n+    public String getUserId(String accountName, String accountPassword) throws MagentaTVException {\n+        return oauth.getUserId(accountName, accountPassword);\n+    }\n+\n+    /**\n+     * Retries the device properties. This will result in an Exception if the device\n+     * is not connected.\n+     *\n+     * Response is returned in XMl format, e.g.:\n+     * <?xml version=\"1.0\"?> <root xmlns=\"urn:schemas-upnp-org:device-1-0\">\n+     * <specVersion><major>1</major><minor>0</minor></specVersion> <device>\n+     * <UDN>uuid:70dff25c-1bdf-5731-a283-XXXXXXXX</UDN>\n+     * <friendlyName>DMS_XXXXXXXXXXXX</friendlyName>\n+     * <deviceType>urn:schemas-upnp-org:device:tvdevice:1</deviceType>\n+     * <manufacturer>Zenterio</manufacturer> <modelName>MR401B</modelName>\n+     * <modelNumber>R01A5</modelNumber> <productVersionNumber>&quot; 334\n+     * &quot;</productVersionNumber> <productType>stb</productType>\n+     * <serialNumber></serialNumber> <X_wakeOnLan>0</X_wakeOnLan> <serviceList>\n+     * <service> <serviceType>urn:dial-multiscreen-org:service:dial:1</serviceType>\n+     * <serviceId>urn:dial-multiscreen-org:service:dial</serviceId> </service>\n+     * </serviceList> </device> </root>\n+     *\n+     * @return true: device is online, false: device is offline\n+     * @throws MagentaTVException\n+     */\n+    public boolean checkDev() throws MagentaTVException {\n+        logger.debug(\"{}: Check device {} ({}:{})\", thingId, config.getTerminalID(), config.getIpAddress(),\n+                config.getPort());\n+\n+        String url = MessageFormat.format(CHECKDEV_URI, config.getIpAddress(), config.getPort(),\n+                config.getDescriptionUrl());\n+        String result = http.httpGet(buildHost(), url, \"\");\n+        if (result.contains(\"<modelName>\")) {\n+            {\n+                config.setModel(substringBetween(result, \"<modelName>\", \"</modelName>\"));\n+            }\n+        }\n+        if (result.contains(\"<modelNumber>\")) {\n+            {\n+                config.setHardwareVersion(substringBetween(result, \"<modelNumber>\", \"</modelNumber>\"));\n+            }\n+        }\n+        if (result.contains(\"<X_wakeOnLan>\")) {\n+            {\n+                String wol = substringBetween(result, \"<X_wakeOnLan>\", \"</X_wakeOnLan>\");\n+                config.setWakeOnLAN(wol);\n+                logger.debug(\"{}: Wake-on-LAN is {}\", thingId, wol.equals(\"0\") ? \"disabled\" : \"enabled\");\n+            }\n+        }\n+        if (result.contains(\"<productVersionNumber>\")) {\n+            {\n+                String version;\n+                if (result.contains(\"<productVersionNumber>&quot; \")) {\n+                    version = substringBetween(result, \"<productVersionNumber>&quot; \",\n+                            \" &quot;</productVersionNumber>\");\n+                } else {\n+                    version = substringBetween(result, \"<productVersionNumber>\", \"</productVersionNumber>\");\n+                }\n+                config.setFirmwareVersion(version);\n+            }\n+        }\n+        if (result.contains(\"<friendlyName>\")) {\n+            String friendlyName = result.substring(result.indexOf(\"<friendlyName>\") + \"<friendlyName>\".length(),\n+                    result.indexOf(\"</friendlyName>\"));\n+            config.setFriendlyName(friendlyName);\n+        }\n+        if (result.contains(\"<UDN>uuid:\")) {\n+            String udn = result.substring(result.indexOf(\"<UDN>uuid:\") + \"<UDN>uuid:\".length(),\n+                    result.indexOf(\"</UDN>\"));\n+            if (config.getUDN().isEmpty()) {\n+                config.setUDN(udn);\n+            }\n+        }\n+        logger.trace(\"{}: Online status verified for device {}:{}, UDN={}\", thingId, config.getIpAddress(),\n+                config.getPort(), config.getUDN());\n+        return true;\n+    }\n+\n+    /**\n+     *\n+     * Sends a SUBSCRIBE request to the MR. This also defines the local callback url\n+     * used by the MR to return the pairing code and event information.\n+     *\n+     * Subscripbe to event channel a) receive the pairing code b) receive\n+     * programInfo and playStatus events after successful paring\n+     *\n+     * SUBSCRIBE /upnp/service/X-CTC_RemotePairing/Event HTTP/1.1\\r\\n HOST:\n+     * $remote_ip:$remote_port CALLBACK: <http://$local_ip:$local_port/>\\r\\n // NT:\n+     * upnp:event\\r\\n // TIMEOUT: Second-300\\r\\n // CONNECTION: close\\r\\n // \\r\\n\n+     *\n+     * @throws MagentaTVException\n+     */\n+    public void subscribeEventChannel() throws MagentaTVException {\n+        String sid = \"\";\n+        logger.debug(\"{}: Subscribe Event Channel (terminalID={}, {}:{}\", thingId, config.getTerminalID(),\n+                config.getIpAddress(), config.getPort());\n+        String subscribe = MessageFormat.format(PAIRING_SUBSCRIBE, config.getIpAddress(), config.getPort(),\n+                network.getLocalIP(), network.getLocalPort(), PAIRING_NOTIFY_URI, PAIRING_TIMEOUT_SEC);\n+        String response = http.sendData(config.getIpAddress(), config.getPort(), subscribe);\n+        if (!response.contains(\"200 OK\")) {\n+            response = substringBefore(response, \"SERVER\");\n+            throw new MagentaTVException(\"Unable to subscribe to pairing channel: \" + response);\n+        }\n+        if (!response.contains(NOTIFY_SID)) {\n+            throw new MagentaTVException(\"Unable to subscribe to pairing channel, SID missing: \" + response);\n+        }\n+\n+        StringTokenizer tokenizer = new StringTokenizer(response, \"\\r\\n\");\n+        while (tokenizer.hasMoreElements()) {\n+            String str = tokenizer.nextToken();\n+            if (!str.isEmpty()) {\n+                if (str.contains(NOTIFY_SID)) {\n+                    sid = str.substring(\"SID: uuid:\".length());\n+                    logger.debug(\"{}: SUBSCRIBE returned SID {}\", thingId, sid);\n+                    continue;", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMjE2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488302166", "bodyText": "yep, changed", "author": "markus7017", "createdAt": "2020-09-14T23:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTE5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487565196", "bodyText": "interface methods don't need public:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onPairingResult(String pairingCode) throws MagentaTVException;\n          \n          \n            \n                void onPairingResult(String pairingCode) throws MagentaTVException;", "author": "Hilbrand", "createdAt": "2020-09-13T19:04:47Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVListener.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+\n+/**\n+ * The {@link MagentaTVListener} defines the interface to pass back the pairing\n+ * code and device events to the listener\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface MagentaTVListener {\n+    /**\n+     * Device returned pairing code\n+     *\n+     * @param pairingCode Code to be used for pairing process\n+     * @throws MagentaTVException\n+     */\n+    public void onPairingResult(String pairingCode) throws MagentaTVException;", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMjQ2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488302467", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T23:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTgwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487565804", "bodyText": "Maybe use try-with-resources to auto close:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        DatagramSocket socket = new DatagramSocket();\n          \n          \n            \n                        try (DatagramSocket socket = new DatagramSocket()) {", "author": "Hilbrand", "createdAt": "2020-09-13T19:10:31Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/network/MagentaTVNetwork.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.network;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.net.UnknownHostException;\n+\n+import org.apache.commons.net.util.SubnetUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVNetwork} supplies network functions.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVNetwork {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVNetwork.class);\n+\n+    private String localIP = \"\";\n+    private String localPort = \"\";\n+    private String localMAC = \"\";\n+    private @Nullable NetworkInterface localInterface;\n+\n+    /**\n+     * Init local network interface, determine local IP and MAC address\n+     *\n+     * @param networkAddressService\n+     * @return\n+     */\n+    public void initLocalNet(String localIP, String localPort) throws MagentaTVException {\n+        try {\n+            if (localIP.isEmpty() || localIP.equals(\"0.0.0.0\") || localIP.equals(\"127.0.0.1\")) {\n+                throw new MagentaTVException(\"Unable to detect local IP address!\");\n+            }\n+            this.localPort = localPort;\n+            this.localIP = localIP;\n+\n+            // get MAC address\n+            InetAddress ip = InetAddress.getByName(localIP);\n+            localInterface = NetworkInterface.getByInetAddress(ip);\n+            if (localInterface != null) {\n+                byte[] mac = localInterface.getHardwareAddress();\n+                StringBuilder sb = new StringBuilder();\n+                for (int i = 0; i < mac.length; i++) {\n+                    sb.append(String.format(\"%02X%s\", mac[i], (i < mac.length - 1) ? \":\" : \"\"));\n+                }\n+                localMAC = sb.toString().toUpperCase();\n+                logger.debug(\"Local IP address={}, Local MAC address = {}\", localIP, localMAC);\n+                return;\n+            }\n+        } catch (UnknownHostException | SocketException e) {\n+            throw new MagentaTVException(e);\n+        }\n+\n+        throw new MagentaTVException(\n+                \"Unable to get local IP / MAC address, check network settings in openHAB system configuration!\");\n+    }\n+\n+    /**\n+     * Checks if client ip equals or is in range of ip networks provided by\n+     * semicolon separated list\n+     *\n+     * @param clientIp in numeric form like \"192.168.0.10\"\n+     * @param ipList like \"127.0.0.1;192.168.0.0/24;10.0.0.0/8\"\n+     * @return true if client ip from the list os ips and networks\n+     */\n+    public static boolean isIpInSubnet(String clientIp, String ipList) {\n+        if (ipList.isEmpty()) {\n+            // No ip address provided\n+            return true;\n+        }\n+        String[] subnetMasks = ipList.split(\";\");\n+        for (String subnetMask : subnetMasks) {\n+            subnetMask = subnetMask.trim();\n+            if (clientIp.equals(subnetMask)) {\n+                return true;\n+            }\n+            if (subnetMask.contains(\"/\")) {\n+                if (new SubnetUtils(subnetMask).getInfo().isInRange(clientIp)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Nullable\n+    public NetworkInterface getLocalInterface() {\n+        return localInterface;\n+    }\n+\n+    public String getLocalIP() {\n+        return localIP;\n+    }\n+\n+    public String getLocalPort() {\n+        return localPort;\n+    }\n+\n+    public String getLocalMAC() {\n+        return localMAC;\n+    }\n+\n+    public static final int WOL_PORT = 9;\n+\n+    /**\n+     * Send a Wake-on-LAN packet\n+     *\n+     * @param ipAddr destination ip\n+     * @param macAddress destination MAC address\n+     * @throws MagentaTVException\n+     */\n+    public void sendWakeOnLAN(String ipAddr, String macAddress) throws MagentaTVException {\n+        try {\n+            byte[] macBytes = getMacBytes(macAddress);\n+            byte[] bytes = new byte[6 + 16 * macBytes.length];\n+            for (int i = 0; i < 6; i++) {\n+                bytes[i] = (byte) 0xff;\n+            }\n+            for (int i = 6; i < bytes.length; i += macBytes.length) {\n+                System.arraycopy(macBytes, 0, bytes, i, macBytes.length);\n+            }\n+\n+            InetAddress address = InetAddress.getByName(ipAddr);\n+            DatagramPacket packet = new DatagramPacket(bytes, bytes.length, address, WOL_PORT);\n+            DatagramSocket socket = new DatagramSocket();", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMjk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488302957", "bodyText": "changed\nthis needs no socket.close(), correct?", "author": "markus7017", "createdAt": "2020-09-15T00:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU5MzQzMw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488593433", "bodyText": "correct. When using, what is called, try-with-resources java will automatically close the stream. This works for all code that implements Closable.", "author": "Hilbrand", "createdAt": "2020-09-15T11:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTkyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487565929", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = HttpServlet.class, configurationPolicy = ConfigurationPolicy.OPTIONAL, immediate = true)\n          \n          \n            \n            @Component(service = HttpServlet.class, configurationPolicy = ConfigurationPolicy.OPTIONAL)", "author": "Hilbrand", "createdAt": "2020-09-13T19:11:36Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/network/MagentaTVNotifyServlet.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.network;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.substringBetween;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Scanner;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Main OSGi service and HTTP servlet for MagentaTV NOTIFY.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = HttpServlet.class, configurationPolicy = ConfigurationPolicy.OPTIONAL, immediate = true)", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMzEwOA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488303108", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-15T00:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NTkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NjExOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487566119", "bodyText": "The gson variable and initialization can also be a field, so it's only done once.", "author": "Hilbrand", "createdAt": "2020-09-13T19:13:26Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/network/MagentaTVOAuth.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.network;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.substringAfterLast;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.text.MessageFormat;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import javax.ws.rs.HttpMethod;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.net.http.HttpUtil;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAuthenticateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAuthenticateResponseInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponseInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentialsInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthKeyValue;\n+import org.openhab.binding.magentatv.internal.handler.MagentaTVControl;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVOAuth} class implements the OAuth authentication, which\n+ * is used to query the userID from the Telekom platform.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ *         Deutsche Telekom uses a OAuth-based authentication to access the EPG portal. The\n+ *         communication between the MR and the remote app requires a pairing before the receiver could be\n+ *         controlled by sending keys etc. The so called userID is not directly derived from any local parameters\n+ *         (like terminalID as a has from the mac address), but will be returned as a result from the OAuth\n+ *         authentication. This will be performed in 3 steps\n+ *         1. Get OAuth credentials -> Service URL, Scope, Secret, Client ID\n+ *         2. Get OAth Token -> authentication token for step 3\n+ *         3. Authenticate, which then provides the userID (beside other parameters)\n+ *\n+ */\n+@NonNullByDefault\n+public class MagentaTVOAuth {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVOAuth.class);\n+\n+    public String getUserId(String accountName, String accountPassword) throws MagentaTVException {\n+        logger.debug(\"Authenticate with account {}\", accountName);\n+        if (accountName.isEmpty() || accountPassword.isEmpty()) {\n+            throw new MagentaTVException(\"Credentials for OAuth missing, check thing config!\");\n+        }\n+\n+        String step = \"initialize\";\n+        String url = \"\";\n+        Properties httpHeader;\n+        String postData = \"\";\n+        String httpResponse = \"\";\n+        InputStream dataStream = null;\n+\n+        // OAuth autentication results\n+        String oAuthScope = \"\";\n+        String oAuthService = \"\";\n+        String epghttpsurl = \"\";\n+        String retcode = \"\";\n+        String retmsg = \"\";\n+\n+        try {\n+            Gson gson = new GsonBuilder()", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMzUxNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488303515", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-15T00:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NjExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2Njc2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487566762", "bodyText": "zero is already predefined in DecimalType.ZERO", "author": "Hilbrand", "createdAt": "2020-09-13T19:19:47Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,688 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVDeviceManager;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAuthenticateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMzcwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488303702", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-15T00:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2Njc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NzEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487567102", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        initializeJob = scheduler.schedule(() -> {\n          \n          \n            \n                        initializeJob = scheduler.schedule(this::initializeThing, 5, TimeUnit.SECONDS);", "author": "Hilbrand", "createdAt": "2020-09-13T19:23:31Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,688 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVDeviceManager;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAuthenticateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVDeviceManager manager;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVDeviceManager manager, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.manager = manager;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAuthenticateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAuthenticateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - initiate OAuth if userId is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMzkzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r488303934", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-15T00:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NzEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NzMwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487567301", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        renewEventJob = scheduler.scheduleWithFixedDelay(() -> {\n          \n          \n            \n                        renewEventJob = scheduler.scheduleWithFixedDelay(this::renewEventSubscription, 2, 5, TimeUnit.MINUTES);", "author": "Hilbrand", "createdAt": "2020-09-13T19:24:56Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,688 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVDeviceManager;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAuthenticateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVDeviceManager manager;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVDeviceManager manager, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.manager = manager;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAuthenticateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAuthenticateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - initiate OAuth if userId is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserId().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                getUserId();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(() -> {", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NDYzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487884637", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T12:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NzMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NzUzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487567538", "bodyText": "The exception toString also contains the whole stacktrace, so you probalby what to do e.getMessage()", "author": "Hilbrand", "createdAt": "2020-09-13T19:27:24Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,688 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVDeviceManager;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAuthenticateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVDeviceManager manager;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVDeviceManager manager, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.manager = manager;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAuthenticateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAuthenticateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - initiate OAuth if userId is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserId().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                getUserId();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(() -> {\n+                renewEventSubscription();\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineStatus(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserId(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails\n+            }\n+\n+            logger.debug(\"{}: Channel command for device {}: {} for channel {}\", thingId, config.getFriendlyName(),\n+                    command, channelUID.getId());\n+            switch (channelUID.getId()) {\n+                case CHANNEL_POWER: // toggle power\n+                    logger.debug(\"{}: Toggle power, new state={}\", thingId, command);\n+                    control.sendKey(\"POWER\");\n+                    break;\n+                case CHANNEL_PLAYER:\n+                    logger.debug(\"{}: Player command: {}\", thingId, command);\n+                    if (command instanceof OnOffType) {\n+                        control.sendKey(\"POWER\");\n+                    } else if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            control.sendKey(\"PLAY\");\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            control.sendKey(\"PAUSE\");\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            control.sendKey(\"NEXTCH\");\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            control.sendKey(\"PREVCH\");\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                        if (command == RewindFastforwardType.FASTFORWARD) {\n+                            control.sendKey(\"FORWARD\");\n+                        } else if (command == RewindFastforwardType.REWIND) {\n+                            control.sendKey(\"REWIND\");\n+                        }\n+                    } else {\n+                        logger.debug(\"{}: Unknown media command: {}\", thingId, command);\n+                    }\n+                    break;\n+                case CHANNEL_CHANNEL:\n+                    String chan = command.toString();\n+                    control.selectChannel(chan);\n+                    break;\n+                case CHANNEL_MUTE:\n+                    if (command == OnOffType.ON) {\n+                        control.sendKey(\"MUTE\");\n+                    } else {\n+                        control.sendKey(\"VOLUP\");\n+                    }\n+                    break;\n+                case CHANNEL_KEY:\n+                    if (command.toString().equalsIgnoreCase(\"PAIR\")) { // special key to re-pair receiver (already done\n+                                                                       // above)\n+                        logger.debug(\"{}: PAIRing key received, reconnect receiver {}\", thingId, deviceName());\n+                    } else {\n+                        control.sendKey(command.toString());\n+                        mapKeyToMediateState(command.toString());\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"{}: Command {} for unknown channel {}\", thingId, command, channelUID.getAsString());\n+            }\n+        } catch (MagentaTVException e) {\n+            String errorMessage = MessageFormat.format(\"Channel operation failed (command={0}, value={1}): {2}\",\n+                    command, channelUID.getId(), e.toString());", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NTE3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487885179", "bodyText": "yep, changed", "author": "markus7017", "createdAt": "2020-09-14T12:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NzUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NzY2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487567662", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            this.getThing().getStatusInfo().getStatus().toString(),\n          \n          \n            \n                            this.getThing().getStatusInfo().getStatus(),", "author": "Hilbrand", "createdAt": "2020-09-13T19:29:04Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/handler/MagentaTVHandler.java", "diffHunk": "@@ -0,0 +1,688 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.handler;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DateTimeType;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.NextPreviousType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PlayPauseType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.RewindFastforwardType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.magentatv.internal.MagentaTVDeviceManager;\n+import org.openhab.binding.magentatv.internal.MagentaTVException;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRPayEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEvent;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramInfoEventInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatus;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRProgramStatusInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfo;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.MRShortProgramInfoInstanceCreator;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthAuthenticateResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OAuthTokenResponse;\n+import org.openhab.binding.magentatv.internal.MagentaTVGsonDTO.OauthCredentials;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVDynamicConfig;\n+import org.openhab.binding.magentatv.internal.config.MagentaTVThingConfiguration;\n+import org.openhab.binding.magentatv.internal.network.MagentaTVNetwork;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MagentaTVHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVHandler extends BaseThingHandler implements MagentaTVListener {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVHandler.class);\n+    private static final DecimalType ZERO = new DecimalType(0);\n+\n+    protected MagentaTVDynamicConfig config = new MagentaTVDynamicConfig();\n+    private final Gson gson;\n+    protected final MagentaTVNetwork network;\n+    protected final MagentaTVDeviceManager manager;\n+    protected MagentaTVControl control = new MagentaTVControl();\n+\n+    private String thingId = \"\";\n+    private volatile int idRefresh = 0;\n+    private @Nullable ScheduledFuture<?> initializeJob;\n+    private @Nullable ScheduledFuture<?> pairingWatchdogJob;\n+    private @Nullable ScheduledFuture<?> renewEventJob;\n+\n+    /**\n+     * Constructor, save bindingConfig (services as default for thingConfig)\n+     *\n+     * @param thing\n+     * @param bindingConfig\n+     */\n+    public MagentaTVHandler(MagentaTVDeviceManager manager, Thing thing, MagentaTVNetwork network) {\n+        super(thing);\n+        this.manager = manager;\n+        this.network = network;\n+        gson = new GsonBuilder().registerTypeAdapter(OauthCredentials.class, new MRProgramInfoEventInstanceCreator())\n+                .registerTypeAdapter(OAuthTokenResponse.class, new MRProgramStatusInstanceCreator())\n+                .registerTypeAdapter(OAuthAuthenticateResponse.class, new MRShortProgramInfoInstanceCreator())\n+                .registerTypeAdapter(OAuthAuthenticateResponse.class, new MRPayEventInstanceCreator()).create();\n+    }\n+\n+    /**\n+     * Thing initialization:\n+     * - initialize thing status from UPnP discovery, thing config, local network settings\n+     * - initiate OAuth if userId is not configured and credentials are available\n+     * - wait for NotifyServlet to initialize (solves timing issues on fast startup)\n+     */\n+    @Override\n+    public void initialize() {\n+        // The framework requires you to return from this method quickly. For that the initialization itself is executed\n+        // asynchronously\n+        String label = getThing().getLabel();\n+        thingId = label != null ? label : getThing().getUID().toString();\n+        resetEventChannels();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        config = new MagentaTVDynamicConfig(getConfigAs(MagentaTVThingConfiguration.class));\n+        try {\n+            initializeJob = scheduler.schedule(() -> {\n+                initializeThing();\n+            }, 5, TimeUnit.SECONDS);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Unable to schedule thing initialization\", e);\n+        }\n+    }\n+\n+    private void initializeThing() {\n+        String errorMessage = \"\";\n+        try {\n+            if (config.getUDN().isEmpty()) {\n+                // get UDN from device name\n+                String uid = this.getThing().getUID().getAsString();\n+                config.setUDN(substringAfterLast(uid, \":\"));\n+            }\n+            if (config.getMacAddress().isEmpty()) {\n+                // get MAC address from UDN (last 12 digits)\n+                String macAddress = substringAfterLast(config.getUDN(), \"_\");\n+                if (macAddress.isEmpty()) {\n+                    macAddress = substringAfterLast(config.getUDN(), \"-\");\n+                }\n+                config.setMacAddress(macAddress);\n+            }\n+            control = new MagentaTVControl(config, network);\n+            config.updateNetwork(control.getConfig()); // get network parameters from control\n+\n+            // Check for emoty credentials (e.g. missing in .things file)\n+            String account = config.getAccountName();\n+            if (config.getUserId().isEmpty()) {\n+                if (account.isEmpty()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Credentials missing or invalid! Fill credentials into thing configuration or generate UID on the openHAB console - see README\");\n+                    return;\n+                }\n+\n+                getUserId();\n+            }\n+\n+            connectReceiver(); // throws MagentaTVException on error\n+\n+            // setup background device check\n+            renewEventJob = scheduler.scheduleWithFixedDelay(() -> {\n+                renewEventSubscription();\n+            }, 2, 5, TimeUnit.MINUTES);\n+\n+            // change to ThingStatus.ONLINE will be done when the pairing result is received\n+            // (see onPairingResult())\n+        } catch (MagentaTVException e) {\n+            errorMessage = e.toString();\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on initialization\", thingId, e);\n+        } finally {\n+            if (!errorMessage.isEmpty()) {\n+                logger.debug(\"{}: {}\", thingId, errorMessage);\n+                setOnlineStatus(ThingStatus.OFFLINE, errorMessage);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This routine is called every time the Thing configuration has been changed (e.g. PaperUI)\n+     */\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        logger.debug(\"{}: Thing config updated, re-initialize\", thingId);\n+        cancelAllJobs();\n+        if (configurationParameters.containsKey(PROPERTY_ACCT_NAME)) {\n+            @Nullable\n+            String newAccount = (String) configurationParameters.get(PROPERTY_ACCT_NAME);\n+            if ((newAccount != null) && !newAccount.isEmpty()) {\n+                // new account info, need to renew userId\n+                config.setUserId(\"\");\n+            }\n+        }\n+\n+        super.handleConfigurationUpdate(configurationParameters);\n+    }\n+\n+    /**\n+     * Handle channel commands\n+     *\n+     * @param channelUID - the channel, which received the command\n+     * @param command - the actual command (could be instance of StringType,\n+     *            DecimalType or OnOffType)\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command == RefreshType.REFRESH) {\n+            // currently no channels to be refreshed\n+            return;\n+        }\n+\n+        try {\n+            if (!isOnline() || command.toString().equalsIgnoreCase(\"PAIR\")) {\n+                logger.debug(\"{}: Receiver {} is offline, try to (re-)connect\", thingId, deviceName());\n+                connectReceiver(); // reconnect to MR, throws an exception if this fails\n+            }\n+\n+            logger.debug(\"{}: Channel command for device {}: {} for channel {}\", thingId, config.getFriendlyName(),\n+                    command, channelUID.getId());\n+            switch (channelUID.getId()) {\n+                case CHANNEL_POWER: // toggle power\n+                    logger.debug(\"{}: Toggle power, new state={}\", thingId, command);\n+                    control.sendKey(\"POWER\");\n+                    break;\n+                case CHANNEL_PLAYER:\n+                    logger.debug(\"{}: Player command: {}\", thingId, command);\n+                    if (command instanceof OnOffType) {\n+                        control.sendKey(\"POWER\");\n+                    } else if (command instanceof PlayPauseType) {\n+                        if (command == PlayPauseType.PLAY) {\n+                            control.sendKey(\"PLAY\");\n+                        } else if (command == PlayPauseType.PAUSE) {\n+                            control.sendKey(\"PAUSE\");\n+                        }\n+                    } else if (command instanceof NextPreviousType) {\n+                        if (command == NextPreviousType.NEXT) {\n+                            control.sendKey(\"NEXTCH\");\n+                        } else if (command == NextPreviousType.PREVIOUS) {\n+                            control.sendKey(\"PREVCH\");\n+                        }\n+                    } else if (command instanceof RewindFastforwardType) {\n+                        if (command == RewindFastforwardType.FASTFORWARD) {\n+                            control.sendKey(\"FORWARD\");\n+                        } else if (command == RewindFastforwardType.REWIND) {\n+                            control.sendKey(\"REWIND\");\n+                        }\n+                    } else {\n+                        logger.debug(\"{}: Unknown media command: {}\", thingId, command);\n+                    }\n+                    break;\n+                case CHANNEL_CHANNEL:\n+                    String chan = command.toString();\n+                    control.selectChannel(chan);\n+                    break;\n+                case CHANNEL_MUTE:\n+                    if (command == OnOffType.ON) {\n+                        control.sendKey(\"MUTE\");\n+                    } else {\n+                        control.sendKey(\"VOLUP\");\n+                    }\n+                    break;\n+                case CHANNEL_KEY:\n+                    if (command.toString().equalsIgnoreCase(\"PAIR\")) { // special key to re-pair receiver (already done\n+                                                                       // above)\n+                        logger.debug(\"{}: PAIRing key received, reconnect receiver {}\", thingId, deviceName());\n+                    } else {\n+                        control.sendKey(command.toString());\n+                        mapKeyToMediateState(command.toString());\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"{}: Command {} for unknown channel {}\", thingId, command, channelUID.getAsString());\n+            }\n+        } catch (MagentaTVException e) {\n+            String errorMessage = MessageFormat.format(\"Channel operation failed (command={0}, value={1}): {2}\",\n+                    command, channelUID.getId(), e.toString());\n+            logger.debug(\"{}: {}\", thingId, errorMessage);\n+            setOnlineStatus(ThingStatus.OFFLINE, errorMessage);\n+        }\n+    }\n+\n+    private void mapKeyToMediateState(String key) {\n+        State state = null;\n+        switch (key.toUpperCase()) {\n+            case \"PLAY\":\n+                state = PlayPauseType.PLAY;\n+                break;\n+            case \"PAUSE\":\n+                state = PlayPauseType.PAUSE;\n+                break;\n+            case \"FORWARD\":\n+                state = RewindFastforwardType.FASTFORWARD;\n+                break;\n+            case \"REWIND\":\n+                updateState(CHANNEL_PLAYER, RewindFastforwardType.REWIND);\n+                break;\n+        }\n+        if (state != null) {\n+            logger.debug(\"{}: Setting Player state to {}\", thingId, state);\n+            updateState(CHANNEL_PLAYER, state);\n+        }\n+    }\n+\n+    /**\n+     * Connect to the receiver\n+     *\n+     * @throws MagentaTVException something failed\n+     */\n+    protected void connectReceiver() throws MagentaTVException {\n+        if (control.checkDev()) {\n+            updateThingProperties();\n+            manager.registerDevice(config.getUDN(), config.getTerminalID(), config.getIpAddress(), this);\n+            control.subscribeEventChannel();\n+            control.sendPairingRequest();\n+\n+            // check for pairing timeout\n+            final int iRefresh = ++idRefresh;\n+            pairingWatchdogJob = scheduler.schedule(() -> {\n+                if (iRefresh == idRefresh) { // Make a best effort to not run multiple deferred refresh\n+                    if (config.getVerificationCode().isEmpty()) {\n+                        setOnlineStatus(ThingStatus.OFFLINE, \"Timeout on pairing request!\");\n+                    }\n+                }\n+            }, 15, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * If userId is empty and credentials are given the Telekom OAuth service is\n+     * used to query the userId\n+     *\n+     * @throws MagentaTVException\n+     */\n+    private void getUserId() throws MagentaTVException {\n+        String userId = config.getUserId();\n+        if (userId.isEmpty()) {\n+            // run OAuth authentication, this finally provides the userId\n+            logger.debug(\"{}: Login with account {}\", thingId, config.getAccountName());\n+            userId = control.getUserId(config.getAccountName(), config.getAccountPassword());\n+\n+            // Update thing configuration (persistent) - remove credentials, add userId\n+            Configuration configuration = this.getConfig();\n+            configuration.remove(PROPERTY_ACCT_NAME);\n+            configuration.remove(PROPERTY_ACCT_PWD);\n+            configuration.remove(PROPERTY_USERID);\n+            configuration.put(PROPERTY_ACCT_NAME, \"\");\n+            configuration.put(PROPERTY_ACCT_PWD, \"\");\n+            configuration.put(PROPERTY_USERID, userId);\n+            this.updateConfiguration(configuration);\n+            config.setAccountName(\"\");\n+            config.setAccountPassword(\"\");\n+        } else {\n+            logger.debug(\"{}: Skip OAuth, use existing userId {}\", thingId, config.getUserId());\n+        }\n+        if (!userId.isEmpty()) {\n+            config.setUserId(userId);\n+        } else {\n+            logger.warn(\"{}: Unable to obtain userId from OAuth\", thingId);\n+        }\n+    }\n+\n+    /**\n+     * Update thing status\n+     *\n+     * @param mode new thing status\n+     * @return ON = power on, OFF=power off\n+     */\n+    public void setOnlineStatus(ThingStatus newStatus, String errorMessage) {\n+        ThingStatus status = this.getThing().getStatus();\n+        if (status != newStatus) {\n+            if (newStatus == ThingStatus.ONLINE) {\n+                updateStatus(newStatus);\n+                updateState(CHANNEL_POWER, OnOffType.ON);\n+            } else {\n+                if (!errorMessage.isEmpty()) {\n+                    logger.debug(\"{}: Communication Error - {}, switch Thing offline\", thingId, errorMessage);\n+                    updateStatus(newStatus, ThingStatusDetail.COMMUNICATION_ERROR, errorMessage);\n+                } else {\n+                    updateStatus(newStatus);\n+                }\n+                updateState(CHANNEL_POWER, OnOffType.OFF);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A wakeup of the MR was detected (e.g. UPnP received)\n+     *\n+     * @throws MagentaTVException\n+     */\n+    @Override\n+    public void onWakeup(Map<String, String> discoveredProperties) throws MagentaTVException {\n+        if ((this.getThing().getStatus() == ThingStatus.OFFLINE) || config.getVerificationCode().isEmpty()) {\n+            // Device sent a UPnP discovery information, trigger to reconnect\n+            connectReceiver();\n+        } else {\n+            logger.debug(\"{}: Refesh device status for {} (UDN={}\", thingId, deviceName(), config.getUDN());\n+            setOnlineStatus(ThingStatus.ONLINE, \"\");\n+        }\n+    }\n+\n+    /**\n+     * The pairing result has been received. The pairing code will be used to generate the verification code and\n+     * complete pairing with the MR. Finally if pairing was completed successful the thing status will change to ONLINE\n+     *\n+     * @param pairingCode pairing code received from MR (NOTIFY event data)\n+     * @throws MagentaTVException\n+     */\n+    @Override\n+    public void onPairingResult(String pairingCode) throws MagentaTVException {\n+        if (control.isInitialized()) {\n+            if (control.generateVerificationCode(pairingCode)) {\n+                config.setPairingCode(pairingCode);\n+                logger.debug(\n+                        \"{}: Pairing code received (UDN {}, terminalID {}, pairingCode={}, verificationCode={}, userId={})\",\n+                        thingId, config.getUDN(), config.getTerminalID(), config.getPairingCode(),\n+                        config.getVerificationCode(), config.getUserId());\n+\n+                // verify pairing completes the pairing process\n+                if (control.verifyPairing()) {\n+                    logger.debug(\"{}: Pairing completed for device {} ({}), Thing now ONLINE\", thingId,\n+                            config.getFriendlyName(), config.getTerminalID());\n+                    setOnlineStatus(ThingStatus.ONLINE, \"\");\n+                    cancelPairingCheck(); // stop timeout check\n+                }\n+            }\n+            updateThingProperties(); // persist pairing and verification code\n+        } else {\n+            logger.debug(\"{}: control not yet initialized!\", thingId);\n+        }\n+    }\n+\n+    @Override\n+    public void onMREvent(String jsonInput) {\n+        logger.trace(\"{}: Process MR event for device {}, json={}\", thingId, deviceName(), jsonInput);\n+        boolean flUpdatePower = false;\n+        String jsonEvent = fixEventJson(jsonInput);\n+        if (jsonEvent.contains(MR_EVENT_EIT_CHANGE)) {\n+            logger.debug(\"{}: EVENT_EIT_CHANGE event received.\", thingId);\n+\n+            MRProgramInfoEvent pinfo = gson.fromJson(jsonEvent, MRProgramInfoEvent.class);\n+            if (!pinfo.channelNum.isEmpty()) {\n+                logger.debug(\"{}: EVENT_EIT_CHANGE for channel {}/{}\", thingId, pinfo.channelNum, pinfo.channelCode);\n+                updateState(CHANNEL_CHANNEL, new DecimalType(pinfo.channelNum));\n+                updateState(CHANNEL_CHANNEL_CODE, new DecimalType(pinfo.channelCode));\n+            }\n+            if (pinfo.programInfo != null) {\n+                int i = 0;\n+                for (MRProgramStatus ps : pinfo.programInfo) {\n+                    if ((ps.startTime == null) || ps.startTime.isEmpty()) {\n+                        logger.debug(\"{}: EVENT_EIT_CHANGE: empty event data = {}\", thingId, jsonEvent);\n+                        continue; // empty program_info\n+                    }\n+                    updateState(CHANNEL_RUN_STATUS, new StringType(control.getRunStatus(ps.runningStatus)));\n+\n+                    if (ps.shortEvent != null) {\n+                        for (MRShortProgramInfo se : ps.shortEvent) {\n+                            if ((ps.startTime == null) || ps.startTime.isEmpty()) {\n+                                logger.debug(\"{}: EVENT_EIT_CHANGE: empty program info\", thingId);\n+                                continue;\n+                            }\n+                            // Convert UTC to local time\n+                            // 2018/11/04 21:45:00 -> \"2018-11-04T10:15:30.00Z\"\n+                            String tsLocal = ps.startTime.replace('/', '-').replace(\" \", \"T\") + \"Z\";\n+                            Instant timestamp = Instant.parse(tsLocal);\n+                            ZonedDateTime localTime = timestamp.atZone(ZoneId.of(\"Europe/Berlin\"));\n+                            tsLocal = substringBeforeLast(localTime.toString(), \"[\");\n+                            tsLocal = substringBefore(tsLocal.replace('-', '/').replace('T', ' '), \"+\");\n+\n+                            logger.debug(\"{}: Info for channel {} / {} - {} {}.{}, start time={}, duration={}\", thingId,\n+                                    pinfo.channelNum, pinfo.channelCode, control.getRunStatus(ps.runningStatus),\n+                                    se.eventName, se.textChar, tsLocal, ps.duration);\n+                            if (ps.runningStatus != EV_EITCHG_RUNNING_NOT_RUNNING) {\n+                                updateState(CHANNEL_PROG_TITLE, new StringType(se.eventName));\n+                                updateState(CHANNEL_PROG_TEXT, new StringType(se.textChar));\n+                                updateState(CHANNEL_PROG_START, new DateTimeType(localTime));\n+\n+                                try {\n+                                    DateFormat dateFormat = new SimpleDateFormat(\"HH:mm:ss\");\n+                                    dateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+                                    Date date = dateFormat.parse(ps.duration);\n+                                    long minutes = date.getTime() / 1000L / 60l;\n+                                    updateState(CHANNEL_PROG_DURATION, toQuantityType(minutes, SmartHomeUnits.MINUTE));\n+                                } catch (ParseException e) {\n+                                    logger.debug(\"{}: Unable to parse programDuration: {}\", thingId, ps.duration);\n+                                }\n+\n+                                if (i++ == 0) {\n+                                    flUpdatePower = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        } else if (jsonEvent.contains(\"new_play_mode\")) {\n+            MRPayEvent event = gson.fromJson(jsonEvent, MRPayEvent.class);\n+            if (event.duration == null) {\n+                event.duration = -1;\n+            }\n+            if (event.playPostion == null) {\n+                event.playPostion = -1;\n+            }\n+            logger.debug(\"{}: STB event playContent: playMode={}, duration={}, playPosition={}\", thingId,\n+                    control.getPlayStatus(event.newPlayMode), event.duration, event.playPostion);\n+\n+            // If we get a playConfig event there MR must be online. However it also sends a\n+            // plyMode stop before powering off the device, so we filter this.\n+            if ((event.newPlayMode != EV_PLAYCHG_STOP) && this.isInitialized()) {\n+                flUpdatePower = true;\n+            }\n+            if (event.newPlayMode != -1) {\n+                String playMode = control.getPlayStatus(event.newPlayMode);\n+                updateState(CHANNEL_PLAY_MODE, new StringType(playMode));\n+                mapPlayModeToMediaControl(playMode);\n+            }\n+            if (event.duration > 0) {\n+                updateState(CHANNEL_PROG_DURATION, new StringType(event.duration.toString()));\n+            }\n+            if (event.playPostion != -1) {\n+                updateState(CHANNEL_PROG_POS, toQuantityType(event.playPostion / 6, SmartHomeUnits.MINUTE));\n+            }\n+        } else {\n+            logger.debug(\"{}: Unknown MR event, JSON={}\", thingId, jsonEvent);\n+        }\n+        if (flUpdatePower) {\n+            // We received a non-stopped event -> MR must be on\n+            updateState(CHANNEL_POWER, OnOffType.ON);\n+        }\n+    }\n+\n+    private void mapPlayModeToMediaControl(String playMode) {\n+        switch (playMode) {\n+            case \"playing\":\n+            case \"playing (MC)\":\n+            case \"playing (UC)\":\n+            case \"buffering\":\n+                logger.debug(\"{}: Setting Player state to PLAY\", thingId);\n+                updateState(CHANNEL_PLAYER, PlayPauseType.PLAY);\n+                break;\n+            case \"paused\":\n+            case \"stopped\":\n+                logger.debug(\"{}: Setting Player state to PAUSE\", thingId);\n+                updateState(CHANNEL_PLAYER, PlayPauseType.PAUSE);\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * When the MR powers off it send a UPnP message, which is catched by the binding.\n+     */\n+    @Override\n+    public void onPowerOff() throws MagentaTVException {\n+        logger.debug(\"{}: Power-Off received for device {}\", thingId, deviceName());\n+        // MR was powered off -> update power status, reset items\n+        resetEventChannels();\n+    }\n+\n+    private void resetEventChannels() {\n+        updateState(CHANNEL_POWER, OnOffType.OFF);\n+        updateState(CHANNEL_PROG_TITLE, StringType.EMPTY);\n+        updateState(CHANNEL_PROG_TEXT, StringType.EMPTY);\n+        updateState(CHANNEL_PROG_START, StringType.EMPTY);\n+        updateState(CHANNEL_PROG_DURATION, ZERO);\n+        updateState(CHANNEL_PROG_POS, ZERO);\n+        updateState(CHANNEL_CHANNEL, ZERO);\n+        updateState(CHANNEL_CHANNEL_CODE, ZERO);\n+    }\n+\n+    private String fixEventJson(String jsonEvent) {\n+        // MR401: channel_num is a string -> ok\n+        // MR201: channel_num is an int -> fix JSON formatting to String\n+        if (jsonEvent.contains(MR_EVENT_CHAN_TAG) && !jsonEvent.contains(MR_EVENT_CHAN_TAG + \"\\\"\")) {\n+            // hack: reformat the JSON string to make it compatible with the GSON parsing\n+            logger.trace(\"{}: malformed JSON->fix channel_num\", thingId);\n+            String start = substringBefore(jsonEvent, MR_EVENT_CHAN_TAG); // up to \"channel_num\":\n+            String end = substringAfter(jsonEvent, MR_EVENT_CHAN_TAG); // behind \"channel_num\":\n+            String chan = substringBetween(jsonEvent, MR_EVENT_CHAN_TAG, \",\").trim();\n+            return start + \"\\\"channel_num\\\":\" + \"\\\"\" + chan + \"\\\"\" + end;\n+        }\n+        return jsonEvent;\n+    }\n+\n+    private boolean isOnline() {\n+        return this.getThing().getStatus() == ThingStatus.ONLINE;\n+    }\n+\n+    /**\n+     * Renew the event subscription. The periodic refresh is required, otherwise the receive will stop sending events.\n+     * Reconnect if nessesary.\n+     */\n+    private void renewEventSubscription() {\n+        if (!control.isInitialized()) {\n+            return;\n+        }\n+        logger.debug(\"{}: Check receiver status, current state  {}/{}\", thingId,\n+                this.getThing().getStatusInfo().getStatus().toString(),", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NTY4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487885684", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T12:49:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NzY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2ODA5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487568093", "bodyText": "For this thread can you set the name and deamon:\nsetName(\"OH-Binding-magentatv\");\nsetDeamon(true);", "author": "Hilbrand", "createdAt": "2020-09-13T19:32:54Z", "path": "bundles/org.openhab.binding.magentatv/src/main/java/org/openhab/binding/magentatv/internal/network/MagentaTVPoweroffListener.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.magentatv.internal.network;\n+\n+import static org.openhab.binding.magentatv.internal.MagentaTVBindingConstants.*;\n+import static org.openhab.binding.magentatv.internal.MagentaTVUtil.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.magentatv.internal.MagentaTVHandlerFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MagentaTVPoweroffListener} implements a UPnP listener to detect\n+ * power-off of the receiver\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MagentaTVPoweroffListener extends Thread {\n+    private final Logger logger = LoggerFactory.getLogger(MagentaTVPoweroffListener.class);\n+\n+    private final MagentaTVHandlerFactory handlerFactory;\n+\n+    public static final String UPNP_MULTICAST_ADDRESS = \"239.255.255.250\";\n+    public static final int UPNP_PORT = 1900;\n+    public static final String UPNP_BYEBYE_MESSAGE = \"ssdp:byebye\";\n+\n+    protected final MulticastSocket socket;\n+    protected @Nullable NetworkInterface networkInterface;\n+    protected byte[] buf = new byte[256];\n+\n+    public MagentaTVPoweroffListener(MagentaTVHandlerFactory handlerFactory,\n+            @Nullable NetworkInterface networkInterface) throws IOException {\n+        this.handlerFactory = handlerFactory;\n+        this.networkInterface = networkInterface;\n+        socket = new MulticastSocket(UPNP_PORT);\n+    }", "originalCommit": "0ad5261b5fdd8129e589874cd325069ac424a39d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NjQ3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7864#discussion_r487886472", "bodyText": "changed", "author": "markus7017", "createdAt": "2020-09-14T12:51:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2ODA5Mw=="}], "type": "inlineReview"}, {"oid": "18d9d48d64f90bbbb39504954aa9f713e13a2c54", "url": "https://github.com/openhab/openhab-addons/commit/18d9d48d64f90bbbb39504954aa9f713e13a2c54", "message": "review changes + German translation for key codes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-14T13:48:02Z", "type": "commit"}, {"oid": "98e810d3f4a1c40f8154caab8b22b6e7cabba9c7", "url": "https://github.com/openhab/openhab-addons/commit/98e810d3f4a1c40f8154caab8b22b6e7cabba9c7", "message": "review changes applied\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>", "committedDate": "2020-09-15T00:05:09Z", "type": "commit"}]}