{"pr_number": 8209, "pr_title": "[WlanThermo] Initial contribution", "pr_createdAt": "2020-07-26T23:29:07Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8209", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1NTY5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480955695", "bodyText": "This looks like it's not formatted correctly. Can you run mvn spotless:apply on your code.", "author": "Hilbrand", "createdAt": "2020-09-01T08:14:58Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoHandlerFactory.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link WlanThermoHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.wlanthermo\", service = ThingHandlerFactory.class)\n+public class WlanThermoHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = new HashSet<ThingTypeUID>(Arrays.asList(WlanThermoBindingConstants.THING_TYPE_WLANTHERMO_NANO, WlanThermoBindingConstants.THING_TYPE_WLANTHERMO_MINI));", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1NjQzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480956439", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @NonNullByDefault({})\n          \n          \n            \n                private String ipAddress;\n          \n          \n            \n                private String ipAddress = \"\";", "author": "Hilbrand", "createdAt": "2020-09-01T08:16:07Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniConfiguration.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link WlanThermoConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniConfiguration {\n+\n+    /**\n+     * IP Address of WlanThermo.\n+     */\n+    @NonNullByDefault({})\n+    private String ipAddress;", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk1NjYyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480956628", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                private String username;\n          \n          \n            \n                private @Nullable String username;", "author": "Hilbrand", "createdAt": "2020-09-01T08:16:29Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniConfiguration.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link WlanThermoConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniConfiguration {\n+\n+    /**\n+     * IP Address of WlanThermo.\n+     */\n+    @NonNullByDefault({})\n+    private String ipAddress;\n+\n+    /**\n+     * Username of WlanThermo user.\n+     */\n+    @Nullable\n+    private String username;", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTIzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480961238", "bodyText": "Don't create your own client, but pass the client via the factory with HttpClientFactory and get a client via httpClientFactory.getCommonHttpClient().", "author": "Hilbrand", "createdAt": "2020-09-01T08:24:17Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1NDE0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481454143", "bodyText": "Can you give a few more details on that? How do I obtain the HttpClientFactory in the Factory class?", "author": "CSchlipp", "createdAt": "2020-09-01T21:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyODkwNA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r482228904", "bodyText": "See some other bindings. Here ia a good example: https://github.com/openhab/openhab-addons/blob/2.5.x/bundles/org.openhab.binding.ojelectronics/src/main/java/org/openhab/binding/ojelectronics/internal/OJCloudHandlerFactory.java", "author": "Hilbrand", "createdAt": "2020-09-02T17:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTYwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480961607", "bodyText": "Why not use the scheduler from the parent class?", "author": "Hilbrand", "createdAt": "2020-09-01T08:24:55Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1NjYxNw==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481456617", "bodyText": "I had a lot of problems with RejectedExecutionExceptions, similar to #1078. Implemented is as suggested in that ticket and got no errors since...", "author": "CSchlipp", "createdAt": "2020-09-01T22:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0MDI0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r482240243", "bodyText": "I don't  know why you got those errors. But your code doesnt look more complex than the average binding that uses the scheduler without problems. That means i suspect something else might be wrong. What i do see is in the method checkConnection you cancel the pollers in certain conditions. However this method is called from within those scheduled threads, meaning the call to cancle would cancel the thread its running on itself, and that might cause some problems. I would suggest  to have a look at how the flow goes and see if you can improve this and try using the provided scheduler. Or if you still have problems show some loging to see if we can find the cause.", "author": "Hilbrand", "createdAt": "2020-09-02T17:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTE4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487429188", "bodyText": "In order to get this in the last 2.5 release, I'd prefer to leave it as it is - running.\nWill conduct some tests later and check if this can be reverted to the common scheduler, ok?", "author": "CSchlipp", "createdAt": "2020-09-12T17:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2MTYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2Mzg4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480963884", "bodyText": "If you have 2 configurations that are the same than use 1 class.", "author": "Hilbrand", "createdAt": "2020-09-01T08:28:31Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoConfiguration.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link WlanThermoConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoConfiguration {", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyODkwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487428907", "bodyText": "Configurations are actually different. Removed Copy&Paste errors ;)", "author": "CSchlipp", "createdAt": "2020-09-12T17:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2Mzg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NDU2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480964569", "bodyText": "If you don't explicitly initialize gson to do something with the Expose annotation you should not annotate fields with Expose. It's then by default exposed.", "author": "Hilbrand", "createdAt": "2020-09-01T08:29:35Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1ODE0Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481458147", "bodyText": "The Gson objects are auto-generated from the json-output.\nIf this is not a blocker for you, I'd rather like to keep them as they are. This will allow an easier update of these classes in case of future JSON changes.", "author": "CSchlipp", "createdAt": "2020-09-01T22:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NDU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0MzEwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r482243109", "bodyText": "Ok  no problem, maybe you can document this in the code somewhere and how you generated the files.", "author": "Hilbrand", "createdAt": "2020-09-02T17:27:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NDU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NTI0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r480965249", "bodyText": "If the variable name is the same as the serialized name than serialized name can be omitted. This is also better for readability of the code.", "author": "Hilbrand", "createdAt": "2020-09-01T08:30:41Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose\n+    private String tempUnit;\n+    @SerializedName(\"pit\")", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ1ODQzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481458432", "bodyText": "Same as above.\nIf this is not a blocker, I'd like to keep it as auto-generated from the JSON to make future updates more easy.", "author": "CSchlipp", "createdAt": "2020-09-01T22:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk2NTI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwMjgzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481402831", "bodyText": "Is this Exception thrown? otherwise you should catch the specific exception.", "author": "Hilbrand", "createdAt": "2020-09-01T20:11:13Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNjM3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481406374", "bodyText": "Only log to error is this is a serious bug. This looks more like a user error and should probably be a warn or info log.", "author": "Hilbrand", "createdAt": "2020-09-01T20:18:01Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNjY2MA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481406660", "bodyText": "lots of empty lines in this area.", "author": "Hilbrand", "createdAt": "2020-09-01T20:18:34Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNjg0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481406841", "bodyText": "Is this exception thrown? or can you make it the specific eception?", "author": "Hilbrand", "createdAt": "2020-09-01T20:18:59Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNzU5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481407596", "bodyText": "This should probably be shown to the user in the thing status. In general the user should not have to look into the log to find out what the problem is. If you set the status this log can be reduced to debug.", "author": "Hilbrand", "createdAt": "2020-09-01T20:20:26Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwNzk4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481407981", "bodyText": "Same comment here as aboce regarding settting status/ log level usage.", "author": "Hilbrand", "createdAt": "2020-09-01T20:21:09Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    logger.error(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status, uri.toString());", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQwODA1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481408058", "bodyText": "Same comment here as aboce regarding settting status/ log level usage.", "author": "Hilbrand", "createdAt": "2020-09-01T20:21:19Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    logger.error(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status, uri.toString());\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                logger.error(\"Failed to update channel {} on device\", c.getName(), e);", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMDQ3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481410479", "bodyText": "No need to set status in dispose the framework takes care of this.", "author": "Hilbrand", "createdAt": "2020-09-01T20:25:58Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    logger.error(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status, uri.toString());\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                logger.error(\"Failed to update channel {} on device\", c.getName(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        } \n+        updateStatus(ThingStatus.REMOVED);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        }\n+        for (Channel channel : thing.getChannels()) {\n+            if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                updateState(channel.getUID(), OnOffType.OFF);\n+            } else {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+        }\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.GONE);", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMDY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481410683", "bodyText": "In dispose you should not set channel states.", "author": "Hilbrand", "createdAt": "2020-09-01T20:26:22Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    logger.error(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status, uri.toString());\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                logger.error(\"Failed to update channel {} on device\", c.getName(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        } \n+        updateStatus(ThingStatus.REMOVED);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        }\n+        for (Channel channel : thing.getChannels()) {", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMTEyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481411122", "bodyText": "Remove this implementation. It is handled by the dispose method.", "author": "Hilbrand", "createdAt": "2020-09-01T20:27:10Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(), TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Could not connect to WlanThermo at \"+config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(true);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+    \n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.error(\"Could not handle command of type {} for channel {}!\",command.getClass().toGenericString() , channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            //Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+            \n+            \n+            //Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    //if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+            \n+\n+        } catch (Exception e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+    \n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri)\n+                                .content(new StringContentProvider(json), \"application/json\")\n+                                .timeout(5, TimeUnit.SECONDS)\n+                                .send()\n+                                .getStatus();\n+                if (status == 401) {\n+                    logger.error(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    logger.error(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status, uri.toString());\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                logger.error(\"Failed to update channel {} on device\", c.getName(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMTY4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481411688", "bodyText": "This error should be reflected in the thing status and log to debug.", "author": "Hilbrand", "createdAt": "2020-09-01T20:28:18Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private HttpClient httpClient = new HttpClient();\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to initialize WlanThermo Nano!\", e);", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMjc3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r481412778", "bodyText": "Almost all comments regarding WlanThermoNanoHandler also apply here. Maybe you can make a shared parent class to have the shared code in 1 place.", "author": "Hilbrand", "createdAt": "2020-09-01T20:30:24Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.google.gson.Gson;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {", "originalCommit": "aaf5c2e7048246293a24c2ab1dff59cee289f274", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyOTA2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487429068", "bodyText": "As the underlying API and data objects differ, the common code is in fact quite small. As some methods have been removed, it became even smaller.\nLeft it with 2 independent handlers.", "author": "CSchlipp", "createdAt": "2020-09-12T17:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQxMjc3OA=="}], "type": "inlineReview"}, {"oid": "89a23c8668038f98905941936e2414f5500307ad", "url": "https://github.com/openhab/openhab-addons/commit/89a23c8668038f98905941936e2414f5500307ad", "message": "[wlanthermo] Initial contribution\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-13T15:04:24Z", "type": "commit"}, {"oid": "95e8de3bac65f65cf65790994da20f5594e807fc", "url": "https://github.com/openhab/openhab-addons/commit/95e8de3bac65f65cf65790994da20f5594e807fc", "message": "Fix first review findings\nReformatted code\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-13T15:04:25Z", "type": "commit"}, {"oid": "0c4e58b9c870c07035f30219d45fabd2dfa8130a", "url": "https://github.com/openhab/openhab-addons/commit/0c4e58b9c870c07035f30219d45fabd2dfa8130a", "message": "Added comment on auto-generated code\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-13T15:04:25Z", "type": "commit"}, {"oid": "eecb127eb156e164103ba5994fa6095f44ad9d62", "url": "https://github.com/openhab/openhab-addons/commit/eecb127eb156e164103ba5994fa6095f44ad9d62", "message": "Pass commonHttpClient to Handlers\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-13T15:04:25Z", "type": "commit"}, {"oid": "839e090c24280559216c37bc7a3e110ea13cd20b", "url": "https://github.com/openhab/openhab-addons/commit/839e090c24280559216c37bc7a3e110ea13cd20b", "message": "revamp error logging and pollingScheduler cancelling\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-13T15:04:25Z", "type": "commit"}, {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "url": "https://github.com/openhab/openhab-addons/commit/dc33af7dfbca3a9dfe62ddbe67abcda684436207", "message": "fix formatting and thing-types.xml\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-13T15:04:25Z", "type": "commit"}, {"oid": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "url": "https://github.com/openhab/openhab-addons/commit/dc33af7dfbca3a9dfe62ddbe67abcda684436207", "message": "fix formatting and thing-types.xml\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-13T15:04:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5NTc2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487795766", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Map<String, String> colorMappings = createColorMap();\n          \n          \n            \n                private static final Map<String, String> COLOR_MAPPINGS = createColorMap();", "author": "Hilbrand", "createdAt": "2020-09-14T10:03:00Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/nano/UtilNano.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.nano;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The {@link UtilNano} class provides conversion functions for the WlanThermo Nano\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class UtilNano {\n+\n+    private static final Map<String, String> colorMappings = createColorMap();", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5ODM5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487798391", "bodyText": "Can you remove the package here?", "author": "Hilbrand", "createdAt": "2020-09-14T10:07:34Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/Channel.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ * Class is auto-generated from JSON using http://www.jsonschema2pojo.org/\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class Channel {\n+\n+    @SerializedName(\"0\")\n+    @Expose\n+    private org.openhab.binding.wlanthermo.internal.api.mini.builtin.Data _0;", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc5ODc5OA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487798798", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Map<String, String> colorMappings = createColorMap();\n          \n          \n            \n                private static final Map<String, String> COLOR_MAPPINGS = createColorMap();", "author": "Hilbrand", "createdAt": "2020-09-14T10:08:19Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/UtilMini.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The {@link UtilMini} class provides conversion functions for the WlanThermo Mini\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class UtilMini {\n+    private static final Map<String, String> colorMappings = createColorMap();", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMDA2OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487800069", "bodyText": "I assume these methods are not auto generated. It might be better to move them out of this class to keep this generated code as much as possible as was generated. Just a suggestion.", "author": "Hilbrand", "createdAt": "2020-09-14T10:10:26Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ * Class is auto-generated from JSON using http://www.jsonschema2pojo.org/\n+ * Be careful to not overwrite the getState/getTrigger function mapping the Data to OH channels!\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose\n+    private String tempUnit;\n+    @SerializedName(\"pit\")\n+    @Expose\n+    private Pit pit;\n+    @SerializedName(\"pit2\")\n+    @Expose\n+    private Pit pit2;\n+    @SerializedName(\"cpu_load\")\n+    @Expose\n+    private Double cpuLoad;\n+    @SerializedName(\"cpu_temp\")\n+    @Expose\n+    private Double cpuTemp;\n+    @SerializedName(\"channel\")\n+    @Expose\n+    private Channel channel;\n+    @SerializedName(\"timestamp\")\n+    @Expose\n+    private String timestamp;\n+\n+    /**\n+     * No args constructor for use in serialization\n+     * \n+     */\n+    public App() {\n+    }\n+\n+    /**\n+     * \n+     * @param cpuLoad\n+     * @param pit2\n+     * @param tempUnit\n+     * @param channel\n+     * @param pit\n+     * @param cpuTemp\n+     * @param timestamp\n+     */\n+    public App(String tempUnit, Pit pit, Pit pit2, Double cpuLoad, Double cpuTemp, Channel channel, String timestamp) {\n+        super();\n+        this.tempUnit = tempUnit;\n+        this.pit = pit;\n+        this.pit2 = pit2;\n+        this.cpuLoad = cpuLoad;\n+        this.cpuTemp = cpuTemp;\n+        this.channel = channel;\n+        this.timestamp = timestamp;\n+    }\n+\n+    public String getTempUnit() {\n+        return tempUnit;\n+    }\n+\n+    public void setTempUnit(String tempUnit) {\n+        this.tempUnit = tempUnit;\n+    }\n+\n+    public App withTempUnit(String tempUnit) {\n+        this.tempUnit = tempUnit;\n+        return this;\n+    }\n+\n+    public Pit getPit() {\n+        return pit;\n+    }\n+\n+    public void setPit(Pit pit) {\n+        this.pit = pit;\n+    }\n+\n+    public App withPit(Pit pit) {\n+        this.pit = pit;\n+        return this;\n+    }\n+\n+    public Pit getPit2() {\n+        return pit2;\n+    }\n+\n+    public void setPit2(Pit pit2) {\n+        this.pit2 = pit2;\n+    }\n+\n+    public App withPit2(Pit pit2) {\n+        this.pit2 = pit2;\n+        return this;\n+    }\n+\n+    public Double getCpuLoad() {\n+        return cpuLoad;\n+    }\n+\n+    public void setCpuLoad(Double cpuLoad) {\n+        this.cpuLoad = cpuLoad;\n+    }\n+\n+    public App withCpuLoad(Double cpuLoad) {\n+        this.cpuLoad = cpuLoad;\n+        return this;\n+    }\n+\n+    public Double getCpuTemp() {\n+        return cpuTemp;\n+    }\n+\n+    public void setCpuTemp(Double cpuTemp) {\n+        this.cpuTemp = cpuTemp;\n+    }\n+\n+    public App withCpuTemp(Double cpuTemp) {\n+        this.cpuTemp = cpuTemp;\n+        return this;\n+    }\n+\n+    public Channel getChannel() {\n+        return channel;\n+    }\n+\n+    public void setChannel(Channel channel) {\n+        this.channel = channel;\n+    }\n+\n+    public App withChannel(Channel channel) {\n+        this.channel = channel;\n+        return this;\n+    }\n+\n+    public String getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public void setTimestamp(String timestamp) {\n+        this.timestamp = timestamp;\n+    }\n+\n+    public App withTimestamp(String timestamp) {\n+        this.timestamp = timestamp;\n+        return this;\n+    }\n+\n+    public State getState(ChannelUID channelUID, WlanThermoMiniHandler wlanThermoHandler) {", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1NDA1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491154053", "bodyText": "Done. Command Handling has been moved to a dedicated class instead.", "author": "CSchlipp", "createdAt": "2020-09-18T19:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMDA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMjQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487802456", "bodyText": "You should not call start on the common client. Remove this code.", "author": "Hilbrand", "createdAt": "2020-09-14T10:14:31Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            httpClient.start();", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMjY2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487802668", "bodyText": "When you remove the start call you can also remove this exception catch.", "author": "Hilbrand", "createdAt": "2020-09-14T10:14:55Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Mini!\");\n+        } catch (Exception e) {", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMjg4OA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487802888", "bodyText": "Remove this part. You should not call stop on the common client.", "author": "Hilbrand", "createdAt": "2020-09-14T10:15:19Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Mini!\");\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Mini!\");\n+            logger.debug(\"Failed to initialize WlanThermo Mini!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri(\"/app.php\")).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(false);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = app.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        }\n+        // Mini is read only!\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/app.php\")).getContentAsString();\n+            app = gson.fromJson(json, App.class);\n+            logger.debug(\"Received at /app.php: {}\", json);\n+\n+            // Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = app.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    String trigger = app.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+\n+            }\n+\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        }", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMzI4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487803284", "bodyText": "Same comment here about start", "author": "Hilbrand", "createdAt": "2020-09-14T10:15:55Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwMzQ3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487803470", "bodyText": "Same comment here about exception catching related to start removal.", "author": "Hilbrand", "createdAt": "2020-09-14T10:16:18Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgwNDA1OA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487804058", "bodyText": "Remove this part. You should not call stop on the common client.", "author": "Hilbrand", "createdAt": "2020-09-14T10:17:20Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = data.getState(channelUID, this);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (data.setState(channelUID, command)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.warn(\"Could not handle command of type {} for channel {}!\", command.getClass().toGenericString(),\n+                        channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = data.getState(channel.getUID(), this);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = data.getTrigger(channel.getUID());\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                if (channel.getUID().getId().equals(SYSTEM + \"#\" + SYSTEM_ONLINE)) {\n+                    updateState(channel.getUID(), OnOffType.OFF);\n+                } else {\n+                    updateState(channel.getUID(), UnDefType.UNDEF);\n+                }\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    logger.warn(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.warn(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status,\n+                            uri.toString());\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device!\");\n+                logger.warn(\"Failed to update channel {} on device\", c.getName(), e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingScheduler != null) {\n+            boolean stopped = pollingScheduler.cancel(true);\n+            logger.debug(\"Stopped polling: {}\", stopped);\n+        }\n+        try {\n+            httpClient.stop();\n+            logger.debug(\"HTTP client stopped\");\n+        } catch (Exception e) {\n+            logger.error(\"Failed to stop HttpClient\", e);\n+        }", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgzNjE3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r487836171", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (channelUID.getId().startsWith(\"system#\")) {\n          \n          \n            \n                    if (\"system\".equals(channelUID.getGroupId())) {", "author": "Hilbrand", "createdAt": "2020-09-14T11:19:21Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/api/mini/builtin/App.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal.api.mini.builtin;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_DEVICE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_HIGH;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_ALARM_OPENHAB_LOW;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_COLOR_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_MIN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_NAME;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CHANNEL_ID;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_CURRENT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_DUTY_CYCLE;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_ENABLED;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_LID_OPEN;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_PITMASTER_SETPOINT;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.CHANNEL_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_LOAD;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_CPU_TEMP;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MAX;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.TRIGGER_ALARM_MIN;\n+\n+import java.awt.Color;\n+\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.WlanThermoMiniHandler;\n+\n+import com.google.gson.annotations.Expose;\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * This DTO is used to parse the JSON\n+ * Class is auto-generated from JSON using http://www.jsonschema2pojo.org/\n+ * Be careful to not overwrite the getState/getTrigger function mapping the Data to OH channels!\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+public class App {\n+\n+    @SerializedName(\"temp_unit\")\n+    @Expose\n+    private String tempUnit;\n+    @SerializedName(\"pit\")\n+    @Expose\n+    private Pit pit;\n+    @SerializedName(\"pit2\")\n+    @Expose\n+    private Pit pit2;\n+    @SerializedName(\"cpu_load\")\n+    @Expose\n+    private Double cpuLoad;\n+    @SerializedName(\"cpu_temp\")\n+    @Expose\n+    private Double cpuTemp;\n+    @SerializedName(\"channel\")\n+    @Expose\n+    private Channel channel;\n+    @SerializedName(\"timestamp\")\n+    @Expose\n+    private String timestamp;\n+\n+    /**\n+     * No args constructor for use in serialization\n+     * \n+     */\n+    public App() {\n+    }\n+\n+    /**\n+     * \n+     * @param cpuLoad\n+     * @param pit2\n+     * @param tempUnit\n+     * @param channel\n+     * @param pit\n+     * @param cpuTemp\n+     * @param timestamp\n+     */\n+    public App(String tempUnit, Pit pit, Pit pit2, Double cpuLoad, Double cpuTemp, Channel channel, String timestamp) {\n+        super();\n+        this.tempUnit = tempUnit;\n+        this.pit = pit;\n+        this.pit2 = pit2;\n+        this.cpuLoad = cpuLoad;\n+        this.cpuTemp = cpuTemp;\n+        this.channel = channel;\n+        this.timestamp = timestamp;\n+    }\n+\n+    public String getTempUnit() {\n+        return tempUnit;\n+    }\n+\n+    public void setTempUnit(String tempUnit) {\n+        this.tempUnit = tempUnit;\n+    }\n+\n+    public App withTempUnit(String tempUnit) {\n+        this.tempUnit = tempUnit;\n+        return this;\n+    }\n+\n+    public Pit getPit() {\n+        return pit;\n+    }\n+\n+    public void setPit(Pit pit) {\n+        this.pit = pit;\n+    }\n+\n+    public App withPit(Pit pit) {\n+        this.pit = pit;\n+        return this;\n+    }\n+\n+    public Pit getPit2() {\n+        return pit2;\n+    }\n+\n+    public void setPit2(Pit pit2) {\n+        this.pit2 = pit2;\n+    }\n+\n+    public App withPit2(Pit pit2) {\n+        this.pit2 = pit2;\n+        return this;\n+    }\n+\n+    public Double getCpuLoad() {\n+        return cpuLoad;\n+    }\n+\n+    public void setCpuLoad(Double cpuLoad) {\n+        this.cpuLoad = cpuLoad;\n+    }\n+\n+    public App withCpuLoad(Double cpuLoad) {\n+        this.cpuLoad = cpuLoad;\n+        return this;\n+    }\n+\n+    public Double getCpuTemp() {\n+        return cpuTemp;\n+    }\n+\n+    public void setCpuTemp(Double cpuTemp) {\n+        this.cpuTemp = cpuTemp;\n+    }\n+\n+    public App withCpuTemp(Double cpuTemp) {\n+        this.cpuTemp = cpuTemp;\n+        return this;\n+    }\n+\n+    public Channel getChannel() {\n+        return channel;\n+    }\n+\n+    public void setChannel(Channel channel) {\n+        this.channel = channel;\n+    }\n+\n+    public App withChannel(Channel channel) {\n+        this.channel = channel;\n+        return this;\n+    }\n+\n+    public String getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public void setTimestamp(String timestamp) {\n+        this.timestamp = timestamp;\n+    }\n+\n+    public App withTimestamp(String timestamp) {\n+        this.timestamp = timestamp;\n+        return this;\n+    }\n+\n+    public State getState(ChannelUID channelUID, WlanThermoMiniHandler wlanThermoHandler) {\n+        State state = null;\n+        if (channelUID.getId().startsWith(\"system#\")) {", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg2NDYxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r490864610", "bodyText": "When having a configuration error you should set the state to OFFLINE.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,", "author": "Hilbrand", "createdAt": "2020-09-18T10:51:36Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Mini!\");\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1MzY0NA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491153644", "bodyText": "Removed Exception block anyways", "author": "CSchlipp", "createdAt": "2020-09-18T19:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg2NDYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg2NzQxNA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r490867414", "bodyText": "It you have an InterruptedException it means this thread should stop and you should probably not reschedule anything.", "author": "Hilbrand", "createdAt": "2020-09-18T10:56:56Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM;\n+import static org.openhab.binding.wlanthermo.internal.WlanThermoBindingConstants.SYSTEM_ONLINE;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            httpClient.start();\n+\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (Exception e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.OFF);\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+                updateState(SYSTEM + \"#\" + SYSTEM_ONLINE, OnOffType.ON);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {", "originalCommit": "dc33af7dfbca3a9dfe62ddbe67abcda684436207", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1MzUxMg==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491153512", "bodyText": "The update-thread may get interrupted, but the reconnect-thread gets scheduled than. Looks fine for me...", "author": "CSchlipp", "createdAt": "2020-09-18T19:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg2NzQxNA=="}], "type": "inlineReview"}, {"oid": "ef7901e1fad948ac21e03b21b075d9fd24fa1d95", "url": "https://github.com/openhab/openhab-addons/commit/ef7901e1fad948ac21e03b21b075d9fd24fa1d95", "message": "Remove httpClient.start()\nRename static final var to UPPERCASE\nRemove package names from vars\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-18T16:23:34Z", "type": "commit"}, {"oid": "14cd5678f5848f9f6de5428787ba91a5ba3369ec", "url": "https://github.com/openhab/openhab-addons/commit/14cd5678f5848f9f6de5428787ba91a5ba3369ec", "message": "Moved Command Handling out of auto-generated classes\nRemoved online channel\nDon't stop common HttpClient\nUpdate README\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-18T19:33:27Z", "type": "commit"}, {"oid": "ddf9f54489842a51617f7f150f0c64e118b10b3b", "url": "https://github.com/openhab/openhab-addons/commit/ddf9f54489842a51617f7f150f0c64e118b10b3b", "message": "mvn spotless\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-18T19:35:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI5NjUyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491296525", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,", "author": "Hilbrand", "createdAt": "2020-09-19T06:48:21Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.WlanThermoNanoCommandHandler;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private WlanThermoNanoCommandHandler wlanThermoNanoCommandHandler = new WlanThermoNanoCommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,", "originalCommit": "ddf9f54489842a51617f7f150f0c64e118b10b3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyOTQ4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491329487", "bodyText": "Sorry, missed that one...", "author": "CSchlipp", "createdAt": "2020-09-19T08:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI5NjUyNQ=="}], "type": "inlineReview"}, {"oid": "b596b51beda9cc35858cff665fcb65af13bb0c7c", "url": "https://github.com/openhab/openhab-addons/commit/b596b51beda9cc35858cff665fcb65af13bb0c7c", "message": "Update bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-19T08:24:09Z", "type": "commit"}, {"oid": "b596b51beda9cc35858cff665fcb65af13bb0c7c", "url": "https://github.com/openhab/openhab-addons/commit/b596b51beda9cc35858cff665fcb65af13bb0c7c", "message": "Update bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java\n\nCo-authored-by: Hilbrand Bouwkamp <hilbrand@h72.nl>\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-19T08:24:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyMTk2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491321968", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (pollingScheduler != null) {\n          \n          \n            \n                                pollingScheduler.cancel(false);\n          \n          \n            \n                            }\n          \n          \n            \n                            ScheduledFuture<?> oldScheduler = pollingScheduler;\n          \n          \n            \n                            if (oldScheduler != null) {\n          \n          \n            \n                                oldScheduler.cancel(false);\n          \n          \n            \n                            }\n          \n      \n    \n    \n  \n\nThis should fix\n[WARNING] /home/travis/build/openhab/openhab-addons/bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java:[76,2910] Potential null pointer access: this expression has a '@Nullable' type\n\nAlso applies below in l. 88-90, l. 129-131 and l.141.143. In case you do not immediately re-init the scheduler, set the pollingScheduler = null;. Probably also in the other handler.", "author": "J-N-K", "createdAt": "2020-09-19T08:03:03Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoMiniHandler.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.App;\n+import org.openhab.binding.wlanthermo.internal.api.mini.builtin.WlanThermoMiniCommandHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoMiniHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoMiniHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoMiniHandler.class);\n+    private final WlanThermoMiniCommandHandler wlanThermoMiniCommandHandler = new WlanThermoMiniCommandHandler();\n+\n+    private WlanThermoMiniConfiguration config = new WlanThermoMiniConfiguration();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private App app = new App();\n+\n+    public WlanThermoMiniHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Mini!\");\n+        config = getConfigAs(WlanThermoMiniConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+        logger.debug(\"Finished initializing WlanThermo Mini!\");\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri(\"/app.php\")).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(false);\n+                }", "originalCommit": "ddf9f54489842a51617f7f150f0c64e118b10b3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMzOTc3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491339771", "bodyText": "That indeed removed the warning. Changed it!", "author": "CSchlipp", "createdAt": "2020-09-19T09:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyMTk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyOTMyMg==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491329322", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n          \n          \n            \n                   data.getChannel().forEach(c -> {\n          \n      \n    \n    \n  \n\nAlso removes the necessity for the fully qualified class name.", "author": "J-N-K", "createdAt": "2020-09-19T08:24:51Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.WlanThermoNanoCommandHandler;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private WlanThermoNanoCommandHandler wlanThermoNanoCommandHandler = new WlanThermoNanoCommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoNanoCommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoNanoCommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.warn(\"Could not handle command of type {} for channel {}!\", command.getClass().toGenericString(),\n+                        channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoNanoCommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoNanoCommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {", "originalCommit": "ddf9f54489842a51617f7f150f0c64e118b10b3b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMzOTg3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491339875", "bodyText": "Like that, done!", "author": "CSchlipp", "createdAt": "2020-09-19T09:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyOTMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyOTY4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491329684", "bodyText": "Not needed, thing status changes are logged anyway, If you want to log something, maybe log the content response at TRACE or DEBUG level (if it adds useful information),", "author": "J-N-K", "createdAt": "2020-09-19T08:25:56Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.WlanThermoNanoCommandHandler;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private WlanThermoNanoCommandHandler wlanThermoNanoCommandHandler = new WlanThermoNanoCommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoNanoCommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoNanoCommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.warn(\"Could not handle command of type {} for channel {}!\", command.getClass().toGenericString(),\n+                        channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoNanoCommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoNanoCommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    logger.warn(", "originalCommit": "ddf9f54489842a51617f7f150f0c64e118b10b3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMyOTgzOA==", "url": "https://github.com/openhab/openhab-addons/pull/8209#discussion_r491329838", "bodyText": "See above, thing status changes are always logged. You could reduce the exception stack trace to DEBUG or TRACE", "author": "J-N-K", "createdAt": "2020-09-19T08:26:36Z", "path": "bundles/org.openhab.binding.wlanthermo/src/main/java/org/openhab/binding/wlanthermo/internal/WlanThermoNanoHandler.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.wlanthermo.internal;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.*;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.Authentication;\n+import org.eclipse.jetty.client.api.AuthenticationStore;\n+import org.eclipse.jetty.client.util.DigestAuthentication;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.smarthome.core.common.ThreadPoolManager;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.wlanthermo.internal.api.nano.WlanThermoNanoCommandHandler;\n+import org.openhab.binding.wlanthermo.internal.api.nano.data.Data;\n+import org.openhab.binding.wlanthermo.internal.api.nano.settings.Settings;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * The {@link WlanThermoNanoHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Christian Schlipp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class WlanThermoNanoHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(WlanThermoNanoHandler.class);\n+\n+    private WlanThermoNanoConfiguration config = new WlanThermoNanoConfiguration();\n+    private WlanThermoNanoCommandHandler wlanThermoNanoCommandHandler = new WlanThermoNanoCommandHandler();\n+    private final HttpClient httpClient;\n+    private @Nullable ScheduledFuture<?> pollingScheduler;\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager\n+            .getScheduledPool(WlanThermoBindingConstants.WLANTHERMO_THREAD_POOL);\n+    private final Gson gson = new Gson();\n+    private Data data = new Data();\n+    private Settings settings = new Settings();\n+\n+    public WlanThermoNanoHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing WlanThermo Nano!\");\n+        config = getConfigAs(WlanThermoNanoConfiguration.class);\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            if (config.getUsername() != null && !config.getUsername().isEmpty() && config.getPassword() != null\n+                    && !config.getPassword().isEmpty()) {\n+                AuthenticationStore authStore = httpClient.getAuthenticationStore();\n+                authStore.addAuthentication(new DigestAuthentication(config.getUri(), Authentication.ANY_REALM,\n+                        config.getUsername(), config.getPassword()));\n+            }\n+            scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+\n+            logger.debug(\"Finished initializing WlanThermo Nano!\");\n+        } catch (URISyntaxException e) {\n+            updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Failed to initialize WlanThermo Nano!\");\n+            logger.debug(\"Failed to initialize WlanThermo Nano!\", e);\n+        }\n+    }\n+\n+    private void checkConnection() {\n+        try {\n+            if (httpClient.GET(config.getUri()).getStatus() == 200) {\n+                updateStatus(ThingStatus.ONLINE);\n+                if (pollingScheduler != null) {\n+                    pollingScheduler.cancel(true);\n+                }\n+                pollingScheduler = scheduler.scheduleWithFixedDelay(this::update, 0, config.getPollingInterval(),\n+                        TimeUnit.SECONDS);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"WlanThermo not found under given address.\");\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Failed to connect.\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Could not connect to WlanThermo at \" + config.getIpAddress());\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            pollingScheduler = scheduler.schedule(this::checkConnection, config.getPollingInterval(), TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            State s = wlanThermoNanoCommandHandler.getState(channelUID, data, settings);\n+            if (s != null)\n+                updateState(channelUID, s);\n+        } else {\n+            if (wlanThermoNanoCommandHandler.setState(channelUID, command, data)) {\n+                logger.debug(\"Data updated, pushing changes\");\n+                push();\n+            } else {\n+                logger.warn(\"Could not handle command of type {} for channel {}!\", command.getClass().toGenericString(),\n+                        channelUID.getId());\n+            }\n+        }\n+    }\n+\n+    private void update() {\n+        try {\n+            // Update objects with data from device\n+            String json = httpClient.GET(config.getUri(\"/data\")).getContentAsString();\n+            data = gson.fromJson(json, Data.class);\n+            logger.debug(\"Received at /data: {}\", json);\n+            json = httpClient.GET(config.getUri(\"/settings\")).getContentAsString();\n+            settings = gson.fromJson(json, Settings.class);\n+            logger.debug(\"Received at /settings: {}\", json);\n+\n+            // Update channels\n+            for (Channel channel : thing.getChannels()) {\n+                State state = wlanThermoNanoCommandHandler.getState(channel.getUID(), data, settings);\n+                if (state != null) {\n+                    updateState(channel.getUID(), state);\n+                } else {\n+                    // if we could not obtain a state, try trigger instead\n+                    String trigger = wlanThermoNanoCommandHandler.getTrigger(channel.getUID(), data);\n+                    if (trigger != null) {\n+                        triggerChannel(channel.getUID(), trigger);\n+                    }\n+                }\n+            }\n+        } catch (URISyntaxException | InterruptedException | ExecutionException | TimeoutException e) {\n+            logger.debug(\"Update failed, checking connection\", e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Update failed, reconnecting...\");\n+            if (pollingScheduler != null) {\n+                pollingScheduler.cancel(false);\n+            }\n+            for (Channel channel : thing.getChannels()) {\n+                updateState(channel.getUID(), UnDefType.UNDEF);\n+            }\n+            checkConnection();\n+        }\n+    }\n+\n+    private void push() {\n+        for (org.openhab.binding.wlanthermo.internal.api.nano.data.Channel c : data.getChannel()) {\n+            try {\n+                String json = gson.toJson(c);\n+                logger.debug(\"Pushing: {}\", json);\n+                URI uri = config.getUri(\"/setchannels\");\n+                int status = httpClient.POST(uri).content(new StringContentProvider(json), \"application/json\")\n+                        .timeout(5, TimeUnit.SECONDS).send().getStatus();\n+                if (status == 401) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                    logger.warn(\n+                            \"No or wrong login credentials provided. Please configure username/password for write access to WlanThermo!\");\n+                } else if (status != 200) {\n+                    updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Failed to update channel \"\n+                            + c.getName() + \" on device, Statuscode \" + status + \" on URI \" + uri.toString());\n+                    logger.warn(\"Failed to update channel {} on device, Statuscode {} on URI {}\", c.getName(), status,\n+                            uri.toString());\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                }\n+            } catch (InterruptedException | TimeoutException | ExecutionException | URISyntaxException e) {\n+                updateStatus(ThingStatus.ONLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Failed to update channel \" + c.getName() + \" on device!\");\n+                logger.warn(\"Failed to update channel {} on device\", c.getName(), e);", "originalCommit": "ddf9f54489842a51617f7f150f0c64e118b10b3b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "86d22695e9545b4a48b21e83cc18bbd129588e1c", "url": "https://github.com/openhab/openhab-addons/commit/86d22695e9545b4a48b21e83cc18bbd129588e1c", "message": "reworked scheduler cancelling\nReduced logging\nCode cleanup\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-19T08:59:19Z", "type": "commit"}, {"oid": "fbde187337391b103757dd4b3b1043dac53a69f4", "url": "https://github.com/openhab/openhab-addons/commit/fbde187337391b103757dd4b3b1043dac53a69f4", "message": "mvn spotless apply\n\nSigned-off-by: Christian Schlipp <christian@schlipp.de>", "committedDate": "2020-09-19T11:24:45Z", "type": "commit"}]}