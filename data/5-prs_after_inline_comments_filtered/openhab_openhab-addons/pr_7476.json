{"pr_number": 7476, "pr_title": "[hue] Add support for groups/rooms", "pr_createdAt": "2020-04-25T19:55:34Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7476", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE2NTI4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7476#discussion_r415165287", "bodyText": "please move final fields above non-final fields", "author": "cpmeister", "createdAt": "2020-04-25T23:16:22Z", "path": "bundles/org.openhab.binding.hue/src/main/java/org/openhab/binding/hue/internal/handler/HueGroupHandler.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.hue.internal.handler;\n+\n+import static org.openhab.binding.hue.internal.HueBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.hue.internal.FullGroup;\n+import org.openhab.binding.hue.internal.HueBridge;\n+import org.openhab.binding.hue.internal.StateUpdate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link HueGroupHandler} is the handler for a hue group of lights. It uses the {@link HueClient} to execute the\n+ * actual command.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HueGroupHandler extends BaseThingHandler implements GroupStatusListener {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_GROUP);\n+\n+    private @NonNullByDefault({}) String groupId;\n+\n+    private final Logger logger = LoggerFactory.getLogger(HueGroupHandler.class);", "originalCommit": "de011af73f71cad736b3de5b9c68798766688a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c924ec621bc5d7c9cf06864a19c3639db259fdd5", "url": "https://github.com/openhab/openhab-addons/commit/c924ec621bc5d7c9cf06864a19c3639db259fdd5", "message": "[hue] Add support for groups/rooms\n\nFix #7419\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-04-27T19:52:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NjE5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7476#discussion_r418776191", "bodyText": "The error logging level should be reserved for issues catastrophic enough to threaten the operation of openHab itself. An error in a binding shouldn't qualify for this. Please read the openHab coding guidelines for expected use of logging in bindings.\nMy general rule for logging levels is:\n\ntrace - used for normal expected execution paths\ndebug - used for unexepected execution paths, but well within normal operation\ninfo - used for notable points in an execution path, like a milestone. (in openhab we try reserve this logging level for the core, so bindings should rarely ever call this.)\nwarn - used for notable unexpected execution paths that a regular user (not just a developer) should be notified of. Warnings should be used to indicate that something not-normal occurred and user intervention is required to resolve. Warnings do not indicate a failure to operate merely an abnormal condition of operation that can still be handled by the binding. Failures in binding operation should be indicated by changing the thing status to offline.\nerror - used to indicate catastrophic program failure. This should be used to indicate a catastrophic failure in openhab's ability to operate. A failure in a binding would never cause openhab as a whole to fail so a failure in a bindings should never log an error. Instead that failure should be indicated by changing the thing status.", "author": "cpmeister", "createdAt": "2020-05-01T23:19:17Z", "path": "bundles/org.openhab.binding.hue/src/main/java/org/openhab/binding/hue/internal/handler/HueBridgeHandler.java", "diffHunk": "@@ -765,6 +910,36 @@ private void notifySensorStatusListeners(final FullSensor fullSensor, final Stri\n         }\n     }\n \n+    private void notifyGroupStatusListeners(final FullGroup fullGroup, final String type) {\n+        if (groupStatusListeners.isEmpty()) {\n+            logger.debug(\"No group status listeners to notify of group change for group '{}'\", fullGroup.getId());\n+            return;\n+        }\n+\n+        for (GroupStatusListener groupStatusListener : groupStatusListeners) {\n+            try {\n+                switch (type) {\n+                    case STATE_ADDED:\n+                        logger.debug(\"Sending groupAdded for group '{}'\", fullGroup.getId());\n+                        groupStatusListener.onGroupAdded(hueBridge, fullGroup);\n+                        break;\n+                    case STATE_GONE:\n+                        groupStatusListener.onGroupGone(hueBridge, fullGroup);\n+                        break;\n+                    case STATE_CHANGED:\n+                        logger.debug(\"Sending groupStateChanged for group '{}'\", fullGroup.getId());\n+                        groupStatusListener.onGroupStateChanged(hueBridge, fullGroup);\n+                        break;\n+                    default:\n+                        throw new IllegalArgumentException(\n+                                \"Could not notify groupStatusListeners for unknown event type \" + type);\n+                }\n+            } catch (Exception e) {\n+                logger.error(\"An exception occurred while calling the Group Listeners\", e);", "originalCommit": "76c7df3f1fc6e90e4252b8a90a5e7ea6a8ff2840", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzMDI2Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7476#discussion_r418930262", "bodyText": "Ok, updated.", "author": "lolodomo", "createdAt": "2020-05-02T08:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NjE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NzQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7476#discussion_r418777417", "bodyText": "When this binding starts up this will get called for every channel. If you are just updating the channels with cached data it should be fine, but if you are making network requests or the like then you should use an expiring cache.", "author": "cpmeister", "createdAt": "2020-05-01T23:24:50Z", "path": "bundles/org.openhab.binding.hue/src/main/java/org/openhab/binding/hue/internal/handler/HueGroupHandler.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.hue.internal.handler;\n+\n+import static org.openhab.binding.hue.internal.HueBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.IncreaseDecreaseType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.hue.internal.FullGroup;\n+import org.openhab.binding.hue.internal.HueBridge;\n+import org.openhab.binding.hue.internal.State;\n+import org.openhab.binding.hue.internal.State.ColorMode;\n+import org.openhab.binding.hue.internal.StateUpdate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link HueGroupHandler} is the handler for a hue group of lights. It uses the {@link HueClient} to execute the\n+ * actual command.\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HueGroupHandler extends BaseThingHandler implements GroupStatusListener {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES = Collections.singleton(THING_TYPE_GROUP);\n+\n+    private final Logger logger = LoggerFactory.getLogger(HueGroupHandler.class);\n+\n+    private @NonNullByDefault({}) String groupId;\n+\n+    private @Nullable Integer lastSentColorTemp;\n+    private @Nullable Integer lastSentBrightness;\n+\n+    private long defaultFadeTime = 400;\n+\n+    private @Nullable HueClient hueClient;\n+\n+    public HueGroupHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing hue group handler.\");\n+        Bridge bridge = getBridge();\n+        initializeThing((bridge == null) ? null : bridge.getStatus());\n+    }\n+\n+    private void initializeThing(@Nullable ThingStatus bridgeStatus) {\n+        logger.debug(\"initializeThing thing {} bridge status {}\", getThing().getUID(), bridgeStatus);\n+        final String configGroupId = (String) getConfig().get(GROUP_ID);\n+        if (configGroupId != null) {\n+            BigDecimal time = (BigDecimal) getConfig().get(FADETIME);\n+            if (time != null) {\n+                defaultFadeTime = time.longValueExact();\n+            }\n+\n+            groupId = configGroupId;\n+            // note: this call implicitly registers our handler as a listener on the bridge\n+            if (getHueClient() != null) {\n+                if (bridgeStatus == ThingStatus.ONLINE) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE);\n+                }\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"@text/offline.conf-error-no-group-id\");\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Hue group handler disposes. Unregistering listener.\");\n+        if (groupId != null) {\n+            HueClient bridgeHandler = getHueClient();\n+            if (bridgeHandler != null) {\n+                bridgeHandler.unregisterGroupStatusListener(this);\n+                hueClient = null;\n+            }\n+            groupId = null;\n+        }\n+    }\n+\n+    protected synchronized @Nullable HueClient getHueClient() {\n+        if (hueClient == null) {\n+            Bridge bridge = getBridge();\n+            if (bridge == null) {\n+                return null;\n+            }\n+            ThingHandler handler = bridge.getHandler();\n+            if (handler instanceof HueBridgeHandler) {\n+                hueClient = (HueClient) handler;\n+                hueClient.registerGroupStatusListener(this);\n+            } else {\n+                return null;\n+            }\n+        }\n+        return hueClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        handleCommand(channelUID.getId(), command, defaultFadeTime);\n+    }\n+\n+    public void handleCommand(String channel, Command command, long fadeTime) {\n+        HueClient bridgeHandler = getHueClient();\n+        if (bridgeHandler == null) {\n+            logger.warn(\"hue bridge handler not found. Cannot handle command without bridge.\");\n+            return;\n+        }\n+\n+        FullGroup group = bridgeHandler.getGroupById(groupId);\n+        if (group == null) {\n+            logger.debug(\"hue group not known on bridge. Cannot handle command.\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"@text/offline.conf-error-wrong-group-id\");\n+            return;\n+        }\n+\n+        StateUpdate groupState = null;\n+        switch (channel) {\n+            case CHANNEL_COLOR:\n+                if (command instanceof HSBType) {\n+                    HSBType hsbCommand = (HSBType) command;\n+                    if (hsbCommand.getBrightness().intValue() == 0) {\n+                        groupState = LightStateConverter.toOnOffLightState(OnOffType.OFF);\n+                    } else {\n+                        groupState = LightStateConverter.toColorLightState(hsbCommand, group.getState());\n+                        if (groupState != null) {\n+                            groupState.setTransitionTime(fadeTime);\n+                        }\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    groupState = LightStateConverter.toBrightnessLightState((PercentType) command);\n+                    if (groupState != null) {\n+                        groupState.setTransitionTime(fadeTime);\n+                    }\n+                } else if (command instanceof OnOffType) {\n+                    groupState = LightStateConverter.toOnOffLightState((OnOffType) command);\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    groupState = convertBrightnessChangeToStateUpdate((IncreaseDecreaseType) command, group);\n+                    if (groupState != null) {\n+                        groupState.setTransitionTime(fadeTime);\n+                    }\n+                }\n+                break;\n+            case CHANNEL_COLORTEMPERATURE:\n+                if (command instanceof PercentType) {\n+                    groupState = LightStateConverter.toColorTemperatureLightState((PercentType) command);\n+                    if (groupState != null) {\n+                        groupState.setTransitionTime(fadeTime);\n+                    }\n+                } else if (command instanceof OnOffType) {\n+                    groupState = LightStateConverter.toOnOffLightState((OnOffType) command);\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    groupState = convertColorTempChangeToStateUpdate((IncreaseDecreaseType) command, group);\n+                    if (groupState != null) {\n+                        groupState.setTransitionTime(fadeTime);\n+                    }\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+                if (command instanceof PercentType) {\n+                    groupState = LightStateConverter.toBrightnessLightState((PercentType) command);\n+                    if (groupState != null) {\n+                        groupState.setTransitionTime(fadeTime);\n+                    }\n+                } else if (command instanceof OnOffType) {\n+                    groupState = LightStateConverter.toOnOffLightState((OnOffType) command);\n+                } else if (command instanceof IncreaseDecreaseType) {\n+                    groupState = convertBrightnessChangeToStateUpdate((IncreaseDecreaseType) command, group);\n+                    if (groupState != null) {\n+                        groupState.setTransitionTime(fadeTime);\n+                    }\n+                }\n+                if (groupState != null && lastSentColorTemp != null) {\n+                    // make sure that the light also has the latest color temp\n+                    // this might not have been yet set in the light, if it was off\n+                    groupState.setColorTemperature(lastSentColorTemp);\n+                    groupState.setTransitionTime(fadeTime);\n+                }\n+                break;\n+            case CHANNEL_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    groupState = LightStateConverter.toOnOffLightState((OnOffType) command);\n+                }\n+                if (groupState != null && lastSentColorTemp != null) {\n+                    // make sure that the light also has the latest color temp\n+                    // this might not have been yet set in the light, if it was off\n+                    groupState.setColorTemperature(lastSentColorTemp);\n+                    groupState.setTransitionTime(fadeTime);\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+        if (groupState != null) {\n+            // Cache values which we have sent\n+            Integer tmpBrightness = groupState.getBrightness();\n+            if (tmpBrightness != null) {\n+                lastSentBrightness = tmpBrightness;\n+            }\n+            Integer tmpColorTemp = groupState.getColorTemperature();\n+            if (tmpColorTemp != null) {\n+                lastSentColorTemp = tmpColorTemp;\n+            }\n+            bridgeHandler.updateGroupState(group, groupState);\n+        } else {\n+            logger.warn(\"Command sent to an unknown channel id: {}:{}\", getThing().getUID(), channel);\n+        }\n+    }\n+\n+    private @Nullable StateUpdate convertColorTempChangeToStateUpdate(IncreaseDecreaseType command, FullGroup group) {\n+        StateUpdate stateUpdate = null;\n+        Integer currentColorTemp = getCurrentColorTemp(group.getState());\n+        if (currentColorTemp != null) {\n+            int newColorTemp = LightStateConverter.toAdjustedColorTemp(command, currentColorTemp);\n+            stateUpdate = new StateUpdate().setColorTemperature(newColorTemp);\n+        }\n+        return stateUpdate;\n+    }\n+\n+    private @Nullable Integer getCurrentColorTemp(@Nullable State groupState) {\n+        Integer colorTemp = lastSentColorTemp;\n+        if (colorTemp == null && groupState != null) {\n+            colorTemp = groupState.getColorTemperature();\n+        }\n+        return colorTemp;\n+    }\n+\n+    private @Nullable StateUpdate convertBrightnessChangeToStateUpdate(IncreaseDecreaseType command, FullGroup group) {\n+        StateUpdate stateUpdate = null;\n+        Integer currentBrightness = getCurrentBrightness(group.getState());\n+        if (currentBrightness != null) {\n+            int newBrightness = LightStateConverter.toAdjustedBrightness(command, currentBrightness);\n+            stateUpdate = createBrightnessStateUpdate(currentBrightness, newBrightness);\n+        }\n+        return stateUpdate;\n+    }\n+\n+    private @Nullable Integer getCurrentBrightness(@Nullable State groupState) {\n+        Integer brightness = lastSentBrightness;\n+        if (brightness == null && groupState != null) {\n+            if (!groupState.isOn()) {\n+                brightness = 0;\n+            } else {\n+                brightness = groupState.getBrightness();\n+            }\n+        }\n+        return brightness;\n+    }\n+\n+    private StateUpdate createBrightnessStateUpdate(int currentBrightness, int newBrightness) {\n+        StateUpdate lightUpdate = new StateUpdate();\n+        if (newBrightness == 0) {\n+            lightUpdate.turnOff();\n+        } else {\n+            lightUpdate.setBrightness(newBrightness);\n+            if (currentBrightness == 0) {\n+                lightUpdate.turnOn();\n+            }\n+        }\n+        return lightUpdate;\n+    }\n+\n+    @Override\n+    public void channelLinked(ChannelUID channelUID) {\n+        HueClient handler = getHueClient();\n+        if (handler != null) {\n+            FullGroup group = handler.getGroupById(groupId);\n+            if (group != null) {\n+                onGroupStateChanged(null, group);\n+            }\n+        }", "originalCommit": "76c7df3f1fc6e90e4252b8a90a5e7ea6a8ff2840", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkyNzg0OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7476#discussion_r418927849", "bodyText": "It is just using the cache:\n    public @Nullable FullGroup getGroupById(String groupId) {\n        return lastGroupStates.get(groupId);\n    }", "author": "lolodomo", "createdAt": "2020-05-02T07:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NzQxNw=="}], "type": "inlineReview"}, {"oid": "a0027e24fd4507e241f705838c97edff0b0d21d8", "url": "https://github.com/openhab/openhab-addons/commit/a0027e24fd4507e241f705838c97edff0b0d21d8", "message": "[hue] Add support for groups/rooms\n\nFix #7419\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-05-02T16:06:58Z", "type": "commit"}, {"oid": "a0027e24fd4507e241f705838c97edff0b0d21d8", "url": "https://github.com/openhab/openhab-addons/commit/a0027e24fd4507e241f705838c97edff0b0d21d8", "message": "[hue] Add support for groups/rooms\n\nFix #7419\n\nSigned-off-by: Laurent Garnier <lg.hc@free.fr>", "committedDate": "2020-05-02T16:06:58Z", "type": "forcePushed"}]}