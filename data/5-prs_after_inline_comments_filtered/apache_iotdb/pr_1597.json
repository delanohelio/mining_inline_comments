{"pr_number": 1597, "pr_title": "add tsfilemanage-merge", "pr_createdAt": "2020-08-05T02:11:43Z", "pr_url": "https://github.com/apache/iotdb/pull/1597", "timeline": [{"oid": "9e70282319f95fb2f17e07ff507608e267ac345b", "url": "https://github.com/apache/iotdb/commit/9e70282319f95fb2f17e07ff507608e267ac345b", "message": "add tsfilemanage", "committedDate": "2020-08-05T02:08:17Z", "type": "commit"}, {"oid": "ca800d5af849085b45befb5d78b995808c541c9b", "url": "https://github.com/apache/iotdb/commit/ca800d5af849085b45befb5d78b995808c541c9b", "message": "Merge branch 'merge' into recover_TsFileProcessor\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "committedDate": "2020-08-05T02:28:53Z", "type": "commit"}, {"oid": "9636c72d9ec49ad1151a79184ce17f9abf0102cf", "url": "https://github.com/apache/iotdb/commit/9636c72d9ec49ad1151a79184ce17f9abf0102cf", "message": "add license", "committedDate": "2020-08-10T01:53:51Z", "type": "commit"}, {"oid": "bc94968f88b72332e4ddc2255caf2e4b80fe035a", "url": "https://github.com/apache/iotdb/commit/bc94968f88b72332e4ddc2255caf2e4b80fe035a", "message": "add lock", "committedDate": "2020-08-10T04:14:59Z", "type": "commit"}, {"oid": "4946bfb285e7935636a657cfcec07ffc17f2e75a", "url": "https://github.com/apache/iotdb/commit/4946bfb285e7935636a657cfcec07ffc17f2e75a", "message": "fix ci", "committedDate": "2020-08-10T15:51:14Z", "type": "commit"}, {"oid": "aec0f0fc46ce9093f0e6ba6fe368cb442cb96a4e", "url": "https://github.com/apache/iotdb/commit/aec0f0fc46ce9093f0e6ba6fe368cb442cb96a4e", "message": "fix ci", "committedDate": "2020-08-10T16:00:46Z", "type": "commit"}, {"oid": "60aeec68d88613ea881e3e68dc9f5312de168182", "url": "https://github.com/apache/iotdb/commit/60aeec68d88613ea881e3e68dc9f5312de168182", "message": "fix windows ci", "committedDate": "2020-08-11T03:33:04Z", "type": "commit"}, {"oid": "eab828b5b26ce6dfb8c3580a78a779168cbd16bf", "url": "https://github.com/apache/iotdb/commit/eab828b5b26ce6dfb8c3580a78a779168cbd16bf", "message": "fix ci", "committedDate": "2020-08-11T06:32:10Z", "type": "commit"}, {"oid": "894aec0236dc49746e6ddada8ec0b1dd8d549757", "url": "https://github.com/apache/iotdb/commit/894aec0236dc49746e6ddada8ec0b1dd8d549757", "message": "fix ci", "committedDate": "2020-08-11T10:46:44Z", "type": "commit"}, {"oid": "dc9770b47fc2e28edfc868fb334074e27d701e24", "url": "https://github.com/apache/iotdb/commit/dc9770b47fc2e28edfc868fb334074e27d701e24", "message": "remove debug log", "committedDate": "2020-08-11T11:54:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ5MzM4MA==", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468493380", "bodyText": "Change back", "author": "JackieTien97", "createdAt": "2020-08-11T10:53:11Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -588,9 +591,9 @@\n   private int defaultFillInterval = -1;\n \n   /**\n-   * default TTL for storage groups that are not set TTL by statements, in ms\n-   * Notice: if this property is changed, previous created storage group which are not set TTL\n-   * will also be affected.\n+   * default TTL for storage groups that are not set TTL by statements, in ms Notice: if this\n+   * property is changed, previous created storage group which are not set TTL will also be\n+   * affected.", "originalCommit": "894aec0236dc49746e6ddada8ec0b1dd8d549757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ5NzgyOA==", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468497828", "bodyText": "It seems that you forgot to call it in IoTDBDescriptor", "author": "JackieTien97", "createdAt": "2020-08-11T11:01:59Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -1256,20 +1252,30 @@ public void setMergeFileStrategy(\n     this.mergeFileStrategy = mergeFileStrategy;\n   }\n \n-  public boolean isEnableVm() {\n-    return enableVm;\n+\n+  public TsFileManagementStrategy getTsFileManagementStrategy() {\n+    return tsFileManagementStrategy;\n+  }\n+\n+  public void setTsFileManagementStrategy(\n+      TsFileManagementStrategy tsFileManagementStrategy) {\n+    this.tsFileManagementStrategy = tsFileManagementStrategy;\n+  }\n+\n+  public int getMaxFileNumInEachLevel() {\n+    return maxFileNumInEachLevel;\n   }\n \n-  public void setEnableVm(boolean enableVm) {\n-    this.enableVm = enableVm;\n+  public void setMaxFileNumInEachLevel(int maxFileNumInEachLevel) {\n+    this.maxFileNumInEachLevel = maxFileNumInEachLevel;", "originalCommit": "894aec0236dc49746e6ddada8ec0b1dd8d549757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUxMTU0OQ==", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468511549", "bodyText": "You should call closeStorageGroupCondition.notify() somewhere.", "author": "JackieTien97", "createdAt": "2020-08-11T11:30:59Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1182,6 +1179,13 @@ public void syncCloseAllWorkingTsFileProcessors() {\n                 (System.currentTimeMillis() - startTime) / 1000);\n           }\n         }\n+        while (hotCompactionMergeWorking) {\n+          closeStorageGroupCondition.wait(100);", "originalCommit": "894aec0236dc49746e6ddada8ec0b1dd8d549757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUxMjY1NA==", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468512654", "bodyText": "why we need to call logDeletion twice.", "author": "JackieTien97", "createdAt": "2020-08-11T11:33:13Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1376,6 +1384,7 @@ public void delete(String deviceId, String measurementId, long startTime, long e\n \n       // write log to impacted working TsFileProcessors\n       logDeletion(startTime, endTime, deviceId, measurementId);\n+      logDeletion(startTime, endTime, deviceId, measurementId);", "originalCommit": "894aec0236dc49746e6ddada8ec0b1dd8d549757", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyNjk5Mg==", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468526992", "bodyText": "It's better to add some java doc for these abstract methods. It will be useful for someone else to implement another TsFileManagement.", "author": "JackieTien97", "createdAt": "2020-08-11T12:01:07Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/TsFileManagement.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.tsfilemanagement;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import org.apache.iotdb.db.engine.storagegroup.StorageGroupProcessor.CloseHotCompactionMergeCallBack;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+\n+public abstract class TsFileManagement {\n+\n+  protected String storageGroupName;\n+  protected String storageGroupDir;\n+\n+  public TsFileManagement(String storageGroupName, String storageGroupDir) {\n+    this.storageGroupName = storageGroupName;\n+    this.storageGroupDir = storageGroupDir;\n+  }\n+\n+  public abstract List<TsFileResource> getMergeTsFileList(boolean sequence);\n+\n+  public abstract List<TsFileResource> getTsFileList(boolean sequence);\n+\n+  public abstract Iterator<TsFileResource> getIterator(boolean sequence);\n+\n+  public abstract void remove(TsFileResource tsFileResource, boolean sequence);\n+\n+  public abstract void removeAll(List<TsFileResource> tsFileResourceList, boolean sequence);\n+\n+  public abstract void add(TsFileResource tsFileResource, boolean sequence);\n+\n+  public abstract void addAll(List<TsFileResource> tsFileResourceList, boolean sequence);\n+\n+  public abstract void addMerged(TsFileResource tsFileResource, boolean sequence);\n+\n+  public abstract void addMergedAll(List<TsFileResource> tsFileResourceList, boolean sequence);\n+\n+  public abstract boolean contains(TsFileResource tsFileResource, boolean sequence);\n+\n+  public abstract void clear();\n+\n+  public abstract boolean isEmpty(boolean sequence);\n+\n+  public abstract int size(boolean sequence);\n+\n+  public abstract void recover();\n+\n+  public abstract void forkCurrentFileList();\n+\n+  protected abstract void merge(ReadWriteLock hotCompactionMergeLock);", "originalCommit": "dc9770b47fc2e28edfc868fb334074e27d701e24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzMTEzNg==", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468531136", "bodyText": "Why we need to iterate each level to delete vmMergeTsFiles? Cause, according to my understanding, they should be on the same level.", "author": "JackieTien97", "createdAt": "2020-08-11T12:08:37Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.tsfilemanagement.level;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.FILE_NAME_SEPARATOR;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.HOT_COMPACTION_LOG_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.SOURCE_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.TARGET_NAME;\n+import static org.apache.iotdb.tsfile.common.constant.TsFileConstant.TSFILE_SUFFIX;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.cache.ChunkMetadataCache;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.engine.tsfilemanagement.TsFileManagement;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogAnalyzer;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionUtils;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.RestorableTsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LevelTsFileManagement extends TsFileManagement {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LevelTsFileManagement.class);\n+  private int maxLevelNum = IoTDBDescriptor.getInstance().getConfig().getMaxLevelNum();\n+  private final List<List<TsFileResource>> sequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> unSequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> forkedSequenceTsFileResources = new ArrayList<>();\n+  private final List<List<TsFileResource>> forkedUnSequenceTsFileResources = new ArrayList<>();\n+\n+  public LevelTsFileManagement(String storageGroupName, String storageGroupDir) {\n+    super(storageGroupName, storageGroupDir);\n+    clear();\n+  }\n+\n+  private void deleteLevelFiles(List<TsFileResource> vmMergeTsFiles) {\n+    logger.debug(\"{} [hot compaction] merge starts to delete file\", storageGroupName);\n+    for (TsFileResource vmMergeTsFile : vmMergeTsFiles) {\n+      deleteLevelFile(vmMergeTsFile);\n+    }\n+    for (int i = 0; i < maxLevelNum; i++) {\n+      sequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+      unSequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+    }", "originalCommit": "dc9770b47fc2e28edfc868fb334074e27d701e24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzMTkyOA==", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468531928", "bodyText": "It seems that we should use currMergeFiles instead of getTsFileList(sequence).", "author": "JackieTien97", "createdAt": "2020-08-11T12:10:07Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.tsfilemanagement.level;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.FILE_NAME_SEPARATOR;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.HOT_COMPACTION_LOG_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.SOURCE_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.TARGET_NAME;\n+import static org.apache.iotdb.tsfile.common.constant.TsFileConstant.TSFILE_SUFFIX;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.cache.ChunkMetadataCache;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.engine.tsfilemanagement.TsFileManagement;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogAnalyzer;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionUtils;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.RestorableTsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LevelTsFileManagement extends TsFileManagement {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LevelTsFileManagement.class);\n+  private int maxLevelNum = IoTDBDescriptor.getInstance().getConfig().getMaxLevelNum();\n+  private final List<List<TsFileResource>> sequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> unSequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> forkedSequenceTsFileResources = new ArrayList<>();\n+  private final List<List<TsFileResource>> forkedUnSequenceTsFileResources = new ArrayList<>();\n+\n+  public LevelTsFileManagement(String storageGroupName, String storageGroupDir) {\n+    super(storageGroupName, storageGroupDir);\n+    clear();\n+  }\n+\n+  private void deleteLevelFiles(List<TsFileResource> vmMergeTsFiles) {\n+    logger.debug(\"{} [hot compaction] merge starts to delete file\", storageGroupName);\n+    for (TsFileResource vmMergeTsFile : vmMergeTsFiles) {\n+      deleteLevelFile(vmMergeTsFile);\n+    }\n+    for (int i = 0; i < maxLevelNum; i++) {\n+      sequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+      unSequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+    }\n+  }\n+\n+  private static void deleteLevelFile(TsFileResource seqFile) {\n+    seqFile.writeLock();\n+    try {\n+      ChunkMetadataCache.getInstance().remove(seqFile);\n+      FileReaderManager.getInstance().closeFileAndRemoveReader(seqFile.getTsFilePath());\n+      seqFile.setDeleted(true);\n+      if (seqFile.getTsFile().exists()) {\n+        Files.delete(seqFile.getTsFile().toPath());\n+      }\n+    } catch (Exception e) {\n+      logger.error(e.getMessage(), e);\n+    } finally {\n+      seqFile.writeUnlock();\n+    }\n+  }\n+\n+  private void flushAllFilesToLastLevel(List<List<TsFileResource>> currMergeFiles,\n+      HotCompactionLogger hotCompactionLogger, boolean sequence,\n+      ReadWriteLock hotCompactionMergeLock) throws IOException {\n+    TsFileResource sourceFile = currMergeFiles.get(0).get(0);\n+    File newTargetFile = createNewTsFileName(sourceFile.getTsFile(), maxLevelNum - 1);\n+    TsFileResource targetResource = new TsFileResource(newTargetFile);\n+    HotCompactionUtils.merge(targetResource, getTsFileList(sequence),\n+        storageGroupName, hotCompactionLogger, new HashSet<>(), sequence);", "originalCommit": "dc9770b47fc2e28edfc868fb334074e27d701e24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzMzg5Mw==", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468533893", "bodyText": "change the parameter name. it can be either sequenceTsFileResources or unSequenceTsFileResources", "author": "JackieTien97", "createdAt": "2020-08-11T12:13:55Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.tsfilemanagement.level;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.FILE_NAME_SEPARATOR;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.HOT_COMPACTION_LOG_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.SOURCE_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.TARGET_NAME;\n+import static org.apache.iotdb.tsfile.common.constant.TsFileConstant.TSFILE_SUFFIX;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.cache.ChunkMetadataCache;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.engine.tsfilemanagement.TsFileManagement;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogAnalyzer;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionUtils;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.RestorableTsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LevelTsFileManagement extends TsFileManagement {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LevelTsFileManagement.class);\n+  private int maxLevelNum = IoTDBDescriptor.getInstance().getConfig().getMaxLevelNum();\n+  private final List<List<TsFileResource>> sequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> unSequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> forkedSequenceTsFileResources = new ArrayList<>();\n+  private final List<List<TsFileResource>> forkedUnSequenceTsFileResources = new ArrayList<>();\n+\n+  public LevelTsFileManagement(String storageGroupName, String storageGroupDir) {\n+    super(storageGroupName, storageGroupDir);\n+    clear();\n+  }\n+\n+  private void deleteLevelFiles(List<TsFileResource> vmMergeTsFiles) {\n+    logger.debug(\"{} [hot compaction] merge starts to delete file\", storageGroupName);\n+    for (TsFileResource vmMergeTsFile : vmMergeTsFiles) {\n+      deleteLevelFile(vmMergeTsFile);\n+    }\n+    for (int i = 0; i < maxLevelNum; i++) {\n+      sequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+      unSequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+    }\n+  }\n+\n+  private static void deleteLevelFile(TsFileResource seqFile) {\n+    seqFile.writeLock();\n+    try {\n+      ChunkMetadataCache.getInstance().remove(seqFile);\n+      FileReaderManager.getInstance().closeFileAndRemoveReader(seqFile.getTsFilePath());\n+      seqFile.setDeleted(true);\n+      if (seqFile.getTsFile().exists()) {\n+        Files.delete(seqFile.getTsFile().toPath());\n+      }\n+    } catch (Exception e) {\n+      logger.error(e.getMessage(), e);\n+    } finally {\n+      seqFile.writeUnlock();\n+    }\n+  }\n+\n+  private void flushAllFilesToLastLevel(List<List<TsFileResource>> currMergeFiles,\n+      HotCompactionLogger hotCompactionLogger, boolean sequence,\n+      ReadWriteLock hotCompactionMergeLock) throws IOException {\n+    TsFileResource sourceFile = currMergeFiles.get(0).get(0);\n+    File newTargetFile = createNewTsFileName(sourceFile.getTsFile(), maxLevelNum - 1);\n+    TsFileResource targetResource = new TsFileResource(newTargetFile);\n+    HotCompactionUtils.merge(targetResource, getTsFileList(sequence),\n+        storageGroupName, hotCompactionLogger, new HashSet<>(), sequence);\n+    hotCompactionLogger.logFullMerge();\n+    hotCompactionLogger.logSequence(sequence);\n+    hotCompactionLogger.logFile(TARGET_NAME, newTargetFile);\n+    hotCompactionMergeLock.writeLock().lock();\n+    for (int i = 0; i < maxLevelNum - 1; i++) {\n+      deleteLevelFiles(currMergeFiles.get(i));\n+    }\n+    hotCompactionMergeLock.writeLock().unlock();\n+    hotCompactionLogger.logMergeFinish();\n+  }\n+\n+  @Override\n+  public List<TsFileResource> getMergeTsFileList(boolean sequence) {\n+    if (sequence) {\n+      return sequenceTsFileResources.get(maxLevelNum - 1);\n+    } else {\n+      return unSequenceTsFileResources.get(maxLevelNum - 1);\n+    }\n+  }\n+\n+  @Override\n+  public List<TsFileResource> getTsFileList(boolean sequence) {\n+    List<TsFileResource> result = new ArrayList<>();\n+    if (sequence) {\n+      for (int i = sequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result.addAll(sequenceTsFileResources.get(i));\n+      }\n+    } else {\n+      for (int i = unSequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result.addAll(unSequenceTsFileResources.get(i));\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public Iterator<TsFileResource> getIterator(boolean sequence) {\n+    return getTsFileList(sequence).iterator();\n+  }\n+\n+  @Override\n+  public void remove(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        sequenceTsFileResource.remove(tsFileResource);\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        unSequenceTsFileResource.remove(tsFileResource);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void removeAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        sequenceTsFileResource.removeAll(tsFileResourceList);\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        unSequenceTsFileResource.removeAll(tsFileResourceList);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void add(TsFileResource tsFileResource, boolean sequence) {\n+    int level = getMergeLevel(tsFileResource.getTsFile());\n+    if (level <= maxLevelNum - 1) {\n+      if (sequence) {\n+        sequenceTsFileResources.get(level).add(tsFileResource);\n+      } else {\n+        unSequenceTsFileResources.get(level).add(tsFileResource);\n+      }\n+    } else {\n+      if (sequence) {\n+        sequenceTsFileResources.get(maxLevelNum).add(tsFileResource);\n+      } else {\n+        unSequenceTsFileResources.get(maxLevelNum).add(tsFileResource);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void addAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    for (TsFileResource tsFileResource : tsFileResourceList) {\n+      add(tsFileResource, sequence);\n+    }\n+  }\n+\n+  @Override\n+  public void addMerged(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      sequenceTsFileResources.get(maxLevelNum - 1).add(tsFileResource);\n+    } else {\n+      unSequenceTsFileResources.get(maxLevelNum - 1).add(tsFileResource);\n+    }\n+  }\n+\n+  @Override\n+  public void addMergedAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    if (sequence) {\n+      sequenceTsFileResources.get(maxLevelNum - 1).addAll(tsFileResourceList);\n+    } else {\n+      unSequenceTsFileResources.get(maxLevelNum - 1).addAll(tsFileResourceList);\n+    }\n+  }\n+\n+  @Override\n+  public boolean contains(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        if (sequenceTsFileResource.contains(tsFileResource)) {\n+          return true;\n+        }\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        if (unSequenceTsFileResource.contains(tsFileResource)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    sequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum + 1; i++) {\n+      sequenceTsFileResources.add(new CopyOnWriteArrayList<>());\n+    }\n+    unSequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum + 1; i++) {\n+      unSequenceTsFileResources.add(new CopyOnWriteArrayList<>());\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEmpty(boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        if (!sequenceTsFileResource.isEmpty()) {\n+          return false;\n+        }\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        if (!unSequenceTsFileResource.isEmpty()) {\n+          return false;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int size(boolean sequence) {\n+    int result = 0;\n+    if (sequence) {\n+      for (int i = sequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result += sequenceTsFileResources.size();\n+      }\n+    } else {\n+      for (int i = unSequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result += unSequenceTsFileResources.size();\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * recover files\n+   */\n+  @Override\n+  public void recover() {\n+    File logFile = FSFactoryProducer.getFSFactory()\n+        .getFile(storageGroupDir, storageGroupName + HOT_COMPACTION_LOG_NAME);\n+    try {\n+      if (logFile.exists()) {\n+        HotCompactionLogAnalyzer logAnalyzer = new HotCompactionLogAnalyzer(logFile);\n+        logAnalyzer.analyze();\n+        Set<String> deviceSet = logAnalyzer.getDeviceSet();\n+        List<File> sourceFileList = logAnalyzer.getSourceFiles();\n+        long offset = logAnalyzer.getOffset();\n+        File targetFile = logAnalyzer.getTargetFile();\n+        boolean isMergeFinished = logAnalyzer.isMergeFinished();\n+        boolean fullMerge = logAnalyzer.isFullMerge();\n+        boolean isSeq = logAnalyzer.isSeq();\n+        if (targetFile == null) {\n+          return;\n+        }\n+        if (fullMerge) {\n+          if (!isMergeFinished) {\n+            RestorableTsFileIOWriter writer = new RestorableTsFileIOWriter(targetFile);\n+            writer.getIOWriterOut().truncate(offset - 1);\n+            writer.close();\n+            HotCompactionUtils\n+                .merge(new TsFileResource(targetFile), getTsFileList(isSeq), storageGroupName,\n+                    new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet, isSeq);\n+            if (isSeq) {\n+              for (List<TsFileResource> currMergeFile : sequenceTsFileResources) {\n+                deleteLevelFiles(currMergeFile);\n+              }\n+            } else {\n+              for (List<TsFileResource> currMergeFile : unSequenceTsFileResources) {\n+                deleteLevelFiles(currMergeFile);\n+              }\n+            }\n+          }\n+        } else {\n+          TsFileResource targetResource = new TsFileResource(targetFile);\n+          RestorableTsFileIOWriter writer = new RestorableTsFileIOWriter(targetFile);\n+          if (sourceFileList.isEmpty()) {\n+            return;\n+          }\n+          int level = getMergeLevel(sourceFileList.get(0));\n+          if (!isMergeFinished) {\n+            if (deviceSet.isEmpty()) {\n+              Files.delete(targetFile.toPath());\n+            } else {\n+              writer.getIOWriterOut().truncate(offset - 1);\n+              writer.close();\n+              if (isSeq) {\n+                HotCompactionUtils\n+                    .merge(targetResource, sequenceTsFileResources.get(level),\n+                        storageGroupName,\n+                        new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet,\n+                        true);\n+                deleteLevelFiles(sequenceTsFileResources.get(level));\n+                sequenceTsFileResources.get(level + 1).add(targetResource);\n+              } else {\n+                HotCompactionUtils\n+                    .merge(targetResource, unSequenceTsFileResources.get(level),\n+                        storageGroupName,\n+                        new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet,\n+                        false);\n+                deleteLevelFiles(unSequenceTsFileResources.get(level));\n+                unSequenceTsFileResources.get(level + 1).add(targetResource);\n+              }\n+            }\n+          }\n+        }\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"recover vm error \", e);\n+    } finally {\n+      if (logFile.exists()) {\n+        try {\n+          Files.delete(logFile.toPath());\n+        } catch (IOException e) {\n+          logger.error(\"delete vm log file error \", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void forkCurrentFileList() {\n+    forkTsFileList(forkedSequenceTsFileResources, sequenceTsFileResources);\n+    forkTsFileList(forkedUnSequenceTsFileResources, unSequenceTsFileResources);\n+  }\n+\n+  private void forkTsFileList(List<List<TsFileResource>> forkedSequenceTsFileResources,\n+      List<List<TsFileResource>> sequenceTsFileResources) {", "originalCommit": "dc9770b47fc2e28edfc868fb334074e27d701e24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNzAxOQ==", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468537019", "bodyText": "sequenceTsFileResources' size is maxLevelNum + 1, so should the maxLevelNum - 1 be maxLevelNum?", "author": "JackieTien97", "createdAt": "2020-08-11T12:19:39Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/tsfilemanagement/level/LevelTsFileManagement.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.tsfilemanagement.level;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.FILE_NAME_SEPARATOR;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.HOT_COMPACTION_LOG_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.SOURCE_NAME;\n+import static org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger.TARGET_NAME;\n+import static org.apache.iotdb.tsfile.common.constant.TsFileConstant.TSFILE_SUFFIX;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.db.engine.cache.ChunkMetadataCache;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.engine.tsfilemanagement.TsFileManagement;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogAnalyzer;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionLogger;\n+import org.apache.iotdb.db.engine.tsfilemanagement.utils.HotCompactionUtils;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetadata;\n+import org.apache.iotdb.tsfile.fileSystem.FSFactoryProducer;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.iotdb.tsfile.write.writer.RestorableTsFileIOWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class LevelTsFileManagement extends TsFileManagement {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LevelTsFileManagement.class);\n+  private int maxLevelNum = IoTDBDescriptor.getInstance().getConfig().getMaxLevelNum();\n+  private final List<List<TsFileResource>> sequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> unSequenceTsFileResources = new CopyOnWriteArrayList<>();\n+  private final List<List<TsFileResource>> forkedSequenceTsFileResources = new ArrayList<>();\n+  private final List<List<TsFileResource>> forkedUnSequenceTsFileResources = new ArrayList<>();\n+\n+  public LevelTsFileManagement(String storageGroupName, String storageGroupDir) {\n+    super(storageGroupName, storageGroupDir);\n+    clear();\n+  }\n+\n+  private void deleteLevelFiles(List<TsFileResource> vmMergeTsFiles) {\n+    logger.debug(\"{} [hot compaction] merge starts to delete file\", storageGroupName);\n+    for (TsFileResource vmMergeTsFile : vmMergeTsFiles) {\n+      deleteLevelFile(vmMergeTsFile);\n+    }\n+    for (int i = 0; i < maxLevelNum; i++) {\n+      sequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+      unSequenceTsFileResources.get(i).removeAll(vmMergeTsFiles);\n+    }\n+  }\n+\n+  private static void deleteLevelFile(TsFileResource seqFile) {\n+    seqFile.writeLock();\n+    try {\n+      ChunkMetadataCache.getInstance().remove(seqFile);\n+      FileReaderManager.getInstance().closeFileAndRemoveReader(seqFile.getTsFilePath());\n+      seqFile.setDeleted(true);\n+      if (seqFile.getTsFile().exists()) {\n+        Files.delete(seqFile.getTsFile().toPath());\n+      }\n+    } catch (Exception e) {\n+      logger.error(e.getMessage(), e);\n+    } finally {\n+      seqFile.writeUnlock();\n+    }\n+  }\n+\n+  private void flushAllFilesToLastLevel(List<List<TsFileResource>> currMergeFiles,\n+      HotCompactionLogger hotCompactionLogger, boolean sequence,\n+      ReadWriteLock hotCompactionMergeLock) throws IOException {\n+    TsFileResource sourceFile = currMergeFiles.get(0).get(0);\n+    File newTargetFile = createNewTsFileName(sourceFile.getTsFile(), maxLevelNum - 1);\n+    TsFileResource targetResource = new TsFileResource(newTargetFile);\n+    HotCompactionUtils.merge(targetResource, getTsFileList(sequence),\n+        storageGroupName, hotCompactionLogger, new HashSet<>(), sequence);\n+    hotCompactionLogger.logFullMerge();\n+    hotCompactionLogger.logSequence(sequence);\n+    hotCompactionLogger.logFile(TARGET_NAME, newTargetFile);\n+    hotCompactionMergeLock.writeLock().lock();\n+    for (int i = 0; i < maxLevelNum - 1; i++) {\n+      deleteLevelFiles(currMergeFiles.get(i));\n+    }\n+    hotCompactionMergeLock.writeLock().unlock();\n+    hotCompactionLogger.logMergeFinish();\n+  }\n+\n+  @Override\n+  public List<TsFileResource> getMergeTsFileList(boolean sequence) {\n+    if (sequence) {\n+      return sequenceTsFileResources.get(maxLevelNum - 1);\n+    } else {\n+      return unSequenceTsFileResources.get(maxLevelNum - 1);\n+    }\n+  }\n+\n+  @Override\n+  public List<TsFileResource> getTsFileList(boolean sequence) {\n+    List<TsFileResource> result = new ArrayList<>();\n+    if (sequence) {\n+      for (int i = sequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result.addAll(sequenceTsFileResources.get(i));\n+      }\n+    } else {\n+      for (int i = unSequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result.addAll(unSequenceTsFileResources.get(i));\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public Iterator<TsFileResource> getIterator(boolean sequence) {\n+    return getTsFileList(sequence).iterator();\n+  }\n+\n+  @Override\n+  public void remove(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        sequenceTsFileResource.remove(tsFileResource);\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        unSequenceTsFileResource.remove(tsFileResource);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void removeAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        sequenceTsFileResource.removeAll(tsFileResourceList);\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        unSequenceTsFileResource.removeAll(tsFileResourceList);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void add(TsFileResource tsFileResource, boolean sequence) {\n+    int level = getMergeLevel(tsFileResource.getTsFile());\n+    if (level <= maxLevelNum - 1) {\n+      if (sequence) {\n+        sequenceTsFileResources.get(level).add(tsFileResource);\n+      } else {\n+        unSequenceTsFileResources.get(level).add(tsFileResource);\n+      }\n+    } else {\n+      if (sequence) {\n+        sequenceTsFileResources.get(maxLevelNum).add(tsFileResource);\n+      } else {\n+        unSequenceTsFileResources.get(maxLevelNum).add(tsFileResource);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void addAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    for (TsFileResource tsFileResource : tsFileResourceList) {\n+      add(tsFileResource, sequence);\n+    }\n+  }\n+\n+  @Override\n+  public void addMerged(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      sequenceTsFileResources.get(maxLevelNum - 1).add(tsFileResource);\n+    } else {\n+      unSequenceTsFileResources.get(maxLevelNum - 1).add(tsFileResource);\n+    }\n+  }\n+\n+  @Override\n+  public void addMergedAll(List<TsFileResource> tsFileResourceList, boolean sequence) {\n+    if (sequence) {\n+      sequenceTsFileResources.get(maxLevelNum - 1).addAll(tsFileResourceList);\n+    } else {\n+      unSequenceTsFileResources.get(maxLevelNum - 1).addAll(tsFileResourceList);\n+    }\n+  }\n+\n+  @Override\n+  public boolean contains(TsFileResource tsFileResource, boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        if (sequenceTsFileResource.contains(tsFileResource)) {\n+          return true;\n+        }\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        if (unSequenceTsFileResource.contains(tsFileResource)) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    sequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum + 1; i++) {\n+      sequenceTsFileResources.add(new CopyOnWriteArrayList<>());\n+    }\n+    unSequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum + 1; i++) {\n+      unSequenceTsFileResources.add(new CopyOnWriteArrayList<>());\n+    }\n+  }\n+\n+  @Override\n+  public boolean isEmpty(boolean sequence) {\n+    if (sequence) {\n+      for (List<TsFileResource> sequenceTsFileResource : sequenceTsFileResources) {\n+        if (!sequenceTsFileResource.isEmpty()) {\n+          return false;\n+        }\n+      }\n+    } else {\n+      for (List<TsFileResource> unSequenceTsFileResource : unSequenceTsFileResources) {\n+        if (!unSequenceTsFileResource.isEmpty()) {\n+          return false;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public int size(boolean sequence) {\n+    int result = 0;\n+    if (sequence) {\n+      for (int i = sequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result += sequenceTsFileResources.size();\n+      }\n+    } else {\n+      for (int i = unSequenceTsFileResources.size() - 1; i >= 0; i--) {\n+        result += unSequenceTsFileResources.size();\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * recover files\n+   */\n+  @Override\n+  public void recover() {\n+    File logFile = FSFactoryProducer.getFSFactory()\n+        .getFile(storageGroupDir, storageGroupName + HOT_COMPACTION_LOG_NAME);\n+    try {\n+      if (logFile.exists()) {\n+        HotCompactionLogAnalyzer logAnalyzer = new HotCompactionLogAnalyzer(logFile);\n+        logAnalyzer.analyze();\n+        Set<String> deviceSet = logAnalyzer.getDeviceSet();\n+        List<File> sourceFileList = logAnalyzer.getSourceFiles();\n+        long offset = logAnalyzer.getOffset();\n+        File targetFile = logAnalyzer.getTargetFile();\n+        boolean isMergeFinished = logAnalyzer.isMergeFinished();\n+        boolean fullMerge = logAnalyzer.isFullMerge();\n+        boolean isSeq = logAnalyzer.isSeq();\n+        if (targetFile == null) {\n+          return;\n+        }\n+        if (fullMerge) {\n+          if (!isMergeFinished) {\n+            RestorableTsFileIOWriter writer = new RestorableTsFileIOWriter(targetFile);\n+            writer.getIOWriterOut().truncate(offset - 1);\n+            writer.close();\n+            HotCompactionUtils\n+                .merge(new TsFileResource(targetFile), getTsFileList(isSeq), storageGroupName,\n+                    new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet, isSeq);\n+            if (isSeq) {\n+              for (List<TsFileResource> currMergeFile : sequenceTsFileResources) {\n+                deleteLevelFiles(currMergeFile);\n+              }\n+            } else {\n+              for (List<TsFileResource> currMergeFile : unSequenceTsFileResources) {\n+                deleteLevelFiles(currMergeFile);\n+              }\n+            }\n+          }\n+        } else {\n+          TsFileResource targetResource = new TsFileResource(targetFile);\n+          RestorableTsFileIOWriter writer = new RestorableTsFileIOWriter(targetFile);\n+          if (sourceFileList.isEmpty()) {\n+            return;\n+          }\n+          int level = getMergeLevel(sourceFileList.get(0));\n+          if (!isMergeFinished) {\n+            if (deviceSet.isEmpty()) {\n+              Files.delete(targetFile.toPath());\n+            } else {\n+              writer.getIOWriterOut().truncate(offset - 1);\n+              writer.close();\n+              if (isSeq) {\n+                HotCompactionUtils\n+                    .merge(targetResource, sequenceTsFileResources.get(level),\n+                        storageGroupName,\n+                        new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet,\n+                        true);\n+                deleteLevelFiles(sequenceTsFileResources.get(level));\n+                sequenceTsFileResources.get(level + 1).add(targetResource);\n+              } else {\n+                HotCompactionUtils\n+                    .merge(targetResource, unSequenceTsFileResources.get(level),\n+                        storageGroupName,\n+                        new HotCompactionLogger(storageGroupDir, storageGroupName), deviceSet,\n+                        false);\n+                deleteLevelFiles(unSequenceTsFileResources.get(level));\n+                unSequenceTsFileResources.get(level + 1).add(targetResource);\n+              }\n+            }\n+          }\n+        }\n+      }\n+    } catch (IOException e) {\n+      logger.error(\"recover vm error \", e);\n+    } finally {\n+      if (logFile.exists()) {\n+        try {\n+          Files.delete(logFile.toPath());\n+        } catch (IOException e) {\n+          logger.error(\"delete vm log file error \", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void forkCurrentFileList() {\n+    forkTsFileList(forkedSequenceTsFileResources, sequenceTsFileResources);\n+    forkTsFileList(forkedUnSequenceTsFileResources, unSequenceTsFileResources);\n+  }\n+\n+  private void forkTsFileList(List<List<TsFileResource>> forkedSequenceTsFileResources,\n+      List<List<TsFileResource>> sequenceTsFileResources) {\n+    forkedSequenceTsFileResources.clear();\n+    for (int i = 0; i < maxLevelNum - 1; i++) {", "originalCommit": "dc9770b47fc2e28edfc868fb334074e27d701e24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU2MjQzMA==", "url": "https://github.com/apache/iotdb/pull/1597#discussion_r468562430", "bodyText": "no, the maxLevelNum - 1 is the last level of hot compaction, and the maxLevelNum is for the all merge completed level", "author": "zhanglingzhe0820", "createdAt": "2020-08-11T13:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNzAxOQ=="}], "type": "inlineReview"}, {"oid": "9017dac414d8da6daef63726cd2ee2ba65fded78", "url": "https://github.com/apache/iotdb/commit/9017dac414d8da6daef63726cd2ee2ba65fded78", "message": "resolve conversation", "committedDate": "2020-08-11T13:32:20Z", "type": "commit"}, {"oid": "6e46d3a241f1a786ac583e072ffa0e002dbc042b", "url": "https://github.com/apache/iotdb/commit/6e46d3a241f1a786ac583e072ffa0e002dbc042b", "message": "fix ci", "committedDate": "2020-08-12T01:19:54Z", "type": "commit"}, {"oid": "d15a5fbb392e502a17bd02f67b11b28d61cc82af", "url": "https://github.com/apache/iotdb/commit/d15a5fbb392e502a17bd02f67b11b28d61cc82af", "message": "dev ci", "committedDate": "2020-08-12T06:04:58Z", "type": "commit"}, {"oid": "cd174455d42e503265f074fcb9e37b30909dfd1b", "url": "https://github.com/apache/iotdb/commit/cd174455d42e503265f074fcb9e37b30909dfd1b", "message": "Revert \"dev ci\"\n\nThis reverts commit d15a5fbb392e502a17bd02f67b11b28d61cc82af.", "committedDate": "2020-08-12T07:11:14Z", "type": "commit"}, {"oid": "b457e4ff8bb91c3a88bb455c2984b41d0b474475", "url": "https://github.com/apache/iotdb/commit/b457e4ff8bb91c3a88bb455c2984b41d0b474475", "message": "fix ci", "committedDate": "2020-08-12T07:37:08Z", "type": "commit"}, {"oid": "cddaa76ff15498a999947d20c752cd1fc9382f8e", "url": "https://github.com/apache/iotdb/commit/cddaa76ff15498a999947d20c752cd1fc9382f8e", "message": "update pool position", "committedDate": "2020-08-12T08:11:45Z", "type": "commit"}, {"oid": "34712bfee5912e0f69ad4419e4304e94eb3e1f1c", "url": "https://github.com/apache/iotdb/commit/34712bfee5912e0f69ad4419e4304e94eb3e1f1c", "message": "Merge branch 'merge' into recover_TsFileProcessor", "committedDate": "2020-08-12T08:13:37Z", "type": "commit"}, {"oid": "7acc04d193f00c83a99106692ed9f3bd2506ec89", "url": "https://github.com/apache/iotdb/commit/7acc04d193f00c83a99106692ed9f3bd2506ec89", "message": "update level", "committedDate": "2020-08-12T09:41:20Z", "type": "commit"}, {"oid": "76dacae95a29e6ef2219521e59823f08f3ec00be", "url": "https://github.com/apache/iotdb/commit/76dacae95a29e6ef2219521e59823f08f3ec00be", "message": "update lock", "committedDate": "2020-08-12T10:57:42Z", "type": "commit"}, {"oid": "f9f4e1812a0d8d2ed6dc218f39abdc367850f5c3", "url": "https://github.com/apache/iotdb/commit/f9f4e1812a0d8d2ed6dc218f39abdc367850f5c3", "message": "fix", "committedDate": "2020-08-13T01:57:57Z", "type": "commit"}, {"oid": "ba46b3d7b6015aedbdf6cccd85a0c07a8d723b54", "url": "https://github.com/apache/iotdb/commit/ba46b3d7b6015aedbdf6cccd85a0c07a8d723b54", "message": "fix ci", "committedDate": "2020-08-13T02:54:36Z", "type": "commit"}, {"oid": "9486d260ed94b00fdc514f8a128bc4a4189f3fb7", "url": "https://github.com/apache/iotdb/commit/9486d260ed94b00fdc514f8a128bc4a4189f3fb7", "message": "fix ci", "committedDate": "2020-08-13T03:59:14Z", "type": "commit"}, {"oid": "cf4f862f1a4ef6402d2a50c6d75b70120eef7b31", "url": "https://github.com/apache/iotdb/commit/cf4f862f1a4ef6402d2a50c6d75b70120eef7b31", "message": "fix ci", "committedDate": "2020-08-13T06:46:00Z", "type": "commit"}, {"oid": "53ecd4149fe40289c4a1be34796dc670ed73f21b", "url": "https://github.com/apache/iotdb/commit/53ecd4149fe40289c4a1be34796dc670ed73f21b", "message": "fix ci", "committedDate": "2020-08-13T08:17:47Z", "type": "commit"}, {"oid": "861cb39b81290d58a222b2d5987058c333338c7c", "url": "https://github.com/apache/iotdb/commit/861cb39b81290d58a222b2d5987058c333338c7c", "message": "fix ci", "committedDate": "2020-08-13T12:22:19Z", "type": "commit"}, {"oid": "6c4893c5e24eee64b88b38e040a39bcb25806344", "url": "https://github.com/apache/iotdb/commit/6c4893c5e24eee64b88b38e040a39bcb25806344", "message": "fix ci", "committedDate": "2020-08-13T15:00:49Z", "type": "commit"}, {"oid": "1580b584e2ae3dad074bd49fd8071c75e3e2b51b", "url": "https://github.com/apache/iotdb/commit/1580b584e2ae3dad074bd49fd8071c75e3e2b51b", "message": "fix ci", "committedDate": "2020-08-14T05:16:56Z", "type": "commit"}, {"oid": "a53c4d6808ebaef24280849ac2390cdd89d831c7", "url": "https://github.com/apache/iotdb/commit/a53c4d6808ebaef24280849ac2390cdd89d831c7", "message": "try fix", "committedDate": "2020-08-14T06:43:18Z", "type": "commit"}]}