{"pr_number": 2353, "pr_title": "[IOTDB-1083] There is no need to get write lock each time when we try\u2026", "pr_createdAt": "2020-12-28T02:20:58Z", "pr_url": "https://github.com/apache/iotdb/pull/2353", "timeline": [{"oid": "495cb3625cec1f4f0722f25171b761b383e664cb", "url": "https://github.com/apache/iotdb/commit/495cb3625cec1f4f0722f25171b761b383e664cb", "message": "[IOTDB-1083] There is no need to get write lock each time when we try to get or create time series file processor", "committedDate": "2020-12-28T02:19:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk2NTA2NA==", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r549965064", "bodyText": "Should consider carefully whether workSequenceTsFileProcessors (The tsFileProcessorTreeMap in this method) is thread safety.", "author": "jixuan1989", "createdAt": "2020-12-30T07:00:44Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -969,35 +969,35 @@ private TsFileProcessor getOrCreateTsFileProcessorIntern(long timeRangeId,\n       boolean sequence)\n       throws IOException, DiskSpaceInsufficientException {\n \n-    TsFileProcessor res;\n-    // we have to ensure only one thread can change workSequenceTsFileProcessors\n-    writeLock();\n-    try {\n-      res = tsFileProcessorTreeMap.get(timeRangeId);\n-      if (res == null) {\n-        // we have to remove oldest processor to control the num of the memtables\n-        // TODO: use a method to control the number of memtables\n-        if (tsFileProcessorTreeMap.size()\n-            >= IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition()) {\n-          Map.Entry<Long, TsFileProcessor> processorEntry = tsFileProcessorTreeMap.firstEntry();\n-          logger.info(\n-              \"will close a {} TsFile because too many active partitions ({} > {}) in the storage group {},\",\n-              sequence, tsFileProcessorTreeMap.size(),\n-              IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition(),\n-              storageGroupName);\n-          asyncCloseOneTsFileProcessor(sequence, processorEntry.getValue());\n-        }\n+    TsFileProcessor res = tsFileProcessorTreeMap.get(timeRangeId);", "originalCommit": "495cb3625cec1f4f0722f25171b761b383e664cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk3NTg5MA==", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r549975890", "bodyText": "Method getOrCreateTsFileProcessorIntern is called by getOrCreateTsFileProcessor which ready guard by lock in StorageGroupProcessor,  this method in fact is trying to get the same lock again", "author": "yuqi1129", "createdAt": "2020-12-30T07:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk2NTA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk3ODQ0OA==", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r549978448", "bodyText": "newTsFileProcess() is better.\nAnd,  I think the following should also be in the method.\n    tsFileProcessor.addCloseFileListeners(customCloseFileListeners);\n    tsFileProcessor.addFlushListeners(customFlushListeners);\n\n    tsFileProcessor.setTimeRangeId(timePartitionId);", "author": "jixuan1989", "createdAt": "2020-12-30T07:19:33Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1006,50 +1006,49 @@ private TsFileProcessor getOrCreateTsFileProcessorIntern(long timeRangeId,\n \n   private TsFileProcessor createTsFileProcessor(boolean sequence, long timePartitionId)\n       throws IOException, DiskSpaceInsufficientException {\n-    String baseDir;\n-    if (sequence) {\n-      baseDir = DirectoryManager.getInstance().getNextFolderForSequenceFile();\n-    } else {\n-      baseDir = DirectoryManager.getInstance().getNextFolderForUnSequenceFile();\n-    }\n+    DirectoryManager directoryManager = DirectoryManager.getInstance();\n+    String baseDir = sequence ? directoryManager.getNextFolderForSequenceFile()\n+        : directoryManager.getNextFolderForUnSequenceFile();\n+\n     fsFactory.getFile(baseDir, storageGroupName).mkdirs();\n \n     String filePath =\n         baseDir + File.separator + storageGroupName + File.separator + timePartitionId\n             + File.separator\n             + getNewTsFileName(timePartitionId);\n \n-    TsFileProcessor tsFileProcessor;\n     VersionController versionController = getVersionControllerByTimePartitionId(timePartitionId);\n+    TsFileProcessor tsFileProcessor = getTsFileProcessor(sequence, filePath, versionController);\n+    tsFileProcessor.addCloseFileListeners(customCloseFileListeners);\n+    tsFileProcessor.addFlushListeners(customFlushListeners);\n+\n+    tsFileProcessor.setTimeRangeId(timePartitionId);\n+    return tsFileProcessor;\n+  }\n+\n+  private TsFileProcessor getTsFileProcessor(boolean sequence, String filePath,", "originalCommit": "495cb3625cec1f4f0722f25171b761b383e664cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk4MjA4MQ==", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r549982081", "bodyText": "Good idea, i will follow your suggestion", "author": "yuqi1129", "createdAt": "2020-12-30T07:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk3ODQ0OA=="}], "type": "inlineReview"}, {"oid": "9eb1fc66fe4c23ddcf916bdec9decfb1df5cc959", "url": "https://github.com/apache/iotdb/commit/9eb1fc66fe4c23ddcf916bdec9decfb1df5cc959", "message": "[IOTDB-1083] There is no need to get write lock each time when we try to get or create time series file processor, fix discussion 1", "committedDate": "2020-12-30T09:08:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjMwNzQ4OQ==", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r562307489", "bodyText": "As you say, outer code has lock this write lock. How come you lock it twice?  May be this lock op can also be removed.", "author": "SilverNarcissus", "createdAt": "2021-01-22T01:21:37Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -969,87 +969,86 @@ private TsFileProcessor getOrCreateTsFileProcessorIntern(long timeRangeId,\n       boolean sequence)\n       throws IOException, DiskSpaceInsufficientException {\n \n-    TsFileProcessor res;\n-    // we have to ensure only one thread can change workSequenceTsFileProcessors\n-    writeLock();\n-    try {\n-      res = tsFileProcessorTreeMap.get(timeRangeId);\n-      if (res == null) {\n-        // we have to remove oldest processor to control the num of the memtables\n-        // TODO: use a method to control the number of memtables\n-        if (tsFileProcessorTreeMap.size()\n-            >= IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition()) {\n-          Map.Entry<Long, TsFileProcessor> processorEntry = tsFileProcessorTreeMap.firstEntry();\n-          logger.info(\n-              \"will close a {} TsFile because too many active partitions ({} > {}) in the storage group {},\",\n-              sequence, tsFileProcessorTreeMap.size(),\n-              IoTDBDescriptor.getInstance().getConfig().getConcurrentWritingTimePartition(),\n-              storageGroupName);\n-          asyncCloseOneTsFileProcessor(sequence, processorEntry.getValue());\n-        }\n+    TsFileProcessor res = tsFileProcessorTreeMap.get(timeRangeId);\n \n-        // build new processor\n-        TsFileProcessor newProcessor = createTsFileProcessor(sequence, timeRangeId);\n-        tsFileProcessorTreeMap.put(timeRangeId, newProcessor);\n-        tsFileManagement.add(newProcessor.getTsFileResource(), sequence);\n-        res = newProcessor;\n-      }\n+    //Use double-check to shorten the lock range\n+    if (null == res) {\n+      writeLock();", "originalCommit": "9eb1fc66fe4c23ddcf916bdec9decfb1df5cc959", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjMxNjg0NA==", "url": "https://github.com/apache/iotdb/pull/2353#discussion_r562316844", "bodyText": "Yes, further optimization about the lock can be made, i will remove related duplication code later, thanks", "author": "yuqi1129", "createdAt": "2021-01-22T01:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjMwNzQ4OQ=="}], "type": "inlineReview"}, {"oid": "ad599115f8e19e485504f096aa8c37824e2d41ae", "url": "https://github.com/apache/iotdb/commit/ad599115f8e19e485504f096aa8c37824e2d41ae", "message": "Merge master and remove redundant lock", "committedDate": "2021-01-28T12:24:13Z", "type": "commit"}, {"oid": "42be462570c7f849c98db2d1657471747f467f71", "url": "https://github.com/apache/iotdb/commit/42be462570c7f849c98db2d1657471747f467f71", "message": "minor change", "committedDate": "2021-01-28T12:26:19Z", "type": "commit"}, {"oid": "60262c87a755028efdb2fa28909548c3830b33d5", "url": "https://github.com/apache/iotdb/commit/60262c87a755028efdb2fa28909548c3830b33d5", "message": "minor change again", "committedDate": "2021-01-28T12:29:56Z", "type": "commit"}]}