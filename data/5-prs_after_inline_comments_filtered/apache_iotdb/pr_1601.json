{"pr_number": 1601, "pr_title": "add a data migration example", "pr_createdAt": "2020-08-06T04:44:19Z", "pr_url": "https://github.com/apache/iotdb/pull/1601", "timeline": [{"oid": "8c56016b2df7e5c69480dcd835677e5ab4cb75f8", "url": "https://github.com/apache/iotdb/commit/8c56016b2df7e5c69480dcd835677e5ab4cb75f8", "message": "add a data migration example", "committedDate": "2020-08-06T04:42:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg3OTY2MA==", "url": "https://github.com/apache/iotdb/pull/1601#discussion_r467879660", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  count ++;\n          \n          \n            \n                  count++;", "author": "Alima777", "createdAt": "2020-08-10T12:49:28Z", "path": "example/session/src/main/java/org/apache/iotdb/DataMigrationExample.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import org.apache.iotdb.rpc.IoTDBConnectionException;\n+import org.apache.iotdb.rpc.StatementExecutionException;\n+import org.apache.iotdb.session.SessionDataSet.DataIterator;\n+import org.apache.iotdb.session.pool.SessionDataSetWrapper;\n+import org.apache.iotdb.session.pool.SessionPool;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.write.record.Tablet;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+\n+/**\n+ * Migrate all data belongs to a path from one IoTDB to another IoTDB\n+ * Each thread migrate one series, the concurrent thread can be configured by concurrency\n+ *\n+ * This example is\n+ * migrating all timeseries from a local IoTDB with 6667 port to a local IoTDB with 6668 port\n+ */\n+public class DataMigrationExample {\n+\n+  // used to read data from the source IoTDB\n+  private static SessionPool readerPool;\n+  // used to write data into the destination IoTDB\n+  private static SessionPool writerPool;\n+  // concurrent thread of loading timeseries data\n+  private static int concurrency = 5;\n+\n+  public static void main(String[] args)\n+      throws IoTDBConnectionException, StatementExecutionException, ExecutionException, InterruptedException {\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(2 * concurrency + 1);\n+\n+    String path = \"root\";\n+\n+    if (args.length != 0) {\n+      path = args[0];\n+    }\n+\n+    readerPool = new SessionPool(\"127.0.0.1\", 6667, \"root\", \"root\", concurrency);\n+    writerPool = new SessionPool(\"127.0.0.1\", 6668, \"root\", \"root\", concurrency);\n+\n+    SessionDataSetWrapper schemaDataSet = readerPool.executeQueryStatement(\"count timeseries \" + path);\n+    DataIterator schemaIter = schemaDataSet.iterator();\n+    int total;\n+    if (schemaIter.next()) {\n+      total = schemaIter.getInt(1);\n+      System.out.println(\"Total timeseries: \" + total);\n+    } else {\n+      System.out.println(\"Can not get timeseries schema\");\n+      System.exit(1);\n+    }\n+    readerPool.closeResultSet(schemaDataSet);\n+\n+\n+    schemaDataSet = readerPool\n+        .executeQueryStatement(\"show timeseries \" + path);\n+    schemaIter = schemaDataSet.iterator();\n+\n+    List<Future> futureList = new ArrayList<>();\n+    int count = 0;\n+    while (schemaIter.next()) {\n+      count ++;", "originalCommit": "8c56016b2df7e5c69480dcd835677e5ab4cb75f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg3OTg1OQ==", "url": "https://github.com/apache/iotdb/pull/1601#discussion_r467879859", "bodyText": "Pay attention to the code style.", "author": "Alima777", "createdAt": "2020-08-10T12:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg3OTY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk2MzY0Mw==", "url": "https://github.com/apache/iotdb/pull/1601#discussion_r467963643", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-08-10T14:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg3OTY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg3OTk4Nw==", "url": "https://github.com/apache/iotdb/pull/1601#discussion_r467879987", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (Future future: futureList) {\n          \n          \n            \n                for (Future future : futureList) {", "author": "Alima777", "createdAt": "2020-08-10T12:50:02Z", "path": "example/session/src/main/java/org/apache/iotdb/DataMigrationExample.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import org.apache.iotdb.rpc.IoTDBConnectionException;\n+import org.apache.iotdb.rpc.StatementExecutionException;\n+import org.apache.iotdb.session.SessionDataSet.DataIterator;\n+import org.apache.iotdb.session.pool.SessionDataSetWrapper;\n+import org.apache.iotdb.session.pool.SessionPool;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.write.record.Tablet;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+\n+/**\n+ * Migrate all data belongs to a path from one IoTDB to another IoTDB\n+ * Each thread migrate one series, the concurrent thread can be configured by concurrency\n+ *\n+ * This example is\n+ * migrating all timeseries from a local IoTDB with 6667 port to a local IoTDB with 6668 port\n+ */\n+public class DataMigrationExample {\n+\n+  // used to read data from the source IoTDB\n+  private static SessionPool readerPool;\n+  // used to write data into the destination IoTDB\n+  private static SessionPool writerPool;\n+  // concurrent thread of loading timeseries data\n+  private static int concurrency = 5;\n+\n+  public static void main(String[] args)\n+      throws IoTDBConnectionException, StatementExecutionException, ExecutionException, InterruptedException {\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(2 * concurrency + 1);\n+\n+    String path = \"root\";\n+\n+    if (args.length != 0) {\n+      path = args[0];\n+    }\n+\n+    readerPool = new SessionPool(\"127.0.0.1\", 6667, \"root\", \"root\", concurrency);\n+    writerPool = new SessionPool(\"127.0.0.1\", 6668, \"root\", \"root\", concurrency);\n+\n+    SessionDataSetWrapper schemaDataSet = readerPool.executeQueryStatement(\"count timeseries \" + path);\n+    DataIterator schemaIter = schemaDataSet.iterator();\n+    int total;\n+    if (schemaIter.next()) {\n+      total = schemaIter.getInt(1);\n+      System.out.println(\"Total timeseries: \" + total);\n+    } else {\n+      System.out.println(\"Can not get timeseries schema\");\n+      System.exit(1);\n+    }\n+    readerPool.closeResultSet(schemaDataSet);\n+\n+\n+    schemaDataSet = readerPool\n+        .executeQueryStatement(\"show timeseries \" + path);\n+    schemaIter = schemaDataSet.iterator();\n+\n+    List<Future> futureList = new ArrayList<>();\n+    int count = 0;\n+    while (schemaIter.next()) {\n+      count ++;\n+      Path currentPath = new Path(schemaIter.getString(\"timeseries\"));\n+      Future future = executorService.submit(new LoadThread(count, currentPath, TSDataType.valueOf(schemaIter.getString(\"dataType\"))));\n+      futureList.add(future);\n+    }\n+    readerPool.closeResultSet(schemaDataSet);\n+\n+    for (Future future: futureList) {", "originalCommit": "8c56016b2df7e5c69480dcd835677e5ab4cb75f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk2MzU4Mg==", "url": "https://github.com/apache/iotdb/pull/1601#discussion_r467963582", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-08-10T14:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg3OTk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4MDE1Nw==", "url": "https://github.com/apache/iotdb/pull/1601#discussion_r467880157", "bodyText": "writerPool.close()\uff1f", "author": "Alima777", "createdAt": "2020-08-10T12:50:24Z", "path": "example/session/src/main/java/org/apache/iotdb/DataMigrationExample.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import org.apache.iotdb.rpc.IoTDBConnectionException;\n+import org.apache.iotdb.rpc.StatementExecutionException;\n+import org.apache.iotdb.session.SessionDataSet.DataIterator;\n+import org.apache.iotdb.session.pool.SessionDataSetWrapper;\n+import org.apache.iotdb.session.pool.SessionPool;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.write.record.Tablet;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+\n+/**\n+ * Migrate all data belongs to a path from one IoTDB to another IoTDB\n+ * Each thread migrate one series, the concurrent thread can be configured by concurrency\n+ *\n+ * This example is\n+ * migrating all timeseries from a local IoTDB with 6667 port to a local IoTDB with 6668 port\n+ */\n+public class DataMigrationExample {\n+\n+  // used to read data from the source IoTDB\n+  private static SessionPool readerPool;\n+  // used to write data into the destination IoTDB\n+  private static SessionPool writerPool;\n+  // concurrent thread of loading timeseries data\n+  private static int concurrency = 5;\n+\n+  public static void main(String[] args)\n+      throws IoTDBConnectionException, StatementExecutionException, ExecutionException, InterruptedException {\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(2 * concurrency + 1);\n+\n+    String path = \"root\";\n+\n+    if (args.length != 0) {\n+      path = args[0];\n+    }\n+\n+    readerPool = new SessionPool(\"127.0.0.1\", 6667, \"root\", \"root\", concurrency);\n+    writerPool = new SessionPool(\"127.0.0.1\", 6668, \"root\", \"root\", concurrency);\n+\n+    SessionDataSetWrapper schemaDataSet = readerPool.executeQueryStatement(\"count timeseries \" + path);\n+    DataIterator schemaIter = schemaDataSet.iterator();\n+    int total;\n+    if (schemaIter.next()) {\n+      total = schemaIter.getInt(1);\n+      System.out.println(\"Total timeseries: \" + total);\n+    } else {\n+      System.out.println(\"Can not get timeseries schema\");\n+      System.exit(1);\n+    }\n+    readerPool.closeResultSet(schemaDataSet);\n+\n+\n+    schemaDataSet = readerPool\n+        .executeQueryStatement(\"show timeseries \" + path);\n+    schemaIter = schemaDataSet.iterator();\n+\n+    List<Future> futureList = new ArrayList<>();\n+    int count = 0;\n+    while (schemaIter.next()) {\n+      count ++;\n+      Path currentPath = new Path(schemaIter.getString(\"timeseries\"));\n+      Future future = executorService.submit(new LoadThread(count, currentPath, TSDataType.valueOf(schemaIter.getString(\"dataType\"))));\n+      futureList.add(future);\n+    }\n+    readerPool.closeResultSet(schemaDataSet);\n+\n+    for (Future future: futureList) {\n+      future.get();\n+    }\n+    executorService.shutdown();\n+\n+    readerPool.close();\n+    readerPool.close();", "originalCommit": "8c56016b2df7e5c69480dcd835677e5ab4cb75f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk2Mzc2OA==", "url": "https://github.com/apache/iotdb/pull/1601#discussion_r467963768", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-08-10T14:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4MDE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4Mzg2NA==", "url": "https://github.com/apache/iotdb/pull/1601#discussion_r467883864", "bodyText": "Are you aimed at blocking the main thread until the end of writing thread using Callable and Future interface? If so, I think using Runnable and executorService.awaitTermination() instead of Future is better.", "author": "Alima777", "createdAt": "2020-08-10T12:57:14Z", "path": "example/session/src/main/java/org/apache/iotdb/DataMigrationExample.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import org.apache.iotdb.rpc.IoTDBConnectionException;\n+import org.apache.iotdb.rpc.StatementExecutionException;\n+import org.apache.iotdb.session.SessionDataSet.DataIterator;\n+import org.apache.iotdb.session.pool.SessionDataSetWrapper;\n+import org.apache.iotdb.session.pool.SessionPool;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.write.record.Tablet;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+\n+/**\n+ * Migrate all data belongs to a path from one IoTDB to another IoTDB\n+ * Each thread migrate one series, the concurrent thread can be configured by concurrency\n+ *\n+ * This example is\n+ * migrating all timeseries from a local IoTDB with 6667 port to a local IoTDB with 6668 port\n+ */\n+public class DataMigrationExample {\n+\n+  // used to read data from the source IoTDB\n+  private static SessionPool readerPool;\n+  // used to write data into the destination IoTDB\n+  private static SessionPool writerPool;\n+  // concurrent thread of loading timeseries data\n+  private static int concurrency = 5;\n+\n+  public static void main(String[] args)\n+      throws IoTDBConnectionException, StatementExecutionException, ExecutionException, InterruptedException {\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(2 * concurrency + 1);\n+\n+    String path = \"root\";\n+\n+    if (args.length != 0) {\n+      path = args[0];\n+    }\n+\n+    readerPool = new SessionPool(\"127.0.0.1\", 6667, \"root\", \"root\", concurrency);\n+    writerPool = new SessionPool(\"127.0.0.1\", 6668, \"root\", \"root\", concurrency);\n+\n+    SessionDataSetWrapper schemaDataSet = readerPool.executeQueryStatement(\"count timeseries \" + path);\n+    DataIterator schemaIter = schemaDataSet.iterator();\n+    int total;\n+    if (schemaIter.next()) {\n+      total = schemaIter.getInt(1);\n+      System.out.println(\"Total timeseries: \" + total);\n+    } else {\n+      System.out.println(\"Can not get timeseries schema\");\n+      System.exit(1);\n+    }\n+    readerPool.closeResultSet(schemaDataSet);\n+\n+\n+    schemaDataSet = readerPool\n+        .executeQueryStatement(\"show timeseries \" + path);\n+    schemaIter = schemaDataSet.iterator();\n+\n+    List<Future> futureList = new ArrayList<>();\n+    int count = 0;\n+    while (schemaIter.next()) {\n+      count ++;\n+      Path currentPath = new Path(schemaIter.getString(\"timeseries\"));\n+      Future future = executorService.submit(new LoadThread(count, currentPath, TSDataType.valueOf(schemaIter.getString(\"dataType\"))));", "originalCommit": "8c56016b2df7e5c69480dcd835677e5ab4cb75f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk3MzY3OQ==", "url": "https://github.com/apache/iotdb/pull/1601#discussion_r467973679", "bodyText": "Yes, it's my purpose.\nawaitTermination() needs a timeout interval, which is hard to determine. We could return something using callable in the future, such as recording a log.", "author": "qiaojialin", "createdAt": "2020-08-10T15:11:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4Mzg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4MjgyNw==", "url": "https://github.com/apache/iotdb/pull/1601#discussion_r467982827", "bodyText": "I agree with the point that if something can be reused as return value, callable will be better and it has to be.\nThen as an EXAMPLE, just keep this and add some comment here to show users more choices may be better. Anyway, maybe users can decide the timeout.", "author": "Alima777", "createdAt": "2020-08-10T15:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4Mzg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4NDE2NA==", "url": "https://github.com/apache/iotdb/pull/1601#discussion_r467884164", "bodyText": "Same as before.", "author": "Alima777", "createdAt": "2020-08-10T12:57:47Z", "path": "example/session/src/main/java/org/apache/iotdb/DataMigrationExample.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import org.apache.iotdb.rpc.IoTDBConnectionException;\n+import org.apache.iotdb.rpc.StatementExecutionException;\n+import org.apache.iotdb.session.SessionDataSet.DataIterator;\n+import org.apache.iotdb.session.pool.SessionDataSetWrapper;\n+import org.apache.iotdb.session.pool.SessionPool;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.write.record.Tablet;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+\n+\n+/**\n+ * Migrate all data belongs to a path from one IoTDB to another IoTDB\n+ * Each thread migrate one series, the concurrent thread can be configured by concurrency\n+ *\n+ * This example is\n+ * migrating all timeseries from a local IoTDB with 6667 port to a local IoTDB with 6668 port\n+ */\n+public class DataMigrationExample {\n+\n+  // used to read data from the source IoTDB\n+  private static SessionPool readerPool;\n+  // used to write data into the destination IoTDB\n+  private static SessionPool writerPool;\n+  // concurrent thread of loading timeseries data\n+  private static int concurrency = 5;\n+\n+  public static void main(String[] args)\n+      throws IoTDBConnectionException, StatementExecutionException, ExecutionException, InterruptedException {\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(2 * concurrency + 1);\n+\n+    String path = \"root\";\n+\n+    if (args.length != 0) {\n+      path = args[0];\n+    }\n+\n+    readerPool = new SessionPool(\"127.0.0.1\", 6667, \"root\", \"root\", concurrency);\n+    writerPool = new SessionPool(\"127.0.0.1\", 6668, \"root\", \"root\", concurrency);\n+\n+    SessionDataSetWrapper schemaDataSet = readerPool.executeQueryStatement(\"count timeseries \" + path);\n+    DataIterator schemaIter = schemaDataSet.iterator();\n+    int total;\n+    if (schemaIter.next()) {\n+      total = schemaIter.getInt(1);\n+      System.out.println(\"Total timeseries: \" + total);\n+    } else {\n+      System.out.println(\"Can not get timeseries schema\");\n+      System.exit(1);\n+    }\n+    readerPool.closeResultSet(schemaDataSet);\n+\n+\n+    schemaDataSet = readerPool\n+        .executeQueryStatement(\"show timeseries \" + path);\n+    schemaIter = schemaDataSet.iterator();\n+\n+    List<Future> futureList = new ArrayList<>();\n+    int count = 0;\n+    while (schemaIter.next()) {\n+      count ++;\n+      Path currentPath = new Path(schemaIter.getString(\"timeseries\"));\n+      Future future = executorService.submit(new LoadThread(count, currentPath, TSDataType.valueOf(schemaIter.getString(\"dataType\"))));\n+      futureList.add(future);\n+    }\n+    readerPool.closeResultSet(schemaDataSet);\n+\n+    for (Future future: futureList) {\n+      future.get();\n+    }\n+    executorService.shutdown();\n+\n+    readerPool.close();\n+    readerPool.close();\n+  }\n+\n+\n+  static class LoadThread implements Callable<Void> {", "originalCommit": "8c56016b2df7e5c69480dcd835677e5ab4cb75f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "313626dfe1761d2fe4e382b43e598fba7202d277", "url": "https://github.com/apache/iotdb/commit/313626dfe1761d2fe4e382b43e598fba7202d277", "message": "format code", "committedDate": "2020-08-10T15:12:41Z", "type": "commit"}]}