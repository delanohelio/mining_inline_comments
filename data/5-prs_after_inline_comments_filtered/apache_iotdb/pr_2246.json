{"pr_number": 2246, "pr_title": "Add Unit tests for Utils module", "pr_createdAt": "2020-12-10T12:51:37Z", "pr_url": "https://github.com/apache/iotdb/pull/2246", "timeline": [{"oid": "234179bc5cea5460663fd51e683b23669d9faafc", "url": "https://github.com/apache/iotdb/commit/234179bc5cea5460663fd51e683b23669d9faafc", "message": "Add UT for Utils module", "committedDate": "2020-12-10T12:50:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkwNTgxMQ==", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540905811", "bodyText": "What about seperating this single test to two? I think it's better to keep the test atomic.", "author": "Alima777", "createdAt": "2020-12-11T12:15:26Z", "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }", "originalCommit": "234179bc5cea5460663fd51e683b23669d9faafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkwOTQ1NQ==", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540909455", "bodyText": "TsRecordSizeTest -> TsRecordMemTest. And add javadoc for this test, it tests getDataPointMem() and getTsRecordMem().", "author": "Alima777", "createdAt": "2020-12-11T12:22:19Z", "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }\n+\n+  @Test\n+  public void TsRecordSizeTest() {", "originalCommit": "234179bc5cea5460663fd51e683b23669d9faafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkwOTU2Mg==", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540909562", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                totalSize += 8 * record.dataPointList.size() + MemUtils.getStringMem(device)+ 16;\n          \n          \n            \n                totalSize += 8 * record.dataPointList.size() + MemUtils.getStringMem(device) + 16;", "author": "Alima777", "createdAt": "2020-12-11T12:22:35Z", "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }\n+\n+  @Test\n+  public void TsRecordSizeTest() {\n+    int totalSize = 0;\n+    String device = \"root.sg.d1\";\n+    TSRecord record = new TSRecord(0, device);\n+\n+    DataPoint point1 = new IntDataPoint(\"s1\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s1\") + 20, MemUtils.getDataPointMem(point1));\n+    totalSize += MemUtils.getDataPointMem(point1);\n+    record.addTuple(point1);\n+\n+    DataPoint point2 = new LongDataPoint(\"s2\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s2\") + 24, MemUtils.getDataPointMem(point2));\n+    totalSize += MemUtils.getDataPointMem(point2);\n+    record.addTuple(point2);\n+\n+    DataPoint point3 = new FloatDataPoint(\"s3\", 1.0f);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s3\") + 20, MemUtils.getDataPointMem(point3));\n+    totalSize += MemUtils.getDataPointMem(point3);\n+    record.addTuple(point3);\n+\n+    DataPoint point4 = new DoubleDataPoint(\"s4\", 1.0d);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s4\") + 24, MemUtils.getDataPointMem(point4));\n+    totalSize += MemUtils.getDataPointMem(point4);\n+    record.addTuple(point4);\n+\n+    DataPoint point5 = new BooleanDataPoint(\"s5\", true);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s5\") + 17, MemUtils.getDataPointMem(point5));\n+    totalSize += MemUtils.getDataPointMem(point5);\n+    record.addTuple(point5);\n+\n+    totalSize += 8 * record.dataPointList.size() + MemUtils.getStringMem(device)+ 16;", "originalCommit": "234179bc5cea5460663fd51e683b23669d9faafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxMDEyNQ==", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540910125", "bodyText": "Why not check StringDataPoint?", "author": "Alima777", "createdAt": "2020-12-11T12:23:40Z", "path": "server/src/test/java/org/apache/iotdb/db/utils/MemUtilsTest.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.physical.crud.InsertTabletPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.write.record.TSRecord;\n+import org.apache.iotdb.tsfile.write.record.datapoint.*;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MemUtilsTest {\n+\n+  @Test\n+  public void recordSizeTest() throws IllegalPathException {\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.INT32, 10, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.INT64, 10, true));\n+    Assert.assertEquals(12, MemUtils.getRecordSize(TSDataType.FLOAT, 10.0, true));\n+    Assert.assertEquals(16, MemUtils.getRecordSize(TSDataType.DOUBLE, 10.0, true));\n+    Assert.assertEquals(8, MemUtils.getRecordSize(TSDataType.TEXT, \"10\", false));\n+\n+    PartialPath device = new PartialPath(\"root.sg.d1\");\n+    String[] measurements = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"};\n+    List<Integer> dataTypes = new ArrayList<>();\n+    int sizeSum = 0;\n+    dataTypes.add(TSDataType.INT32.ordinal());\n+    sizeSum += 8 + TSDataType.INT32.getDataTypeSize();\n+    dataTypes.add(TSDataType.INT64.ordinal());\n+    sizeSum += 8 + TSDataType.INT64.getDataTypeSize();\n+    dataTypes.add(TSDataType.FLOAT.ordinal());\n+    sizeSum += 8 + TSDataType.FLOAT.getDataTypeSize();\n+    dataTypes.add(TSDataType.DOUBLE.ordinal());\n+    sizeSum += 8 + TSDataType.DOUBLE.getDataTypeSize();\n+    dataTypes.add(TSDataType.TEXT.ordinal());\n+    sizeSum += TSDataType.TEXT.getDataTypeSize();\n+    InsertTabletPlan insertPlan = new InsertTabletPlan(device, measurements, dataTypes);\n+    Assert.assertEquals(sizeSum, MemUtils.getRecordSize(insertPlan, 0, 1, false));\n+  }\n+\n+  @Test\n+  public void TsRecordSizeTest() {\n+    int totalSize = 0;\n+    String device = \"root.sg.d1\";\n+    TSRecord record = new TSRecord(0, device);\n+\n+    DataPoint point1 = new IntDataPoint(\"s1\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s1\") + 20, MemUtils.getDataPointMem(point1));\n+    totalSize += MemUtils.getDataPointMem(point1);\n+    record.addTuple(point1);\n+\n+    DataPoint point2 = new LongDataPoint(\"s2\", 1);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s2\") + 24, MemUtils.getDataPointMem(point2));\n+    totalSize += MemUtils.getDataPointMem(point2);\n+    record.addTuple(point2);\n+\n+    DataPoint point3 = new FloatDataPoint(\"s3\", 1.0f);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s3\") + 20, MemUtils.getDataPointMem(point3));\n+    totalSize += MemUtils.getDataPointMem(point3);\n+    record.addTuple(point3);\n+\n+    DataPoint point4 = new DoubleDataPoint(\"s4\", 1.0d);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s4\") + 24, MemUtils.getDataPointMem(point4));\n+    totalSize += MemUtils.getDataPointMem(point4);\n+    record.addTuple(point4);\n+\n+    DataPoint point5 = new BooleanDataPoint(\"s5\", true);\n+    Assert.assertEquals(MemUtils.getStringMem(\"s5\") + 17, MemUtils.getDataPointMem(point5));\n+    totalSize += MemUtils.getDataPointMem(point5);\n+    record.addTuple(point5);", "originalCommit": "234179bc5cea5460663fd51e683b23669d9faafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxMTA4NQ==", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540911085", "bodyText": "I don't think serdes is a good abbreviation...", "author": "Alima777", "createdAt": "2020-12-11T12:25:30Z", "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {", "originalCommit": "234179bc5cea5460663fd51e683b23669d9faafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxMzExNA==", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540913114", "bodyText": "Hi, I checked the name of this method in SerializeUtils, which called just serialize. FMP, it's better to rename it.\nserialize -> serializeIntList,  serialize -> serializeIntSet...", "author": "Alima777", "createdAt": "2020-12-11T12:29:13Z", "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {", "originalCommit": "234179bc5cea5460663fd51e683b23669d9faafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxNTQwMg==", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540915402", "bodyText": "Actually, there are three types of BatchData, and two of them are subClass of BatchData. You should test them all.", "author": "Alima777", "createdAt": "2020-12-11T12:33:33Z", "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intlist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesIntSetTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    Set<Integer> intSet = new TreeSet<>(intlist);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intSet, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesNodeTest() {\n+    Node node = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(node, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Node anotherNode = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    SerializeUtils.deserialize(anotherNode, buffer);\n+    Assert.assertEquals(node, anotherNode);\n+  }\n+\n+  @Test\n+  public void serdesINT32BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT32);\n+    int ivalue = 0;", "originalCommit": "234179bc5cea5460663fd51e683b23669d9faafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxNjYzOA==", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540916638", "bodyText": "Add javadoc for this and the next test.", "author": "Alima777", "createdAt": "2020-12-11T12:35:51Z", "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intlist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesIntSetTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    Set<Integer> intSet = new TreeSet<>(intlist);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intSet, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesNodeTest() {\n+    Node node = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(node, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Node anotherNode = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    SerializeUtils.deserialize(anotherNode, buffer);\n+    Assert.assertEquals(node, anotherNode);\n+  }\n+\n+  @Test\n+  public void serdesINT32BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT32);\n+    int ivalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, ivalue);\n+      ivalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesINT64BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT64);\n+    long lvalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, lvalue);\n+      lvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesFLOATBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.FLOAT);\n+    float fvalue = 0f;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, fvalue);\n+      fvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesDOUBLEBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.DOUBLE);\n+    double dvalue = 0d;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, dvalue);\n+      dvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesBOOLEANBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.BOOLEAN);\n+    batchData.putAnObject(1, true);\n+    batchData.putAnObject(2, false);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTEXTBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.TEXT);\n+    String svalue = \"\";\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, Binary.valueOf(svalue));\n+      svalue += String.valueOf(time);\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTVPairTest() {\n+    List<TimeValuePair> TVPairs = new ArrayList<>();\n+    TimeValuePair p1 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.BOOLEAN, true));\n+    TVPairs.add(p1);", "originalCommit": "234179bc5cea5460663fd51e683b23669d9faafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkxNzQxMw==", "url": "https://github.com/apache/iotdb/pull/2246#discussion_r540917413", "bodyText": "It's Longs here. And add javadoc.", "author": "Alima777", "createdAt": "2020-12-11T12:37:19Z", "path": "server/src/test/java/org/apache/iotdb/db/utils/SerializeUtilsTest.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.utils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class SerializeUtilsTest {\n+  @Test\n+  public void serdesStringTest() {\n+    String str = \"abcd%+/123\\n\\t\";\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(str, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(str, SerializeUtils.deserializeString(buffer));\n+  }\n+\n+  @Test\n+  public void serdesStringListTest() {\n+    List<String> slist = Arrays.asList(\"abc\", \"123\", \"y87@\", \"9+&d\\n\");\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeStringList(slist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(slist, SerializeUtils.deserializeStringList(buffer));\n+  }\n+\n+  @Test\n+  public void serdesIntListTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intlist, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesIntSetTest() {\n+    List<Integer> intlist = Arrays.asList(12, 34, 567, 8910);\n+    Set<Integer> intSet = new TreeSet<>(intlist);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(intSet, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    List<Integer> anotherIntlist = new ArrayList<>();\n+    SerializeUtils.deserialize(anotherIntlist, buffer);\n+    Assert.assertEquals(intlist, anotherIntlist);\n+  }\n+\n+  @Test\n+  public void serdesNodeTest() {\n+    Node node = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serialize(node, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Node anotherNode = new Node(\"127.0.0.1\", 6667, 1, 6535, 4678);\n+    SerializeUtils.deserialize(anotherNode, buffer);\n+    Assert.assertEquals(node, anotherNode);\n+  }\n+\n+  @Test\n+  public void serdesINT32BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT32);\n+    int ivalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, ivalue);\n+      ivalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesINT64BatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.INT64);\n+    long lvalue = 0;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, lvalue);\n+      lvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesFLOATBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.FLOAT);\n+    float fvalue = 0f;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, fvalue);\n+      fvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesDOUBLEBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.DOUBLE);\n+    double dvalue = 0d;\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, dvalue);\n+      dvalue++;\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesBOOLEANBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.BOOLEAN);\n+    batchData.putAnObject(1, true);\n+    batchData.putAnObject(2, false);\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTEXTBatchDataTest() {\n+    BatchData batchData = new BatchData(TSDataType.TEXT);\n+    String svalue = \"\";\n+    for (long time = 0; time < 10; time++) {\n+      batchData.putAnObject(time, Binary.valueOf(svalue));\n+      svalue += String.valueOf(time);\n+    }\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeBatchData(batchData, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    BatchData anotherBatch = SerializeUtils.deserializeBatchData(buffer);\n+    while (batchData.hasCurrent()) {\n+      Assert.assertEquals(batchData.currentValue(), anotherBatch.currentValue());\n+      batchData.next();\n+      anotherBatch.next();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesTVPairTest() {\n+    List<TimeValuePair> TVPairs = new ArrayList<>();\n+    TimeValuePair p1 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.BOOLEAN, true));\n+    TVPairs.add(p1);\n+    TimeValuePair p2 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT32, 1));\n+    TVPairs.add(p2);\n+    TimeValuePair p3 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT64, 1L));\n+    TVPairs.add(p3);\n+    TimeValuePair p4 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.FLOAT, 1.0f));\n+    TVPairs.add(p4);\n+    TimeValuePair p5 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.DOUBLE, 1.0d));\n+    TVPairs.add(p5);\n+    TimeValuePair p6 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.TEXT, Binary.valueOf(\"a\")));\n+    TVPairs.add(p6);\n+\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    for (TimeValuePair tv : TVPairs) {\n+      SerializeUtils.serializeTVPair(tv, outputStream);\n+      ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+      Assert.assertEquals(tv, SerializeUtils.deserializeTVPair(buffer));\n+      baos.reset();\n+    }\n+\n+  }\n+\n+  @Test\n+  public void serdesTVPairsTest() {\n+    List<List<TimeValuePair>> TVPairs = new ArrayList<>();\n+    TimeValuePair p1 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.BOOLEAN, true));\n+    TVPairs.add(Collections.singletonList(p1));\n+    TimeValuePair p2 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT32, 1));\n+    TVPairs.add(Collections.singletonList(p2));\n+    TimeValuePair p3 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.INT64, 1L));\n+    TVPairs.add(Collections.singletonList(p3));\n+    TimeValuePair p4 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.FLOAT, 1.0f));\n+    TVPairs.add(Collections.singletonList(p4));\n+    TimeValuePair p5 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.DOUBLE, 1.0d));\n+    TVPairs.add(Collections.singletonList(p5));\n+    TimeValuePair p6 = new TimeValuePair(0, TsPrimitiveType.getByType(TSDataType.TEXT, Binary.valueOf(\"a\")));\n+    TVPairs.add(Collections.singletonList(p6));\n+\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    for (List<TimeValuePair> tv : TVPairs) {\n+      SerializeUtils.serializeTVPairs(tv, outputStream);\n+      ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+      Assert.assertEquals(tv, SerializeUtils.deserializeTVPairs(buffer));\n+      baos.reset();\n+    }\n+  }\n+\n+  @Test\n+  public void serdesObjectTest() {\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeObject(1, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertEquals(1, SerializeUtils.deserializeObject(buffer));\n+  }\n+\n+  @Test\n+  public void serdesObjectsTest() {\n+    Object[] objects = { 1, \"2\", 3d};\n+    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    DataOutputStream outputStream = new DataOutputStream(baos);\n+    SerializeUtils.serializeObjects(objects, outputStream);\n+    ByteBuffer buffer = ByteBuffer.wrap(baos.toByteArray());\n+    Assert.assertArrayEquals(objects, SerializeUtils.deserializeObjects(buffer));\n+  }\n+\n+  @Test\n+  public void serdesLongTest() {\n+    long[] array = {1, 10, 100, 1000, 10000};", "originalCommit": "234179bc5cea5460663fd51e683b23669d9faafc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7fc0fdcd39d87cbd5ce56c60cc8da266ec198f9a", "url": "https://github.com/apache/iotdb/commit/7fc0fdcd39d87cbd5ce56c60cc8da266ec198f9a", "message": "More test cases", "committedDate": "2020-12-16T01:38:04Z", "type": "commit"}, {"oid": "a9cbfaaee368cbaaae034ebfa418a55193864339", "url": "https://github.com/apache/iotdb/commit/a9cbfaaee368cbaaae034ebfa418a55193864339", "message": "More test cases", "committedDate": "2020-12-17T09:58:13Z", "type": "commit"}, {"oid": "4a5791d014f0113f22ad6f68034fdbddfff40b4e", "url": "https://github.com/apache/iotdb/commit/4a5791d014f0113f22ad6f68034fdbddfff40b4e", "message": "rename serialize methods", "committedDate": "2020-12-17T10:10:31Z", "type": "commit"}, {"oid": "47af65f45ecffc78b6e4f6416b0115d474418825", "url": "https://github.com/apache/iotdb/commit/47af65f45ecffc78b6e4f6416b0115d474418825", "message": "Merge remote-tracking branch 'upstream/master' into unittest", "committedDate": "2020-12-18T10:48:01Z", "type": "commit"}]}