{"pr_number": 1474, "pr_title": "prepare for wal replayed successfully after restart", "pr_createdAt": "2020-07-09T07:10:25Z", "pr_url": "https://github.com/apache/iotdb/pull/1474", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQwMzIwMA==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r453403200", "bodyText": "When is this pool shut down? And what is the point that you do not wait until the recovery finishes?", "author": "jt2594838", "createdAt": "2020-07-13T02:27:09Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "diffHunk": "@@ -135,6 +140,15 @@ private StorageEngine() {\n     // recover upgrade process\n     UpgradeUtils.recoverUpgrade();\n \n+    recover();\n+  }\n+\n+  public void recover() {\n+    ExecutorService executors = Executors.newSingleThreadExecutor();\n+    executors.submit(this::recoverAllSgs);", "originalCommit": "8bda5930a9162fb3b0efaefa81514b96ff862e05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxNDYwOA==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r453414608", "bodyText": "Wait util all sgs have been recoverd. This means all sgs could get the remote schema or someone return that the schema is not exist when replayed the wal", "author": "mychaow", "createdAt": "2020-07-13T03:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQwMzIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQwNDU4Ng==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r453404586", "bodyText": "I think this is not very friendly. Some users may want to send requests once the server is up, without noticing whether the recovery has finished, and they will feel upset when they receive failures.\nIt may help to add some wait and timeout, so there is less chance that the user will miss first operations.", "author": "jt2594838", "createdAt": "2020-07-13T02:33:51Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "diffHunk": "@@ -252,18 +267,24 @@ public StorageGroupProcessor getProcessor(String path) throws StorageEngineExcep\n       StorageGroupProcessor processor;\n       processor = processorMap.get(storageGroupName);\n       if (processor == null) {\n-        storageGroupName = storageGroupName.intern();\n-        synchronized (storageGroupName) {\n-          processor = processorMap.get(storageGroupName);\n-          if (processor == null) {\n-            logger.info(\"construct a processor instance, the storage group is {}, Thread is {}\",\n+        // if finish recover\n+        if (isAllSgReady.get()) {\n+          storageGroupName = storageGroupName.intern();\n+          synchronized (storageGroupName) {\n+            processor = processorMap.get(storageGroupName);\n+            if (processor == null) {\n+              logger.info(\"construct a processor instance, the storage group is {}, Thread is {}\",\n                 storageGroupName, Thread.currentThread().getId());\n-            processor = new StorageGroupProcessor(systemDir, storageGroupName, fileFlushPolicy);\n-            StorageGroupMNode storageGroup = IoTDB.metaManager\n+              processor = new StorageGroupProcessor(systemDir, storageGroupName, fileFlushPolicy);\n+              StorageGroupMNode storageGroup = IoTDB.metaManager\n                 .getStorageGroupNode(storageGroupName);\n-            processor.setDataTTL(storageGroup.getDataTTL());\n-            processorMap.put(storageGroupName, processor);\n+              processor.setDataTTL(storageGroup.getDataTTL());\n+              processorMap.put(storageGroupName, processor);\n+            }\n           }\n+        } else {\n+          // not finished recover, refuse the request\n+          throw new StorageEngineException(\"the sg \" + storageGroupName + \" may not ready now, please wait and retry later\");", "originalCommit": "8bda5930a9162fb3b0efaefa81514b96ff862e05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxMzkyOA==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r453413928", "bodyText": "yes, some wait will be friendly, I will add it.", "author": "mychaow", "createdAt": "2020-07-13T03:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQwNDU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQwNjEwNw==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r453406107", "bodyText": "Using the device node will help reduce the search path (otherwise it will search from the root node every time), so I would suggest you add the device node as a nullable parameter of MManager.updateLastCache and use it as much as possible.", "author": "jt2594838", "createdAt": "2020-07-13T02:41:01Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -792,8 +792,9 @@ private void tryToUpdateBatchInsertLastCache(InsertTabletPlan plan, Long latestF\n           continue;\n         }\n         // Update cached last value with high priority\n-        ((MeasurementMNode) manager.getChild(node, measurementList[i]))\n-            .updateCachedLast(plan.composeLastTimeValuePair(i), true, latestFlushedTime);\n+        Path tmpPath = new Path(plan.getDeviceId(), measurementList[i]);\n+        manager.updateLastCache(tmpPath.getFullPath(),\n+          plan.composeLastTimeValuePair(i), true, latestFlushedTime);", "originalCommit": "8bda5930a9162fb3b0efaefa81514b96ff862e05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQwNjQyOQ==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r453406429", "bodyText": "And it is a little wasteful to join deviceId and measurementId using a Path. You may just use string concatenation.", "author": "jt2594838", "createdAt": "2020-07-13T02:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQwNjEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxMzAxMQ==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r453413011", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-07-13T03:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQwNjEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxMDI5NQ==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r453410295", "bodyText": "How about just waiting where you created that single thread pool and shuting down it?", "author": "jt2594838", "createdAt": "2020-07-13T03:01:28Z", "path": "server/src/main/java/org/apache/iotdb/db/service/IoTDB.java", "diffHunk": "@@ -123,7 +120,22 @@ private void setUp() throws StartupException {\n     if (IoTDBDescriptor.getInstance().getConfig().isEnableMQTTService()) {\n       registerManager.register(MQTTService.getInstance());\n     }\n-    logger.info(\"IoTDB is set up.\");\n+\n+    logger.info(\"IoTDB is set up, now may some sgs are not ready, don't worry, the superman Dr. Huang will teach the sg to fix themselves.\");\n+\n+    while (!StorageEngine.getInstance().isAllSgReady()) {\n+      try {\n+        Thread.sleep(1000);\n+      } catch (InterruptedException e) {\n+        e.printStackTrace();\n+      }\n+    }", "originalCommit": "8bda5930a9162fb3b0efaefa81514b96ff862e05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxNDY2Mg==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r453414662", "bodyText": "Good idea!", "author": "mychaow", "createdAt": "2020-07-13T03:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQxMDI5NQ=="}], "type": "inlineReview"}, {"oid": "dc9c8fc919f3d6859450d05a578b3c9f0fa8c361", "url": "https://github.com/apache/iotdb/commit/dc9c8fc919f3d6859450d05a578b3c9f0fa8c361", "message": "wait all wals are replayed successfully", "committedDate": "2020-07-13T04:14:22Z", "type": "commit"}, {"oid": "99028b758d8bcf451a59cff14f0d765005308b63", "url": "https://github.com/apache/iotdb/commit/99028b758d8bcf451a59cff14f0d765005308b63", "message": "modify the logic to support cluster", "committedDate": "2020-07-13T06:56:53Z", "type": "commit"}, {"oid": "0f2f84b886605b0e7880c93e1c5274819fd2d32f", "url": "https://github.com/apache/iotdb/commit/0f2f84b886605b0e7880c93e1c5274819fd2d32f", "message": "use device node when update last cache", "committedDate": "2020-07-13T08:16:31Z", "type": "commit"}, {"oid": "0f2f84b886605b0e7880c93e1c5274819fd2d32f", "url": "https://github.com/apache/iotdb/commit/0f2f84b886605b0e7880c93e1c5274819fd2d32f", "message": "use device node when update last cache", "committedDate": "2020-07-13T08:16:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDEyMzE2OA==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r454123168", "bodyText": "please log the exception and format the code", "author": "qiaojialin", "createdAt": "2020-07-14T06:07:42Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -1837,6 +1758,40 @@ public void cacheSchema(String path, MeasurementSchema schema) {\n     boolean satisfy(String storageGroup);\n   }\n \n+  /**\n+   * if the path is in local mtree, nothing needed to do (because mtree is in the memory); Otherwise\n+   * cache the path to mRemoteSchemaCache\n+   */\n+  public void cacheMeta(String path, MeasurementMeta meta) {\n+    // do nothing\n+  }\n+\n+  public void updateLastCache(String seriesPath, TimeValuePair timeValuePair,\n+                              boolean highPriorityUpdate, Long latestFlushedTime,\n+                              MeasurementMNode node) {\n+    if (node != null) {\n+      node.updateCachedLast(timeValuePair, highPriorityUpdate, latestFlushedTime);\n+    } else {\n+      try {\n+        MeasurementMNode node1 = (MeasurementMNode) mtree.getNodeByPath(seriesPath);\n+        node1.updateCachedLast(timeValuePair, highPriorityUpdate, latestFlushedTime);\n+      } catch (MetadataException e) {\n+        logger.warn(\"the {} is not exist\", seriesPath);\n+      }\n+    }\n+  }\n+\n+  public TimeValuePair getLastCache(String seriesPath) {\n+   try {\n+     MeasurementMNode node = null;\n+     node = (MeasurementMNode) mtree.getNodeByPath(seriesPath);\n+     return node.getCachedLast();\n+  } catch (MetadataException e) {\n+     // do nothing\n+  }\n+  return null;", "originalCommit": "0f2f84b886605b0e7880c93e1c5274819fd2d32f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDEyNDQ4Ng==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r454124486", "bodyText": "The String concat is an overhead in single node IoTDB, could we avoid this?", "author": "qiaojialin", "createdAt": "2020-07-14T06:11:21Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -785,8 +785,12 @@ private void tryToUpdateBatchInsertLastCache(InsertTabletPlan plan, Long latestF\n         continue;\n       }\n       // Update cached last value with high priority\n-      ((MeasurementMNode) node.getChild(measurementList[i]))\n-          .updateCachedLast(plan.composeLastTimeValuePair(i), true, latestFlushedTime);\n+      MeasurementMNode tmpMeasurementNode = null;\n+      if (node != null) {\n+        tmpMeasurementNode = (MeasurementMNode) node.getChild(measurementList[i]);\n+      }\n+      IoTDB.metaManager.updateLastCache(node.getFullPath() + IoTDBConstant.PATH_SEPARATOR + measurementList[i],", "originalCommit": "0f2f84b886605b0e7880c93e1c5274819fd2d32f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE3NDcwMQ==", "url": "https://github.com/apache/iotdb/pull/1474#discussion_r454174701", "bodyText": "How about the following code?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  IoTDB.metaManager.updateLastCache(node.getFullPath() + IoTDBConstant.PATH_SEPARATOR + measurementList[i],\n          \n          \n            \n             if (tmpMeasurementNode != null) {\n          \n          \n            \n                    IoTDB.metaManager.updateLastCache(node.getFullPath(),\n          \n          \n            \n                      plan.composeLastTimeValuePair(i), true, latestFlushedTime, tmpMeasurementNode);\n          \n          \n            \n                  } else {\n          \n          \n            \n                    IoTDB.metaManager.updateLastCache(node.getFullPath() + IoTDBConstant.PATH_SEPARATOR + measurementList[i],\n          \n          \n            \n                      plan.composeLastTimeValuePair(i), true, latestFlushedTime, tmpMeasurementNode);\n          \n          \n            \n                  }", "author": "mychaow", "createdAt": "2020-07-14T07:58:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDEyNDQ4Ng=="}], "type": "inlineReview"}, {"oid": "05bfe1c7222ab69402646d647febdfb3b2a29770", "url": "https://github.com/apache/iotdb/commit/05bfe1c7222ab69402646d647febdfb3b2a29770", "message": "avoid string concat for single node version", "committedDate": "2020-07-14T08:18:49Z", "type": "commit"}]}