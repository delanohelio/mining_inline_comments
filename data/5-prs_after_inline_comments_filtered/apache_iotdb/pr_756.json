{"pr_number": 756, "pr_title": "[IOTDB-434] Refactor SeriesReaderByTimestamp", "pr_createdAt": "2020-01-20T07:13:18Z", "pr_url": "https://github.com/apache/iotdb/pull/756", "timeline": [{"oid": "b3104c524ca7000ea6370fbacd4e85d3e7956ad6", "url": "https://github.com/apache/iotdb/commit/b3104c524ca7000ea6370fbacd4e85d3e7956ad6", "message": "add new byTimestampReader", "committedDate": "2020-01-20T07:11:38Z", "type": "commit"}, {"oid": "f524bd14f66b835c8aa3d3b90900a8a2e64f08f5", "url": "https://github.com/apache/iotdb/commit/f524bd14f66b835c8aa3d3b90900a8a2e64f08f5", "message": "skip read", "committedDate": "2020-01-21T01:46:07Z", "type": "commit"}, {"oid": "972d340bfdd5210cedf8ffa1027db0d596170009", "url": "https://github.com/apache/iotdb/commit/972d340bfdd5210cedf8ffa1027db0d596170009", "message": "rewrite if", "committedDate": "2020-01-21T01:54:25Z", "type": "commit"}, {"oid": "bc9047cf8d956b4e085536d0eeb13100d8dc5f32", "url": "https://github.com/apache/iotdb/commit/bc9047cf8d956b4e085536d0eeb13100d8dc5f32", "message": "fix bug", "committedDate": "2020-01-21T01:56:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1MDkyMQ==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368850921", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throws StorageEngineException, IOException {\n          \n          \n            \n                  throws StorageEngineException {", "author": "qiaojialin", "createdAt": "2020-01-21T07:51:05Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithValueFilterDataSet.java", "diffHunk": "@@ -75,12 +75,13 @@ public GroupByWithValueFilterDataSet(long queryId, GroupByPlan groupByPlan) {\n    * init reader and aggregate function.\n    */\n   private void initGroupBy(QueryContext context, GroupByPlan groupByPlan)\n-      throws StorageEngineException, IOException, PathException {\n+      throws StorageEngineException, IOException {", "originalCommit": "bc9047cf8d956b4e085536d0eeb13100d8dc5f32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a93734e3caa04b6ec3b2aaf41f4faab14596912d", "url": "https://github.com/apache/iotdb/commit/a93734e3caa04b6ec3b2aaf41f4faab14596912d", "message": "Update server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithValueFilterDataSet.java\n\nCo-Authored-By: Jialin Qiao <qjl16@mails.tsinghua.edu.cn>", "committedDate": "2020-01-21T08:55:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3MTI3OQ==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368871279", "bodyText": "It's better to treat the timestamp into a time >= t or time = t filter, and set this filter into AbstractDataReader.\nThen, the loadSatisfiedChunkMetadatas method in AbstractDataReader will help filter chunks.\nFuthermore, the tryToFillChunkMetadatas should be improved in this condition, the filter should be applied to the TsFileResource, if the startTime and end time of a tsfile does not satisfy the filter, we should not call loadSatisfiedChunkMetadatas for this resource.", "author": "qiaojialin", "createdAt": "2020-01-21T08:47:14Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/seriesRelated/SeriesDataReaderByTimestamp.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.query.reader.seriesRelated;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.reader.IReaderByTimestamp;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+\n+\n+public class SeriesDataReaderByTimestamp extends AbstractDataReader implements\n+    IReaderByTimestamp {\n+\n+  private BatchData batchData;\n+  private long timestamp;\n+\n+  public SeriesDataReaderByTimestamp(Path seriesPath, TSDataType dataType, QueryContext context)\n+      throws StorageEngineException {\n+    super(seriesPath, dataType, null, context);\n+  }\n+\n+  @Override\n+  public Object getValueInTimestamp(long timestamp) throws IOException {\n+    this.timestamp = timestamp;\n+    if (batchData == null || batchData.getTimeByIndex(batchData.length() - 1) < timestamp) {\n+      if (!hasNext(timestamp)) {\n+        return null;\n+      }\n+    }\n+\n+    return batchData.getValueInTimestamp(timestamp);\n+  }\n+\n+  private boolean hasNext(long timestamp) throws IOException {\n+    while (super.hasNextChunk()) {\n+      Statistics statistics = firstChunkMetaData.getStatistics();\n+      if (statistics.getEndTime() < timestamp) {", "originalCommit": "bc9047cf8d956b4e085536d0eeb13100d8dc5f32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk5NDIyMg==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368994222", "bodyText": "You're absolutely right, I need to refactor part of AbstractReader to complete the implementation of this method", "author": "liutaohua", "createdAt": "2020-01-21T13:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3MTI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3MjY0NA==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368872644", "bodyText": "Maybe this class should extend SeriesDataReaderWithoutValueFilter", "author": "qiaojialin", "createdAt": "2020-01-21T08:50:38Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/seriesRelated/SeriesDataReaderByTimestamp.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.query.reader.seriesRelated;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.reader.IReaderByTimestamp;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+\n+\n+public class SeriesDataReaderByTimestamp extends AbstractDataReader implements\n+    IReaderByTimestamp {\n+\n+  private BatchData batchData;\n+  private long timestamp;\n+\n+  public SeriesDataReaderByTimestamp(Path seriesPath, TSDataType dataType, QueryContext context)\n+      throws StorageEngineException {\n+    super(seriesPath, dataType, null, context);\n+  }\n+\n+  @Override\n+  public Object getValueInTimestamp(long timestamp) throws IOException {\n+    this.timestamp = timestamp;\n+    if (batchData == null || batchData.getTimeByIndex(batchData.length() - 1) < timestamp) {\n+      if (!hasNext(timestamp)) {\n+        return null;\n+      }\n+    }\n+\n+    return batchData.getValueInTimestamp(timestamp);\n+  }\n+\n+  private boolean hasNext(long timestamp) throws IOException {\n+    while (super.hasNextChunk()) {\n+      Statistics statistics = firstChunkMetaData.getStatistics();\n+      if (statistics.getEndTime() < timestamp) {\n+        hasCachedFirstChunkMetadata = false;\n+        firstChunkMetaData = null;\n+        continue;\n+      }\n+      while (super.hasNextPage()) {\n+        Statistics pageStatistics = currentPageStatistics();\n+        if (pageStatistics.getEndTime() < timestamp) {\n+          overlappedPageReaders.poll();\n+          continue;\n+        }\n+        if (canUseCurrentPageStatistics()) {\n+          batchData = nextPage();\n+        } else {\n+          batchData = nextOverlappedPage();\n+        }\n+        if (batchData.getTimeByIndex(batchData.length() - 1) >= timestamp) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private Statistics currentPageStatistics() throws IOException {", "originalCommit": "bc9047cf8d956b4e085536d0eeb13100d8dc5f32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk5NTA4MA==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368995080", "bodyText": "I think should be  extends AbstractReader  directly, currentPageStatistics is not theSeriesDataReaderWithoutValueFilter method", "author": "liutaohua", "createdAt": "2020-01-21T13:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3MjY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NDI3MA==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368874270", "bodyText": "Remove the hasNext method in IReaderByTimestamp, it's a redundant method.\nTry to remove the SeqResourceReaderByTimestamp, UnseqResourceReaderByTimestamp and all related classes that unsless.", "author": "qiaojialin", "createdAt": "2020-01-21T08:54:16Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/seriesRelated/SeriesDataReaderByTimestamp.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.query.reader.seriesRelated;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.reader.IReaderByTimestamp;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+\n+\n+public class SeriesDataReaderByTimestamp extends AbstractDataReader implements\n+    IReaderByTimestamp {\n+\n+  private BatchData batchData;\n+  private long timestamp;\n+\n+  public SeriesDataReaderByTimestamp(Path seriesPath, TSDataType dataType, QueryContext context)\n+      throws StorageEngineException {\n+    super(seriesPath, dataType, null, context);\n+  }\n+\n+  @Override\n+  public Object getValueInTimestamp(long timestamp) throws IOException {\n+    this.timestamp = timestamp;\n+    if (batchData == null || batchData.getTimeByIndex(batchData.length() - 1) < timestamp) {\n+      if (!hasNext(timestamp)) {\n+        return null;\n+      }\n+    }\n+\n+    return batchData.getValueInTimestamp(timestamp);\n+  }\n+\n+  private boolean hasNext(long timestamp) throws IOException {\n+    while (super.hasNextChunk()) {\n+      Statistics statistics = firstChunkMetaData.getStatistics();\n+      if (statistics.getEndTime() < timestamp) {\n+        hasCachedFirstChunkMetadata = false;\n+        firstChunkMetaData = null;\n+        continue;\n+      }\n+      while (super.hasNextPage()) {\n+        Statistics pageStatistics = currentPageStatistics();\n+        if (pageStatistics.getEndTime() < timestamp) {\n+          overlappedPageReaders.poll();\n+          continue;\n+        }\n+        if (canUseCurrentPageStatistics()) {\n+          batchData = nextPage();\n+        } else {\n+          batchData = nextOverlappedPage();\n+        }\n+        if (batchData.getTimeByIndex(batchData.length() - 1) >= timestamp) {\n+          return true;\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private Statistics currentPageStatistics() throws IOException {\n+    if (overlappedPageReaders.isEmpty() || overlappedPageReaders.peek().data == null) {\n+      throw new IOException(\"No next page statistics.\");\n+    }\n+    return overlappedPageReaders.peek().data.getStatistics();\n+  }\n+\n+\n+  @Override\n+  protected boolean satisfyFilter(Statistics statistics) {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean hasNext() throws IOException {", "originalCommit": "bc9047cf8d956b4e085536d0eeb13100d8dc5f32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk5ODE0MQ==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368998141", "bodyText": "Currently, ExternalSortJob is also using IReaderByTimestamp, I'm not going to fix it in this pr", "author": "liutaohua", "createdAt": "2020-01-21T13:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NDI3MA=="}], "type": "inlineReview"}, {"oid": "7ea8203af9569c8c1b72275e8dddd9ba3c1593ec", "url": "https://github.com/apache/iotdb/commit/7ea8203af9569c8c1b72275e8dddd9ba3c1593ec", "message": "rewrite AbstractDataReader", "committedDate": "2020-01-21T12:47:56Z", "type": "commit"}, {"oid": "97a5184b9f8aa11b3f67335c0f19aafed358a1d0", "url": "https://github.com/apache/iotdb/commit/97a5184b9f8aa11b3f67335c0f19aafed358a1d0", "message": "Merge remote-tracking branch 'origin/overwrite_timestampReader' into overwrite_timestampReader", "committedDate": "2020-01-21T12:49:42Z", "type": "commit"}, {"oid": "fbf12a32b81b157c6e21e36b151cbffc0aaa15bc", "url": "https://github.com/apache/iotdb/commit/fbf12a32b81b157c6e21e36b151cbffc0aaa15bc", "message": "rewrite satisfyFilter", "committedDate": "2020-01-21T12:56:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk4NDQ4NA==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368984484", "bodyText": "remove this class", "author": "qiaojialin", "createdAt": "2020-01-21T12:57:51Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/resourceRelated/SeqResourceReaderByTimestamp.java", "diffHunk": "@@ -1,190 +1,189 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.iotdb.db.query.reader.resourceRelated;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n-import org.apache.iotdb.db.engine.modification.Modification;\n-import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n-import org.apache.iotdb.db.query.context.QueryContext;\n-import org.apache.iotdb.db.query.control.FileReaderManager;\n-import org.apache.iotdb.db.query.reader.IReaderByTimestamp;\n-import org.apache.iotdb.db.query.reader.fileRelated.FileSeriesReaderByTimestampAdapter;\n-import org.apache.iotdb.db.query.reader.fileRelated.UnSealedTsFileReaderByTimestamp;\n-import org.apache.iotdb.db.utils.QueryUtils;\n-import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n-import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n-import org.apache.iotdb.tsfile.read.common.Path;\n-import org.apache.iotdb.tsfile.read.controller.IChunkLoader;\n-import org.apache.iotdb.tsfile.read.controller.ChunkLoaderImpl;\n-import org.apache.iotdb.tsfile.read.reader.series.FileSeriesReaderByTimestamp;\n-\n-/**\n- * To read a chronologically ordered list of sequence TsFiles by timestamp, this class implements\n- * <code>IReaderByTimestamp</code> for the TsFiles.\n- * <p>\n- * Notes: 1) The list of sequence TsFiles is in strict chronological order. 2) The data in a\n- * sequence TsFile is also organized in chronological order. 3) A sequence TsFile can be either\n- * sealed or unsealed. 4) An unsealed sequence TsFile consists of two parts of data in chronological\n- * order: data that has been flushed to disk and data in the flushing memtable list.\n- * <p>\n- * This class is used in {@link org.apache.iotdb.db.query.reader.seriesRelated.SeriesReaderByTimestamp}.\n- */\n-\n-public class SeqResourceReaderByTimestamp implements IReaderByTimestamp {\n-\n-  protected Path seriesPath;\n-  private List<TsFileResource> seqResources;\n-  private QueryContext context;\n-  private int nextIntervalFileIndex;\n-  private IReaderByTimestamp seriesReader;\n-\n-  /**\n-   * Constructor function.\n-   * <p>\n-   *\n-   * @param seriesPath the path of the series data\n-   * @param seqResources a list of sequence TsFile resources in chronological order\n-   * @param context query context\n-   */\n-  public SeqResourceReaderByTimestamp(Path seriesPath, List<TsFileResource> seqResources,\n-      QueryContext context) {\n-    this.seriesPath = seriesPath;\n-    this.seqResources = seqResources;\n-    this.context = context;\n-    this.nextIntervalFileIndex = 0;\n-    this.seriesReader = null;\n-  }\n-\n-  @Override\n-  public Object getValueInTimestamp(long timestamp) throws IOException {\n-    Object value = null;\n-\n-    if (seriesReader != null) {\n-      value = seriesReader.getValueInTimestamp(timestamp);\n-      // if get value or no value in this timestamp but has next, return.\n-      if (value != null || seriesReader.hasNext()) {\n-        return value;\n-      }\n-    }\n-\n-    // Because the sequence TsFile resources are chronologically globally ordered, there exists at\n-    // most one TsFile resource that overlaps this timestamp.\n-    while (nextIntervalFileIndex < seqResources.size()) {\n-      boolean isConstructed = constructNextReader(nextIntervalFileIndex++, timestamp);\n-      if (isConstructed) {\n-        value = seriesReader.getValueInTimestamp(timestamp);\n-        // if get value or no value in this timestamp but has next, return.\n-        if (value != null || seriesReader.hasNext()) {\n-          return value;\n-        }\n-      }\n-    }\n-    return value;\n-  }\n-\n-  @Override\n-  public boolean hasNext() throws IOException {\n-    if (seriesReader != null && seriesReader.hasNext()) {\n-      return true;\n-    }\n-\n-    while (nextIntervalFileIndex < seqResources.size()) {\n-      TsFileResource tsFileResource = seqResources.get(nextIntervalFileIndex++);\n-      if (tsFileResource.isClosed()) {\n-        seriesReader = initSealedTsFileReaderByTimestamp(tsFileResource, context);\n-      } else {\n-        seriesReader = new UnSealedTsFileReaderByTimestamp(tsFileResource);\n-      }\n-      if (seriesReader.hasNext()) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * If the idx-th TsFile in the <code>seqResources</code> might overlap this\n-   * <code>timestamp</code>, then construct <code>IReaderByTimestamp</code> for it, assign to the\n-   * <code>currentSeriesReader</code> and return true. Otherwise, return false.\n-   * <p>\n-   * Note that the list of sequence TsFiles is chronologically ordered, so there will be at most one\n-   * TsFile that overlaps this timestamp.\n-   *\n-   * @param idx the index of the TsFile in the resource list\n-   * @param timestamp check whether or not to construct the reader according to this timestamp\n-   * @return True if the reader is constructed; False if not.\n-   */\n-  private boolean constructNextReader(int idx, long timestamp) throws IOException {\n-    TsFileResource tsFileResource = seqResources.get(idx);\n-    if (tsFileResource.isClosed()) {\n-      if (isTsFileNotSatisfied(tsFileResource, timestamp)) {\n-        return false;\n-      }\n-      seriesReader = initSealedTsFileReaderByTimestamp(tsFileResource, context);\n-      return true;\n-    } else {\n-      // an unsealed sequence TsFile's endTimeMap size may be equal to 0 or greater than 0\n-      // If endTimeMap size is 0, conservatively assume that this TsFile might overlap this timestamp.\n-      // If endTimeMap size is not 0, call isTsFileNotSatisfied to check.\n-      if (tsFileResource.getEndTimeMap().size() != 0) {\n-        if (isTsFileNotSatisfied(tsFileResource, timestamp)) {\n-          return false;\n-        }\n-      }\n-      seriesReader = new UnSealedTsFileReaderByTimestamp(tsFileResource);\n-      return true;\n-    }\n-  }\n-\n-  /**\n-   * Returns true if the end time of the series data in this sequence TsFile is smaller than this\n-   * timestamp.\n-   * <p>\n-   * Note that <code>seqResources</code> is a list of chronologically ordered sequence TsFiles, so\n-   * there will be at most one TsFile that overlaps this timestamp.\n-   * <p>\n-   * This method is used to in <code>constructNextReader</code> to check whether this TsFile can be\n-   * skipped.\n-   */\n-  private boolean isTsFileNotSatisfied(TsFileResource tsFile, long timestamp) {\n-    return tsFile.getEndTimeMap().get(seriesPath.getDevice()) < timestamp;\n-  }\n-\n-  private IReaderByTimestamp initSealedTsFileReaderByTimestamp(TsFileResource sealedTsFile,\n-      QueryContext context) throws IOException {\n-    // prepare metaDataList\n-    List<ChunkMetaData> metaDataList = DeviceMetaDataCache.getInstance()\n-        .get(sealedTsFile, seriesPath);\n-\n-    List<Modification> pathModifications = context.getPathModifications(sealedTsFile.getModFile(),\n-        seriesPath.getFullPath());\n-    if (!pathModifications.isEmpty()) {\n-      QueryUtils.modifyChunkMetaData(metaDataList, pathModifications);\n-    }\n-    // prepare chunkLoader\n-    TsFileSequenceReader tsFileReader = FileReaderManager.getInstance()\n-        .get(sealedTsFile, true);\n-    IChunkLoader chunkLoader = new ChunkLoaderImpl(tsFileReader);\n-\n-    return new FileSeriesReaderByTimestampAdapter(\n-        new FileSeriesReaderByTimestamp(chunkLoader, metaDataList));\n-  }\n-}\n\\ No newline at end of file\n+///*\n+// * Licensed to the Apache Software Foundation (ASF) under one\n+// * or more contributor license agreements.  See the NOTICE file\n+// * distributed with this work for additional information\n+// * regarding copyright ownership.  The ASF licenses this file\n+// * to you under the Apache License, Version 2.0 (the\n+// * \"License\"); you may not use this file except in compliance\n+// * with the License.  You may obtain a copy of the License at\n+// *\n+// *     http://www.apache.org/licenses/LICENSE-2.0\n+// *\n+// * Unless required by applicable law or agreed to in writing,\n+// * software distributed under the License is distributed on an\n+// * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// * KIND, either express or implied.  See the License for the\n+// * specific language governing permissions and limitations\n+// * under the License.\n+// */\n+//package org.apache.iotdb.db.query.reader.resourceRelated;\n+//\n+//import java.io.IOException;\n+//import java.util.List;\n+//import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+//import org.apache.iotdb.db.engine.modification.Modification;\n+//import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+//import org.apache.iotdb.db.query.context.QueryContext;\n+//import org.apache.iotdb.db.query.control.FileReaderManager;\n+//import org.apache.iotdb.db.query.reader.IReaderByTimestamp;\n+//import org.apache.iotdb.db.query.reader.fileRelated.FileSeriesReaderByTimestampAdapter;\n+//import org.apache.iotdb.db.query.reader.fileRelated.UnSealedTsFileReaderByTimestamp;\n+//import org.apache.iotdb.db.utils.QueryUtils;\n+//import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+//import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+//import org.apache.iotdb.tsfile.read.common.Path;\n+//import org.apache.iotdb.tsfile.read.controller.IChunkLoader;\n+//import org.apache.iotdb.tsfile.read.controller.ChunkLoaderImpl;\n+//import org.apache.iotdb.tsfile.read.reader.series.FileSeriesReaderByTimestamp;\n+//\n+///**\n+// * To read a chronologically ordered list of sequence TsFiles by timestamp, this class implements\n+// * <code>IReaderByTimestamp</code> for the TsFiles.\n+// * <p>\n+// * Notes: 1) The list of sequence TsFiles is in strict chronological order. 2) The data in a\n+// * sequence TsFile is also organized in chronological order. 3) A sequence TsFile can be either\n+// * sealed or unsealed. 4) An unsealed sequence TsFile consists of two parts of data in chronological\n+// * order: data that has been flushed to disk and data in the flushing memtable list.\n+// * <p>\n+// */\n+//\n+//public class SeqResourceReaderByTimestamp implements IReaderByTimestamp {", "originalCommit": "fbf12a32b81b157c6e21e36b151cbffc0aaa15bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk5ODI0MQ==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368998241", "bodyText": "done", "author": "liutaohua", "createdAt": "2020-01-21T13:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk4NDQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk4NjkzNg==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368986936", "bodyText": "we may need to set the value in TimeEq filter, construct this object each time is costly.", "author": "qiaojialin", "createdAt": "2020-01-21T13:03:00Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/seriesRelated/SeriesDataReaderByTimestamp.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.query.reader.seriesRelated;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.reader.IReaderByTimestamp;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+\n+\n+public class SeriesDataReaderByTimestamp extends AbstractDataReader implements\n+    IReaderByTimestamp {\n+\n+  private BatchData batchData;\n+  private Filter filter;\n+\n+  public SeriesDataReaderByTimestamp(Path seriesPath, TSDataType dataType, QueryContext context,\n+      QueryDataSource dataSource) {\n+    super(seriesPath, dataType, context, dataSource.getSeqResources(),\n+        dataSource.getUnseqResources());\n+  }\n+\n+  @Override\n+  public Object getValueInTimestamp(long timestamp) throws IOException {\n+    this.filter = TimeFilter.gtEq(timestamp);", "originalCommit": "fbf12a32b81b157c6e21e36b151cbffc0aaa15bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk5ODQ4NQ==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368998485", "bodyText": "no , I think gtEq should be used here", "author": "liutaohua", "createdAt": "2020-01-21T13:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk4NjkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk4NzYxOA==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368987618", "bodyText": "could this method be removed from the IReaderByTimestamp?", "author": "qiaojialin", "createdAt": "2020-01-21T13:04:35Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/seriesRelated/SeriesDataReaderByTimestamp.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.query.reader.seriesRelated;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.reader.IReaderByTimestamp;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+\n+\n+public class SeriesDataReaderByTimestamp extends AbstractDataReader implements\n+    IReaderByTimestamp {\n+\n+  private BatchData batchData;\n+  private Filter filter;\n+\n+  public SeriesDataReaderByTimestamp(Path seriesPath, TSDataType dataType, QueryContext context,\n+      QueryDataSource dataSource) {\n+    super(seriesPath, dataType, context, dataSource.getSeqResources(),\n+        dataSource.getUnseqResources());\n+  }\n+\n+  @Override\n+  public Object getValueInTimestamp(long timestamp) throws IOException {\n+    this.filter = TimeFilter.gtEq(timestamp);\n+    if (batchData == null || batchData.getTimeByIndex(batchData.length() - 1) < timestamp) {\n+      if (!hasNext(timestamp)) {\n+        return null;\n+      }\n+    }\n+\n+    return batchData.getValueInTimestamp(timestamp);\n+  }\n+\n+  @Override\n+  public boolean hasNext() throws IOException {", "originalCommit": "fbf12a32b81b157c6e21e36b151cbffc0aaa15bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk5ODc3MA==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r368998770", "bodyText": "I'm not going to fix it in this pr", "author": "liutaohua", "createdAt": "2020-01-21T13:28:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk4NzYxOA=="}], "type": "inlineReview"}, {"oid": "2cc7dd2f508d8e65e65553de15fe14344fb5a73d", "url": "https://github.com/apache/iotdb/commit/2cc7dd2f508d8e65e65553de15fe14344fb5a73d", "message": "del unused class", "committedDate": "2020-01-21T13:16:20Z", "type": "commit"}, {"oid": "26420d515f96e7bfc7532b938cb53265ee98176b", "url": "https://github.com/apache/iotdb/commit/26420d515f96e7bfc7532b938cb53265ee98176b", "message": "MemChunkReaderByTimestamp use only one ReadOnlyMemChunk", "committedDate": "2020-01-21T13:24:28Z", "type": "commit"}, {"oid": "467d401d42e375f280f009e0e45fc6027112450c", "url": "https://github.com/apache/iotdb/commit/467d401d42e375f280f009e0e45fc6027112450c", "message": "add setValue for UnaryFilter", "committedDate": "2020-01-21T13:34:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwNjU0Mw==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r369006543", "bodyText": "no need to use a  prioritemergereader", "author": "qiaojialin", "createdAt": "2020-01-21T13:43:17Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/chunkRelated/MemChunkReaderByTimestamp.java", "diffHunk": "@@ -19,31 +19,25 @@\n package org.apache.iotdb.db.query.reader.chunkRelated;\n \n import java.io.IOException;\n-import java.util.List;\n import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n import org.apache.iotdb.db.query.reader.IReaderByTimestamp;\n-import org.apache.iotdb.db.query.reader.fileRelated.UnSealedTsFileReaderByTimestamp;\n import org.apache.iotdb.db.query.reader.universal.PriorityMergeReader;\n import org.apache.iotdb.tsfile.read.TimeValuePair;\n \n /**\n  * To read data in memory by timestamp, this class implements an interface {@link\n  * IReaderByTimestamp} based on the data source {@link ReadOnlyMemChunk}.\n  * <p>\n- * This class is used in {@link UnSealedTsFileReaderByTimestamp} and {@link\n- * org.apache.iotdb.db.query.reader.resourceRelated.UnseqResourceReaderByTimestamp}.\n  */\n public class MemChunkReaderByTimestamp implements IReaderByTimestamp {\n \n   private PriorityMergeReader timeValuePairIterator;\n   private boolean hasCachedTimeValuePair;\n   private TimeValuePair cachedTimeValuePair;\n \n-  public MemChunkReaderByTimestamp(List<ReadOnlyMemChunk> readableChunk) throws IOException {\n+  public MemChunkReaderByTimestamp(ReadOnlyMemChunk memChunk) throws IOException {\n     timeValuePairIterator = new PriorityMergeReader();\n-    for (ReadOnlyMemChunk memChunk : readableChunk) {\n-      timeValuePairIterator.addReader(memChunk.getIterator(), memChunk.getVersion());\n-    }\n+    timeValuePairIterator.addReader(memChunk.getIterator(), memChunk.getVersion());", "originalCommit": "467d401d42e375f280f009e0e45fc6027112450c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMDQ4NA==", "url": "https://github.com/apache/iotdb/pull/756#discussion_r369010484", "bodyText": "done", "author": "liutaohua", "createdAt": "2020-01-21T13:50:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwNjU0Mw=="}], "type": "inlineReview"}, {"oid": "2d16006002da4fea825e1f41d9e74c438d316732", "url": "https://github.com/apache/iotdb/commit/2d16006002da4fea825e1f41d9e74c438d316732", "message": "fix bug for MemChunkReaderByTimestamp to use PriorityMergeReader", "committedDate": "2020-01-21T13:50:34Z", "type": "commit"}]}