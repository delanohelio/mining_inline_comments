{"pr_number": 1134, "pr_title": "[IOTDB-631] Using new TsFile MetadataIndex to optimize query and cache", "pr_createdAt": "2020-04-30T09:11:50Z", "pr_url": "https://github.com/apache/iotdb/pull/1134", "timeline": [{"oid": "4339c68bbbfb0886d3661a3308b90feb83f681b1", "url": "https://github.com/apache/iotdb/commit/4339c68bbbfb0886d3661a3308b90feb83f681b1", "message": "[IOTDB-631] Using new TsFile MetadataIndex to optimize query and cache", "committedDate": "2020-04-30T09:10:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTYyMA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418935620", "bodyText": "Hi, the key.measurement should be also in the allSensors set. Therefore, we only need to query the allSensor, put them into cache. Then return the queried sensor's TimeseriesMetadata.", "author": "qiaojialin", "createdAt": "2020-05-02T09:22:18Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/TimeSeriesMetadataCache.java", "diffHunk": "@@ -125,9 +130,20 @@ public TimeseriesMetadata get(TimeSeriesMetadataCacheKey key, Set<String> allSen\n         return null;\n       }\n       TsFileSequenceReader reader = FileReaderManager.getInstance().get(key.filePath, true);\n-      TimeseriesMetadata timeseriesMetadata = reader.readTimeseriesMetadata(new Path(key.device, key.measurement));\n-      lruCache.put(key, timeseriesMetadata);\n-      return timeseriesMetadata;\n+      TimeseriesMetadata resultTimeseriesMetadata = reader\n+          .readTimeseriesMetadata(new Path(key.device, key.measurement));\n+      lruCache.put(key, resultTimeseriesMetadata);\n+\n+      List<TimeseriesMetadata> timeSeriesMetadataList = reader\n+          .readTimeseriesMetadata(key.device, allSensors);\n+      if (!allSensors.isEmpty()) {\n+        // put TimeSeriesMetadata of all sensors used in this query into cache\n+        timeSeriesMetadataList.forEach(timeseriesMetadata -> {\n+          lruCache.put(new TimeSeriesMetadataCacheKey(key.filePath, key.device,\n+              timeseriesMetadata.getMeasurementId()), timeseriesMetadata);\n+        });\n+      }", "originalCommit": "4339c68bbbfb0886d3661a3308b90feb83f681b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk2NTIzNA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418965234", "bodyText": "Hi, when I tried to only query the allSensor, I found some tests failed... which means that the allSensors set doesn't contain key.measurement... Is it a bug in query module? Or it was designed as this?", "author": "samperson1997", "createdAt": "2020-05-02T14:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUxNzczOA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r420517738", "bodyText": "it's a bug..", "author": "qiaojialin", "createdAt": "2020-05-06T02:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTk1OA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418935958", "bodyText": "check if the size of measurements reaches a threshold, just traversing from start to end is quicker, no need to binary search for each", "author": "qiaojialin", "createdAt": "2020-05-02T09:25:51Z", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java", "diffHunk": "@@ -314,28 +311,76 @@ public TsFileMetadata readFileMetadata() throws IOException {\n   public TimeseriesMetadata readTimeseriesMetadata(Path path) throws IOException {\n     readFileMetadata();\n     MetadataIndexNode deviceMetadataIndexNode = tsFileMetaData.getMetadataIndex();\n-    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetaDataAndEndOffset(\n+    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetadataAndEndOffset(\n         deviceMetadataIndexNode, path.getDevice(), MetadataIndexNodeType.INTERNAL_DEVICE);\n     ByteBuffer buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n     while (!metadataIndexPair.left.getChildNodeType()\n         .equals(MetadataIndexNodeType.LEAF_MEASUREMENT)) {\n       MetadataIndexNode metadataIndexNode = MetadataIndexNode.deserializeFrom(buffer);\n-      metadataIndexPair = getMetaDataAndEndOffset(metadataIndexNode,\n+      metadataIndexPair = getMetadataAndEndOffset(metadataIndexNode,\n           path.getMeasurement(), MetadataIndexNodeType.INTERNAL_MEASUREMENT);\n     }\n     List<TimeseriesMetadata> timeseriesMetadataList = new ArrayList<>();\n     buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n     while (buffer.hasRemaining()) {\n       timeseriesMetadataList.add(TimeseriesMetadata.deserializeFrom(buffer));\n     }\n-    String[] measurementNameList = timeseriesMetadataList.stream()\n-        .map(TimeseriesMetadata::getMeasurementId).collect(Collectors.toList())\n-        .toArray(new String[timeseriesMetadataList.size()]);\n-\n     // return null if path does not exist in the TsFile\n-    int searchResult;\n-    return (searchResult = Arrays.binarySearch(measurementNameList, path.getMeasurement())) >= 0\n-        ? timeseriesMetadataList.get(searchResult) : null;\n+    int searchResult = binarySearchInTimeseriesMetadataList(timeseriesMetadataList,\n+        path.getMeasurement());\n+    return searchResult >= 0 ? timeseriesMetadataList.get(searchResult) : null;\n+  }\n+\n+  public List<TimeseriesMetadata> readTimeseriesMetadata(String device, Set<String> measurements)\n+      throws IOException {\n+    readFileMetadata();\n+    MetadataIndexNode deviceMetadataIndexNode = tsFileMetaData.getMetadataIndex();\n+    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetadataAndEndOffset(\n+        deviceMetadataIndexNode, device, MetadataIndexNodeType.INTERNAL_DEVICE);\n+    List<TimeseriesMetadata> resultTimeseriesMetadataList = new ArrayList<>();\n+    for (String measurement : measurements) {\n+      ByteBuffer buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n+      Pair<MetadataIndexEntry, Long> measurementMetadataIndexPair = metadataIndexPair;\n+      List<TimeseriesMetadata> timeseriesMetadataList = new ArrayList<>();\n+      while (!measurementMetadataIndexPair.left.getChildNodeType()\n+          .equals(MetadataIndexNodeType.LEAF_MEASUREMENT)) {\n+        MetadataIndexNode metadataIndexNode = MetadataIndexNode.deserializeFrom(buffer);\n+        measurementMetadataIndexPair = getMetadataAndEndOffset(metadataIndexNode,\n+            measurement, MetadataIndexNodeType.INTERNAL_MEASUREMENT);\n+      }\n+      buffer = readData(measurementMetadataIndexPair.left.getOffset(),\n+          measurementMetadataIndexPair.right);\n+      while (buffer.hasRemaining()) {\n+        timeseriesMetadataList.add(TimeseriesMetadata.deserializeFrom(buffer));\n+      }\n+      int searchResult = binarySearchInTimeseriesMetadataList(timeseriesMetadataList,", "originalCommit": "4339c68bbbfb0886d3661a3308b90feb83f681b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk1MDYxOA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418950618", "bodyText": "How to define the threshold? So should we use 2 different methods for 2 situation (measurements number > threshold and < threshold)?", "author": "samperson1997", "createdAt": "2020-05-02T12:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDUyMDU5OQ==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r420520599", "bodyText": "yes\uff0c just calculate the search number is ok", "author": "qiaojialin", "createdAt": "2020-05-06T03:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNTk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNjE5Ng==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418936196", "bodyText": "I'm not clear about the MetadataIndexNodeType.INTERNAL_DEVICE, how can I see this parameter, the queried node type? Shouldn't this be Leaf_Device?", "author": "qiaojialin", "createdAt": "2020-05-02T09:28:33Z", "path": "tsfile/src/main/java/org/apache/iotdb/tsfile/read/TsFileSequenceReader.java", "diffHunk": "@@ -314,28 +311,76 @@ public TsFileMetadata readFileMetadata() throws IOException {\n   public TimeseriesMetadata readTimeseriesMetadata(Path path) throws IOException {\n     readFileMetadata();\n     MetadataIndexNode deviceMetadataIndexNode = tsFileMetaData.getMetadataIndex();\n-    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetaDataAndEndOffset(\n+    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetadataAndEndOffset(\n         deviceMetadataIndexNode, path.getDevice(), MetadataIndexNodeType.INTERNAL_DEVICE);\n     ByteBuffer buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n     while (!metadataIndexPair.left.getChildNodeType()\n         .equals(MetadataIndexNodeType.LEAF_MEASUREMENT)) {\n       MetadataIndexNode metadataIndexNode = MetadataIndexNode.deserializeFrom(buffer);\n-      metadataIndexPair = getMetaDataAndEndOffset(metadataIndexNode,\n+      metadataIndexPair = getMetadataAndEndOffset(metadataIndexNode,\n           path.getMeasurement(), MetadataIndexNodeType.INTERNAL_MEASUREMENT);\n     }\n     List<TimeseriesMetadata> timeseriesMetadataList = new ArrayList<>();\n     buffer = readData(metadataIndexPair.left.getOffset(), metadataIndexPair.right);\n     while (buffer.hasRemaining()) {\n       timeseriesMetadataList.add(TimeseriesMetadata.deserializeFrom(buffer));\n     }\n-    String[] measurementNameList = timeseriesMetadataList.stream()\n-        .map(TimeseriesMetadata::getMeasurementId).collect(Collectors.toList())\n-        .toArray(new String[timeseriesMetadataList.size()]);\n-\n     // return null if path does not exist in the TsFile\n-    int searchResult;\n-    return (searchResult = Arrays.binarySearch(measurementNameList, path.getMeasurement())) >= 0\n-        ? timeseriesMetadataList.get(searchResult) : null;\n+    int searchResult = binarySearchInTimeseriesMetadataList(timeseriesMetadataList,\n+        path.getMeasurement());\n+    return searchResult >= 0 ? timeseriesMetadataList.get(searchResult) : null;\n+  }\n+\n+  public List<TimeseriesMetadata> readTimeseriesMetadata(String device, Set<String> measurements)\n+      throws IOException {\n+    readFileMetadata();\n+    MetadataIndexNode deviceMetadataIndexNode = tsFileMetaData.getMetadataIndex();\n+    Pair<MetadataIndexEntry, Long> metadataIndexPair = getMetadataAndEndOffset(\n+        deviceMetadataIndexNode, device, MetadataIndexNodeType.INTERNAL_DEVICE);", "originalCommit": "4339c68bbbfb0886d3661a3308b90feb83f681b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk1ODk2Nw==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r418958967", "bodyText": "I could explain why I use INTERAL_DEVICE / INTERNAL_MEASUREMENT in method getMetadataAndEndOffset:\nThe statement which ends the recursion is: if (!childIndexEntry.left.getChildNodeType().equals(type)). For example, when searching for a device node, we look for LEAF_DEVICE, so we return when it is not INTERNAL_DEVICE. Likewise, when searching for a measurement node, we look for LEAF_MEASUREMENT, so we return when it is not INTERNAL_MEASUREMENT.\nWhy not judging by == LEAF_DEVICE or == LEAF_MEASUREMENT? Because this works for the situation when we are searching for device, but the index tree does not have the device level and only has the measurement level. Or we will never meet the LEAF_DEVICE.", "author": "samperson1997", "createdAt": "2020-05-02T13:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNjE5Ng=="}], "type": "inlineReview"}, {"oid": "c1eca42db3e3e23b3249abfb7c24292a3c9fe3c2", "url": "https://github.com/apache/iotdb/commit/c1eca42db3e3e23b3249abfb7c24292a3c9fe3c2", "message": "Fix code review", "committedDate": "2020-05-02T14:46:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0ODYyMA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r420548620", "bodyText": "A very small misspelling.\nFor query clause \"select s1, s2 form root -> For query clause \"select s1, s2 from root", "author": "HTHou", "createdAt": "2020-05-06T05:11:54Z", "path": "server/src/main/java/org/apache/iotdb/db/query/timegenerator/ServerTimeGenerator.java", "diffHunk": "@@ -33,8 +36,6 @@\n import org.apache.iotdb.tsfile.read.query.timegenerator.TimeGenerator;\n import org.apache.iotdb.tsfile.read.reader.IBatchReader;\n \n-import java.io.IOException;\n-\n /**\n  * A timestamp generator for query with filter. e.g. For query clause \"select s1, s2 form root where\n  * s3 < 0 and time > 100\", this class can iterate back to every timestamp of the query.", "originalCommit": "de83282bcf452589707c1c59c948414739dd93a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU1MTY4NA==", "url": "https://github.com/apache/iotdb/pull/1134#discussion_r420551684", "bodyText": "Thanks!  Good catch : )", "author": "samperson1997", "createdAt": "2020-05-06T05:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0ODYyMA=="}], "type": "inlineReview"}, {"oid": "05c1367777675b67738fb14f8eea0224b3c0099d", "url": "https://github.com/apache/iotdb/commit/05c1367777675b67738fb14f8eea0224b3c0099d", "message": "Fix PhysicalGenerator", "committedDate": "2020-05-06T08:09:45Z", "type": "commit"}, {"oid": "05c1367777675b67738fb14f8eea0224b3c0099d", "url": "https://github.com/apache/iotdb/commit/05c1367777675b67738fb14f8eea0224b3c0099d", "message": "Fix PhysicalGenerator", "committedDate": "2020-05-06T08:09:45Z", "type": "forcePushed"}, {"oid": "5f319cf38309fdd07b3bace77fb5b38ccc7cde4b", "url": "https://github.com/apache/iotdb/commit/5f319cf38309fdd07b3bace77fb5b38ccc7cde4b", "message": "Fix code review", "committedDate": "2020-05-06T08:13:12Z", "type": "commit"}, {"oid": "6384244de4c572c5043720d1a89fc2993eae2b47", "url": "https://github.com/apache/iotdb/commit/6384244de4c572c5043720d1a89fc2993eae2b47", "message": "Add filterPath in deviceToMeasurements", "committedDate": "2020-05-06T08:25:16Z", "type": "commit"}, {"oid": "549a645627c62c625f3de40ff444b921a2e972d0", "url": "https://github.com/apache/iotdb/commit/549a645627c62c625f3de40ff444b921a2e972d0", "message": "Fix tests", "committedDate": "2020-05-06T09:23:02Z", "type": "commit"}]}