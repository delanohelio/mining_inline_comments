{"pr_number": 1387, "pr_title": "[IOTDB-709] Create schema automatically", "pr_createdAt": "2020-06-18T09:02:13Z", "pr_url": "https://github.com/apache/iotdb/pull/1387", "timeline": [{"oid": "e4f19e52c55ba2171ed939ce2b40da13c5c299fa", "url": "https://github.com/apache/iotdb/commit/e4f19e52c55ba2171ed939ce2b40da13c5c299fa", "message": "auto schema creation", "committedDate": "2020-06-18T07:50:29Z", "type": "commit"}, {"oid": "267c814be2c8cd0457bbda9996a1b3c2b7515be8", "url": "https://github.com/apache/iotdb/commit/267c814be2c8cd0457bbda9996a1b3c2b7515be8", "message": "add comment", "committedDate": "2020-06-18T09:12:42Z", "type": "commit"}, {"oid": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "url": "https://github.com/apache/iotdb/commit/484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "message": "fix sonar", "committedDate": "2020-06-19T00:37:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMwOA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442594308", "bodyText": "This should still be debug.", "author": "jt2594838", "createdAt": "2020-06-19T02:12:20Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1520,12 +1534,31 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && IoTDBDescriptor.getInstance().getConfig()\n+          .isAutoCreateSchemaEnabled()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            throw new MetadataException(\"Failed to set storage group \" + storageGroupName);\n+          }\n+          return executeNonQuery(plan);\n+        } catch (MetadataException e) {\n+          logger.info(\"Failed to set storage group of device id {}\", deviceId);\n+        }\n+      }\n+      logger.error(\"{}: Cannot found storage groups for {}\", name, plan);\n       return StatusUtils.NO_STORAGE_GROUP;\n     }\n-    logger.debug(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);\n+    logger.error(\"{}: The data groups of {} are {}\", name, plan, planGroupMap);", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3OTA2NA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443679064", "bodyText": "Alright, I will revert.", "author": "Ring-k", "createdAt": "2020-06-22T16:22:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NDMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NjE5Nw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442596197", "bodyText": "I think we should add a specific status code like \"TSStatusCode.NO_TIMESERIES\", as this one is too abstract and we are not sure whether it is because of no metadata.", "author": "jt2594838", "createdAt": "2020-06-19T02:20:40Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1551,6 +1584,20 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n         subStatus = forwardPlan(entry.getKey(), entry.getValue());\n       }\n       if (subStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (entry.getKey() instanceof InsertPlan\n+            && subStatus.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwNjk0OA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444706948", "bodyText": "Thanks for your suggestion. The error code TIMESERIES_NOT_EXIST will be introduced.", "author": "Ring-k", "createdAt": "2020-06-24T07:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NjE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5ODM1Mg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442598352", "bodyText": "\"entry.getValue()\" is the data group you are going to send the plan to, and it may not be the group that should hold the metadata, so create timeseries plans should be forward to the group that should hold the metadata.", "author": "jt2594838", "createdAt": "2020-06-19T02:29:52Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1551,6 +1584,20 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n         subStatus = forwardPlan(entry.getKey(), entry.getValue());\n       }\n       if (subStatus.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (entry.getKey() instanceof InsertPlan\n+            && subStatus.getCode() == TSStatusCode.STORAGE_ENGINE_ERROR.getStatusCode()\n+            && IoTDBDescriptor.getInstance().getConfig().isAutoCreateSchemaEnabled()) {\n+          // try to create timeseries\n+          boolean hasCreate = autoCreateTimeseries((InsertPlan) entry.getKey(), entry.getValue());", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5OTcxOA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442599718", "bodyText": "getting -> get\nI would suggest print something like \"{} and other {} paths\", seriesList.get(0), seriesList.size() - 1 instead of \"{}\", serieseList, in case that the list is too long.\nAnd if you want to print a list in a log, you can just use the list as a parameter and there is no need to wrap it with \"Arrays.toString(seriesList.toArray(new String[0]))\".", "author": "jt2594838", "createdAt": "2020-06-19T02:35:30Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        Map<String, Boolean> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        for (Map.Entry<String, Boolean> entry : result.entrySet()) {\n+          if (!entry.getValue()) {\n+            unregistered.add(entry.getKey());\n+          }\n+        }\n+      } catch (TException | IOException e) {\n+        logger.error(\"{}: cannot getting unregistered series list {} from {}\", name,", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3OTM4Mw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443679383", "bodyText": "Thanks for your suggestion. I will change that.", "author": "Ring-k", "createdAt": "2020-06-22T16:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5OTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMDU3Ng==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442600576", "bodyText": "Please add a TODO here: \"TODO-Cluster: add executeNonQueryBatch()\", so we can cut the number of communications later.", "author": "jt2594838", "createdAt": "2020-06-19T02:39:11Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3Njc3Ng==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443676776", "bodyText": "Thanks for your reminding. I will add the comment.", "author": "Ring-k", "createdAt": "2020-06-22T16:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMTIwMg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442601202", "bodyText": "The schema may be auto-created concurrently, so I think the status code should be carefully checked, and if it says that the timeseries are already created, we should also return true.", "author": "jt2594838", "createdAt": "2020-06-19T02:41:43Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1569,6 +1616,70 @@ TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   * @param insertPlan, some of the timeseries in it are not created yet\n+   * @param partitionGroup\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan, PartitionGroup partitionGroup) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcxOTcwMg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444719702", "bodyText": "Thanks for your suggestion. An extra condition will be added in the if clause to make sure of it.", "author": "Ring-k", "createdAt": "2020-06-24T08:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMTIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwODkzMw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r442608933", "bodyText": "How about CreateTimeSeriesPlan? and other plans which can cause first check storage group exist or not ?", "author": "neuyilan", "createdAt": "2020-06-19T03:15:35Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1520,12 +1534,31 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && IoTDBDescriptor.getInstance().getConfig()", "originalCommit": "484bde76ead0c67ec16fcf7e6f4f6547699a9c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkzMzUxNA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443933514", "bodyText": "The problem you mentioned refers to CreateTimeseriesPlan, InsertTimeseriesPlan, DeleteTimeseriesPlan and DeleteTimeseriesPlan. However, if storage group is not set when executing DeleteTimeseriesPlan and DeleteTimeseriesPlan, logically there's no necessity for the storage group to be created. As in the method executeNonQuery in MetaGroupMember, these two plans will trigger processNonPartitionDataPlan and processNonPartitionMetaPlan respectively. CreateTimeseriesPlan and InsertTimeseriesPlan are \"partitioned plans\". As a result, if storage group is not set for these 2 types, auto creation will be performed.", "author": "Ring-k", "createdAt": "2020-06-23T02:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwODkzMw=="}], "type": "inlineReview"}, {"oid": "8ea91ee1062bb191e6047f873b71b10e22120f42", "url": "https://github.com/apache/iotdb/commit/8ea91ee1062bb191e6047f873b71b10e22120f42", "message": "fix conflict", "committedDate": "2020-06-22T15:20:51Z", "type": "commit"}, {"oid": "0bca1a88bb8bd36b47bed84e76f992509660e3ce", "url": "https://github.com/apache/iotdb/commit/0bca1a88bb8bd36b47bed84e76f992509660e3ce", "message": "error->debug", "committedDate": "2020-06-22T15:26:01Z", "type": "commit"}, {"oid": "da7a76aa10b7d559fc1919fad2bc0d0ad2f46872", "url": "https://github.com/apache/iotdb/commit/da7a76aa10b7d559fc1919fad2bc0d0ad2f46872", "message": "cluster properties", "committedDate": "2020-06-22T15:40:06Z", "type": "commit"}, {"oid": "283cf21e45755ec8e47bff25c36e5851ee7f7de5", "url": "https://github.com/apache/iotdb/commit/283cf21e45755ec8e47bff25c36e5851ee7f7de5", "message": "map -> list", "committedDate": "2020-06-22T15:51:44Z", "type": "commit"}, {"oid": "78c7c230a3af641ed6abaeb54cfc9e3a70e93757", "url": "https://github.com/apache/iotdb/commit/78c7c230a3af641ed6abaeb54cfc9e3a70e93757", "message": "measurement -> timeseries", "committedDate": "2020-06-22T16:30:35Z", "type": "commit"}, {"oid": "3c7b5079ddafe3212684986dcecdd877946e6029", "url": "https://github.com/apache/iotdb/commit/3c7b5079ddafe3212684986dcecdd877946e6029", "message": "change name", "committedDate": "2020-06-23T01:14:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjU3MA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443916570", "bodyText": "Please resolve the conflicts.", "author": "jt2594838", "createdAt": "2020-06-23T01:52:20Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1073,7 +1072,12 @@ public void pullTimeSeriesSchema(PullSchemaRequest request,\n \n   /**\n    * Create an IPointReader of \"path\" with \u201ctimeFilter\u201d and \"valueFilter\". A synchronization with\n+<<<<<<< HEAD\n+   * the leader will be performed first to preserve strong consistency. TODO-Cluster: also support\n+   * weak consistency\n+=======\n    * the leader will be performed according to consistency level\n+>>>>>>> origin/cluster_new", "originalCommit": "3c7b5079ddafe3212684986dcecdd877946e6029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY5NzgyNQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444697825", "bodyText": "Thanks for your reminding.", "author": "Ring-k", "createdAt": "2020-06-24T07:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjkwMg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443916902", "bodyText": "I think there is a method syncLeaderWithConsistencyCheck now, and that one should be used.", "author": "jt2594838", "createdAt": "2020-06-23T01:53:39Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1610,6 +1623,34 @@ public void getAggrResult(GetAggrResultRequest request,\n     resultHandler.onComplete(resultBuffers);\n   }\n \n+  /**\n+   * Check if the given measurements are registered or not\n+   * @param header\n+   * @param timeseriesList\n+   * @param resultHandler\n+   * @throws TException\n+   */\n+  @Override\n+  public void getUnregisteredTimeseries(Node header, List<String> timeseriesList,\n+      AsyncMethodCallback<List<String>> resultHandler) throws TException {\n+    if (!syncLeader()) {", "originalCommit": "3c7b5079ddafe3212684986dcecdd877946e6029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY5OTMzNg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444699336", "bodyText": "Thank you for your suggestion. The method syncLeaderWithConsistencyCheck will be used.", "author": "Ring-k", "createdAt": "2020-06-24T07:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNjkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNzM5NQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443917395", "bodyText": "Better add the seriesPath which triggers the exception into the message.", "author": "jt2594838", "createdAt": "2020-06-23T01:55:25Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -1610,6 +1623,34 @@ public void getAggrResult(GetAggrResultRequest request,\n     resultHandler.onComplete(resultBuffers);\n   }\n \n+  /**\n+   * Check if the given measurements are registered or not\n+   * @param header\n+   * @param timeseriesList\n+   * @param resultHandler\n+   * @throws TException\n+   */\n+  @Override\n+  public void getUnregisteredTimeseries(Node header, List<String> timeseriesList,\n+      AsyncMethodCallback<List<String>> resultHandler) throws TException {\n+    if (!syncLeader()) {\n+      resultHandler.onError(new LeaderUnknownException(getAllNodes()));\n+      return;\n+    }\n+    List<String> result = new ArrayList<>();\n+    for (String seriesPath : timeseriesList) {\n+      try {\n+        List<String> path = MManager.getInstance().getAllTimeseriesName(seriesPath);\n+        if (path.size() != 1) {\n+          throw new MetadataException(\"Size of the path is not 1.\");", "originalCommit": "3c7b5079ddafe3212684986dcecdd877946e6029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMDM3Nw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444700377", "bodyText": "Thanks for your suggestion. The information of the series will be included.", "author": "Ring-k", "createdAt": "2020-06-24T07:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNzM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxODQwOQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r443918409", "bodyText": "Report the status code and its message in the exception.", "author": "jt2594838", "createdAt": "2020-06-23T01:58:58Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,29 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+            throw new MetadataException(\"Failed to set storage group \" + storageGroupName);", "originalCommit": "3c7b5079ddafe3212684986dcecdd877946e6029", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMDkyMw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444700923", "bodyText": "Thanks for your suggestion. The status code will be included in the exception.", "author": "Ring-k", "createdAt": "2020-06-24T07:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxODQwOQ=="}], "type": "inlineReview"}, {"oid": "523f1063953f57b5ac537213cf38ca2b4a717593", "url": "https://github.com/apache/iotdb/commit/523f1063953f57b5ac537213cf38ca2b4a717593", "message": "route meta", "committedDate": "2020-06-23T02:36:31Z", "type": "commit"}, {"oid": "4687aaad5b3ce268d08401c7f94fcf3a345e7171", "url": "https://github.com/apache/iotdb/commit/4687aaad5b3ce268d08401c7f94fcf3a345e7171", "message": "fix conflict", "committedDate": "2020-06-23T03:00:46Z", "type": "commit"}, {"oid": "2493bcc51d702b6be99b84b0fae53f140469d61b", "url": "https://github.com/apache/iotdb/commit/2493bcc51d702b6be99b84b0fae53f140469d61b", "message": "exception report", "committedDate": "2020-06-23T03:15:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxNDkwMQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444014901", "bodyText": "It seems that this function forwardPlan will only be used in processNonPartitionedDataPlan, which will be called only when the type of plan is DeletePlan or DeleteTimeSeriesPlan, so maybe these new code in this function will never be called?", "author": "LebronAl", "createdAt": "2020-06-23T07:23:59Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1667,6 +1710,18 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n         status = forwardPlan(plan, partitionGroup);\n       }\n       if (status.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        if (plan instanceof InsertPlan", "originalCommit": "2493bcc51d702b6be99b84b0fae53f140469d61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMjY4OA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444702688", "bodyText": "You are right. Thanks for your reminding. These codes will be moved to TSStatus forwardPlan(Map<PhysicalPlan, PartitionGroup> planGroupMap, PhysicalPlan plan).", "author": "Ring-k", "createdAt": "2020-06-24T07:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxNDkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxODYzMg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444018632", "bodyText": "maybe you can use processNonPartitionedMetaPlan directly to avoid unnecessary judgement", "author": "LebronAl", "createdAt": "2020-06-23T07:31:08Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,38 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = executeNonQuery(setStorageGroupPlan);", "originalCommit": "2493bcc51d702b6be99b84b0fae53f140469d61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDcwMzEwNQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444703105", "bodyText": "Good idea. Thanks for your suggestion.", "author": "Ring-k", "createdAt": "2020-06-24T07:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxODYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyODU3NQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444028575", "bodyText": "maybe you can use processPartitionedPlan directly to avoid unnecessary judgement", "author": "LebronAl", "createdAt": "2020-06-23T07:48:22Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1739,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);", "originalCommit": "2493bcc51d702b6be99b84b0fae53f140469d61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTkyOA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929928", "bodyText": "You are right. Thanks.", "author": "Ring-k", "createdAt": "2020-06-24T14:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyODU3NQ=="}], "type": "inlineReview"}, {"oid": "362b4d00bd18798f3c83c566408735218429d34d", "url": "https://github.com/apache/iotdb/commit/362b4d00bd18798f3c83c566408735218429d34d", "message": "insertPlan backup", "committedDate": "2020-06-24T04:34:03Z", "type": "commit"}, {"oid": "d98656a9b1150d20ba4abf395a715298f6c28766", "url": "https://github.com/apache/iotdb/commit/d98656a9b1150d20ba4abf395a715298f6c28766", "message": "clone", "committedDate": "2020-06-24T04:54:42Z", "type": "commit"}, {"oid": "dfc17a5eefea399f14d423bad50cb8864927690a", "url": "https://github.com/apache/iotdb/commit/dfc17a5eefea399f14d423bad50cb8864927690a", "message": "new error code", "committedDate": "2020-06-24T07:21:18Z", "type": "commit"}, {"oid": "ec1a35174123572c5a7ef45ecad4086539d2b141", "url": "https://github.com/apache/iotdb/commit/ec1a35174123572c5a7ef45ecad4086539d2b141", "message": "executeNonQuery -> processNonPartitionedMetaPlan", "committedDate": "2020-06-24T07:41:18Z", "type": "commit"}, {"oid": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "url": "https://github.com/apache/iotdb/commit/c1a9f422e64004228e06f4b4adcdaeb46944fd87", "message": "check storage group already set", "committedDate": "2020-06-24T08:07:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MDc3Ng==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444790776", "bodyText": "It would be better to use e (preserve stack traces).", "author": "jt2594838", "createdAt": "2020-06-24T10:13:35Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1530,9 +1544,39 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n     } catch (MetadataException e) {\n       logger.error(\"Cannot route plan {}\", plan, e);\n     }\n-    // the storage group is not found locally, forward it to the leader\n+    // the storage group is not found locally\n     if (planGroupMap == null || planGroupMap.isEmpty()) {\n-      logger.debug(\"{}: Cannot found storage groups for {}\", name, plan);\n+      if (plan instanceof InsertPlan && ClusterDescriptor.getInstance().getConfig()\n+          .isEnableAutoCreateSchema()) {\n+        // try to set storage group\n+        String deviceId = ((InsertPlan) plan).getDeviceId();\n+        try {\n+          String storageGroupName = MetaUtils\n+              .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+                  .getConfig().getDefaultStorageGroupLevel());\n+          SetStorageGroupPlan setStorageGroupPlan = new SetStorageGroupPlan(\n+              new Path(storageGroupName));\n+          TSStatus setStorageGroupResult = processNonPartitionedMetaPlan(setStorageGroupPlan);\n+          if (setStorageGroupResult.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode() &&\n+          setStorageGroupResult.getCode() != TSStatusCode.PATH_ALREADY_EXIST_ERROR.getStatusCode()) {\n+            throw new MetadataException(\n+                String.format(\"Status Code: %d, failed to set storage group \",\n+                    setStorageGroupResult.getCode(), storageGroupName)\n+            );\n+          }\n+          // try to create timeseries\n+          boolean isAutoCreateTimeseriesSuccess = autoCreateTimeseries((InsertPlan)plan);\n+          if(!isAutoCreateTimeseriesSuccess){\n+            throw new MetadataException(\n+                String.format(\"Failed to create timeseries from InsertPlan automatically.\")\n+            );\n+          }\n+          return executeNonQuery(plan);\n+        } catch (MetadataException e) {\n+          logger.error(\"Failed to set storage group or create timeseries, because {}\", e.getMessage());", "originalCommit": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTcwMA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929700", "bodyText": "Thanks for your suggestion.", "author": "Ring-k", "createdAt": "2020-06-24T14:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MDc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MjcyOA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444792728", "bodyText": "Please refactor this message like the former one to avoid printing too many seriesPaths.", "author": "jt2594838", "createdAt": "2020-06-24T10:17:28Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1743,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   *\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        List<String> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        unregistered.addAll(result);\n+      } catch (TException | IOException e) {\n+        logger.error(\"{}: cannot getting unregistered {} and other {} paths from {}\", name,\n+            seriesList.get(0), seriesList.get(seriesList.size() - 1), node, e);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        logger.error(\"{}: getting unregistered series list {} is interrupted from {}\", name,\n+            Arrays.toString(seriesList.toArray(new String[0])), node, e);", "originalCommit": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTQ3Ng==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929476", "bodyText": "Thanks for your reminding.", "author": "Ring-k", "createdAt": "2020-06-24T14:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MjcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MzQ3NA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444793474", "bodyText": "I think you should break once a non-null result is returned, and I do not think using a Set is necessary.", "author": "jt2594838", "createdAt": "2020-06-24T10:18:56Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1684,6 +1743,77 @@ TSStatus forwardPlan(List<PartitionGroup> partitionGroups, PhysicalPlan plan) {\n     return status;\n   }\n \n+  /**\n+   * Create timeseries automatically\n+   *\n+   * @param insertPlan,    some of the timeseries in it are not created yet\n+   * @return true of all uncreated timeseries are created\n+   */\n+  boolean autoCreateTimeseries(InsertPlan insertPlan) {\n+    List<String> seriesList = new ArrayList<>();\n+    String deviceId = insertPlan.getDeviceId();\n+    String storageGroupName;\n+    try {\n+      storageGroupName = MetaUtils\n+          .getStorageGroupNameByLevel(deviceId, IoTDBDescriptor.getInstance()\n+              .getConfig().getDefaultStorageGroupLevel());\n+    } catch (MetadataException e) {\n+      logger.error(\"Failed to infer storage group from deviceId {}\", deviceId);\n+      return false;\n+    }\n+    for (String measurementId : insertPlan.getMeasurements()) {\n+      seriesList.add(\n+          new StringContainer(new String[]{deviceId, measurementId}, TsFileConstant.PATH_SEPARATOR)\n+              .toString());\n+    }\n+    PartitionGroup partitionGroup = partitionTable.route(storageGroupName, 0);\n+    List<String> unregisteredSeriesList = getUnregisteredSeriesList(seriesList, partitionGroup);\n+    for (String seriesPath : unregisteredSeriesList) {\n+      int index = seriesList.indexOf(seriesPath);\n+      TSDataType dataType = TypeInferenceUtils\n+          .getPredictedDataType(insertPlan.getValues()[index], true);\n+      TSEncoding encoding = getDefaultEncoding(dataType);\n+      CompressionType compressionType = TSFileDescriptor.getInstance().getConfig().getCompressor();\n+      CreateTimeSeriesPlan createTimeSeriesPlan = new CreateTimeSeriesPlan(new Path(seriesPath),\n+          dataType, encoding, compressionType, null, null, null, null);\n+      // TODO-Cluster: add executeNonQueryBatch()\n+      TSStatus result = executeNonQuery(createTimeSeriesPlan);\n+      if (result.getCode() != TSStatusCode.SUCCESS_STATUS.getStatusCode()) {\n+        logger.error(\"{} failed to execute create timeseries {}\", thisNode, seriesPath);\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+\n+  /**\n+   * To check which timeseries in the input list is unregistered\n+   *\n+   * @param seriesList\n+   * @param partitionGroup\n+   * @return\n+   */\n+  List<String> getUnregisteredSeriesList(List<String> seriesList, PartitionGroup partitionGroup) {\n+    Set<String> unregistered = new HashSet<>();\n+    for (Node node : partitionGroup) {\n+      try {\n+        DataClient client = getDataClient(node);\n+        List<String> result = SyncClientAdaptor\n+            .getUnregisteredMeasurements(client, partitionGroup.getHeader(), seriesList);\n+        unregistered.addAll(result);", "originalCommit": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyOTMyNA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444929324", "bodyText": "You are right. Finishing the loop is not necessary.", "author": "Ring-k", "createdAt": "2020-06-24T14:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5MzQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NTQxNw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444795417", "bodyText": "I suggest you just add a field of List in PathNotExistException, since concatenating a long string list is time-consuming.\nBesides, please perform a reformat.", "author": "jt2594838", "createdAt": "2020-06-24T10:22:29Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -914,8 +914,26 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       insertPlan.setSchemasAndTransferType(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n-        throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+        // check if all path not exist exceptions\n+        List<String> failedPaths = new ArrayList<>(insertPlan.getFailedMeasurements().keySet());\n+        List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n+        boolean isPathNotExistException = true;\n+        for(Exception e : exceptions){\n+          Exception curException = e;\n+          while(curException.getCause() != null){\n+            curException = (Exception) curException.getCause();\n+          }\n+          if(!(curException instanceof PathNotExistException)){\n+            isPathNotExistException = false;\n+            break;\n+          }\n+        }\n+        if(isPathNotExistException){\n+          throw new PathNotExistException(failedPaths.toString());", "originalCommit": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyODY0Nw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444928647", "bodyText": "An attribute is added in the PathNotExistExeption. Thanks for your suggestion.", "author": "Ring-k", "createdAt": "2020-06-24T14:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NTQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NjIwOQ==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444796209", "bodyText": "You may just define this as a Throwable so you may avoid the typecast.", "author": "jt2594838", "createdAt": "2020-06-24T10:23:57Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -914,8 +914,26 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       insertPlan.setSchemasAndTransferType(schemas);\n       StorageEngine.getInstance().insert(insertPlan);\n       if (insertPlan.getFailedMeasurements() != null) {\n-        throw new StorageEngineException(\n-            \"failed to insert points \" + insertPlan.getFailedMeasurements());\n+        // check if all path not exist exceptions\n+        List<String> failedPaths = new ArrayList<>(insertPlan.getFailedMeasurements().keySet());\n+        List<Exception> exceptions = new ArrayList<>(insertPlan.getFailedMeasurements().values());\n+        boolean isPathNotExistException = true;\n+        for(Exception e : exceptions){\n+          Exception curException = e;\n+          while(curException.getCause() != null){\n+            curException = (Exception) curException.getCause();", "originalCommit": "c1a9f422e64004228e06f4b4adcdaeb46944fd87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyODA4NA==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r444928084", "bodyText": "Thanks for yoru suggestion.", "author": "Ring-k", "createdAt": "2020-06-24T14:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc5NjIwOQ=="}], "type": "inlineReview"}, {"oid": "acc18960ae7318bcafa49271f90398eaeca11ff3", "url": "https://github.com/apache/iotdb/commit/acc18960ae7318bcafa49271f90398eaeca11ff3", "message": "exception message", "committedDate": "2020-06-24T14:34:53Z", "type": "commit"}, {"oid": "10f19941e1e5986189b6fa35c767e69615b8bfa2", "url": "https://github.com/apache/iotdb/commit/10f19941e1e5986189b6fa35c767e69615b8bfa2", "message": "fix conflict", "committedDate": "2020-06-24T14:37:31Z", "type": "commit"}, {"oid": "ef2fd52fa5ef78aea2de64070746ae3b674c711a", "url": "https://github.com/apache/iotdb/commit/ef2fd52fa5ef78aea2de64070746ae3b674c711a", "message": "test", "committedDate": "2020-06-28T07:13:15Z", "type": "commit"}, {"oid": "b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9", "url": "https://github.com/apache/iotdb/commit/b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9", "message": "fix sonar", "committedDate": "2020-06-28T07:26:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzkwMw==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r446623903", "bodyText": "Why change this?", "author": "jt2594838", "createdAt": "2020-06-28T09:07:30Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -1586,7 +1586,7 @@ private TSStatus processPartitionedPlan(PhysicalPlan plan) throws UnsupportedPla\n           }\n           return executeNonQuery(plan);\n         } catch (MetadataException e) {\n-          logger.error(\"Failed to set storage group or create timeseries, because {}\", e);\n+          logger.error(String.format(\"Failed to set storage group or create timeseries, because %s\", e));", "originalCommit": "b9ba68f83d885a4adde57ec6c9eb705ec49dd8d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyNjYyMg==", "url": "https://github.com/apache/iotdb/pull/1387#discussion_r446626622", "bodyText": "It was recognized as a bug according to rules of sonar, \"Fewer arguments provided (0) than placeholders specified (1) \".", "author": "Ring-k", "createdAt": "2020-06-28T09:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzkwMw=="}], "type": "inlineReview"}]}