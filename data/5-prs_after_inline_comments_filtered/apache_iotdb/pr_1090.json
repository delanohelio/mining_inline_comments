{"pr_number": 1090, "pr_title": "[IOTDB-604] support more robust remote reader", "pr_createdAt": "2020-04-23T11:31:37Z", "pr_url": "https://github.com/apache/iotdb/pull/1090", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5OTY2Mw==", "url": "https://github.com/apache/iotdb/pull/1090#discussion_r414399663", "bodyText": "It would be better to check the information or cause of the exception and see if it is what you have expected.", "author": "jt2594838", "createdAt": "2020-04-24T08:39:02Z", "path": "cluster/src/test/java/org/apache/iotdb/cluster/query/reader/RemoteSeriesReaderByTimestampTest.java", "diffHunk": "@@ -71,18 +74,93 @@ public void fetchSingleSeriesByTimestamp(Node header, long readerId, long time,\n             resultHandler.onComplete(ByteBuffer.wrap(byteArrayOutputStream.toByteArray()));\n           }).start();\n         }\n+\n+        @Override\n+        public void querySingleSeriesByTimestamp(SingleSeriesQueryRequest request, AsyncMethodCallback<Long> resultHandler) throws TException {\n+          resultHandler.onComplete(1L);\n+        }\n       };\n     }\n   };\n \n   @Test\n   public void test() throws IOException {\n-    RemoteSeriesReaderByTimestamp reader = new RemoteSeriesReaderByTimestamp(0,\n-        TestUtils.getNode(1), TestUtils.getNode(0),\n-        metaGroupMember);\n+    PartitionGroup group = new PartitionGroup();\n+    group.add(TestUtils.getNode(0));\n+    group.add(TestUtils.getNode(1));\n+    group.add(TestUtils.getNode(2));\n+\n+    SingleSeriesQueryRequest request = new SingleSeriesQueryRequest();\n+    RemoteQueryContext context = new RemoteQueryContext(1);\n+\n+    DataSourceInfo sourceInfo = new DataSourceInfo(group, TSDataType.DOUBLE,\n+      request, context, metaGroupMember, group);\n+    sourceInfo.nextDataClient(true, Long.MIN_VALUE);\n+\n+    RemoteSeriesReaderByTimestamp reader = new RemoteSeriesReaderByTimestamp(sourceInfo);\n+\n     for (int i = 0; i < 100; i++) {\n       assertEquals(i * 1.0, reader.getValueInTimestamp(i));\n     }\n     assertNull(reader.getValueInTimestamp(101));\n   }\n+\n+  @Test\n+  public void testFailedNode() throws IOException {\n+    batchData = TestUtils.genBatchData(TSDataType.DOUBLE, 0, 100);\n+    PartitionGroup group = new PartitionGroup();\n+    group.add(TestUtils.getNode(0));\n+    group.add(TestUtils.getNode(1));\n+    group.add(TestUtils.getNode(2));\n+\n+    SingleSeriesQueryRequest request = new SingleSeriesQueryRequest();\n+    RemoteQueryContext context = new RemoteQueryContext(1);\n+\n+    DataSourceInfo sourceInfo = new DataSourceInfo(group, TSDataType.DOUBLE,\n+      request, context, metaGroupMember, group);\n+    sourceInfo.nextDataClient(true, Long.MIN_VALUE);\n+    RemoteSeriesReaderByTimestamp reader = new RemoteSeriesReaderByTimestamp(sourceInfo);\n+\n+    // normal read\n+    assertEquals(TestUtils.getNode(0), sourceInfo.getCurrentNode());\n+    for (int i = 0; i < 50; i++) {\n+      assertEquals(i * 1.0, reader.getValueInTimestamp(i));\n+    }\n+\n+    // a bad client, change to another node\n+    DataClient badClient = new DataClient(null, null, TestUtils.getNode(0), null) {\n+      @Override\n+      public void fetchSingleSeriesByTimestamp(Node header, long readerId, long time,\n+                                               AsyncMethodCallback<ByteBuffer> resultHandler) throws TException {\n+        throw new TException(\"Good bye.\");\n+      }\n+\n+      @Override\n+      public void querySingleSeriesByTimestamp(SingleSeriesQueryRequest request, AsyncMethodCallback<Long> resultHandler) throws TException {\n+        resultHandler.onComplete(1L);\n+      }\n+    };\n+\n+    reader.setClientForTest(badClient);\n+    for (int i = 50; i < 80; i++) {\n+      assertEquals(i * 1.0, reader.getValueInTimestamp(i));\n+    }\n+    assertEquals(TestUtils.getNode(1), sourceInfo.getCurrentNode());\n+\n+    // a bad client, change to another node again\n+    reader.setClientForTest(badClient);\n+    for (int i = 80; i < 90; i++) {\n+      assertEquals(i * 1.0, reader.getValueInTimestamp(i));\n+    }\n+    assertEquals(TestUtils.getNode(2), sourceInfo.getCurrentNode());\n+\n+    // all node failed\n+    reader.setClientForTest(badClient);\n+    try {\n+      reader.getValueInTimestamp(90);\n+      fail();\n+    } catch (IOException e) {\n+      //ignore", "originalCommit": "8d8960c45fca8ef502e4d8c19ac630c0bc5a5dab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwNjgyNw==", "url": "https://github.com/apache/iotdb/pull/1090#discussion_r414406827", "bodyText": "Recording the failed nodes is one way, but there is a chance that previously down nodes will go back online when the query proceeds, or maybe there is just a temporary network partition that caused the node time out.\nFor example, the query reads data of [1, 100] from node1 and node2, when it is reading 10, node1 fails, but later when it is reading 90, node1 recovers but node2 fails and the current implementation will miss a chance to let the query go on. Such a situation is more common when the query is complicated and time-consuming.\nSo I advise that do not record the visited node, but every time nextDataClient is called, traverse nodes once from the current position and only return null when the traverse ends but no nodes respond.", "author": "jt2594838", "createdAt": "2020-04-24T08:49:53Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/query/reader/DataSourceInfo.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.query.reader;\n+\n+import org.apache.iotdb.cluster.client.DataClient;\n+import org.apache.iotdb.cluster.partition.PartitionGroup;\n+import org.apache.iotdb.cluster.query.RemoteQueryContext;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.rpc.thrift.SingleSeriesQueryRequest;\n+import org.apache.iotdb.cluster.server.handlers.caller.GenericHandler;\n+import org.apache.iotdb.cluster.server.member.MetaGroupMember;\n+import org.apache.iotdb.cluster.utils.SerializeUtils;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.filter.factory.FilterFactory;\n+import org.apache.iotdb.tsfile.read.filter.operator.AndFilter;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.apache.iotdb.cluster.server.RaftServer.connectionTimeoutInMS;\n+\n+/**\n+ * provide client which could connect to all nodes of the partitionGroup\n+ */\n+public class DataSourceInfo {\n+  private static final Logger logger = LoggerFactory.getLogger(DataSourceInfo.class);\n+\n+  private long readerId;\n+  private Node curSource;\n+  private PartitionGroup partitionGroup;\n+  private TSDataType dataType;\n+  private SingleSeriesQueryRequest request;\n+  private RemoteQueryContext context;\n+  private MetaGroupMember metaGroupMember;\n+  private List<Node> nodes;\n+  private DataClient curClient;\n+  private boolean isNoData;\n+\n+  private Map<Node, Boolean> visitedNodes;", "originalCommit": "8d8960c45fca8ef502e4d8c19ac630c0bc5a5dab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4Mjc5MQ==", "url": "https://github.com/apache/iotdb/pull/1090#discussion_r415182791", "bodyText": "Ok, I will change the code.", "author": "mychaow", "createdAt": "2020-04-26T01:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwNjgyNw=="}], "type": "inlineReview"}, {"oid": "caf05a10b46e0dc82680e68bbd0db681c0c37cc1", "url": "https://github.com/apache/iotdb/commit/caf05a10b46e0dc82680e68bbd0db681c0c37cc1", "message": "[IOTDB-604] support more robust remote reader", "committedDate": "2020-04-26T12:27:22Z", "type": "commit"}, {"oid": "caf05a10b46e0dc82680e68bbd0db681c0c37cc1", "url": "https://github.com/apache/iotdb/commit/caf05a10b46e0dc82680e68bbd0db681c0c37cc1", "message": "[IOTDB-604] support more robust remote reader", "committedDate": "2020-04-26T12:27:22Z", "type": "forcePushed"}]}