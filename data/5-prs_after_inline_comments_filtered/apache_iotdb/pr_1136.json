{"pr_number": 1136, "pr_title": "[IOTDB-632]Performance improve for Linear Fill", "pr_createdAt": "2020-04-30T10:27:28Z", "pr_url": "https://github.com/apache/iotdb/pull/1136", "timeline": [{"oid": "9b1bc492e0297142db46eb87f547fb72b601d41f", "url": "https://github.com/apache/iotdb/commit/9b1bc492e0297142db46eb87f547fb72b601d41f", "message": "reposition fill module", "committedDate": "2020-04-30T10:18:21Z", "type": "commit"}, {"oid": "3d591d7cd6af378b832ccf71c55eaa9f8b0bb96f", "url": "https://github.com/apache/iotdb/commit/3d591d7cd6af378b832ccf71c55eaa9f8b0bb96f", "message": "Re-implement linear fill", "committedDate": "2020-04-30T10:18:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk1NzU3OA==", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r417957578", "bodyText": "XXX?", "author": "qiaojialin", "createdAt": "2020-04-30T12:00:20Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/PreviousFill.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.query.executor.fill;\n+\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.qp.physical.crud.RawDataQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.tsfile.file.metadata.TimeseriesMetadata;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.filter.TimeFilter;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.filter.factory.FilterFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class PreviousFill extends IFill {\n+\n+  private Path seriesPath;\n+  private QueryContext context;\n+  private long beforeRange;\n+  private Set<String> allSensors;\n+  private Filter timeFilter;\n+\n+  private boolean untilLast;\n+\n+  public PreviousFill(TSDataType dataType, long queryTime, long beforeRange) {\n+    this(dataType, queryTime, beforeRange, false);\n+  }\n+\n+  public PreviousFill(long beforeRange) {\n+    this(beforeRange, false);\n+  }\n+\n+\n+  public PreviousFill(long beforeRange, boolean untilLast) {\n+    this.beforeRange = beforeRange;\n+    this.untilLast = untilLast;\n+  }\n+\n+\n+  public PreviousFill(TSDataType dataType, long queryTime, long beforeRange, boolean untilLast) {\n+    super(dataType, queryTime);\n+    this.beforeRange = beforeRange;\n+    this.untilLast = untilLast;\n+  }\n+\n+  @Override\n+  public IFill copy() {\n+    return new PreviousFill(dataType,  queryTime, beforeRange, untilLast);\n+  }\n+\n+  @Override\n+  void constructFilter() {\n+    Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n+        : TimeFilter.gtEq(queryTime - beforeRange);\n+    // time in [queryTime - beforeRange, queryTime]\n+    timeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+  }\n+\n+  public long getBeforeRange() {\n+    return beforeRange;\n+  }\n+\n+  @Override\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n+    this.dataType = dataType;\n+    this.context = context;\n+    this.queryTime = queryTime;\n+    this.allSensors = sensors;\n+    constructFilter();\n+  }\n+\n+  @Override\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, timeFilter);\n+    // update filter by TTL\n+    timeFilter = dataSource.updateFilterUsingTTL(timeFilter);\n+    LastPointReader lastReader = new LastPointReader(\n+        seriesPath, dataType, allSensors, context, dataSource, queryTime, timeFilter);\n+\n+    return lastReader.getTimeseriesLastPointXXX();", "originalCommit": "3d591d7cd6af378b832ccf71c55eaa9f8b0bb96f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2NjcwNQ==", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r418466705", "bodyText": "Oh, that's a temporary name forgot to correct.. Fixed", "author": "wshao08", "createdAt": "2020-05-01T08:50:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk1NzU3OA=="}], "type": "inlineReview"}, {"oid": "97228086f571be511ddfd07dc74c0abda0babab0", "url": "https://github.com/apache/iotdb/commit/97228086f571be511ddfd07dc74c0abda0babab0", "message": "rename to readLastPoint", "committedDate": "2020-05-01T08:49:27Z", "type": "commit"}, {"oid": "0ad2cbe3f95af040202cbb7f7312712517a01f49", "url": "https://github.com/apache/iotdb/commit/0ad2cbe3f95af040202cbb7f7312712517a01f49", "message": "Merge remote-tracking branch 'upstream/master' into linearFill_refactor", "committedDate": "2020-05-06T02:13:50Z", "type": "commit"}, {"oid": "413518a90b049219f757596a03ebb556ad96bf58", "url": "https://github.com/apache/iotdb/commit/413518a90b049219f757596a03ebb556ad96bf58", "message": "Update Linear Fill documentations", "committedDate": "2020-05-06T04:09:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwODM4Nw==", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r420608387", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private TimeValuePair calculatFirstPointAfterQueryTime()\n          \n          \n            \n              private TimeValuePair calculateFirstPointAfterQueryTime()", "author": "qiaojialin", "createdAt": "2020-05-06T07:57:49Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java", "diffHunk": "@@ -83,57 +92,80 @@ public IFill copy() {\n   }\n \n   @Override\n-  Filter constructFilter() {\n+  void constructFilter() {\n     Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n         : TimeFilter.gtEq(queryTime - beforeRange);\n     Filter upperBound = afterRange == -1 ? TimeFilter.ltEq(Long.MAX_VALUE)\n         : TimeFilter.ltEq(queryTime + afterRange);\n     // [queryTIme - beforeRange, queryTime + afterRange]\n-    return FilterFactory.and(lowerBound, upperBound);\n+    beforeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+    afterFilter = FilterFactory.and(TimeFilter.gtEq(queryTime), upperBound);\n   }\n \n   @Override\n-  public void configureFill(Path path, TSDataType dataType, long queryTime,\n-      Set<String> sensors, QueryContext context)\n-      throws StorageEngineException, QueryProcessException {\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n     this.dataType = dataType;\n     this.queryTime = queryTime;\n-    Filter timeFilter = constructFilter();\n-    dataReader = new SeriesRawDataBatchReader(path, sensors, dataType, context,\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter),\n-        timeFilter, null, null);\n+    this.context = context;\n+    this.allSensors = sensors;\n+    constructFilter();\n   }\n \n   @Override\n-  public TimeValuePair getFillResult() throws IOException, UnSupportedFillTypeException {\n-    TimeValuePair beforePair = null;\n-    TimeValuePair afterPair = null;\n-    while (batchData.hasCurrent() || dataReader.hasNextBatch()) {\n-      if (!batchData.hasCurrent() && dataReader.hasNextBatch()) {\n-        batchData = dataReader.nextBatch();\n-      }\n-      afterPair = new TimeValuePair(batchData.currentTime(), batchData.currentTsPrimitiveType());\n-      batchData.next();\n-      if (afterPair.getTimestamp() <= queryTime) {\n-        beforePair = afterPair;\n-      } else {\n-        break;\n-      }\n-    }\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, beforeFilter);\n+    LastPointReader lastReader =\n+        new LastPointReader(seriesPath, dataType, allSensors, context, dataSource, queryTime, beforeFilter);\n+\n+    TimeValuePair beforePair = lastReader.readLastPoint();\n+    TimeValuePair afterPair = calculatFirstPointAfterQueryTime();\n \n     // no before data or has data on the query timestamp\n-    if (beforePair == null || beforePair.getTimestamp() == queryTime) {\n+    if (beforePair.getValue() == null || beforePair.getTimestamp() == queryTime) {\n       return beforePair;\n     }\n \n     // on after data or after data is out of range\n-    if (afterPair.getTimestamp() < queryTime || (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n+    if (afterPair.getValue() == null || afterPair.getTimestamp() < queryTime ||\n+        (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n       return new TimeValuePair(queryTime, null);\n     }\n \n     return average(beforePair, afterPair);\n   }\n \n+  private TimeValuePair calculatFirstPointAfterQueryTime()", "originalCommit": "413518a90b049219f757596a03ebb556ad96bf58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYwOTMyMg==", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r420609322", "bodyText": "This is not needed, you could directly construct AggregateResult using dataType.", "author": "qiaojialin", "createdAt": "2020-05-06T07:59:38Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java", "diffHunk": "@@ -83,57 +92,80 @@ public IFill copy() {\n   }\n \n   @Override\n-  Filter constructFilter() {\n+  void constructFilter() {\n     Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n         : TimeFilter.gtEq(queryTime - beforeRange);\n     Filter upperBound = afterRange == -1 ? TimeFilter.ltEq(Long.MAX_VALUE)\n         : TimeFilter.ltEq(queryTime + afterRange);\n     // [queryTIme - beforeRange, queryTime + afterRange]\n-    return FilterFactory.and(lowerBound, upperBound);\n+    beforeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+    afterFilter = FilterFactory.and(TimeFilter.gtEq(queryTime), upperBound);\n   }\n \n   @Override\n-  public void configureFill(Path path, TSDataType dataType, long queryTime,\n-      Set<String> sensors, QueryContext context)\n-      throws StorageEngineException, QueryProcessException {\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n     this.dataType = dataType;\n     this.queryTime = queryTime;\n-    Filter timeFilter = constructFilter();\n-    dataReader = new SeriesRawDataBatchReader(path, sensors, dataType, context,\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter),\n-        timeFilter, null, null);\n+    this.context = context;\n+    this.allSensors = sensors;\n+    constructFilter();\n   }\n \n   @Override\n-  public TimeValuePair getFillResult() throws IOException, UnSupportedFillTypeException {\n-    TimeValuePair beforePair = null;\n-    TimeValuePair afterPair = null;\n-    while (batchData.hasCurrent() || dataReader.hasNextBatch()) {\n-      if (!batchData.hasCurrent() && dataReader.hasNextBatch()) {\n-        batchData = dataReader.nextBatch();\n-      }\n-      afterPair = new TimeValuePair(batchData.currentTime(), batchData.currentTsPrimitiveType());\n-      batchData.next();\n-      if (afterPair.getTimestamp() <= queryTime) {\n-        beforePair = afterPair;\n-      } else {\n-        break;\n-      }\n-    }\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, beforeFilter);\n+    LastPointReader lastReader =\n+        new LastPointReader(seriesPath, dataType, allSensors, context, dataSource, queryTime, beforeFilter);\n+\n+    TimeValuePair beforePair = lastReader.readLastPoint();\n+    TimeValuePair afterPair = calculatFirstPointAfterQueryTime();\n \n     // no before data or has data on the query timestamp\n-    if (beforePair == null || beforePair.getTimestamp() == queryTime) {\n+    if (beforePair.getValue() == null || beforePair.getTimestamp() == queryTime) {\n       return beforePair;\n     }\n \n     // on after data or after data is out of range\n-    if (afterPair.getTimestamp() < queryTime || (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n+    if (afterPair.getValue() == null || afterPair.getTimestamp() < queryTime ||\n+        (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n       return new TimeValuePair(queryTime, null);\n     }\n \n     return average(beforePair, afterPair);\n   }\n \n+  private TimeValuePair calculatFirstPointAfterQueryTime()\n+      throws IOException, StorageEngineException, QueryProcessException {\n+    TimeValuePair result = new TimeValuePair(0, null);\n+    List<String> aggregations = new ArrayList<>();\n+    aggregations.add(AggregationType.MIN_TIME.toString());\n+    aggregations.add(AggregationType.FIRST_VALUE.toString());", "originalCommit": "413518a90b049219f757596a03ebb556ad96bf58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYxMzkyNg==", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r420613926", "bodyText": "add the LinearFill in UserGuide, explain how we fill when beforePair or afterPair is null", "author": "qiaojialin", "createdAt": "2020-05-06T08:09:02Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java", "diffHunk": "@@ -83,57 +92,80 @@ public IFill copy() {\n   }\n \n   @Override\n-  Filter constructFilter() {\n+  void constructFilter() {\n     Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n         : TimeFilter.gtEq(queryTime - beforeRange);\n     Filter upperBound = afterRange == -1 ? TimeFilter.ltEq(Long.MAX_VALUE)\n         : TimeFilter.ltEq(queryTime + afterRange);\n     // [queryTIme - beforeRange, queryTime + afterRange]\n-    return FilterFactory.and(lowerBound, upperBound);\n+    beforeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+    afterFilter = FilterFactory.and(TimeFilter.gtEq(queryTime), upperBound);\n   }\n \n   @Override\n-  public void configureFill(Path path, TSDataType dataType, long queryTime,\n-      Set<String> sensors, QueryContext context)\n-      throws StorageEngineException, QueryProcessException {\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n     this.dataType = dataType;\n     this.queryTime = queryTime;\n-    Filter timeFilter = constructFilter();\n-    dataReader = new SeriesRawDataBatchReader(path, sensors, dataType, context,\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter),\n-        timeFilter, null, null);\n+    this.context = context;\n+    this.allSensors = sensors;\n+    constructFilter();\n   }\n \n   @Override\n-  public TimeValuePair getFillResult() throws IOException, UnSupportedFillTypeException {\n-    TimeValuePair beforePair = null;\n-    TimeValuePair afterPair = null;\n-    while (batchData.hasCurrent() || dataReader.hasNextBatch()) {\n-      if (!batchData.hasCurrent() && dataReader.hasNextBatch()) {\n-        batchData = dataReader.nextBatch();\n-      }\n-      afterPair = new TimeValuePair(batchData.currentTime(), batchData.currentTsPrimitiveType());\n-      batchData.next();\n-      if (afterPair.getTimestamp() <= queryTime) {\n-        beforePair = afterPair;\n-      } else {\n-        break;\n-      }\n-    }\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, beforeFilter);\n+    LastPointReader lastReader =\n+        new LastPointReader(seriesPath, dataType, allSensors, context, dataSource, queryTime, beforeFilter);\n+\n+    TimeValuePair beforePair = lastReader.readLastPoint();\n+    TimeValuePair afterPair = calculatFirstPointAfterQueryTime();\n \n     // no before data or has data on the query timestamp\n-    if (beforePair == null || beforePair.getTimestamp() == queryTime) {\n+    if (beforePair.getValue() == null || beforePair.getTimestamp() == queryTime) {", "originalCommit": "413518a90b049219f757596a03ebb556ad96bf58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "39fea6c8aa256bfa9dd136c9bc22f080fd9eb662", "url": "https://github.com/apache/iotdb/commit/39fea6c8aa256bfa9dd136c9bc22f080fd9eb662", "message": "Update user guide for linear fill", "committedDate": "2020-05-06T16:30:37Z", "type": "commit"}, {"oid": "d418649ea6ccd18ef3aa75d27484756da35e1d01", "url": "https://github.com/apache/iotdb/commit/d418649ea6ccd18ef3aa75d27484756da35e1d01", "message": "Delete unused imports", "committedDate": "2020-05-07T01:43:03Z", "type": "commit"}, {"oid": "227dbddcf434478a090397f108103824e602f22f", "url": "https://github.com/apache/iotdb/commit/227dbddcf434478a090397f108103824e602f22f", "message": "Fix a null before_pair bug and add tests", "committedDate": "2020-05-07T07:54:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxMzcwNg==", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r421313706", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                AggregateResult minTimeResult =\n          \n          \n            \n                    AggregateResultFactory.getAggrResultByName(AggregationType.MIN_TIME.toString(), dataType);\n          \n          \n            \n                AggregateResult minTimeResult = new MinTimeAggrResult(dataType);", "author": "qiaojialin", "createdAt": "2020-05-07T08:01:11Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java", "diffHunk": "@@ -83,57 +89,79 @@ public IFill copy() {\n   }\n \n   @Override\n-  Filter constructFilter() {\n+  void constructFilter() {\n     Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n         : TimeFilter.gtEq(queryTime - beforeRange);\n     Filter upperBound = afterRange == -1 ? TimeFilter.ltEq(Long.MAX_VALUE)\n         : TimeFilter.ltEq(queryTime + afterRange);\n     // [queryTIme - beforeRange, queryTime + afterRange]\n-    return FilterFactory.and(lowerBound, upperBound);\n+    beforeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+    afterFilter = FilterFactory.and(TimeFilter.gtEq(queryTime), upperBound);\n   }\n \n   @Override\n-  public void configureFill(Path path, TSDataType dataType, long queryTime,\n-      Set<String> sensors, QueryContext context)\n-      throws StorageEngineException, QueryProcessException {\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n     this.dataType = dataType;\n     this.queryTime = queryTime;\n-    Filter timeFilter = constructFilter();\n-    dataReader = new SeriesRawDataBatchReader(path, sensors, dataType, context,\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter),\n-        timeFilter, null, null);\n+    this.context = context;\n+    this.allSensors = sensors;\n+    constructFilter();\n   }\n \n   @Override\n-  public TimeValuePair getFillResult() throws IOException, UnSupportedFillTypeException {\n-    TimeValuePair beforePair = null;\n-    TimeValuePair afterPair = null;\n-    while (batchData.hasCurrent() || dataReader.hasNextBatch()) {\n-      if (!batchData.hasCurrent() && dataReader.hasNextBatch()) {\n-        batchData = dataReader.nextBatch();\n-      }\n-      afterPair = new TimeValuePair(batchData.currentTime(), batchData.currentTsPrimitiveType());\n-      batchData.next();\n-      if (afterPair.getTimestamp() <= queryTime) {\n-        beforePair = afterPair;\n-      } else {\n-        break;\n-      }\n-    }\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, beforeFilter);\n+    LastPointReader lastReader =\n+        new LastPointReader(seriesPath, dataType, allSensors, context, dataSource, queryTime, beforeFilter);\n+\n+    TimeValuePair beforePair = lastReader.readLastPoint();\n+    TimeValuePair afterPair = calculateFirstPointAfterQueryTime();\n \n     // no before data or has data on the query timestamp\n-    if (beforePair == null || beforePair.getTimestamp() == queryTime) {\n+    if (beforePair.getValue() == null || beforePair.getTimestamp() == queryTime) {\n+      beforePair.setTimestamp(queryTime);\n       return beforePair;\n     }\n \n     // on after data or after data is out of range\n-    if (afterPair.getTimestamp() < queryTime || (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n+    if (afterPair.getValue() == null || afterPair.getTimestamp() < queryTime ||\n+        (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n       return new TimeValuePair(queryTime, null);\n     }\n \n     return average(beforePair, afterPair);\n   }\n \n+  private TimeValuePair calculateFirstPointAfterQueryTime()\n+      throws IOException, StorageEngineException, QueryProcessException {\n+    TimeValuePair result = new TimeValuePair(0, null);\n+\n+    List<AggregateResult> aggregateResultList = new ArrayList<>();\n+    AggregateResult minTimeResult =\n+        AggregateResultFactory.getAggrResultByName(AggregationType.MIN_TIME.toString(), dataType);", "originalCommit": "227dbddcf434478a090397f108103824e602f22f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMxNDE0Ng==", "url": "https://github.com/apache/iotdb/pull/1136#discussion_r421314146", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                AggregateResult firstValueResult =\n          \n          \n            \n                    AggregateResultFactory.getAggrResultByName(\n          \n          \n            \n                        AggregationType.FIRST_VALUE.toString(), dataType);\n          \n          \n            \n                AggregateResult firstValueResult = new FirstValueAggrResult(dataType);", "author": "qiaojialin", "createdAt": "2020-05-07T08:01:54Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java", "diffHunk": "@@ -83,57 +89,79 @@ public IFill copy() {\n   }\n \n   @Override\n-  Filter constructFilter() {\n+  void constructFilter() {\n     Filter lowerBound = beforeRange == -1 ? TimeFilter.gtEq(Long.MIN_VALUE)\n         : TimeFilter.gtEq(queryTime - beforeRange);\n     Filter upperBound = afterRange == -1 ? TimeFilter.ltEq(Long.MAX_VALUE)\n         : TimeFilter.ltEq(queryTime + afterRange);\n     // [queryTIme - beforeRange, queryTime + afterRange]\n-    return FilterFactory.and(lowerBound, upperBound);\n+    beforeFilter = FilterFactory.and(lowerBound, TimeFilter.ltEq(queryTime));\n+    afterFilter = FilterFactory.and(TimeFilter.gtEq(queryTime), upperBound);\n   }\n \n   @Override\n-  public void configureFill(Path path, TSDataType dataType, long queryTime,\n-      Set<String> sensors, QueryContext context)\n-      throws StorageEngineException, QueryProcessException {\n+  public void configureFill(\n+      Path path, TSDataType dataType, long queryTime, Set<String> sensors, QueryContext context) {\n+    this.seriesPath = path;\n     this.dataType = dataType;\n     this.queryTime = queryTime;\n-    Filter timeFilter = constructFilter();\n-    dataReader = new SeriesRawDataBatchReader(path, sensors, dataType, context,\n-        QueryResourceManager.getInstance().getQueryDataSource(path, context, timeFilter),\n-        timeFilter, null, null);\n+    this.context = context;\n+    this.allSensors = sensors;\n+    constructFilter();\n   }\n \n   @Override\n-  public TimeValuePair getFillResult() throws IOException, UnSupportedFillTypeException {\n-    TimeValuePair beforePair = null;\n-    TimeValuePair afterPair = null;\n-    while (batchData.hasCurrent() || dataReader.hasNextBatch()) {\n-      if (!batchData.hasCurrent() && dataReader.hasNextBatch()) {\n-        batchData = dataReader.nextBatch();\n-      }\n-      afterPair = new TimeValuePair(batchData.currentTime(), batchData.currentTsPrimitiveType());\n-      batchData.next();\n-      if (afterPair.getTimestamp() <= queryTime) {\n-        beforePair = afterPair;\n-      } else {\n-        break;\n-      }\n-    }\n+  public TimeValuePair getFillResult()\n+      throws IOException, QueryProcessException, StorageEngineException {\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, beforeFilter);\n+    LastPointReader lastReader =\n+        new LastPointReader(seriesPath, dataType, allSensors, context, dataSource, queryTime, beforeFilter);\n+\n+    TimeValuePair beforePair = lastReader.readLastPoint();\n+    TimeValuePair afterPair = calculateFirstPointAfterQueryTime();\n \n     // no before data or has data on the query timestamp\n-    if (beforePair == null || beforePair.getTimestamp() == queryTime) {\n+    if (beforePair.getValue() == null || beforePair.getTimestamp() == queryTime) {\n+      beforePair.setTimestamp(queryTime);\n       return beforePair;\n     }\n \n     // on after data or after data is out of range\n-    if (afterPair.getTimestamp() < queryTime || (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n+    if (afterPair.getValue() == null || afterPair.getTimestamp() < queryTime ||\n+        (afterRange != -1 && afterPair.getTimestamp() > queryTime + afterRange)) {\n       return new TimeValuePair(queryTime, null);\n     }\n \n     return average(beforePair, afterPair);\n   }\n \n+  private TimeValuePair calculateFirstPointAfterQueryTime()\n+      throws IOException, StorageEngineException, QueryProcessException {\n+    TimeValuePair result = new TimeValuePair(0, null);\n+\n+    List<AggregateResult> aggregateResultList = new ArrayList<>();\n+    AggregateResult minTimeResult =\n+        AggregateResultFactory.getAggrResultByName(AggregationType.MIN_TIME.toString(), dataType);\n+    AggregateResult firstValueResult =\n+        AggregateResultFactory.getAggrResultByName(\n+            AggregationType.FIRST_VALUE.toString(), dataType);", "originalCommit": "227dbddcf434478a090397f108103824e602f22f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e21bf1c2b646a3672995fcd86e603e4afda21e6a", "url": "https://github.com/apache/iotdb/commit/e21bf1c2b646a3672995fcd86e603e4afda21e6a", "message": "Update server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java\n\nCo-authored-by: Jialin Qiao <qjl16@mails.tsinghua.edu.cn>", "committedDate": "2020-05-07T08:06:41Z", "type": "commit"}, {"oid": "ced502c9acfc0aa2519df0a5a3922030dd707e93", "url": "https://github.com/apache/iotdb/commit/ced502c9acfc0aa2519df0a5a3922030dd707e93", "message": "Update server/src/main/java/org/apache/iotdb/db/query/executor/fill/LinearFill.java\n\nCo-authored-by: Jialin Qiao <qjl16@mails.tsinghua.edu.cn>", "committedDate": "2020-05-07T08:07:02Z", "type": "commit"}, {"oid": "e7f6af0874adf24ad4562daa89f49d3817d2b2d7", "url": "https://github.com/apache/iotdb/commit/e7f6af0874adf24ad4562daa89f49d3817d2b2d7", "message": "Add missing imports", "committedDate": "2020-05-07T08:46:35Z", "type": "commit"}]}