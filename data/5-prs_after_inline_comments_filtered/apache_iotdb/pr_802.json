{"pr_number": 802, "pr_title": "Cached chunk", "pr_createdAt": "2020-02-14T04:31:59Z", "pr_url": "https://github.com/apache/iotdb/pull/802", "timeline": [{"oid": "a74ce816788ae1424e4aee18a69f5d77d3c1da06", "url": "https://github.com/apache/iotdb/commit/a74ce816788ae1424e4aee18a69f5d77d3c1da06", "message": "add cached chunk in server", "committedDate": "2020-02-14T03:24:41Z", "type": "commit"}, {"oid": "be7abc72483959b2bb52995105d6f3988c5f6415", "url": "https://github.com/apache/iotdb/commit/be7abc72483959b2bb52995105d6f3988c5f6415", "message": "Merge branch 'new_series_reader' into CachedChunk", "committedDate": "2020-02-14T03:25:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MTU1OA==", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379261558", "bodyText": "I suggest using lock.readLock to replace the readLock field", "author": "qiaojialin", "createdAt": "2020-02-14T05:56:03Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.cache;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * This class is used to cache <code>Chunk</code> of <code>ChunkMetaData</code> in IoTDB. The caching\n+ * strategy is LRU.\n+ */\n+public class ChunkCache {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(ChunkCache.class);\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final long MEMORY_THRESHOLD_IN_CHUNK_CACHE = config.getAllocateMemoryForChunkCache();\n+  private static boolean cacheEnable = config.isMetaDataCacheEnable();\n+\n+  private final LRULinkedHashMap<ChunkMetaData, Chunk> lruCache;\n+\n+  private AtomicLong cacheHitNum = new AtomicLong();\n+  private AtomicLong cacheRequestNum = new AtomicLong();\n+\n+  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n+  private final Lock readLock = lock.readLock();\n+  private final Lock writeLock = lock.writeLock();", "originalCommit": "be7abc72483959b2bb52995105d6f3988c5f6415", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MjU5Nw==", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379262597", "bodyText": "why not return the chunk got from cache?", "author": "qiaojialin", "createdAt": "2020-02-14T06:00:45Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.cache;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * This class is used to cache <code>Chunk</code> of <code>ChunkMetaData</code> in IoTDB. The caching\n+ * strategy is LRU.\n+ */\n+public class ChunkCache {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(ChunkCache.class);\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final long MEMORY_THRESHOLD_IN_CHUNK_CACHE = config.getAllocateMemoryForChunkCache();\n+  private static boolean cacheEnable = config.isMetaDataCacheEnable();\n+\n+  private final LRULinkedHashMap<ChunkMetaData, Chunk> lruCache;\n+\n+  private AtomicLong cacheHitNum = new AtomicLong();\n+  private AtomicLong cacheRequestNum = new AtomicLong();\n+\n+  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n+  private final Lock readLock = lock.readLock();\n+  private final Lock writeLock = lock.writeLock();\n+\n+\n+  private ChunkCache() {\n+    lruCache = new LRULinkedHashMap<ChunkMetaData, Chunk>(MEMORY_THRESHOLD_IN_CHUNK_CACHE, true) {\n+      @Override\n+      protected long calEntrySize(ChunkMetaData key, Chunk value) {\n+        return RamUsageEstimator.sizeOf(value) + RamUsageEstimator.sizeOf(value);\n+      }\n+    };\n+  }\n+\n+  public static ChunkCache getInstance() {\n+    return ChunkCacheHolder.INSTANCE;\n+  }\n+\n+  public Chunk get(ChunkMetaData chunkMetaData, TsFileSequenceReader reader) throws IOException {\n+    if (!cacheEnable) {\n+      Chunk chunk = reader.readMemChunk(chunkMetaData);\n+      return new Chunk(chunk.getHeader(), chunk.getData().duplicate(), chunk.getDeletedAt(), reader.getEndianType());\n+    }\n+\n+    cacheRequestNum.incrementAndGet();\n+\n+    try {\n+      readLock.lock();\n+      if (lruCache.containsKey(chunkMetaData)) {\n+        cacheHitNum.incrementAndGet();\n+        printCacheLog(true);\n+        Chunk chunk = lruCache.get(chunkMetaData);\n+        return new Chunk(chunk.getHeader(), chunk.getData().duplicate(), chunk.getDeletedAt(), reader.getEndianType());", "originalCommit": "be7abc72483959b2bb52995105d6f3988c5f6415", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI3NjMyMQ==", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379276321", "bodyText": "The chunk has a field byte buffer, it should be reused.", "author": "JackieTien97", "createdAt": "2020-02-14T07:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MjU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0NjM4MA==", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379346380", "bodyText": "why this return valueSize * 2 ?", "author": "liutaohua", "createdAt": "2020-02-14T10:06:54Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.cache;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * This class is used to cache <code>Chunk</code> of <code>ChunkMetaData</code> in IoTDB. The caching\n+ * strategy is LRU.\n+ */\n+public class ChunkCache {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(ChunkCache.class);\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final long MEMORY_THRESHOLD_IN_CHUNK_CACHE = config.getAllocateMemoryForChunkCache();\n+  private static boolean cacheEnable = config.isMetaDataCacheEnable();\n+\n+  private final LRULinkedHashMap<ChunkMetaData, Chunk> lruCache;\n+\n+  private AtomicLong cacheHitNum = new AtomicLong();\n+  private AtomicLong cacheRequestNum = new AtomicLong();\n+\n+  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n+  private final Lock readLock = lock.readLock();\n+  private final Lock writeLock = lock.writeLock();\n+\n+\n+  private ChunkCache() {\n+    lruCache = new LRULinkedHashMap<ChunkMetaData, Chunk>(MEMORY_THRESHOLD_IN_CHUNK_CACHE, true) {\n+      @Override\n+      protected long calEntrySize(ChunkMetaData key, Chunk value) {\n+        return RamUsageEstimator.sizeOf(value) + RamUsageEstimator.sizeOf(value);", "originalCommit": "be7abc72483959b2bb52995105d6f3988c5f6415", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4NTQ1OA==", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379385458", "bodyText": "it's a typo, should be RamUsageEstimator.sizeOf(key) + RamUsageEstimator.sizeOf(value);\nFixed", "author": "JackieTien97", "createdAt": "2020-02-14T11:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0NjM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM0ODYwMg==", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379348602", "bodyText": "Why not down the lock to readLock directly", "author": "liutaohua", "createdAt": "2020-02-14T10:11:26Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/cache/ChunkCache.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.engine.cache;\n+\n+import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBDescriptor;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * This class is used to cache <code>Chunk</code> of <code>ChunkMetaData</code> in IoTDB. The caching\n+ * strategy is LRU.\n+ */\n+public class ChunkCache {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(ChunkCache.class);\n+  private static final IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static final long MEMORY_THRESHOLD_IN_CHUNK_CACHE = config.getAllocateMemoryForChunkCache();\n+  private static boolean cacheEnable = config.isMetaDataCacheEnable();\n+\n+  private final LRULinkedHashMap<ChunkMetaData, Chunk> lruCache;\n+\n+  private AtomicLong cacheHitNum = new AtomicLong();\n+  private AtomicLong cacheRequestNum = new AtomicLong();\n+\n+  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n+  private final Lock readLock = lock.readLock();\n+  private final Lock writeLock = lock.writeLock();\n+\n+\n+  private ChunkCache() {\n+    lruCache = new LRULinkedHashMap<ChunkMetaData, Chunk>(MEMORY_THRESHOLD_IN_CHUNK_CACHE, true) {\n+      @Override\n+      protected long calEntrySize(ChunkMetaData key, Chunk value) {\n+        return RamUsageEstimator.sizeOf(value) + RamUsageEstimator.sizeOf(value);\n+      }\n+    };\n+  }\n+\n+  public static ChunkCache getInstance() {\n+    return ChunkCacheHolder.INSTANCE;\n+  }\n+\n+  public Chunk get(ChunkMetaData chunkMetaData, TsFileSequenceReader reader) throws IOException {\n+    if (!cacheEnable) {\n+      Chunk chunk = reader.readMemChunk(chunkMetaData);\n+      return new Chunk(chunk.getHeader(), chunk.getData().duplicate(), chunk.getDeletedAt(), reader.getEndianType());\n+    }\n+\n+    cacheRequestNum.incrementAndGet();\n+\n+    try {\n+      readLock.lock();\n+      if (lruCache.containsKey(chunkMetaData)) {\n+        cacheHitNum.incrementAndGet();\n+        printCacheLog(true);\n+        Chunk chunk = lruCache.get(chunkMetaData);\n+        return new Chunk(chunk.getHeader(), chunk.getData().duplicate(), chunk.getDeletedAt(), reader.getEndianType());\n+      }\n+    } finally {\n+      readLock.unlock();\n+    }\n+\n+    writeLock.lock();\n+    if (lruCache.containsKey(chunkMetaData)) {\n+      writeLock.unlock();", "originalCommit": "be7abc72483959b2bb52995105d6f3988c5f6415", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM1MDg1OA==", "url": "https://github.com/apache/iotdb/pull/802#discussion_r379350858", "bodyText": "i think , this method can delete for  interface, neither memChunk nor diskChunk don't need to clear ,and the cache is  LRU", "author": "liutaohua", "createdAt": "2020-02-14T10:15:56Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/chunk/DiskChunkLoader.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.reader.chunk;\n+\n+import org.apache.iotdb.db.engine.cache.ChunkCache;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Chunk;\n+import org.apache.iotdb.tsfile.read.controller.IChunkLoader;\n+\n+import java.io.IOException;\n+\n+public class DiskChunkLoader implements IChunkLoader {\n+\n+  private final TsFileSequenceReader reader;\n+\n+  public DiskChunkLoader(TsFileSequenceReader reader) {\n+    this.reader = reader;\n+  }\n+\n+  @Override\n+  public Chunk getChunk(ChunkMetaData chunkMetaData) throws IOException {\n+    return ChunkCache.getInstance().get(chunkMetaData, reader);\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    reader.close();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    // no cache need clear", "originalCommit": "be7abc72483959b2bb52995105d6f3988c5f6415", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4305fdeef6b059d6a427ec9292013c4547f34928", "url": "https://github.com/apache/iotdb/commit/4305fdeef6b059d6a427ec9292013c4547f34928", "message": "update field name and lock sequence", "committedDate": "2020-02-14T11:50:12Z", "type": "commit"}, {"oid": "48157a5465eec0745fe63b562c0fd4434f9fdecf", "url": "https://github.com/apache/iotdb/commit/48157a5465eec0745fe63b562c0fd4434f9fdecf", "message": "delete confusing two fields", "committedDate": "2020-02-16T02:19:24Z", "type": "commit"}, {"oid": "879f14277b92e0e9863902fa924f11f3b3048417", "url": "https://github.com/apache/iotdb/commit/879f14277b92e0e9863902fa924f11f3b3048417", "message": "change to no final", "committedDate": "2020-02-17T03:45:14Z", "type": "commit"}, {"oid": "bbf28dce3c520ed88006d0d818fec399d7f042e0", "url": "https://github.com/apache/iotdb/commit/bbf28dce3c520ed88006d0d818fec399d7f042e0", "message": "solve jdk11 module problem", "committedDate": "2020-02-17T04:29:25Z", "type": "commit"}]}