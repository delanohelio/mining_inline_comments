{"pr_number": 1725, "pr_title": "[IOTDB-23] Restart state monitor module", "pr_createdAt": "2020-09-11T12:19:56Z", "pr_url": "https://github.com/apache/iotdb/pull/1725", "timeline": [{"oid": "1fb48680c801346d1d7dd19c7b31bb93ff3634f6", "url": "https://github.com/apache/iotdb/commit/1fb48680c801346d1d7dd19c7b31bb93ff3634f6", "message": "delete something old,next step: insert", "committedDate": "2020-08-30T12:59:35Z", "type": "commit"}, {"oid": "cd2793f6fb91e1d96c24e237f122c93a2f19f0f6", "url": "https://github.com/apache/iotdb/commit/cd2793f6fb91e1d96c24e237f122c93a2f19f0f6", "message": "Add update method in flush()", "committedDate": "2020-08-31T09:18:19Z", "type": "commit"}, {"oid": "e5b6635dc02bf221f09002455f5af8f67ec2b9dc", "url": "https://github.com/apache/iotdb/commit/e5b6635dc02bf221f09002455f5af8f67ec2b9dc", "message": "Merge branch 'state_monitor' of github.com:Alima777/incubator-iotdb into state_monitor", "committedDate": "2020-09-01T05:58:47Z", "type": "commit"}, {"oid": "35fa0dd8a2fa4db8847f209f0f9e90d807b24f4a", "url": "https://github.com/apache/iotdb/commit/35fa0dd8a2fa4db8847f209f0f9e90d807b24f4a", "message": "implement monitorSeriesMap and cachedValueMap", "committedDate": "2020-09-03T13:00:26Z", "type": "commit"}, {"oid": "12bc8e0cebd28d9978a25cedea8a558efaac7c89", "url": "https://github.com/apache/iotdb/commit/12bc8e0cebd28d9978a25cedea8a558efaac7c89", "message": "Merge branch 'state_monitor' of github.com:Alima777/incubator-iotdb into state_monitor", "committedDate": "2020-09-03T13:01:45Z", "type": "commit"}, {"oid": "09195967a9d6967ced96940bed81339c2aebfbe2", "url": "https://github.com/apache/iotdb/commit/09195967a9d6967ced96940bed81339c2aebfbe2", "message": "update StatMonitorMBean", "committedDate": "2020-09-03T13:58:13Z", "type": "commit"}, {"oid": "7d415597ca7e656d81e9b561b4bbbf1afb588c95", "url": "https://github.com/apache/iotdb/commit/7d415597ca7e656d81e9b561b4bbbf1afb588c95", "message": "implement recovery", "committedDate": "2020-09-04T04:05:07Z", "type": "commit"}, {"oid": "facee9d8395e7e8a5018bb6977c094eb0f5c9b4d", "url": "https://github.com/apache/iotdb/commit/facee9d8395e7e8a5018bb6977c094eb0f5c9b4d", "message": "Merge branch 'state_monitor' of github.com:Alima777/incubator-iotdb into state_monitor", "committedDate": "2020-09-04T06:12:57Z", "type": "commit"}, {"oid": "7687584f97689e1b0315fc1f1dc38cefcbe99989", "url": "https://github.com/apache/iotdb/commit/7687584f97689e1b0315fc1f1dc38cefcbe99989", "message": "add license and some metrics", "committedDate": "2020-09-04T07:11:05Z", "type": "commit"}, {"oid": "0b808331276016760b1ee50e3cf3446e52cdbeac", "url": "https://github.com/apache/iotdb/commit/0b808331276016760b1ee50e3cf3446e52cdbeac", "message": "fix Url bug", "committedDate": "2020-09-07T08:14:42Z", "type": "commit"}, {"oid": "575a0b1f1535d7b4dc0adda7b28e33a71ece89f0", "url": "https://github.com/apache/iotdb/commit/575a0b1f1535d7b4dc0adda7b28e33a71ece89f0", "message": "Merge branch 'fixUrlBug' into state_monitor", "committedDate": "2020-09-07T08:19:14Z", "type": "commit"}, {"oid": "3afc748f0e5fcff2f28928ff75978fb9203085a7", "url": "https://github.com/apache/iotdb/commit/3afc748f0e5fcff2f28928ff75978fb9203085a7", "message": "fix recovery bug", "committedDate": "2020-09-07T08:44:02Z", "type": "commit"}, {"oid": "d5976ad97cdc4855b28117b86c9900f8b84739e6", "url": "https://github.com/apache/iotdb/commit/d5976ad97cdc4855b28117b86c9900f8b84739e6", "message": "add mbean method:", "committedDate": "2020-09-11T10:59:29Z", "type": "commit"}, {"oid": "640a2a02fe7336e47ebf7de53ac49f5e4f4eab73", "url": "https://github.com/apache/iotdb/commit/640a2a02fe7336e47ebf7de53ac49f5e4f4eab73", "message": "update user guide doc", "committedDate": "2020-09-11T12:13:26Z", "type": "commit"}, {"oid": "54e489bb083ba2655741ffc4fa40d2623745f605", "url": "https://github.com/apache/iotdb/commit/54e489bb083ba2655741ffc4fa40d2623745f605", "message": "fix conflict", "committedDate": "2020-09-11T12:22:03Z", "type": "commit"}, {"oid": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "url": "https://github.com/apache/iotdb/commit/43dfbef093e05d77704d5e65672294b28f8e5bdd", "message": "fix ci bug", "committedDate": "2020-09-14T02:10:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3ODgxOQ==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493178819", "bodyText": "put this out of the for-loop.\nAnd, set the size of the list as 3.", "author": "jixuan1989", "createdAt": "2020-09-23T03:42:51Z", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI2MDg1Nw==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493260857", "bodyText": "Fixed.", "author": "Alima777", "createdAt": "2020-09-23T07:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3ODgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3ODkzNg==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493178936", "bodyText": "why adding \"?\nWhat will happen if a user storage group name is global", "author": "jixuan1989", "createdAt": "2020-09-23T03:43:28Z", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI0MDQ4OA==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493240488", "bodyText": "storageGroupName contains the seperator \".\", we add \" to see it as the whole.\nglobal is surrounded by \" too to keep consistence, and otherwise select * from root.stats.global will throw an exception as global is recognized as a keyword.", "author": "Alima777", "createdAt": "2020-09-23T06:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3ODkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTE2MA==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493179160", "bodyText": "claim the size of the arrayList size as 1", "author": "jixuan1989", "createdAt": "2020-09-23T03:44:24Z", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI2MDk0Mw==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493260943", "bodyText": "Fixed.", "author": "Alima777", "createdAt": "2020-09-23T07:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTU2OA==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493179568", "bodyText": "are you sure RLE is ok?\nI think there are no two points having the same value... ( monotone increasing)", "author": "jixuan1989", "createdAt": "2020-09-23T03:46:04Z", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI2MDU1OQ==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493260559", "bodyText": "I reused the code before... I think TS_2DIFF is better.", "author": "Alima777", "createdAt": "2020-09-23T07:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTkwMw==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493179903", "bodyText": "can we give a null rather than Collections.emptyMap() ?", "author": "jixuan1989", "createdAt": "2020-09-23T03:47:29Z", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI1NzIzOA==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493257238", "bodyText": "Yes\uff01", "author": "Alima777", "createdAt": "2020-09-23T07:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIxOTMwNg==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493219306", "bodyText": "\uff1f\uff1f if so, why use for?\nand how about REQ_FAIL", "author": "jixuan1989", "createdAt": "2020-09-23T06:09:07Z", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI0NDE1NQ==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493244155", "bodyText": "I designed it for ... extensibility :D. Maybe we will add more metrics later...  I will fix it~\nREQ_FAIL is not calculated with the successful situation.", "author": "Alima777", "createdAt": "2020-09-23T07:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIxOTMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMTM4Ng==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493221386", "bodyText": "saveStatValue()?", "author": "jixuan1989", "createdAt": "2020-09-23T06:14:41Z", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL\n+      switch (i) {\n+        case 0:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + successPointsNum);\n+          break;\n+        case 1:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + 1);\n+          break;\n+      }\n+    }\n   }\n \n-  public long getNumBackLoop() {\n-    return numBackLoop.get();\n+  public void updateFailedStatValue() {\n+    PartialPath failedSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME).get(2);\n+    cachedValueMap.computeIfPresent(failedSeries, (key, oldValue) -> oldValue + 1);\n   }\n \n   /**\n-   * register class which implemented IStatistic interface into statisticMap\n-   *\n-   * @param path the stat series prefix path, like root.stat.file.size\n-   * @param iStatistic instance of class which implemented IStatistic interface\n+   * Generate tsRecords for stat parameters and insert them into StorageEngine.\n    */\n-  public void registerStatistics(String path, IStatistic iStatistic) {\n-    synchronized (statisticMap) {\n-      logger.debug(\"Register {} to StatMonitor for statistics service\", path);\n-      this.statisticMap.put(path, iStatistic);\n+  public void cacheStatValue() {", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI0NDk4Ng==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493244986", "bodyText": "Fixed.", "author": "Alima777", "createdAt": "2020-09-23T07:06:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMTM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMTY4OA==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493221688", "bodyText": "TSRecord should be refined, as we do not need to generate a String in TsRecord.", "author": "jixuan1989", "createdAt": "2020-09-23T06:15:26Z", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL\n+      switch (i) {\n+        case 0:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + successPointsNum);\n+          break;\n+        case 1:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + 1);\n+          break;\n+      }\n+    }\n   }\n \n-  public long getNumBackLoop() {\n-    return numBackLoop.get();\n+  public void updateFailedStatValue() {\n+    PartialPath failedSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME).get(2);\n+    cachedValueMap.computeIfPresent(failedSeries, (key, oldValue) -> oldValue + 1);\n   }\n \n   /**\n-   * register class which implemented IStatistic interface into statisticMap\n-   *\n-   * @param path the stat series prefix path, like root.stat.file.size\n-   * @param iStatistic instance of class which implemented IStatistic interface\n+   * Generate tsRecords for stat parameters and insert them into StorageEngine.\n    */\n-  public void registerStatistics(String path, IStatistic iStatistic) {\n-    synchronized (statisticMap) {\n-      logger.debug(\"Register {} to StatMonitor for statistics service\", path);\n-      this.statisticMap.put(path, iStatistic);\n+  public void cacheStatValue() {\n+    StorageEngine storageEngine = StorageEngine.getInstance();\n+    long insertTime = System.currentTimeMillis();\n+    for (Entry<PartialPath, Long> cachedValue : cachedValueMap.entrySet()) {\n+      TSRecord tsRecord = new TSRecord(insertTime, cachedValue.getKey().getDevice());", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMjI0NA==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493222244", "bodyText": "and clear the data structures in memory", "author": "jixuan1989", "createdAt": "2020-09-23T06:16:54Z", "path": "server/src/main/java/org/apache/iotdb/db/monitor/StatMonitor.java", "diffHunk": "@@ -16,317 +16,291 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-\n package org.apache.iotdb.db.monitor;\n \n-import org.apache.iotdb.db.concurrent.IoTDBThreadPoolFactory;\n-import org.apache.iotdb.db.concurrent.ThreadName;\n-import org.apache.iotdb.db.concurrent.WrappedRunnable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.commons.io.FileUtils;\n import org.apache.iotdb.db.conf.IoTDBConfig;\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.db.conf.IoTDBDescriptor;\n import org.apache.iotdb.db.engine.StorageEngine;\n+import org.apache.iotdb.db.engine.fileSystem.SystemFileFactory;\n import org.apache.iotdb.db.exception.StartupException;\n import org.apache.iotdb.db.exception.StorageEngineException;\n import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n import org.apache.iotdb.db.metadata.MManager;\n import org.apache.iotdb.db.metadata.PartialPath;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeManagerStatConstants;\n-import org.apache.iotdb.db.monitor.MonitorConstants.FileNodeProcessorStatConstants;\n-import org.apache.iotdb.db.monitor.collector.FileSize;\n+import org.apache.iotdb.db.monitor.MonitorConstants.StatMeasurementConstants;\n import org.apache.iotdb.db.qp.physical.crud.InsertRowPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.executor.LastQueryExecutor;\n import org.apache.iotdb.db.service.IService;\n import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.db.service.JMXService;\n import org.apache.iotdb.db.service.ServiceType;\n import org.apache.iotdb.tsfile.common.conf.TSFileDescriptor;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n import org.apache.iotdb.tsfile.write.record.TSRecord;\n import org.apache.iotdb.tsfile.write.record.datapoint.LongDataPoint;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class StatMonitor implements IService {\n+public class StatMonitor implements StatMonitorMBean, IService {\n \n   private static final Logger logger = LoggerFactory.getLogger(StatMonitor.class);\n-  private final int backLoopPeriod;\n-  private final int statMonitorDetectFreqSec;\n-  private final int statMonitorRetainIntervalSec;\n-  private long runningTimeMillis = System.currentTimeMillis();\n-  private static final ArrayList<String> temporaryStatList = new ArrayList<>();\n-  /**\n-   * key: is the statistics store seriesPath Value: is an interface that implements statistics\n-   * function.\n-   */\n-  private final HashMap<String, IStatistic> statisticMap;\n-  private ScheduledExecutorService service;\n-\n-  /**\n-   * stats params.\n-   */\n-  private AtomicLong numBackLoop = new AtomicLong(0);\n-  private AtomicLong numInsert = new AtomicLong(0);\n-  private AtomicLong numPointsInsert = new AtomicLong(0);\n-  private AtomicLong numInsertError = new AtomicLong(0);\n-\n-  private StatMonitor() {\n-    initTemporaryStatList();\n-    MManager mmanager = IoTDB.metaManager;\n-    statisticMap = new HashMap<>();\n-    IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n-    statMonitorDetectFreqSec = config.getStatMonitorDetectFreqSec();\n-    statMonitorRetainIntervalSec = config.getStatMonitorRetainIntervalSec();\n-    backLoopPeriod = config.getBackLoopPeriodSec();\n+  private static IoTDBConfig config = IoTDBDescriptor.getInstance().getConfig();\n+  private static MManager mManager = IoTDB.metaManager;\n+  private final String mbeanName = String\n+      .format(\"%s:%s=%s\", IoTDBConstant.IOTDB_PACKAGE, IoTDBConstant.JMX_TYPE,\n+          getID().getJmxName());\n+\n+  // storage group name -> monitor series of it.\n+  // List is used to be maintainable, maybe some metrics will be added\n+  private Map<String, List<PartialPath>> monitorSeriesMap = new ConcurrentHashMap<>();\n+  // monitor series -> current value of it.   e.g. root.stats.global.TOTAL_POINTS -> value\n+  private Map<PartialPath, Long> cachedValueMap = new ConcurrentHashMap<>();\n+\n+  public StatMonitor() {\n     if (config.isEnableStatMonitor()) {\n-      try {\n-        PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-        if (!mmanager.isPathExist(prefix)) {\n-          mmanager.setStorageGroup(prefix);\n-        }\n-      } catch (MetadataException e) {\n-        logger.error(\"MManager cannot set storage group to MTree.\", e);\n-      }\n-    }\n-  }\n-\n-  private void initTemporaryStatList() {\n-    for (FileNodeManagerStatConstants constants : FileNodeManagerStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n-    }\n-    for (FileNodeProcessorStatConstants constants : FileNodeProcessorStatConstants.values()) {\n-      temporaryStatList.add(constants.name());\n+      registerStatGlobalInfo();\n+      List<PartialPath> storageGroupNames = mManager.getAllStorageGroupPaths();\n+      registerStatStorageGroupInfo(storageGroupNames);\n     }\n   }\n \n   public static StatMonitor getInstance() {\n     return StatMonitorHolder.INSTANCE;\n   }\n \n-  /**\n-   * generate TSRecord.\n-   *\n-   * @param hashMap key is statParams name, values is AtomicLong type\n-   * @param statGroupDeltaName is the deviceId seriesPath of this module\n-   * @param curTime current time stamp\n-   * @return TSRecord contains the DataPoints of a statGroupDeltaName\n-   */\n-  public static TSRecord convertToTSRecord(Map<String, AtomicLong> hashMap,\n-      String statGroupDeltaName, long curTime) {\n-    TSRecord tsRecord = new TSRecord(curTime, statGroupDeltaName);\n-    tsRecord.dataPointList = new ArrayList<>();\n-    for (Map.Entry<String, AtomicLong> entry : hashMap.entrySet()) {\n-      AtomicLong value = entry.getValue();\n-      tsRecord.dataPointList.add(new LongDataPoint(entry.getKey(), value.get()));\n-    }\n-    return tsRecord;\n-  }\n-\n-  public long getNumPointsInsert() {\n-    return numPointsInsert.get();\n+  public Map<String, List<PartialPath>> getMonitorSeriesMap() {\n+    return monitorSeriesMap;\n   }\n \n-  public long getNumInsert() {\n-    return numInsert.get();\n-  }\n+  /**\n+   * Register monitor storage group into system.\n+   */\n+  public void registerStatGlobalInfo() {\n+    PartialPath storageGroupPrefix = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY);\n+    try {\n+      if (!mManager.isPathExist(storageGroupPrefix)) {\n+        mManager.setStorageGroup(storageGroupPrefix);\n+      }\n \n-  public long getNumInsertError() {\n-    return numInsertError.get();\n-  }\n+      for (StatMeasurementConstants statConstant : StatMeasurementConstants.values()) {\n+        PartialPath fullPath = new PartialPath(MonitorConstants.STAT_GLOBAL_ARRAY)\n+            .concatNode(statConstant.getMeasurement());\n+        registSeriesToMManager(fullPath);\n \n-  void registerStatStorageGroup() {\n-    MManager mManager = IoTDB.metaManager;\n-    PartialPath prefix = new PartialPath(MonitorConstants.getStatStorageGroupPrefixArray());\n-    try {\n-      if (!mManager.isPathExist(prefix)) {\n-        mManager.setStorageGroup(prefix);\n+        List<PartialPath> seriesList = monitorSeriesMap\n+            .computeIfAbsent(MonitorConstants.STAT_STORAGE_GROUP_NAME, k -> new ArrayList<>());\n+        seriesList.add(fullPath);\n+        cachedValueMap.putIfAbsent(fullPath, (long) 0);\n       }\n-    } catch (Exception e) {\n-      logger.error(\"MManager cannot set storage group to MTree.\", e);\n+    } catch (MetadataException e) {\n+      logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n   /**\n-   * register monitor statistics time series metadata into MManager.\n-   *\n-   * @param hashMap series path and data type pair, for example: [root.stat.file.size.DATA, INT64]\n+   * Register monitor time series metadata of each storageGroup into MManager.\n    */\n-  public synchronized void registerStatStorageGroup(Map<String, String> hashMap) {\n-    MManager mManager = IoTDB.metaManager;\n+  public void registerStatStorageGroupInfo(List<PartialPath> storageGroupNames) {\n+    if (storageGroupNames.isEmpty()) {\n+      return;\n+    }\n     try {\n-      for (Map.Entry<String, String> entry : hashMap.entrySet()) {\n-        if (entry.getValue() == null) {\n-          logger.error(\"Registering metadata but data type of {} is null\", entry.getKey());\n-        }\n-\n-        if (!mManager.isPathExist(new PartialPath(entry.getKey()))) {\n-          mManager.createTimeseries(new PartialPath(entry.getKey()), TSDataType.valueOf(entry.getValue()),\n-              TSEncoding.valueOf(\"RLE\"),\n-              TSFileDescriptor.getInstance().getConfig().getCompressor(),\n-              Collections.emptyMap());\n+      for (PartialPath storageGroupName : storageGroupNames) {\n+        if (!storageGroupName.equals(MonitorConstants.STAT_STORAGE_GROUP_NAME)) {\n+          // for storage group which is not global, only TOTAL_POINTS is registered now\n+          PartialPath fullPath = new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY)\n+              .concatNode(\"\\\"\" + storageGroupName + \"\\\"\")\n+              .concatNode(StatMeasurementConstants.TOTAL_POINTS.getMeasurement());\n+          registSeriesToMManager(fullPath);\n+\n+          List<PartialPath> seriesList = monitorSeriesMap\n+              .computeIfAbsent(storageGroupName.toString(), k -> new ArrayList<>());\n+          seriesList.add(fullPath);\n+          cachedValueMap.putIfAbsent(fullPath, (long) 0);\n         }\n       }\n     } catch (MetadataException e) {\n       logger.error(\"Initialize the metadata error.\", e);\n     }\n   }\n \n-  public void recovery() {\n-    // // restore the FildeNode Manager TOTAL_POINTS statistics info\n+  private void registSeriesToMManager(PartialPath fullPath) throws MetadataException {\n+    if (!mManager.isPathExist(fullPath)) {\n+      mManager.createTimeseries(fullPath,\n+          TSDataType.valueOf(MonitorConstants.INT64),\n+          TSEncoding.valueOf(\"RLE\"),\n+          TSFileDescriptor.getInstance().getConfig().getCompressor(),\n+          Collections.emptyMap());\n+    }\n   }\n \n-  void activate() {\n-    service = IoTDBThreadPoolFactory.newScheduledThreadPool(1,\n-        ThreadName.STAT_MONITOR.getName());\n-    service.scheduleAtFixedRate(\n-        new StatBackLoop(), 1, backLoopPeriod, TimeUnit.SECONDS);\n+  public void updateStatStorageGroupValue(String storageGroupName, int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap.get(storageGroupName);\n+    // update TOTAL_POINTS of each storage group\n+    cachedValueMap.computeIfPresent(monitorSeries.get(0),\n+        (key, oldValue) -> oldValue + successPointsNum);\n   }\n \n-  void clearIStatisticMap() {\n-    statisticMap.clear();\n+  public void updateStatGlobalValue(int successPointsNum) {\n+    List<PartialPath> monitorSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME);\n+    for (int i = 0; i < monitorSeries.size() - 1; i++) {\n+      // 0 -> TOTAL_POINTS, 1 -> REQ_SUCCESS, 2 -> REQ_FAIL\n+      switch (i) {\n+        case 0:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + successPointsNum);\n+          break;\n+        case 1:\n+          cachedValueMap.computeIfPresent(monitorSeries.get(i),\n+              (key, oldValue) -> oldValue + 1);\n+          break;\n+      }\n+    }\n   }\n \n-  public long getNumBackLoop() {\n-    return numBackLoop.get();\n+  public void updateFailedStatValue() {\n+    PartialPath failedSeries = monitorSeriesMap\n+        .get(MonitorConstants.STAT_STORAGE_GROUP_NAME).get(2);\n+    cachedValueMap.computeIfPresent(failedSeries, (key, oldValue) -> oldValue + 1);\n   }\n \n   /**\n-   * register class which implemented IStatistic interface into statisticMap\n-   *\n-   * @param path the stat series prefix path, like root.stat.file.size\n-   * @param iStatistic instance of class which implemented IStatistic interface\n+   * Generate tsRecords for stat parameters and insert them into StorageEngine.\n    */\n-  public void registerStatistics(String path, IStatistic iStatistic) {\n-    synchronized (statisticMap) {\n-      logger.debug(\"Register {} to StatMonitor for statistics service\", path);\n-      this.statisticMap.put(path, iStatistic);\n+  public void cacheStatValue() {\n+    StorageEngine storageEngine = StorageEngine.getInstance();\n+    long insertTime = System.currentTimeMillis();\n+    for (Entry<PartialPath, Long> cachedValue : cachedValueMap.entrySet()) {\n+      TSRecord tsRecord = new TSRecord(insertTime, cachedValue.getKey().getDevice());\n+      tsRecord.addTuple(\n+          new LongDataPoint(cachedValue.getKey().getMeasurement(), cachedValue.getValue()));\n+      try {\n+        storageEngine.insert(new InsertRowPlan(tsRecord));\n+      } catch (StorageEngineException | IllegalPathException e) {\n+        logger.error(\"Inserting stat points error.\", e);\n+      }\n     }\n   }\n \n-  /**\n-   * deregister statistics.\n-   */\n-  public void deregisterStatistics(String path) {\n-    logger.debug(\"Deregister {} in StatMonitor for stopping statistics service\", path);\n-    synchronized (statisticMap) {\n-      if (statisticMap.containsKey(path)) {\n-        statisticMap.put(path, null);\n+  public void recovery() {\n+    try {\n+      List<PartialPath> monitorSeries = mManager\n+          .getAllTimeseriesPath(new PartialPath(MonitorConstants.STAT_STORAGE_GROUP_ARRAY));\n+      for (PartialPath oneSeries : monitorSeries) {\n+        TimeValuePair timeValuePair = LastQueryExecutor\n+            .calculateLastPairForOneSeriesLocally(oneSeries, TSDataType.INT64, new QueryContext(\n+                    QueryResourceManager.getInstance().assignQueryId(true)),\n+                Collections.singleton(oneSeries.getMeasurement()));\n+        if (timeValuePair.getValue() != null) {\n+          cachedValueMap.put(oneSeries, timeValuePair.getValue().getLong());\n+        }\n       }\n+    } catch (MetadataException e) {\n+      logger.error(\"Can not get monitor series from mManager while recovering.\", e);\n+    } catch (StorageEngineException | IOException | QueryProcessException e) {\n+      logger.error(\"Load last value from disk error.\", e);\n     }\n   }\n \n-  /**\n-   * This function is not used and need to complete the query key concept.\n-   *\n-   * @return TSRecord, query statistics params\n-   */\n-  public Map<String, TSRecord> getOneStatisticsValue(String key) {\n-    // queryPath like fileNode seriesPath: root.stats.car1,\n-    // or StorageEngine seriesPath:StorageEngine\n-    String queryPath;\n-    if (key.contains(\"\\\\.\")) {\n-      queryPath =\n-          MonitorConstants.STAT_STORAGE_GROUP_PREFIX + MonitorConstants.MONITOR_PATH_SEPARATOR\n-              + key.replaceAll(\"\\\\.\", \"_\");\n-    } else {\n-      queryPath = key;\n-    }\n-    if (statisticMap.containsKey(queryPath)) {\n-      return statisticMap.get(queryPath).getAllStatisticsValue();\n-    } else {\n-      long currentTimeMillis = System.currentTimeMillis();\n-      HashMap<String, TSRecord> hashMap = new HashMap<>();\n-      TSRecord tsRecord = convertToTSRecord(\n-          MonitorConstants.initValues(MonitorConstants.FILENODE_PROCESSOR_CONST), queryPath,\n-          currentTimeMillis);\n-      hashMap.put(queryPath, tsRecord);\n-      return hashMap;\n-    }\n+  public void close() {\n+    config.setEnableStatMonitor(false);", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI2MTIxMg==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493261212", "bodyText": "Fixed.", "author": "Alima777", "createdAt": "2020-09-23T07:35:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyMjI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyOTExMw==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493229113", "bodyText": "have you tested the performance?\nI think maybe \"each tsfileProcessor records the results, and then reports to the SG processor (and then reports the the Storage Engine if needed)\" can reach a better performance.\nThe sacrifice is we can not get a real time stats.\nA solution is add an JMX interface to update the value immediately, (then the tsfileProcessors report the data immediately)", "author": "jixuan1989", "createdAt": "2020-09-23T06:33:06Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "diffHunk": "@@ -348,6 +352,9 @@ public void insert(InsertRowPlan insertRowPlan) throws StorageEngineException {\n     // TODO monitor: update statistics\n     try {\n       storageGroupProcessor.insert(insertRowPlan);\n+      if (config.isEnableStatMonitor()) {", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyOTQzMA==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493229430", "bodyText": "remove", "author": "jixuan1989", "createdAt": "2020-09-23T06:33:56Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/memtable/AbstractMemTable.java", "diffHunk": "@@ -30,6 +30,7 @@\n import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n import org.apache.iotdb.db.exception.WriteProcessException;\n import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.monitor.StatMonitor;", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyOTYwMw==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493229603", "bodyText": "It is better to just flush the flushed SG.", "author": "jixuan1989", "createdAt": "2020-09-23T06:34:20Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/FlushManager.java", "diffHunk": "@@ -93,6 +95,10 @@ public void runMayThrow() {\n             tsFileProcessor.getTsFileResource().getTsFile().getAbsolutePath());\n       }\n       registerTsFileProcessor(tsFileProcessor);\n+      // update stat monitor cache to system during each flush()\n+      if (IoTDBDescriptor.getInstance().getConfig().isEnableStatMonitor()) {\n+        StatMonitor.getInstance().cacheStatValue();", "originalCommit": "43dfbef093e05d77704d5e65672294b28f8e5bdd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI5MDkwMw==", "url": "https://github.com/apache/iotdb/pull/1725#discussion_r493290903", "bodyText": "Fixed.", "author": "Alima777", "createdAt": "2020-09-23T08:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIyOTYwMw=="}], "type": "inlineReview"}, {"oid": "4643b11106068c30ab1878726e1ba9e9025b4c63", "url": "https://github.com/apache/iotdb/commit/4643b11106068c30ab1878726e1ba9e9025b4c63", "message": "modify based on review", "committedDate": "2020-09-23T08:58:50Z", "type": "commit"}, {"oid": "5a5857e5ce0a37f5eae3079f7d64530246e58bc1", "url": "https://github.com/apache/iotdb/commit/5a5857e5ce0a37f5eae3079f7d64530246e58bc1", "message": "delete conf properties", "committedDate": "2020-09-29T08:15:25Z", "type": "commit"}, {"oid": "df2d2f831a32ae8ab4619d26186ca353b79c9756", "url": "https://github.com/apache/iotdb/commit/df2d2f831a32ae8ab4619d26186ca353b79c9756", "message": "change the cache strategy", "committedDate": "2020-09-29T12:38:29Z", "type": "commit"}, {"oid": "1207fb23559c680b400396ce85dcc0ced4fd2ef6", "url": "https://github.com/apache/iotdb/commit/1207fb23559c680b400396ce85dcc0ced4fd2ef6", "message": "extract some code", "committedDate": "2020-09-30T07:24:34Z", "type": "commit"}, {"oid": "a144d5c09ab9fae9a5890b47b4bb6dd481a11f68", "url": "https://github.com/apache/iotdb/commit/a144d5c09ab9fae9a5890b47b4bb6dd481a11f68", "message": "fix conflict", "committedDate": "2020-09-30T07:29:13Z", "type": "commit"}, {"oid": "b00cf38d4cbd821abcd29b1f411ee1677a2d3fe7", "url": "https://github.com/apache/iotdb/commit/b00cf38d4cbd821abcd29b1f411ee1677a2d3fe7", "message": "merge master and fix conflicts", "committedDate": "2020-11-16T02:49:48Z", "type": "commit"}, {"oid": "ce58b3f347b61c595075f04b8653dbfca432a10f", "url": "https://github.com/apache/iotdb/commit/ce58b3f347b61c595075f04b8653dbfca432a10f", "message": "add switch to control writing:", "committedDate": "2020-11-16T04:23:54Z", "type": "commit"}, {"oid": "c43b4dc5db380591fa725fdba916690c6a901ea4", "url": "https://github.com/apache/iotdb/commit/c43b4dc5db380591fa725fdba916690c6a901ea4", "message": "modify properties", "committedDate": "2020-11-16T11:43:17Z", "type": "commit"}, {"oid": "e741ce8bc21261d2bb49ab856938f78bdb9c1fa0", "url": "https://github.com/apache/iotdb/commit/e741ce8bc21261d2bb49ab856938f78bdb9c1fa0", "message": "add english doc and return null if no storage group", "committedDate": "2020-11-19T08:29:43Z", "type": "commit"}, {"oid": "7e4d662bd59d69575ac3e2fca4fb13b214f48a86", "url": "https://github.com/apache/iotdb/commit/7e4d662bd59d69575ac3e2fca4fb13b214f48a86", "message": "return -1", "committedDate": "2020-11-19T10:04:31Z", "type": "commit"}, {"oid": "262a75213813a7e4b696a62806c11d3a62cb72ac", "url": "https://github.com/apache/iotdb/commit/262a75213813a7e4b696a62806c11d3a62cb72ac", "message": "Merge branch 'master' into state_monitor", "committedDate": "2020-11-19T10:19:59Z", "type": "commit"}, {"oid": "8c4b48efdb95218e676d7066722bb1f255d206a4", "url": "https://github.com/apache/iotdb/commit/8c4b48efdb95218e676d7066722bb1f255d206a4", "message": "fix ci", "committedDate": "2020-11-19T12:45:51Z", "type": "commit"}, {"oid": "859f31436bbc207f21e31a53f7c0098037652aac", "url": "https://github.com/apache/iotdb/commit/859f31436bbc207f21e31a53f7c0098037652aac", "message": "Merge branch 'master' into state_monitor", "committedDate": "2020-11-20T08:07:18Z", "type": "commit"}, {"oid": "a03cae1628621f39853b209e4521d6aefc507642", "url": "https://github.com/apache/iotdb/commit/a03cae1628621f39853b209e4521d6aefc507642", "message": "fix conflict", "committedDate": "2020-11-23T02:19:18Z", "type": "commit"}, {"oid": "09946ee13c2381d622bdf7986f4f65a0defab6fe", "url": "https://github.com/apache/iotdb/commit/09946ee13c2381d622bdf7986f4f65a0defab6fe", "message": "fix doc typo", "committedDate": "2020-11-24T02:13:37Z", "type": "commit"}, {"oid": "ba1ab25aa0b8836a6e9bf0dc6a9517a6a63829ff", "url": "https://github.com/apache/iotdb/commit/ba1ab25aa0b8836a6e9bf0dc6a9517a6a63829ff", "message": "fix doc again", "committedDate": "2020-11-24T02:20:19Z", "type": "commit"}, {"oid": "47ca8d86c3949c27577207ef4588da87ea13fa38", "url": "https://github.com/apache/iotdb/commit/47ca8d86c3949c27577207ef4588da87ea13fa38", "message": "modify user doc", "committedDate": "2020-11-24T03:04:04Z", "type": "commit"}, {"oid": "6aa9a21777839cefe014e154d49338d70cdd15b3", "url": "https://github.com/apache/iotdb/commit/6aa9a21777839cefe014e154d49338d70cdd15b3", "message": "modify typo:", "committedDate": "2020-11-24T03:05:39Z", "type": "commit"}, {"oid": "47a33f526906f9ef001a8d7a407b0b0d212c90c3", "url": "https://github.com/apache/iotdb/commit/47a33f526906f9ef001a8d7a407b0b0d212c90c3", "message": "modify typo", "committedDate": "2020-11-24T03:06:06Z", "type": "commit"}, {"oid": "29ccf2b4d742e51984443864993c2f46ffade68e", "url": "https://github.com/apache/iotdb/commit/29ccf2b4d742e51984443864993c2f46ffade68e", "message": "remove redundant doc content", "committedDate": "2020-11-24T03:09:35Z", "type": "commit"}, {"oid": "087f932072217cbe860f98b8a6fd3550417994a4", "url": "https://github.com/apache/iotdb/commit/087f932072217cbe860f98b8a6fd3550417994a4", "message": "modify user doc", "committedDate": "2020-11-24T09:10:04Z", "type": "commit"}]}