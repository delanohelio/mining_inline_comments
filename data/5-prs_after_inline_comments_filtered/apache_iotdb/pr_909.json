{"pr_number": 909, "pr_title": "[IOTDB-355] Start-up checks", "pr_createdAt": "2020-03-14T05:41:39Z", "pr_url": "https://github.com/apache/iotdb/pull/909", "timeline": [{"oid": "41db9d5a1b86344a9ae8ef8fc42b626218c24473", "url": "https://github.com/apache/iotdb/commit/41db9d5a1b86344a9ae8ef8fc42b626218c24473", "message": "fix some typo", "committedDate": "2020-03-14T05:38:53Z", "type": "commit"}, {"oid": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "url": "https://github.com/apache/iotdb/commit/6abea8410570fb569a8749cfe4b88b2e2b56690f", "message": "start up check", "committedDate": "2020-03-14T14:30:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1ODQ1Mw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392858453", "bodyText": "This check should only be used when a node tries to form the initial cluster (startCluster()). If a node wants to join a cluster, the size of its seeds does not really matter.", "author": "jt2594838", "createdAt": "2020-03-16T08:42:52Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java", "diffHunk": "@@ -56,16 +59,22 @@\n   // to register the ClusterMonitor that helps monitoring the cluster\n   private RegisterManager registerManager = new RegisterManager();\n \n-  public MetaClusterServer() throws QueryProcessException {\n+  public MetaClusterServer() throws QueryProcessException, StartupException {\n     super();\n     member = new MetaGroupMember(protocolFactory, thisNode);\n-    // TODO-Cluster#355: check the initial cluster size and refuse to start when the size <\n-    //  #replication\n+    // check the initial cluster size and refuse to start when the size < quorum\n+    int quorum = config.getReplicationNum() / 2 + 1;\n+    if (config.getSeedNodeUrls().size() < quorum) {\n+      String message = String.format(\"Seed number less than quorum, seed number: {}, quorum: {}.\",\n+          config.getSeedNodeUrls().size(), quorum);\n+      throw new StartupException(member.getName(), message);\n+    }", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYzNzkzMA==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r393637930", "bodyText": "Thanks for your suggestion. I will change it.", "author": "Ring-k", "createdAt": "2020-03-17T12:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1ODQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1ODY4Nw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392858687", "bodyText": "remove this or use a log", "author": "jt2594838", "createdAt": "2020-03-16T08:43:18Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/MetaClusterServer.java", "diffHunk": "@@ -74,6 +83,7 @@ public void start() throws TTransportException, StartupException {\n     super.start();\n     ioTDB = new IoTDB();\n     ioTDB.active();\n+    System.out.println(\"--------------------start connecting\");", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3MTU0NQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392871545", "bodyText": "This line of code is removed.", "author": "Ring-k", "createdAt": "2020-03-16T09:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1ODY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1OTgxMg==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392859812", "bodyText": "Is it necessary to new here? I think the handler should always have the result set by onComplete.", "author": "jt2594838", "createdAt": "2020-03-16T08:45:31Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandler.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.apache.iotdb.cluster.server.handlers.caller;\n+\n+import org.apache.iotdb.cluster.rpc.thrift.CheckStatusResponse;\n+import org.apache.thrift.async.AsyncMethodCallback;\n+\n+public class CheckStatusHandler implements AsyncMethodCallback<CheckStatusResponse> {\n+\n+  CheckStatusResponse checkStatusResponse;\n+\n+  public CheckStatusHandler() {\n+    this.checkStatusResponse = new CheckStatusResponse();", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3MjExNQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392872115", "bodyText": "I used GenericHandler instead in the updated version. This class is removed.", "author": "Ring-k", "createdAt": "2020-03-16T09:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1OTgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MTg0NQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392861845", "bodyText": "I think it is simpler to just add these configurations that should be checked into the AddNodeRequest so that you can cut one communication down.\nBesides, please remove the commented code.", "author": "jt2594838", "createdAt": "2020-03-16T08:49:29Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -623,6 +627,50 @@ private boolean processAddNodeLocally(Node node, AddNodeResponse response,\n         return true;\n       }\n \n+      // check status of the new node\n+//      AsyncClient client = (AsyncClient) connectNode(node);\n+//      try {\n+//        AsyncMethodCallback<String> result = new AsyncMethodCallback<String>() {\n+//          String words;\n+//          @Override\n+//          public void onComplete(String s) {\n+//            this.words = s;\n+//          }\n+//          @Override\n+//          public void onError(Exception e) {\n+//            System.out.println(\"some error happens\");\n+//          }\n+//          public String getWords() {\n+//            return words;\n+//          }\n+//        };\n+//        System.out.println(result);\n+//        client.echo(\"hello world\", result);\n+//      } catch (TException e) {\n+//        e.printStackTrace();\n+//      }\n+      CheckStatusRequest checkStatusRequest = new CheckStatusRequest();\n+      checkStatusRequest.setHashSalt(ClusterConstant.HASH_SALT);\n+      checkStatusRequest\n+          .setPartitionInterval(IoTDBDescriptor.getInstance().getConfig().getPartitionInterval());\n+      checkStatusRequest.setReplicationNumber(config.getReplicationNum());\n+      CheckStatusHandler checkStatusHandler = new CheckStatusHandler();\n+      try {\n+        sendStatusToNewNode(node, checkStatusRequest, checkStatusHandler);\n+      } catch (TException exception) {\n+        logger.error(\"Failed to send current state to the new node {}\", node, exception);\n+      }\n+      if (!checkStatusHandler.getCheckStatusResponse().isPartitionalIntervalEquals()) {\n+        logger.info(\"The partition interval of the new node {} conflicts.\", node);\n+        return true;\n+      } else if (!checkStatusHandler.getCheckStatusResponse().isHashSaltIntervalEquals()) {\n+        logger.info(\"The hash salt of the new node {} conflicts.\", node);\n+        return true;\n+      } else if (!checkStatusHandler.getCheckStatusResponse().isReplicationNumEquals()) {\n+        logger.info(\"The replication number of the new node {} conflicts.\", node);\n+        return true;\n+      }", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3NDAxMw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392874013", "bodyText": "That's a good idea. I will change it", "author": "Ring-k", "createdAt": "2020-03-16T09:13:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MTg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MzMwMQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392863301", "bodyText": "client.checkStatus is an asynchronous method, so if you use it like this, you will probably get nothing in the response. Please refer to other usages where a lock (synchronized) is used to assure that the result is returned before we move on.", "author": "jt2594838", "createdAt": "2020-03-16T08:52:20Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -663,6 +711,14 @@ private boolean processAddNodeLocally(Node node, AddNodeResponse response,\n     return false;\n   }\n \n+\n+  private void sendStatusToNewNode(Node node, CheckStatusRequest checkStatusRequest,\n+      AsyncMethodCallback<CheckStatusResponse> response)\n+      throws TException {\n+    AsyncClient client = (AsyncClient) connectNode(node);\n+    client.checkStatus(checkStatusRequest, response);", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3NDk3OQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392874979", "bodyText": "Thanks for your suggestion. I will implement it.", "author": "Ring-k", "createdAt": "2020-03-16T09:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2MzMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NDMzMg==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392864332", "bodyText": "Please also fulfill the tests.", "author": "jt2594838", "createdAt": "2020-03-16T08:54:22Z", "path": "cluster/src/test/java/org/apache/iotdb/cluster/server/handlers/caller/CheckStatusHandlerTest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.apache.iotdb.cluster.server.handlers.caller;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertFalse;\n+import static junit.framework.TestCase.assertTrue;\n+\n+import org.apache.iotdb.cluster.common.TestException;\n+import org.apache.iotdb.cluster.common.TestLogManager;\n+import org.apache.iotdb.cluster.common.TestMetaGroupMember;\n+import org.apache.iotdb.cluster.common.TestUtils;\n+import org.apache.iotdb.cluster.log.LogManager;\n+import org.apache.iotdb.cluster.rpc.thrift.HeartbeatResponse;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.server.Response;\n+import org.apache.iotdb.cluster.server.member.MetaGroupMember;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class CheckStatusHandlerTest {\n+  private MetaGroupMember metaGroupMember;\n+  private boolean catchUpFlag;\n+\n+  @Before\n+  public void setUp() {\n+    metaGroupMember = new TestMetaGroupMember() {\n+      @Override\n+      public void catchUp(Node follower, long followerLastLogIndex) {\n+        synchronized (metaGroupMember) {\n+          catchUpFlag = true;\n+          metaGroupMember.notifyAll();\n+        }\n+      }\n+\n+      @Override\n+      public LogManager getLogManager() {\n+        return new TestLogManager();\n+      }\n+    };\n+  }\n+\n+  @Test\n+  public void testComplete() throws InterruptedException {\n+    CheckStatusHandler checkStatusHandler = new CheckStatusHandler();\n+    // TODO\n+  }", "originalCommit": "6abea8410570fb569a8749cfe4b88b2e2b56690f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3MzkzNA==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392873934", "bodyText": "I removed the CheckStatusHander class. The unit test is also removed.", "author": "Ring-k", "createdAt": "2020-03-16T09:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg2NDMzMg=="}], "type": "inlineReview"}, {"oid": "850a3af48f766b84404dd1d653e50e831d7c20b4", "url": "https://github.com/apache/iotdb/commit/850a3af48f766b84404dd1d653e50e831d7c20b4", "message": "implement startup check", "committedDate": "2020-03-16T09:05:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3OTk1OQ==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392879959", "bodyText": "Please reverse this.", "author": "jt2594838", "createdAt": "2020-03-16T09:24:14Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -60,7 +60,7 @@\n   /**\n    * Port which the JDBC server listens to.\n    */\n-  private int rpcPort = 6667;\n+  private int rpcPort = 6670;", "originalCommit": "850a3af48f766b84404dd1d653e50e831d7c20b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4OTQ0OA==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r393389448", "bodyText": "Thanks for your reminding. This is reversed.", "author": "Ring-k", "createdAt": "2020-03-17T00:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg3OTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MTY2Nw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r392881667", "bodyText": "If you decide to return true, then you must call either resultHandler.onComplete() or resultHandler.onError(), otherwise the requestor will wait forever.\nAnd be sure to let the requestor know why there is a failure.", "author": "jt2594838", "createdAt": "2020-03-16T09:27:21Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/MetaGroupMember.java", "diffHunk": "@@ -628,45 +627,32 @@ private boolean processAddNodeLocally(Node node, AddNodeResponse response,\n       }\n \n       // check status of the new node\n-//      AsyncClient client = (AsyncClient) connectNode(node);\n-//      try {\n-//        AsyncMethodCallback<String> result = new AsyncMethodCallback<String>() {\n-//          String words;\n-//          @Override\n-//          public void onComplete(String s) {\n-//            this.words = s;\n-//          }\n-//          @Override\n-//          public void onError(Exception e) {\n-//            System.out.println(\"some error happens\");\n-//          }\n-//          public String getWords() {\n-//            return words;\n-//          }\n-//        };\n-//        System.out.println(result);\n-//        client.echo(\"hello world\", result);\n-//      } catch (TException e) {\n-//        e.printStackTrace();\n-//      }\n       CheckStatusRequest checkStatusRequest = new CheckStatusRequest();\n       checkStatusRequest.setHashSalt(ClusterConstant.HASH_SALT);\n       checkStatusRequest\n           .setPartitionInterval(IoTDBDescriptor.getInstance().getConfig().getPartitionInterval());\n       checkStatusRequest.setReplicationNumber(config.getReplicationNum());\n-      CheckStatusHandler checkStatusHandler = new CheckStatusHandler();\n+\n+      AtomicReference<CheckStatusResponse> checkStatusResponseReference = new AtomicReference<>();\n+      GenericHandler<CheckStatusResponse> checkStatusHandler = new GenericHandler<>(node,\n+          checkStatusResponseReference);\n       try {\n-        sendStatusToNewNode(node, checkStatusRequest, checkStatusHandler);\n-      } catch (TException exception) {\n+        synchronized (checkStatusResponseReference) {\n+          AsyncClient client = (AsyncClient) connectNode(node);\n+          client.checkStatus(checkStatusRequest, checkStatusHandler);\n+          checkStatusResponseReference.wait(connectionTimeoutInMS);\n+        }\n+      } catch (TException | InterruptedException exception) {\n         logger.error(\"Failed to send current state to the new node {}\", node, exception);\n       }\n-      if (!checkStatusHandler.getCheckStatusResponse().isPartitionalIntervalEquals()) {\n+      CheckStatusResponse checkStatusResult = checkStatusResponseReference.get();\n+      if (!checkStatusResult.isPartitionalIntervalEquals()) {\n         logger.info(\"The partition interval of the new node {} conflicts.\", node);\n         return true;\n-      } else if (!checkStatusHandler.getCheckStatusResponse().isHashSaltIntervalEquals()) {\n+      } else if (!checkStatusResult.isHashSaltIntervalEquals()) {\n         logger.info(\"The hash salt of the new node {} conflicts.\", node);\n         return true;\n-      } else if (!checkStatusHandler.getCheckStatusResponse().isReplicationNumEquals()) {\n+      } else if (!checkStatusResult.isReplicationNumEquals()) {\n         logger.info(\"The replication number of the new node {} conflicts.\", node);\n         return true;", "originalCommit": "850a3af48f766b84404dd1d653e50e831d7c20b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY0MTk0Nw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r393641947", "bodyText": "Thanks for your reminding. The onComplete() method will be called before returning results.", "author": "Ring-k", "createdAt": "2020-03-17T12:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4MTY2Nw=="}], "type": "inlineReview"}, {"oid": "32681c926673032db696bf0aeef8b274a12127a2", "url": "https://github.com/apache/iotdb/commit/32681c926673032db696bf0aeef8b274a12127a2", "message": "reset iotdb config", "committedDate": "2020-03-16T10:50:54Z", "type": "commit"}, {"oid": "186335a727b2419bbdff65d58980f3180c6f27dd", "url": "https://github.com/apache/iotdb/commit/186335a727b2419bbdff65d58980f3180c6f27dd", "message": "start up check on -s mode", "committedDate": "2020-03-17T12:12:51Z", "type": "commit"}, {"oid": "6cec35de3cc498311785f1b5c1d254c2382bb433", "url": "https://github.com/apache/iotdb/commit/6cec35de3cc498311785f1b5c1d254c2382bb433", "message": "call onComplete() before returning", "committedDate": "2020-03-17T12:26:22Z", "type": "commit"}, {"oid": "a269b96788a3994dd4655708d427f0e3a2979296", "url": "https://github.com/apache/iotdb/commit/a269b96788a3994dd4655708d427f0e3a2979296", "message": "merge check status in add node", "committedDate": "2020-03-18T13:51:17Z", "type": "commit"}, {"oid": "c9d0c10634efbd5fdd7fd9e3c76ccbaf34797b51", "url": "https://github.com/apache/iotdb/commit/c9d0c10634efbd5fdd7fd9e3c76ccbaf34797b51", "message": "remove useless comment", "committedDate": "2020-03-18T13:52:12Z", "type": "commit"}, {"oid": "db5019c0483230de9650702bc431c557898911e7", "url": "https://github.com/apache/iotdb/commit/db5019c0483230de9650702bc431c557898911e7", "message": "add unit test", "committedDate": "2020-03-18T14:14:36Z", "type": "commit"}, {"oid": "c8642a2cb02a0488fea39cdab1b0bdaab8bc5e68", "url": "https://github.com/apache/iotdb/commit/c8642a2cb02a0488fea39cdab1b0bdaab8bc5e68", "message": "fix conflict", "committedDate": "2020-03-18T14:41:18Z", "type": "commit"}, {"oid": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "url": "https://github.com/apache/iotdb/commit/79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "message": "fix conflict", "committedDate": "2020-03-19T14:08:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyMzc5Ng==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395423796", "bodyText": "Please notice the conflict marks and resolve them. I will mark all I see in case you miss any.", "author": "jt2594838", "createdAt": "2020-03-20T03:22:47Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -545,424 +550,487 @@ public Node getThisNode() {\n   }\n \n \n-  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n+    /**\n+     * Sub-classes will add their own process of HeartBeatResponse in this method.\n+     * @param response\n+     * @param receiver\n+     */\n+    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n \n-  }\n-\n-  /**\n-   * The actions performed when the node wins in an election (becoming a leader).\n-   */\n-  public void onElectionWins() {\n-\n-  }\n-\n-  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n+    }\n \n-  }\n+    /**\n+     * The actions performed when the node wins in an election (becoming a leader).\n+     */\n+    public void onElectionWins () {\n \n-  /**\n-   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-   * reset heartbeat timer.\n-   * @param newTerm\n-   */\n-  public void retireFromLeader(long newTerm) {\n-    synchronized (term) {\n-      long currTerm = term.get();\n-      // confirm that the heartbeat of the new leader hasn't come\n-      if (currTerm < newTerm) {\n-        term.set(newTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        setLeader(null);\n-        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-      }\n     }\n-  }\n-\n-  /**\n-   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-   * request is valid.\n-   * @param electionRequest\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long processElectionRequest(ElectionRequest electionRequest) {\n \n-    long thatTerm = electionRequest.getTerm();\n-    long thatLastLogId = electionRequest.getLastLogIndex();\n-    long thatLastLogTerm = electionRequest.getLastLogTerm();\n-    logger.info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-        name, thatTerm,\n-        thatLastLogId, thatLastLogTerm);\n \n-    long lastLogIndex = logManager.getLastLogIndex();\n-    long lastLogTerm = logManager.getLastLogTerm();\n+      /**\n+       * Sub-classes will add their own process of HeartBeatRequest in this method.\n+       * @param request\n+       * @param response\n+       */\n+      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n \n-    synchronized (term) {\n-      long thisTerm = term.get();\n-      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-          thatLastLogTerm);\n-      if (resp == Response.RESPONSE_AGREE) {\n-        term.set(thatTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        lastHeartbeatReceivedTime = System.currentTimeMillis();\n-        leader = electionRequest.getElector();\n-        // interrupt election\n-        term.notifyAll();\n       }\n-      return resp;\n-    }\n-  }\n \n-  /**\n-   *  Reject the election if one of the four holds:\n-   *   1. the term of the candidate is no bigger than the voter's\n-   *   2. the lastLogTerm of the candidate is smaller than the voter's\n-   *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-   *      smaller than the voter's\n-   *   Otherwise accept the election.\n-   * @param thisTerm\n-   * @param thisLastLogIndex\n-   * @param thisLastLogTerm\n-   * @param thatTerm\n-   * @param thatLastLogId\n-   * @param thatLastLogTerm\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n-    long response;\n-    if (thatTerm <= thisTerm) {\n-      response = thisTerm;\n-      logger.debug(\"{} rejected an election request, term:{}/{}\",\n-          name, thatTerm, thisTerm);\n-    } else if (thatLastLogTerm < thisLastLogTerm\n-        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-      response = Response.RESPONSE_LOG_MISMATCH;\n-    } else {\n-      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-          thisLastLogTerm);\n-      response = Response.RESPONSE_AGREE;\n-    }\n-    return response;\n-  }\n-\n-  /**\n-   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-   * follower. If some of the logs are not in memory, also send the snapshot.\n-   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-   *\n-   * @param follower\n-   * @param followerLastLogIndex\n-   */\n-  public void catchUp(Node follower, long followerLastLogIndex) {\n-    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-    // for one follower, there is at most one ongoing catch-up\n-    synchronized (follower) {\n-      // check if the last catch-up is still ongoing\n-      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-      if (lastCatchupResp != null\n-          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-        return;\n-      } else {\n-        // record the start of the catch-up\n-        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      /**\n+       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n+       * reset heartbeat timer.\n+       * @param newTerm\n+       */\n+      public void retireFromLeader ( long newTerm){\n+        synchronized (term) {\n+          long currTerm = term.get();\n+          // confirm that the heartbeat of the new leader hasn't come\n+          if (currTerm < newTerm) {\n+            term.set(newTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            setLeader(null);\n+            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n+          }\n+        }\n       }\n-    }\n-    if (followerLastLogIndex == -1) {\n-      // if the follower does not have any logs, send from the first one\n-      followerLastLogIndex = 0;\n-    }\n \n-    AsyncClient client = connectNode(follower);\n-    if (client != null) {\n-      List<Log> logs;\n-      boolean allLogsValid;\n-      Snapshot snapshot = null;\n-      synchronized (logManager) {\n-        // check if the very first log has been snapshot\n-        allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-        if (!allLogsValid) {\n-          // if the first log has been snapshot, the snapshot should also be sent to the\n-          // follower, otherwise some data will be missing\n-          snapshot = logManager.getSnapshot();\n+      /**\n+       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+       * request is valid.\n+       * @param electionRequest\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long processElectionRequest (ElectionRequest electionRequest){\n+\n+        long thatTerm = electionRequest.getTerm();\n+        long thatLastLogId = electionRequest.getLastLogIndex();\n+        long thatLastLogTerm = electionRequest.getLastLogTerm();\n+        logger\n+            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+                name, thatTerm,\n+                thatLastLogId, thatLastLogTerm);\n+\n+        long lastLogIndex = logManager.getLastLogIndex();\n+        long lastLogTerm = logManager.getLastLogTerm();\n+\n+        synchronized (term) {\n+          long thisTerm = term.get();\n+          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+              thatLastLogTerm);\n+          if (resp == Response.RESPONSE_AGREE) {\n+            term.set(thatTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            lastHeartbeatReceivedTime = System.currentTimeMillis();\n+            leader = electionRequest.getElector();\n+            // interrupt election\n+            term.notifyAll();\n+          }\n+          return resp;\n         }\n       }\n \n-      if (allLogsValid) {\n-        if (logger.isDebugEnabled()) {\n-          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+      /**\n+       *  Reject the election if one of the four holds:\n+       *   1. the term of the candidate is no bigger than the voter's\n+       *   2. the lastLogTerm of the candidate is smaller than the voter's\n+       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n+       *      smaller than the voter's\n+       *   Otherwise accept the election.\n+       * @param thisTerm\n+       * @param thisLastLogIndex\n+       * @param thisLastLogTerm\n+       * @param thatTerm\n+       * @param thatLastLogId\n+       * @param thatLastLogTerm\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n+        long response;\n+        if (thatTerm <= thisTerm) {\n+          response = thisTerm;\n+          logger.debug(\"{} rejected an election request, term:{}/{}\",\n+              name, thatTerm, thisTerm);\n+        } else if (thatLastLogTerm < thisLastLogTerm\n+            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+          response = Response.RESPONSE_LOG_MISMATCH;\n+        } else {\n+          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+              thisLastLogTerm);\n+          response = Response.RESPONSE_AGREE;\n         }\n-        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-      } else {\n-        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+        return response;\n       }\n-    } else {\n-      lastCatchUpResponseTime.remove(follower);\n-      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n-    }\n-  }\n \n-  public String getName() {\n-    return name;\n-  }\n+      /**\n+       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+       * follower. If some of the logs are not in memory, also send the snapshot.\n+       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+       *\n+       * @param follower\n+       * @param followerLastLogIndex\n+       */\n+      public void catchUp (Node follower,long followerLastLogIndex){\n+        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+        // for one follower, there is at most one ongoing catch-up\n+        synchronized (follower) {\n+          // check if the last catch-up is still ongoing\n+          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+          if (lastCatchupResp != null\n+              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+            return;\n+          } else {\n+            // record the start of the catch-up\n+            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+          }\n+        }\n+        if (followerLastLogIndex == -1) {\n+          // if the follower does not have any logs, send from the first one\n+          followerLastLogIndex = 0;\n+        }\n \n-  /**\n-   * @return the header of the data raft group or null if this is in a meta group.\n-   */\n-  public Node getHeader() {\n-    return null;\n-  }\n+        AsyncClient client = connectNode(follower);\n+        if (client != null) {\n+          List<Log> logs;\n+          boolean allLogsValid;\n+          Snapshot snapshot = null;\n+          synchronized (logManager) {\n+            // check if the very first log has been snapshot\n+            allLogsValid = logManager.logValid(followerLastLogIndex);\n+            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+            if (!allLogsValid) {\n+              // if the first log has been snapshot, the snapshot should also be sent to the\n+              // follower, otherwise some data will be missing\n+              snapshot = logManager.getSnapshot();\n+            }\n+          }\n \n-  /**\n-   * Forward a plan to a node using the default client.\n-   *\n-   * @param plan\n-   * @param node\n-   * @param header must be set for data group communication, set to null for meta group\n-   *               communication\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n-    if (node == thisNode || node == null) {\n-      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-      return StatusUtils.NO_LEADER;\n-    }\n+          if (allLogsValid) {\n+            if (logger.isDebugEnabled()) {\n+              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+            }\n+            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+          } else {\n+            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+          }\n+        } else {\n+          lastCatchUpResponseTime.remove(follower);\n+          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+        }\n+      }\n \n-    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+      public String getName () {\n+        return name;\n+      }\n \n-    AsyncClient client = connectNode(node);\n-    if (client != null) {\n-      return forwardPlan(plan, client, node, header);\n-    }\n-    return StatusUtils.TIME_OUT;\n-  }\n+      /**\n+       * @return the header of the data raft group or null if this is in a meta group.\n+       */\n+      public Node getHeader () {\n+        return null;\n+      }\n \n-  /**\n-   * Forward a non-query plan to \"receiver\" using \"client\".\n-   * @param plan a non-query plan\n-   * @param client\n-   * @param receiver\n-   * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n-    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-    try {\n-      plan.serializeTo(dataOutputStream);\n-      AtomicReference<TSStatus> status = new AtomicReference<>();\n-      ExecutNonQueryReq req = new ExecutNonQueryReq();\n-      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-      if (header != null) {\n-        req.setHeader(header);\n+      /**\n+       <<<<<<< HEAD\n+       * Forward a plan to a node using the default client.\n+       *\n+       * @param plan\n+       * @param node\n+      =======\n+       * Forward a non-query plan to a node using the default client.\n+       * @param plan a non-query plan\n+       * @param node cannot be the local node\n+      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c", "originalCommit": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNjI3Mg==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395426272", "bodyText": "Thanks for your reminding. I will remove them.", "author": "Ring-k", "createdAt": "2020-03-20T03:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyMzc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNDA1OA==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395424058", "bodyText": "Conflict marks.", "author": "jt2594838", "createdAt": "2020-03-20T03:24:02Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -545,424 +550,487 @@ public Node getThisNode() {\n   }\n \n \n-  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n+    /**\n+     * Sub-classes will add their own process of HeartBeatResponse in this method.\n+     * @param response\n+     * @param receiver\n+     */\n+    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n \n-  }\n-\n-  /**\n-   * The actions performed when the node wins in an election (becoming a leader).\n-   */\n-  public void onElectionWins() {\n-\n-  }\n-\n-  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n+    }\n \n-  }\n+    /**\n+     * The actions performed when the node wins in an election (becoming a leader).\n+     */\n+    public void onElectionWins () {\n \n-  /**\n-   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-   * reset heartbeat timer.\n-   * @param newTerm\n-   */\n-  public void retireFromLeader(long newTerm) {\n-    synchronized (term) {\n-      long currTerm = term.get();\n-      // confirm that the heartbeat of the new leader hasn't come\n-      if (currTerm < newTerm) {\n-        term.set(newTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        setLeader(null);\n-        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-      }\n     }\n-  }\n-\n-  /**\n-   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-   * request is valid.\n-   * @param electionRequest\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long processElectionRequest(ElectionRequest electionRequest) {\n \n-    long thatTerm = electionRequest.getTerm();\n-    long thatLastLogId = electionRequest.getLastLogIndex();\n-    long thatLastLogTerm = electionRequest.getLastLogTerm();\n-    logger.info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-        name, thatTerm,\n-        thatLastLogId, thatLastLogTerm);\n \n-    long lastLogIndex = logManager.getLastLogIndex();\n-    long lastLogTerm = logManager.getLastLogTerm();\n+      /**\n+       * Sub-classes will add their own process of HeartBeatRequest in this method.\n+       * @param request\n+       * @param response\n+       */\n+      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n \n-    synchronized (term) {\n-      long thisTerm = term.get();\n-      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-          thatLastLogTerm);\n-      if (resp == Response.RESPONSE_AGREE) {\n-        term.set(thatTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        lastHeartbeatReceivedTime = System.currentTimeMillis();\n-        leader = electionRequest.getElector();\n-        // interrupt election\n-        term.notifyAll();\n       }\n-      return resp;\n-    }\n-  }\n \n-  /**\n-   *  Reject the election if one of the four holds:\n-   *   1. the term of the candidate is no bigger than the voter's\n-   *   2. the lastLogTerm of the candidate is smaller than the voter's\n-   *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-   *      smaller than the voter's\n-   *   Otherwise accept the election.\n-   * @param thisTerm\n-   * @param thisLastLogIndex\n-   * @param thisLastLogTerm\n-   * @param thatTerm\n-   * @param thatLastLogId\n-   * @param thatLastLogTerm\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n-    long response;\n-    if (thatTerm <= thisTerm) {\n-      response = thisTerm;\n-      logger.debug(\"{} rejected an election request, term:{}/{}\",\n-          name, thatTerm, thisTerm);\n-    } else if (thatLastLogTerm < thisLastLogTerm\n-        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-      response = Response.RESPONSE_LOG_MISMATCH;\n-    } else {\n-      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-          thisLastLogTerm);\n-      response = Response.RESPONSE_AGREE;\n-    }\n-    return response;\n-  }\n-\n-  /**\n-   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-   * follower. If some of the logs are not in memory, also send the snapshot.\n-   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-   *\n-   * @param follower\n-   * @param followerLastLogIndex\n-   */\n-  public void catchUp(Node follower, long followerLastLogIndex) {\n-    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-    // for one follower, there is at most one ongoing catch-up\n-    synchronized (follower) {\n-      // check if the last catch-up is still ongoing\n-      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-      if (lastCatchupResp != null\n-          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-        return;\n-      } else {\n-        // record the start of the catch-up\n-        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      /**\n+       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n+       * reset heartbeat timer.\n+       * @param newTerm\n+       */\n+      public void retireFromLeader ( long newTerm){\n+        synchronized (term) {\n+          long currTerm = term.get();\n+          // confirm that the heartbeat of the new leader hasn't come\n+          if (currTerm < newTerm) {\n+            term.set(newTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            setLeader(null);\n+            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n+          }\n+        }\n       }\n-    }\n-    if (followerLastLogIndex == -1) {\n-      // if the follower does not have any logs, send from the first one\n-      followerLastLogIndex = 0;\n-    }\n \n-    AsyncClient client = connectNode(follower);\n-    if (client != null) {\n-      List<Log> logs;\n-      boolean allLogsValid;\n-      Snapshot snapshot = null;\n-      synchronized (logManager) {\n-        // check if the very first log has been snapshot\n-        allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-        if (!allLogsValid) {\n-          // if the first log has been snapshot, the snapshot should also be sent to the\n-          // follower, otherwise some data will be missing\n-          snapshot = logManager.getSnapshot();\n+      /**\n+       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+       * request is valid.\n+       * @param electionRequest\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long processElectionRequest (ElectionRequest electionRequest){\n+\n+        long thatTerm = electionRequest.getTerm();\n+        long thatLastLogId = electionRequest.getLastLogIndex();\n+        long thatLastLogTerm = electionRequest.getLastLogTerm();\n+        logger\n+            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+                name, thatTerm,\n+                thatLastLogId, thatLastLogTerm);\n+\n+        long lastLogIndex = logManager.getLastLogIndex();\n+        long lastLogTerm = logManager.getLastLogTerm();\n+\n+        synchronized (term) {\n+          long thisTerm = term.get();\n+          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+              thatLastLogTerm);\n+          if (resp == Response.RESPONSE_AGREE) {\n+            term.set(thatTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            lastHeartbeatReceivedTime = System.currentTimeMillis();\n+            leader = electionRequest.getElector();\n+            // interrupt election\n+            term.notifyAll();\n+          }\n+          return resp;\n         }\n       }\n \n-      if (allLogsValid) {\n-        if (logger.isDebugEnabled()) {\n-          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+      /**\n+       *  Reject the election if one of the four holds:\n+       *   1. the term of the candidate is no bigger than the voter's\n+       *   2. the lastLogTerm of the candidate is smaller than the voter's\n+       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n+       *      smaller than the voter's\n+       *   Otherwise accept the election.\n+       * @param thisTerm\n+       * @param thisLastLogIndex\n+       * @param thisLastLogTerm\n+       * @param thatTerm\n+       * @param thatLastLogId\n+       * @param thatLastLogTerm\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n+        long response;\n+        if (thatTerm <= thisTerm) {\n+          response = thisTerm;\n+          logger.debug(\"{} rejected an election request, term:{}/{}\",\n+              name, thatTerm, thisTerm);\n+        } else if (thatLastLogTerm < thisLastLogTerm\n+            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+          response = Response.RESPONSE_LOG_MISMATCH;\n+        } else {\n+          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+              thisLastLogTerm);\n+          response = Response.RESPONSE_AGREE;\n         }\n-        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-      } else {\n-        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+        return response;\n       }\n-    } else {\n-      lastCatchUpResponseTime.remove(follower);\n-      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n-    }\n-  }\n \n-  public String getName() {\n-    return name;\n-  }\n+      /**\n+       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+       * follower. If some of the logs are not in memory, also send the snapshot.\n+       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+       *\n+       * @param follower\n+       * @param followerLastLogIndex\n+       */\n+      public void catchUp (Node follower,long followerLastLogIndex){\n+        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+        // for one follower, there is at most one ongoing catch-up\n+        synchronized (follower) {\n+          // check if the last catch-up is still ongoing\n+          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+          if (lastCatchupResp != null\n+              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+            return;\n+          } else {\n+            // record the start of the catch-up\n+            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+          }\n+        }\n+        if (followerLastLogIndex == -1) {\n+          // if the follower does not have any logs, send from the first one\n+          followerLastLogIndex = 0;\n+        }\n \n-  /**\n-   * @return the header of the data raft group or null if this is in a meta group.\n-   */\n-  public Node getHeader() {\n-    return null;\n-  }\n+        AsyncClient client = connectNode(follower);\n+        if (client != null) {\n+          List<Log> logs;\n+          boolean allLogsValid;\n+          Snapshot snapshot = null;\n+          synchronized (logManager) {\n+            // check if the very first log has been snapshot\n+            allLogsValid = logManager.logValid(followerLastLogIndex);\n+            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+            if (!allLogsValid) {\n+              // if the first log has been snapshot, the snapshot should also be sent to the\n+              // follower, otherwise some data will be missing\n+              snapshot = logManager.getSnapshot();\n+            }\n+          }\n \n-  /**\n-   * Forward a plan to a node using the default client.\n-   *\n-   * @param plan\n-   * @param node\n-   * @param header must be set for data group communication, set to null for meta group\n-   *               communication\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n-    if (node == thisNode || node == null) {\n-      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-      return StatusUtils.NO_LEADER;\n-    }\n+          if (allLogsValid) {\n+            if (logger.isDebugEnabled()) {\n+              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+            }\n+            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+          } else {\n+            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+          }\n+        } else {\n+          lastCatchUpResponseTime.remove(follower);\n+          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+        }\n+      }\n \n-    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+      public String getName () {\n+        return name;\n+      }\n \n-    AsyncClient client = connectNode(node);\n-    if (client != null) {\n-      return forwardPlan(plan, client, node, header);\n-    }\n-    return StatusUtils.TIME_OUT;\n-  }\n+      /**\n+       * @return the header of the data raft group or null if this is in a meta group.\n+       */\n+      public Node getHeader () {\n+        return null;\n+      }\n \n-  /**\n-   * Forward a non-query plan to \"receiver\" using \"client\".\n-   * @param plan a non-query plan\n-   * @param client\n-   * @param receiver\n-   * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n-    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-    try {\n-      plan.serializeTo(dataOutputStream);\n-      AtomicReference<TSStatus> status = new AtomicReference<>();\n-      ExecutNonQueryReq req = new ExecutNonQueryReq();\n-      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-      if (header != null) {\n-        req.setHeader(header);\n+      /**\n+       <<<<<<< HEAD\n+       * Forward a plan to a node using the default client.\n+       *\n+       * @param plan\n+       * @param node\n+      =======\n+       * Forward a non-query plan to a node using the default client.\n+       * @param plan a non-query plan\n+       * @param node cannot be the local node\n+      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n+       * @param header must be set for data group communication, set to null for meta group\n+       *               communication\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, Node node, Node header){\n+        if (node == thisNode || node == null) {\n+          logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n+          return StatusUtils.NO_LEADER;\n+        }\n+\n+        logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+\n+        AsyncClient client = connectNode(node);\n+        if (client != null) {\n+          return forwardPlan(plan, client, node, header);\n+        }\n+        return StatusUtils.TIME_OUT;\n       }\n-      synchronized (status) {\n-        client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n-        status.wait(RaftServer.connectionTimeoutInMS);\n+\n+      /**\n+       * Forward a non-query plan to \"receiver\" using \"client\".\n+       * @param plan a non-query plan\n+       * @param client\n+       * @param receiver\n+       * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, AsyncClient client, Node receiver, Node header){\n+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n+        try {\n+          plan.serializeTo(dataOutputStream);\n+          AtomicReference<TSStatus> status = new AtomicReference<>();\n+          ExecutNonQueryReq req = new ExecutNonQueryReq();\n+          req.setPlanBytes(byteArrayOutputStream.toByteArray());\n+          if (header != null) {\n+            req.setHeader(header);\n+          }\n+          synchronized (status) {\n+            client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n+            status.wait(RaftServer.connectionTimeoutInMS);\n+          }\n+          return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n+        } catch (IOException | TException e) {\n+          TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n+          status.setMessage(e.getMessage());\n+          logger\n+              .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n+          return status;\n+        } catch (InterruptedException e) {\n+          return StatusUtils.TIME_OUT;\n+        }\n       }\n-      return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n-    } catch (IOException | TException e) {\n-      TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n-      status.setMessage(e.getMessage());\n-      logger.error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n-      return status;\n-    } catch (InterruptedException e) {\n-      return StatusUtils.TIME_OUT;\n-    }\n-  }\n \n-  /**\n-   * Only the group leader can call this method. Will commit the log locally and send it to\n-   * followers\n-   *\n-   * @param plan\n-   * @return OK if over half of the followers accept the log or null if the leadership is lost\n-   * during the appending\n-   */\n-  TSStatus processPlanLocally(PhysicalPlan plan) {\n-    logger.debug(\"{}: Processing plan {}\", name, plan);\n-    if (readOnly) {\n-      return StatusUtils.NODE_READ_ONLY;\n-    }\n+      /**\n+       <<<<<<< HEAD\n+       * Only the group leader can call this method. Will commit the log locally and send it to\n+       * followers\n+       *\n+       =======\n+       * Create a log for \"plan\" and append it locally and to all followers.\n+       * Only the group leader can call this method.\n+       * Will commit the log locally and send it to followers\n+       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c", "originalCommit": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNjI4OA==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395426288", "bodyText": "Thanks for your reminding. I will remove them.", "author": "Ring-k", "createdAt": "2020-03-20T03:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNDA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNDA4Ng==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395424086", "bodyText": "Conflict marks.", "author": "jt2594838", "createdAt": "2020-03-20T03:24:13Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -545,424 +550,487 @@ public Node getThisNode() {\n   }\n \n \n-  public void processValidHeartbeatResp(HeartbeatResponse response, Node receiver) {\n+    /**\n+     * Sub-classes will add their own process of HeartBeatResponse in this method.\n+     * @param response\n+     * @param receiver\n+     */\n+    public void processValidHeartbeatResp (HeartbeatResponse response, Node receiver){\n \n-  }\n-\n-  /**\n-   * The actions performed when the node wins in an election (becoming a leader).\n-   */\n-  public void onElectionWins() {\n-\n-  }\n-\n-  void processValidHeartbeatReq(HeartbeatRequest request, HeartbeatResponse response) {\n+    }\n \n-  }\n+    /**\n+     * The actions performed when the node wins in an election (becoming a leader).\n+     */\n+    public void onElectionWins () {\n \n-  /**\n-   * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n-   * reset heartbeat timer.\n-   * @param newTerm\n-   */\n-  public void retireFromLeader(long newTerm) {\n-    synchronized (term) {\n-      long currTerm = term.get();\n-      // confirm that the heartbeat of the new leader hasn't come\n-      if (currTerm < newTerm) {\n-        term.set(newTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        setLeader(null);\n-        setLastHeartbeatReceivedTime(System.currentTimeMillis());\n-      }\n     }\n-  }\n-\n-  /**\n-   * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n-   * request is valid.\n-   * @param electionRequest\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long processElectionRequest(ElectionRequest electionRequest) {\n \n-    long thatTerm = electionRequest.getTerm();\n-    long thatLastLogId = electionRequest.getLastLogIndex();\n-    long thatLastLogTerm = electionRequest.getLastLogTerm();\n-    logger.info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n-        name, thatTerm,\n-        thatLastLogId, thatLastLogTerm);\n \n-    long lastLogIndex = logManager.getLastLogIndex();\n-    long lastLogTerm = logManager.getLastLogTerm();\n+      /**\n+       * Sub-classes will add their own process of HeartBeatRequest in this method.\n+       * @param request\n+       * @param response\n+       */\n+      void processValidHeartbeatReq (HeartbeatRequest request, HeartbeatResponse response){\n \n-    synchronized (term) {\n-      long thisTerm = term.get();\n-      long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n-          thatLastLogTerm);\n-      if (resp == Response.RESPONSE_AGREE) {\n-        term.set(thatTerm);\n-        setCharacter(NodeCharacter.FOLLOWER);\n-        lastHeartbeatReceivedTime = System.currentTimeMillis();\n-        leader = electionRequest.getElector();\n-        // interrupt election\n-        term.notifyAll();\n       }\n-      return resp;\n-    }\n-  }\n \n-  /**\n-   *  Reject the election if one of the four holds:\n-   *   1. the term of the candidate is no bigger than the voter's\n-   *   2. the lastLogTerm of the candidate is smaller than the voter's\n-   *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n-   *      smaller than the voter's\n-   *   Otherwise accept the election.\n-   * @param thisTerm\n-   * @param thisLastLogIndex\n-   * @param thisLastLogTerm\n-   * @param thatTerm\n-   * @param thatLastLogId\n-   * @param thatLastLogTerm\n-   * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n-   * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n-   */\n-  long verifyElector(long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n-      long thatTerm, long thatLastLogId, long thatLastLogTerm) {\n-    long response;\n-    if (thatTerm <= thisTerm) {\n-      response = thisTerm;\n-      logger.debug(\"{} rejected an election request, term:{}/{}\",\n-          name, thatTerm, thisTerm);\n-    } else if (thatLastLogTerm < thisLastLogTerm\n-        || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n-      logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n-      response = Response.RESPONSE_LOG_MISMATCH;\n-    } else {\n-      logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n-          name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n-          thisLastLogTerm);\n-      response = Response.RESPONSE_AGREE;\n-    }\n-    return response;\n-  }\n-\n-  /**\n-   * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n-   * follower. If some of the logs are not in memory, also send the snapshot.\n-   * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n-   *\n-   * @param follower\n-   * @param followerLastLogIndex\n-   */\n-  public void catchUp(Node follower, long followerLastLogIndex) {\n-    // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n-    // for one follower, there is at most one ongoing catch-up\n-    synchronized (follower) {\n-      // check if the last catch-up is still ongoing\n-      Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n-      if (lastCatchupResp != null\n-          && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n-        logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n-        return;\n-      } else {\n-        // record the start of the catch-up\n-        lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+      /**\n+       * If \"newTerm\" is larger than the local term, give up the leadership, become a follower and\n+       * reset heartbeat timer.\n+       * @param newTerm\n+       */\n+      public void retireFromLeader ( long newTerm){\n+        synchronized (term) {\n+          long currTerm = term.get();\n+          // confirm that the heartbeat of the new leader hasn't come\n+          if (currTerm < newTerm) {\n+            term.set(newTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            setLeader(null);\n+            setLastHeartbeatReceivedTime(System.currentTimeMillis());\n+          }\n+        }\n       }\n-    }\n-    if (followerLastLogIndex == -1) {\n-      // if the follower does not have any logs, send from the first one\n-      followerLastLogIndex = 0;\n-    }\n \n-    AsyncClient client = connectNode(follower);\n-    if (client != null) {\n-      List<Log> logs;\n-      boolean allLogsValid;\n-      Snapshot snapshot = null;\n-      synchronized (logManager) {\n-        // check if the very first log has been snapshot\n-        allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n-        if (!allLogsValid) {\n-          // if the first log has been snapshot, the snapshot should also be sent to the\n-          // follower, otherwise some data will be missing\n-          snapshot = logManager.getSnapshot();\n+      /**\n+       * Verify the validity of an ElectionRequest, and make itself a follower of the elector if the\n+       * request is valid.\n+       * @param electionRequest\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       *   a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long processElectionRequest (ElectionRequest electionRequest){\n+\n+        long thatTerm = electionRequest.getTerm();\n+        long thatLastLogId = electionRequest.getLastLogIndex();\n+        long thatLastLogTerm = electionRequest.getLastLogTerm();\n+        logger\n+            .info(\"{} received an election request, term:{}, metaLastLogId:{}, metaLastLogTerm:{}\",\n+                name, thatTerm,\n+                thatLastLogId, thatLastLogTerm);\n+\n+        long lastLogIndex = logManager.getLastLogIndex();\n+        long lastLogTerm = logManager.getLastLogTerm();\n+\n+        synchronized (term) {\n+          long thisTerm = term.get();\n+          long resp = verifyElector(thisTerm, lastLogIndex, lastLogTerm, thatTerm, thatLastLogId,\n+              thatLastLogTerm);\n+          if (resp == Response.RESPONSE_AGREE) {\n+            term.set(thatTerm);\n+            setCharacter(NodeCharacter.FOLLOWER);\n+            lastHeartbeatReceivedTime = System.currentTimeMillis();\n+            leader = electionRequest.getElector();\n+            // interrupt election\n+            term.notifyAll();\n+          }\n+          return resp;\n         }\n       }\n \n-      if (allLogsValid) {\n-        if (logger.isDebugEnabled()) {\n-          logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+      /**\n+       *  Reject the election if one of the four holds:\n+       *   1. the term of the candidate is no bigger than the voter's\n+       *   2. the lastLogTerm of the candidate is smaller than the voter's\n+       *   3. the lastLogTerm of the candidate equals to the voter's but its lastLogIndex is\n+       *      smaller than the voter's\n+       *   Otherwise accept the election.\n+       * @param thisTerm\n+       * @param thisLastLogIndex\n+       * @param thisLastLogTerm\n+       * @param thatTerm\n+       * @param thatLastLogId\n+       * @param thatLastLogTerm\n+       * @return Response.RESPONSE_AGREE if the elector is valid or the local term if the elector has\n+       * a smaller term or Response.RESPONSE_LOG_MISMATCH if the elector has older logs.\n+       */\n+      long verifyElector ( long thisTerm, long thisLastLogIndex, long thisLastLogTerm,\n+      long thatTerm, long thatLastLogId, long thatLastLogTerm){\n+        long response;\n+        if (thatTerm <= thisTerm) {\n+          response = thisTerm;\n+          logger.debug(\"{} rejected an election request, term:{}/{}\",\n+              name, thatTerm, thisTerm);\n+        } else if (thatLastLogTerm < thisLastLogTerm\n+            || (thatLastLogTerm == thisLastLogTerm && thatLastLogId < thisLastLogIndex)) {\n+          logger.debug(\"{} rejected an election request, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatLastLogId, thisLastLogIndex, thatLastLogTerm, thisLastLogTerm);\n+          response = Response.RESPONSE_LOG_MISMATCH;\n+        } else {\n+          logger.debug(\"{} accepted an election request, term:{}/{}, logIndex:{}/{}, logTerm:{}/{}\",\n+              name, thatTerm, thisTerm, thatLastLogId, thisLastLogIndex, thatLastLogTerm,\n+              thisLastLogTerm);\n+          response = Response.RESPONSE_AGREE;\n         }\n-        catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n-      } else {\n-        logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n-        catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+        return response;\n       }\n-    } else {\n-      lastCatchUpResponseTime.remove(follower);\n-      logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n-    }\n-  }\n \n-  public String getName() {\n-    return name;\n-  }\n+      /**\n+       * Update the followers' log by sending logs whose index >= followerLastMatchedLogIndex to the\n+       * follower. If some of the logs are not in memory, also send the snapshot.\n+       * <br>notice that if a part of data is in the snapshot, then it is not in the logs</>\n+       *\n+       * @param follower\n+       * @param followerLastLogIndex\n+       */\n+      public void catchUp (Node follower,long followerLastLogIndex){\n+        // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex\n+        // for one follower, there is at most one ongoing catch-up\n+        synchronized (follower) {\n+          // check if the last catch-up is still ongoing\n+          Long lastCatchupResp = lastCatchUpResponseTime.get(follower);\n+          if (lastCatchupResp != null\n+              && System.currentTimeMillis() - lastCatchupResp < RaftServer.connectionTimeoutInMS) {\n+            logger.debug(\"{}: last catch up of {} is ongoing\", name, follower);\n+            return;\n+          } else {\n+            // record the start of the catch-up\n+            lastCatchUpResponseTime.put(follower, System.currentTimeMillis());\n+          }\n+        }\n+        if (followerLastLogIndex == -1) {\n+          // if the follower does not have any logs, send from the first one\n+          followerLastLogIndex = 0;\n+        }\n \n-  /**\n-   * @return the header of the data raft group or null if this is in a meta group.\n-   */\n-  public Node getHeader() {\n-    return null;\n-  }\n+        AsyncClient client = connectNode(follower);\n+        if (client != null) {\n+          List<Log> logs;\n+          boolean allLogsValid;\n+          Snapshot snapshot = null;\n+          synchronized (logManager) {\n+            // check if the very first log has been snapshot\n+            allLogsValid = logManager.logValid(followerLastLogIndex);\n+            logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n+            if (!allLogsValid) {\n+              // if the first log has been snapshot, the snapshot should also be sent to the\n+              // follower, otherwise some data will be missing\n+              snapshot = logManager.getSnapshot();\n+            }\n+          }\n \n-  /**\n-   * Forward a plan to a node using the default client.\n-   *\n-   * @param plan\n-   * @param node\n-   * @param header must be set for data group communication, set to null for meta group\n-   *               communication\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, Node node, Node header) {\n-    if (node == thisNode || node == null) {\n-      logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n-      return StatusUtils.NO_LEADER;\n-    }\n+          if (allLogsValid) {\n+            if (logger.isDebugEnabled()) {\n+              logger.debug(\"{} makes {} catch up with {} cached logs\", name, follower, logs.size());\n+            }\n+            catchUpService.submit(new LogCatchUpTask(logs, follower, this));\n+          } else {\n+            logger.debug(\"{}: Logs in {} are too old, catch up with snapshot\", name, follower);\n+            catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));\n+          }\n+        } else {\n+          lastCatchUpResponseTime.remove(follower);\n+          logger.warn(\"{}: Catch-up failed: node {} is currently unavailable\", name, follower);\n+        }\n+      }\n \n-    logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+      public String getName () {\n+        return name;\n+      }\n \n-    AsyncClient client = connectNode(node);\n-    if (client != null) {\n-      return forwardPlan(plan, client, node, header);\n-    }\n-    return StatusUtils.TIME_OUT;\n-  }\n+      /**\n+       * @return the header of the data raft group or null if this is in a meta group.\n+       */\n+      public Node getHeader () {\n+        return null;\n+      }\n \n-  /**\n-   * Forward a non-query plan to \"receiver\" using \"client\".\n-   * @param plan a non-query plan\n-   * @param client\n-   * @param receiver\n-   * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n-   * @return a TSStatus indicating if the forwarding is successful.\n-   */\n-  TSStatus forwardPlan(PhysicalPlan plan, AsyncClient client, Node receiver, Node header) {\n-    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n-    DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n-    try {\n-      plan.serializeTo(dataOutputStream);\n-      AtomicReference<TSStatus> status = new AtomicReference<>();\n-      ExecutNonQueryReq req = new ExecutNonQueryReq();\n-      req.setPlanBytes(byteArrayOutputStream.toByteArray());\n-      if (header != null) {\n-        req.setHeader(header);\n+      /**\n+       <<<<<<< HEAD\n+       * Forward a plan to a node using the default client.\n+       *\n+       * @param plan\n+       * @param node\n+      =======\n+       * Forward a non-query plan to a node using the default client.\n+       * @param plan a non-query plan\n+       * @param node cannot be the local node\n+      >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n+       * @param header must be set for data group communication, set to null for meta group\n+       *               communication\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, Node node, Node header){\n+        if (node == thisNode || node == null) {\n+          logger.debug(\"{}: plan {} has no where to be forwarded\", name, plan);\n+          return StatusUtils.NO_LEADER;\n+        }\n+\n+        logger.info(\"{}: Forward {} to node {}\", name, plan, node);\n+\n+        AsyncClient client = connectNode(node);\n+        if (client != null) {\n+          return forwardPlan(plan, client, node, header);\n+        }\n+        return StatusUtils.TIME_OUT;\n       }\n-      synchronized (status) {\n-        client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n-        status.wait(RaftServer.connectionTimeoutInMS);\n+\n+      /**\n+       * Forward a non-query plan to \"receiver\" using \"client\".\n+       * @param plan a non-query plan\n+       * @param client\n+       * @param receiver\n+       * @param header to determine which DataGroupMember of \"receiver\" will process the request.\n+       * @return a TSStatus indicating if the forwarding is successful.\n+       */\n+      TSStatus forwardPlan (PhysicalPlan plan, AsyncClient client, Node receiver, Node header){\n+        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);\n+        try {\n+          plan.serializeTo(dataOutputStream);\n+          AtomicReference<TSStatus> status = new AtomicReference<>();\n+          ExecutNonQueryReq req = new ExecutNonQueryReq();\n+          req.setPlanBytes(byteArrayOutputStream.toByteArray());\n+          if (header != null) {\n+            req.setHeader(header);\n+          }\n+          synchronized (status) {\n+            client.executeNonQueryPlan(req, new ForwardPlanHandler(status, plan, receiver));\n+            status.wait(RaftServer.connectionTimeoutInMS);\n+          }\n+          return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n+        } catch (IOException | TException e) {\n+          TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n+          status.setMessage(e.getMessage());\n+          logger\n+              .error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n+          return status;\n+        } catch (InterruptedException e) {\n+          return StatusUtils.TIME_OUT;\n+        }\n       }\n-      return status.get() == null ? StatusUtils.TIME_OUT : status.get();\n-    } catch (IOException | TException e) {\n-      TSStatus status = StatusUtils.INTERNAL_ERROR.deepCopy();\n-      status.setMessage(e.getMessage());\n-      logger.error(\"{}: encountered an error when forwarding {} to {}\", name, plan, receiver, e);\n-      return status;\n-    } catch (InterruptedException e) {\n-      return StatusUtils.TIME_OUT;\n-    }\n-  }\n \n-  /**\n-   * Only the group leader can call this method. Will commit the log locally and send it to\n-   * followers\n-   *\n-   * @param plan\n-   * @return OK if over half of the followers accept the log or null if the leadership is lost\n-   * during the appending\n-   */\n-  TSStatus processPlanLocally(PhysicalPlan plan) {\n-    logger.debug(\"{}: Processing plan {}\", name, plan);\n-    if (readOnly) {\n-      return StatusUtils.NODE_READ_ONLY;\n-    }\n+      /**\n+       <<<<<<< HEAD\n+       * Only the group leader can call this method. Will commit the log locally and send it to\n+       * followers\n+       *\n+       =======\n+       * Create a log for \"plan\" and append it locally and to all followers.\n+       * Only the group leader can call this method.\n+       * Will commit the log locally and send it to followers\n+       >>>>>>> 378da6117d05a7e38d05fb46cb20b3023434c08c\n+       * @param plan\n+       * @return OK if over half of the followers accept the log or null if the leadership is lost\n+       * during the appending\n+       */\n+      TSStatus processPlanLocally (PhysicalPlan plan){\n+        logger.debug(\"{}: Processing plan {}\", name, plan);\n+        if (readOnly) {\n+          return StatusUtils.NODE_READ_ONLY;\n+        }\n \n-    PhysicalPlanLog log = new PhysicalPlanLog();\n-    // assign term and index to the new log and append it\n-    synchronized (logManager) {\n-      log.setCurrLogTerm(getTerm().get());\n-      log.setPreviousLogIndex(logManager.getLastLogIndex());\n-      log.setPreviousLogTerm(logManager.getLastLogTerm());\n-      log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n+        PhysicalPlanLog log = new PhysicalPlanLog();\n+        // assign term and index to the new log and append it\n+        synchronized (logManager) {\n+          log.setCurrLogTerm(getTerm().get());\n+          log.setPreviousLogIndex(logManager.getLastLogIndex());\n+          log.setPreviousLogTerm(logManager.getLastLogTerm());\n+          log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n \n-      log.setPlan(plan);\n-      logManager.appendLog(log);\n-    }\n+          log.setPlan(plan);\n+          logManager.appendLog(log);\n+        }\n \n-    if (appendLogInGroup(log)) {\n-      return StatusUtils.OK;\n-    }\n-    return null;\n-  }\n+        if (appendLogInGroup(log)) {\n+          return StatusUtils.OK;\n+        }\n+        return null;\n+      }\n \n-  /**\n-   * if the node is not a leader, will send it to the leader. Otherwise do it locally (whether to\n-   * send it to followers depends on the implementation of executeNonQuery()).\n-   *\n-   * @param request\n-   * @param resultHandler\n-   */\n-  public void executeNonQueryPlan(ExecutNonQueryReq request,\n-      AsyncMethodCallback<TSStatus> resultHandler) {\n-    if (character != NodeCharacter.LEADER) {\n-      // forward the plan to the leader\n-      AsyncClient client = connectNode(leader);\n-      if (client != null) {\n+      /**\n+       <<<<<<< HEAD\n+       * if the node is not a leader, will send it to the leader. Otherwise do it locally (whether to\n+       * send it to followers depends on the implementation of executeNonQuery()).\n+       *\n+       =======\n+       * Append a log to all followers in the group until half of them accept the log or the\n+       * leadership is lost.\n+       * @param log\n+       * @return true if the log is accepted by the quorum of the group, false otherwise", "originalCommit": "79b40fbb1b17649d63ac64fdbc0c0fd5202d78dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNjI5Nw==", "url": "https://github.com/apache/iotdb/pull/909#discussion_r395426297", "bodyText": "Thanks for your reminding. I will remove them.", "author": "Ring-k", "createdAt": "2020-03-20T03:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQyNDA4Ng=="}], "type": "inlineReview"}, {"oid": "5fcb9f0786aee2f36e1b224931059371cfc9b465", "url": "https://github.com/apache/iotdb/commit/5fcb9f0786aee2f36e1b224931059371cfc9b465", "message": "fix conflict in RaftMember", "committedDate": "2020-03-20T03:36:02Z", "type": "commit"}]}