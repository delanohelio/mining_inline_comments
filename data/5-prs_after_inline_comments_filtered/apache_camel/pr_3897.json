{"pr_number": 3897, "pr_title": "CAMEL-13934 camel-minio - Component to store/load files from blob store", "pr_createdAt": "2020-06-07T21:45:18Z", "pr_url": "https://github.com/apache/camel/pull/3897", "timeline": [{"oid": "18ec4f679abc44faac6792ddc5a619a880e05e93", "url": "https://github.com/apache/camel/commit/18ec4f679abc44faac6792ddc5a619a880e05e93", "message": "Replaced redundant checks with centralized lambdas", "committedDate": "2020-08-08T16:44:10Z", "type": "forcePushed"}, {"oid": "4e7587acde63bffaa8966d15689af206cb9577d9", "url": "https://github.com/apache/camel/commit/4e7587acde63bffaa8966d15689af206cb9577d9", "message": "Changed the error message in checkAndSetRegistryClient in MinioComponent.java", "committedDate": "2020-08-08T17:17:25Z", "type": "commit"}, {"oid": "9f619c84b46945598c63f1d7ad04cdefa1329d39", "url": "https://github.com/apache/camel/commit/9f619c84b46945598c63f1d7ad04cdefa1329d39", "message": "Fixed article issues in minio-component.adoc and unused parameter", "committedDate": "2020-08-08T17:46:46Z", "type": "commit"}, {"oid": "5ce02877a27e4c44242760f1bd7af412bd220664", "url": "https://github.com/apache/camel/commit/5ce02877a27e4c44242760f1bd7af412bd220664", "message": "Mimicked aws2-s3 component, ran mvn clean install -DskipTests", "committedDate": "2020-08-09T03:36:30Z", "type": "commit"}, {"oid": "ae457d0c7b0907f3ede8722baf1eec49803d60d4", "url": "https://github.com/apache/camel/commit/ae457d0c7b0907f3ede8722baf1eec49803d60d4", "message": "Minor fixes", "committedDate": "2020-08-09T06:27:38Z", "type": "commit"}, {"oid": "7e7c617cce3dc8ee50b2c4eaf46d9730918ce63d", "url": "https://github.com/apache/camel/commit/7e7c617cce3dc8ee50b2c4eaf46d9730918ce63d", "message": "Resolved a TODO", "committedDate": "2020-08-09T16:10:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDc5NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436470795", "bodyText": "This class can be removed.", "author": "oscerd", "createdAt": "2020-06-08T05:56:38Z", "path": "components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Used for demonstrations purpose to simulate some external system event bus/broker, where messages are sent to, and\n+ * this component can consume from.\n+ */\n+public class EventBusHelper {", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MjQzNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r437672436", "bodyText": "Hi thank you for the suggestion, and I'll remove this for sure. But I'll keep it for a while for some random hello world kind tests while on the go. :)", "author": "Nayananga", "createdAt": "2020-06-09T19:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDk1MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436470950", "bodyText": "You can use directly Component annotation without the whole package.", "author": "oscerd", "createdAt": "2020-06-08T05:57:13Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import java.util.Map;\n+\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.Endpoint;\n+\n+import org.apache.camel.support.DefaultComponent;\n+\n+@org.apache.camel.spi.annotations.Component(\"MinIO\")", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTE0NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436471145", "bodyText": "Remove the eventBusHelper, except it is something really useful to the basic feature of component, but I don't think so.", "author": "oscerd", "createdAt": "2020-06-08T05:58:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Exchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.support.DefaultConsumer;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+public class MinIOConsumer extends DefaultConsumer {\n+    private final MinIOEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n+\n+    private ExecutorService executorService;\n+\n+    public MinIOConsumer(MinIOEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3Mzg1MQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r437673851", "bodyText": "Hi thank you for the suggestion, and I'll remove this for sure. But I'll keep it for a while for some random hello world kind tests while on the go. :)", "author": "Nayananga", "createdAt": "2020-06-09T19:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTE0NQ=="}], "type": "inlineReview"}, {"oid": "ece2cb7569d380486b4a0187ac97b3fac0574bbd", "url": "https://github.com/apache/camel/commit/ece2cb7569d380486b4a0187ac97b3fac0574bbd", "message": "Added auto generated files", "committedDate": "2020-06-10T04:13:01Z", "type": "forcePushed"}, {"oid": "2acf3087813b7b772b0efa5415212d4aa26495cd", "url": "https://github.com/apache/camel/commit/2acf3087813b7b772b0efa5415212d4aa26495cd", "message": "Updated minio-component.adoc file", "committedDate": "2020-06-12T13:33:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NjMzMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r439466333", "bodyText": "Maybe firstVersion could be set to 3.5.0 or something like that.", "author": "DenisIstomin", "createdAt": "2020-06-12T14:50:31Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.support.DefaultEndpoint;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * MinIO component which does bla bla.\n+ *\n+ * TODO: Update one line description above what the component does.\n+ */\n+@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",", "originalCommit": "2acf3087813b7b772b0efa5415212d4aa26495cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NjY0NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r439466644", "bodyText": "And maybe scheme could be lowercase, like \"minio\"", "author": "DenisIstomin", "createdAt": "2020-06-12T14:51:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.support.DefaultEndpoint;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * MinIO component which does bla bla.\n+ *\n+ * TODO: Update one line description above what the component does.\n+ */\n+@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",", "originalCommit": "2acf3087813b7b772b0efa5415212d4aa26495cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c26cc5d467d572180ba8a6a0d42bf52967b32010", "url": "https://github.com/apache/camel/commit/c26cc5d467d572180ba8a6a0d42bf52967b32010", "message": "Code fixed for camel-checkstyle", "committedDate": "2020-06-12T20:41:12Z", "type": "forcePushed"}, {"oid": "39e847ad781ca35a4d69735cf9d92c47aeeba0d0", "url": "https://github.com/apache/camel/commit/39e847ad781ca35a4d69735cf9d92c47aeeba0d0", "message": "Code fixed for camel-checkstyle", "committedDate": "2020-06-13T06:41:19Z", "type": "forcePushed"}, {"oid": "1e7d342708e717f9299d7b55ef435ac776e616e9", "url": "https://github.com/apache/camel/commit/1e7d342708e717f9299d7b55ef435ac776e616e9", "message": "Recommended changes done", "committedDate": "2020-06-13T07:28:48Z", "type": "forcePushed"}, {"oid": "a0538d43806eac5d88a4b6cb9ee7fcea97a0ad41", "url": "https://github.com/apache/camel/commit/a0538d43806eac5d88a4b6cb9ee7fcea97a0ad41", "message": "Recommended changes done", "committedDate": "2020-06-13T08:03:57Z", "type": "forcePushed"}, {"oid": "c1f4c4a57e9b85b40cd531746b0f98b98f9fc66c", "url": "https://github.com/apache/camel/commit/c1f4c4a57e9b85b40cd531746b0f98b98f9fc66c", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-06-13T22:09:26Z", "type": "forcePushed"}, {"oid": "d965cdf77194a40ee48877e4551ef97e63c692e7", "url": "https://github.com/apache/camel/commit/d965cdf77194a40ee48877e4551ef97e63c692e7", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-06-14T03:07:03Z", "type": "forcePushed"}, {"oid": "557c54ccc663f5b0b044f80629973afd8ceacb28", "url": "https://github.com/apache/camel/commit/557c54ccc663f5b0b044f80629973afd8ceacb28", "message": "Code reformatted", "committedDate": "2020-06-18T04:28:40Z", "type": "forcePushed"}, {"oid": "c9282c3f360308ad99724fb7ebf3aecf16ffe7b8", "url": "https://github.com/apache/camel/commit/c9282c3f360308ad99724fb7ebf3aecf16ffe7b8", "message": "Updated imports", "committedDate": "2020-06-18T21:18:28Z", "type": "forcePushed"}, {"oid": "1fe1eda807af55348e41b0a61fd601003f7e1360", "url": "https://github.com/apache/camel/commit/1fe1eda807af55348e41b0a61fd601003f7e1360", "message": "Updated camel version in camel-mino/pom.xml", "committedDate": "2020-06-19T16:16:43Z", "type": "forcePushed"}, {"oid": "f46f2996d879c333635e764484ec74d5deb2b890", "url": "https://github.com/apache/camel/commit/f46f2996d879c333635e764484ec74d5deb2b890", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-24T22:11:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjkxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445202915", "bodyText": "@oscerd @DenisIstomin What kind of approach suitable here? AWS2 S3 component have use something like this\nListObjectsRequest.Builder listObjectsRequest = ListObjectsRequest.builder();\n            listObjectsRequest.bucket(bucketName);\n            listObjectsRequest.prefix(getConfiguration().getPrefix());\n            listObjectsRequest.delimiter(getConfiguration().getDelimiter());", "author": "Nayananga", "createdAt": "2020-06-24T22:18:37Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {", "originalCommit": "f46f2996d879c333635e764484ec74d5deb2b890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwMjk1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445302954", "bodyText": "you could use https://docs.min.io/docs/java-client-api-reference.html#listObjects @Nayananga", "author": "oscerd", "createdAt": "2020-06-25T04:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445307693", "bodyText": "Hi @oscerd, here if users haven't provided any objectName then my intention is to pull all the objects in the bucket using Iterator named marker, first I would like to know is that ok to do?", "author": "Nayananga", "createdAt": "2020-06-25T05:00:48Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,", "originalCommit": "f46f2996d879c333635e764484ec74d5deb2b890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwODYzNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445308634", "bodyText": "Hello @Nayananga , yes it is ok. You can do that and then process the result as a batch, like the S3 AWS2 component does.", "author": "oscerd", "createdAt": "2020-06-25T05:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMxMDY0NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445310644", "bodyText": "Thank you, is it okay to queue all the bucket objects (may take lot memory I guess) then send to  processBatch(CastUtils.cast(exchanges))? because in minio I had to queue each object in a Queue<Object> until iterator.hasNext() return false", "author": "Nayananga", "createdAt": "2020-06-25T05:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMxMTc5MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445311790", "bodyText": "Not all the objects in one call, you need to define a limit for the batch, like setMaxKeys in AWS2 S3 component https://github.com/apache/camel/blob/master/components/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/AWS2S3Consumer.java#L88", "author": "oscerd", "createdAt": "2020-06-25T05:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}], "type": "inlineReview"}, {"oid": "7174a3c85fdc5148e794521a6e86ca82d3520f2f", "url": "https://github.com/apache/camel/commit/7174a3c85fdc5148e794521a6e86ca82d3520f2f", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-25T21:54:51Z", "type": "forcePushed"}, {"oid": "58e3d1b028374ac69716844c063623003d33c19f", "url": "https://github.com/apache/camel/commit/58e3d1b028374ac69716844c063623003d33c19f", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-27T21:34:59Z", "type": "forcePushed"}, {"oid": "6040d1fa742dea91463f02238c51de4ef432b5e6", "url": "https://github.com/apache/camel/commit/6040d1fa742dea91463f02238c51de4ef432b5e6", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-28T09:42:08Z", "type": "forcePushed"}, {"oid": "303b36dc012fe0439b1ef3f9127489227fade0cc", "url": "https://github.com/apache/camel/commit/303b36dc012fe0439b1ef3f9127489227fade0cc", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-07-02T20:46:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0OTY3OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449649678", "bodyText": "Maybe you should avoid using assert. It is not enabled by default. It would be better to handle that with if condition.", "author": "DenisIstomin", "createdAt": "2020-07-03T16:15:31Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.*;\n+\n+import io.minio.DownloadObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.AsyncCallback;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.NoFactoryAvailableException;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        assert getConfiguration().getBucketName() != null;", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDM4Ng==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449650386", "bodyText": "Maybe try-with-resources could be used here. It would be nice to reduce nesting.", "author": "DenisIstomin", "createdAt": "2020-07-03T16:18:04Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.*;\n+\n+import io.minio.DownloadObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.AsyncCallback;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.NoFactoryAvailableException;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        assert getConfiguration().getBucketName() != null;\n+        String bucketName = getConfiguration().getBucketName();\n+        MinioClient minioClient = getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        InputStream minioObject = null;\n+        Queue<Exchange> exchanges = null;\n+\n+        if (bucketExists(minioClient, bucketName)) {\n+            LOG.trace(\"Bucket {} exists\", bucketName);\n+        } else {\n+            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n+        }\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            try {\n+                minioObject = getObject(bucketName, minioClient, objectName);\n+                if (minioObject != null) {\n+                    exchanges = createExchanges(minioObject, objectName);\n+                }\n+\n+            } catch (Throwable e) {\n+                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n+                throw e;\n+\n+            } finally {\n+                //must be closed after use to release network resources.\n+                try {\n+                    assert minioObject != null;\n+                    minioObject.close();", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDk3Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449650977", "bodyText": "Typo: retrieve", "author": "DenisIstomin", "createdAt": "2020-07-03T16:20:17Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import io.minio.GetObjectTagsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.messages.Tags;\n+import jdk.internal.org.jline.utils.Log;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrie objects from Minio Storage Service using Minio SDK.", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTU3OQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449651579", "bodyText": "Looks like that test should fail, because there are no messages being sent.", "author": "DenisIstomin", "createdAt": "2020-07-03T16:22:46Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit4.CamelTestSupport;\n+import org.junit.Test;\n+\n+public class MinioComponentTest extends CamelTestSupport {\n+\n+    @Test\n+    public void testMinio() throws Exception {\n+        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n+        mock.expectedMinimumMessageCount(1);\n+\n+        assertMockEndpointsSatisfied();", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc2MDE4NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449760185", "bodyText": "ack, I haven't look into tests yet, I'll work on these asap :)", "author": "Nayananga", "createdAt": "2020-07-04T10:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTU3OQ=="}], "type": "inlineReview"}, {"oid": "eb8a5eab91055dbefb8eb2a664bc6efc02068922", "url": "https://github.com/apache/camel/commit/eb8a5eab91055dbefb8eb2a664bc6efc02068922", "message": "Added message headers in MinioEndpoint", "committedDate": "2020-07-07T20:00:00Z", "type": "forcePushed"}, {"oid": "9a61617593bd21370a09598b54c766d167a9484c", "url": "https://github.com/apache/camel/commit/9a61617593bd21370a09598b54c766d167a9484c", "message": "Completed porting AWS2 S3 component", "committedDate": "2020-07-09T14:43:55Z", "type": "forcePushed"}, {"oid": "c03064959bc92443b06333578b1c3a212adb8012", "url": "https://github.com/apache/camel/commit/c03064959bc92443b06333578b1c3a212adb8012", "message": "Updated to Minio 7.1.0", "committedDate": "2020-07-09T23:42:26Z", "type": "forcePushed"}, {"oid": "6aa5e647d00ee7dae2c321f22f01b45b03f2cbd4", "url": "https://github.com/apache/camel/commit/6aa5e647d00ee7dae2c321f22f01b45b03f2cbd4", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-07-10T18:45:31Z", "type": "forcePushed"}, {"oid": "6321e33f3fd832d2af57dc8c5e2d8b966cc7f97e", "url": "https://github.com/apache/camel/commit/6321e33f3fd832d2af57dc8c5e2d8b966cc7f97e", "message": "Include integration Tests", "committedDate": "2020-07-13T22:08:02Z", "type": "forcePushed"}, {"oid": "311972bb833e08423b081d8268f686355cdcc161", "url": "https://github.com/apache/camel/commit/311972bb833e08423b081d8268f686355cdcc161", "message": "Code Reformatted", "committedDate": "2020-07-15T23:25:21Z", "type": "forcePushed"}, {"oid": "3878b763e4e472b798d59f32e77fe5d52b7d4446", "url": "https://github.com/apache/camel/commit/3878b763e4e472b798d59f32e77fe5d52b7d4446", "message": "Ran Integration tests", "committedDate": "2020-07-16T22:20:43Z", "type": "forcePushed"}, {"oid": "aa7ba42bf24225df0036f6164360b5067781d18b", "url": "https://github.com/apache/camel/commit/aa7ba42bf24225df0036f6164360b5067781d18b", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-07-19T04:14:27Z", "type": "forcePushed"}, {"oid": "0faf24a60a7eaffb51af24f8ac2f15b83b3f8219", "url": "https://github.com/apache/camel/commit/0faf24a60a7eaffb51af24f8ac2f15b83b3f8219", "message": "Added documentation", "committedDate": "2020-07-19T18:43:50Z", "type": "forcePushed"}, {"oid": "e6028a86cd2018454b7d0d65938785171b6d02ab", "url": "https://github.com/apache/camel/commit/e6028a86cd2018454b7d0d65938785171b6d02ab", "message": "Minor changes to the tests", "committedDate": "2020-07-24T15:58:23Z", "type": "forcePushed"}, {"oid": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "url": "https://github.com/apache/camel/commit/ca963a048e1beb422fdf86ed84790523e9fd4b76", "message": "Fixed typo", "committedDate": "2020-07-25T18:22:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyODIxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460728216", "bodyText": "labels are missing here, for example producer, consumer, common ..etc", "author": "omarsmak", "createdAt": "2020-07-27T08:29:11Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java", "diffHunk": "@@ -0,0 +1,641 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.time.ZonedDateTime;\n+\n+import io.minio.MinioClient;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import okhttp3.OkHttpClient;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriParams;\n+\n+@UriParams\n+public class MinioConfiguration implements Cloneable {\n+\n+    @UriParam\n+    private String endpoint;\n+    @UriParam\n+    private Integer proxyPort;\n+\n+    @UriParam(label = \"security\", secret = true)\n+    private String accessKey;\n+    @UriParam(label = \"security\", secret = true)\n+    private String secretKey;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean secure;\n+\n+    @UriParam", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyOTQyOQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460729429", "bodyText": "Please avoid wildcard import", "author": "omarsmak", "createdAt": "2020-07-27T08:31:06Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460731257", "bodyText": "Should we handle this exception as well?", "author": "omarsmak", "createdAt": "2020-07-27T08:34:15Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange ...\");\n+            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n+        try {\n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+\n+            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n+                if (getConfiguration().isMoveAfterRead()) {\n+                    copyObject(srcBucketName, srcObjectName);\n+                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n+                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n+                }\n+\n+                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+\n+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                        .bucket(srcBucketName)\n+                        .object(srcObjectName)\n+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+                if (getConfiguration().getVersionId() != null) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                if (getConfiguration().isBypassGovernanceMode()) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                getMinioClient().removeObject(removeObjectRequest.build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n+                    exchange, e);\n+        } catch (Exception e) {\n+            LOG.trace(\"Error process commit...\");", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA4ODI0Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464088247", "bodyText": "Hi @omarsmak this has to handle since getMinioClient().removeObject(removeObjectRequest.build()); throws an error", "author": "Nayananga", "createdAt": "2020-08-02T15:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2OTIxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464269216", "bodyText": "What I mean here, does it make sense to handle it through  getExceptionHandler().handleException", "author": "omarsmak", "createdAt": "2020-08-03T08:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxNDAyMQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464614021", "bodyText": "Hi, @omarsmak I was mimicking this line. should I keep this or change it to maybe LOG.warn?", "author": "Nayananga", "createdAt": "2020-08-03T19:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg4NjIxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464886215", "bodyText": "@Nayananga my question is about catching Exception e, do you need your consumer to ignore all exceptions (as the case now) or you need your consumer to throw  and halt camel process in case minio client throw any exceptions other than MinioException? My gut feeling, you may just need to remove catch (Exception e) block and only handle MinioException as you are currently doing, by that camel will halt its process in any unexpected process.", "author": "omarsmak", "createdAt": "2020-08-04T08:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxNTU3OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466215578", "bodyText": "Hi @omarsmak, thank you for your suggestion. I did some changes :)", "author": "Nayananga", "createdAt": "2020-08-06T07:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460731754", "bodyText": "Same here, should handle this exception as well?", "author": "omarsmak", "createdAt": "2020-07-27T08:35:06Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange ...\");\n+            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n+        try {\n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+\n+            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n+                if (getConfiguration().isMoveAfterRead()) {\n+                    copyObject(srcBucketName, srcObjectName);\n+                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n+                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n+                }\n+\n+                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+\n+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                        .bucket(srcBucketName)\n+                        .object(srcObjectName)\n+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+                if (getConfiguration().getVersionId() != null) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                if (getConfiguration().isBypassGovernanceMode()) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                getMinioClient().removeObject(removeObjectRequest.build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n+                    exchange, e);\n+        } catch (Exception e) {\n+            LOG.trace(\"Error process commit...\");\n+        }\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) {\n+        String destinationBucketName = getConfiguration().getDestinationBucketName();\n+        if (destinationBucketName == null) {\n+            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n+        }\n+\n+        try {\n+            // set destination object name as source object name, if not specified\n+            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n+                    ? getConfiguration().getDestinationObjectName()\n+                    : srcObjectName;\n+\n+\n+            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                    srcBucketName, srcObjectName, destinationBucketName);\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n+            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+            }\n+            if (getConfiguration().getOffset() != 0) {\n+                copySourceBuilder.offset(getConfiguration().getOffset());\n+            }\n+            if (getConfiguration().getLength() != 0) {\n+                copySourceBuilder.length(getConfiguration().getLength());\n+            }\n+            if (getConfiguration().getVersionId() != null) {\n+                copySourceBuilder.versionId(getConfiguration().getVersionId());\n+            }\n+            if (getConfiguration().getMatchETag() != null) {\n+                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n+            }\n+            if (getConfiguration().getNotMatchETag() != null) {\n+                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n+            }\n+            if (getConfiguration().getModifiedSince() != null) {\n+                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n+            }\n+            if (getConfiguration().getUnModifiedSince() != null) {\n+                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+            }\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .source(copySourceBuilder.build())\n+                    .bucket(getConfiguration().getDestinationBucketName())\n+                    .object(destinationObjectName);\n+\n+            if (getConfiguration().getServerSideEncryption() != null) {\n+                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n+            }\n+\n+            getMinioClient().copyObject(copyObjectRequest.build());\n+\n+        } catch (Exception e) {\n+            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA4ODM1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464088357", "bodyText": "Hi @omarsmak this has to handle since getMinioClient().copyObject(copyObjectRequest.build()); throws an error", "author": "Nayananga", "createdAt": "2020-08-02T15:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMDUyMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464620523", "bodyText": "I'll remove this error handle since this is redundant", "author": "Nayananga", "createdAt": "2020-08-03T19:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0MDMyMQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460740321", "bodyText": "I am bit not comfortable of having check with not equal 0, odd cases like minus could slip. I'd recommend changing this to > 0 instead. Same for the other checks", "author": "omarsmak", "createdAt": "2020-07-27T08:49:28Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0Nzk0OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460747948", "bodyText": "Perhaps we can use isNotEmpty from org.apache.camel.util.ObjectHelper to check for nulls or emptyness", "author": "omarsmak", "createdAt": "2020-07-27T09:01:43Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MDQxMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460750413", "bodyText": "I don't see any reason to null the client here, isn't?", "author": "omarsmak", "createdAt": "2020-07-27T09:06:05Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MTMxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460751316", "bodyText": "please don't print the stack trace here, instead handle the exception.", "author": "omarsmak", "createdAt": "2020-07-27T09:07:49Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NDgyNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460754824", "bodyText": "versionId is not used here", "author": "omarsmak", "createdAt": "2020-07-27T09:14:04Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NjczMA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460756730", "bodyText": "isNotEmpty as I mentioned earlier would make more sense here", "author": "omarsmak", "createdAt": "2020-07-27T09:17:20Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1Nzg3Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460757877", "bodyText": "this check here is not needed. ObjectHelper.isEmpty(bucketName) will check if string is empty or null", "author": "omarsmak", "createdAt": "2020-07-27T09:19:21Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460759163", "bodyText": "why is it 1024 bits here? Can you please move this into constant and with some comment why you opted for 1024bits?", "author": "omarsmak", "createdAt": "2020-07-27T09:21:29Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {\n+            throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+        }\n+\n+        return bucketName;\n+    }\n+\n+    private String determineObjectName(final Exchange exchange) {\n+        String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+        if (ObjectHelper.isEmpty(objectName)) {\n+            objectName = getConfiguration().getKeyName();\n+        }\n+        if (objectName == null) {\n+            throw new IllegalArgumentException(\"Minio Key header is missing.\");\n+        }\n+        return objectName;\n+    }\n+\n+    private String determineStorageClass(final Exchange exchange) {\n+        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n+        if (storageClass == null) {\n+            storageClass = getConfiguration().getStorageClass();\n+        }\n+\n+        return storageClass;\n+    }\n+\n+    private String determineVersionId(final Exchange exchange) {\n+        String versionId = exchange.getIn().getHeader(MinioConstants.VERSION_ID, String.class);\n+        if (versionId == null) {\n+            versionId = getConfiguration().getVersionId();\n+        }\n+\n+        return versionId;\n+    }\n+\n+    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        byte[] bytes = new byte[1024];", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMzI1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464113257", "bodyText": "Hi @omarsmak, I was actually mimicking this line. I will put this as a constant in MinioConstants.java", "author": "Nayananga", "createdAt": "2020-08-02T19:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMzI5NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464113295", "bodyText": "Hi @omarsmak, I was actually mimicking this line. I will put this as a constant in MinioConstants.java", "author": "Nayananga", "createdAt": "2020-08-02T19:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NTMwNw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460765307", "bodyText": "This class name is weird for the client impl. If this the remote client from the factory, something like MinioRemoteClientImpl would make more sense", "author": "omarsmak", "createdAt": "2020-07-27T09:32:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.client;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.component.minio.MinioConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Creates MinIO client object according to the\n+ * given endpoint, port, access key, secret key, region and secure option.\n+ */\n+public class GetMinioClient implements MinioCamelInternalClient {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460766063", "bodyText": "I wonder accessKeys, same as region are not required?", "author": "omarsmak", "createdAt": "2020-07-27T09:33:28Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.client;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.component.minio.MinioConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Creates MinIO client object according to the\n+ * given endpoint, port, access key, secret key, region and secure option.\n+ */\n+public class GetMinioClient implements MinioCamelInternalClient {\n+    private static final Logger LOG = LoggerFactory.getLogger(GetMinioClient.class);\n+    private final MinioConfiguration configuration;\n+\n+    /**\n+     * Constructor that uses the config file.\n+     */\n+    public GetMinioClient(MinioConfiguration configuration) {\n+        LOG.trace(\"Creating an Minio client.\");\n+        this.configuration = configuration;\n+    }\n+\n+    /**\n+     * Getting the minio client.\n+     *\n+     * @return Minio Client.\n+     */\n+    @Override\n+    public MinioClient getMinioClient() {\n+        if (configuration.getEndpoint() != null) {\n+            MinioClient.Builder minioClientRequest = MinioClient.builder();\n+\n+            if (configuration.getProxyPort() != null) {\n+                minioClientRequest.endpoint(configuration.getEndpoint(), configuration.getProxyPort(), configuration.isSecure());\n+            } else {\n+                minioClientRequest.endpoint(configuration.getEndpoint());\n+            }\n+            if (configuration.getAccessKey() != null && configuration.getSecretKey() != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMDMyMA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464100320", "bodyText": "Hi @omarsmak sorry, I didn't get this question?", "author": "Nayananga", "createdAt": "2020-08-02T17:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3MDYwNw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464270607", "bodyText": "What I mean here, are the accessKey, secretKey and region are required in order to initiate the client? What happens if one of these is null or not set?", "author": "omarsmak", "createdAt": "2020-08-03T08:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMzg2NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464623864", "bodyText": "@omarsmak, As per Java Client API Reference you can create MinioClient with or without accessKey, secretKey (namely anonymous access) or region.", "author": "Nayananga", "createdAt": "2020-08-03T19:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxNjIwNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466216204", "bodyText": "@omarsmak is it okay to mark this as resolved?", "author": "Nayananga", "createdAt": "2020-08-06T07:56:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjU1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460766557", "bodyText": "Please add more cases for region, secretKey .. etc", "author": "omarsmak", "createdAt": "2020-07-27T09:34:22Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class MinioComponentConfigurationTest extends CamelTestSupport {\n+\n+    @Test\n+    public void createEndpointWithMinimalConfiguration() throws Exception {\n+        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n+        MinioEndpoint endpoint = (MinioEndpoint) component\n+                .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc3NTgzMg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460775832", "bodyText": "These checks are pretty redundant. Perhaps what we can do here, wrap these into centralized lambdas somewhere and just pass the function reference. Example:\nprivate void checkMatchTagConfig(final MinioConfiguration configuration, final java.util.function.Consumer<String> fn) {\n        if ( ObjectHelper.isNotEmpty(configuration.getMatchETag()) ) {\n            fn.accept(configuration.getMatchETag());\n        }\n    }\n\nAnd then somewhere in the code:\ncheckMatchTagConfig(getConfiguration(), statObjectRequest::matchETag);", "author": "omarsmak", "createdAt": "2020-07-27T09:50:46Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+            IOHelper.close(minioObject);\n+        }\n+\n+        return exchange;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n+    }\n+\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n+\n+    public int getMaxConnections() {\n+        return maxConnections;\n+    }\n+\n+    /**\n+     * Set the maxConnections parameter in the minio client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(InputStream minioObject) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char) c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (getConfiguration().getRegion() != null) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        minioClient.makeBucket(makeBucketRequest.build());\n+    }\n+\n+    private void setBucketPolicy(String bucketName) throws Exception {\n+        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+        minioClient.setBucketPolicy(\n+                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n+        LOG.trace(\"Bucket policy updated\");\n+    }\n+\n+    private void getObjectStat(String objectName, Message message) throws Exception {\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4MTczNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463681735", "bodyText": "Not sure about this, might lead to NullPointerExceptions", "author": "zregvart", "createdAt": "2020-07-31T15:34:12Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.annotations.Component;\n+import org.apache.camel.support.DefaultComponent;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents the component that manages {@link MinioEndpoint}.\n+ */\n+@Component(\"minio\")\n+public class MinioComponent extends DefaultComponent {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioComponent.class);\n+\n+    @Metadata\n+    private MinioConfiguration configuration = new MinioConfiguration();\n+\n+    public MinioComponent() {\n+        this(null);", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NDMzNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463684336", "bodyText": "No, this is fine, we are using similar approach for component with Extension for validation like this https://github.com/apache/camel/blob/master/components/camel-aws-s3/src/main/java/org/apache/camel/component/aws/s3/S3Component.java#L35", "author": "oscerd", "createdAt": "2020-07-31T15:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4MTczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MjIyMg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463692222", "bodyText": "I would suggest to reformat it like this:\n    @Override\n    protected Result verifyParameters(Map<String, Object> parameters) {\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n                                             .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n\n        // Validate using the catalog\n        super.verifyParametersAgainstCatalog(builder, parameters);\n\n        return builder.build();\n    }", "author": "DenisIstomin", "createdAt": "2020-07-31T15:53:27Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+\n+import io.minio.MinioClient;\n+import io.minio.errors.MinioException;\n+import org.apache.camel.component.extension.verifier.DefaultComponentVerifierExtension;\n+import org.apache.camel.component.extension.verifier.ResultBuilder;\n+import org.apache.camel.component.extension.verifier.ResultErrorBuilder;\n+import org.apache.camel.component.extension.verifier.ResultErrorHelper;\n+\n+public class MinioComponentVerifierExtension extends DefaultComponentVerifierExtension {\n+\n+    public MinioComponentVerifierExtension() {\n+        this(\"minio\");\n+    }\n+\n+    public MinioComponentVerifierExtension(String scheme) {\n+        super(scheme);\n+    }\n+\n+    // *********************************\n+    // Parameters validation\n+    // *********************************\n+\n+    @Override", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5Mjg0NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463692845", "bodyText": "And the same below", "author": "DenisIstomin", "createdAt": "2020-07-31T15:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MjIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5NDMwOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463694308", "bodyText": "This is TODO comment?", "author": "DenisIstomin", "createdAt": "2020-07-31T15:57:10Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5NTYwOQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463695609", "bodyText": "Looks like it could be simplified:\nReader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8));", "author": "DenisIstomin", "createdAt": "2020-07-31T15:59:40Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+            IOHelper.close(minioObject);\n+        }\n+\n+        return exchange;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n+    }\n+\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n+\n+    public int getMaxConnections() {\n+        return maxConnections;\n+    }\n+\n+    /**\n+     * Set the maxConnections parameter in the minio client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(InputStream minioObject) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5OTg5Ng==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463699896", "bodyText": "Please avoid star import usage.", "author": "DenisIstomin", "createdAt": "2020-07-31T16:08:36Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.Message;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463700750", "bodyText": "It would be nice to extract all credentials into .properties file", "author": "DenisIstomin", "createdAt": "2020-07-31T16:10:19Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient client = MinioClient.builder()\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMjAxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464112015", "bodyText": "Hi @DenisIstomin, How can I do that?", "author": "Nayananga", "createdAt": "2020-08-02T19:03:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3MjE5NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464272194", "bodyText": "An example here", "author": "omarsmak", "createdAt": "2020-08-03T08:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzNzgyOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466837828", "bodyText": "@omarsmak, @DenisIstomin I have put minio_key.properties file in test/resources file along with the log4j2.properties file,\nendpoint=https://play.min.io\naccessKey=Q3AM3UQ867SPQQA43P2F\nsecretKey=zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\nregion=us-west-1\n\nbut then it throws this error java.lang.Exception: Make sure to supply minio endpoint and credentials as throws in this line. Any suggestions?", "author": "Nayananga", "createdAt": "2020-08-07T06:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MDE4Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466840183", "bodyText": "Hi this problem solved", "author": "Nayananga", "createdAt": "2020-08-07T06:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDk4Mg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463700982", "bodyText": "Please resolve this TODO", "author": "DenisIstomin", "createdAt": "2020-07-31T16:10:47Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient client = MinioClient.builder()\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+            .region(\"us-west-1\")\n+            .build();\n+\n+    @EndpointInject\n+    private ProducerTemplate template;\n+\n+    @EndpointInject(\"mock:result\")\n+    private MockEndpoint result;\n+\n+    @Test\n+    public void sendIn() throws Exception {\n+        result.expectedMessageCount(3);\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n+            exchange.getIn().setBody(\"Test1\");\n+        });\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n+            exchange.getIn().setBody(\"Test2\");\n+        });\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test3.txt\");\n+            exchange.getIn().setBody(\"Test3\");\n+        });\n+\n+        assertMockEndpointsSatisfied();\n+    }\n+\n+    @Override\n+    protected RouteBuilder createRouteBuilder() {\n+        return new RouteBuilder() {\n+            @Override\n+            public void configure() {\n+                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+\n+                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n+\n+                // TODO: Check why this is not working", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk3ODgwOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463978808", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean autocloseBody = true;\n          \n          \n            \n                private boolean autoCloseBody = true;", "author": "dmvolod", "createdAt": "2020-08-01T16:41:18Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java", "diffHunk": "@@ -0,0 +1,641 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.time.ZonedDateTime;\n+\n+import io.minio.MinioClient;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import okhttp3.OkHttpClient;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriParams;\n+\n+@UriParams\n+public class MinioConfiguration implements Cloneable {\n+\n+    @UriParam\n+    private String endpoint;\n+    @UriParam\n+    private Integer proxyPort;\n+\n+    @UriParam(label = \"security\", secret = true)\n+    private String accessKey;\n+    @UriParam(label = \"security\", secret = true)\n+    private String secretKey;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean secure;\n+\n+    @UriParam\n+    private String region;\n+\n+    @UriParam\n+    private OkHttpClient customHttpClient;\n+\n+    private String bucketName;\n+    @UriParam(defaultValue = \"true\")\n+    private boolean autoCreateBucket = true;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean objectLock;\n+\n+    @UriParam\n+    private ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey;\n+    @UriParam\n+    private ServerSideEncryption serverSideEncryption;\n+\n+    @UriParam\n+    private MinioClient minioClient;\n+\n+    @UriParam(label = \"consumer\")\n+    private String objectName;\n+    @UriParam(label = \"consumer\")\n+    private String delimiter;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeUserMetadata;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeVersions;\n+    @UriParam(label = \"consumer\")\n+    private String prefix;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean recursive;\n+    @UriParam(label = \"consumer\")\n+    private String startAfter;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean useVersion1;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeFolders;\n+    @UriParam(label = \"consumer\")\n+    private long offset;\n+    @UriParam(label = \"consumer\")\n+    private long length;\n+    @UriParam(label = \"consumer\")\n+    private String matchETag;\n+    @UriParam(label = \"consumer\")\n+    private String notMatchETag;\n+    @UriParam(label = \"consumer\")\n+    private ZonedDateTime modifiedSince;\n+    @UriParam(label = \"consumer\")\n+    private ZonedDateTime unModifiedSince;\n+    @UriParam(label = \"consumer\")\n+    private String destinationBucketName;\n+    @UriParam(label = \"consumer\")\n+    private String destinationObjectName;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean deleteAfterRead = true;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean moveAfterRead;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean includeBody = true;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean autocloseBody = true;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463980253", "bodyText": "I saw this implementation in large number of components, developed by @omarsmak, @oscerd and other members, but a little bit confusing about error message as getCamelContext().getRegistry().findByType can return more than one record if user suddenly put more than one MinioClient.class in the registry even if it doesn't make sense.\nThe error will be \"No MinioClient instance in the registry\" but can be wrong enough.", "author": "dmvolod", "createdAt": "2020-08-01T16:58:38Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.annotations.Component;\n+import org.apache.camel.support.DefaultComponent;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents the component that manages {@link MinioEndpoint}.\n+ */\n+@Component(\"minio\")\n+public class MinioComponent extends DefaultComponent {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioComponent.class);\n+\n+    @Metadata\n+    private MinioConfiguration configuration = new MinioConfiguration();\n+\n+    public MinioComponent() {\n+        this(null);\n+    }\n+\n+    public MinioComponent(CamelContext context) {\n+        super(context);\n+        registerExtension(new MinioComponentVerifierExtension());\n+\n+    }\n+\n+    @Override\n+    protected MinioEndpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n+        if (remaining == null || remaining.trim().length() == 0) {\n+            throw new IllegalArgumentException(\"Bucket name must be specified.\");\n+        }\n+\n+        final MinioConfiguration configuration = this.configuration != null ? this.configuration.copy() : new MinioConfiguration();\n+        configuration.setBucketName(remaining);\n+        MinioEndpoint endpoint = new MinioEndpoint(uri, this, configuration);\n+        setProperties(endpoint, parameters);\n+        checkAndSetRegistryClient(configuration, endpoint);\n+\n+        return endpoint;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    /**\n+     * The component configuration\n+     */\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n+        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n+            LOG.debug(\"Looking for an MinioClient instance in the registry\");\n+            Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n+            if (clients.size() == 1) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MTMyNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463981326", "bodyText": "I introduced the autoDisvoverCliebt for this situation in 3.5.0. in case it is false, that method won't be called", "author": "oscerd", "createdAt": "2020-08-01T17:11:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI4MDc2Mg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464280762", "bodyText": "@dmvolod yes, I agree, this error message could be misleading, I think error message could be changed if there are two cases, one for more than one MinioClient instance and other one for in case there is no instance of MinioClient.", "author": "omarsmak", "createdAt": "2020-08-03T08:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ4NDY1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r467484654", "bodyText": "Hi all,\nif (clients.size() > 1) {\n                LOG.debug(\"Found more than one MinioClient instance in the registry, getting the first one...\");\n                configuration.setMinioClient(clients.stream().findFirst().get());\n            } else if (clients.size() == 1) {\n                LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n                configuration.setMinioClient(clients.stream().findFirst().get());\n            } else {\n                LOG.debug(\"No MinioClient instance in the registry\");\n            }\n\nis this approach okay?", "author": "Nayananga", "createdAt": "2020-08-08T17:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDUyOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463980528", "bodyText": "@Nayananga a little bit confusing about key name and key value. The same as for LENGTH", "author": "dmvolod", "createdAt": "2020-08-01T17:01:42Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+/**\n+ * Constants used in Camel Minio module\n+ */\n+public interface MinioConstants {\n+\n+    String BUCKET_NAME = \"CamelMinioBucketName\";\n+    String DESTINATION_BUCKET_NAME = \"CamelMinioDestinationBucketName\";\n+    String CACHE_CONTROL = \"CamelMinioContentControl\";\n+    String CONTENT_DISPOSITION = \"CamelMinioContentDisposition\";\n+    String CONTENT_ENCODING = \"CamelMinioContentEncoding\";\n+    String CONTENT_LENGTH = \"CamelMinioContentLength\";\n+    String CONTENT_MD5 = \"CamelMinioContentMD5\";\n+    String CONTENT_TYPE = \"CamelMinioContentType\";\n+    String E_TAG = \"CamelMinioETag\";\n+    String OBJECT_NAME = \"CamelMinioObjectName\";\n+    String DESTINATION_OBJECT_NAME = \"CamelMinioDestinationObjectName\";\n+    String LAST_MODIFIED = \"CamelMinioLastModified\";\n+    String STORAGE_CLASS = \"CamelMinioStorageClass\";\n+    String VERSION_ID = \"CamelMinioVersionId\";\n+    String CANNED_ACL = \"CamelMinioCannedAcl\";\n+    String MINIO_OPERATION = \"CamelMinioOperation\";\n+    String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n+    String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n+    String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n+    String OFFSET = \"CamelMinioRangeStart\";", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NTY5MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464275690", "bodyText": "@Nayananga a tip: I think it will be easier for these Integration Tests classes to run through maven command line instead of having to remove the @Disabled. An example, take a look at this component IT tests. You will need to add a maven profile that will run IT tests that end with IT here. And then, you can add a Util class to load the credentials from the maven command line. Therefore after you have done all of the mentioned steps, you will just run your IT like this:\nmvn clean test -PfullTests", "author": "omarsmak", "createdAt": "2020-08-03T08:45:16Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.UUID;\n+\n+import javax.crypto.KeyGenerator;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.PutObjectArgs;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.minio.MinioOperations;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "url": "https://github.com/apache/camel/commit/fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "message": "Ran  mvn clean install -DskipTests", "committedDate": "2020-08-03T18:42:35Z", "type": "forcePushed"}, {"oid": "c0038995d0dd7129eade273ff2039a79e00d49f6", "url": "https://github.com/apache/camel/commit/c0038995d0dd7129eade273ff2039a79e00d49f6", "message": "Code simplified", "committedDate": "2020-08-06T07:48:09Z", "type": "forcePushed"}, {"oid": "d99a0cfad3d9437b0b7bf15dd9526b67007b0458", "url": "https://github.com/apache/camel/commit/d99a0cfad3d9437b0b7bf15dd9526b67007b0458", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-06T18:25:17Z", "type": "forcePushed"}, {"oid": "0e860b49082c2ce8ae735e48cfb746850711f22e", "url": "https://github.com/apache/camel/commit/0e860b49082c2ce8ae735e48cfb746850711f22e", "message": "Removed redundant check", "committedDate": "2020-08-07T05:02:20Z", "type": "forcePushed"}, {"oid": "1535a16a62132c3be469a43230d0507eba76063c", "url": "https://github.com/apache/camel/commit/1535a16a62132c3be469a43230d0507eba76063c", "message": "Added component basic sketch", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "228df3f1623107af49b9755bf053b063e3375dda", "url": "https://github.com/apache/camel/commit/228df3f1623107af49b9755bf053b063e3375dda", "message": "Ran mvn clean install -Pfastinstall", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "0fd206c77f5d3fa320bad1cd34683710c229b2cf", "url": "https://github.com/apache/camel/commit/0fd206c77f5d3fa320bad1cd34683710c229b2cf", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "url": "https://github.com/apache/camel/commit/90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "message": "Added existing implementation and fixed build failures", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "1e66a510a172e04b1bbeece7e1a5d330944daf14", "url": "https://github.com/apache/camel/commit/1e66a510a172e04b1bbeece7e1a5d330944daf14", "message": "Code reformatted", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "c6a9b5ac3b4d5a128c045495008174d905492576", "url": "https://github.com/apache/camel/commit/c6a9b5ac3b4d5a128c045495008174d905492576", "message": "Updated imports", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "cfce4fb8f46ec8057652ad366b47bbc93da82849", "url": "https://github.com/apache/camel/commit/cfce4fb8f46ec8057652ad366b47bbc93da82849", "message": "Updated camel version in camel-mino/pom.xml", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "url": "https://github.com/apache/camel/commit/1328d8106703a3d90d671d8d32c5eaa7419fa147", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "843335696c2da037e026ad7cc0318cf36494b183", "url": "https://github.com/apache/camel/commit/843335696c2da037e026ad7cc0318cf36494b183", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "2de2427460630152d5be00c6c33bad22c015f2cd", "url": "https://github.com/apache/camel/commit/2de2427460630152d5be00c6c33bad22c015f2cd", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "url": "https://github.com/apache/camel/commit/bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "152fd8b381686621d3de6a6300323fe89f42720b", "url": "https://github.com/apache/camel/commit/152fd8b381686621d3de6a6300323fe89f42720b", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "cce1852e6ad88c7c3a35134e8b0771f3a216e754", "url": "https://github.com/apache/camel/commit/cce1852e6ad88c7c3a35134e8b0771f3a216e754", "message": "Code Reformatted", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "0acedfcedaaf81796626b5f205f187b1262137ec", "url": "https://github.com/apache/camel/commit/0acedfcedaaf81796626b5f205f187b1262137ec", "message": "Added message headers in MinioEndpoint", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "acaa69fc2cf7a1f7127fc945e0bc5724c0af8aaa", "url": "https://github.com/apache/camel/commit/acaa69fc2cf7a1f7127fc945e0bc5724c0af8aaa", "message": "Added new implementations for MinioProducer", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "45beb5ddeaad938003b700bcf4f34b1da4105be3", "url": "https://github.com/apache/camel/commit/45beb5ddeaad938003b700bcf4f34b1da4105be3", "message": "Completed porting AWS2 S3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "c31ba2f8a3f6292297ff18111c199ffd8e4bb2b8", "url": "https://github.com/apache/camel/commit/c31ba2f8a3f6292297ff18111c199ffd8e4bb2b8", "message": "Updated to Minio 7.1.0", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "6972439ee57658ed13ff58c89df749dfafbfa18b", "url": "https://github.com/apache/camel/commit/6972439ee57658ed13ff58c89df749dfafbfa18b", "message": "Fixed code issues", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "f4aea6f0902b2108a296a183973813785969618b", "url": "https://github.com/apache/camel/commit/f4aea6f0902b2108a296a183973813785969618b", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "9dd0f1297a490222db92d0e8aee5919403fdcda7", "url": "https://github.com/apache/camel/commit/9dd0f1297a490222db92d0e8aee5919403fdcda7", "message": "Include integration Tests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "3e2463ac08dfe95e015a7c22394bba783110e159", "url": "https://github.com/apache/camel/commit/3e2463ac08dfe95e015a7c22394bba783110e159", "message": "Include integration Tests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "217cea4fdb007779cfeaa3f709c8b5111de0ec22", "url": "https://github.com/apache/camel/commit/217cea4fdb007779cfeaa3f709c8b5111de0ec22", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "a118ffe604943fd210497c88aaf14265888eceb8", "url": "https://github.com/apache/camel/commit/a118ffe604943fd210497c88aaf14265888eceb8", "message": "ran Integration tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "f2e79fda016b69999310571208bcda56d08251a4", "url": "https://github.com/apache/camel/commit/f2e79fda016b69999310571208bcda56d08251a4", "message": "Code Reformatted", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "08f2029caf83805ec099e160924b48da294350d8", "url": "https://github.com/apache/camel/commit/08f2029caf83805ec099e160924b48da294350d8", "message": "Integration test fixed", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "url": "https://github.com/apache/camel/commit/dbe1b9d6a59d2d844b774b48c576d31519b8239e", "message": "Updated code to mimic the AWS2 s3 component", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "5e215f54a6df69b8da845a48ab9966c6f5afdef8", "url": "https://github.com/apache/camel/commit/5e215f54a6df69b8da845a48ab9966c6f5afdef8", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "0c39393a1c2b10699825ca6286d2d5f3c0062dab", "url": "https://github.com/apache/camel/commit/0c39393a1c2b10699825ca6286d2d5f3c0062dab", "message": "Ran Integration tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "url": "https://github.com/apache/camel/commit/bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "message": "Fixed code issues", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "c35a7cb2bc1e76ec8968eb7e7b7b92b9c267ed0f", "url": "https://github.com/apache/camel/commit/c35a7cb2bc1e76ec8968eb7e7b7b92b9c267ed0f", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "6d02c2928ffc2cb751e6fae3d2353aa29fda95f0", "url": "https://github.com/apache/camel/commit/6d02c2928ffc2cb751e6fae3d2353aa29fda95f0", "message": "Added documentation", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "url": "https://github.com/apache/camel/commit/166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "message": "Minor changes to the tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "429db9080e37920a959ef6837141e7ed94357f9d", "url": "https://github.com/apache/camel/commit/429db9080e37920a959ef6837141e7ed94357f9d", "message": "Fixed typo", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "585e4deebddd6999431c35a3b5a8f3ce72f1f974", "url": "https://github.com/apache/camel/commit/585e4deebddd6999431c35a3b5a8f3ce72f1f974", "message": "Added missing labels", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "d09d6135cbb90dde34b080b393621fa69c16777d", "url": "https://github.com/apache/camel/commit/d09d6135cbb90dde34b080b393621fa69c16777d", "message": "Ran  mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "c627c28ed07400606c1f31ef1a6a6e0ce975da10", "url": "https://github.com/apache/camel/commit/c627c28ed07400606c1f31ef1a6a6e0ce975da10", "message": "Removed wildcard imports", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "e01c571ced63b6f85456cb419085ad2a5db9df3d", "url": "https://github.com/apache/camel/commit/e01c571ced63b6f85456cb419085ad2a5db9df3d", "message": "Removed redundant error handling and extracted removeObject method in MinioConsumer.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "652ceb5290bc403dfa12cc3dfc27447163f07e20", "url": "https://github.com/apache/camel/commit/652ceb5290bc403dfa12cc3dfc27447163f07e20", "message": "Renamed GetMinioClient.java to MinioRemoteClientImpl.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "5a8af2544004b9d92e26d5db558932c2bb446f4f", "url": "https://github.com/apache/camel/commit/5a8af2544004b9d92e26d5db558932c2bb446f4f", "message": "Renamed Offset and Length in MinioConstants.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "170ea27658ce31d585e0df8cddc599d6e2e63d74", "url": "https://github.com/apache/camel/commit/170ea27658ce31d585e0df8cddc599d6e2e63d74", "message": "Added more cases in MinioComponentConfigurationTest.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "5c97f24959e7766acbc0e8159512233954d0ecbb", "url": "https://github.com/apache/camel/commit/5c97f24959e7766acbc0e8159512233954d0ecbb", "message": "Added new MinioConstant", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "1f08aa281662d69aecfdbad038df3b1d8add228b", "url": "https://github.com/apache/camel/commit/1f08aa281662d69aecfdbad038df3b1d8add228b", "message": "Replaced != 0 with > 0", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "fa241fb3e2068636d81e3e918a63414639c06eec", "url": "https://github.com/apache/camel/commit/fa241fb3e2068636d81e3e918a63414639c06eec", "message": "Handled processCommit exception", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "27adf752f62677ae3e8488ed7350fb3bd5e2eefa", "url": "https://github.com/apache/camel/commit/27adf752f62677ae3e8488ed7350fb3bd5e2eefa", "message": "Handled createExchange exceptions", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "73e3b6bd522d7123fee5dbe1045b5a0890ffe326", "url": "https://github.com/apache/camel/commit/73e3b6bd522d7123fee5dbe1045b5a0890ffe326", "message": "Reformatted code", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "7136941423266b6a21f290a250e1e0017e439219", "url": "https://github.com/apache/camel/commit/7136941423266b6a21f290a250e1e0017e439219", "message": "Code simplified", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "2b27c7c868f05fbad30816b0a540fc4aa4c0965d", "url": "https://github.com/apache/camel/commit/2b27c7c868f05fbad30816b0a540fc4aa4c0965d", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "56eddb9a3966a9f0dfa00c44ea030b09db3492c3", "url": "https://github.com/apache/camel/commit/56eddb9a3966a9f0dfa00c44ea030b09db3492c3", "message": "Renamed autocloseBody to autoCloseBody in MinioConfiguration.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "409614e6426f1393c9c465c7dae4ff670902b2d2", "url": "https://github.com/apache/camel/commit/409614e6426f1393c9c465c7dae4ff670902b2d2", "message": "Minor fix", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "url": "https://github.com/apache/camel/commit/c308169b9ee19d93399a599b1a4df08e7816b5fd", "message": "Replaced == null / != null with isEmpty / isNotEmpty", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "c1bebb8cb5eea864f23e7347cc793c84ea5036cf", "url": "https://github.com/apache/camel/commit/c1bebb8cb5eea864f23e7347cc793c84ea5036cf", "message": "Removed redundant check", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "b08f49d96a2ce88cc46a80decd169986249b5779", "url": "https://github.com/apache/camel/commit/b08f49d96a2ce88cc46a80decd169986249b5779", "message": "Extracted all credentials into minio_key.properties file", "committedDate": "2020-08-08T16:44:10Z", "type": "commit"}]}