{"pr_number": 3152, "pr_title": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "pr_createdAt": "2020-03-22T19:10:21Z", "pr_url": "https://github.com/openmrs/openmrs-core/pull/3152", "timeline": [{"oid": "5d410e9b2f47c3e31da92111c5ca2658a604b068", "url": "https://github.com/openmrs/openmrs-core/commit/5d410e9b2f47c3e31da92111c5ca2658a604b068", "message": "Solving TRUNK-5724 - Refactor getSimilarPeople to use Lucene", "committedDate": "2020-03-22T19:07:25Z", "type": "forcePushed"}, {"oid": "c094fe164751004fe471ad8e5d7e4fceb136edb5", "url": "https://github.com/openmrs/openmrs-core/commit/c094fe164751004fe471ad8e5d7e4fceb136edb5", "message": "TRUNK-5274: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-03-23T20:45:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MzExMA==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r396793110", "bodyText": "I would remove this from your commit altogether", "author": "ibacher", "createdAt": "2020-03-23T22:24:19Z", "path": "api/src/main/java/org/openmrs/ConceptName.java", "diffHunk": "@@ -13,7 +13,6 @@\n import java.util.Date;\n import java.util.HashSet;\n import java.util.Locale;\n-", "originalCommit": "c094fe164751004fe471ad8e5d7e4fceb136edb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5Mzk4Mg==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r396793982", "bodyText": "x ->", "author": "ibacher", "createdAt": "2020-03-23T22:26:19Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/HibernatePersonDAO.java", "diffHunk": "@@ -72,6 +73,121 @@ public void setSessionFactory(SessionFactory sessionFactory) {\n \t\tthis.sessionFactory = sessionFactory;\n \t}\n \t\n+\t/**\n+\t * This method executes a Lucene search on persons based on the soundex filter with one search name given\n+\t * \n+\t * @param name a person should match using soundex representation\n+\t * @param birthyear the birthyear the searched person should have \n+\t * @param includeVoided true if voided person should be included \n+\t * @param gender of the person to search for \n+\t * @return the set of Persons that match the search criteria \n+\t */\n+\tprivate Set<Person> executeSoundexOnePersonNameQuery(String name, Integer birthyear, boolean includeVoided , String gender) {\n+\t\t// Use the Soundex Search Mode for each query\n+\t\tString matchMode = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE);\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX);\n+\t\t\n+\t\t\n+\t\tPersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);\n+\t\tString query = LuceneQuery.escapeQuery(name);\n+\t\tint maxResults = HibernatePersonDAO.getMaximumSearchResults();\n+\t\tLinkedHashSet<Person> people = new LinkedHashSet<>();\n+\t\t\n+\t\tLuceneQuery<PersonName> luceneQuery = personLuceneQuery.getSoundexPersonNameQuery(query, birthyear, false, gender);;\n+\t\tListPart<Object[]> names = luceneQuery.listPartProjection(0, maxResults, \"person.personId\");\n+\t\tnames.getList().forEach(x-> people.add(getPerson((Integer) x[0])));", "originalCommit": "c094fe164751004fe471ad8e5d7e4fceb136edb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NDY0NQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r396794645", "bodyText": "if (firstName) {", "author": "ibacher", "createdAt": "2020-03-23T22:27:49Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/HibernatePersonDAO.java", "diffHunk": "@@ -72,6 +73,121 @@ public void setSessionFactory(SessionFactory sessionFactory) {\n \t\tthis.sessionFactory = sessionFactory;\n \t}\n \t\n+\t/**\n+\t * This method executes a Lucene search on persons based on the soundex filter with one search name given\n+\t * \n+\t * @param name a person should match using soundex representation\n+\t * @param birthyear the birthyear the searched person should have \n+\t * @param includeVoided true if voided person should be included \n+\t * @param gender of the person to search for \n+\t * @return the set of Persons that match the search criteria \n+\t */\n+\tprivate Set<Person> executeSoundexOnePersonNameQuery(String name, Integer birthyear, boolean includeVoided , String gender) {\n+\t\t// Use the Soundex Search Mode for each query\n+\t\tString matchMode = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE);\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX);\n+\t\t\n+\t\t\n+\t\tPersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);\n+\t\tString query = LuceneQuery.escapeQuery(name);\n+\t\tint maxResults = HibernatePersonDAO.getMaximumSearchResults();\n+\t\tLinkedHashSet<Person> people = new LinkedHashSet<>();\n+\t\t\n+\t\tLuceneQuery<PersonName> luceneQuery = personLuceneQuery.getSoundexPersonNameQuery(query, birthyear, false, gender);;\n+\t\tListPart<Object[]> names = luceneQuery.listPartProjection(0, maxResults, \"person.personId\");\n+\t\tnames.getList().forEach(x-> people.add(getPerson((Integer) x[0])));\n+\t\t\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, matchMode);\n+\t\t\n+\t\treturn people; \n+\t}\n+\t\n+\t/**\n+\t * This method executes a Lucene search on persons based on the soundex filter with two search names given\n+\t * \n+\t * @param name1 firstName to be searched\n+\t * @param name2 last name to be searched \n+\t * @param birthyear the birthyear the searched person should have \n+\t * @param includeVoided true if voided person should be included \n+\t * @param gender of the person to search for \n+\t * @return the set of Persons that match the search criteria\n+\t */\n+\tprivate Set<Person> executeSoundexTwoPersonNameQuery(String name1, String name2,  Integer birthyear, boolean includeVoided , String gender) {\n+\t\t// Use the Soundex Search Mode for each query\n+\t\tString matchMode = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE);\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX);\n+\t\t\n+\t\tPersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);\n+\t\tint maxResults = HibernatePersonDAO.getMaximumSearchResults();\n+\t\t\n+\t\t// Execute a search on all names of a person with the given criteria\n+\t\tLuceneQuery<PersonName> luceneQuery = personLuceneQuery.getSoundexPersonNameSearchOnAllNames(name1, name2, 0, false, \"M\");\n+\t\tLinkedHashSet<Person> people = new LinkedHashSet<>();\n+\t\tListPart<Object[]> names = luceneQuery.listPartProjection(0, maxResults, \"person.personId\");\n+\t\tnames.getList().forEach(x-> people.add(getPerson((Integer) x[0])));\n+\t\t\n+\t\tSet<Person> firstNamesMatch = new HashSet<>();\n+\t\tSet<Person> secondNamesMatch = new HashSet<>();\n+\t\tSet<Person> secondNamesMatchFirstName = new HashSet<>();\n+\t\tSet<Person> firstNamesMatchSecondName = new HashSet<>();\n+\t\t\n+\t\t\n+\t\t// Executed Filter Logic: \n+\t\t// People whose first name matches n1 and second part of the name (givenName, familyName, familyName2) matches at least once n2\n+\t\tfirstNamesMatch = execSoundexLuceneQueryByNames(true, name1, birthyear, includeVoided, gender);\n+\t\tsecondNamesMatch = execSoundexLuceneQueryByNames(false, name2, birthyear, includeVoided, gender);\n+\t\t\n+\t\tfirstNamesMatch.retainAll(secondNamesMatch);\n+\t\tpeople.addAll(firstNamesMatch);\n+\t\t\n+\t\t// Executed Filter Logic: \n+\t\t// People who have second part of the name(givenName, familyName, familyName2) matching n2 and n1 (at least once)\n+\t\tsecondNamesMatchFirstName = execSoundexLuceneQueryByNames(false, name1, birthyear, includeVoided, gender);\n+\t\tsecondNamesMatch.retainAll(secondNamesMatchFirstName);\n+\t\tpeople.addAll(secondNamesMatch);\n+\t\tsecondNamesMatch.clear();\n+\t\t\n+\t\t// Executed Filter Logic:\n+\t\t// People who have given_name matching n2, second name matching n1, and another part of second name matching \u201c\u201d\n+\t\tfirstNamesMatchSecondName = execSoundexLuceneQueryByNames(true, name2, birthyear, includeVoided, gender);\n+\t\tsecondNamesMatch = execSoundexLuceneQueryByNames(false, \"\", birthyear, includeVoided, gender);\n+\t\t\n+\t\tfirstNamesMatchSecondName.retainAll(secondNamesMatchFirstName);\n+\t\tfirstNamesMatchSecondName.retainAll(secondNamesMatch);\n+\t\tpeople.addAll(firstNamesMatchSecondName);\n+\t\t\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, matchMode);\n+\t\treturn people;\n+\t}\n+\t\n+\t/**\n+\t * This method executes a search on either firstName or lastName attributes of person\n+\t * \n+\t * @param firstName true if search should be executed on firstname only\n+\t * @param name to be searched in soundex representation\n+\t * @param birthyear to be matched\n+\t * @param includeVoided true if voided persons should be matched\n+\t * @param gender of the person to search for \n+\t * @return the persons that match the search criteria as defined\n+\t */\n+\tprivate Set<Person> execSoundexLuceneQueryByNames(boolean firstName, String name, Integer birthyear, boolean includeVoided , String gender) {\n+\t\tPersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);\n+\t\tint maxResults = HibernatePersonDAO.getMaximumSearchResults();\n+\t\tSet<Person> results = new HashSet<>();\n+\t\tLuceneQuery<PersonName> luceneQuery;\n+\t\t\n+\t\tif(firstName) {", "originalCommit": "c094fe164751004fe471ad8e5d7e4fceb136edb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTA0MQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r396795041", "bodyText": "Is there a reason this case isn't covered?", "author": "ibacher", "createdAt": "2020-03-23T22:28:48Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/HibernatePersonDAO.java", "diffHunk": "@@ -84,35 +200,19 @@ public void setSessionFactory(SessionFactory sessionFactory) {\n \t\tif (birthyear == null) {\n \t\t\tbirthyear = 0;\n \t\t}\n-\n+\t\t\n \t\tname = name.replaceAll(\"  \", \" \");\n \t\tname = name.replace(\", \", \" \");\n \t\tString[] names = name.split(\" \");\n+\t\tSet<Person> result;\n \t\t\n \t\tStringBuilder q = new StringBuilder(\n \t\t        \"select p from Person p left join p.names as pname where p.personVoided = false and pname.voided = false and \");\n \t\t\n \t\tif (names.length == 1) {\n-\t\t\tq.append(\"(\").append(\" soundex(pname.givenName) = soundex(:n1)\").append(\n-\t\t\t    \" or soundex(pname.middleName) = soundex(:n1)\").append(\" or soundex(pname.familyName) = soundex(:n1) \")\n-\t\t\t        .append(\" or soundex(pname.familyName2) = soundex(:n1) \").append(\")\");\n+\t\t\treturn  executeSoundexOnePersonNameQuery(name, birthyear, false, gender);\n \t\t} else if (names.length == 2) {\n-\t\t\tq.append(\"(\").append(\" case\").append(\"  when pname.givenName is null then 1\").append(\n-\t\t\t    \"  when pname.givenName = '' then 1\").append(\"  when soundex(pname.givenName) = soundex(:n1) then 4\")\n-\t\t\t        .append(\"  when soundex(pname.givenName) = soundex(:n2) then 3\").append(\"  else 0 \").append(\" end\")\n-\t\t\t        .append(\" + \").append(\" case\").append(\"  when pname.middleName is null then 1\").append(\n-\t\t\t            \"  when pname.middleName = '' then 1\").append(\n-\t\t\t            \"  when soundex(pname.middleName) = soundex(:n1) then 3\").append(\n-\t\t\t            \"  when soundex(pname.middleName) = soundex(:n2) then 4\").append(\"  else 0 \").append(\" end\").append(\n-\t\t\t            \" + \").append(\" case\").append(\"  when pname.familyName is null then 1\").append(\n-\t\t\t            \"  when pname.familyName = '' then 1\").append(\n-\t\t\t            \"  when soundex(pname.familyName) = soundex(:n1) then 3\").append(\n-\t\t\t            \"  when soundex(pname.familyName) = soundex(:n2) then 4\").append(\"  else 0 \").append(\" end\").append(\n-\t\t\t            \" +\").append(\" case\").append(\"  when pname.familyName2 is null then 1\").append(\n-\t\t\t            \"  when pname.familyName2 = '' then 1\").append(\n-\t\t\t            \"  when soundex(pname.familyName2) = soundex(:n1) then 3\").append(\n-\t\t\t            \"  when soundex(pname.familyName2) = soundex(:n2) then 4\").append(\"  else 0 \").append(\" end\")\n-\t\t\t        .append(\") > 6\");\n+\t\t\treturn executeSoundexTwoPersonNameQuery(names[0], names[1], birthyear, false, gender);\n \t\t} else if (names.length == 3) {", "originalCommit": "c094fe164751004fe471ad8e5d7e4fceb136edb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyNjIwMw==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r397426203", "bodyText": "I want to split the issue in several parts to make discussion more structured and not make a to large PR. That is why I created a accoding subtask to the main issue.\nFor now I focused on the case of a names.length of 1 or 2. So we can first agree that this part works. And once this PR is done I will focus on coding this case.", "author": "fruether", "createdAt": "2020-03-24T20:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyOTM0NQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r397429345", "bodyText": "That's a very reasonable route to take. Just wanted to understand what is going on here.", "author": "ibacher", "createdAt": "2020-03-24T20:08:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQzMTMyNA==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r397431324", "bodyText": "\ud83d\udc4d\nThere seems like a lot is going on while re-factoring since Lucene core functionality is touched (LuceneQuery.java) which may affects other PersonName searches although the test cases do not indicate it.\nAnd the reverse engineering of the business logic of the sql code is not too trivial: https://talk.openmrs.org/t/soundex-search-in-lucenequeries/26068/22?u=fruether\nThe other comments should be fixed for now", "author": "fruether", "createdAt": "2020-03-24T20:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NzA2Ng==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r396797066", "bodyText": "I'm not particularly a fan of having a blank line after the last executable statement in a function, but we definitely shouldn't have two.", "author": "ibacher", "createdAt": "2020-03-23T22:33:58Z", "path": "api/src/test/java/org/openmrs/api/PersonServiceTest.java", "diffHunk": "@@ -478,27 +485,92 @@ public void getSimilarPeople_shouldMatchSingleSearchToAnyNamePart() throws Excep\n \t@Test\n \tpublic void getSimilarPeople_shouldMatchTwoWordSearchToAnyNamePart() throws Exception {\n \t\texecuteDataSet(\"org/openmrs/api/include/PersonServiceTest-names.xml\");\n+\t\tupdateSearchIndex();\n+\t\t\n \t\tSet<Person> matches = Context.getPersonService().getSimilarPeople(\"Darius Graham\", 1979, \"M\");\n-\t\tAssert.assertEquals(6, matches.size());\n+\t\tAssert.assertEquals(11, matches.size());\n \t\tassertTrue(containsId(matches, 1000));\n \t\tassertTrue(containsId(matches, 1003));\n-\t\tassertTrue(containsId(matches, 1004));\n-\t\tassertTrue(containsId(matches, 1005));\n+\t\tassertTrue(containsId(matches, 1004)); \n+\t\tassertTrue(containsId(matches, 1005)); \n \t\tassertTrue(containsId(matches, 1006));\n \t\tassertTrue(containsId(matches, 1007));\n+\t\t\n+\t\tassertTrue(containsId(matches, 1009));\n+\t\tassertTrue(containsId(matches, 1010));\n+\t\tassertTrue(containsId(matches, 1011));\n+\t\tassertTrue(containsId(matches, 1012));\n+\t\tassertTrue(containsId(matches, 1013));\n+\t\t\n+\t\t", "originalCommit": "c094fe164751004fe471ad8e5d7e4fceb136edb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "30dd6b31e8376da57c0ffe2e8f3a174af4d8cf22", "url": "https://github.com/openmrs/openmrs-core/commit/30dd6b31e8376da57c0ffe2e8f3a174af4d8cf22", "message": "TRUNK-5274: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-03-24T20:07:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQzMTQ2Mw==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r397431463", "bodyText": "I will fix this space in next commit", "author": "fruether", "createdAt": "2020-03-24T20:12:46Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/PersonLuceneQuery.java", "diffHunk": "@@ -49,7 +49,7 @@ public PersonLuceneQuery(SessionFactory sessionFactory) {\n \t}\n \n \tpublic LuceneQuery<PersonName> getPatientNameQuery(String query, boolean includeVoided, LuceneQuery<?> skipSame) {\n-\t\treturn getPersonNameQuery(query, false, includeVoided, true, skipSame);\n+\t\treturn   getPersonNameQuery(query, false, includeVoided, true, skipSame);", "originalCommit": "30dd6b31e8376da57c0ffe2e8f3a174af4d8cf22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "550408266685ac854c2d58428ccd3c223714527f", "url": "https://github.com/openmrs/openmrs-core/commit/550408266685ac854c2d58428ccd3c223714527f", "message": "TRUNK-5274: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-03-28T13:05:09Z", "type": "forcePushed"}, {"oid": "55097604f75e76d5ea5e78da5a22ba9eff423f32", "url": "https://github.com/openmrs/openmrs-core/commit/55097604f75e76d5ea5e78da5a22ba9eff423f32", "message": "TRUNK-5274: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-03-28T13:23:52Z", "type": "forcePushed"}, {"oid": "ae1b592d482d31c5907d60f25041be65ed31d088", "url": "https://github.com/openmrs/openmrs-core/commit/ae1b592d482d31c5907d60f25041be65ed31d088", "message": "TRUNK-5274: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-03-28T13:28:45Z", "type": "forcePushed"}, {"oid": "4a54a1953af632db5bb21b754bebe02c1aea6349", "url": "https://github.com/openmrs/openmrs-core/commit/4a54a1953af632db5bb21b754bebe02c1aea6349", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-03-28T13:45:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwMTQ2OA==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400401468", "bodyText": "Is there any value to this comment here?", "author": "ibacher", "createdAt": "2020-03-30T18:23:53Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/search/LuceneAnalyzerFactory.java", "diffHunk": "@@ -58,6 +60,12 @@ public SearchMapping getSearchMapping() {\n \t\t\t.filter(NGramFilterFactory.class)\n \t\t\t.param(\"minGramSize\", \"2\")\n \t\t\t.param(\"maxGramSize\", \"20\");\n+\t\tmapping.analyzerDef(LuceneAnalyzers.SOUNDEX_ANALYZER, StandardTokenizerFactory.class)\n+\t\t\t.filter(ClassicFilterFactory.class) //StandardTokenizerFactory https://www.programcreek.com/java-api-examples/index.php?api=org.apache.lucene.analysis.phonetic.PhoneticFilterFactory", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ0Mzg1NQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400443855", "bodyText": "The URL shows the example I used for the setup. I will remove it in the next commit", "author": "fruether", "createdAt": "2020-03-30T19:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwMTQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwMTk3Mg==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400401972", "bodyText": "\"soundexExactAnalyzer\" sounds like a weird descriptor to me... SOUNDEX is, by its very nature, not an exact match, unless I'm missing something?", "author": "ibacher", "createdAt": "2020-03-30T18:24:44Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/search/LuceneAnalyzers.java", "diffHunk": "@@ -26,4 +26,6 @@ private LuceneAnalyzers() {\n \tpublic static final String EXACT_ANALYZER = \"exactAnalyzer\";\n \t\n \tpublic static final String PHRASE_ANALYZER = \"phraseAnalyzer\";\n+\t\n+\tpublic static final String SOUNDEX_ANALYZER = \"soundexExactAnalyzer\";", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ0NDYyMQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400444621", "bodyText": "Yes makes sense.  I will change it accordingly", "author": "fruether", "createdAt": "2020-03-30T19:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwMTk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwNDE0MA==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400404140", "bodyText": "Shouldn't this be \"SOUNDEX\" to match the other types here?", "author": "ibacher", "createdAt": "2020-03-30T18:28:05Z", "path": "api/src/main/java/org/openmrs/util/OpenmrsConstants.java", "diffHunk": "@@ -339,6 +339,8 @@ public static String getOpenmrsProperty(String property) {\n \t\n \tpublic static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_START = \"START\";\n \t\n+\tpublic static final String GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX = \"Soundex\";", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ0NjMyNw==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400446327", "bodyText": "Done", "author": "fruether", "createdAt": "2020-03-30T19:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwNDE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwNTk5MQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400405991", "bodyText": "Do we really want such a high boost for a SOUNDEX match? I would suggest the boost should be left at 1.0.", "author": "ibacher", "createdAt": "2020-03-30T18:30:59Z", "path": "api/src/main/java/org/openmrs/PersonName.java", "diffHunk": "@@ -58,15 +58,17 @@\n \t@Fields({\n \t\t\t@Field(name = \"givenNameExact\", analyzer = @Analyzer(definition = LuceneAnalyzers.EXACT_ANALYZER), boost = @Boost(8f)),\n \t\t\t@Field(name = \"givenNameStart\", analyzer = @Analyzer(definition = LuceneAnalyzers.START_ANALYZER), boost = @Boost(4f)),\n-\t\t\t@Field(name = \"givenNameAnywhere\", analyzer = @Analyzer(definition = LuceneAnalyzers.ANYWHERE_ANALYZER), boost = @Boost(2f))\n+\t\t\t@Field(name = \"givenNameAnywhere\", analyzer = @Analyzer(definition = LuceneAnalyzers.ANYWHERE_ANALYZER), boost = @Boost(2f)),\n+\t\t\t@Field(name = \"givenNameSoundex\", analyzer =  @Analyzer(definition = LuceneAnalyzers.SOUNDEX_ANALYZER), boost = @Boost(16f))", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwNjA0Mw==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400406043", "bodyText": "Do we really want such a high boost for a SOUNDEX match? I would suggest the boost should be 0.5.", "author": "ibacher", "createdAt": "2020-03-30T18:31:04Z", "path": "api/src/main/java/org/openmrs/PersonName.java", "diffHunk": "@@ -58,15 +58,17 @@\n \t@Fields({\n \t\t\t@Field(name = \"givenNameExact\", analyzer = @Analyzer(definition = LuceneAnalyzers.EXACT_ANALYZER), boost = @Boost(8f)),\n \t\t\t@Field(name = \"givenNameStart\", analyzer = @Analyzer(definition = LuceneAnalyzers.START_ANALYZER), boost = @Boost(4f)),\n-\t\t\t@Field(name = \"givenNameAnywhere\", analyzer = @Analyzer(definition = LuceneAnalyzers.ANYWHERE_ANALYZER), boost = @Boost(2f))\n+\t\t\t@Field(name = \"givenNameAnywhere\", analyzer = @Analyzer(definition = LuceneAnalyzers.ANYWHERE_ANALYZER), boost = @Boost(2f)),\n+\t\t\t@Field(name = \"givenNameSoundex\", analyzer =  @Analyzer(definition = LuceneAnalyzers.SOUNDEX_ANALYZER), boost = @Boost(16f))\n \t})\n \tprivate String givenName;\n \tprivate String prefix;\n \n \t@Fields({\n \t\t\t@Field(name = \"middleNameExact\", analyzer = @Analyzer(definition = LuceneAnalyzers.EXACT_ANALYZER), boost = @Boost(4f)),\n \t\t\t@Field(name = \"middleNameStart\", analyzer = @Analyzer(definition = LuceneAnalyzers.START_ANALYZER), boost = @Boost(2f)),\n-\t\t\t@Field(name = \"middleNameAnywhere\", analyzer = @Analyzer(definition = LuceneAnalyzers.ANYWHERE_ANALYZER))\n+\t\t\t@Field(name = \"middleNameAnywhere\", analyzer = @Analyzer(definition = LuceneAnalyzers.ANYWHERE_ANALYZER)),\n+\t\t\t@Field(name = \"middleNameSoundex\", analyzer =  @Analyzer(definition = LuceneAnalyzers.SOUNDEX_ANALYZER), boost = @Boost(8f))", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwNjIyMw==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400406223", "bodyText": "Do we really want such a high boost for a SOUNDEX match? I would suggest the boost should be left at 1.0.", "author": "ibacher", "createdAt": "2020-03-30T18:31:22Z", "path": "api/src/main/java/org/openmrs/PersonName.java", "diffHunk": "@@ -76,13 +78,15 @@\n \t\t\t@Field(name = \"familyNameExact\", analyzer = @Analyzer(definition = LuceneAnalyzers.EXACT_ANALYZER), boost = @Boost(8f)),\n \t\t\t@Field(name = \"familyNameStart\", analyzer = @Analyzer(definition = LuceneAnalyzers.START_ANALYZER), boost = @Boost(4f)),\n \t\t\t@Field(name = \"familyNameAnywhere\", analyzer = @Analyzer(definition = LuceneAnalyzers.ANYWHERE_ANALYZER), boost = @Boost(2f)),\n+\t\t\t@Field(name = \"familyNameSoundex\", analyzer =  @Analyzer(definition = LuceneAnalyzers.SOUNDEX_ANALYZER), boost = @Boost(16f))", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2MjU2MA==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400462560", "bodyText": "I can set all to 1.0. It should have no effect I think \ud83d\udc4d", "author": "fruether", "createdAt": "2020-03-30T20:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwNjIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwNjM0MQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400406341", "bodyText": "Do we really want such a high boost for a SOUNDEX match? I would suggest the boost should be 0.5.", "author": "ibacher", "createdAt": "2020-03-30T18:31:34Z", "path": "api/src/main/java/org/openmrs/PersonName.java", "diffHunk": "@@ -76,13 +78,15 @@\n \t\t\t@Field(name = \"familyNameExact\", analyzer = @Analyzer(definition = LuceneAnalyzers.EXACT_ANALYZER), boost = @Boost(8f)),\n \t\t\t@Field(name = \"familyNameStart\", analyzer = @Analyzer(definition = LuceneAnalyzers.START_ANALYZER), boost = @Boost(4f)),\n \t\t\t@Field(name = \"familyNameAnywhere\", analyzer = @Analyzer(definition = LuceneAnalyzers.ANYWHERE_ANALYZER), boost = @Boost(2f)),\n+\t\t\t@Field(name = \"familyNameSoundex\", analyzer =  @Analyzer(definition = LuceneAnalyzers.SOUNDEX_ANALYZER), boost = @Boost(16f))\n \t})\n \tprivate String familyName;\n \n \t@Fields({\n \t\t\t@Field(name = \"familyName2Exact\", analyzer = @Analyzer(definition = LuceneAnalyzers.EXACT_ANALYZER), boost = @Boost(4f)),\n \t\t\t@Field(name = \"familyName2Start\", analyzer = @Analyzer(definition = LuceneAnalyzers.START_ANALYZER), boost = @Boost(2f)),\n \t\t\t@Field(name = \"familyName2Anywhere\", analyzer = @Analyzer(definition = LuceneAnalyzers.ANYWHERE_ANALYZER)),\n+\t\t\t@Field(name = \"familyName2Soundex\", analyzer =  @Analyzer(definition = LuceneAnalyzers.SOUNDEX_ANALYZER), boost = @Boost(8f))", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwNjU0Ng==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400406546", "bodyText": "Does this change need to be in this PR?", "author": "ibacher", "createdAt": "2020-03-30T18:31:54Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/HibernatePatientDAO.java", "diffHunk": "@@ -787,8 +787,8 @@ public Long getCountOfPatients(String query, boolean includeVoided) {\n \t\t}\n \n \t\tPersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);\n-\n \t\tLuceneQuery<PersonName> nameQuery = personLuceneQuery.getPatientNameQuery(query, includeVoided, identifierQuery);\n+\t\t", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1NjIxNQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400456215", "bodyText": "Fixed", "author": "fruether", "createdAt": "2020-03-30T19:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwNjU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwODA2MA==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400408060", "bodyText": "What happens when two people search for patients at the same time in different browsers?", "author": "ibacher", "createdAt": "2020-03-30T18:34:35Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/HibernatePersonDAO.java", "diffHunk": "@@ -72,6 +73,121 @@ public void setSessionFactory(SessionFactory sessionFactory) {\n \t\tthis.sessionFactory = sessionFactory;\n \t}\n \t\n+\t/**\n+\t * This method executes a Lucene search on persons based on the soundex filter with one search name given\n+\t * \n+\t * @param name a person should match using soundex representation\n+\t * @param birthyear the birthyear the searched person should have \n+\t * @param includeVoided true if voided person should be included \n+\t * @param gender of the person to search for \n+\t * @return the set of Persons that match the search criteria \n+\t */\n+\tprivate Set<Person> executeSoundexOnePersonNameQuery(String name, Integer birthyear, boolean includeVoided , String gender) {\n+\t\t// Use the Soundex Search Mode for each query\n+\t\tString matchMode = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE);\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX);", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwODExMg==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400408112", "bodyText": "What happens when two people search for patients at the same time in different browsers?", "author": "ibacher", "createdAt": "2020-03-30T18:34:42Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/HibernatePersonDAO.java", "diffHunk": "@@ -72,6 +73,121 @@ public void setSessionFactory(SessionFactory sessionFactory) {\n \t\tthis.sessionFactory = sessionFactory;\n \t}\n \t\n+\t/**\n+\t * This method executes a Lucene search on persons based on the soundex filter with one search name given\n+\t * \n+\t * @param name a person should match using soundex representation\n+\t * @param birthyear the birthyear the searched person should have \n+\t * @param includeVoided true if voided person should be included \n+\t * @param gender of the person to search for \n+\t * @return the set of Persons that match the search criteria \n+\t */\n+\tprivate Set<Person> executeSoundexOnePersonNameQuery(String name, Integer birthyear, boolean includeVoided , String gender) {\n+\t\t// Use the Soundex Search Mode for each query\n+\t\tString matchMode = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE);\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX);\n+\t\t\n+\t\t\n+\t\tPersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);\n+\t\tString query = LuceneQuery.escapeQuery(name);\n+\t\tint maxResults = HibernatePersonDAO.getMaximumSearchResults();\n+\t\tLinkedHashSet<Person> people = new LinkedHashSet<>();\n+\t\t\n+\t\tLuceneQuery<PersonName> luceneQuery = personLuceneQuery.getSoundexPersonNameQuery(query, birthyear, false, gender);;\n+\t\tListPart<Object[]> names = luceneQuery.listPartProjection(0, maxResults, \"person.personId\");\n+\t\tnames.getList().forEach(x -> people.add(getPerson((Integer) x[0])));\n+\t\t\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, matchMode);\n+\t\t\n+\t\treturn people; \n+\t}\n+\t\n+\t/**\n+\t * This method executes a Lucene search on persons based on the soundex filter with two search names given\n+\t * \n+\t * @param name1 firstName to be searched\n+\t * @param name2 last name to be searched \n+\t * @param birthyear the birthyear the searched person should have \n+\t * @param includeVoided true if voided person should be included \n+\t * @param gender of the person to search for \n+\t * @return the set of Persons that match the search criteria\n+\t */\n+\tprivate Set<Person> executeSoundexTwoPersonNameQuery(String name1, String name2,  Integer birthyear, boolean includeVoided , String gender) {\n+\t\t// Use the Soundex Search Mode for each query\n+\t\tString matchMode = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE);\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX);", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2NDA1MQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400464051", "bodyText": "Honestly, I don't know. Of all the options it seems like this was the smoothest way.\nPerhaps there is a constant that is bound to a session?\nOr there is a near way to set the choosen Lucene Analyzer that I was not aware of", "author": "fruether", "createdAt": "2020-03-30T20:11:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwODExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2NDQ1Mw==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400464453", "bodyText": "I asked in talk if we can get some support deciding what the approach would be. Hope you do not mind!", "author": "fruether", "createdAt": "2020-03-30T20:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwODExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2NzYwMA==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400467600", "bodyText": "Not at all!", "author": "ibacher", "createdAt": "2020-03-30T20:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwODExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwODIzMA==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400408230", "bodyText": "What happens when two people search for patients at the same time in different browsers?", "author": "ibacher", "createdAt": "2020-03-30T18:34:51Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/HibernatePersonDAO.java", "diffHunk": "@@ -72,6 +73,121 @@ public void setSessionFactory(SessionFactory sessionFactory) {\n \t\tthis.sessionFactory = sessionFactory;\n \t}\n \t\n+\t/**\n+\t * This method executes a Lucene search on persons based on the soundex filter with one search name given\n+\t * \n+\t * @param name a person should match using soundex representation\n+\t * @param birthyear the birthyear the searched person should have \n+\t * @param includeVoided true if voided person should be included \n+\t * @param gender of the person to search for \n+\t * @return the set of Persons that match the search criteria \n+\t */\n+\tprivate Set<Person> executeSoundexOnePersonNameQuery(String name, Integer birthyear, boolean includeVoided , String gender) {\n+\t\t// Use the Soundex Search Mode for each query\n+\t\tString matchMode = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE);\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX);\n+\t\t\n+\t\t\n+\t\tPersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);\n+\t\tString query = LuceneQuery.escapeQuery(name);\n+\t\tint maxResults = HibernatePersonDAO.getMaximumSearchResults();\n+\t\tLinkedHashSet<Person> people = new LinkedHashSet<>();\n+\t\t\n+\t\tLuceneQuery<PersonName> luceneQuery = personLuceneQuery.getSoundexPersonNameQuery(query, birthyear, false, gender);;\n+\t\tListPart<Object[]> names = luceneQuery.listPartProjection(0, maxResults, \"person.personId\");\n+\t\tnames.getList().forEach(x -> people.add(getPerson((Integer) x[0])));\n+\t\t\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, matchMode);", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwODMzNQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r400408335", "bodyText": "What happens when two people search for patients at the same time in different browsers?", "author": "ibacher", "createdAt": "2020-03-30T18:35:02Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/HibernatePersonDAO.java", "diffHunk": "@@ -72,6 +73,121 @@ public void setSessionFactory(SessionFactory sessionFactory) {\n \t\tthis.sessionFactory = sessionFactory;\n \t}\n \t\n+\t/**\n+\t * This method executes a Lucene search on persons based on the soundex filter with one search name given\n+\t * \n+\t * @param name a person should match using soundex representation\n+\t * @param birthyear the birthyear the searched person should have \n+\t * @param includeVoided true if voided person should be included \n+\t * @param gender of the person to search for \n+\t * @return the set of Persons that match the search criteria \n+\t */\n+\tprivate Set<Person> executeSoundexOnePersonNameQuery(String name, Integer birthyear, boolean includeVoided , String gender) {\n+\t\t// Use the Soundex Search Mode for each query\n+\t\tString matchMode = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE);\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX);\n+\t\t\n+\t\t\n+\t\tPersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);\n+\t\tString query = LuceneQuery.escapeQuery(name);\n+\t\tint maxResults = HibernatePersonDAO.getMaximumSearchResults();\n+\t\tLinkedHashSet<Person> people = new LinkedHashSet<>();\n+\t\t\n+\t\tLuceneQuery<PersonName> luceneQuery = personLuceneQuery.getSoundexPersonNameQuery(query, birthyear, false, gender);;\n+\t\tListPart<Object[]> names = luceneQuery.listPartProjection(0, maxResults, \"person.personId\");\n+\t\tnames.getList().forEach(x -> people.add(getPerson((Integer) x[0])));\n+\t\t\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, matchMode);\n+\t\t\n+\t\treturn people; \n+\t}\n+\t\n+\t/**\n+\t * This method executes a Lucene search on persons based on the soundex filter with two search names given\n+\t * \n+\t * @param name1 firstName to be searched\n+\t * @param name2 last name to be searched \n+\t * @param birthyear the birthyear the searched person should have \n+\t * @param includeVoided true if voided person should be included \n+\t * @param gender of the person to search for \n+\t * @return the set of Persons that match the search criteria\n+\t */\n+\tprivate Set<Person> executeSoundexTwoPersonNameQuery(String name1, String name2,  Integer birthyear, boolean includeVoided , String gender) {\n+\t\t// Use the Soundex Search Mode for each query\n+\t\tString matchMode = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE);\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_SOUNDEX);\n+\t\t\n+\t\tPersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);\n+\t\tint maxResults = HibernatePersonDAO.getMaximumSearchResults();\n+\t\t\n+\t\t// Execute a search on all names of a person with the given criteria\n+\t\tLuceneQuery<PersonName> luceneQuery = personLuceneQuery.getSoundexPersonNameSearchOnAllNames(name1, name2, 0, false, \"M\");\n+\t\tLinkedHashSet<Person> people = new LinkedHashSet<>();\n+\t\tListPart<Object[]> names = luceneQuery.listPartProjection(0, maxResults, \"person.personId\");\n+\t\tnames.getList().forEach(x -> people.add(getPerson((Integer) x[0])));\n+\t\t\n+\t\tSet<Person> firstNamesMatch = new HashSet<>();\n+\t\tSet<Person> secondNamesMatch = new HashSet<>();\n+\t\tSet<Person> secondNamesMatchFirstName = new HashSet<>();\n+\t\tSet<Person> firstNamesMatchSecondName = new HashSet<>();\n+\t\t\n+\t\t\n+\t\t// Executed Filter Logic: \n+\t\t// People whose first name matches n1 and second part of the name (givenName, familyName, familyName2) matches at least once n2\n+\t\tfirstNamesMatch = execSoundexLuceneQueryByNames(true, name1, birthyear, includeVoided, gender);\n+\t\tsecondNamesMatch = execSoundexLuceneQueryByNames(false, name2, birthyear, includeVoided, gender);\n+\t\t\n+\t\tfirstNamesMatch.retainAll(secondNamesMatch);\n+\t\tpeople.addAll(firstNamesMatch);\n+\t\t\n+\t\t// Executed Filter Logic: \n+\t\t// People who have second part of the name(givenName, familyName, familyName2) matching n2 and n1 (at least once)\n+\t\tsecondNamesMatchFirstName = execSoundexLuceneQueryByNames(false, name1, birthyear, includeVoided, gender);\n+\t\tsecondNamesMatch.retainAll(secondNamesMatchFirstName);\n+\t\tpeople.addAll(secondNamesMatch);\n+\t\tsecondNamesMatch.clear();\n+\t\t\n+\t\t// Executed Filter Logic:\n+\t\t// People who have given_name matching n2, second name matching n1, and another part of second name matching \u201c\u201d\n+\t\tfirstNamesMatchSecondName = execSoundexLuceneQueryByNames(true, name2, birthyear, includeVoided, gender);\n+\t\tsecondNamesMatch = execSoundexLuceneQueryByNames(false, \"\", birthyear, includeVoided, gender);\n+\t\t\n+\t\tfirstNamesMatchSecondName.retainAll(secondNamesMatchFirstName);\n+\t\tfirstNamesMatchSecondName.retainAll(secondNamesMatch);\n+\t\tpeople.addAll(firstNamesMatchSecondName);\n+\t\t\n+\t\tContext.getAdministrationService().setGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_MODE, matchMode);", "originalCommit": "4a54a1953af632db5bb21b754bebe02c1aea6349", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "948d5763a809fc8e3316803fda33c6fcf0010bd1", "url": "https://github.com/openmrs/openmrs-core/commit/948d5763a809fc8e3316803fda33c6fcf0010bd1", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-03-30T20:13:36Z", "type": "forcePushed"}, {"oid": "5618482f024500f26b07e06f7b2e1e1b9f5e0fd3", "url": "https://github.com/openmrs/openmrs-core/commit/5618482f024500f26b07e06f7b2e1e1b9f5e0fd3", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-03-31T19:42:35Z", "type": "forcePushed"}, {"oid": "d31bd4fb8c250826437e487bb906b7e1e3ebfa70", "url": "https://github.com/openmrs/openmrs-core/commit/d31bd4fb8c250826437e487bb906b7e1e3ebfa70", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-03-31T20:05:30Z", "type": "forcePushed"}, {"oid": "ae619c234743f0d8ab298693cce1e2abb1226c4b", "url": "https://github.com/openmrs/openmrs-core/commit/ae619c234743f0d8ab298693cce1e2abb1226c4b", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-03-31T20:15:19Z", "type": "forcePushed"}, {"oid": "b40cf43f3cbf6881479fa66426f7399f48bedd0b", "url": "https://github.com/openmrs/openmrs-core/commit/b40cf43f3cbf6881479fa66426f7399f48bedd0b", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-04-04T12:17:13Z", "type": "forcePushed"}, {"oid": "8940c8db4cd055dbe5f9eeb59e6c08bd654bfd28", "url": "https://github.com/openmrs/openmrs-core/commit/8940c8db4cd055dbe5f9eeb59e6c08bd654bfd28", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-04-04T12:20:01Z", "type": "forcePushed"}, {"oid": "e82b6f645eea4d22c6a35296732be5db4ea1a64b", "url": "https://github.com/openmrs/openmrs-core/commit/e82b6f645eea4d22c6a35296732be5db4ea1a64b", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-04-14T22:45:11Z", "type": "forcePushed"}, {"oid": "4a652c81d2620eb4a572ade4d6ed754a4f3b3562", "url": "https://github.com/openmrs/openmrs-core/commit/4a652c81d2620eb4a572ade4d6ed754a4f3b3562", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-04-14T22:49:32Z", "type": "forcePushed"}, {"oid": "e875b7254033dd45985c6f748d92c857b5f96091", "url": "https://github.com/openmrs/openmrs-core/commit/e875b7254033dd45985c6f748d92c857b5f96091", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-04-15T13:01:31Z", "type": "forcePushed"}, {"oid": "0f9d265483aa349d695abb2fb3941f3a54a30481", "url": "https://github.com/openmrs/openmrs-core/commit/0f9d265483aa349d695abb2fb3941f3a54a30481", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-05-09T18:16:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU2MjU2Mg==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r429562562", "bodyText": "Remove this", "author": "fruether", "createdAt": "2020-05-23T17:10:57Z", "path": "api/src/main/java/org/openmrs/api/db/hibernate/HibernatePersonDAO.java", "diffHunk": "@@ -72,6 +73,109 @@ public void setSessionFactory(SessionFactory sessionFactory) {\n \t\tthis.sessionFactory = sessionFactory;\n \t}\n \t\n+\t/**\n+\t * This method executes a Lucene search on persons based on the soundex filter with one search name given\n+\t * \n+\t * @param name a person should match using soundex representation\n+\t * @param birthyear the birthyear the searched person should have \n+\t * @param includeVoided true if voided person should be included \n+\t * @param gender of the person to search for \n+\t * @return the set of Persons that match the search criteria \n+\t */\n+\tprivate Set<Person> executeSoundexOnePersonNameQuery(String name, Integer birthyear, boolean includeVoided , String gender) {\n+\t\tPersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);\n+\t\tString query = LuceneQuery.escapeQuery(name);\n+\t\tint maxResults = HibernatePersonDAO.getMaximumSearchResults();\n+\t\tLinkedHashSet<Person> people = new LinkedHashSet<>();\n+\t\t\n+\t\tLuceneQuery<PersonName> luceneQuery = personLuceneQuery.getSoundexPersonNameQuery(query, birthyear, false, gender);;\n+\t\tListPart<Object[]> names = luceneQuery.listPartProjection(0, maxResults, \"person.personId\");\n+\t\tnames.getList().forEach(x -> people.add(getPerson((Integer) x[0])));\n+\t\t\n+\t\treturn people; \n+\t}\n+\t\n+\t/**\n+\t * This method executes a Lucene search on persons based on the soundex filter with two search names given\n+\t * \n+\t * @param name1 firstName to be searched\n+\t * @param name2 last name to be searched \n+\t * @param birthyear the birthyear the searched person should have \n+\t * @param includeVoided true if voided person should be included \n+\t * @param gender of the person to search for \n+\t * @return the set of Persons that match the search criteria\n+\t */\n+\tprivate Set<Person> executeSoundexTwoPersonNameQuery(String name1, String name2,  Integer birthyear, boolean includeVoided , String gender) {\n+\t\tPersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);\n+\t\tint maxResults = HibernatePersonDAO.getMaximumSearchResults();\n+\t\t\n+\t\t// Execute a search on all names of a person with the given criteria\n+\t\tLuceneQuery<PersonName> luceneQuery = personLuceneQuery.getSoundexPersonNameSearchOnAllNames(name1, name2, 0, false, \"M\");", "originalCommit": "0f9d265483aa349d695abb2fb3941f3a54a30481", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "320e92f180ec3dcbf90e3ccc04a89610b47bcc92", "url": "https://github.com/openmrs/openmrs-core/commit/320e92f180ec3dcbf90e3ccc04a89610b47bcc92", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-05-23T18:04:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3NTAyNg==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r443675026", "bodyText": "As a general rule, we'd actually want to store the resolution of the birth date as a DAY rather than a YEAR (even for the purposes of getSimilarPeople(), the resolution isn't quite a year, but a fuzzy \"3 year period either side of this given year).", "author": "ibacher", "createdAt": "2020-06-22T16:15:47Z", "path": "api/src/main/java/org/openmrs/Person.java", "diffHunk": "@@ -59,6 +62,9 @@\n \t@Field\n \tprivate String gender;\n \t\n+\n+\t@Field(analyze = Analyze.YES)\n+\t@DateBridge(encoding = EncodingType.STRING, resolution = Resolution.YEAR)", "originalCommit": "320e92f180ec3dcbf90e3ccc04a89610b47bcc92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3NTEyOQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r443675129", "bodyText": "I can see we do explicitly need a year. If we cannot construct a year query in Lucene, I think we should add a new calculated Lucene-only field of birthyear or something.", "author": "ibacher", "createdAt": "2020-06-22T16:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3NTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgwNTA2Mw==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r443805063", "bodyText": "Alright. Then let me work on adding a Lucene only field. I will first do a small research if there is way within Lucene", "author": "fruether", "createdAt": "2020-06-22T20:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3NTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyMzYwNQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r449223605", "bodyText": "@ibacher I can set the resolution to DAY and will not end anything on the result.", "author": "fruether", "createdAt": "2020-07-02T19:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3NTAyNg=="}], "type": "inlineReview"}, {"oid": "d55aaba6322a3a4b63fc212f41ab077560792944", "url": "https://github.com/openmrs/openmrs-core/commit/d55aaba6322a3a4b63fc212f41ab077560792944", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-07-02T19:28:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyNTk0Mg==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r449225942", "bodyText": "@ibacher I changed it to DAY and it is still working as expected. Is this concern of yours then adressed?", "author": "fruether", "createdAt": "2020-07-02T19:30:00Z", "path": "api/src/main/java/org/openmrs/Person.java", "diffHunk": "@@ -59,6 +62,9 @@\n \t@Field\n \tprivate String gender;\n \t\n+\n+\t@Field(analyze = Analyze.YES)\n+\t@DateBridge(encoding = EncodingType.STRING, resolution = Resolution.DAY)", "originalCommit": "d55aaba6322a3a4b63fc212f41ab077560792944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMzOTY1Mw==", "url": "https://github.com/openmrs/openmrs-core/pull/3152#discussion_r457339653", "bodyText": "That should be fine. Thanks!", "author": "ibacher", "createdAt": "2020-07-20T12:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIyNTk0Mg=="}], "type": "inlineReview"}, {"oid": "411f20b1f6d39c0f163ceb6957e485d16540b70a", "url": "https://github.com/openmrs/openmrs-core/commit/411f20b1f6d39c0f163ceb6957e485d16540b70a", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-07-19T21:09:40Z", "type": "forcePushed"}, {"oid": "f0c1d406444d7c2c3cee2bd4d34400f772feaf8e", "url": "https://github.com/openmrs/openmrs-core/commit/f0c1d406444d7c2c3cee2bd4d34400f772feaf8e", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-07-19T21:12:13Z", "type": "forcePushed"}, {"oid": "396e27314431bec52bed4de8c88f9ce24799b921", "url": "https://github.com/openmrs/openmrs-core/commit/396e27314431bec52bed4de8c88f9ce24799b921", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-07-19T21:21:51Z", "type": "forcePushed"}, {"oid": "47c8cd95f66a320ae153b27a61e05a4f7b239e34", "url": "https://github.com/openmrs/openmrs-core/commit/47c8cd95f66a320ae153b27a61e05a4f7b239e34", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-07-19T21:23:19Z", "type": "commit"}, {"oid": "47c8cd95f66a320ae153b27a61e05a4f7b239e34", "url": "https://github.com/openmrs/openmrs-core/commit/47c8cd95f66a320ae153b27a61e05a4f7b239e34", "message": "TRUNK-5724: Refactor getSimilarPeople to use Lucene", "committedDate": "2020-07-19T21:23:19Z", "type": "forcePushed"}, {"oid": "2dc1c1ef9e1604c59923b7219aa60a042929aa0d", "url": "https://github.com/openmrs/openmrs-core/commit/2dc1c1ef9e1604c59923b7219aa60a042929aa0d", "message": "Remove unnecessary whitespace", "committedDate": "2020-07-20T12:36:04Z", "type": "commit"}, {"oid": "196237256eb477db3f659c8167ea093940e4a76d", "url": "https://github.com/openmrs/openmrs-core/commit/196237256eb477db3f659c8167ea093940e4a76d", "message": "Normalise whitespace", "committedDate": "2020-07-20T12:37:41Z", "type": "commit"}, {"oid": "e65aff2cbdb25a89422b3c2ed841fbf9b9d4a174", "url": "https://github.com/openmrs/openmrs-core/commit/e65aff2cbdb25a89422b3c2ed841fbf9b9d4a174", "message": "Modify indentation", "committedDate": "2020-07-20T12:39:14Z", "type": "commit"}]}