{"pr_number": 2180, "pr_title": "Added Watch support on MockServer in Crud mode", "pr_createdAt": "2020-04-29T21:26:29Z", "pr_url": "https://github.com/fabric8io/kubernetes-client/pull/2180", "timeline": [{"oid": "92ea25b1b16026d5833878836639e1b89faba7b7", "url": "https://github.com/fabric8io/kubernetes-client/commit/92ea25b1b16026d5833878836639e1b89faba7b7", "message": "Added Watch support on MockServer in Crud mode", "committedDate": "2020-04-29T21:27:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MjY1MQ==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r417752651", "bodyText": "Is ADDED the right event received for a replace operation?", "author": "manusa", "createdAt": "2020-04-30T04:54:11Z", "path": "kubernetes-server-mock/src/main/java/io/fabric8/kubernetes/client/server/mock/KubernetesCrudDispatcher.java", "diffHunk": "@@ -42,6 +71,50 @@ public KubernetesCrudDispatcher(AttributeExtractor attributeExtractor, ResponseC\n     super(new Context(Serialization.jsonMapper()), attributeExtractor, responseComposer);\n   }\n \n+  @Override\n+  public MockResponse dispatch(RecordedRequest request) {\n+    String path = request.getPath();\n+    String method = request.getMethod();\n+    switch (method.toUpperCase()) {\n+      case POST:\n+      case PUT:", "originalCommit": "92ea25b1b16026d5833878836639e1b89faba7b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MzQyNA==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r417753424", "bodyText": "When declaring inner classes it's' recommended that you make them static, else you'll be creating the class each time the parent class is instantiated.\nAnyway, this file is already 400 lines long, why not move this class to a separate file to make things clearer and more readable?", "author": "manusa", "createdAt": "2020-04-30T04:57:15Z", "path": "kubernetes-server-mock/src/main/java/io/fabric8/kubernetes/client/server/mock/KubernetesCrudDispatcher.java", "diffHunk": "@@ -75,4 +148,248 @@ public MockResponse handleGet(String path) {\n     return response;\n   }\n \n+  /**\n+   * Patches the specified object to the in-memory db.\n+   *\n+   * @param path\n+   * @param s\n+   * @return\n+   */\n+  public MockResponse handlePatch(String path, String s) {\n+    MockResponse response = new MockResponse();\n+    String body = doGet(path);\n+    if (body == null) {\n+      response.setResponseCode(404);\n+    } else {\n+      try {\n+        JsonNode patch = context.getMapper().readTree(s);\n+        JsonNode source = context.getMapper().readTree(body);\n+        JsonNode updated = JsonPatch.apply(patch, source);\n+        String updatedAsString = context.getMapper().writeValueAsString(updated);\n+\n+        AttributeSet attributeSet = null;\n+\n+        AttributeSet query = attributeExtractor.extract(path);\n+        for (Map.Entry<AttributeSet, String> entry : map.entrySet()) {\n+          if (entry.getKey().matches(query)) {\n+            attributeSet = entry.getKey();\n+            break;\n+          }\n+        }\n+\n+        map.remove(attributeSet);\n+        AttributeSet newAttributeSet = AttributeSet.merge(attributeSet, attributeExtractor.fromResource(updatedAsString));\n+        map.put(newAttributeSet, updatedAsString);\n+\n+        for (Map.Entry<AttributeSet, Set<WatchEventsListener>> entry: watchEventListenerMapping.entrySet()) {\n+          boolean flag = false;\n+          if (attributeSet.matches(entry.getKey())) {\n+            flag = true;\n+            for (WatchEventsListener listener : entry.getValue()) {\n+              listener.sendWebSocketResponse(updatedAsString, \"MODIFIED\");\n+            }\n+          }\n+\n+          if (flag) { continue; }\n+\n+          if (newAttributeSet.matches(entry.getKey())) {\n+            for (WatchEventsListener listener : entry.getValue()) {\n+              listener.sendWebSocketResponse(updatedAsString, \"ADDED\");\n+            }\n+          }\n+        }\n+\n+        response.setResponseCode(202);\n+        response.setBody(updatedAsString);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+\n+    }\n+    return response;\n+  }\n+\n+  /**\n+   * Performs a delete for the corresponding object from the in-memory db.\n+   *\n+   * @param path\n+   * @return\n+   */\n+  public MockResponse handleDelete(String path) {\n+    MockResponse response = new MockResponse();\n+    List<AttributeSet> items = new ArrayList<>();\n+    AttributeSet query = attributeExtractor.extract(path);\n+\n+    for (Map.Entry<AttributeSet, String> entry : map.entrySet()) {\n+      if (entry.getKey().matches(query)) {\n+        items.add(entry.getKey());\n+      }\n+    }\n+    if (!items.isEmpty()) {\n+      for (AttributeSet item : items) {\n+        for (Map.Entry<AttributeSet, Set<WatchEventsListener>> entry: watchEventListenerMapping.entrySet()) {\n+          if (item.matches(entry.getKey())) {\n+            for (WatchEventsListener listener : entry.getValue()) {\n+              listener.sendWebSocketResponse(map.get(item), \"DELETED\");\n+            }\n+          }\n+        }\n+        map.remove(item);\n+      }\n+      response.setResponseCode(200);\n+    } else {\n+      response.setResponseCode(404);\n+    }\n+    return response;\n+  }\n+\n+  public MockResponse handleWatch(RecordedRequest request) {\n+    MockResponse mockResponse = new MockResponse();\n+    String path = request.getPath();\n+    String resourceName = fetchResourceNameFromWatchRequestPath(path);\n+    AttributeSet query = attributeExtractor.extract(path);\n+    if (resourceName != null) {\n+      query = query.add(new Attribute(\"name\", resourceName));\n+    }\n+    WatchEventsListener watchEventListener = new WatchEventsListener(query, UUID.randomUUID());\n+    if (watchEventListenerMapping.containsKey(query)) {\n+      watchEventListenerMapping.get(query).add(watchEventListener);\n+    } else {\n+      watchEventListenerMapping.put(query, new HashSet<WatchEventsListener>() {{ add(watchEventListener); }});\n+    }\n+    mockResponse.setSocketPolicy(SocketPolicy.KEEP_OPEN);\n+    return mockResponse.withWebSocketUpgrade(watchEventListener);\n+  }\n+\n+  boolean detectWatchMode(String path) {\n+    String queryString = null;\n+    try {\n+      queryString = new URI(path).getQuery();\n+    } catch (URISyntaxException e) {\n+      LOGGER.debug(\"incorrect URI string: \" + path);\n+      return false;\n+    }\n+    return queryString == null || queryString.isEmpty()? false: queryString.contains(\"watch=true\");\n+  }\n+\n+  String fetchResourceNameFromWatchRequestPath(String path) {\n+    String queryString = null;\n+    try {\n+      queryString = new URI(path).getQuery();\n+    } catch (URISyntaxException e) {\n+      LOGGER.debug(\"Incorrect URI string: \" + path);\n+      return null;\n+    }\n+\n+    if (queryString == null || queryString.isEmpty()) {\n+      return null;\n+    }\n+\n+    String name = \"\";\n+    for (String q: queryString.split(\"&\")) {\n+      if (q.contains(\"fieldSelector\") && q.contains(\"metadata.name\")) {\n+        String s[] = q.split(\"=\");\n+        name = s[s.length - 1];\n+      }\n+    }\n+    return name.isEmpty()? null: name;\n+  }\n+\n+  private String doGet(String path) {\n+    List<String> items = new ArrayList<>();\n+    AttributeSet query = attributeExtractor.extract(path);\n+    for (Map.Entry<AttributeSet, String> entry : map.entrySet()) {\n+      if (entry.getKey().matches(query)) {\n+        items.add(entry.getValue());\n+      }\n+    }\n+\n+    if (items.isEmpty()) {\n+      return null;\n+    } else if (items.size() == 1) {\n+      return items.get(0);\n+    } else {\n+      return responseComposer.compose(items);\n+    }\n+  }\n+\n+  private class WatchEventsListener extends WebSocketListener {", "originalCommit": "92ea25b1b16026d5833878836639e1b89faba7b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MzY3Mw==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r417753673", "bodyText": "This executor is never shutdown", "author": "manusa", "createdAt": "2020-04-30T04:58:24Z", "path": "kubernetes-server-mock/src/main/java/io/fabric8/kubernetes/client/server/mock/KubernetesCrudDispatcher.java", "diffHunk": "@@ -75,4 +148,248 @@ public MockResponse handleGet(String path) {\n     return response;\n   }\n \n+  /**\n+   * Patches the specified object to the in-memory db.\n+   *\n+   * @param path\n+   * @param s\n+   * @return\n+   */\n+  public MockResponse handlePatch(String path, String s) {\n+    MockResponse response = new MockResponse();\n+    String body = doGet(path);\n+    if (body == null) {\n+      response.setResponseCode(404);\n+    } else {\n+      try {\n+        JsonNode patch = context.getMapper().readTree(s);\n+        JsonNode source = context.getMapper().readTree(body);\n+        JsonNode updated = JsonPatch.apply(patch, source);\n+        String updatedAsString = context.getMapper().writeValueAsString(updated);\n+\n+        AttributeSet attributeSet = null;\n+\n+        AttributeSet query = attributeExtractor.extract(path);\n+        for (Map.Entry<AttributeSet, String> entry : map.entrySet()) {\n+          if (entry.getKey().matches(query)) {\n+            attributeSet = entry.getKey();\n+            break;\n+          }\n+        }\n+\n+        map.remove(attributeSet);\n+        AttributeSet newAttributeSet = AttributeSet.merge(attributeSet, attributeExtractor.fromResource(updatedAsString));\n+        map.put(newAttributeSet, updatedAsString);\n+\n+        for (Map.Entry<AttributeSet, Set<WatchEventsListener>> entry: watchEventListenerMapping.entrySet()) {\n+          boolean flag = false;\n+          if (attributeSet.matches(entry.getKey())) {\n+            flag = true;\n+            for (WatchEventsListener listener : entry.getValue()) {\n+              listener.sendWebSocketResponse(updatedAsString, \"MODIFIED\");\n+            }\n+          }\n+\n+          if (flag) { continue; }\n+\n+          if (newAttributeSet.matches(entry.getKey())) {\n+            for (WatchEventsListener listener : entry.getValue()) {\n+              listener.sendWebSocketResponse(updatedAsString, \"ADDED\");\n+            }\n+          }\n+        }\n+\n+        response.setResponseCode(202);\n+        response.setBody(updatedAsString);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+\n+    }\n+    return response;\n+  }\n+\n+  /**\n+   * Performs a delete for the corresponding object from the in-memory db.\n+   *\n+   * @param path\n+   * @return\n+   */\n+  public MockResponse handleDelete(String path) {\n+    MockResponse response = new MockResponse();\n+    List<AttributeSet> items = new ArrayList<>();\n+    AttributeSet query = attributeExtractor.extract(path);\n+\n+    for (Map.Entry<AttributeSet, String> entry : map.entrySet()) {\n+      if (entry.getKey().matches(query)) {\n+        items.add(entry.getKey());\n+      }\n+    }\n+    if (!items.isEmpty()) {\n+      for (AttributeSet item : items) {\n+        for (Map.Entry<AttributeSet, Set<WatchEventsListener>> entry: watchEventListenerMapping.entrySet()) {\n+          if (item.matches(entry.getKey())) {\n+            for (WatchEventsListener listener : entry.getValue()) {\n+              listener.sendWebSocketResponse(map.get(item), \"DELETED\");\n+            }\n+          }\n+        }\n+        map.remove(item);\n+      }\n+      response.setResponseCode(200);\n+    } else {\n+      response.setResponseCode(404);\n+    }\n+    return response;\n+  }\n+\n+  public MockResponse handleWatch(RecordedRequest request) {\n+    MockResponse mockResponse = new MockResponse();\n+    String path = request.getPath();\n+    String resourceName = fetchResourceNameFromWatchRequestPath(path);\n+    AttributeSet query = attributeExtractor.extract(path);\n+    if (resourceName != null) {\n+      query = query.add(new Attribute(\"name\", resourceName));\n+    }\n+    WatchEventsListener watchEventListener = new WatchEventsListener(query, UUID.randomUUID());\n+    if (watchEventListenerMapping.containsKey(query)) {\n+      watchEventListenerMapping.get(query).add(watchEventListener);\n+    } else {\n+      watchEventListenerMapping.put(query, new HashSet<WatchEventsListener>() {{ add(watchEventListener); }});\n+    }\n+    mockResponse.setSocketPolicy(SocketPolicy.KEEP_OPEN);\n+    return mockResponse.withWebSocketUpgrade(watchEventListener);\n+  }\n+\n+  boolean detectWatchMode(String path) {\n+    String queryString = null;\n+    try {\n+      queryString = new URI(path).getQuery();\n+    } catch (URISyntaxException e) {\n+      LOGGER.debug(\"incorrect URI string: \" + path);\n+      return false;\n+    }\n+    return queryString == null || queryString.isEmpty()? false: queryString.contains(\"watch=true\");\n+  }\n+\n+  String fetchResourceNameFromWatchRequestPath(String path) {\n+    String queryString = null;\n+    try {\n+      queryString = new URI(path).getQuery();\n+    } catch (URISyntaxException e) {\n+      LOGGER.debug(\"Incorrect URI string: \" + path);\n+      return null;\n+    }\n+\n+    if (queryString == null || queryString.isEmpty()) {\n+      return null;\n+    }\n+\n+    String name = \"\";\n+    for (String q: queryString.split(\"&\")) {\n+      if (q.contains(\"fieldSelector\") && q.contains(\"metadata.name\")) {\n+        String s[] = q.split(\"=\");\n+        name = s[s.length - 1];\n+      }\n+    }\n+    return name.isEmpty()? null: name;\n+  }\n+\n+  private String doGet(String path) {\n+    List<String> items = new ArrayList<>();\n+    AttributeSet query = attributeExtractor.extract(path);\n+    for (Map.Entry<AttributeSet, String> entry : map.entrySet()) {\n+      if (entry.getKey().matches(query)) {\n+        items.add(entry.getValue());\n+      }\n+    }\n+\n+    if (items.isEmpty()) {\n+      return null;\n+    } else if (items.size() == 1) {\n+      return items.get(0);\n+    } else {\n+      return responseComposer.compose(items);\n+    }\n+  }\n+\n+  private class WatchEventsListener extends WebSocketListener {\n+    private final AtomicReference<WebSocket> webSocketRef = new AtomicReference<>();\n+    private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();", "originalCommit": "92ea25b1b16026d5833878836639e1b89faba7b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1NDQ1Mg==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r417754452", "bodyText": "Is this something forgotten? We're ignoring the returned object", "author": "manusa", "createdAt": "2020-04-30T05:01:18Z", "path": "kubernetes-server-mock/src/main/java/io/fabric8/kubernetes/client/server/mock/KubernetesCrudDispatcher.java", "diffHunk": "@@ -42,6 +71,50 @@ public KubernetesCrudDispatcher(AttributeExtractor attributeExtractor, ResponseC\n     super(new Context(Serialization.jsonMapper()), attributeExtractor, responseComposer);\n   }\n \n+  @Override\n+  public MockResponse dispatch(RecordedRequest request) {\n+    String path = request.getPath();\n+    String method = request.getMethod();\n+    switch (method.toUpperCase()) {\n+      case POST:\n+      case PUT:\n+        return handleCreate(path, request.getBody().readUtf8());\n+      case PATCH:\n+        return handlePatch(path, request.getBody().readUtf8());\n+      case GET:\n+        return detectWatchMode(path)? handleWatch(request): handleGet(path);\n+      case DELETE:\n+        return handleDelete(path);\n+      default:\n+        return null;\n+    }\n+  }\n+\n+  /**\n+   * Adds the specified object to the in-memory db.\n+   *\n+   * @param path\n+   * @param s\n+   * @return\n+   */\n+  public MockResponse handleCreate(String path, String s) {\n+    Serialization.unmarshal(s, KubernetesResource.class);", "originalCommit": "92ea25b1b16026d5833878836639e1b89faba7b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1NTM4MQ==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r417755381", "bodyText": "The key object should be improved or replaced so that you don't have to iterate through the Map's entries and check if the key matches.\nIf your key had a proper equals/hashCode, you could simply get the value from the map watchEventListenerMapping.get(features)\nJust create an extra object for the Key that encapsulates the AttributeSet and whatever other thing you're using to identify the object and implement the equals/hashCode methods.", "author": "manusa", "createdAt": "2020-04-30T05:05:08Z", "path": "kubernetes-server-mock/src/main/java/io/fabric8/kubernetes/client/server/mock/KubernetesCrudDispatcher.java", "diffHunk": "@@ -42,6 +71,50 @@ public KubernetesCrudDispatcher(AttributeExtractor attributeExtractor, ResponseC\n     super(new Context(Serialization.jsonMapper()), attributeExtractor, responseComposer);\n   }\n \n+  @Override\n+  public MockResponse dispatch(RecordedRequest request) {\n+    String path = request.getPath();\n+    String method = request.getMethod();\n+    switch (method.toUpperCase()) {\n+      case POST:\n+      case PUT:\n+        return handleCreate(path, request.getBody().readUtf8());\n+      case PATCH:\n+        return handlePatch(path, request.getBody().readUtf8());\n+      case GET:\n+        return detectWatchMode(path)? handleWatch(request): handleGet(path);\n+      case DELETE:\n+        return handleDelete(path);\n+      default:\n+        return null;\n+    }\n+  }\n+\n+  /**\n+   * Adds the specified object to the in-memory db.\n+   *\n+   * @param path\n+   * @param s\n+   * @return\n+   */\n+  public MockResponse handleCreate(String path, String s) {\n+    Serialization.unmarshal(s, KubernetesResource.class);\n+    MockResponse response = new MockResponse();\n+    AttributeSet features = AttributeSet.merge(attributeExtractor.fromPath(path), attributeExtractor.fromResource(s));\n+    map.put(features, s);\n+\n+    for (Map.Entry<AttributeSet, Set<WatchEventsListener>> entry: watchEventListenerMapping.entrySet()) {\n+      if (features.matches(entry.getKey())) {", "originalCommit": "92ea25b1b16026d5833878836639e1b89faba7b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5MTM2Mg==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r419891362", "bodyText": "Remove commented lines", "author": "manusa", "createdAt": "2020-05-05T06:34:39Z", "path": "kubernetes-examples/src/main/java/io/fabric8/kubernetes/examples/WatchExample.java", "diffHunk": "@@ -67,7 +75,106 @@ public void onClose(KubernetesClientException e) {\n         }\n       }\n     }\n-    Thread.sleep(60000l);\n+    Thread.sleep(60000l);*/", "originalCommit": "bee736a4c6813683e5916becc6093903c3a58159", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5MjY0Mg==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r419892642", "bodyText": "Why, non-deterministic", "author": "manusa", "createdAt": "2020-05-05T06:37:57Z", "path": "kubernetes-examples/src/main/java/io/fabric8/kubernetes/examples/WatchExample.java", "diffHunk": "@@ -67,7 +75,106 @@ public void onClose(KubernetesClientException e) {\n         }\n       }\n     }\n-    Thread.sleep(60000l);\n+    Thread.sleep(60000l);*/\n+  }\n+\n+  static void podWatch() throws InterruptedException {\n+    Config config = new ConfigBuilder().build();\n+    final KubernetesClient client = new DefaultKubernetesClient(config);\n+\n+    client.namespaces().create(new NamespaceBuilder().withNewMetadata().withName(\"ns1\").endMetadata().build());\n+    Pod pod1 = new PodBuilder()\n+      .withNewMetadata()\n+      .withName(\"pod1\").addToLabels(\"test\", \"watch\")\n+      .endMetadata()\n+      .withNewSpec()\n+      .addToContainers(new ContainerBuilder().withName(\"nginx\").withImage(\"nginx\").build())\n+      .endSpec()\n+      .build();\n+\n+    client.pods().inNamespace(\"ns1\").create(pod1);\n+\n+    Thread.sleep(5000);", "originalCommit": "bee736a4c6813683e5916becc6093903c3a58159", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjgwNjAzOA==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r422806038", "bodyText": "There are still Thread.sleep calls within the tests.", "author": "manusa", "createdAt": "2020-05-11T06:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5MjY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5Mjc2NQ==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r419892765", "bodyText": "This looks like WIP", "author": "manusa", "createdAt": "2020-05-05T06:38:15Z", "path": "kubernetes-examples/src/main/java/io/fabric8/kubernetes/examples/WatchExample.java", "diffHunk": "@@ -67,7 +75,106 @@ public void onClose(KubernetesClientException e) {\n         }\n       }\n     }\n-    Thread.sleep(60000l);\n+    Thread.sleep(60000l);*/\n+  }\n+\n+  static void podWatch() throws InterruptedException {\n+    Config config = new ConfigBuilder().build();\n+    final KubernetesClient client = new DefaultKubernetesClient(config);\n+\n+    client.namespaces().create(new NamespaceBuilder().withNewMetadata().withName(\"ns1\").endMetadata().build());\n+    Pod pod1 = new PodBuilder()\n+      .withNewMetadata()\n+      .withName(\"pod1\").addToLabels(\"test\", \"watch\")\n+      .endMetadata()\n+      .withNewSpec()\n+      .addToContainers(new ContainerBuilder().withName(\"nginx\").withImage(\"nginx\").build())\n+      .endSpec()\n+      .build();\n+\n+    client.pods().inNamespace(\"ns1\").create(pod1);\n+\n+    Thread.sleep(5000);\n+    Watch watch = client.pods().inNamespace(\"ns1\")\n+      .withLabels(new HashMap<String, String>() {{ put(\"test\", \"watch\");}})\n+      .watch(new Watcher<Pod>() {\n+        @Override\n+        public void eventReceived(Action action, Pod resource) {\n+          switch (action) {\n+            case DELETED:\n+              System.out.println(\"DELETED  \" +  resource.getMetadata().getName());\n+              break;\n+            case ADDED:\n+              System.out.println(\"ADDED  \" + resource.getMetadata().getName());\n+              break;\n+            case MODIFIED:\n+              System.out.println(\"EDITED  \" + resource.getMetadata().getName());\n+              break;\n+            default:\n+              throw new AssertionFailedError(action.toString());\n+          }\n+        }\n+\n+        @Override\n+        public void onClose(KubernetesClientException cause) {\n+          System.out.println(\"CLOSSSSSINGGG\");\n+        }\n+      });\n+\n+    Pod pod2 = new PodBuilder()\n+      .withNewMetadata()\n+      .withName(\"pod2\")\n+      .endMetadata()\n+      .withNewSpec()\n+      .addToContainers(new ContainerBuilder().withName(\"nginx\").withImage(\"nginx\").build())\n+      .endSpec()\n+      .build();\n+\n+    client.pods().inNamespace(\"ns1\").create(pod2);\n+\n+    //pod2 = client.pods().inNamespace(\"ns1\").withName(\"pod2\").get();\n+    //pod2.getMetadata().setLabels(new HashMap<String, String>() {{ put(\"test\", \"watch\"); }});\n+\n+//    System.out.println(pod2.getMetadata());\n+    Thread.sleep(10000);\n+\n+    System.out.println(\"ADDING THE TEST LABEL\");\n+    client.pods().inNamespace(\"ns1\").withName(\"pod2\").edit()\n+      .editMetadata().addToLabels(\"test\", \"watch\").endMetadata()\n+      .done();\n+\n+    //System.out.println(\"EXECUTING REPLACE\");\n+   //pod2.getSpec().getContainers().get(0).setImage(\"redis\");\n+\n+\n+\n+    //client.pods().inNamespace(\"ns1\").withName(\"pod2\").replace(pod2);\n+    //client.pods().inNamespace(\"ns1\").withName(\"pod2\")\n+      //.patch(pod2);\n+\n+    Thread.sleep(10000);\n+\n+    //pod2 = client.pods().inNamespace(\"ns1\").withName(\"pod2\").get();\n+\n+    System.out.println(\"REMOVING THE TEST LABEL\");\n+    client.pods().inNamespace(\"ns1\").withName(\"pod2\").edit()\n+      .editMetadata().removeFromLabels(\"test\").endMetadata()\n+      .done();\n+\n+  //  System.out.println(pod2.getMetadata());\n+\n+    /*\n+    client.pods().inNamespace(\"ns1\").withName(\"pod2\")\n+      .patch(new PodBuilder().withNewMetadata()\n+        .withLabels(new HashMap<String, String>() {{put(\"test1\", \"watch\");}})\n+        .endMetadata()\n+        .build());*/\n+\n+    System.out.println(\"Closing watch....\");\n+    watch.close();\n+//    Pod pod3 = new PodBuilder().withNewMetadata().withName(\"pod3\").addToLabels(\"test\", \"watch\").endMetadata().build();\n+\n+    System.out.println(\"Let's end this\");", "originalCommit": "bee736a4c6813683e5916becc6093903c3a58159", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1MjU5NA==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r420152594", "bodyText": "Hey, I mistakenly included this file in this commit.. wasn't supposed to be in this PR", "author": "dev-gaur", "createdAt": "2020-05-05T14:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5Mjc2NQ=="}], "type": "inlineReview"}, {"oid": "e55e129ebc511c2e146049b4eaaff04de10b8965", "url": "https://github.com/fabric8io/kubernetes-client/commit/e55e129ebc511c2e146049b4eaaff04de10b8965", "message": "Added Watch support on MockServer in Crud mode", "committedDate": "2020-05-05T15:02:54Z", "type": "forcePushed"}, {"oid": "3ee8abdcca8c3b56627e79eeff460ba5e1d79956", "url": "https://github.com/fabric8io/kubernetes-client/commit/3ee8abdcca8c3b56627e79eeff460ba5e1d79956", "message": "Added Watch support on MockServer in Crud mode", "committedDate": "2020-05-06T14:02:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjgwNzM1Mg==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r422807352", "bodyText": "findFirst() returns an Optional, you're performing an Optional#get with no checks, this will probably break (this has also been reported by Sonar.\nTry to chenge that get with orElse(...) or orElseThrow(...) depending on if we are expecting the key to always be present or not.", "author": "manusa", "createdAt": "2020-05-11T06:23:13Z", "path": "kubernetes-server-mock/src/main/java/io/fabric8/kubernetes/client/server/mock/KubernetesCrudDispatcher.java", "diffHunk": "@@ -75,4 +127,170 @@ public MockResponse handleGet(String path) {\n     return response;\n   }\n \n+  /**\n+   * Patches the specified object to the in-memory db.\n+   *\n+   * @param path\n+   * @param s\n+   * @return\n+   */\n+  public MockResponse handlePatch(String path, String s) {\n+    MockResponse response = new MockResponse();\n+    String body = doGet(path);\n+    if (body == null) {\n+      response.setResponseCode(404);\n+    } else {\n+      try {\n+        JsonNode patch = context.getMapper().readTree(s);\n+        JsonNode source = context.getMapper().readTree(body);\n+        JsonNode updated = JsonPatch.apply(patch, source);\n+        String updatedAsString = context.getMapper().writeValueAsString(updated);\n+\n+        AttributeSet attributeSet = null;\n+\n+        AttributeSet query = attributeExtractor.fromPath(path);\n+\n+        attributeSet = map.entrySet().stream()\n+          .filter(entry -> entry.getKey().matches(query))\n+          .findFirst().get().getKey();", "originalCommit": "3ee8abdcca8c3b56627e79eeff460ba5e1d79956", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0c2dd6b3a48cf4a971324e3c0b50a29d437f1a88", "url": "https://github.com/fabric8io/kubernetes-client/commit/0c2dd6b3a48cf4a971324e3c0b50a29d437f1a88", "message": "Added Watch support on MockServer in Crud mode", "committedDate": "2020-05-11T09:20:43Z", "type": "forcePushed"}, {"oid": "a07c8b0a5c253c97df6f4243598bbc7eaa981804", "url": "https://github.com/fabric8io/kubernetes-client/commit/a07c8b0a5c253c97df6f4243598bbc7eaa981804", "message": "Added Watch support on MockServer in Crud mode", "committedDate": "2020-05-11T15:27:32Z", "type": "forcePushed"}, {"oid": "30555ffa95ba847e84de11cc82b63ec1089b98e2", "url": "https://github.com/fabric8io/kubernetes-client/commit/30555ffa95ba847e84de11cc82b63ec1089b98e2", "message": "Added Watch support on MockServer in Crud mode", "committedDate": "2020-05-11T16:54:48Z", "type": "forcePushed"}, {"oid": "c736932a3738b1d7bc1a956f900338987de696f1", "url": "https://github.com/fabric8io/kubernetes-client/commit/c736932a3738b1d7bc1a956f900338987de696f1", "message": "Added Watch support on MockServer in Crud mode", "committedDate": "2020-05-12T06:52:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NDA0NA==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r424174044", "bodyText": "Could you please provide complete JavaDoc for this method?", "author": "rohanKanojia", "createdAt": "2020-05-13T05:04:06Z", "path": "kubernetes-server-mock/src/main/java/io/fabric8/kubernetes/client/server/mock/KubernetesCrudDispatcher.java", "diffHunk": "@@ -15,51 +15,105 @@\n  */\n package io.fabric8.kubernetes.client.server.mock;\n \n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import io.fabric8.kubernetes.client.utils.Serialization;\n import io.fabric8.mockwebserver.Context;\n-import io.fabric8.mockwebserver.crud.AttributeExtractor;\n+import io.fabric8.mockwebserver.crud.Attribute;\n import io.fabric8.mockwebserver.crud.AttributeSet;\n import io.fabric8.mockwebserver.crud.CrudDispatcher;\n import io.fabric8.mockwebserver.crud.ResponseComposer;\n+import io.fabric8.zjsonpatch.JsonPatch;\n import okhttp3.mockwebserver.MockResponse;\n \n+import java.net.URI;\n+import java.net.URISyntaxException;\n import java.util.ArrayList;\n import java.util.List;\n-import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n+import okhttp3.mockwebserver.RecordedRequest;\n+import okhttp3.mockwebserver.SocketPolicy;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n public class KubernetesCrudDispatcher extends CrudDispatcher {\n \n+  private static final String POST = \"POST\";\n+  private static final String PUT = \"PUT\";\n+  private static final String PATCH = \"PATCH\";\n+  private static final String GET = \"GET\";\n+  private static final String DELETE = \"DELETE\";\n+\n   private static final Logger LOGGER = LoggerFactory.getLogger(KubernetesCrudDispatcher.class);\n+  private final Set<WatchEventsListener> watchEventListeners = new CopyOnWriteArraySet<>();\n \n   public KubernetesCrudDispatcher() {\n     this(new KubernetesCrudAttributesExtractor(), new KubernetesResponseComposer());\n   }\n \n-  public KubernetesCrudDispatcher(AttributeExtractor attributeExtractor, ResponseComposer responseComposer) {\n+  public KubernetesCrudDispatcher(KubernetesCrudAttributesExtractor attributeExtractor, ResponseComposer responseComposer) {\n     super(new Context(Serialization.jsonMapper()), attributeExtractor, responseComposer);\n   }\n \n+  @Override\n+  public MockResponse dispatch(RecordedRequest request) {\n+    String path = request.getPath();\n+    String method = request.getMethod();\n+    switch (method.toUpperCase()) {\n+      case POST:\n+        return handleCreate(path, request.getBody().readUtf8());\n+      case PUT:\n+        return handleReplace(path, request.getBody().readUtf8());\n+      case PATCH:\n+        return handlePatch(path, request.getBody().readUtf8());\n+      case GET:\n+        return detectWatchMode(path)? handleWatch(request): handleGet(path);\n+      case DELETE:\n+        return handleDelete(path);\n+      default:\n+        return null;\n+    }\n+  }\n+\n+  /**\n+   * Adds the specified object to the in-memory db.\n+   *\n+   * @param path\n+   * @param s\n+   * @return\n+   */\n+  @Override", "originalCommit": "c736932a3738b1d7bc1a956f900338987de696f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NTU1MA==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r424175550", "bodyText": "nit, can we use org.junit.jupiter.api.Assertions.assertTrue just for consistency?", "author": "rohanKanojia", "createdAt": "2020-05-13T05:09:29Z", "path": "kubernetes-tests/src/test/java/io/fabric8/kubernetes/client/mock/PodCrudTest.java", "diffHunk": "@@ -19,14 +19,25 @@\n import io.fabric8.kubernetes.api.model.Pod;\n import io.fabric8.kubernetes.api.model.PodBuilder;\n import io.fabric8.kubernetes.api.model.PodList;\n+import io.fabric8.kubernetes.api.model.PodSpec;\n+import io.fabric8.kubernetes.api.model.PodSpecBuilder;\n import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.KubernetesClientException;\n+import io.fabric8.kubernetes.client.Watch;\n+import io.fabric8.kubernetes.client.Watcher;\n import io.fabric8.kubernetes.client.server.mock.KubernetesServer;\n+import junit.framework.AssertionFailedError;\n import org.junit.Rule;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.migrationsupport.rules.EnableRuleMigrationSupport;\n \n import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n \n+import static junit.framework.TestCase.assertTrue;", "originalCommit": "c736932a3738b1d7bc1a956f900338987de696f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMwODY5MQ==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r424308691", "bodyText": "Thanks for pointing that out", "author": "dev-gaur", "createdAt": "2020-05-13T09:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NTU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3Njg5Mg==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r424176892", "bodyText": "Any specific reason you have made these methods static?", "author": "rohanKanojia", "createdAt": "2020-05-13T05:14:32Z", "path": "kubernetes-server-mock/src/main/java/io/fabric8/kubernetes/client/server/mock/WatchEventsListener.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Copyright (C) 2015 Red Hat, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *         http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.fabric8.kubernetes.client.server.mock;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import io.fabric8.kubernetes.api.model.KubernetesResource;\n+import io.fabric8.kubernetes.api.model.WatchEvent;\n+import io.fabric8.kubernetes.client.utils.Serialization;\n+import io.fabric8.mockwebserver.Context;\n+import io.fabric8.mockwebserver.crud.AttributeSet;\n+import io.fabric8.mockwebserver.internal.WebSocketMessage;\n+import okhttp3.Response;\n+import okhttp3.WebSocket;\n+import okhttp3.WebSocketListener;\n+import org.slf4j.Logger;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+class WatchEventsListener extends WebSocketListener {\n+  private final AtomicReference<WebSocket> webSocketRef = new AtomicReference<>();\n+  private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+  private final AttributeSet attributeSet;\n+  private final Context context;\n+  private final Set<WatchEventsListener> watchEventListenerList;\n+  private final Logger logger;\n+\n+  public WatchEventsListener(Context context, AttributeSet attributeSet, final Set<WatchEventsListener> watchEventListenerList, Logger logger) {\n+    this.logger = logger;\n+    this.context = context;\n+    this.attributeSet = attributeSet;\n+    this.watchEventListenerList = watchEventListenerList;\n+  }\n+\n+  public boolean attributeMatches(AttributeSet set) {\n+    return set.matches(attributeSet);\n+  }\n+  @Override\n+  public void onOpen(WebSocket webSocket, Response response) {\n+    webSocketRef.set(webSocket);\n+  }\n+\n+  @Override\n+  public void onClosing(WebSocket webSocket, int code, String reason) {\n+    webSocketRef.get().close(code, reason);\n+  }\n+\n+  @Override\n+  public void onClosed(WebSocket webSocket, int code, String reason) {\n+    if (webSocketRef.get() != null){\n+      webSocketRef.get().close(code, reason);\n+    }\n+    executor.shutdown();\n+    try {\n+      executor.awaitTermination(1, TimeUnit.MINUTES);\n+    } catch (InterruptedException e) {\n+      logger.debug(e.getLocalizedMessage());\n+      Thread.currentThread().interrupt();\n+    }\n+    watchEventListenerList.remove(this);\n+  }\n+\n+  @Override\n+  public void onFailure(WebSocket webSocket, Throwable t, Response response) {\n+    webSocket.close(1000, t.getMessage());\n+    executor.shutdown();\n+    try {\n+      executor.awaitTermination(1, TimeUnit.MINUTES);\n+    } catch (InterruptedException e) {\n+      logger.debug(e.getLocalizedMessage());\n+      Thread.currentThread().interrupt();\n+    }\n+    watchEventListenerList.remove(this);\n+  }\n+\n+\n+  public void sendWebSocketResponse(String object, String eventType) {\n+    WebSocketMessage message = toWebSocketMessage(context, new WatchEvent(Serialization.unmarshal(object, KubernetesResource.class), eventType));\n+    executor.schedule(() -> webSocketRef.get().send(message.getBody()), message.getDelay(), TimeUnit.SECONDS);\n+  }\n+\n+  private static WebSocketMessage toWebSocketMessage(Context context, Object content) {\n+    return toWebSocketMessage(context, content, true);\n+  }\n+\n+  private static WebSocketMessage toWebSocketMessage(Context context, Object content, Boolean toBeRemoved) {\n+    return toWebSocketMessage(context,0L, content, toBeRemoved);\n+  }\n+\n+  private static WebSocketMessage toWebSocketMessage(Context context, Long delay, Object content, Boolean toBeRemoved) {", "originalCommit": "c736932a3738b1d7bc1a956f900338987de696f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE5MDU2MA==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r424190560", "bodyText": "What's the reason not make them static if they are not affecting the state of the object and they don't require any of the declared fields (helper-methods)?", "author": "manusa", "createdAt": "2020-05-13T06:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3Njg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIwNzQ0NQ==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r424207445", "bodyText": "Umm, ok", "author": "rohanKanojia", "createdAt": "2020-05-13T06:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3Njg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NzM1NA==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r424177354", "bodyText": "nit, maybe it would be better if we use some constant, (e.g. HttpURLConnection.HTTP_ACCEPTED in this case) rather than hardcoding status codes.", "author": "rohanKanojia", "createdAt": "2020-05-13T05:16:16Z", "path": "kubernetes-server-mock/src/main/java/io/fabric8/kubernetes/client/server/mock/KubernetesCrudDispatcher.java", "diffHunk": "@@ -75,4 +129,172 @@ public MockResponse handleGet(String path) {\n     return response;\n   }\n \n+  /**\n+   * Patches the specified object to the in-memory db.\n+   *\n+   * @param path\n+   * @param s\n+   * @return\n+   */\n+  @Override\n+  public MockResponse handlePatch(String path, String s) {\n+    MockResponse response = new MockResponse();\n+    String body = fetchResource(path);\n+    if (body == null) {\n+      response.setResponseCode(404);\n+    } else {\n+      try {\n+        JsonNode patch = context.getMapper().readTree(s);\n+        JsonNode source = context.getMapper().readTree(body);\n+        JsonNode updated = JsonPatch.apply(patch, source);\n+        String updatedAsString = context.getMapper().writeValueAsString(updated);\n+\n+        AttributeSet attributeSet = null;\n+\n+        AttributeSet query = attributeExtractor.fromPath(path);\n+\n+        attributeSet = map.entrySet().stream()\n+          .filter(entry -> entry.getKey().matches(query))\n+          .findFirst().orElseThrow(IllegalStateException::new).getKey();\n+\n+        map.remove(attributeSet);\n+        AttributeSet newAttributeSet = AttributeSet.merge(attributeSet, attributeExtractor.fromResource(updatedAsString));\n+        map.put(newAttributeSet, updatedAsString);\n+\n+        final AtomicBoolean flag = new AtomicBoolean(false);\n+        AttributeSet finalAttributeSet = attributeSet;\n+        watchEventListeners.stream()\n+          .filter(watchEventsListener -> watchEventsListener.attributeMatches(finalAttributeSet))\n+          .forEach(watchEventsListener -> {\n+              flag.set(true);\n+              watchEventsListener.sendWebSocketResponse(updatedAsString, \"MODIFIED\");\n+          });\n+\n+        if (!flag.get()) {\n+          watchEventListeners.stream()\n+            .filter(watchEventsListener -> watchEventsListener.attributeMatches(newAttributeSet))\n+            .forEach(watchEventsListener -> watchEventsListener.sendWebSocketResponse(updatedAsString, \"ADDED\"));\n+        }\n+\n+        response.setResponseCode(202);\n+        response.setBody(updatedAsString);", "originalCommit": "c736932a3738b1d7bc1a956f900338987de696f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NzYzNw==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r424177637", "bodyText": "Please either complete the Javadoc or completely remove it", "author": "rohanKanojia", "createdAt": "2020-05-13T05:17:31Z", "path": "kubernetes-server-mock/src/main/java/io/fabric8/kubernetes/client/server/mock/KubernetesCrudDispatcher.java", "diffHunk": "@@ -75,4 +129,172 @@ public MockResponse handleGet(String path) {\n     return response;\n   }\n \n+  /**\n+   * Patches the specified object to the in-memory db.\n+   *\n+   * @param path", "originalCommit": "c736932a3738b1d7bc1a956f900338987de696f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8cdfe154a67979fe91ea08bbe9827af97ea55e12", "url": "https://github.com/fabric8io/kubernetes-client/commit/8cdfe154a67979fe91ea08bbe9827af97ea55e12", "message": "Added Watch support on MockServer in Crud mode", "committedDate": "2020-05-13T09:52:30Z", "type": "forcePushed"}, {"oid": "56b13f1c22ca95845b6963ce2f081fd37bc5e2d7", "url": "https://github.com/fabric8io/kubernetes-client/commit/56b13f1c22ca95845b6963ce2f081fd37bc5e2d7", "message": "Added Watch support on MockServer in Crud mode", "committedDate": "2020-05-13T10:55:07Z", "type": "commit"}, {"oid": "56b13f1c22ca95845b6963ce2f081fd37bc5e2d7", "url": "https://github.com/fabric8io/kubernetes-client/commit/56b13f1c22ca95845b6963ce2f081fd37bc5e2d7", "message": "Added Watch support on MockServer in Crud mode", "committedDate": "2020-05-13T10:55:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzNzg0Ng==", "url": "https://github.com/fabric8io/kubernetes-client/pull/2180#discussion_r428537846", "bodyText": "I missed this during my first round of review. Why have you created 3 watches? I think one watch should be able to test all kind of events being emitted. Am I missing something here?", "author": "rohanKanojia", "createdAt": "2020-05-21T09:12:23Z", "path": "kubernetes-tests/src/test/java/io/fabric8/kubernetes/client/mock/PodCrudTest.java", "diffHunk": "@@ -79,5 +86,298 @@ public void testCrud() {\n       .editMetadata().addToLabels(\"key1\", \"value1\").endMetadata().done();\n     assertNotNull(pod2);\n     assertEquals(\"value1\", pod2.getMetadata().getLabels().get(\"key1\"));\n+\n+    podList = client.pods().inNamespace(\"ns1\").list();\n+    assertNotNull(podList);\n+    assertEquals(1, podList.getItems().size());\n+\n+    Pod pod = client.pods().inNamespace(\"ns1\").withName(\"pod2\").get();\n+    assertNotNull(pod);\n+    assertEquals(2, pod.getMetadata().getLabels().size());\n   }\n+\n+  @Test\n+  public void testPodWatchOnName() throws InterruptedException {\n+    KubernetesClient client = server.getClient();\n+    Pod pod1 = new PodBuilder().withNewMetadata().withName(\"pod1\").addToLabels(\"testKey\", \"testValue\").endMetadata().build();\n+    final CountDownLatch deleteLatch = new CountDownLatch(1);\n+    final CountDownLatch closeLatch = new CountDownLatch(1);\n+    final CountDownLatch editLatch = new CountDownLatch(2);\n+    final CountDownLatch addLatch = new CountDownLatch(1);\n+\n+    pod1 = client.pods().inNamespace(\"ns1\").create(pod1);\n+    Watch watch = client.pods().inNamespace(\"ns1\").withName(pod1.getMetadata().getName()).watch(new Watcher<Pod>() {\n+      @Override\n+      public void eventReceived(Action action, Pod resource) {\n+        switch (action) {\n+          case DELETED:\n+            deleteLatch.countDown();\n+            break;\n+          case MODIFIED:\n+            editLatch.countDown();\n+            break;\n+          case ADDED:\n+            addLatch.countDown();\n+            break;\n+          default:\n+            throw new AssertionFailedError(action.toString().concat(\" isn't recognised.\"));\n+        }\n+      }\n+      @Override\n+      public void onClose(KubernetesClientException cause) {\n+        closeLatch.countDown();\n+      }\n+    });\n+\n+    pod1 = client.pods().inNamespace(\"ns1\").withName(pod1.getMetadata().getName())\n+      .patch(new PodBuilder().withNewMetadataLike(pod1.getMetadata()).endMetadata().build());\n+\n+    pod1.setSpec(new PodSpecBuilder().addNewContainer().withImage(\"nginx\").withName(\"nginx\").endContainer().build());\n+\n+    client.pods().inNamespace(\"ns1\").withName(pod1.getMetadata().getName()).replace(pod1);\n+\n+    client.pods().inNamespace(\"ns1\").withName(pod1.getMetadata().getName()).delete();\n+\n+    client.pods().inNamespace(\"ns1\").create(new PodBuilder().withNewMetadata().withName(\"pod1\").addToLabels(\"testKey\", \"testValue\").endMetadata().build());\n+\n+    assertEquals(1, client.pods().inNamespace(\"ns1\").list().getItems().size());\n+    assertTrue(addLatch.await(1, TimeUnit.MINUTES));\n+    assertTrue(editLatch.await(1, TimeUnit.MINUTES));\n+    assertTrue(deleteLatch.await(1, TimeUnit.MINUTES));\n+\n+    watch.close();\n+\n+    assertTrue(closeLatch.await(1, TimeUnit.MINUTES));\n+  }\n+\n+  @Test\n+  public void testPodWatchOnNamespace() throws InterruptedException {\n+    KubernetesClient client = server.getClient();\n+    Pod pod1 = new PodBuilder().withNewMetadata().withName(\"pod1\").addToLabels(\"testKey\", \"testValue\").endMetadata().build();\n+\n+    final CountDownLatch deleteLatch = new CountDownLatch(3);\n+    final CountDownLatch closeLatch = new CountDownLatch(3);\n+    final CountDownLatch addLatch = new CountDownLatch(3);\n+    final CountDownLatch editLatch = new CountDownLatch(2);\n+\n+    client.pods().inNamespace(\"ns1\").create(pod1);\n+    Watch watch = client.pods().inNamespace(\"ns1\").watch(new Watcher<Pod>() {\n+      @Override\n+      public void eventReceived(Action action, Pod resource) {\n+        switch (action) {\n+          case DELETED:\n+            deleteLatch.countDown();\n+            break;\n+          case ADDED:\n+            addLatch.countDown();\n+            break;\n+          case MODIFIED:\n+            editLatch.countDown();\n+            break;\n+          default:\n+            throw new AssertionFailedError(action.toString());\n+        }\n+      }\n+      @Override\n+      public void onClose(KubernetesClientException cause) {\n+        closeLatch.countDown();\n+      }\n+    });\n+\n+    Watch watch1 = client.pods().inNamespace(\"ns1\").watch(new Watcher<Pod>() {", "originalCommit": "56b13f1c22ca95845b6963ce2f081fd37bc5e2d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}