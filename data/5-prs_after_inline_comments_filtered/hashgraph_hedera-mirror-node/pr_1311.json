{"pr_number": 1311, "pr_title": "Publish topic messages to redis in a separate thread", "pr_createdAt": "2020-12-02T17:25:37Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311", "timeline": [{"oid": "cfa1b74143bb1c0703a84cf57b0decc0e1c523ea", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cfa1b74143bb1c0703a84cf57b0decc0e1c523ea", "message": "- publish topic messages to redis service in a separate thread\n- integration tests", "committedDate": "2020-12-09T19:44:28Z", "type": "forcePushed"}, {"oid": "0eb230840ae026138a88bbc0bf96304f068e607f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0eb230840ae026138a88bbc0bf96304f068e607f", "message": "- publish topic messages to redis service in a separate thread\n- integration tests\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-12-09T19:47:07Z", "type": "commit"}, {"oid": "0eb230840ae026138a88bbc0bf96304f068e607f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0eb230840ae026138a88bbc0bf96304f068e607f", "message": "- publish topic messages to redis service in a separate thread\n- integration tests\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-12-09T19:47:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDA1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r539604053", "bodyText": "leave TASK_QUEUE_SIZE as a static non-configurable field due to spring validation penalty on redisProperties.isEnabled() which is checked in every onSave() invocation.", "author": "xin-hedera", "createdAt": "2020-12-09T19:57:38Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/redis/RedisEntityListener.java", "diffHunk": "@@ -51,22 +56,31 @@\n @RequiredArgsConstructor\n public class RedisEntityListener implements BatchEntityListener {\n \n+    public static final int TASK_QUEUE_SIZE = 8;", "originalCommit": "0eb230840ae026138a88bbc0bf96304f068e607f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0NjYzMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r539746630", "bodyText": "make this a comment since there's an intention behind it", "author": "Nana-EC", "createdAt": "2020-12-10T00:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NDk5MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540474990", "bodyText": "added some comment", "author": "xin-hedera", "createdAt": "2020-12-10T20:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0OTEyOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r539749128", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // batch save action may run asynchronously, trigger it before other operations can reduce latency\n          \n          \n            \n                        // batch save action may run asynchronously, triggering it before other operations can reduce latency\n          \n      \n    \n    \n  \n\nor\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // batch save action may run asynchronously, trigger it before other operations can reduce latency\n          \n          \n            \n                        // batch save action may run asynchronously, trigger it before other operations to potentially reduce latency", "author": "Nana-EC", "createdAt": "2020-12-10T00:23:35Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java", "diffHunk": "@@ -184,6 +184,9 @@ private void executeBatches() {\n         Connection connection = null;\n \n         try {\n+            // batch save action may run asynchronously, trigger it before other operations can reduce latency", "originalCommit": "0eb230840ae026138a88bbc0bf96304f068e607f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NDg3NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540474874", "bodyText": "took the first suggestion", "author": "xin-hedera", "createdAt": "2020-12-10T20:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc0OTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MjA3Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r539752076", "bodyText": "nit: please add a bit more content to this to highlight the intricacies of the flux here.\nIf my understanding is correct you're generating topicmessage and adding to the sink, whiles supporting subscription on a single thread with messages in the pipeline converted and published.\nThis is something I'm pushing for with all our reactive streams to ensure the intent is clear and make it easier to understand and manage future changes/improvements.", "author": "Nana-EC", "createdAt": "2020-12-10T00:30:51Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/redis/RedisEntityListener.java", "diffHunk": "@@ -77,20 +91,39 @@ public boolean isEnabled() {\n \n     @Override\n     public void onTopicMessage(TopicMessage topicMessage) throws ImporterException {\n+        long consensusTimestamp = topicMessage.getConsensusTimestamp();\n+        if (consensusTimestamp <= lastConsensusTimestamp) {\n+            return;\n+        }\n+\n+        lastConsensusTimestamp = consensusTimestamp;\n         topicMessages.add(topicMessage);\n     }\n \n     @Override\n     @EventListener\n-    public void onSave(EntityBatchSaveEvent event) {\n-        try {\n-            if (isEnabled()) {\n-                Stopwatch stopwatch = Stopwatch.createStarted();\n-                timer.record(() -> redisOperations.executePipelined(callback()));\n-                log.info(\"Finished notifying {} messages in {}\", topicMessages.size(), stopwatch);\n-            }\n-        } catch (Exception e) {\n-            log.error(\"Unable to publish to redis\", e);\n+    public void onSave(EntityBatchSaveEvent event) throws InterruptedException {\n+        if (!isEnabled() || topicMessages.isEmpty()) {\n+            return;\n+        }\n+\n+        // defer flux, subscription, and scheduler creation\n+        if (subscription == null) {\n+            // run the flux operations in a different thread", "originalCommit": "0eb230840ae026138a88bbc0bf96304f068e607f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NTIyMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540475222", "bodyText": "added comment to describe the flow", "author": "xin-hedera", "createdAt": "2020-12-10T20:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc1MjA3Ng=="}], "type": "inlineReview"}, {"oid": "e04643e8339a32c3feff3bb91d21cd1e08b1157c", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e04643e8339a32c3feff3bb91d21cd1e08b1157c", "message": "address feedback\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-12-10T05:31:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkyODc1Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r539928757", "bodyText": "I'm still learning the ins and outs of Flux, if there were a period where no messages were coming in would this cause the complete() to close the Flux?  And then what would happen if messages were then to come in later, would it generate a new Flux?  This code looks good, just trying to make sure I understand.", "author": "ijungmann", "createdAt": "2020-12-10T07:16:08Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/redis/RedisEntityListener.java", "diffHunk": "@@ -101,12 +138,37 @@ public void onCleanup(EntityBatchCleanupEvent event) {\n         topicMessages.clear();\n     }\n \n+    private void generate(SynchronousSink<List<TopicMessage>> sink) {\n+        try {\n+            List<TopicMessage> messages = topicMessagesQueue.take();\n+            if (messages.isEmpty()) {\n+                sink.complete();", "originalCommit": "e04643e8339a32c3feff3bb91d21cd1e08b1157c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMTk2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540221964", "bodyText": "An empty list is only put into the topicMessagesQueue in the shutdown hook, which is used as a special value to gracefully complete the flux. btw, BlockingQueue by spec throws NPE if the element to add is null, so an empty list is chosen as the special value.\nDuring normal processing, at the beginning of onSave, we have\nif (!isEnabled() || topicMessages.isEmpty()) {\n    return;\n}\n\nso only when there are messages, the list is pushed into the flux.", "author": "xin-hedera", "createdAt": "2020-12-10T14:41:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkyODc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI2MTYyNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540261624", "bodyText": "Ah, got it.  I also had some misunderstanding of how take() works, after some more reading I get it.  Thanks!", "author": "ijungmann", "createdAt": "2020-12-10T15:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkyODc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNzQ5Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r539937493", "bodyText": "nit: I would name this something a little clearer, maybe latestMessageBatch.", "author": "ijungmann", "createdAt": "2020-12-10T07:31:33Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/redis/RedisEntityListener.java", "diffHunk": "@@ -77,20 +93,41 @@ public boolean isEnabled() {\n \n     @Override\n     public void onTopicMessage(TopicMessage topicMessage) throws ImporterException {\n+        long consensusTimestamp = topicMessage.getConsensusTimestamp();\n+        if (consensusTimestamp <= lastConsensusTimestamp) {\n+            return;\n+        }\n+\n+        lastConsensusTimestamp = consensusTimestamp;\n         topicMessages.add(topicMessage);\n     }\n \n     @Override\n     @EventListener\n-    public void onSave(EntityBatchSaveEvent event) {\n-        try {\n-            if (isEnabled()) {\n-                Stopwatch stopwatch = Stopwatch.createStarted();\n-                timer.record(() -> redisOperations.executePipelined(callback()));\n-                log.info(\"Finished notifying {} messages in {}\", topicMessages.size(), stopwatch);\n-            }\n-        } catch (Exception e) {\n-            log.error(\"Unable to publish to redis\", e);\n+    public void onSave(EntityBatchSaveEvent event) throws InterruptedException {\n+        if (!isEnabled() || topicMessages.isEmpty()) {\n+            return;\n+        }\n+\n+        // defer flux, subscription, and scheduler creation\n+        if (subscription == null) {\n+            // create a flux from the generator to pull then pump the topic messages list, immediately subscribe to the\n+            // flux to publish the topic messages list to redis service. With subscribeOn the new single thread\n+            // scheduler, the whole flux pipeline runs in a single thread.\n+            subscription = Flux.generate(this::generate)\n+                    .doOnSubscribe(s -> log.info(\"Starting redis publish flow\"))\n+                    .doFinally(s -> log.info(\"Redis publish flow stopped with {} signal\", s))\n+                    .doOnError(t -> log.error(\"Unexpected error during redis publish flow\", t))\n+                    .subscribeOn(Schedulers.newSingle(\"redis-publish\"))\n+                    .subscribe(this::publish);\n+            Runtime.getRuntime().addShutdownHook(new Thread(() -> topicMessagesQueue.offer(new ArrayList<>())));\n+        }\n+\n+        List<TopicMessage> messages = topicMessages;", "originalCommit": "e04643e8339a32c3feff3bb91d21cd1e08b1157c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NDczNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540474734", "bodyText": "just did so", "author": "xin-hedera", "createdAt": "2020-12-10T20:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzNzQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTA0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r539939041", "bodyText": "nit: I would prefer either messages or topicMessages be renamed, having a hard time following which is which at times.", "author": "ijungmann", "createdAt": "2020-12-10T07:34:40Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/redis/RedisEntityListenerTest.java", "diffHunk": "@@ -60,4 +82,86 @@ public RedisEntityListenerTest(RedisEntityListener entityListener, RedisProperti\n         redisOperations.execute(redisCallback);\n         return processor;\n     }\n+\n+    @Test\n+    void onDuplicateTopicMessages() throws InterruptedException {\n+        // given\n+        TopicMessage topicMessage1 = topicMessage();\n+        TopicMessage topicMessage2 = topicMessage();\n+        TopicMessage topicMessage3 = topicMessage();\n+        Flux<TopicMessage> topicMessages = subscribe(topicMessage1.getTopicNum());\n+\n+        // when\n+        entityListener.onTopicMessage(topicMessage1);\n+        entityListener.onTopicMessage(topicMessage2);\n+        entityListener.onTopicMessage(topicMessage1); // duplicate\n+        entityListener.onTopicMessage(topicMessage2); // duplicate\n+        entityListener.onTopicMessage(topicMessage3);\n+        entityListener.onSave(new EntityBatchSaveEvent(this));\n+        entityListener.onCleanup(new EntityBatchCleanupEvent(this));\n+\n+        // then\n+        topicMessages.as(StepVerifier::create)\n+                .expectNext(topicMessage1, topicMessage2, topicMessage3)\n+                .thenCancel()\n+                .verify(Duration.ofMillis(1000));\n+    }\n+\n+    @Test\n+    void onSlowPublish() {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        AtomicInteger saveCount = new AtomicInteger(0);\n+\n+        // given\n+        List<TopicMessage> messages = new ArrayList<>();\n+        for (int i = 0; i < RedisEntityListener.TASK_QUEUE_SIZE + 2; i++) {\n+            messages.add(topicMessage());\n+        }\n+        Flux<TopicMessage> topicMessages = subscribe(messages.get(0).getTopicNum());", "originalCommit": "e04643e8339a32c3feff3bb91d21cd1e08b1157c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NDY5Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540474693", "bodyText": "renamed topicMessages to topicMessagesFlux", "author": "xin-hedera", "createdAt": "2020-12-10T20:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTkzOTA0MQ=="}], "type": "inlineReview"}, {"oid": "d56c995855f34378dfecfcf44f2af43a7d75f2bb", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d56c995855f34378dfecfcf44f2af43a7d75f2bb", "message": "address feedback\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-12-10T20:26:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxNjQzMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540516433", "bodyText": "When I said we should consider Flux I meant replace things entirely with it. We shouldn't mix and match non-blocking Flux with blocking queues and regular array lists. We should either use all flux or all BlockingQueue with a regular thread. For latter can just have a method like below:\n@Async\n@EventListener\npublic void onStartup(ApplicationReadyEvent event) {\n  while (true) {\n    publish(topicMessagesQueue.take());\n  }\n}\nFor Flux only approach, can actually remove queue and list and just create a flux on startup like below (exact processor, overflow strategy and values would need to be investigated):\nvoid init() {\n  DirectProcessor<TopicMessage> directProcessor = DirectProcessor.create();\n  topicMessageSink = directProcessor.sink();\n  directProcessor.filter(last timestamp)\n    .bufferTimeout(1000, Duration.ofSeconds(1))\n    .subscribeOn(Schedulers.single())\n    .subscribe(this::publish);\n}\n\npublic void onTopicMessage(TopicMessage topicMessage) {\n  topicMessageSink.next(topicMessage);\n}\nFlux only approach would have the added benefit of allowing us to remove batch onSave() and make the class stateless.", "author": "steven-sheehy", "createdAt": "2020-12-10T21:40:06Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/redis/RedisEntityListener.java", "diffHunk": "@@ -51,22 +56,33 @@\n @RequiredArgsConstructor\n public class RedisEntityListener implements BatchEntityListener {\n \n+    // hardcode it now to avoid spring validation performance penalty incurred on RedisProperties.isEnabled() if it were\n+    // added to RedisProperties with validation annotations\n+    public static final int TASK_QUEUE_SIZE = 8;\n+\n     private final MirrorProperties mirrorProperties;\n     private final RedisProperties redisProperties;\n     private final RedisOperations<String, StreamMessage> redisOperations;\n-    private final List<TopicMessage> topicMessages = new ArrayList<>();\n     private final MeterRegistry meterRegistry;\n \n+    private long lastConsensusTimestamp;\n+    private Disposable subscription;", "originalCommit": "d56c995855f34378dfecfcf44f2af43a7d75f2bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYzNTE5MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540635191", "bodyText": "Looks like there isn't a way to achieve the following at the same time:\n\nuse Flux only approach\nrun the redis publish in a different thread\nblock the parser thread when downstream redis publish is blocked / slow\nnot rely on non-flux mechanism for example BlockingQueue\n\nThe DirectProcessor and subscribeOn approach does not work as expected, it turns out to be the whole flux pipeline runs in the same thread sink.next/error/complete is called.\nUnicastProcessor may honor subscribeOn, and when created with a BlockingQueue, we can achieve the first 3 goals but not the last. Same as DirectProcessor, the queue for UnicastProcessor is used as the buffer internally between processor and downstream subscribers.\nSo sounds like using @Async with BlockingQueue is the way to go.", "author": "xin-hedera", "createdAt": "2020-12-11T02:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxNjQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY3MDcxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540670719", "bodyText": "@Async and @EventListener cause BeanNotOfRequiredTypeException, so instead, use Executor to run the publish task.", "author": "xin-hedera", "createdAt": "2020-12-11T03:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxNjQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY3MDg3OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540670879", "bodyText": "block the parser thread when downstream redis publish is blocked / slow\n\nTechnically the requirement is don't increase memory unbounded. Blocking is just one approach to do that. Other is to throw an error when queue maxed (e.g. backpressure) and retry in the next poll. But am fine with Async if that accomplishes our goals.", "author": "steven-sheehy", "createdAt": "2020-12-11T03:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxNjQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxNzIzMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540517232", "bodyText": "Should be made volatile or AtomicLong. Sonar seems to complain about volatile even when used properly, so maybe AtomicLong.", "author": "steven-sheehy", "createdAt": "2020-12-10T21:41:29Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/redis/RedisEntityListener.java", "diffHunk": "@@ -51,22 +56,33 @@\n @RequiredArgsConstructor\n public class RedisEntityListener implements BatchEntityListener {\n \n+    // hardcode it now to avoid spring validation performance penalty incurred on RedisProperties.isEnabled() if it were\n+    // added to RedisProperties with validation annotations\n+    public static final int TASK_QUEUE_SIZE = 8;\n+\n     private final MirrorProperties mirrorProperties;\n     private final RedisProperties redisProperties;\n     private final RedisOperations<String, StreamMessage> redisOperations;\n-    private final List<TopicMessage> topicMessages = new ArrayList<>();\n     private final MeterRegistry meterRegistry;\n \n+    private long lastConsensusTimestamp;", "originalCommit": "d56c995855f34378dfecfcf44f2af43a7d75f2bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxOTQ5MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540519490", "bodyText": "Shouldn't remove generics. Sonar will most likely complain", "author": "steven-sheehy", "createdAt": "2020-12-10T21:45:26Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/redis/RedisEntityListener.java", "diffHunk": "@@ -101,12 +138,37 @@ public void onCleanup(EntityBatchCleanupEvent event) {\n         topicMessages.clear();\n     }\n \n+    private void generate(SynchronousSink<List<TopicMessage>> sink) {\n+        try {\n+            List<TopicMessage> messages = topicMessagesQueue.take();\n+            if (messages.isEmpty()) {\n+                sink.complete();\n+            } else {\n+                sink.next(messages);\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Unable to retrieve topicMessages from the blocking queue\", e);\n+            sink.error(new RuntimeException(\"Unexpected error when generating messages for the flow\", e));\n+        }\n+    }\n+\n+    private void publish(List<TopicMessage> messages) {\n+        try {\n+            Stopwatch stopwatch = Stopwatch.createStarted();\n+            timer.record(() -> redisOperations.executePipelined(callback(messages)));\n+            log.info(\"Finished notifying {} messages in {}\", messages.size(), stopwatch);\n+            messages.clear();\n+        } catch (Exception e) {\n+            log.error(\"Unable to publish to redis\", e);\n+        }\n+    }\n+\n     // Batch send using Redis pipelining\n-    private <K, V> SessionCallback<Object> callback() {\n+    private SessionCallback<Object> callback(List<TopicMessage> messages) {\n         return new SessionCallback<>() {\n             @Override\n-            public <K, V> Object execute(RedisOperations<K, V> operations) throws DataAccessException {\n-                for (TopicMessage topicMessage : topicMessages) {\n+            public Object execute(RedisOperations operations) {", "originalCommit": "d56c995855f34378dfecfcf44f2af43a7d75f2bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0MzAwNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540543006", "bodyText": "I recall I removed it because of sonar complaint on K, V not being used", "author": "xin-hedera", "createdAt": "2020-12-10T22:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxOTQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyMDQ3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540520478", "bodyText": "Should probably onErrorContinue since we never want to stop publishing and not know about it or keep trying.", "author": "steven-sheehy", "createdAt": "2020-12-10T21:47:10Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/redis/RedisEntityListener.java", "diffHunk": "@@ -77,20 +93,41 @@ public boolean isEnabled() {\n \n     @Override\n     public void onTopicMessage(TopicMessage topicMessage) throws ImporterException {\n+        long consensusTimestamp = topicMessage.getConsensusTimestamp();\n+        if (consensusTimestamp <= lastConsensusTimestamp) {\n+            return;\n+        }\n+\n+        lastConsensusTimestamp = consensusTimestamp;\n         topicMessages.add(topicMessage);\n     }\n \n     @Override\n     @EventListener\n-    public void onSave(EntityBatchSaveEvent event) {\n-        try {\n-            if (isEnabled()) {\n-                Stopwatch stopwatch = Stopwatch.createStarted();\n-                timer.record(() -> redisOperations.executePipelined(callback()));\n-                log.info(\"Finished notifying {} messages in {}\", topicMessages.size(), stopwatch);\n-            }\n-        } catch (Exception e) {\n-            log.error(\"Unable to publish to redis\", e);\n+    public void onSave(EntityBatchSaveEvent event) throws InterruptedException {\n+        if (!isEnabled() || topicMessages.isEmpty()) {\n+            return;\n+        }\n+\n+        // defer flux, subscription, and scheduler creation\n+        if (subscription == null) {\n+            // create a flux from the generator to pull then pump the topic messages list, immediately subscribe to the\n+            // flux to publish the topic messages list to redis service. With subscribeOn the new single thread\n+            // scheduler, the whole flux pipeline runs in a single thread.\n+            subscription = Flux.generate(this::generate)\n+                    .doOnSubscribe(s -> log.info(\"Starting redis publish flow\"))\n+                    .doFinally(s -> log.info(\"Redis publish flow stopped with {} signal\", s))\n+                    .doOnError(t -> log.error(\"Unexpected error during redis publish flow\", t))", "originalCommit": "d56c995855f34378dfecfcf44f2af43a7d75f2bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyMjg1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r540522853", "bodyText": "There's not really any point in clearing this anymore, right?", "author": "steven-sheehy", "createdAt": "2020-12-10T21:51:24Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/redis/RedisEntityListener.java", "diffHunk": "@@ -101,12 +138,37 @@ public void onCleanup(EntityBatchCleanupEvent event) {\n         topicMessages.clear();\n     }\n \n+    private void generate(SynchronousSink<List<TopicMessage>> sink) {\n+        try {\n+            List<TopicMessage> messages = topicMessagesQueue.take();\n+            if (messages.isEmpty()) {\n+                sink.complete();\n+            } else {\n+                sink.next(messages);\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Unable to retrieve topicMessages from the blocking queue\", e);\n+            sink.error(new RuntimeException(\"Unexpected error when generating messages for the flow\", e));\n+        }\n+    }\n+\n+    private void publish(List<TopicMessage> messages) {\n+        try {\n+            Stopwatch stopwatch = Stopwatch.createStarted();\n+            timer.record(() -> redisOperations.executePipelined(callback(messages)));\n+            log.info(\"Finished notifying {} messages in {}\", messages.size(), stopwatch);\n+            messages.clear();", "originalCommit": "d56c995855f34378dfecfcf44f2af43a7d75f2bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "476ac3757e60f0527527237c099195bb43b73a45", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/476ac3757e60f0527527237c099195bb43b73a45", "message": "remove flux, use single thread executor to run the publish task\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-12-11T03:45:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NTM5Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r541085392", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            //", "author": "ijungmann", "createdAt": "2020-12-11T16:51:36Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/redis/RedisEntityListener.java", "diffHunk": "@@ -51,23 +55,43 @@\n @RequiredArgsConstructor\n public class RedisEntityListener implements BatchEntityListener {\n \n+    // hardcode it now to avoid spring validation performance penalty incurred on RedisProperties.isEnabled() if it were\n+    // added to RedisProperties with validation annotations\n+    public static final int TASK_QUEUE_SIZE = 8;\n+\n     private final MirrorProperties mirrorProperties;\n     private final RedisProperties redisProperties;\n     private final RedisOperations<String, StreamMessage> redisOperations;\n-    private final List<TopicMessage> topicMessages = new ArrayList<>();\n     private final MeterRegistry meterRegistry;\n \n+    private AtomicLong lastConsensusTimestamp;\n     private Timer timer;\n+    private List<TopicMessage> topicMessages;\n+    private BlockingQueue<List<TopicMessage>> topicMessagesQueue;\n     private String topicPrefix;\n \n     @PostConstruct\n     void init() {\n+        lastConsensusTimestamp = new AtomicLong(0);\n         timer = Timer.builder(\"hedera.mirror.importer.publish.duration\")\n                 .description(\"The amount of time it took to publish the domain entity\")\n                 .tag(\"entity\", TopicMessage.class.getSimpleName())\n                 .tag(\"type\", \"redis\")\n                 .register(meterRegistry);\n+        topicMessages = new ArrayList<>();\n+        topicMessagesQueue = new ArrayBlockingQueue<>(TASK_QUEUE_SIZE);\n         topicPrefix = \"topic.\" + mirrorProperties.getShard() + \".\"; // Cache to avoid reflection penalty\n+\n+        Executor executor = Executors.newSingleThreadExecutor();\n+        executor.execute(() -> {\n+            try {\n+                while (true) {\n+                    publish(topicMessagesQueue.take());\n+                }\n+            } catch (InterruptedException ex) {\n+                //", "originalCommit": "476ac3757e60f0527527237c099195bb43b73a45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwMTgxNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r541101815", "bodyText": "I think this is probably to fix sonar complaining of an empty block. Probably safe to just Thread.currentThread().interrupt() instead even though the thread is already closing since it's out of the while.", "author": "steven-sheehy", "createdAt": "2020-12-11T17:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NTM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTMyNTk2OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1311#discussion_r541325968", "bodyText": "Got it.", "author": "ijungmann", "createdAt": "2020-12-11T21:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NTM5Mg=="}], "type": "inlineReview"}, {"oid": "84e91cfba2e2ae607a7683089f8c794520a4218d", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/84e91cfba2e2ae607a7683089f8c794520a4218d", "message": "address feedback\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-12-11T20:21:31Z", "type": "commit"}]}