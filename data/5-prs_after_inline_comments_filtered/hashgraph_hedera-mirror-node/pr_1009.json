{"pr_number": 1009, "pr_title": "Store verification info in stream file tables", "pr_createdAt": "2020-09-01T17:11:14Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009", "timeline": [{"oid": "f2290a7a45cac147da63992385261f93b0fb183f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f2290a7a45cac147da63992385261f93b0fb183f", "message": "store nodeAccountId of the node used to verify signature files and download stream file\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-01T03:50:49Z", "type": "commit"}, {"oid": "d7751899fcb5e2910560c0793eb2d93aebf7f34f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d7751899fcb5e2910560c0793eb2d93aebf7f34f", "message": "transactions and unit / integration tests\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-01T16:39:27Z", "type": "commit"}, {"oid": "63770227312ad5fdaf2e28b75f6cf295765fba95", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/63770227312ad5fdaf2e28b75f6cf295765fba95", "message": "fix RecordFileParserIntegrationTest rollback integration test\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-01T17:06:27Z", "type": "commit"}, {"oid": "4d8396f1a5aec6518883f027a0fee812526886a5", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4d8396f1a5aec6518883f027a0fee812526886a5", "message": "add node_account_id to record_file.sql, fix stateproof integration tests\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-01T17:24:43Z", "type": "commit"}, {"oid": "d413ab804f6185e41ec5e5f17c18f26ff98bf749", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d413ab804f6185e41ec5e5f17c18f26ff98bf749", "message": "fix datagenerator\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-01T17:28:39Z", "type": "commit"}, {"oid": "c3d3880f3e701dcf149f9b7c5aed306aadda9fbe", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c3d3880f3e701dcf149f9b7c5aed306aadda9fbe", "message": "add count to stream file classes / tables\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-02T01:58:19Z", "type": "commit"}, {"oid": "5251b0139aee7d5d3b9f1808a0f02cb25c11cf97", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/5251b0139aee7d5d3b9f1808a0f02cb25c11cf97", "message": "roll back on exception\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-02T02:27:49Z", "type": "commit"}, {"oid": "cce57ed4ecdefe4c13df243efa412ae63dd8d6fe", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cce57ed4ecdefe4c13df243efa412ae63dd8d6fe", "message": "Merge branch 'master' into store-verification-info-in-stream-file-tables\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-02T16:06:52Z", "type": "commit"}, {"oid": "c7e6f7f853a231395dd3620aa6e4cb43e82d663f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c7e6f7f853a231395dd3620aa6e4cb43e82d663f", "message": "change endDate default to Utility.MAX_INSTANT_LONG\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-02T16:15:16Z", "type": "commit"}, {"oid": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6b0690c2a6a9513aea8be98884958f0adfe4b035", "message": "fix condition check after endDate default is changed, also add test case\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-02T16:29:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU0OTQzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482549436", "bodyText": "Missing the convert\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private EntityId nodeAccountId;\n          \n          \n            \n               @Convert(converter = AccountIdConverter.class)\n          \n          \n            \n                private EntityId nodeAccountId;", "author": "Nana-EC", "createdAt": "2020-09-02T22:35:12Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EventFile.java", "diffHunk": "@@ -37,4 +37,8 @@\n     private String previousHash;\n \n     private int fileVersion;\n+\n+    private EntityId nodeAccountId;", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4NzA1Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482987056", "bodyText": "good catch. the reason there is no converter is EventFile is not an Entity class yet and there is not event_file table. But I agree it's better to add it.", "author": "xin-hedera", "createdAt": "2020-09-03T13:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU0OTQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU1MTc0Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482551746", "bodyText": "based on the logic so far shouldn't Long getCount() also be a member?", "author": "Nana-EC", "createdAt": "2020-09-02T22:37:11Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/StreamFile.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.NonNull;\n+\n+public interface StreamFile {\n+\n+    String getName();\n+\n+    String getFileHash();\n+\n+    void setNodeAccountId(@NonNull EntityId nodeAccountId);", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4NzYzNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482987635", "bodyText": "The three getters/setters in the interface are needed by the abstract base class Downloader while getCount is not.", "author": "xin-hedera", "createdAt": "2020-09-03T13:43:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU1MTc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU3MjE3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482572173", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                log.warn(\"Failed to verify data file from node {} corresponding to {}. Will retry another node\",\n          \n          \n            \n                                log.warn(\"Failed to verify signature of data file from node {} corresponding to {}. Will retry another node\",", "author": "Nana-EC", "createdAt": "2020-09-02T22:54:04Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -385,38 +389,34 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n                 }\n \n                 try {\n-                    File signedDataFile = downloadSignedDataFile(signature.getFile(), signature.getNode());\n+                    File signedDataFile = downloadSignedDataFile(signature.getFile(), signature.getNodeAccountIdString());\n                     if (signedDataFile == null) {\n                         continue;\n                     }\n \n-                    if (verifyDataFile(signedDataFile, signature.getHash())) {\n-                        if (Utility.isStreamFileAfterInstant(sigFilename, endDate)) {\n-                            downloaderProperties.setEnabled(false);\n-                            log.warn(\"Disabled polling after downloading all files <= endDate ({})\", endDate);\n-                            return;\n-                        }\n+                    StreamFile streamFile = readAndVerifyDataFile(signedDataFile, signature.getHashAsHex());\n+                    streamFile.setNodeAccountId(signature.getNodeAccountId());\n \n-                        // move the file to the valid directory\n-                        File destination = validPath.resolve(signedDataFile.getName()).toFile();\n-                        if (moveFile(signedDataFile, destination)) {\n-                            if (lastValidDownloadedFileHashKey != null) {\n-                                applicationStatusRepository.updateStatusValue(lastValidDownloadedFileHashKey,\n-                                        signature.getHashAsHex());\n-                            }\n-                            applicationStatusRepository\n-                                    .updateStatusValue(lastValidDownloadedFileKey, destination.getName());\n-                            valid = true;\n-                            signatures.forEach(this::moveSignatureFile);\n-                            break;\n-                        }\n-                    } else {\n-                        log.warn(\"Verification of data file {} from node {} failed. Will retry another node\",\n-                                signedDataFile.getName(), signature.getNode());\n+                    if (Utility.isStreamFileAfterInstant(sigFilename, endDate)) {\n+                        downloaderProperties.setEnabled(false);\n+                        log.warn(\"Disabled polling after downloading all files <= endDate ({})\", endDate);\n+                        return;\n                     }\n+\n+                    // move the file to the valid directory\n+                    File destination = validPath.resolve(signedDataFile.getName()).toFile();\n+                    moveFile(signedDataFile, destination);\n+                    signatures.forEach(this::moveSignatureFile);\n+\n+                    updateApplicationStatus(streamFile);\n+                    valid = true;\n+                    break;\n+                } catch (HashMismatchException e) {\n+                    log.warn(\"Failed to verify data file from node {} corresponding to {}. Will retry another node\",", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5MTIzNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482991234", "bodyText": "I think the log message is appropriate since here it's hash mismatch, not the signature's in the sig files.", "author": "xin-hedera", "createdAt": "2020-09-03T13:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU3MjE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU4NzIxMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482587210", "bodyText": "Here's a suggestion. If we refactored this like the the following would it allow you to use @transactional and simplify the code instead of having to use the transactionManager directly\nDownloader.java\npublic Multimap<String, FileStreamSignature> downloadNextBatch() {\n     ....(current code minus call to verifySigsAndDownloadDataFiles()) ...\n\n     return sigFilesMap;\n}\n\n@Transactional\npublic void verifyBatch() {\n            // Verify signature files and download corresponding files of valid signature files\n            verifySigsAndDownloadDataFiles(sigFilesMap);\n}\n\nRecordFileDownloader.java\n    @Leader\n    @Scheduled(fixedRateString = \"${hedera.mirror.importer.downloader.record.frequency:500}\")\n    public void download() {\n        downloadNextBatch();\n        verifyBatch();\n    }\n\nThis was the download and the verify logic is broken up making it easier to manage and test.", "author": "Nana-EC", "createdAt": "2020-09-02T23:11:45Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -451,7 +451,33 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n-    protected abstract boolean verifyDataFile(File file, byte[] signedHash);\n+    /**\n+     * Updates last valid downloaded file and last valid downloaded file hash key in database if applicable. Also saves\n+     * the stream file to its corresponding database table.\n+     * @param streamFile the verified stream file\n+     */\n+    private void updateApplicationStatus(StreamFile streamFile) {\n+        DefaultTransactionDefinition def = new DefaultTransactionDefinition();", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5MzQ4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482993483", "bodyText": "according to spring doc, it won't work because by default @Transactional is in proxy mode. here even though verifyBatch() is a public method, but calling it inside download() is self-invocation, which means the proxy used to add the Transactional mechanism is bypassed.", "author": "xin-hedera", "createdAt": "2020-09-03T13:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU4NzIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5NDU2Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482594566", "bodyText": "Should be current hashes not previous\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new HashMismatchException(fileName, expectedPrevFileHash, eventFile.getPreviousHash());\n          \n          \n            \n                        throw new HashMismatchException(fileName, verifiedHash, eventFile.getFileHash());", "author": "Nana-EC", "createdAt": "2020-09-02T23:22:25Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/event/EventFileDownloader.java", "diffHunk": "@@ -59,34 +61,33 @@ public void download() {\n     }\n \n     /**\n-     * Checks that hash of data file matches the verified hash and that data file is next in line based on previous file\n-     * hash. Returns false if any condition is false.\n+     * Reads the event file and checks that the file hash matches the verified hash and that data file is next in\n+     * line based on previous file hash.\n+     * @param file event file object\n+     * @param verifiedHash the verified hash in hex\n+     * @return StreamFile object\n      */\n     @Override\n-    protected boolean verifyDataFile(File file, byte[] verifiedHash) {\n+    protected StreamFile readAndVerifyDataFile(File file, String verifiedHash) {\n         String expectedPrevFileHash = applicationStatusRepository.findByStatusCode(lastValidDownloadedFileHashKey);\n         String fileName = file.getName();\n+        Instant verifyHashAfter = downloaderProperties.getMirrorProperties().getVerifyHashAfter();\n \n-        try {\n-            EventFile eventFile = eventFileReader.read(file);\n+        EventFile eventFile = eventFileReader.read(file);\n \n-            if (!verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash,\n-                    downloaderProperties.getMirrorProperties().getVerifyHashAfter(), fileName)) {\n-                log.error(\"PreviousHash mismatch for file {}. Expected = {}, Actual = {}\", fileName,\n-                        expectedPrevFileHash, eventFile.getPreviousHash());\n-                return false;\n-            }\n+        if (!verifyHashChain(eventFile.getPreviousHash(), expectedPrevFileHash, verifyHashAfter, fileName)) {\n+            throw new HashMismatchException(fileName, expectedPrevFileHash, eventFile.getPreviousHash());\n+        }\n \n-            String expectedFileHash = Hex.encodeHexString(verifiedHash);\n-            if (!eventFile.getFileHash().contentEquals(expectedFileHash)) {\n-                log.error(\"File {}'s hash mismatch. Expected = {}, Actual = {}\", fileName, expectedFileHash,\n-                        eventFile.getFileHash());\n-                return false;\n-            }\n-        } catch (ImporterException e) {\n-            log.error(e);\n-            return false;\n+        if (!eventFile.getFileHash().contentEquals(verifiedHash)) {\n+            throw new HashMismatchException(fileName, expectedPrevFileHash, eventFile.getPreviousHash());", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5NDYyMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482994620", "bodyText": "good catch. will correct it.", "author": "xin-hedera", "createdAt": "2020-09-03T13:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5NDU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5NjI3MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482596271", "bodyText": "q: would it be easier for you to just use repositories at this point? We're trying to move towards that where possible.\nWould simplify this class and hopefully shouldn't break too many tests", "author": "Nana-EC", "createdAt": "2020-09-02T23:24:57Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/balance/AccountBalancesFileLoader.java", "diffHunk": "@@ -54,6 +56,14 @@\n     private static final String UPDATE_SET_STATEMENT = \"update account_balance_sets set is_complete = ?, \" +\n             \"processing_end_timestamp = now() at time zone 'utc' where consensus_timestamp = ? and is_complete = \" +\n             \"false;\";\n+    private static final String UPDATE_ACCOUNT_BALANCE_FILE_STATEMENT = \"update account_balance_file \" +", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAxMzU3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483013573", "bodyText": "during the last refactor effort the prepared statement is left as is since I couldn't optimize the repository way to match the original performance. I'd prefer to address the performance in a separate ticket.", "author": "xin-hedera", "createdAt": "2020-09-03T14:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5NjI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMDUzMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482600532", "bodyText": "Q: Why do we save the recordFile earlier after downloading if we're still passing the object along and eventually hitting the db for its table here as before?\nIs there a separation of design we're going for? Just asking in favor of minimizing db calls.", "author": "Nana-EC", "createdAt": "2020-09-02T23:36:51Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/pubsub/PubSubRecordStreamFileListener.java", "diffHunk": "@@ -40,11 +42,19 @@\n \n     @Override\n     public void onStart(StreamFileData streamFileData) throws ImporterException {\n+        String fileName = FilenameUtils.getName(streamFileData.getFilename());\n+        if (recordFileRepository.findByName(fileName).size() != 1) {\n+            throw new MissingFileException(\"File not found in the database: \" + fileName);\n+        }\n     }\n \n     @Override\n     public void onEnd(RecordFile recordFile) throws ImporterException {\n-        recordFileRepository.save(recordFile);\n+        int count = recordFileRepository.updateLoadStats(recordFile.getName(), recordFile.getLoadStart(), recordFile.getLoadEnd());", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5ODQ1MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482998451", "bodyText": "it's the requirement of the ticket and the way we chose to implement the logic.\nonly in downloader we know the node from which sig file is verified to reach consensus & corresponding data file is downloaded and verified. We need a mechanism to either persist the node info or pass it to parser. We chose to persist the node info of the stream file in downloader thus we have a db record insert in downloader and update (load stats and other info depending on type of file) in parser.", "author": "xin-hedera", "createdAt": "2020-09-03T13:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYwMDUzMg=="}], "type": "inlineReview"}, {"oid": "64481f82d05eff7d1a8d60c4eb9293ff00db5af3", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/64481f82d05eff7d1a8d60c4eb9293ff00db5af3", "message": "address review feedback\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-03T14:26:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU4NTgxMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482585810", "bodyText": "The @Id should be the consensusTimestamp", "author": "steven-sheehy", "createdAt": "2020-09-02T23:09:43Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AccountBalanceFile.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+\n+@Data\n+@Entity\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class AccountBalanceFile implements StreamFile {\n+\n+    @Id\n+    private String name;\n+\n+    private Long consensusTimestamp;", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU4NjM3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482586375", "bodyText": "nit: Would prefer fields sorted alphabetically.", "author": "steven-sheehy", "createdAt": "2020-09-02T23:10:33Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AccountBalanceFile.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+\n+@Data\n+@Entity\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class AccountBalanceFile implements StreamFile {\n+\n+    @Id\n+    private String name;\n+\n+    private Long consensusTimestamp;\n+\n+    private Long loadStart;\n+\n+    private Long loadEnd;\n+\n+    private String fileHash;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId nodeAccountId;\n+\n+    private Long count;", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5MzY2Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482593663", "bodyText": "Is it possible to add a version field to denote version 1 vs 2?", "author": "steven-sheehy", "createdAt": "2020-09-02T23:21:07Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/AccountBalanceFile.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+\n+@Data\n+@Entity\n+@AllArgsConstructor\n+@NoArgsConstructor\n+public class AccountBalanceFile implements StreamFile {\n+\n+    @Id\n+    private String name;\n+\n+    private Long consensusTimestamp;\n+\n+    private Long loadStart;\n+\n+    private Long loadEnd;\n+\n+    private String fileHash;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId nodeAccountId;\n+", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0Njg0OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483146848", "bodyText": "I'm not aware of different versions of account balance file. So I would assume till now, it's all version 1 account balance files.", "author": "xin-hedera", "createdAt": "2020-09-03T17:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5MzY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5NjkzNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r482596937", "bodyText": "Since we can't use @Transactional here, the next best thing is TransactionTemplate. Use something like TransactionTemplate.execute(s -> {updateApplicationStatus(sf);return null;})", "author": "steven-sheehy", "createdAt": "2020-09-02T23:25:57Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -451,7 +451,33 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n-    protected abstract boolean verifyDataFile(File file, byte[] signedHash);\n+    /**\n+     * Updates last valid downloaded file and last valid downloaded file hash key in database if applicable. Also saves\n+     * the stream file to its corresponding database table.\n+     * @param streamFile the verified stream file\n+     */\n+    private void updateApplicationStatus(StreamFile streamFile) {\n+        DefaultTransactionDefinition def = new DefaultTransactionDefinition();", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE1NTg0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483155841", "bodyText": "sure. will switch to TransactionTemplate inside updateApplicationStatus", "author": "xin-hedera", "createdAt": "2020-09-03T17:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjU5NjkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA5NTU4MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483095581", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        signature.getNodeAccountId(), signature.getFile().getName(), e);\n          \n          \n            \n                                        signature.getNodeAccountIdString(), signature.getFile().getName(), e);", "author": "steven-sheehy", "createdAt": "2020-09-03T16:10:26Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -385,38 +389,34 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n                 }\n \n                 try {\n-                    File signedDataFile = downloadSignedDataFile(signature.getFile(), signature.getNode());\n+                    File signedDataFile = downloadSignedDataFile(signature.getFile(), signature.getNodeAccountIdString());\n                     if (signedDataFile == null) {\n                         continue;\n                     }\n \n-                    if (verifyDataFile(signedDataFile, signature.getHash())) {\n-                        if (Utility.isStreamFileAfterInstant(sigFilename, endDate)) {\n-                            downloaderProperties.setEnabled(false);\n-                            log.warn(\"Disabled polling after downloading all files <= endDate ({})\", endDate);\n-                            return;\n-                        }\n+                    StreamFile streamFile = readAndVerifyDataFile(signedDataFile, signature.getHashAsHex());\n+                    streamFile.setNodeAccountId(signature.getNodeAccountId());\n \n-                        // move the file to the valid directory\n-                        File destination = validPath.resolve(signedDataFile.getName()).toFile();\n-                        if (moveFile(signedDataFile, destination)) {\n-                            if (lastValidDownloadedFileHashKey != null) {\n-                                applicationStatusRepository.updateStatusValue(lastValidDownloadedFileHashKey,\n-                                        signature.getHashAsHex());\n-                            }\n-                            applicationStatusRepository\n-                                    .updateStatusValue(lastValidDownloadedFileKey, destination.getName());\n-                            valid = true;\n-                            signatures.forEach(this::moveSignatureFile);\n-                            break;\n-                        }\n-                    } else {\n-                        log.warn(\"Verification of data file {} from node {} failed. Will retry another node\",\n-                                signedDataFile.getName(), signature.getNode());\n+                    if (Utility.isStreamFileAfterInstant(sigFilename, endDate)) {\n+                        downloaderProperties.setEnabled(false);\n+                        log.warn(\"Disabled polling after downloading all files <= endDate ({})\", endDate);\n+                        return;\n                     }\n+\n+                    // move the file to the valid directory\n+                    File destination = validPath.resolve(signedDataFile.getName()).toFile();\n+                    moveFile(signedDataFile, destination);\n+                    signatures.forEach(this::moveSignatureFile);\n+\n+                    updateApplicationStatus(streamFile);\n+                    valid = true;\n+                    break;\n+                } catch (HashMismatchException e) {\n+                    log.warn(\"Failed to verify data file from node {} corresponding to {}. Will retry another node\",\n+                            signature.getNodeAccountId(), signature.getFile().getName(), e);\n                 } catch (Exception e) {\n                     log.error(\"Error downloading data file from node {} corresponding to {}. Will retry another node\",\n-                            signature.getNode(), signature.getFile().getName(), e);\n+                            signature.getNodeAccountId(), signature.getFile().getName(), e);", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA5NzAwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483097005", "bodyText": "This can be pulled to parent if you create a StreamFileRepository interface. Though maybe this has to wait until we have an EventFileRepository?", "author": "steven-sheehy", "createdAt": "2020-09-03T16:12:35Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/balance/AccountBalancesDownloader.java", "diffHunk": "@@ -22,37 +22,65 @@\n \n import io.micrometer.core.instrument.MeterRegistry;\n import java.io.File;\n-import java.util.Arrays;\n import javax.inject.Named;\n import lombok.extern.log4j.Log4j2;\n import org.springframework.scheduling.annotation.Scheduled;\n+import org.springframework.transaction.PlatformTransactionManager;\n import software.amazon.awssdk.services.s3.S3AsyncClient;\n \n import com.hedera.mirror.importer.addressbook.AddressBookService;\n+import com.hedera.mirror.importer.domain.AccountBalanceFile;\n+import com.hedera.mirror.importer.domain.StreamFile;\n import com.hedera.mirror.importer.downloader.Downloader;\n+import com.hedera.mirror.importer.exception.HashMismatchException;\n import com.hedera.mirror.importer.leader.Leader;\n+import com.hedera.mirror.importer.repository.AccountBalanceFileRepository;\n import com.hedera.mirror.importer.repository.ApplicationStatusRepository;\n import com.hedera.mirror.importer.util.Utility;\n \n @Log4j2\n @Named\n public class AccountBalancesDownloader extends Downloader {\n \n+    private AccountBalanceFileRepository accountBalanceFileRepository;\n+\n     public AccountBalancesDownloader(\n             S3AsyncClient s3Client, ApplicationStatusRepository applicationStatusRepository,\n             AddressBookService addressBookService, BalanceDownloaderProperties downloaderProperties,\n-            MeterRegistry meterRegistry) {\n-        super(s3Client, applicationStatusRepository, addressBookService, downloaderProperties, meterRegistry);\n+            PlatformTransactionManager platformTransactionManager, MeterRegistry meterRegistry, AccountBalanceFileRepository accountBalanceFileRepository) {\n+        super(s3Client, applicationStatusRepository, addressBookService, downloaderProperties, platformTransactionManager, meterRegistry);\n+        this.accountBalanceFileRepository = accountBalanceFileRepository;\n+    }\n+\n+    /**\n+     * Reads the account balance file and checks that the file hash matches the verified hash.\n+     * @param file account balance file object\n+     * @param verifiedHash the verified hash in hex\n+     * @return StreamFile object\n+     */\n+    @Override\n+    protected StreamFile readAndVerifyDataFile(File file, String verifiedHash) {\n+        String fileHash = Utility.getBalanceFileHash(file.getPath());\n+        if (!verifiedHash.contentEquals(fileHash)) {\n+            throw new HashMismatchException(file.getName(), verifiedHash, fileHash);\n+        }\n+\n+        AccountBalanceFile accountBalanceFile = new AccountBalanceFile();\n+        accountBalanceFile.setName(file.getName());\n+        accountBalanceFile.setConsensusTimestamp(Utility.getTimestampFromFilename(file.getName()));\n+        accountBalanceFile.setFileHash(fileHash);\n+        accountBalanceFile.setCount(0L);\n+        return accountBalanceFile;\n+    }\n+\n+    @Override\n+    protected void saveStreamFileRecord(StreamFile streamFile) {\n+        accountBalanceFileRepository.save((AccountBalanceFile)streamFile);", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE1NDIxNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483154215", "bodyText": "Yeah prefer to wait till we have an EventFileRepository.", "author": "xin-hedera", "createdAt": "2020-09-03T17:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA5NzAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwOTgzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483109838", "bodyText": "Would be better if Utility.verifyHashChain() is removed from Utility.parseRecordFile() and moved to Downloader. There's no need to re-verify hash chain again in parser and it simplifies Utility.parseRecordFile(). It's also more consistent with EventFileDownloader and paves the way for a future RecordFileReader.", "author": "steven-sheehy", "createdAt": "2020-09-03T16:32:51Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/record/RecordFileDownloader.java", "diffHunk": "@@ -57,28 +62,32 @@ public void download() {\n     }\n \n     /**\n-     * Checks that hash of data file matches the verified hash and that data file is next in line based on previous file\n-     * hash. Returns false if any condition is false.\n+     * Reads the data file and checks that hash of data file matches the verified hash and that data file is next in\n+     * line based on previous file hash.\n+     * @param file data file object\n+     * @param verifiedHash the verified hash in hex\n+     * @return StreamFile object\n      */\n     @Override\n-    protected boolean verifyDataFile(File file, byte[] verifiedHash) {\n+    protected StreamFile readAndVerifyDataFile(File file, String verifiedHash) {\n         String expectedPrevFileHash = applicationStatusRepository.findByStatusCode(lastValidDownloadedFileHashKey);\n-        try {\n-            RecordFile recordFile = Utility.parseRecordFile(file.getPath(), expectedPrevFileHash,\n-                    downloaderProperties.getMirrorProperties().getVerifyHashAfter(), null);\n-            if (!recordFile.getFileHash().contentEquals(Hex.encodeHexString(verifiedHash))) {\n-                return false;\n-            }\n+        RecordFile recordFile = Utility.parseRecordFile(file.getPath(), expectedPrevFileHash,", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI1Mzk2OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483253968", "bodyText": "yes and we can further pull the hash chain and hash verification into the base class.", "author": "xin-hedera", "createdAt": "2020-09-03T21:06:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEwOTgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExMDYwOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483110608", "bodyText": "Remove unused constructors increase code coverage. YAGNI", "author": "steven-sheehy", "createdAt": "2020-09-03T16:34:08Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/exception/MissingFileException.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package com.hedera.mirror.importer.exception;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+public class MissingFileException extends ImporterException {\n+\n+    private static final long serialVersionUID = -3538381075104588657L;\n+\n+    public MissingFileException(String message) {\n+        super(message);\n+    }\n+\n+    public MissingFileException(Throwable throwable) {\n+        super(throwable);", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExMzEzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483113136", "bodyText": "We should use DataSourceUtils.getConnection(dataSource) and DataSourceUtils.releaseConnection(connection, dataSource) like we do in SqlEntityListener. Then put @Transactional on loadAccountBalances(). This also needs a rollback test.", "author": "steven-sheehy", "createdAt": "2020-09-03T16:38:05Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/balance/AccountBalancesFileLoader.java", "diffHunk": "@@ -94,14 +109,19 @@ public boolean loadAccountBalances(@NonNull File balanceFile, DateRangeFilter da\n         int insertedCount = 0;\n         boolean complete = false;\n         Stopwatch stopwatch = Stopwatch.createStarted();\n+        Instant startTime = Instant.now();\n \n         try (Connection connection = dataSource.getConnection();\n              PreparedStatement insertSetStatement = connection.prepareStatement(INSERT_SET_STATEMENT);\n              PreparedStatement insertBalanceStatement = connection.prepareStatement(INSERT_BALANCE_STATEMENT);\n              PreparedStatement updateSetStatement = connection.prepareStatement(UPDATE_SET_STATEMENT);\n+             PreparedStatement updateAccountBalanceFileStatement = connection.prepareStatement(UPDATE_ACCOUNT_BALANCE_FILE_STATEMENT);\n              Stream<AccountBalance> stream = balanceFileReader.read(balanceFile)) {\n             long consensusTimestamp = -1;\n             List<AccountBalance> accountBalanceList = new ArrayList<>();\n+            boolean skip = false;\n+\n+            connection.setAutoCommit(false);", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNDk3Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483114976", "bodyText": "It would be preferable that onStart() return the RecordFile and onEnd() just recordFileRepository.save(recordFile).", "author": "steven-sheehy", "createdAt": "2020-09-03T16:40:57Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java", "diffHunk": "@@ -130,13 +132,21 @@ public boolean isEnabled() {\n \n     @Override\n     public void onStart(StreamFileData streamFileData) {\n+        String fileName = FilenameUtils.getName(streamFileData.getFilename());\n+        if (recordFileRepository.findByName(fileName).size() != 1) {\n+            throw new MissingFileException(\"File not found in the database: \" + fileName);\n+        }\n+\n         cleanup();\n     }\n \n     @Override\n     public void onEnd(RecordFile recordFile) {\n         executeBatches();\n-        recordFileRepository.save(recordFile);\n+        int count = recordFileRepository.updateLoadStats(recordFile.getName(), recordFile.getLoadStart(), recordFile.getLoadEnd());", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNjE0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483116141", "bodyText": "Id type should be Long since consensusTimestamp is the appropriate ID.", "author": "steven-sheehy", "createdAt": "2020-09-03T16:42:54Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/AccountBalanceFileRepository.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+import com.hedera.mirror.importer.domain.AccountBalanceFile;\n+\n+public interface AccountBalanceFileRepository extends CrudRepository<AccountBalanceFile, String> {", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExNjQyNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483116426", "bodyText": "Can remove with other suggestion", "author": "steven-sheehy", "createdAt": "2020-09-03T16:43:24Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/RecordFileRepository.java", "diffHunk": "@@ -21,10 +21,20 @@\n  */\n \n import java.util.List;\n+import org.springframework.data.jpa.repository.Modifying;\n+import org.springframework.data.jpa.repository.Query;\n import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.query.Param;\n+import org.springframework.transaction.annotation.Transactional;\n \n import com.hedera.mirror.importer.domain.RecordFile;\n \n public interface RecordFileRepository extends CrudRepository<RecordFile, Long> {\n+\n     List<RecordFile> findByName(String name);\n+\n+    @Transactional\n+    @Modifying\n+    @Query(\"UPDATE RecordFile SET loadStart = :loadStart, loadEnd = :loadEnd WHERE name = :name\")\n+    int updateLoadStats(@Param(\"name\") String name, @Param(\"loadStart\") Long loadStart, @Param(\"loadEnd\") Long loadEnd);", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyMzg1NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483123855", "bodyText": "We should have a post assert to validate count, loadstart, etc. are updated.", "author": "steven-sheehy", "createdAt": "2020-09-03T16:55:56Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/balance/AccountBalancesFileLoaderTest.java", "diffHunk": "@@ -80,6 +87,10 @@ void setup() {\n                 .filterFiles(balanceFile.getFilename())\n                 .to(streamType.getPath(), streamType.getValid());\n         testFile = fileCopier.getTo().resolve(balanceFile.getFilename()).toFile();\n+\n+        EntityId nodeAccountId = EntityId.of(TestUtils.toAccountId(\"0.0.3\"));\n+        AccountBalanceFile accountBalanceFile = new AccountBalanceFile(balanceFile.getFilename(), balanceFile.getConsensusTimestamp(), 0L, 0L, \"\", nodeAccountId, 0L);\n+        accountBalanceFileRepository.save(accountBalanceFile);", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyNDkzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483124938", "bodyText": "Wrong method name", "author": "steven-sheehy", "createdAt": "2020-09-03T16:57:50Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListenerTest.java", "diffHunk": "@@ -245,9 +251,22 @@ void testRecordFile() {\n     }\n \n     private String completeFileAndCommit() {\n-        String newFileHash = UUID.randomUUID().toString();\n-        sqlEntityListener.onEnd(new RecordFile(1L, 2L, null, fileName, 0L, 0L, newFileHash, \"fileHash0\", 0));\n-        return newFileHash;\n+        sqlEntityListener.onEnd(recordFile);\n+        return recordFile.getFileHash();\n+    }\n+\n+    private RecordFile insertAccountBalanceFile(String filename, String fileHash, String prevHash) {", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyNTQ2Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483125462", "bodyText": "Should have a missing record file test", "author": "steven-sheehy", "createdAt": "2020-09-03T16:58:44Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListenerTest.java", "diffHunk": "@@ -72,9 +73,13 @@\n     private final SqlProperties sqlProperties;\n \n     private String fileName = \"2019-08-30T18_10_00.419072Z.rcd\";\n+    private RecordFile recordFile;\n \n     @BeforeEach\n     final void beforeEach() {\n+        String newFileHash = UUID.randomUUID().toString();\n+        recordFile = insertAccountBalanceFile(fileName, newFileHash, \"fileHash0\");", "originalCommit": "6b0690c2a6a9513aea8be98884958f0adfe4b035", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3db0d7c8925da4d4af42bfe60ce1217e7d3c0380", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3db0d7c8925da4d4af42bfe60ce1217e7d3c0380", "message": "address additional review feedback\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-04T00:06:01Z", "type": "commit"}, {"oid": "fe89c0b8b6a652d10bd7b0f28c4a7e8c78a35dcf", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fe89c0b8b6a652d10bd7b0f28c4a7e8c78a35dcf", "message": "add back hashchain verificaton in RecordFileParser and the corresponding test cases\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-04T17:27:22Z", "type": "commit"}, {"oid": "54a048a4ab8818d5075c92316eae06b2f305582c", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/54a048a4ab8818d5075c92316eae06b2f305582c", "message": "minor, format\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-04T18:08:54Z", "type": "commit"}, {"oid": "2109d887aa7b2d42e10f16f0ada5d4430e623d61", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/2109d887aa7b2d42e10f16f0ada5d4430e623d61", "message": "use bigint in place of nanos_timestamp\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-04T19:18:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg1OTgxNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483859817", "bodyText": "You can just inject the TransactionTemplate directly. Spring Boot already creates one as a bean.", "author": "steven-sheehy", "createdAt": "2020-09-04T21:53:59Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -96,11 +102,12 @@\n \n     public Downloader(S3AsyncClient s3Client, ApplicationStatusRepository applicationStatusRepository,\n                       AddressBookService addressBookService, DownloaderProperties downloaderProperties,\n-                      MeterRegistry meterRegistry) {\n+                      PlatformTransactionManager platformTransactionManager, MeterRegistry meterRegistry) {", "originalCommit": "2109d887aa7b2d42e10f16f0ada5d4430e623d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY1MDEzMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r486650130", "bodyText": "changed to inject TransactionTemplate", "author": "xin-hedera", "createdAt": "2020-09-10T21:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg1OTgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2MTc1MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483861751", "bodyText": "Name has a unique constraint, so this can be changed to return an Optional<RecordFile> and cleanup the logic in the calling classes.", "author": "steven-sheehy", "createdAt": "2020-09-04T22:01:19Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/RecordFileRepository.java", "diffHunk": "@@ -26,5 +26,6 @@\n import com.hedera.mirror.importer.domain.RecordFile;\n \n public interface RecordFileRepository extends CrudRepository<RecordFile, Long> {\n+\n     List<RecordFile> findByName(String name);", "originalCommit": "2109d887aa7b2d42e10f16f0ada5d4430e623d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY1MDI2NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r486650265", "bodyText": "changed to Optional<RecordFile>", "author": "xin-hedera", "createdAt": "2020-09-10T21:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2MTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2MjgzMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r483862830", "bodyText": "We shouldn't catch this exception as it will skip the balance file and move on to the next even for transient errors like database down.", "author": "steven-sheehy", "createdAt": "2020-09-04T22:05:45Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/balance/BalanceFileParser.java", "diffHunk": "@@ -77,12 +77,15 @@ public void parse() {\n     }\n \n     private void parseBalanceFile(File balanceFile, DateRangeFilter dateRangeFilter) {\n-        if (accountBalancesFileLoader.loadAccountBalances(balanceFile, dateRangeFilter)) {\n+        try {\n+            accountBalancesFileLoader.loadAccountBalances(balanceFile, dateRangeFilter);\n             if (parserProperties.isKeepFiles()) {\n                 Utility.archiveFile(balanceFile, parserProperties.getParsedPath());\n             } else {\n                 FileUtils.deleteQuietly(balanceFile);\n             }\n+        } catch (Exception ex) {", "originalCommit": "2109d887aa7b2d42e10f16f0ada5d4430e623d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY1MTMxMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r486651312", "bodyText": "my thought is since account balance files are not hash chained so in case of transient database issue, we try the best to process as many files in a batch and pick up what's left in the next scheduled run", "author": "xin-hedera", "createdAt": "2020-09-10T21:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2MjgzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY3ODIzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r486678236", "bodyText": "Agreed", "author": "steven-sheehy", "createdAt": "2020-09-10T22:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2MjgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5MjIwMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r485092202", "bodyText": "This looks like a change in behavior. Previously if not complete then it would not move the file and continue to retry it. Now it is skipping it. We should probably throw an exception above, which causes a rollback and will retry the file later.", "author": "steven-sheehy", "createdAt": "2020-09-08T17:44:12Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/balance/AccountBalancesFileLoader.java", "diffHunk": "@@ -110,48 +128,52 @@ public boolean loadAccountBalances(@NonNull File balanceFile, DateRangeFilter da\n                     consensusTimestamp = accountBalance.getId().getConsensusTimestamp();\n                     if (timestampFromFileName != consensusTimestamp) {\n                         // The assumption is that the dataset has been validated via signatures and running hashes,\n-                        // so it is\n-                        // the \"next\" dataset, and the consensus timestamp in it is correct.\n-                        // The fact that the filename timestamp and timestamp in the file differ should still be\n-                        // investigated.\n-                        log.error(\"Account balance dataset timestamp mismatch! Processing can continue, but this must\" +\n-                                        \" be \" +\n-                                        \"investigated! Dataset {} internal timestamp {} filename timestamp {}.\",\n+                        // so it is the \"next\" dataset, and the consensus timestamp in it is correct. The fact that\n+                        // the filename timestamp and timestamp in the file differ should still be investigated.\n+                        log.error(\"Account balance dataset timestamp mismatch! Processing can continue, but this \" +\n+                                        \"must be investigated! Dataset {} internal timestamp {} filename timestamp {}.\",\n                                 fileName, consensusTimestamp, timestampFromFileName);\n                     }\n \n                     if (dateRangeFilter != null && !dateRangeFilter.filter(consensusTimestamp)) {\n                         log.warn(\"Account balances file {} not in configured date range {}, skip it\",\n                                 fileName, dateRangeFilter);\n-                        complete = true;\n-                        break;\n+                        skip = true;\n+                    } else {\n+                        insertAccountBalanceSet(insertSetStatement, consensusTimestamp);\n                     }\n-\n-                    insertAccountBalanceSet(insertSetStatement, consensusTimestamp);\n                 }\n \n                 validCount++;\n-                accountBalanceList.add(accountBalance);\n-                insertedCount += tryInsertBatchAccountBalance(insertBalanceStatement, accountBalanceList,\n-                        insertBatchSize);\n+\n+                if (!skip) {\n+                    accountBalanceList.add(accountBalance);\n+                    insertedCount += tryInsertBatchAccountBalance(insertBalanceStatement, accountBalanceList,\n+                            insertBatchSize);\n+                }\n             }\n \n-            insertedCount += tryInsertBatchAccountBalance(insertBalanceStatement, accountBalanceList, 1);\n-            complete = (insertedCount == validCount);\n-            updateAccountBalanceSet(updateSetStatement, complete, consensusTimestamp);\n-        } catch (InvalidDatasetException | SQLException ex) {\n-            log.error(\"Failed to load account balances file \" + fileName, ex);\n-        }\n+            if (!skip) {\n+                insertedCount += tryInsertBatchAccountBalance(insertBalanceStatement, accountBalanceList, 1);\n+                complete = (insertedCount == validCount);\n+            } else {\n+                complete = true;\n+            }\n \n-        if (complete) {\n-            log.info(\"Successfully processed account balances file {} with {} out of {} records inserted in {}\",\n-                    fileName, insertedCount, validCount, stopwatch);\n-        } else {\n-            log.error(\"ERRORS processing account balances file {} with {} out of {} records inserted in {}\", fileName,\n-                    insertedCount, validCount, stopwatch);\n+            updateAccountBalanceSet(updateSetStatement, complete, consensusTimestamp);\n+            updateAccountBalanceFile(updateAccountBalanceFileStatement, consensusTimestamp, validCount,\n+                    startTime.getEpochSecond(), Instant.now().getEpochSecond(), fileName);\n+\n+            if (complete) {\n+                log.info(\"Successfully processed account balances file {} with {} out of {} records inserted in {}\",\n+                        fileName, insertedCount, validCount, stopwatch);\n+            } else {\n+                log.error(\"ERRORS processing account balances file {} with {} records parsed so far in {}\",\n+                        fileName, validCount, stopwatch);\n+            }\n+        } finally {\n+            DataSourceUtils.releaseConnection(connection, dataSource);\n         }\n-\n-        return complete;", "originalCommit": "2109d887aa7b2d42e10f16f0ada5d4430e623d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2NDk3MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r486664971", "bodyText": "refactored. after changing tryInsertBatchAccountBalance to throw under SQL execution failure, the original condition complete = (insertedCount == validCount) would always be true so unnecessary\nNow in loadAccountBalances, any db error would eventually cause ParserSQLException so spring will roll back the transaction", "author": "xin-hedera", "createdAt": "2020-09-10T22:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5MjIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5MzI3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r485093278", "bodyText": "We can probably invert this and just throw an exception if failed instead of using counts to track if failed.", "author": "steven-sheehy", "createdAt": "2020-09-08T17:46:20Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/balance/AccountBalancesFileLoader.java", "diffHunk": "@@ -160,43 +182,29 @@ private void insertAccountBalanceSet(PreparedStatement insertSetStatement, long\n     }\n \n     private int tryInsertBatchAccountBalance(PreparedStatement insertBalanceStatement,\n-                                             List<AccountBalance> accountBalanceList, int threshold) {\n+                                             List<AccountBalance> accountBalanceList, int threshold) throws SQLException {\n         if (accountBalanceList.size() < threshold) {\n             return 0;\n         }\n \n-        int batchSize = 0;\n         for (var accountBalance : accountBalanceList) {\n             AccountBalance.Id id = accountBalance.getId();\n-            try {\n-                insertBalanceStatement.setLong(F_INSERT_BALANCE.CONSENSUS_TIMESTAMP.ordinal(),\n-                        id.getConsensusTimestamp());\n-                insertBalanceStatement.setShort(F_INSERT_BALANCE.ACCOUNT_REALM_NUM.ordinal(),\n-                        (short) id.getAccountRealmNum());\n-                insertBalanceStatement.setInt(F_INSERT_BALANCE.ACCOUNT_NUM.ordinal(), id.getAccountNum());\n-                insertBalanceStatement.setLong(F_INSERT_BALANCE.BALANCE.ordinal(), accountBalance.getBalance());\n-                insertBalanceStatement.addBatch();\n-                batchSize++;\n-            } catch (SQLException ex) {\n-                log.error(\"Failed to add account balance to the batch\", ex);\n-            }\n+            insertBalanceStatement.setLong(F_INSERT_BALANCE.CONSENSUS_TIMESTAMP.ordinal(), id.getConsensusTimestamp());\n+            insertBalanceStatement.setShort(F_INSERT_BALANCE.ACCOUNT_REALM_NUM.ordinal(),\n+                    (short) id.getAccountRealmNum());\n+            insertBalanceStatement.setInt(F_INSERT_BALANCE.ACCOUNT_NUM.ordinal(), id.getAccountNum());\n+            insertBalanceStatement.setLong(F_INSERT_BALANCE.BALANCE.ordinal(), accountBalance.getBalance());\n+            insertBalanceStatement.addBatch();\n         }\n \n         accountBalanceList.clear();\n-        if (batchSize == 0) {\n-            return 0;\n-        }\n \n         int insertedCount = 0;\n-        try {\n-            var result = insertBalanceStatement.executeBatch();\n-            for (int code : result) {\n-                if (code != Statement.EXECUTE_FAILED) {\n-                    insertedCount++;\n-                }\n+        var result = insertBalanceStatement.executeBatch();\n+        for (int code : result) {\n+            if (code != Statement.EXECUTE_FAILED) {\n+                insertedCount++;", "originalCommit": "2109d887aa7b2d42e10f16f0ada5d4430e623d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MzM3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r486663373", "bodyText": "removed unnecessary count, inverted the condition and now it throws ParserSQLException if the underlying db driver will continue execution on failure of a statement", "author": "xin-hedera", "createdAt": "2020-09-10T22:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5MzI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NjE4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r485096180", "bodyText": "It would be cleaner to separate read from verify and to pass the full objects instead of individual fields to verify.\nStreamFile streamFile = readStreamFile(signedDataFile);\nstreamFile.setNodeAccountId(signature.getNodeAccountId());\n\nverify(streamFile, signature);", "author": "steven-sheehy", "createdAt": "2020-09-08T17:51:39Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -385,38 +389,34 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n                 }\n \n                 try {\n-                    File signedDataFile = downloadSignedDataFile(signature.getFile(), signature.getNode());\n+                    File signedDataFile = downloadSignedDataFile(signature.getFile(), signature.getNodeAccountIdString());\n                     if (signedDataFile == null) {\n                         continue;\n                     }\n \n-                    if (verifyDataFile(signedDataFile, signature.getHash())) {\n-                        if (Utility.isStreamFileAfterInstant(sigFilename, endDate)) {\n-                            downloaderProperties.setEnabled(false);\n-                            log.warn(\"Disabled polling after downloading all files <= endDate ({})\", endDate);\n-                            return;\n-                        }\n+                    StreamFile streamFile = readAndVerifyStreamFile(signedDataFile, signature.getHashAsHex());", "originalCommit": "2109d887aa7b2d42e10f16f0ada5d4430e623d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjU0Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r486662546", "bodyText": "made the suggested change", "author": "xin-hedera", "createdAt": "2020-09-10T22:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NjE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5ODQ3Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r485098477", "bodyText": "I think moveFile() should be within the transaction at the end so if it fails the database updates are rolled back as well.", "author": "steven-sheehy", "createdAt": "2020-09-08T17:55:58Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -385,38 +389,34 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n                 }\n \n                 try {\n-                    File signedDataFile = downloadSignedDataFile(signature.getFile(), signature.getNode());\n+                    File signedDataFile = downloadSignedDataFile(signature.getFile(), signature.getNodeAccountIdString());\n                     if (signedDataFile == null) {\n                         continue;\n                     }\n \n-                    if (verifyDataFile(signedDataFile, signature.getHash())) {\n-                        if (Utility.isStreamFileAfterInstant(sigFilename, endDate)) {\n-                            downloaderProperties.setEnabled(false);\n-                            log.warn(\"Disabled polling after downloading all files <= endDate ({})\", endDate);\n-                            return;\n-                        }\n+                    StreamFile streamFile = readAndVerifyStreamFile(signedDataFile, signature.getHashAsHex());\n+                    streamFile.setNodeAccountId(signature.getNodeAccountId());\n \n-                        // move the file to the valid directory\n-                        File destination = validPath.resolve(signedDataFile.getName()).toFile();\n-                        if (moveFile(signedDataFile, destination)) {\n-                            if (lastValidDownloadedFileHashKey != null) {\n-                                applicationStatusRepository.updateStatusValue(lastValidDownloadedFileHashKey,\n-                                        signature.getHashAsHex());\n-                            }\n-                            applicationStatusRepository\n-                                    .updateStatusValue(lastValidDownloadedFileKey, destination.getName());\n-                            valid = true;\n-                            signatures.forEach(this::moveSignatureFile);\n-                            break;\n-                        }\n-                    } else {\n-                        log.warn(\"Verification of data file {} from node {} failed. Will retry another node\",\n-                                signedDataFile.getName(), signature.getNode());\n+                    if (Utility.isStreamFileAfterInstant(sigFilename, endDate)) {\n+                        downloaderProperties.setEnabled(false);\n+                        log.warn(\"Disabled polling after downloading all files <= endDate ({})\", endDate);\n+                        return;\n                     }\n+\n+                    // move the file to the valid directory\n+                    File destination = validPath.resolve(signedDataFile.getName()).toFile();\n+                    moveFile(signedDataFile, destination);", "originalCommit": "2109d887aa7b2d42e10f16f0ada5d4430e623d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjgyOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r486662828", "bodyText": "moveFile is now called inside transactionTemplate's callback", "author": "xin-hedera", "createdAt": "2020-09-10T22:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5ODQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwMDQ5NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r485100494", "bodyText": "This is a change in behavior as it won't try another node now. We shouldn't catch and rollback here manually. Let TransactionTemplate automatically rollback on exception and let the exception bubble up so it can retry the next node.", "author": "steven-sheehy", "createdAt": "2020-09-08T17:59:52Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -451,7 +451,50 @@ private File downloadSignedDataFile(File sigFile, String nodeAccountId) {\n         return null;\n     }\n \n-    protected abstract boolean verifyDataFile(File file, byte[] signedHash);\n+    private StreamFile readAndVerifyStreamFile(File file, String verifiedHash) {\n+        String fileName = file.getName();\n+        StreamFile streamFile = readStreamFile(file);\n+\n+        if (lastValidDownloadedFileHashKey != null) {\n+            String expectedPrevFileHash = applicationStatusRepository.findByStatusCode(lastValidDownloadedFileHashKey);\n+            Instant verifyHashAfter = downloaderProperties.getMirrorProperties().getVerifyHashAfter();\n+            if (!verifyHashChain(streamFile.getPreviousHash(), expectedPrevFileHash, verifyHashAfter, fileName)) {\n+                throw new HashMismatchException(fileName, expectedPrevFileHash, streamFile.getPreviousHash());\n+            }\n+        }\n+\n+        if (!streamFile.getFileHash().contentEquals(verifiedHash)) {\n+            throw new HashMismatchException(fileName, verifiedHash, streamFile.getFileHash());\n+        }\n+\n+        return streamFile;\n+    }\n+\n+    /**\n+     * Updates last valid downloaded file and last valid downloaded file hash key in database if applicable. Also saves\n+     * the stream file to its corresponding database table.\n+     * @param streamFile the verified stream file\n+     */\n+    private void updateApplicationStatus(StreamFile streamFile) {\n+        transactionTemplate.executeWithoutResult(status -> {\n+            try {\n+                if (lastValidDownloadedFileHashKey != null) {\n+                    applicationStatusRepository\n+                            .updateStatusValue(lastValidDownloadedFileHashKey, streamFile.getFileHash());\n+                }\n+                applicationStatusRepository.updateStatusValue(lastValidDownloadedFileKey, streamFile.getName());\n+\n+                saveStreamFileRecord(streamFile);\n+            } catch (Exception ex) {\n+                log.error(\"Roll back the transaction due to error\", ex);", "originalCommit": "2109d887aa7b2d42e10f16f0ada5d4430e623d61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUwNjMwOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r486506308", "bodyText": "The catch and log here is intended to log the original exception so we have the complete stack trace. I'll run it manually to see if it's not needed and the TransactionException thrown by TransactionTemplate has all info.\nThe logic here does not change the behavior because the setRollBackOnly call will cause transactionTemplate to throw TransactionException.", "author": "xin-hedera", "createdAt": "2020-09-10T17:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwMDQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2Mjk1MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r486662951", "bodyText": "removed the catch and log", "author": "xin-hedera", "createdAt": "2020-09-10T22:14:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwMDQ5NA=="}], "type": "inlineReview"}, {"oid": "0a0eee99533f2d5351939e94ee92cd7c3da618dd", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0a0eee99533f2d5351939e94ee92cd7c3da618dd", "message": "get load_start and load_end from processing_start/end_timestamp in account_balance_sets\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-10T18:37:06Z", "type": "commit"}, {"oid": "c0d1b7d7cfc3c687e92b2eb5f76e0111433fba7d", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c0d1b7d7cfc3c687e92b2eb5f76e0111433fba7d", "message": "inject TransactionTemplate\nchange RecordFileRepository.findByName to return Optional\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-10T18:46:19Z", "type": "commit"}, {"oid": "c9b81efc2263916c9efed9e854c16985e9372e42", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c9b81efc2263916c9efed9e854c16985e9372e42", "message": "move cleanup_V1.28.1.sql to test resources\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-10T18:58:32Z", "type": "commit"}, {"oid": "cb5d8ec116acd9248135a5ffcbd49e28ab79de06", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cb5d8ec116acd9248135a5ffcbd49e28ab79de06", "message": "catch SQLException and wrap it in ParserSQLException so transaction manager will roll back the transaction\n\nthrow ParserSQLException if the there are failures in the batch\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-10T20:21:58Z", "type": "commit"}, {"oid": "fc9b13b8385c5d7b802f2bc7e4c746bc134ac104", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fc9b13b8385c5d7b802f2bc7e4c746bc134ac104", "message": "move moveFile into updateApplicationStatus so it's a uow and if moveFile fails the db transaction is rolled back\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-10T20:46:26Z", "type": "commit"}, {"oid": "f409a3265f933197ecb1a02f0cea405eb5649265", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f409a3265f933197ecb1a02f0cea405eb5649265", "message": "simplify the logic in AccountBalancesFileLoader.loadAccountBalances\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-10T22:06:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4NDEyNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1009#discussion_r486684125", "bodyText": "Looks like insertAccountBalanceSet is conditional but updateAccountBalanceSet is unconditional. Latter should probably be inside if statement.", "author": "steven-sheehy", "createdAt": "2020-09-10T23:15:20Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/balance/AccountBalancesFileLoader.java", "diffHunk": "@@ -110,101 +127,95 @@ public boolean loadAccountBalances(@NonNull File balanceFile, DateRangeFilter da\n                     consensusTimestamp = accountBalance.getId().getConsensusTimestamp();\n                     if (timestampFromFileName != consensusTimestamp) {\n                         // The assumption is that the dataset has been validated via signatures and running hashes,\n-                        // so it is\n-                        // the \"next\" dataset, and the consensus timestamp in it is correct.\n-                        // The fact that the filename timestamp and timestamp in the file differ should still be\n-                        // investigated.\n-                        log.error(\"Account balance dataset timestamp mismatch! Processing can continue, but this must\" +\n-                                        \" be \" +\n-                                        \"investigated! Dataset {} internal timestamp {} filename timestamp {}.\",\n+                        // so it is the \"next\" dataset, and the consensus timestamp in it is correct. The fact that\n+                        // the filename timestamp and timestamp in the file differ should still be investigated.\n+                        log.error(\"Account balance dataset timestamp mismatch! Processing can continue, but this \" +\n+                                        \"must be investigated! Dataset {} internal timestamp {} filename timestamp {}.\",\n                                 fileName, consensusTimestamp, timestampFromFileName);\n                     }\n \n                     if (dateRangeFilter != null && !dateRangeFilter.filter(consensusTimestamp)) {\n                         log.warn(\"Account balances file {} not in configured date range {}, skip it\",\n                                 fileName, dateRangeFilter);\n-                        complete = true;\n-                        break;\n+                        skip = true;\n+                    } else {\n+                        insertAccountBalanceSet(insertSetStatement, consensusTimestamp);\n                     }\n-\n-                    insertAccountBalanceSet(insertSetStatement, consensusTimestamp);\n                 }\n \n                 validCount++;\n-                accountBalanceList.add(accountBalance);\n-                insertedCount += tryInsertBatchAccountBalance(insertBalanceStatement, accountBalanceList,\n-                        insertBatchSize);\n+\n+                if (!skip) {\n+                    accountBalanceList.add(accountBalance);\n+                    tryInsertBatchAccountBalance(insertBalanceStatement, accountBalanceList, insertBatchSize);\n+                }\n             }\n \n-            insertedCount += tryInsertBatchAccountBalance(insertBalanceStatement, accountBalanceList, 1);\n-            complete = (insertedCount == validCount);\n-            updateAccountBalanceSet(updateSetStatement, complete, consensusTimestamp);\n-        } catch (InvalidDatasetException | SQLException ex) {\n-            log.error(\"Failed to load account balances file \" + fileName, ex);\n-        }\n+            if (!skip) {\n+                tryInsertBatchAccountBalance(insertBalanceStatement, accountBalanceList, 1);\n+            }\n+            updateAccountBalanceSet(updateSetStatement, consensusTimestamp);", "originalCommit": "f409a3265f933197ecb1a02f0cea405eb5649265", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d7eb1044766ed4582e24850b46c09299acfe30a4", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d7eb1044766ed4582e24850b46c09299acfe30a4", "message": "move updateAccountBalanceSet inside the if statement\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-11T00:45:35Z", "type": "commit"}]}