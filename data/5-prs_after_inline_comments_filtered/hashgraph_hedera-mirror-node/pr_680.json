{"pr_number": 680, "pr_title": "Add updateEntity() and updateTransaction() to TransactionHandler", "pr_createdAt": "2020-04-10T06:45:01Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/680", "timeline": [{"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8686f1d495948844ff363344cad7fb9d4124a4c6", "message": "Add updateEntity() and updateTransaction() to TransactionHandler\n\n- Moved functionality from RecordItemParser to respective implementations of\n  TransactionHandler.updateEntity() and updateTransaction()\n- Before recent cleanups, RIP.onItem() used to be 300+ lines. Now it's ~75.\n- EntityRepository:\n  - Moved lookupOrCreateId(EntityId) to EntityRepository\n  - Removed saveAndCacheEntityId(), not needed anymore after recent cleanups\n  - Big cache is needed only to lookup db id for an entity because of FKs.\n    No need of entity type in cache. Going forward, we want to removing FKs, and hence the cache.\n    So changed findEntityIdByNativeIds() to return just Long. Simplifies the query too.\n- Fix bad tests in RecordItemParserContractTest and RecordItemParserCryptoTest\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-10T19:38:08Z", "type": "commit"}, {"oid": "8686f1d495948844ff363344cad7fb9d4124a4c6", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8686f1d495948844ff363344cad7fb9d4124a4c6", "message": "Add updateEntity() and updateTransaction() to TransactionHandler\n\n- Moved functionality from RecordItemParser to respective implementations of\n  TransactionHandler.updateEntity() and updateTransaction()\n- Before recent cleanups, RIP.onItem() used to be 300+ lines. Now it's ~75.\n- EntityRepository:\n  - Moved lookupOrCreateId(EntityId) to EntityRepository\n  - Removed saveAndCacheEntityId(), not needed anymore after recent cleanups\n  - Big cache is needed only to lookup db id for an entity because of FKs.\n    No need of entity type in cache. Going forward, we want to removing FKs, and hence the cache.\n    So changed findEntityIdByNativeIds() to return just Long. Simplifies the query too.\n- Fix bad tests in RecordItemParserContractTest and RecordItemParserCryptoTest\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-10T19:38:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMDk1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407500953", "bodyText": "nit: isn't this duplicate code with ContractCreateTransactionHandler.updateEntity()\nIf so shouldn't the AutoRenew, Key and proxy account logic from the TransactionBody be shared and the differences be called?", "author": "Nana-EC", "createdAt": "2020-04-13T14:17:39Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoCreateTransactionHandler.java", "diffHunk": "@@ -39,4 +44,26 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateTransaction(Transaction transaction, RecordItem recordItem) {\n+        transaction.setInitialBalance(recordItem.getTransactionBody().getCryptoCreateAccount().getInitialBalance());\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYzNDgyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407634823", "bodyText": "wanted to, you know i really don't like duplication of code chunks :)\nBut not possible here since we can't write something like\n<T> void processCommonFieldsForCreate(T transactionBody) {\n  ....common logic\n}\n\nIf there's another simple way, lemme know.\nDitto for other similar comments. Will leave this one open.", "author": "apeksharma", "createdAt": "2020-04-13T18:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMDk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY1NjIyMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407656221", "bodyText": "one thing could be creating utility (not base class) like\nvoid updateEntityAutoRenewPeriod(Entity entity, Duration autoRenewPeriod) {\n  if (autoRenewPeriod.getSeconds() != 0) { // proxy for hasAutoRenewPeriod()\n    entity.setAutoRenewPeriod(autoRenewPeriod.getSeconds());\n  }\n\nThen only use following in TH.updateEntity() fns.\nTransactionHandlerUtility.updateEntityAutoRenewPeriod(entity, txMessage.getAutoRenewPeriod()\nHowever, i don't think it's any better, so left it as such.", "author": "apeksharma", "createdAt": "2020-04-13T19:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMDk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMTMwMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407501303", "bodyText": "Same comments. Good amount of duplicate logic shared with ContractUpdateTransactionHandler.updateEntity()", "author": "Nana-EC", "createdAt": "2020-04-13T14:18:21Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/CryptoUpdateTransactionHandler.java", "diffHunk": "@@ -39,4 +44,24 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        CryptoUpdateTransactionBody txMessage = recordItem.getTransactionBody().getCryptoUpdateAccount();", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwMjE0NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407502145", "bodyText": "Duplicate code with FileCreateTransactionHandler. updateEntity()", "author": "Nana-EC", "createdAt": "2020-04-13T14:19:50Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/FileUpdateTransactionHandler.java", "diffHunk": "@@ -39,4 +42,15 @@ public EntityId getEntityId(RecordItem recordItem) {\n     public boolean updatesEntity() {\n         return true;\n     }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwNDU3Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407504576", "bodyText": "nit: you call entityId.getId() 3 times. Might as well just get it once and use it 3 times.", "author": "Nana-EC", "createdAt": "2020-04-13T14:24:17Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/EntityRepositoryCustomImpl.java", "diffHunk": "@@ -49,8 +49,21 @@\n         return results;\n     }\n \n-    public <S extends Entities> EntityId saveAndCacheEntityId(S entity) {\n-        var saved = entityRepository.save(entity);\n-        return entityRepository.cache(saved.toEntityId());\n+    /**\n+     * @param entityId for which the id needs to be looked up (from cache/repo). If no id is found, the the entity is\n+     *                 inserted into the repo and the newly minted id is returned.\n+     * @return looked up/newly minted id of the given entityId.\n+     */\n+    public long lookupOrCreateId(EntityId entityId) {\n+        if (entityId.getId() != null && entityId.getId() != 0) {", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NjY3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407646673", "bodyText": "done.", "author": "apeksharma", "createdAt": "2020-04-13T18:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUwNDU3Ng=="}], "type": "inlineReview"}, {"oid": "ed0e7a27b9ea801bfa58d6aea6ffbf2e7106660f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ed0e7a27b9ea801bfa58d6aea6ffbf2e7106660f", "message": "address NPE in autoRenewAccount\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-13T18:44:57Z", "type": "commit"}, {"oid": "617acd2c6adcc310c45ba6841827f8808b7e265d", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/617acd2c6adcc310c45ba6841827f8808b7e265d", "message": "Merge branch 'master' into parser_03", "committedDate": "2020-04-13T18:52:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MjMzNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407642335", "bodyText": "Would prefer not storing these as variables as they're not immutable. Hibernate may or may not populate id on object passed to save. Would prefer helper method entityId()", "author": "steven-sheehy", "createdAt": "2020-04-13T18:37:53Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/EntityRepositoryTest.java", "diffHunk": "@@ -21,13 +21,16 @@\n  */\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static org.junit.jupiter.api.Assertions.*;\n \n import org.junit.jupiter.api.Test;\n \n import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n \n public class EntityRepositoryTest extends AbstractRepositoryTest {\n+    private static final EntityId ENTITY_ID = new EntityId(null, 1L, 2L, 3L, EntityTypeEnum.ACCOUNT.getId());\n+    private static final Entities ENTITY = ENTITY_ID.toEntity();", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwOTcxMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407709712", "bodyText": "done.", "author": "apeksharma", "createdAt": "2020-04-13T20:44:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0MjMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NDMxNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407644317", "bodyText": "Would prefer transactionBody and transactionRecord not be stored as it's confusing for sub-classes if they should use getDefaultTransactionBody()/getDefaultTransactionRecord() or use default stored in parent. It also couples the two unnecessarily.", "author": "steven-sheehy", "createdAt": "2020-04-13T18:41:36Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/transactionhandler/AbstractTransactionHandlerTest.java", "diffHunk": "@@ -28,14 +28,19 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.TestInfo;\n+import org.mockito.Mock;\n \n import com.hedera.mirror.importer.domain.EntityId;\n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.parser.domain.RecordItem;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n \n public abstract class AbstractTransactionHandlerTest {\n     protected static final Long DEFAULT_ENTITY_NUM = 100L;\n-\n+    @Mock\n+    protected EntityRepository entityRepository;\n+    protected TransactionBody transactionBody;", "originalCommit": "8686f1d495948844ff363344cad7fb9d4124a4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwNDI3MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407704270", "bodyText": "yeah, right now they are redundant. Removed.", "author": "apeksharma", "createdAt": "2020-04-13T20:33:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY0NDMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NTY4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407665680", "bodyText": "Should do tx.setEntity(entityRepository.save(entity)); as Hibernate can return a proxied object. Can move this logic into getEntity() so that it either retrieves or create and saves the entity.", "author": "steven-sheehy", "createdAt": "2020-04-13T19:20:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordItemParser.java", "diffHunk": "@@ -115,185 +110,33 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n             return;\n         }\n \n-        // TODO: updatesEntity() is true for all and only the transaction types which are in body.has*() if-else\n-        //   conditions below. This is temporary to keep scope of changes in single PR limited and will be fixed in\n-        //   followup PR quickly. All if-else conditions will be replaced by:\n-        //     transactionHandler.updateEntity(entity, recordItem).\n-        Entities entity = null; // Entity used when t_entities row must be updated.\n-        if (transactionHandler.updatesEntity()) {\n-            entity = getEntity(entityId);\n-        }\n-\n-        // Only when transaction is successful:\n-        // - Fields of 'entity' will be updated. Fields are not updated for failed transactions since 'entity' may be an\n-        //   instance from cache and reused in future.\n-        // - proxyAccountId/autoRenewAccountId: If present, the account's id will be looked up (from big cache)\n-        //   or created immediately.\n+        boolean isSuccessful = isSuccessful(txRecord);\n+        Transaction tx = buildTransaction(consensusNs, recordItem);\n+        transactionHandler.updateTransaction(tx, recordItem);\n \n-        // For all transactions:\n-        // - 'entity' (may have been updated or not) is always inserted into repo since\n+        // Irrespective of transaction failure/success, if entityId is not null, it will be inserted into repo since:\n         //   (1) it is guaranteed to be valid entity on network (validated to exist in pre-consensus checks)\n         //   (2) fk_cud_entity_id is foreign key in t_transactions\n-        boolean doUpdateEntity = isSuccessful(txRecord);\n-        long initialBalance = 0;\n-\n-        if (entity == null) {\n-            // Do nothing. This can be true if transaction is of type that doesn't update the entity. Or, if the\n-            // transaction doesn't contain non-zero entity id (i.e. with entityNum != 0).\n-        } else if (body.hasContractCreateInstance()) {\n-            if (txRecord.getReceipt().hasContractID()) { // implies SUCCESS\n-                ContractCreateTransactionBody txMessage = body.getContractCreateInstance();\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                // Can't clear memo on contracts. 0 length indicates no change\n-                if (txMessage.getMemo() != null && txMessage.getMemo().length() > 0) {\n-                    entity.setMemo(txMessage.getMemo());\n-                }\n-\n-                if (txMessage.hasAdminKey()) {\n-                    entity.setKey(txMessage.getAdminKey().toByteArray());\n-                }\n-            }\n-\n-            initialBalance = body.getContractCreateInstance().getInitialBalance();\n-        } else if (body.hasContractDeleteInstance()) {\n-            if (body.getContractDeleteInstance().hasContractID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasContractUpdateInstance()) {\n-            ContractUpdateTransactionBody txMessage = body.getContractUpdateInstance();\n-            if (doUpdateEntity) {\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasAdminKey()) {\n-                    entity.setKey(txMessage.getAdminKey().toByteArray());\n-                }\n-                // Can't clear memo on contracts. 0 length indicates no change\n-                if (txMessage.getMemo() != null && txMessage.getMemo().length() > 0) {\n-                    entity.setMemo(txMessage.getMemo());\n-                }\n-            }\n-        } else if (body.hasCryptoCreateAccount()) {\n-            if (txRecord.getReceipt().hasAccountID()) { // Implies SUCCESS\n-                CryptoCreateTransactionBody txMessage = body.getCryptoCreateAccount();\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasKey()) {\n-                    entity.setKey(txMessage.getKey().toByteArray());\n-                }\n-            }\n-\n-            initialBalance = body.getCryptoCreateAccount().getInitialBalance();\n-        } else if (body.hasCryptoDelete()) {\n-            if (body.getCryptoDelete().hasDeleteAccountID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasCryptoUpdateAccount()) {\n-            CryptoUpdateTransactionBody txMessage = body.getCryptoUpdateAccount();\n-            if (doUpdateEntity) {\n-                setProxyAccountID(txMessage.getProxyAccountID(), entity);\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-                if (txMessage.hasAutoRenewPeriod()) {\n-                    entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod().getSeconds());\n-                }\n-                if (txMessage.hasKey()) {\n-                    entity.setKey(txMessage.getKey().toByteArray());\n-                }\n-            }\n-        } else if (body.hasFileCreate()) {\n-            if (txRecord.getReceipt().hasFileID()) { // Implies SUCCESS\n-                FileCreateTransactionBody txMessage = body.getFileCreate();\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-\n-                if (txMessage.hasKeys()) {\n-                    entity.setKey(txMessage.getKeys().toByteArray());\n-                }\n-            }\n-        } else if (body.hasFileDelete()) {\n-            if (body.getFileDelete().hasFileID()) {\n-                if (doUpdateEntity) {\n-                    entity.setDeleted(true);\n-                }\n-            }\n-        } else if (body.hasFileUpdate()) {\n-            FileUpdateTransactionBody txMessage = body.getFileUpdate();\n-            if (doUpdateEntity) {\n-                if (txMessage.hasExpirationTime()) {\n-                    entity.setExpiryTimeNs(Utility.timestampInNanosMax(txMessage.getExpirationTime()));\n-                }\n-\n-                if (txMessage.hasKeys()) {\n-                    entity.setKey(txMessage.getKeys().toByteArray());\n-                }\n-            }\n-        } else if (body.hasSystemDelete()) {\n-            if (doUpdateEntity) {\n-                entity.setDeleted(true);\n-            }\n-        } else if (body.hasSystemUndelete()) {\n-            if (doUpdateEntity) {\n-                entity.setDeleted(false);\n-            }\n-        } else if (body.hasConsensusCreateTopic()) {\n-            consensusCreateTopicUpdateEntity(entity, body, txRecord);\n-        } else if (body.hasConsensusUpdateTopic()) {\n-            consensusUpdateTopicUpdateEntity(entity, body, txRecord);\n-        } else if (body.hasConsensusDeleteTopic()) {\n-            consensusDeleteTopicUpdateEntity(entity, body, txRecord);\n-        }\n-\n-        TransactionID transactionID = body.getTransactionID();\n-        long validDurationSeconds = body.hasTransactionValidDuration() ? body.getTransactionValidDuration()\n-                .getSeconds() : null;\n-        long validStartNs = Utility.timeStampInNanos(transactionID.getTransactionValidStart());\n-        AccountID payerAccountId = transactionID.getAccountID();\n-\n-        com.hedera.mirror.importer.domain.Transaction tx = new com.hedera.mirror.importer.domain.Transaction();\n-        tx.setChargedTxFee(txRecord.getTransactionFee());\n-        tx.setConsensusNs(consensusNs);\n-        tx.setInitialBalance(initialBalance);\n-        tx.setMemo(body.getMemo().getBytes());\n-        tx.setMaxFee(body.getTransactionFee());\n-        tx.setResult(txRecord.getReceipt().getStatusValue());\n-        tx.setType(transactionType);\n-        tx.setTransactionBytes(parserProperties.getPersist().isTransactionBytes() ?\n-                recordItem.getTransactionBytes() : null);\n-        tx.setTransactionHash(txRecord.getTransactionHash().toByteArray());\n-        tx.setValidDurationSeconds(validDurationSeconds);\n-        tx.setValidStartNs(validStartNs);\n-        if (entity != null) {\n+        //\n+        // Additionally, if transaction is successful:\n+        // - Fields of 'entity' will be updated.\n+        // - proxyAccountId/autoRenewAccountId: If present, the account's id are looked up (from big cache) or created\n+        //   immediately in TransactionHandler.updateEntity(..).\n+        if (transactionHandler.updatesEntity() && isSuccessful && entityId != null) {\n+            Entities entity = getEntity(entityId);\n+            transactionHandler.updateEntity(entity, recordItem);\n             tx.setEntity(entity);\n             entityRepository.save(entity);", "originalCommit": "617acd2c6adcc310c45ba6841827f8808b7e265d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcyMzQwNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/680#discussion_r407723406", "bodyText": "Done.", "author": "apeksharma", "createdAt": "2020-04-13T21:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzY2NTY4MA=="}], "type": "inlineReview"}, {"oid": "598d071e29b84f1a1f5a40e6889ef682330d344f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/598d071e29b84f1a1f5a40e6889ef682330d344f", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-13T21:09:08Z", "type": "commit"}, {"oid": "598d071e29b84f1a1f5a40e6889ef682330d344f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/598d071e29b84f1a1f5a40e6889ef682330d344f", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-13T21:09:08Z", "type": "forcePushed"}, {"oid": "39ebf2f316b2df6b3db5367dc90174e9cd2584bb", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/39ebf2f316b2df6b3db5367dc90174e9cd2584bb", "message": "fix @Cacheable\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-13T21:58:06Z", "type": "commit"}, {"oid": "f4ded5344bbbb1645e518c01550aff315a5a4518", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f4ded5344bbbb1645e518c01550aff315a5a4518", "message": "minor fix\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-13T22:09:28Z", "type": "commit"}]}