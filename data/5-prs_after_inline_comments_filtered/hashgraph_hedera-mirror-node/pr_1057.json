{"pr_number": 1057, "pr_title": "gRPC notify thread blocked improvement", "pr_createdAt": "2020-09-17T15:28:32Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/1057", "timeline": [{"oid": "a0f0e3d721270da45965afdc0c9fcc7676168ff0", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/a0f0e3d721270da45965afdc0c9fcc7676168ff0", "message": "rework grpc notify thread blocked issue, increase maxBufferSize and add timeout mechanism\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-16T15:30:36Z", "type": "commit"}, {"oid": "e0116da8034956a5ac3a97e1c87b196df4e5b4d3", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e0116da8034956a5ac3a97e1c87b196df4e5b4d3", "message": "add ClientTimeoutException, change max of maxBufferSize\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-17T15:12:06Z", "type": "commit"}, {"oid": "d74c87a70a08953c86b7bfeb61eafa0e8c05c87d", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d74c87a70a08953c86b7bfeb61eafa0e8c05c87d", "message": "fix test case\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-17T15:28:05Z", "type": "commit"}, {"oid": "63690388148350ccbd355a8e0380bc64b341355f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/63690388148350ccbd355a8e0380bc64b341355f", "message": "remove accidentally checked-in file\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-17T15:41:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxODYyMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1057#discussion_r490618621", "bodyText": "q: was AtomicLong having adverse effects? Why the change? I thought it was safer given the shared nature of this flow", "author": "Nana-EC", "createdAt": "2020-09-17T23:35:51Z", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedPollingTopicListener.java", "diffHunk": "@@ -94,38 +83,38 @@ public SharedPollingTopicListener(ListenerProperties listenerProperties,\n         return Flux.fromIterable(topicMessageRepository.findLatest(context.getLastConsensusTimestamp(), pageable))\n                 .name(\"findLatest\")\n                 .metrics()\n+                .doOnNext(context::onNext)\n                 .doOnCancel(context::onPollEnd)\n                 .doOnComplete(context::onPollEnd)\n                 .doOnSubscribe(context::onPollStart);\n     }\n \n-    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {\n-        return message.getRealmNum() == filter.getRealmNum() &&\n-                message.getTopicNum() == filter.getTopicNum() &&\n-                message.getConsensusTimestamp() >= filter.getStartTimeLong();\n+    @Override\n+    protected Logger getLogger() {\n+        return log;\n     }\n \n     @Data\n     private class PollingContext {\n \n-        private final AtomicLong count = new AtomicLong(0L);\n+        private long count = 0;", "originalCommit": "63690388148350ccbd355a8e0380bc64b341355f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY2MTAwMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1057#discussion_r490661000", "bodyText": "PollingContext::onNext was after repeatWhen\nit's possible that the messages returned by one poll are still in the queue for subscribers to consume (share() internally has a small queue of size by default 256, i.e., share requests 256 messages and buffer them no matter how big the request of the downstream subscribers is)\nthis leads to the situation that onNext is increasing the atmoic counter for the current poll batch and at the same time repeat kicks in to subscribe, which triggers onPollStart and resets count to 0\nthus count becomes inaccurate\n\nthis is why PollingContext::onNext is moved. My thought is onNext and onPollStart now will not run concurrently, so atomic is not needed.", "author": "xin-hedera", "createdAt": "2020-09-18T02:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxODYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY5NDMwOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1057#discussion_r490694309", "bodyText": "Gotcha", "author": "Nana-EC", "createdAt": "2020-09-18T04:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxODYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyMjM3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1057#discussion_r490622373", "bodyText": "Instead you could just add protected final Logger log = LogManager.getLogger(getClass()); to the class.\nThen all the classes extending wouldn't have to implement the getLogger()", "author": "Nana-EC", "createdAt": "2020-09-17T23:48:35Z", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.time.Duration;\n+import org.apache.logging.log4j.Logger;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.UnicastProcessor;\n+\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+import com.hedera.mirror.grpc.exception.ClientTimeoutException;\n+\n+public abstract class SharedTopicListener implements TopicListener {\n+\n+    protected final ListenerProperties listenerProperties;\n+    protected Flux<TopicMessage> sharedTopicMessages;\n+\n+    public SharedTopicListener(ListenerProperties listenerProperties) {\n+        this.listenerProperties = listenerProperties;\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        Duration delay = Duration.ofMillis(listenerProperties.getBufferTimeout());\n+        UnicastProcessor<String> processor = UnicastProcessor.create();\n+        Flux<String> timeoutFlux = processor.delayElements(delay)\n+                .publish()\n+                .autoConnect();\n+\n+        return sharedTopicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> getLogger().info(\"Subscribing: {}\", filter))\n+                .doOnCancel(() -> processor.onNext(\"timeout\"))\n+                .onBackpressureBuffer(listenerProperties.getMaxBufferSize())\n+                .timeout(timeoutFlux, message -> timeoutFlux,\n+                        Mono.error(new ClientTimeoutException(\"Client times out to receive the buffered messages\")));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {\n+        return message.getRealmNum() == filter.getRealmNum() &&\n+                message.getTopicNum() == filter.getTopicNum() &&\n+                message.getConsensusTimestamp() >= filter.getStartTimeLong();\n+    }\n+\n+    protected abstract Logger getLogger();", "originalCommit": "63690388148350ccbd355a8e0380bc64b341355f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4MzgxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1057#discussion_r490983814", "bodyText": "thanks, made the recommended change", "author": "xin-hedera", "createdAt": "2020-09-18T14:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyMjM3Mw=="}], "type": "inlineReview"}, {"oid": "2b9736241819384b0cc8dbd64eb698d24f94bd78", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/2b9736241819384b0cc8dbd64eb698d24f94bd78", "message": "move log instantiation to abstract base class\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-18T14:15:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1Njg4Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1057#discussion_r491156887", "bodyText": "As I understand it, this code will trigger a cancellation after backpressure causes the buffer to fill up. That cancellation will trigger the timeoutFlux to publish after the buffer timeout. If no onNext occurs before the timeout, an exception is thrown.\nMy concern here is I don't see how this can recover from the cancellation? There's no repeat or retry logic here. Please add a test for this scenario.", "author": "steven-sheehy", "createdAt": "2020-09-18T19:45:51Z", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.time.Duration;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.UnicastProcessor;\n+\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+import com.hedera.mirror.grpc.exception.ClientTimeoutException;\n+\n+public abstract class SharedTopicListener implements TopicListener {\n+\n+    protected final Logger log = LogManager.getLogger(getClass());\n+    protected final ListenerProperties listenerProperties;\n+    protected Flux<TopicMessage> sharedTopicMessages;\n+\n+    public SharedTopicListener(ListenerProperties listenerProperties) {\n+        this.listenerProperties = listenerProperties;\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        Duration delay = Duration.ofMillis(listenerProperties.getBufferTimeout());\n+        UnicastProcessor<String> processor = UnicastProcessor.create();\n+        Flux<String> timeoutFlux = processor.delayElements(delay)\n+                .publish()\n+                .autoConnect();\n+\n+        return sharedTopicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter))\n+                .doOnCancel(() -> processor.onNext(\"timeout\"))", "originalCommit": "2b9736241819384b0cc8dbd64eb698d24f94bd78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7d52e6654a4a19dbec7c300ded5dbe9c5fd2a1b3", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7d52e6654a4a19dbec7c300ded5dbe9c5fd2a1b3", "message": "change to replay the timeout message to mitigate potential race condition that \"timeout\" is received but doesn't trigger Flux.timeout() internal mechanism\n\nSigned-off-by: Xin Li <xin.li@swirlds.com>", "committedDate": "2020-09-19T15:46:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4MDUxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1057#discussion_r492280519", "bodyText": "changed from publish() to replay(1)\nthere is a race condition in Flux.timeout():\n\nEvery timeout subscription has an index which is the sequence of the actual subscription's onNext call when the timeout subscription is created\nwhen onNext of the timeout subscription is called, it delegates to TimeoutMainSubscriber to handle the timeout only if the saved index equals to the index in TimeoutMainSubscriber\n\nIt's possible that the onNext of timeout subscription and the actual subscription happen around the same time in different threads, and the actual's onNext triggers index increment so timeout won't happened.\nBecause with publish(), the \"timeout\" message is one-shot and once it's consumed, there will be no more timeout triggered. Changing it to replay(1) will make the \"timeout\" message replayed to every subscriber of timeoutFlux thus timeout will happen even with the race condition", "author": "xin-hedera", "createdAt": "2020-09-21T19:00:37Z", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/SharedTopicListener.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import java.time.Duration;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.UnicastProcessor;\n+\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+import com.hedera.mirror.grpc.exception.ClientTimeoutException;\n+\n+public abstract class SharedTopicListener implements TopicListener {\n+\n+    protected final Logger log = LogManager.getLogger(getClass());\n+    protected final ListenerProperties listenerProperties;\n+    protected Flux<TopicMessage> sharedTopicMessages;\n+\n+    public SharedTopicListener(ListenerProperties listenerProperties) {\n+        this.listenerProperties = listenerProperties;\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        Duration delay = Duration.ofMillis(listenerProperties.getBufferTimeout());\n+        UnicastProcessor<String> processor = UnicastProcessor.create();\n+        Flux<String> timeoutFlux = processor.delayElements(delay)\n+                .replay(1)", "originalCommit": "7d52e6654a4a19dbec7c300ded5dbe9c5fd2a1b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}