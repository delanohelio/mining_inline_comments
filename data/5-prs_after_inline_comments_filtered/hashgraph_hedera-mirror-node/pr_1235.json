{"pr_number": 1235, "pr_title": "Add version migrations to fix entity type mismatches in db", "pr_createdAt": "2020-11-06T21:44:12Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235", "timeline": [{"oid": "3159528dcbfc9d4a3b175de51b30401257205662", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3159528dcbfc9d4a3b175de51b30401257205662", "message": "Cleaned up\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-09T19:08:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNjQ1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520836458", "bodyText": "Nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void verifyEntityTypeMigrationInValidEntities() throws Exception {\n          \n          \n            \n                void verifyEntityTypeMigrationInvalidEntities() throws Exception {", "author": "ijungmann", "createdAt": "2020-11-10T19:56:19Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")\n+public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n+    @Resource\n+    private V1_31_1__Entity_Type_Mismatch migration;\n+\n+    @Resource\n+    private DataSource dataSource;\n+\n+    @Resource\n+    private EntityRepository entityRepository;\n+\n+    @Resource\n+    private MirrorProperties mirrorProperties;\n+\n+    @Resource\n+    private TransactionRepository transactionRepository;\n+\n+    @Resource\n+    private FlywayMigrationProperties flywayMigrationProperties;\n+\n+    @BeforeEach\n+    void before() {\n+        mirrorProperties.setStartDate(Instant.EPOCH);\n+        mirrorProperties.setEndDate(Instant.EPOCH.plusSeconds(1));\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationEmpty() throws Exception {\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(0, entityRepository.count());\n+        assertEquals(0, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        entityRepository.insertEntityId(entityId(1, EntityTypeEnum.ACCOUNT));\n+        entityRepository.insertEntityId(entityId(2, EntityTypeEnum.CONTRACT));\n+        entityRepository.insertEntityId(entityId(3, EntityTypeEnum.FILE));\n+        entityRepository.insertEntityId(entityId(4, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(5, EntityTypeEnum.TOKEN));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(5, entityRepository.count());\n+        assertEquals(5, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntities() throws Exception {", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NTY3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521475675", "bodyText": "Renamed", "author": "Nana-EC", "createdAt": "2020-11-11T16:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNjQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzODcwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520838705", "bodyText": "Nit: I'm wondering if the variable name could be enhanced a little, I had to read the SQL to really understand the sentiment but I'm failing to come up with something better.", "author": "ijungmann", "createdAt": "2020-11-10T20:00:13Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NTgwMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521475800", "bodyText": "Took another hack at it", "author": "Nana-EC", "createdAt": "2020-11-11T16:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzODcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwMzg4Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521503887", "bodyText": "Much better, thanks", "author": "ijungmann", "createdAt": "2020-11-11T17:02:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzODcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0MzMyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520843323", "bodyText": "Nit: not sure how you feel about ternary operators, but this method could be replaced with one I believe.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return expectedEntityType.getId();\n          \n          \n            \n                    return expectedEntityType.getId() == currentEntityType ? 0 :  expectedEntityType.getId();", "author": "ijungmann", "createdAt": "2020-11-10T20:08:25Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NDQxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520874419", "bodyText": "I like ternary operators and prefer your suggestion. Thanks", "author": "Nana-EC", "createdAt": "2020-11-10T21:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0MzMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NTM2Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520845366", "bodyText": "I understand incrementing the entity id cap by 1, I'm not sure I understand incrementing the timestamp cap though, if the cap is already set to the current time.", "author": "ijungmann", "createdAt": "2020-11-10T20:12:01Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3MzkwNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520873904", "bodyText": "True, +1 on timestamp is not needed", "author": "Nana-EC", "createdAt": "2020-11-10T21:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NTM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NjgzNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520846835", "bodyText": "Nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void verifyEntityTypeMigrationInValidEntitiesMultiBatch() throws Exception {\n          \n          \n            \n                void verifyEntityTypeMigrationInvalidEntitiesMultiBatch() throws Exception {", "author": "ijungmann", "createdAt": "2020-11-10T20:14:48Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")\n+public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n+    @Resource\n+    private V1_31_1__Entity_Type_Mismatch migration;\n+\n+    @Resource\n+    private DataSource dataSource;\n+\n+    @Resource\n+    private EntityRepository entityRepository;\n+\n+    @Resource\n+    private MirrorProperties mirrorProperties;\n+\n+    @Resource\n+    private TransactionRepository transactionRepository;\n+\n+    @Resource\n+    private FlywayMigrationProperties flywayMigrationProperties;\n+\n+    @BeforeEach\n+    void before() {\n+        mirrorProperties.setStartDate(Instant.EPOCH);\n+        mirrorProperties.setEndDate(Instant.EPOCH.plusSeconds(1));\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationEmpty() throws Exception {\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(0, entityRepository.count());\n+        assertEquals(0, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        entityRepository.insertEntityId(entityId(1, EntityTypeEnum.ACCOUNT));\n+        entityRepository.insertEntityId(entityId(2, EntityTypeEnum.CONTRACT));\n+        entityRepository.insertEntityId(entityId(3, EntityTypeEnum.FILE));\n+        entityRepository.insertEntityId(entityId(4, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(5, EntityTypeEnum.TOKEN));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(5, entityRepository.count());\n+        assertEquals(5, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        EntityId typeMismatchedAccountEntityId = entityId(1, EntityTypeEnum.TOPIC);\n+        EntityId typeMismatchedContractEntityId = entityId(2, EntityTypeEnum.TOKEN);\n+        EntityId typeMismatchedFileEntityId = entityId(3, EntityTypeEnum.CONTRACT);\n+        EntityId typeMismatchedTopicEntityId = entityId(4, EntityTypeEnum.ACCOUNT);\n+        EntityId typeMismatchedTokenEntityId = entityId(5, EntityTypeEnum.FILE);\n+        entityRepository.insertEntityId(typeMismatchedAccountEntityId);\n+        entityRepository.insertEntityId(typeMismatchedContractEntityId);\n+        entityRepository.insertEntityId(typeMismatchedFileEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTopicEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTokenEntityId);\n+        entityRepository.insertEntityId(entityId(50, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(100, EntityTypeEnum.TOPIC));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionList\n+                .add(transaction(70, 50, EntityTypeEnum.TOPIC, ResponseCodeEnum.INVALID_TOPIC_ID,\n+                        TransactionTypeEnum.CONSENSUSSUBMITMESSAGE));\n+        transactionList\n+                .add(transaction(80, 100, EntityTypeEnum.TOPIC, ResponseCodeEnum.TOPIC_EXPIRED,\n+                        TransactionTypeEnum.CONSENSUSSUBMITMESSAGE));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(7, entityRepository.count());\n+        assertEquals(7, transactionRepository.count());\n+\n+        assertAll(\n+                () -> assertThat(entityRepository.findById(typeMismatchedAccountEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.ACCOUNT.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedContractEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.CONTRACT.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedFileEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.FILE.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedTopicEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.TOPIC.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedTokenEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.TOKEN.getId())\n+        );\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntitiesMultiBatch() throws Exception {", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NTk2Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521475967", "bodyText": "Renamed", "author": "Nana-EC", "createdAt": "2020-11-11T16:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NjgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0OTA2Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520849063", "bodyText": "I'm a little confused on not checking these last two in any of the invalid tests.  I'm sure it's a use case I'm just not understanding.", "author": "ijungmann", "createdAt": "2020-11-10T20:19:09Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")\n+public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n+    @Resource\n+    private V1_31_1__Entity_Type_Mismatch migration;\n+\n+    @Resource\n+    private DataSource dataSource;\n+\n+    @Resource\n+    private EntityRepository entityRepository;\n+\n+    @Resource\n+    private MirrorProperties mirrorProperties;\n+\n+    @Resource\n+    private TransactionRepository transactionRepository;\n+\n+    @Resource\n+    private FlywayMigrationProperties flywayMigrationProperties;\n+\n+    @BeforeEach\n+    void before() {\n+        mirrorProperties.setStartDate(Instant.EPOCH);\n+        mirrorProperties.setEndDate(Instant.EPOCH.plusSeconds(1));\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationEmpty() throws Exception {\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(0, entityRepository.count());\n+        assertEquals(0, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        entityRepository.insertEntityId(entityId(1, EntityTypeEnum.ACCOUNT));\n+        entityRepository.insertEntityId(entityId(2, EntityTypeEnum.CONTRACT));\n+        entityRepository.insertEntityId(entityId(3, EntityTypeEnum.FILE));\n+        entityRepository.insertEntityId(entityId(4, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(5, EntityTypeEnum.TOKEN));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(5, entityRepository.count());\n+        assertEquals(5, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        EntityId typeMismatchedAccountEntityId = entityId(1, EntityTypeEnum.TOPIC);\n+        EntityId typeMismatchedContractEntityId = entityId(2, EntityTypeEnum.TOKEN);\n+        EntityId typeMismatchedFileEntityId = entityId(3, EntityTypeEnum.CONTRACT);\n+        EntityId typeMismatchedTopicEntityId = entityId(4, EntityTypeEnum.ACCOUNT);\n+        EntityId typeMismatchedTokenEntityId = entityId(5, EntityTypeEnum.FILE);\n+        entityRepository.insertEntityId(typeMismatchedAccountEntityId);\n+        entityRepository.insertEntityId(typeMismatchedContractEntityId);\n+        entityRepository.insertEntityId(typeMismatchedFileEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTopicEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTokenEntityId);\n+        entityRepository.insertEntityId(entityId(50, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(100, EntityTypeEnum.TOPIC));", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3Njg4MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520876881", "bodyText": "Left over, will remove.\nOriginally, these two are added to make it so the max entities in the table isn't actually a valid entity.\nI can actually take it out because by this migration any entities above the max valid entityId would have been delete in v1_31_1\nAlso originally I was going to do the delete after this migration.\nWill remove thanks", "author": "Nana-EC", "createdAt": "2020-11-10T21:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0OTA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUyMjA5MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521522091", "bodyText": "Cool, makes sense, thanks for the details.", "author": "ijungmann", "createdAt": "2020-11-11T17:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0OTA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MjA4Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520282086", "bodyText": "Is this used somewhere?", "author": "steven-sheehy", "createdAt": "2020-11-10T04:41:04Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java", "diffHunk": "@@ -34,4 +34,14 @@\n     TOKEN(5);\n \n     private final int id;\n+\n+    public static EntityTypeEnum fromId(int id) {", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwODU3Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520908576", "bodyText": "Initially it was, seems in my refactors I no longer needed it. Will remove", "author": "Nana-EC", "createdAt": "2020-11-10T22:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MjA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzE1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520283153", "bodyText": "Why not continue chaining and avoid the temporary entitiesIterableAssert variable?", "author": "steven-sheehy", "createdAt": "2020-11-10T04:45:16Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java", "diffHunk": "@@ -365,11 +366,13 @@ protected void assertEntities(EntityId... entityIds) {\n             return;\n         }\n \n-        assertEquals(entityIds.length, entityRepository.count());\n+        IterableAssert<Entities> entitiesIterableAssert = assertThat(entityRepository.findAll())\n+                .hasSize(entityIds.length)\n+                .allMatch(entity -> entity.getId() > 0)\n+                .allMatch(entity -> entity.getEntityTypeId() != null);\n \n-        // verify entities\n-        for (EntityId entityId : entityIds) {\n-            assertThat(entityRepository.findById(entityId.getId())).isPresent();\n-        }\n+        entitiesIterableAssert", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NjY4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521476683", "bodyText": "Continued chaining. Intellisense error was misleading but since I didn't need the return chaining works fine.", "author": "Nana-EC", "createdAt": "2020-11-11T16:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5ODk1NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520798955", "bodyText": "This doesn't work here. Nor should you have transactions within the larger flyway transaction as it would leave the database in an inconsistent state.", "author": "steven-sheehy", "createdAt": "2020-11-10T18:55:54Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NjM3OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520956379", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-11-11T00:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5ODk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNDc1OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520834759", "bodyText": "You should move non join statements to a where clause for clarity. They produce the same query plan for inner joins either way.", "author": "steven-sheehy", "createdAt": "2020-11-10T19:53:11Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NzE2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521477160", "bodyText": "Moved out into where.\nAlso created a separate where string for easier reading.", "author": "Nana-EC", "createdAt": "2020-11-11T16:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNDc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNzE2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520837164", "bodyText": "Just inject a JdbcOperations instead of the DataSource.", "author": "steven-sheehy", "createdAt": "2020-11-10T19:57:34Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NzM2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521477364", "bodyText": "Injected JdbcOperations", "author": "Nana-EC", "createdAt": "2020-11-11T16:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNzE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NDA1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520864053", "bodyText": "Both these repositories are unused and should be removed.", "author": "steven-sheehy", "createdAt": "2020-11-10T20:47:48Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMDEwMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520910100", "bodyText": "Left over, removed", "author": "Nana-EC", "createdAt": "2020-11-10T22:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NDA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NDc0NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520864745", "bodyText": "Don't think we need to denote Nullable on non-API/internal methods", "author": "steven-sheehy", "createdAt": "2020-11-10T20:49:09Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NzUyNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521477524", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-11-11T16:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NDc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2ODExNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520868115", "bodyText": "What's the point of backing up if we're going to drop it at the end? If something goes wrong the transaction will rollback.", "author": "steven-sheehy", "createdAt": "2020-11-10T20:55:37Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1Njg3MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520956871", "bodyText": "Will removed, had toyed with the idea of leaving temp table around for a while, then deciding on dropping.\nGiven migration logic and verification I can remove temp table need.", "author": "Nana-EC", "createdAt": "2020-11-11T00:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2ODExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NTk1Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520875957", "bodyText": "Don't need to hardcode to seconds, can just log.info(\"{}\", stopwatch) and it will automatically use the biggest duration unit.", "author": "steven-sheehy", "createdAt": "2020-11-10T21:10:58Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NzgyOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521477828", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-11-11T16:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NzI0NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520877244", "bodyText": "Each of these is a full table scan since it doesn't use indexes. You can just do a single query with a group by. You can then use having to remove rows equal to zero and have a single throw statement.", "author": "steven-sheehy", "createdAt": "2020-11-10T21:13:26Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n+        return entityIdType;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3ODc1NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521478754", "bodyText": "Adopted single query. With group by letting me log  clearly each entity type that has mismatches whiles till having a single throw for if it's at all above 0", "author": "Nana-EC", "createdAt": "2020-11-11T16:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NzI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3OTQ2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520879469", "bodyText": "Why do we need to confirm no entity mismatch unless the database migration has a bug? If it there is a bug in the migration do we really want to block/fail the deployment? We haven't done this in any previous migration", "author": "steven-sheehy", "createdAt": "2020-11-10T21:18:03Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n+        return entityIdType;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNjI5Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520926297", "bodyText": "In migrations where info is deleted/updated I think if there's a way to verify the final state is as expected we should utilize it.\nIf it's not we certainly should fail and prioritize accuracy, no?", "author": "Nana-EC", "createdAt": "2020-11-10T22:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3OTQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwNjYyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520906623", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    ps.setLong(1, entityIdType.correctedEntityTypeId);\n          \n          \n            \n                                    ps.setInt(1, entityIdType.correctedEntityTypeId);", "author": "xin-hedera", "createdAt": "2020-11-10T22:11:39Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3ODkwNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521478904", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-11-11T16:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwNjYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwNzM2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520907360", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private final long correctedEntityTypeId;\n          \n          \n            \n                    private final long entityId;\n          \n          \n            \n                    private final long initialEntityTypeId;\n          \n          \n            \n                    private final long transactionType;\n          \n          \n            \n                    private final int correctedEntityTypeId;\n          \n          \n            \n                    private final long entityId;\n          \n          \n            \n                    private final int initialEntityTypeId;\n          \n          \n            \n                    private final int transactionType;", "author": "xin-hedera", "createdAt": "2020-11-10T22:13:02Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n+        return entityIdType;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n+                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n+        if (accountMismatchCount > 0) {\n+            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n+        }\n+\n+        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n+                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n+        if (contractMismatchCount > 0) {\n+            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n+        }\n+\n+        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n+                .getProtoId(), EntityTypeEnum.FILE.getId());\n+        if (fileMismatchCount > 0) {\n+            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n+        }\n+\n+        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n+                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n+        if (topicMismatchCount > 0) {\n+            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n+        }\n+\n+        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n+                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n+        if (tokenMismatchCount > 0) {\n+            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n+        }\n+    }\n+\n+    @Data\n+    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n+    private class EntityIdType {\n+        private final long consensusTimestamp;\n+        private final long correctedEntityTypeId;\n+        private final long entityId;\n+        private final long initialEntityTypeId;\n+        private final long transactionType;", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3Mjc3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520972773", "bodyText": "Updating, only the entityId and timestamp need to be of type long", "author": "Nana-EC", "createdAt": "2020-11-11T00:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwNzM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDEzNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520914134", "bodyText": "nit: order by consensus_ns desc is redundant since there won't be duplicate entity IDs in those successful create transactions", "author": "xin-hedera", "createdAt": "2020-11-10T22:27:13Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNTUxMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521015512", "bodyText": "the order by is to ensure that the search is done in desc order to support the batching of search", "author": "Nana-EC", "createdAt": "2020-11-11T01:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQyMDEzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521420138", "bodyText": "I got that part, I meant only order by id desc is needed for the reason I provided in the initial comment.", "author": "xin-hedera", "createdAt": "2020-11-11T15:03:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MDU3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521480575", "bodyText": "Sure, I guess that inherently works because entity id are created in asc id value over time.", "author": "Nana-EC", "createdAt": "2020-11-11T16:29:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUxMjU3MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521512571", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-11-11T17:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMTYyNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520921625", "bodyText": "these are already updated in getTypeMismatchedEntity and it's also possible updating them here would cause some rows to be reprocessed.", "author": "xin-hedera", "createdAt": "2020-11-10T22:44:06Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MTM0Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521481346", "bodyText": "Left over, single update occurs in getTypeMismatchedEntity() now", "author": "Nana-EC", "createdAt": "2020-11-11T16:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMTYyNQ=="}], "type": "inlineReview"}, {"oid": "268b341265e3640631a626897a9ac82ccd2adbb6", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/268b341265e3640631a626897a9ac82ccd2adbb6", "message": "Addressed feedback 2\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-11T06:09:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzODU1NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521538554", "bodyText": "I'm generally hesitant to use default values, like I'm assuming the boolean continueSearch is being defaulted to false without it being stated anywhere.  That could just be a personal preference though.", "author": "ijungmann", "createdAt": "2020-11-11T17:56:11Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n+            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n+            \"limit ?\";\n+    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    private AtomicLong entityIdCap;\n+    private AtomicLong timestampCap;\n+    private AtomicLong entityTransactionCount;\n+    private AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        if (getMismatchCount() == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n+        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n+        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n+        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n+                .get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchSearchResult.isContinueSearch()) {\n+            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n+                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n+            }\n+\n+            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n+                    .get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the count of entity type mismatches found across all entities\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n+     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return new TypeMismatchSearchResult();", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4ODc1Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521588757", "bodyText": "Happy to remove the @noargs on the class and be explicit here w the following\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return new TypeMismatchSearchResult();\n          \n          \n            \n                        return new TypeMismatchSearchResult(null, false);", "author": "Nana-EC", "createdAt": "2020-11-11T19:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzODU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5NDM3MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521594371", "bodyText": "I'd prefer that.", "author": "ijungmann", "createdAt": "2020-11-11T19:39:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzODU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg0OTk0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521849941", "bodyText": "Made the change but then blew this whole class away in the end.", "author": "Nana-EC", "createdAt": "2020-11-12T05:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzODU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU0MjQ4OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521542489", "bodyText": "Is there a reason to do the granular type mismatch checks ((t.type = 8 and e.fk_entity_type_id <> 2), etc) in the count SQL but not here?", "author": "ijungmann", "createdAt": "2020-11-11T18:02:35Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n+            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU3ODQ1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521578458", "bodyText": "Yeah, had wanted to share that logic, but if you do that and combine with paging logic on the search the result is that you don't know when you've hit the end.\nIt's difficult to reliably differentiate between not finding a a mismatch in the last batch search vs there's no more rows left to actually search.\nI didn't want to get down to relying on static id or time stamp numbers to determine this as it could be wrong.\nSo decided to leave it as is.\nUpside is we're ensured to consider every single entity that was said to have been created.", "author": "Nana-EC", "createdAt": "2020-11-11T19:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU0MjQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5NDA1NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521594055", "bodyText": "That makes sense, I'm okay with it then", "author": "ijungmann", "createdAt": "2020-11-11T19:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU0MjQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NDE2Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521564163", "bodyText": "private", "author": "steven-sheehy", "createdAt": "2020-11-11T18:42:18Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n+            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n+            \"limit ?\";\n+    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    private AtomicLong entityIdCap;\n+    private AtomicLong timestampCap;\n+    private AtomicLong entityTransactionCount;\n+    private AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        if (getMismatchCount() == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n+        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n+        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n+        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n+                .get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchSearchResult.isContinueSearch()) {\n+            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n+                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n+            }\n+\n+            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n+                    .get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the count of entity type mismatches found across all entities\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n+     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return new TypeMismatchSearchResult();\n+        }\n+\n+        // remove nulls\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+\n+        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param typeMismatchedEntities List of mismatched entities\n+     * @return\n+     */\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1MDE2NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521850165", "bodyText": "N/A, class removed.", "author": "Nana-EC", "createdAt": "2020-11-12T05:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NDE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2ODE3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521568175", "bodyText": "You'll need a custom cleanup.sql that's a copy of current sql so this doesn't break in the future.", "author": "steven-sheehy", "createdAt": "2020-11-11T18:49:51Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,298 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.1\")", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1MDQzMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521850433", "bodyText": "Is this still applicable. Should be okay now with the modification to\n@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")", "author": "Nana-EC", "createdAt": "2020-11-12T05:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2ODE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwOTc1Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521609757", "bodyText": "Why are we limiting to these certain types here and in the search SQL? It should be all transaction types that are associated with one of the entity types. For example, a CONSENSUSUPDATETOPIC can certainly return an INVALID_TOPIC_ID.", "author": "steven-sheehy", "createdAt": "2020-11-11T20:09:18Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzNTA2OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521635068", "bodyText": "True, but the additional transactions types aren't necessary to determine if an entity type is mismatched.\nEvery entity noted by a successful transaction create type should have a mapping in the t_entities table.\nThat's all you need to determine and correct the t_entities table.\nUpdated and deletes etc will all follow a create transaction, so it's sufficient to look at that.", "author": "Nana-EC", "createdAt": "2020-11-11T20:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwOTc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY0NjgzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521646836", "bodyText": "Post offline discussion the tricky part here is the backfill problem. With missing historic data we can't rely on only create transactions as they may not be present.\nI see the need for all transactions, which can make the list exhaustive and sql long but will look into that", "author": "Nana-EC", "createdAt": "2020-11-11T21:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwOTc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1MDg2MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521850861", "bodyText": "Went for an exclusive set. in CTE update I ignore system, unknown and freeze transaction - basically those that don't relate to an entity.\nThis way future entities added can be picked up.\nAlso update the transaction_types table with the corresponding entity_type", "author": "Nana-EC", "createdAt": "2020-11-12T05:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwOTc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxMTIxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521611214", "bodyText": "If we later add new transaction types but someone runs this migration after that point, it would miss those types. Perhaps we should auto-generate this SQL from the enums? Also, it would be less brittle and hard to understand.\nThat is, add an optional EntityTypeEnum field to TransactionTypeEnum that groups transactions types per which entity they are associated with. Then generate the SQL using that info.", "author": "steven-sheehy", "createdAt": "2020-11-11T20:12:10Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY0NzU4Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521647586", "bodyText": "Good point. Such a mapping is useful.\nEspecially given the exhaustive transactions type discussed.\nWill look into this.", "author": "Nana-EC", "createdAt": "2020-11-11T21:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxMTIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1MDk0OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521850949", "bodyText": "Mapping now in db as noted", "author": "Nana-EC", "createdAt": "2020-11-12T05:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxMTIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxNDQ3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521614478", "bodyText": "We should use a DB cursor instead of using this complicated keyset pagination approach with stateful Atomics. The updating can be batched but the querying should not be.\nBesides being harder to understand and making the class stateful, this query will be slower since it's joining an un-indexed field. Keyset pagination only makes sense when using index fields. I ran this query in mainnet and a single page took a few minutes.\nThis would also allow you to reuse the sql that compares the entity type with the transaction type. It would also make the verification query completely unnecessary as it's the same SQL.", "author": "steven-sheehy", "createdAt": "2020-11-11T20:18:47Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY0NzcxMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521647710", "bodyText": "Agreed, will look into this.", "author": "Nana-EC", "createdAt": "2020-11-11T21:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxNDQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1MTExMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521851110", "bodyText": "Cursor was a good idea.\nWith CTE update no longer needed as this class is gone", "author": "Nana-EC", "createdAt": "2020-11-12T05:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxNDQ3OA=="}], "type": "inlineReview"}, {"oid": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9cd402f6d7192e23001ae1682fce95a6173eb0d5", "message": "Add version migrations to fix entity type mismatches in db\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "88f9d4a81c84f67f52a94920adca590bcb2ecb32", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/88f9d4a81c84f67f52a94920adca590bcb2ecb32", "message": "Cleaned up\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "f7ca3eadb88f6c7187cd4d0450fe98d3e75ab2d9", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f7ca3eadb88f6c7187cd4d0450fe98d3e75ab2d9", "message": "Renamed sql migration\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "e9c2cb723b1f5f8b275748fad84d9d9809162606", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e9c2cb723b1f5f8b275748fad84d9d9809162606", "message": "Addressed feedback 1\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "3d689050d99226ce8472b047bbe2d7456c88b25b", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3d689050d99226ce8472b047bbe2d7456c88b25b", "message": "Addressed feedback 2\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "8f8fd323edb4583b79f3f5907f01a353a806cb33", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8f8fd323edb4583b79f3f5907f01a353a806cb33", "message": "Cleaned up object rename leftover\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "7968b291b082964abae72b59aef354d392895d0b", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7968b291b082964abae72b59aef354d392895d0b", "message": "Fix code smells\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "message": "Substitued java magration for sql migration w cte. Added entity_type to t_transaction_types\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "message": "Updated migration number\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:30:06Z", "type": "commit"}, {"oid": "7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "message": "Updated migration number\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:30:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MTA3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r522371078", "bodyText": "This class name no longer matches the sql name", "author": "steven-sheehy", "createdAt": "2020-11-12T19:35:28Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.io.File;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.jdbc.core.JdbcOperations;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.1\")\n+class V_1_31_2__Entity_Type_MismatchTest extends IntegrationTest {", "originalCommit": "7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cb54c5cd7c18de9194a270cf03f86315c332e3b7", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cb54c5cd7c18de9194a270cf03f86315c332e3b7", "message": "Renamed test class to match sql\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T20:30:47Z", "type": "commit"}]}