{"pr_number": 757, "pr_title": "Change hash mismatch bypassing from state to config based", "pr_createdAt": "2020-05-14T19:04:36Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/757", "timeline": [{"oid": "c869cb373e79c34ddec13628d6a77db6e585a102", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c869cb373e79c34ddec13628d6a77db6e585a102", "message": "Change hash mismatch bypassing from state to config based\n\n- Share verifyHashChain() function between downloader and parser.\n\nDownloader was calling static public readPrevFileHash() in RecordFileParser to get hash.\nThat function wasn't used by RFP itself. Moved it first. Then realizing that\nUtility.getRecordFileHash() was already reading complete file once. It's best to extract\neverything from record file in single pass rather than multiple passes and duplicated\ncode fragments. So made following changes:\n- Renamed it to Utility.parseRecordFile()\n- It returns a parsed RecordFile object\n- Downloader and parser logic use the returned RecordFile rather than parsing the\n  file again\n- As a result, now there's only one place doing byte level parsing of record file\n  rather than 3 places earlier.\nThe function itself can be moved to a better place in future, leaving here for now\nfor easy reviewing and limit scope of refactoring.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-05-14T18:31:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM2ODI2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425368264", "bodyText": "chain verification logic was duplicated in two places  - here and in RecordFileParser.\nMoved it to Utility.verifyHashChain() to be shared.", "author": "apeksharma", "createdAt": "2020-05-14T19:07:00Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -386,32 +379,6 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n         }\n     }\n \n-    /**\n-     * Verifies that prevFileHash in given {@code file} matches that in application repository.\n-     *\n-     * @throws Exception\n-     */\n-    protected boolean verifyHashChain(File file) {", "originalCommit": "c869cb373e79c34ddec13628d6a77db6e585a102", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3MDA1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425370058", "bodyText": "This is the crux of parsing record file only once.\nRather than getPrevFileHash() and getDataFileHash() parsing file twice, this does everything in single parse.\nEven better, it's shared with RecordFileParser rather than having duplicate parsing logic.", "author": "apeksharma", "createdAt": "2020-05-14T19:10:21Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/record/RecordFileDownloader.java", "diffHunk": "@@ -62,18 +63,21 @@ protected ApplicationStatusCode getLastValidDownloadedFileHashKey() {\n         return ApplicationStatusCode.LAST_VALID_DOWNLOADED_RECORD_FILE_HASH;\n     }\n \n+    /**\n+     * Checks that hash of data file matches the verified hash. Then checks that data file is next in line based on\n+     * previous file hash.\n+     */\n     @Override\n-    protected ApplicationStatusCode getBypassHashKey() {\n-        return ApplicationStatusCode.RECORD_HASH_MISMATCH_BYPASS_UNTIL_AFTER;\n-    }\n-\n-    @Override\n-    protected String getPrevFileHash(String filePath) {\n-        return RecordFileParser.readPrevFileHash(filePath);\n-    }\n-\n-    @Override\n-    protected byte[] getDataFileHash(String fileName) {\n-        return Utility.getRecordFileHash(fileName);\n+    protected boolean verifyDataFile(String filePath, byte[] verifiedHash) {\n+        RecordFile recordFile =  Utility.parseRecordFile(filePath, false);", "originalCommit": "c869cb373e79c34ddec13628d6a77db6e585a102", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3MDM2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425370364", "bodyText": "This was being used in downloader only, and it's in RFP file :-/", "author": "apeksharma", "createdAt": "2020-05-14T19:10:54Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -98,101 +92,27 @@ public RecordFileParser(ApplicationStatusRepository applicationStatusRepository,\n                         \"processed the transaction\");\n     }\n \n-    /**\n-     * Given a service record name, read its prevFileHash\n-     *\n-     * @param fileName the name of record file to read\n-     * @return return previous file hash's Hex String\n-     */\n-    public static String readPrevFileHash(String fileName) {", "originalCommit": "c869cb373e79c34ddec13628d6a77db6e585a102", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3MTExOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425371118", "bodyText": "Removed this parsing logic which was almost same as in Utility.parseRecordFile()\nAlso RFP was reading file twice, once in this logic, second time in String thisFileHash = Hex.encodeHexString(Utility.getRecordFileHash(fileName)) below,", "author": "apeksharma", "createdAt": "2020-05-14T19:12:31Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -98,101 +92,27 @@ public RecordFileParser(ApplicationStatusRepository applicationStatusRepository,\n                         \"processed the transaction\");\n     }\n \n-    /**\n-     * Given a service record name, read its prevFileHash\n-     *\n-     * @param fileName the name of record file to read\n-     * @return return previous file hash's Hex String\n-     */\n-    public static String readPrevFileHash(String fileName) {\n-        File file = new File(fileName);\n-        if (file.exists() == false) {\n-            log.warn(\"File does not exist {}\", fileName);\n-            return null;\n-        }\n-        byte[] prevFileHash = new byte[48];\n-        try (DataInputStream dis = new DataInputStream(new FileInputStream(file))) {\n-            // record_format_version\n-            dis.readInt();\n-            // version\n-            dis.readInt();\n-\n-            byte typeDelimiter = dis.readByte();\n-\n-            if (typeDelimiter == FileDelimiter.RECORD_TYPE_PREV_HASH) {\n-                dis.read(prevFileHash);\n-                String hexString = Hex.encodeHexString(prevFileHash);\n-                log.trace(\"Read previous file hash {} for file {}\", hexString, fileName);\n-                return hexString;\n-            } else {\n-                log.error(\"Expecting previous file hash, but found file delimiter {} for file {}\", typeDelimiter,\n-                        fileName);\n-            }\n-        } catch (Exception e) {\n-            log.error(\"Error reading previous file hash {}\", fileName, e);\n-        }\n-\n-        return null;\n-    }\n-\n     /**\n      * Given a service record name, read and parse and return as a list of service record pair\n      *\n      * @param streamFileData containing information about file to be processed\n      */\n-    public void loadRecordFile(StreamFileData streamFileData) throws IOException {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        long loadStart = Instant.now().getEpochSecond();\n+    public void loadRecordFile(StreamFileData streamFileData) {\n+        Instant startTime = Instant.now();\n         recordStreamFileListener.onStart(streamFileData);\n-        String fileName = streamFileData.getFilename();\n-        String actualPrevFileHash = \"\";\n-        long counter = 0;\n-        Integer recordFileVersion = 0;\n-        Boolean success = false;\n-\n-        try (DataInputStream dis = new DataInputStream(streamFileData.getInputStream())) {", "originalCommit": "c869cb373e79c34ddec13628d6a77db6e585a102", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2OTg2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425469860", "bodyText": "q: Is there UT coverage for this? I'm not seeing it here", "author": "Nana-EC", "createdAt": "2020-05-14T22:39:41Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/util/Utility.java", "diffHunk": "@@ -450,10 +455,28 @@ String protobufKeyToHexIfEd25519OrNull(@Nullable byte[] protobufKey)\n      * Generates a TransactionID object\n      *\n      * @param payerAccountId the AccountID of the transaction payer account\n-     * @return\n      */\n     public static TransactionID getTransactionId(AccountID payerAccountId) {\n         Timestamp validStart = Utility.instantToTimestamp(Instant.now());\n         return TransactionID.newBuilder().setAccountID(payerAccountId).setTransactionValidStart(validStart).build();\n     }\n+\n+    public static boolean verifyHashChain(", "originalCommit": "c869cb373e79c34ddec13628d6a77db6e585a102", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyNTk1NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425525955", "bodyText": "added the tests.", "author": "apeksharma", "createdAt": "2020-05-15T02:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2OTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3MDcxMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425470712", "bodyText": "You should add a basic test coverage for this", "author": "Nana-EC", "createdAt": "2020-05-14T22:42:18Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/balance/AccountBalancesDownloader.java", "diffHunk": "@@ -53,8 +54,8 @@ public void download() {\n     }\n \n     @Override\n-    protected boolean verifyHashChain(File file) {\n-        return true;\n+    protected boolean verifyDataFile(String filePath, byte[] verifiedHash) {", "originalCommit": "c869cb373e79c34ddec13628d6a77db6e585a102", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyNTc4Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425525782", "bodyText": "not public function, so shouldn't be tested in unit tests.\nAlso, gets covered by other tests.", "author": "apeksharma", "createdAt": "2020-05-15T02:04:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3MDcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3MDkxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425470919", "bodyText": "Similar this should have a test for this method.", "author": "Nana-EC", "createdAt": "2020-05-14T22:42:58Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/record/RecordFileDownloader.java", "diffHunk": "@@ -62,18 +63,21 @@ protected ApplicationStatusCode getLastValidDownloadedFileHashKey() {\n         return ApplicationStatusCode.LAST_VALID_DOWNLOADED_RECORD_FILE_HASH;\n     }\n \n+    /**\n+     * Checks that hash of data file matches the verified hash. Then checks that data file is next in line based on\n+     * previous file hash.\n+     */\n     @Override\n-    protected ApplicationStatusCode getBypassHashKey() {\n-        return ApplicationStatusCode.RECORD_HASH_MISMATCH_BYPASS_UNTIL_AFTER;\n-    }\n-\n-    @Override\n-    protected String getPrevFileHash(String filePath) {\n-        return RecordFileParser.readPrevFileHash(filePath);\n-    }\n-\n-    @Override\n-    protected byte[] getDataFileHash(String fileName) {\n-        return Utility.getRecordFileHash(fileName);\n+    protected boolean verifyDataFile(String filePath, byte[] verifiedHash) {", "originalCommit": "c869cb373e79c34ddec13628d6a77db6e585a102", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyNTg1MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425525850", "bodyText": "same as above.", "author": "apeksharma", "createdAt": "2020-05-15T02:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ3MDkxOQ=="}], "type": "inlineReview"}, {"oid": "9a8275433cf7427bb13fc103387a4ad827b0ca11", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9a8275433cf7427bb13fc103387a4ad827b0ca11", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-05-15T02:06:49Z", "type": "forcePushed"}, {"oid": "827fce5f27c0599e5949216b0958760b1985718e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/827fce5f27c0599e5949216b0958760b1985718e", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-05-15T02:10:53Z", "type": "commit"}, {"oid": "827fce5f27c0599e5949216b0958760b1985718e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/827fce5f27c0599e5949216b0958760b1985718e", "message": "address review comments\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-05-15T02:10:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4NDEwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425384105", "bodyText": "Unused", "author": "steven-sheehy", "createdAt": "2020-05-14T19:37:52Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/downloader/record/RecordFileDownloaderTest.java", "diffHunk": "@@ -47,6 +47,8 @@\n \n @ExtendWith(MockitoExtension.class)\n public class RecordFileDownloaderTest extends AbstractDownloaderTest {\n+    private static final String FILE1_HASH =", "originalCommit": "c869cb373e79c34ddec13628d6a77db6e585a102", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI5NzgyMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r429297820", "bodyText": "I fixed in one of my PRs", "author": "steven-sheehy", "createdAt": "2020-05-22T14:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM4NDEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk0NTgyOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r425945828", "bodyText": "Would be better to move this default into the class itself to avoid NPE in more places.\nedit: did in my PR", "author": "steven-sheehy", "createdAt": "2020-05-15T17:27:52Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/util/Utility.java", "diffHunk": "@@ -125,80 +128,82 @@\n      * @param filename file name\n      * @return byte array of hash value of null if calculating has failed\n      */\n-    public static byte[] getRecordFileHash(String filename) {\n-        byte[] readFileHash = new byte[48];\n+    public static RecordFile parseRecordFile(String filename, boolean parseRecordItems) {\n+        RecordFile recordFile = new RecordFile();\n+        recordFile.setName(filename);\n+        recordFile.setRecordItems(new ArrayList<>());", "originalCommit": "c869cb373e79c34ddec13628d6a77db6e585a102", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2ODU3Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r426068572", "bodyText": "Do we need to update troubleshooting doc and ops with this change?", "author": "steven-sheehy", "createdAt": "2020-05-15T22:10:31Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -365,11 +359,10 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n                                         .updateStatusValue(getLastValidDownloadedFileKey(), destination.getName());\n                                 valid = true;\n                                 break;\n-                            }\n                         }\n-                    } else if (signedDataFile != null) {\n-                        log.warn(\"Hash doesn't match the hash contained in valid signature file. Will try to download\" +\n-                                \" a file with same timestamp from other nodes and check the Hash: {}\", signedDataFile);\n+                    } else {\n+                        log.warn(\"Verification of data file failed. Will try to download a file with same timestamp \" +", "originalCommit": "827fce5f27c0599e5949216b0958760b1985718e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1NTM4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r432255380", "bodyText": "Thanks for bringing to attention. Not needed for this, but updated troubleshooting doc with other messages.", "author": "apeksharma", "createdAt": "2020-05-29T04:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2ODU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3Mjk1MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r426072951", "bodyText": "nit: The testName actually make this harder to understand, but of course provides value at runtime. Perhaps a // @formatter:off/on might help here to make them each on a single line?", "author": "steven-sheehy", "createdAt": "2020-05-15T22:26:49Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/util/UtilityTest.java", "diffHunk": "@@ -214,4 +214,27 @@ void convertTimestampToNanosIllegalInput() {\n             Utility.timeStampInNanos(timestamp);\n         });\n     }\n+\n+    @ParameterizedTest(name = \"verifyHashChain {5}\")\n+    @CsvSource({\n+            \"'', '', '', 2000-01-01T10_00_00.000000.rcd, true, passes if both hashes are empty\",", "originalCommit": "827fce5f27c0599e5949216b0958760b1985718e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1MjczMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r432252730", "bodyText": "done.", "author": "apeksharma", "createdAt": "2020-05-29T04:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3Mjk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExNzI1Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r426117257", "bodyText": "Should pass in a File object so you don't need to re-load the file just to get its filename.", "author": "steven-sheehy", "createdAt": "2020-05-16T04:31:56Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/record/RecordFileDownloader.java", "diffHunk": "@@ -62,18 +63,21 @@ protected ApplicationStatusCode getLastValidDownloadedFileHashKey() {\n         return ApplicationStatusCode.LAST_VALID_DOWNLOADED_RECORD_FILE_HASH;\n     }\n \n+    /**\n+     * Checks that hash of data file matches the verified hash. Then checks that data file is next in line based on\n+     * previous file hash.\n+     */\n     @Override\n-    protected ApplicationStatusCode getBypassHashKey() {\n-        return ApplicationStatusCode.RECORD_HASH_MISMATCH_BYPASS_UNTIL_AFTER;\n-    }\n-\n-    @Override\n-    protected String getPrevFileHash(String filePath) {\n-        return RecordFileParser.readPrevFileHash(filePath);\n-    }\n-\n-    @Override\n-    protected byte[] getDataFileHash(String fileName) {\n-        return Utility.getRecordFileHash(fileName);\n+    protected boolean verifyDataFile(String filePath, byte[] verifiedHash) {\n+        RecordFile recordFile =  Utility.parseRecordFile(filePath, false);\n+        if (!recordFile.getFileHash().contentEquals(Hex.encodeHexString(verifiedHash))) {\n+            return false;\n+        }\n+        String fileName = Utility.getFileName(filePath);", "originalCommit": "827fce5f27c0599e5949216b0958760b1985718e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1MTQ4Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r432251487", "bodyText": "done.", "author": "apeksharma", "createdAt": "2020-05-29T04:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExNzI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExNzM5NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r426117395", "bodyText": "This log doesn't make sense here as this method is dealing with verification, not downloading. Also, there's already a log for \"finished downloading {}\" in PendingDownload. We can remove this.", "author": "steven-sheehy", "createdAt": "2020-05-16T04:34:23Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/record/RecordFileDownloader.java", "diffHunk": "@@ -62,18 +63,21 @@ protected ApplicationStatusCode getLastValidDownloadedFileHashKey() {\n         return ApplicationStatusCode.LAST_VALID_DOWNLOADED_RECORD_FILE_HASH;\n     }\n \n+    /**\n+     * Checks that hash of data file matches the verified hash. Then checks that data file is next in line based on\n+     * previous file hash.\n+     */\n     @Override\n-    protected ApplicationStatusCode getBypassHashKey() {\n-        return ApplicationStatusCode.RECORD_HASH_MISMATCH_BYPASS_UNTIL_AFTER;\n-    }\n-\n-    @Override\n-    protected String getPrevFileHash(String filePath) {\n-        return RecordFileParser.readPrevFileHash(filePath);\n-    }\n-\n-    @Override\n-    protected byte[] getDataFileHash(String fileName) {\n-        return Utility.getRecordFileHash(fileName);\n+    protected boolean verifyDataFile(String filePath, byte[] verifiedHash) {\n+        RecordFile recordFile =  Utility.parseRecordFile(filePath, false);\n+        if (!recordFile.getFileHash().contentEquals(Hex.encodeHexString(verifiedHash))) {\n+            return false;\n+        }\n+        String fileName = Utility.getFileName(filePath);\n+        log.debug(\"Downloaded data file {} corresponding to verified hash\", fileName);", "originalCommit": "827fce5f27c0599e5949216b0958760b1985718e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExODU3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r426118573", "bodyText": "This test fails if you remove the .rcd extension, as the docs suggest you populate the value. Would recommend removing .rcd from all tests here.", "author": "steven-sheehy", "createdAt": "2020-05-16T04:53:58Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/util/UtilityTest.java", "diffHunk": "@@ -214,4 +214,27 @@ void convertTimestampToNanosIllegalInput() {\n             Utility.timeStampInNanos(timestamp);\n         });\n     }\n+\n+    @ParameterizedTest(name = \"verifyHashChain {5}\")\n+    @CsvSource({\n+            \"'', '', '', 2000-01-01T10_00_00.000000.rcd, true, passes if both hashes are empty\",\n+            \"xx, '', '', 2000-01-01T10_00_00.000000.rcd, true, \" +\n+                    \" passes if hash mismatch and expected hash is empty\", // starting stream in middle\n+            \"'', xx, '', 2000-01-01T10_00_00.000000.rcd, false,\" +\n+                    \" fails if hash mismatch and actual hash is empty\", // bad db state\n+            \"xx, yy, '', 2000-01-01T10_00_00.000000.rcd, false, fails if hash mismatch and hashes are non-empty\",\n+            \"xx, yy, 2000-01-02T10_00_00.000001.rcd, 2000-01-01T10_00_00.000000.rcd, true,\" +\n+                    \" passes if hash mismatch but verifyHashAfter is after filename\",\n+            \"xx, yy, 2000-01-01T10_00_00.000000.rcd, 2000-01-01T10_00_00.000000.rcd, true,\" +", "originalCommit": "827fce5f27c0599e5949216b0958760b1985718e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1Mjg4MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r432252881", "bodyText": "should not be a problem now.", "author": "apeksharma", "createdAt": "2020-05-29T04:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExODU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMDMzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r426120338", "bodyText": "Utility.hashIsEmpty(prevFileHash) is not carried over to the new code. To be honest I'm not sure if that's good or bad. The old behavior of just accepting a stream reset file seems suspect. This needs to be considered carefully.", "author": "steven-sheehy", "createdAt": "2020-05-16T05:23:26Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/downloader/Downloader.java", "diffHunk": "@@ -386,32 +379,6 @@ private void verifySigsAndDownloadDataFiles(Multimap<String, FileStreamSignature\n         }\n     }\n \n-    /**\n-     * Verifies that prevFileHash in given {@code file} matches that in application repository.\n-     *\n-     * @throws Exception\n-     */\n-    protected boolean verifyHashChain(File file) {\n-        String filePath = file.getAbsolutePath();\n-        String lastValidFileHash = applicationStatusRepository.findByStatusCode(getLastValidDownloadedFileHashKey());\n-        String bypassMismatch = applicationStatusRepository.findByStatusCode(getBypassHashKey());\n-        String prevFileHash = getPrevFileHash(filePath);\n-\n-        if (prevFileHash == null) {\n-            log.warn(\"Does not contain valid previous file hash: {}\", filePath);\n-            return false;\n-        }\n-\n-        if (StringUtils.isBlank(lastValidFileHash) || lastValidFileHash.equals(prevFileHash) ||\n-                Utility.hashIsEmpty(prevFileHash) || bypassMismatch.compareTo(file.getName()) > 0) {", "originalCommit": "827fce5f27c0599e5949216b0958760b1985718e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1MDg0Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r432250846", "bodyText": "prev hash in a file cannot be empty unless its first file in the stream. In which case, database should be empty too and both hashes (equal to empty) will match.\nWe should not skip hash check if prevFileHash is empty.", "author": "apeksharma", "createdAt": "2020-05-29T04:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMDMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMDg0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r426120841", "bodyText": "I have a huge concern with this new approach to loading all record items into memory at once instead of processing them one by one. If we process 10K TPS * 5s per file * 6144 bytes per transaction that's 293MB loaded into memory in this loop. At 100K TPS it would be crazy. Even if we consider a more average of 500 bytes per transaction that's still 25MB causing a lot of memory churn.\nI like the code de-duplication done here, but it needs to be done in a streaming fashion without loading everything at once and then processing. For downloader, there's the parseRecordItems flag so it's not a problem. For parser, he doesn't need to read the whole file first to verify anything, he just needs the previous hash. Perhaps a callback passed in or returning a file reading Iterator instead of a list.", "author": "steven-sheehy", "createdAt": "2020-05-16T05:32:18Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/util/Utility.java", "diffHunk": "@@ -125,80 +128,82 @@\n      * @param filename file name\n      * @return byte array of hash value of null if calculating has failed\n      */\n-    public static byte[] getRecordFileHash(String filename) {\n-        byte[] readFileHash = new byte[48];\n+    public static RecordFile parseRecordFile(String filename, boolean parseRecordItems) {\n+        RecordFile recordFile = new RecordFile();\n+        recordFile.setName(filename);\n+        recordFile.setRecordItems(new ArrayList<>());\n \n         try (DataInputStream dis = new DataInputStream(new FileInputStream(filename))) {\n             MessageDigest md = MessageDigest.getInstance(FileDelimiter.HASH_ALGORITHM);\n             MessageDigest mdForContent = MessageDigest.getInstance(FileDelimiter.HASH_ALGORITHM);\n \n-            int record_format_version = dis.readInt();\n+            int recordFormatVersion = dis.readInt();\n             int version = dis.readInt();\n+            log.info(\"Loading record format version {} from record file: {}\", recordFormatVersion, filename);\n+            recordFile.setRecordFormatVersion(recordFormatVersion);\n \n-            md.update(Utility.integerToBytes(record_format_version));\n+            md.update(Utility.integerToBytes(recordFormatVersion));\n             md.update(Utility.integerToBytes(version));\n \n-            log.debug(\"Calculating hash for version {} record file: {}\", record_format_version, filename);\n+            log.debug(\"Calculating hash for version {} record file: {}\", recordFormatVersion, filename);\n \n             while (dis.available() != 0) {\n-\n                 byte typeDelimiter = dis.readByte();\n-\n                 switch (typeDelimiter) {\n                     case FileDelimiter.RECORD_TYPE_PREV_HASH:\n                         md.update(typeDelimiter);\n+                        byte[] readFileHash = new byte[48];\n                         dis.read(readFileHash);\n+                        recordFile.setPreviousHash(Hex.encodeHexString(readFileHash));\n                         md.update(readFileHash);\n                         break;\n-                    case FileDelimiter.RECORD_TYPE_RECORD:\n \n-                        int byteLength = dis.readInt();\n-                        byte[] rawBytes = new byte[byteLength];\n-                        dis.readFully(rawBytes);\n-                        if (record_format_version >= FileDelimiter.RECORD_FORMAT_VERSION) {\n-                            mdForContent.update(typeDelimiter);\n-                            mdForContent.update(Utility.integerToBytes(byteLength));\n-                            mdForContent.update(rawBytes);\n-                        } else {\n-                            md.update(typeDelimiter);\n-                            md.update(Utility.integerToBytes(byteLength));\n-                            md.update(rawBytes);\n+                    case FileDelimiter.RECORD_TYPE_RECORD:\n+                        MessageDigest messageDigest = md;\n+                        if (recordFormatVersion >= FileDelimiter.RECORD_FORMAT_VERSION) {\n+                            messageDigest = mdForContent;\n                         }\n-\n+                        // Read Transaction\n+                        int byteLength = dis.readInt();\n+                        byte[] transactionRawBytes = new byte[byteLength];\n+                        dis.readFully(transactionRawBytes);\n+                        messageDigest.update(typeDelimiter);\n+                        messageDigest.update(Utility.integerToBytes(byteLength));\n+                        messageDigest.update(transactionRawBytes);\n+                        // Read TransactionRecord\n                         byteLength = dis.readInt();\n-                        rawBytes = new byte[byteLength];\n-                        dis.readFully(rawBytes);\n-\n-                        if (record_format_version >= FileDelimiter.RECORD_FORMAT_VERSION) {\n-                            mdForContent.update(Utility.integerToBytes(byteLength));\n-                            mdForContent.update(rawBytes);\n-                        } else {\n-                            md.update(Utility.integerToBytes(byteLength));\n-                            md.update(rawBytes);\n+                        byte[] recordRawBytes = new byte[byteLength];\n+                        dis.readFully(recordRawBytes);\n+                        messageDigest.update(Utility.integerToBytes(byteLength));\n+                        messageDigest.update(recordRawBytes);\n+                        if (parseRecordItems) {\n+                            recordFile.getRecordItems().add(new RecordItem(transactionRawBytes, recordRawBytes));", "originalCommit": "827fce5f27c0599e5949216b0958760b1985718e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1NDY0Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r432254647", "bodyText": "I have given it a good thought in first iteration itself. With 10k tps and 6k txns msg size totaling to 300MB, it's nothing worth worry about. Java GC will have no problem at such small scale.\nIt's worth nothing that we want to remove FS dependency and all things will live in memory eventually.\nAn importer with few gigs of mem would have no issues even then.\nNo need of optimization here. Keep it simple.", "author": "apeksharma", "createdAt": "2020-05-29T04:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMDg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMTE2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r426121160", "bodyText": "This will print hash mismatch errors twice in the log: one for Utility.verifyHashChain() and one for catch.", "author": "steven-sheehy", "createdAt": "2020-05-16T05:37:30Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/RecordFileParser.java", "diffHunk": "@@ -98,101 +92,27 @@ public RecordFileParser(ApplicationStatusRepository applicationStatusRepository,\n                         \"processed the transaction\");\n     }\n \n-    /**\n-     * Given a service record name, read its prevFileHash\n-     *\n-     * @param fileName the name of record file to read\n-     * @return return previous file hash's Hex String\n-     */\n-    public static String readPrevFileHash(String fileName) {\n-        File file = new File(fileName);\n-        if (file.exists() == false) {\n-            log.warn(\"File does not exist {}\", fileName);\n-            return null;\n-        }\n-        byte[] prevFileHash = new byte[48];\n-        try (DataInputStream dis = new DataInputStream(new FileInputStream(file))) {\n-            // record_format_version\n-            dis.readInt();\n-            // version\n-            dis.readInt();\n-\n-            byte typeDelimiter = dis.readByte();\n-\n-            if (typeDelimiter == FileDelimiter.RECORD_TYPE_PREV_HASH) {\n-                dis.read(prevFileHash);\n-                String hexString = Hex.encodeHexString(prevFileHash);\n-                log.trace(\"Read previous file hash {} for file {}\", hexString, fileName);\n-                return hexString;\n-            } else {\n-                log.error(\"Expecting previous file hash, but found file delimiter {} for file {}\", typeDelimiter,\n-                        fileName);\n-            }\n-        } catch (Exception e) {\n-            log.error(\"Error reading previous file hash {}\", fileName, e);\n-        }\n-\n-        return null;\n-    }\n-\n     /**\n      * Given a service record name, read and parse and return as a list of service record pair\n      *\n      * @param streamFileData containing information about file to be processed\n      */\n-    public void loadRecordFile(StreamFileData streamFileData) throws IOException {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        long loadStart = Instant.now().getEpochSecond();\n+    public void loadRecordFile(StreamFileData streamFileData) {\n+        Instant startTime = Instant.now();\n         recordStreamFileListener.onStart(streamFileData);\n-        String fileName = streamFileData.getFilename();\n-        String actualPrevFileHash = \"\";\n-        long counter = 0;\n-        Integer recordFileVersion = 0;\n-        Boolean success = false;\n-\n-        try (DataInputStream dis = new DataInputStream(streamFileData.getInputStream())) {\n-            recordFileVersion = dis.readInt();\n-            int version = dis.readInt();\n-            log.info(\"Loading version {} record file: {}\", recordFileVersion, fileName);\n-            while (dis.available() != 0) {\n-                byte typeDelimiter = dis.readByte();\n-\n-                switch (typeDelimiter) {\n-                    case FileDelimiter.RECORD_TYPE_PREV_HASH:\n-                        byte[] readFileHash = new byte[48];\n-                        dis.read(readFileHash);\n-                        actualPrevFileHash = Hex.encodeHexString(readFileHash);\n-                        String expectedPrevFileHash = applicationStatusRepository.findByStatusCode(\n-                                ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH);\n-                        if (Utility.hashIsEmpty(expectedPrevFileHash)) {\n-                            log.error(\"Previous file hash not available\");\n-                            expectedPrevFileHash = actualPrevFileHash;\n-                        }\n-                        log.trace(\"actual file hash = {}, expected file hash = {}\", actualPrevFileHash,\n-                                expectedPrevFileHash);\n-                        if (!actualPrevFileHash.contentEquals(expectedPrevFileHash)) {\n-                            if (applicationStatusRepository\n-                                    .findByStatusCode(ApplicationStatusCode.RECORD_HASH_MISMATCH_BYPASS_UNTIL_AFTER)\n-                                    .compareTo(Utility.getFileName(fileName)) < 0) {\n-                                // last file for which mismatch is allowed is in the past\n-                                throw new ParserException(String.format(\n-                                        \"Hash mismatch for file %s. Expected = %s, Actual = %s\",\n-                                        fileName, expectedPrevFileHash, actualPrevFileHash));\n-                            }\n-                        }\n-                        break;\n-                    case FileDelimiter.RECORD_TYPE_RECORD:\n+        RecordFile recordFile = Utility.parseRecordFile(streamFileData.getFilename(), true);\n+        String fileName = Utility.getFileName(streamFileData.getFilename());\n+        recordFile.setLoadStart(startTime.getEpochSecond());\n+        int counter = 0;\n+        boolean success = false;\n+        try {\n+            if (!Utility.verifyHashChain(recordFile.getPreviousHash(),\n+                    applicationStatusRepository.findByStatusCode(ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH),\n+                    parserProperties.getMirrorProperties().getVerifyHashAfter(), fileName)) {\n+                throw new ParserException(\"Hash mismatch for file \" + fileName);", "originalCommit": "827fce5f27c0599e5949216b0958760b1985718e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1MTk5OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/757#discussion_r432251998", "bodyText": "The actual log is fn is detailed. This is just exception message.", "author": "apeksharma", "createdAt": "2020-05-29T04:41:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMTE2MA=="}], "type": "inlineReview"}]}