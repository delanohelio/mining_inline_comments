{"pr_number": 1340, "pr_title": "Addressbook migration", "pr_createdAt": "2020-12-09T06:42:35Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340", "timeline": [{"oid": "b93843b1ace451586d860a15823c0b1dbea0d789", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/b93843b1ace451586d860a15823c0b1dbea0d789", "message": "Move AddressBook Migration Logic to AddresBookService\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-09T05:19:48Z", "type": "commit"}, {"oid": "0b3c8b38afdb440d6be9a02c25d4fe87e0b26de5", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/0b3c8b38afdb440d6be9a02c25d4fe87e0b26de5", "message": "Added tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-09T06:31:46Z", "type": "commit"}, {"oid": "301311eec0205bdc6811defa7d8e7fa651418eff", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/301311eec0205bdc6811defa7d8e7fa651418eff", "message": "Expand startupWithOtherNetwork test\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-09T07:30:51Z", "type": "commit"}, {"oid": "f6ee6783bfe6f52c2dd40359bf19a654f3226e39", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f6ee6783bfe6f52c2dd40359bf19a654f3226e39", "message": "Fix tests and clean up AddressBookServiceImpl migration flow\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-09T18:13:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwNDI4OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539504289", "bodyText": "q: Would it be better to just call getCurrent() here and utilize ADDRESS_BOOK_102_CACHE_NAME cache and share the code.\nThis would only ever get called for every 101 or 102 file transaction so it's a minimal impact on db calls.", "author": "Nana-EC", "createdAt": "2020-12-09T17:31:11Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -82,6 +97,11 @@ public void update(FileData fileData) {\n             return;\n         }\n \n+        // ensure address_book table is populated with at least bootstrap addressBook prior to additions\n+        if (shouldMigrate()) {", "originalCommit": "301311eec0205bdc6811defa7d8e7fa651418eff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDg0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539560841", "bodyText": "I think it can actually just call migrate() directly (remove shouldMigrate()) with my request to add a db check inside migrate to solve a race condition. As you state, 101/102 files are extremely rare and a synchronized block is in comparison quite fast.", "author": "steven-sheehy", "createdAt": "2020-12-09T18:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwNDI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MTEwOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539681109", "bodyText": "Works for me", "author": "Nana-EC", "createdAt": "2020-12-09T22:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwNDI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5NDUzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539694536", "bodyText": "Modified to call migrate() directly and removed shouldMigrate()", "author": "Nana-EC", "createdAt": "2020-12-09T22:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwNDI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxMTk2OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539511968", "bodyText": "move synchronized to getInitialAddressBookFileData() as the file is the resource we want to synchronize on", "author": "Nana-EC", "createdAt": "2020-12-09T17:39:44Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,6 +136,17 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    @Override\n+    public synchronized void migrate() {", "originalCommit": "301311eec0205bdc6811defa7d8e7fa651418eff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxMjY5OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539512699", "bodyText": "Update this to call parse so there's no circular behavior here. Add byte size check", "author": "Nana-EC", "createdAt": "2020-12-09T17:40:45Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -269,4 +303,89 @@ private void updatePreviousAddressBook(FileData fileData) {\n                     }\n                 });\n     }\n+\n+    /**\n+     * Check whether address book migration should be run based on if flag has been set and if table is empty\n+     *\n+     * @return Whether to run address book migration\n+     */\n+    private boolean shouldMigrate() {\n+        if (hasAddressBooks) {\n+            return false;\n+        }\n+\n+        hasAddressBooks = addressBookRepository.count() > 0;\n+        return !hasAddressBooks;\n+    }\n+\n+    /**\n+     * Retrieve the initial address book file for the network from either the file system or class path\n+     *\n+     * @return Address book fileData object\n+     */\n+    private FileData getInitialAddressBookFileData() {\n+        byte[] addressBookBytes;\n+\n+        // retrieve bootstrap address book from filesystem or classpath\n+        try {\n+            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+            if (initialAddressBook != null) {\n+                addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                        initialAddressBook);\n+            } else {\n+                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                Resource resource = new ClassPathResource(resourcePath, getClass());\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n+        }\n+\n+        return new FileData(0L, addressBookBytes,\n+                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n+                TransactionTypeEnum.FILECREATE.getProtoId());\n+    }\n+\n+    /**\n+     * Batch parse all 101 and 102 addressBook fileData objects and update the address_book table\n+     */\n+    private void parseHistoricAddressBooks() {\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n+        int pageSize = 1000; //\n+        List<FileData> fileDataList = fileDataRepository\n+                .findAddressBooksAfter(currentConsensusTimestamp.get(), pageSize);\n+        while (!CollectionUtils.isEmpty(fileDataList)) {\n+            log.info(\"Retrieved {} file_data rows for address book processing\", fileDataList.size());\n+            fileDataList.forEach(fileData -> {\n+                // call normal address book file transaction parsing flow to parse and ingest address book contents\n+                update(fileData);", "originalCommit": "301311eec0205bdc6811defa7d8e7fa651418eff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxMzgyMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539513820", "bodyText": "Original order of steps was off.\nParser logic would add an item to the address_book prior to adding the file_data item.\nUpdate for correctness", "author": "Nana-EC", "createdAt": "2020-12-09T17:42:17Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImplTest.java", "diffHunk": "@@ -95,12 +109,16 @@ private static NodeAddressBook addressBook(int size) {\n         return builder.build();\n     }\n \n-    private void update(byte[] contents, long consensusTimeStamp, boolean is102) {\n+    private FileData store(byte[] contents, long consensusTimeStamp, boolean is102) {\n         EntityId entityId = is102 ? AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID :\n                 AddressBookServiceImpl.ADDRESS_BOOK_101_ENTITY_ID;\n         FileData fileData = new FileData(consensusTimeStamp, contents, entityId, TransactionTypeEnum.FILEUPDATE\n                 .getProtoId());\n-        fileDataRepository.save(fileData);\n+        return fileDataRepository.save(fileData);\n+    }\n+\n+    private void update(byte[] contents, long consensusTimeStamp, boolean is102) {\n+        FileData fileData = store(contents, consensusTimeStamp, is102);", "originalCommit": "301311eec0205bdc6811defa7d8e7fa651418eff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxNTYzNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539515637", "bodyText": "Update by reverting back to using Bean for addressBookService and using a custom AddressBookService instance in the startupWithOtherNetwork() where it's needed", "author": "Nana-EC", "createdAt": "2020-12-09T17:44:54Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImplTest.java", "diffHunk": "@@ -113,18 +131,34 @@ private void append(byte[] contents, long consensusTimeStamp, boolean is102) {\n         addressBookService.update(fileData);\n     }\n \n+    @BeforeAll\n+    static void setupAll() throws IOException {\n+        Path addressBookPath = ResourceUtils.getFile(\"classpath:addressbook/testnet\").toPath();\n+        initialAddressBookBytes = Files.readAllBytes(addressBookPath);\n+    }\n+\n     @BeforeEach\n     void setup() {\n-        mirrorProperties = new MirrorProperties();\n-        mirrorProperties.setDataPath(dataPath);\n+        addressBookService = new AddressBookServiceImpl(addressBookRepository, fileDataRepository, mirrorProperties);", "originalCommit": "301311eec0205bdc6811defa7d8e7fa651418eff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7d89285c4a28e536483b7ea21b730d733444c4fb", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7d89285c4a28e536483b7ea21b730d733444c4fb", "message": "Cleaned up some comments and added startupWithOtherNetworkIncorrectInitialAddressBookPath test\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-09T18:30:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyNjE3Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539526172", "bodyText": "This can fail if the schema changes and should be removed. The AddressBookService.migrate() always uses the latest schema but when this is ran with an older schema it can fail for the same reasons we don't use Repository classes in Java migrations. If we can remove the entire class and it doesn't break things for current deployments, that would be even better.", "author": "steven-sheehy", "createdAt": "2020-12-09T17:59:55Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_28_1__Address_Book.java", "diffHunk": "@@ -21,115 +21,32 @@\n  */\n \n import com.google.common.base.Stopwatch;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.List;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n import javax.inject.Named;\n-import javax.sql.DataSource;\n import lombok.extern.log4j.Log4j2;\n-import org.apache.commons.io.IOUtils;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n import org.flywaydb.core.api.migration.Context;\n import org.springframework.context.annotation.Lazy;\n-import org.springframework.core.io.ClassPathResource;\n-import org.springframework.core.io.Resource;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.util.CollectionUtils;\n \n-import com.hedera.mirror.importer.MirrorProperties;\n import com.hedera.mirror.importer.addressbook.AddressBookService;\n-import com.hedera.mirror.importer.addressbook.AddressBookServiceImpl;\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.FileData;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.util.EntityIdEndec;\n \n @Log4j2\n @Named\n-public class V1_28_1__Address_Book extends BaseJavaMigration {\n+public class V1_28_1__Address_Book extends MirrorBaseJavaMigration {\n     private final AddressBookService addressBookService;\n-    private final MirrorProperties mirrorProperties;\n-    private final DataSource dataSource;\n-    private final String FILE_DATA_SQL = \"select * from file_data where consensus_timestamp > ? and entity_id \" +\n-            \"in (101, 102) order by consensus_timestamp asc limit ?\";\n-    private JdbcTemplate jdbcTemplate;\n \n-    public V1_28_1__Address_Book(MirrorProperties mirrorProperties, @Lazy AddressBookService addressBookService,\n-                                 DataSource dataSource) {\n+    public V1_28_1__Address_Book(@Lazy AddressBookService addressBookService) {\n         this.addressBookService = addressBookService;\n-        this.mirrorProperties = mirrorProperties;\n-        this.dataSource = dataSource;\n     }\n \n     @Override\n-    public void migrate(Context context) throws Exception {\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n-        AtomicLong fileDataEntries = new AtomicLong(0);\n-        byte[] addressBookBytes;\n-\n-        // retrieve bootstrap address book from filesystem or classpath\n-        try {\n-            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n-            if (initialAddressBook != null) {\n-                addressBookBytes = Files.readAllBytes(initialAddressBook);\n-                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n-                        initialAddressBook);\n-            } else {\n-                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n-                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n-                Resource resource = new ClassPathResource(resourcePath, getClass());\n-                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n-                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n-            }\n-        } catch (Exception e) {\n-            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n-        }\n-\n-        FileData bootStrapFileData = new FileData(0L, addressBookBytes,\n-                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n-                TransactionTypeEnum.FILECREATE.getProtoId());\n-        addressBookService.update(bootStrapFileData);\n-        fileDataEntries.incrementAndGet();\n-\n-        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n-        int pageSize = 1000; // option to parameterize this\n-        List<FileData> fileDataList = getLatestFileData(currentConsensusTimestamp.get(), pageSize);\n-        while (!CollectionUtils.isEmpty(fileDataList)) {\n-            fileDataList.forEach(fileData -> {\n-                // call normal address book file transaction parsing flow to parse and ingest address book contents\n-                addressBookService.update(fileData);\n-                fileDataEntries.incrementAndGet();\n-                currentConsensusTimestamp.set(fileData.getConsensusTimestamp());\n-            });\n-\n-            fileDataList = getLatestFileData(currentConsensusTimestamp.get(), pageSize);\n+    public void migrate(Context context) {\n+        if (skipMigrationVersion(getVersion(), context.getConfiguration())) {\n+            return;\n         }\n-        log.info(\"Migration processed {} in {} ms\", fileDataEntries.get(), stopwatch.elapsed(TimeUnit.MILLISECONDS));\n-    }\n \n-    private List<FileData> getLatestFileData(long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve file_data rows after {} ns with page size {}\", consensusTimestamp, pageSize);\n-        List<FileData> fileDataList = jdbcTemplate.query(\n-                FILE_DATA_SQL,\n-                new Object[] {consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public FileData mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return new FileData(rs.getLong(\"consensus_timestamp\"),\n-                                rs.getBytes(\"file_data\"),\n-                                EntityIdEndec.decode(rs.getInt(\"entity_id\"), EntityTypeEnum.FILE),\n-                                rs.getInt(\"transaction_type\"));\n-                    }\n-                });\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        addressBookService.migrate();", "originalCommit": "301311eec0205bdc6811defa7d8e7fa651418eff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxMDY4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539610680", "bodyText": "Good point\nGiven Java migration checksums are null and we have ignoreMissingMigrations set to true should be fine to remove this.", "author": "Nana-EC", "createdAt": "2020-12-09T20:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyNjE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5NDE4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539694180", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-12-09T22:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyNjE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyODE4OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539528188", "bodyText": "It would be more encapsulated if the parent class implemented migrate(context) and contained this skip logic while child classes implement an abstract void doMigrate().", "author": "steven-sheehy", "createdAt": "2020-12-09T18:02:48Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_11_6__Missing_Entities.java", "diffHunk": "@@ -54,14 +53,18 @@\n     // break it.\n     // Correct way is to not use repositories and construct manually: new JdbcTemplate(context.getConnection())\n     public V1_11_6__Missing_Entities(MirrorProperties mirrorProperties, @Lazy EntityRepository entityRepository,\n-            @Lazy JdbcOperations jdbcOperations) {\n+                                     @Lazy JdbcOperations jdbcOperations) {\n         this.mirrorProperties = mirrorProperties;\n         this.entityRepository = entityRepository;\n         this.jdbcOperations = jdbcOperations;\n     }\n \n     @Override\n     public void migrate(Context context) throws Exception {\n+        if (skipMigrationVersion(getVersion(), context.getConfiguration())) {", "originalCommit": "301311eec0205bdc6811defa7d8e7fa651418eff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxMTE3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539611175", "bodyText": "Good suggestion. Will make this change", "author": "Nana-EC", "createdAt": "2020-12-09T20:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyODE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5NDA3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539694073", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-12-09T22:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyODE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyOTc5NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539529794", "bodyText": "Don't think @Named has any effect here and can be removed.", "author": "steven-sheehy", "createdAt": "2020-12-09T18:05:14Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/MirrorBaseJavaMigration.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+\n+@Log4j2\n+@Named", "originalCommit": "301311eec0205bdc6811defa7d8e7fa651418eff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5NTY0Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539695646", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-12-09T22:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyOTc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUzMDUwOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539530509", "bodyText": "Doesn't need to be public or in the interface due to my other comment.", "author": "steven-sheehy", "createdAt": "2020-12-09T18:06:19Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,6 +136,17 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    @Override\n+    public synchronized void migrate() {", "originalCommit": "301311eec0205bdc6811defa7d8e7fa651418eff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NzU0Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539557546", "bodyText": "This whole migrate methods needs to be synchronized and it needs to recheck if the address book table is empty before continuing in case a race condition caused someone else to migrate after it checked the db but before it got the lock.", "author": "steven-sheehy", "createdAt": "2020-12-09T18:46:15Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,6 +136,17 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    @Override\n+    public void migrate() {", "originalCommit": "f6ee6783bfe6f52c2dd40359bf19a654f3226e39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MTUyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539681529", "bodyText": "Good point. I'll move the synchronized back up here instead of only on the file read method", "author": "Nana-EC", "createdAt": "2020-12-09T22:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NzU0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5NDc2Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539694767", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-12-09T22:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NzU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5ODkxNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539598915", "bodyText": "migrate() needs to be in a transaction to be functionally equivalent to the flyway approach. What's less clear if it's okay to put @Transactional on the public methods of this class and let it join outer transactions or it requires its own inner transaction via TransactionTemplate. I'm thinking the latter.", "author": "steven-sheehy", "createdAt": "2020-12-09T19:49:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,6 +136,17 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    @Override\n+    public void migrate() {\n+        log.debug(\"Searching for address book on file system\");\n+        AddressBook addressBook = buildAddressBook(getInitialAddressBookFileData());\n+        addressBook = addressBookRepository.save(addressBook);", "originalCommit": "7d89285c4a28e536483b7ea21b730d733444c4fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MTcyNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539681725", "bodyText": "Will go with TransactionTemplate to be safe", "author": "Nana-EC", "createdAt": "2020-12-09T22:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5ODkxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5NTI2Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539695266", "bodyText": "Added TransactionTemplate execute", "author": "Nana-EC", "createdAt": "2020-12-09T22:27:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5ODkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwMTcwMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539601702", "bodyText": "Technically buildAddressBook() has the potential to return null. Why not reuse parse() method?", "author": "steven-sheehy", "createdAt": "2020-12-09T19:53:52Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,6 +136,17 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    @Override\n+    public void migrate() {\n+        log.debug(\"Searching for address book on file system\");\n+        AddressBook addressBook = buildAddressBook(getInitialAddressBookFileData());\n+        addressBook = addressBookRepository.save(addressBook);", "originalCommit": "7d89285c4a28e536483b7ea21b730d733444c4fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4MjA5OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539682099", "bodyText": "Yeah parse is better. Less code as it does what I need.", "author": "Nana-EC", "createdAt": "2020-12-09T22:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwMTcwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5NTM0MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539695340", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-12-09T22:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwMTcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDE2OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539604168", "bodyText": "This method seems unnecessary. You've already retrieved all the data at some point inside the migrate() method. Just have it keep track of which is the latest and return that so the signature becomes:\nprivate synchronized AddressBook migrate() {\n...\n}", "author": "steven-sheehy", "createdAt": "2020-12-09T19:57:48Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -269,4 +303,92 @@ private void updatePreviousAddressBook(FileData fileData) {\n                     }\n                 });\n     }\n+\n+    /**\n+     * Check whether address book migration should be run based on if flag has been set and if table is empty\n+     *\n+     * @return Whether to run address book migration\n+     */\n+    private boolean shouldMigrate() {\n+        if (hasAddressBooks) {\n+            return false;\n+        }\n+\n+        hasAddressBooks = addressBookRepository.count() > 0;\n+        return !hasAddressBooks;\n+    }\n+\n+    /**\n+     * Retrieve the initial address book file for the network from either the file system or class path\n+     *\n+     * @return Address book fileData object\n+     */\n+    private synchronized FileData getInitialAddressBookFileData() {\n+        byte[] addressBookBytes;\n+\n+        // retrieve bootstrap address book from filesystem or classpath\n+        try {\n+            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+            if (initialAddressBook != null) {\n+                addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                        initialAddressBook);\n+            } else {\n+                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                Resource resource = new ClassPathResource(resourcePath, getClass());\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n+        }\n+\n+        return new FileData(0L, addressBookBytes,\n+                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n+                TransactionTypeEnum.FILECREATE.getProtoId());\n+    }\n+\n+    /**\n+     * Batch parse all 101 and 102 addressBook fileData objects and update the address_book table\n+     */\n+    private void parseHistoricAddressBooks() {\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n+        int pageSize = 1000; //\n+        List<FileData> fileDataList = fileDataRepository\n+                .findAddressBooksAfter(currentConsensusTimestamp.get(), pageSize);\n+        while (!CollectionUtils.isEmpty(fileDataList)) {\n+            log.info(\"Retrieved {} file_data rows for address book processing\", fileDataList.size());\n+            fileDataList.forEach(fileData -> {\n+                if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                    // call normal address book file transaction parsing flow to parse and ingest address book contents\n+                    parse(fileData);\n+                    fileDataEntries.incrementAndGet();\n+                }\n+\n+                currentConsensusTimestamp.set(fileData.getConsensusTimestamp());\n+            });\n+\n+            fileDataList = fileDataRepository.findAddressBooksAfter(currentConsensusTimestamp.get(), pageSize);\n+        }\n+\n+        log.info(\"Processed {} historic address books\", fileDataEntries.get());\n+    }\n+\n+    /**\n+     * Run address book migration logic and return the latest addressBook 102 object\n+     *\n+     * @param consensusTimestamp time stamp reference to get latest address book\n+     * @return\n+     */\n+    private AddressBook migrateAndRetrieveLatestAddressBook(long consensusTimestamp) {", "originalCommit": "7d89285c4a28e536483b7ea21b730d733444c4fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxMjQ1Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539612457", "bodyText": "Had considered that, went with the above to be more explicit but I'm okay with this approach.", "author": "Nana-EC", "createdAt": "2020-12-09T20:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5NTU2Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539695566", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-12-09T22:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDE2OA=="}], "type": "inlineReview"}, {"oid": "3cdffe7dde417a6ebbe7ce6d716995aa12bf11c1", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3cdffe7dde417a6ebbe7ce6d716995aa12bf11c1", "message": "Address feedback on reuse, migrations and fixed tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-09T22:12:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4NzI5Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539687293", "bodyText": "Nit, unless there's supposed to be a comment here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int pageSize = 1000; //\n          \n          \n            \n                    int pageSize = 1000;", "author": "ijungmann", "createdAt": "2020-12-09T22:13:29Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -269,4 +303,92 @@ private void updatePreviousAddressBook(FileData fileData) {\n                     }\n                 });\n     }\n+\n+    /**\n+     * Check whether address book migration should be run based on if flag has been set and if table is empty\n+     *\n+     * @return Whether to run address book migration\n+     */\n+    private boolean shouldMigrate() {\n+        if (hasAddressBooks) {\n+            return false;\n+        }\n+\n+        hasAddressBooks = addressBookRepository.count() > 0;\n+        return !hasAddressBooks;\n+    }\n+\n+    /**\n+     * Retrieve the initial address book file for the network from either the file system or class path\n+     *\n+     * @return Address book fileData object\n+     */\n+    private synchronized FileData getInitialAddressBookFileData() {\n+        byte[] addressBookBytes;\n+\n+        // retrieve bootstrap address book from filesystem or classpath\n+        try {\n+            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+            if (initialAddressBook != null) {\n+                addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                        initialAddressBook);\n+            } else {\n+                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                Resource resource = new ClassPathResource(resourcePath, getClass());\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n+        }\n+\n+        return new FileData(0L, addressBookBytes,\n+                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n+                TransactionTypeEnum.FILECREATE.getProtoId());\n+    }\n+\n+    /**\n+     * Batch parse all 101 and 102 addressBook fileData objects and update the address_book table\n+     */\n+    private void parseHistoricAddressBooks() {\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n+        int pageSize = 1000; //", "originalCommit": "7d89285c4a28e536483b7ea21b730d733444c4fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY5OTY4Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539699686", "bodyText": "Will remove thanks", "author": "Nana-EC", "createdAt": "2020-12-09T22:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4NzI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMzUzNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539703537", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-12-09T22:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY4NzI5Mw=="}], "type": "inlineReview"}, {"oid": "9576a37b9742dde55d5d70f8775320d011b4317f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9576a37b9742dde55d5d70f8775320d011b4317f", "message": "Removed V1_28_1__Address_Book migration and tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-09T22:21:07Z", "type": "commit"}, {"oid": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "message": "Cleaned up a bit\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-09T22:39:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg3ODA4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r539878080", "bodyText": "Is there any risk here of migrate() returning null?  I just see that findLatestAddressBook() is a more granular search than the one migrate() does.", "author": "ijungmann", "createdAt": "2020-12-10T06:14:29Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -95,9 +116,14 @@ public void update(FileData fileData) {\n     public AddressBook getCurrent() {\n         Instant now = Instant.now();\n         long consensusTimestamp = Utility.convertToNanosMax(now.getEpochSecond(), now.getNano());\n+\n+        // retrieve latest address book. If address_book is empty parse initial and historic address book files\n         return addressBookRepository\n                 .findLatestAddressBook(consensusTimestamp, ADDRESS_BOOK_102_ENTITY_ID.getId())\n-                .orElseThrow(() -> new IllegalStateException(\"No valid address book found in DB\"));\n+                .orElseGet(() -> {\n+                    log.debug(\"No address book found in db\");\n+                    return migrate();", "originalCommit": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQyNjcwNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540426704", "bodyText": "There shouldn't be.\nmigrate() keeps track of the latest addressBook encountered, so it should return the same value as a findLatestAddressBook()\nmigrate() transactionTemplate also checks for empty historical case and ensures at the least the initialAddressBook is passed.\nOnly way that would fail is with a TransactionException and we'd wanna see those.\nLet me know if that covers your question or if I'm missing something", "author": "Nana-EC", "createdAt": "2020-12-10T19:10:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg3ODA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ0ODg2MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540448861", "bodyText": "It can return null on race condition between two threads migrating at same time.", "author": "steven-sheehy", "createdAt": "2020-12-10T19:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg3ODA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUxOTg0Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540519847", "bodyText": "Gotcha, with recent updated to check for current and return on non-null I believe that case should now be handled", "author": "Nana-EC", "createdAt": "2020-12-10T21:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTg3ODA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM0MzgyNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540343827", "bodyText": "Log can be moved into migrate to produce a more accurate log for race condition and so you can shorten this to .orElseGet(this::migrate). It should also be changed to info log level. In fact, all logs inside migrate can be info (besides the skipping migration log) since it should only occur once and is very important we understand what is going on.", "author": "steven-sheehy", "createdAt": "2020-12-10T17:07:50Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -95,9 +116,14 @@ public void update(FileData fileData) {\n     public AddressBook getCurrent() {\n         Instant now = Instant.now();\n         long consensusTimestamp = Utility.convertToNanosMax(now.getEpochSecond(), now.getNano());\n+\n+        // retrieve latest address book. If address_book is empty parse initial and historic address book files\n         return addressBookRepository\n                 .findLatestAddressBook(consensusTimestamp, ADDRESS_BOOK_102_ENTITY_ID.getId())\n-                .orElseThrow(() -> new IllegalStateException(\"No valid address book found in DB\"));\n+                .orElseGet(() -> {\n+                    log.debug(\"No address book found in db\");", "originalCommit": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwODY5OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540508698", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-12-10T21:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM0MzgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM0ODA1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540348058", "bodyText": "We should never return null. It will NPE during the race condition scenario. Instead of count(), can just call addressBookRepository.findLatestAddressBook(102) again like in getCurrent() and return it if not null. This is effectively double checked locking, so the same check should be done twice.", "author": "steven-sheehy", "createdAt": "2020-12-10T17:13:50Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,13 +137,39 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    /**\n+     * Migrates address book data by searching file_data table for applicable 101 and 102 files. These files are\n+     * converted to AddressBook objects and used to populate address_book and address_book_entry tables\n+     *\n+     * @return Latest AddressBook from historical files\n+     */\n+    private synchronized AddressBook migrate() {\n+        if (addressBookRepository.count() > 0) {\n+            if (log.isTraceEnabled()) {\n+                log.trace(\"Valid address books exist in db, skipping migration\");\n+            }\n+            return null;", "originalCommit": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ1MTY4Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540451687", "bodyText": "Was siding with going with count() as an optimization but the double check is the more correct option", "author": "Nana-EC", "createdAt": "2020-12-10T19:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM0ODA1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwODYxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540508619", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-12-10T21:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM0ODA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MDIyNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540350225", "bodyText": "This will log as MirrorBaseJavaMigration instead of the concrete class. Should remove @Log4j2 and use protected final Logger log = LogManager.getLogger(getClass()) instead. You can also remove the annotation from children classes.", "author": "steven-sheehy", "createdAt": "2020-12-10T17:16:49Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/MirrorBaseJavaMigration.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+\n+@Log4j2\n+public abstract class MirrorBaseJavaMigration extends BaseJavaMigration {\n+\n+    public abstract void doMigrate() throws Exception;\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        MigrationVersion current = getVersion();\n+        if (skipMigrationVersion(current, context.getConfiguration())) {\n+            log.trace(\"Migration {} will be skipped as it precedes baseline version {}\",", "originalCommit": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQzOTU3Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540439576", "bodyText": "Good point", "author": "Nana-EC", "createdAt": "2020-12-10T19:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MDIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwODU1Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540508552", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-12-10T21:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MDIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MTM5OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540351399", "bodyText": "protected", "author": "steven-sheehy", "createdAt": "2020-12-10T17:18:27Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/MirrorBaseJavaMigration.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+\n+@Log4j2\n+public abstract class MirrorBaseJavaMigration extends BaseJavaMigration {\n+\n+    public abstract void doMigrate() throws Exception;", "originalCommit": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwODQ1MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540508450", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-12-10T21:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MTM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1NTA2NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540355065", "bodyText": "nit: If you just used a normal for loop you could avoid all the atomics. ForEach is useful to be concise, but due to the atomics it actually makes things more verbose in my opinion.", "author": "steven-sheehy", "createdAt": "2020-12-10T17:23:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -269,4 +321,68 @@ private void updatePreviousAddressBook(FileData fileData) {\n                     }\n                 });\n     }\n+\n+    /**\n+     * Retrieve the initial address book file for the network from either the file system or class path\n+     *\n+     * @return Address book fileData object\n+     */\n+    private FileData getInitialAddressBookFileData() {\n+        byte[] addressBookBytes;\n+\n+        // retrieve bootstrap address book from filesystem or classpath\n+        try {\n+            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+            if (initialAddressBook != null) {\n+                addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                        initialAddressBook);\n+            } else {\n+                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                Resource resource = new ClassPathResource(resourcePath, getClass());\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n+        }\n+\n+        return new FileData(0L, addressBookBytes,\n+                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n+                TransactionTypeEnum.FILECREATE.getProtoId());\n+    }\n+\n+    /**\n+     * Batch parse all 101 and 102 addressBook fileData objects and update the address_book table. Uses page size and\n+     * timestamp counters to batch query file data entries\n+     */\n+    private AddressBook parseHistoricAddressBooks() {\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+        AtomicReference<AddressBook> lastAddressBook = new AtomicReference<>();\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n+        int pageSize = 1000;\n+        List<FileData> fileDataList = fileDataRepository\n+                .findAddressBooksAfter(currentConsensusTimestamp.get(), pageSize);\n+        while (!CollectionUtils.isEmpty(fileDataList)) {\n+            log.info(\"Retrieved {} file_data rows for address book processing\", fileDataList.size());\n+            fileDataList.forEach(fileData -> {", "originalCommit": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwODIwMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540508200", "bodyText": "Changed to a normal for loop", "author": "Nana-EC", "createdAt": "2020-12-10T21:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1NTA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1NTcyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540355723", "bodyText": "Codecov says Added lines #L374 - L375 were not covered by tests. Is that true? These seem like pretty important lines to test if so.", "author": "steven-sheehy", "createdAt": "2020-12-10T17:24:27Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -269,4 +321,68 @@ private void updatePreviousAddressBook(FileData fileData) {\n                     }\n                 });\n     }\n+\n+    /**\n+     * Retrieve the initial address book file for the network from either the file system or class path\n+     *\n+     * @return Address book fileData object\n+     */\n+    private FileData getInitialAddressBookFileData() {\n+        byte[] addressBookBytes;\n+\n+        // retrieve bootstrap address book from filesystem or classpath\n+        try {\n+            Path initialAddressBook = mirrorProperties.getInitialAddressBook();\n+            if (initialAddressBook != null) {\n+                addressBookBytes = Files.readAllBytes(initialAddressBook);\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length,\n+                        initialAddressBook);\n+            } else {\n+                MirrorProperties.HederaNetwork hederaNetwork = mirrorProperties.getNetwork();\n+                String resourcePath = String.format(\"/addressbook/%s\", hederaNetwork.name().toLowerCase());\n+                Resource resource = new ClassPathResource(resourcePath, getClass());\n+                addressBookBytes = IOUtils.toByteArray(resource.getInputStream());\n+                log.info(\"Loading bootstrap address book of {} B from {}\", addressBookBytes.length, resource);\n+            }\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Unable to load bootstrap address book\", e);\n+        }\n+\n+        return new FileData(0L, addressBookBytes,\n+                AddressBookServiceImpl.ADDRESS_BOOK_102_ENTITY_ID,\n+                TransactionTypeEnum.FILECREATE.getProtoId());\n+    }\n+\n+    /**\n+     * Batch parse all 101 and 102 addressBook fileData objects and update the address_book table. Uses page size and\n+     * timestamp counters to batch query file data entries\n+     */\n+    private AddressBook parseHistoricAddressBooks() {\n+        AtomicLong fileDataEntries = new AtomicLong(0);\n+        AtomicLong currentConsensusTimestamp = new AtomicLong(0);\n+        AtomicReference<AddressBook> lastAddressBook = new AtomicReference<>();\n+\n+        // starting from consensusTimeStamp = 0 retrieve pages of fileData entries for historic address books\n+        int pageSize = 1000;\n+        List<FileData> fileDataList = fileDataRepository\n+                .findAddressBooksAfter(currentConsensusTimestamp.get(), pageSize);\n+        while (!CollectionUtils.isEmpty(fileDataList)) {\n+            log.info(\"Retrieved {} file_data rows for address book processing\", fileDataList.size());\n+            fileDataList.forEach(fileData -> {\n+                if (fileData.getFileData() != null && fileData.getFileData().length > 0) {\n+                    // convert and ingest address book fileData contents\n+                    lastAddressBook.set(parse(fileData));\n+                    fileDataEntries.incrementAndGet();", "originalCommit": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2MTQ2Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540461467", "bodyText": "I had a specific migration test(). It got removed in some refactoring.\nWill add back as it definitely covers this", "author": "Nana-EC", "createdAt": "2020-12-10T20:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1NTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1Njc1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540356758", "bodyText": "Is it possible to get coverage for this? Even if it's a test of just the base class.", "author": "steven-sheehy", "createdAt": "2020-12-10T17:25:58Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/MirrorBaseJavaMigration.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+\n+@Log4j2\n+public abstract class MirrorBaseJavaMigration extends BaseJavaMigration {\n+\n+    public abstract void doMigrate() throws Exception;\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        MigrationVersion current = getVersion();\n+        if (skipMigrationVersion(current, context.getConfiguration())) {\n+            log.trace(\"Migration {} will be skipped as it precedes baseline version {}\",\n+                    current,\n+                    context.getConfiguration().getBaselineVersion());\n+            return;\n+        }\n+\n+        doMigrate();\n+    }\n+\n+    /**\n+     * Determine whether a java migration should be skipped based on version and isIgnoreMissingMigrations setting\n+     *\n+     * @param current                The current java migration version\n+     * @param migrationConfiguration flyway Configuration\n+     * @return\n+     */\n+    private boolean skipMigrationVersion(MigrationVersion current, Configuration migrationConfiguration) {\n+        MigrationVersion baselineVersion = migrationConfiguration.getBaselineVersion();\n+        if (baselineVersion.isNewerThan(current.getVersion()) && migrationConfiguration.isIgnoreMissingMigrations()) {", "originalCommit": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwMDAyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540500029", "bodyText": "Can do", "author": "Nana-EC", "createdAt": "2020-12-10T21:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1Njc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwNzk0Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540507946", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-12-10T21:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1Njc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1ODIzOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540358239", "bodyText": "Why do we care about ignoreMissingMigrations here? Missing migrations is for files that have been deleted since they've been ran. I don't think that applies here. If you're baselining you're moving up the min version without regard for the presence of the migrations before that.", "author": "steven-sheehy", "createdAt": "2020-12-10T17:28:01Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/MirrorBaseJavaMigration.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+\n+@Log4j2\n+public abstract class MirrorBaseJavaMigration extends BaseJavaMigration {\n+\n+    public abstract void doMigrate() throws Exception;\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        MigrationVersion current = getVersion();\n+        if (skipMigrationVersion(current, context.getConfiguration())) {\n+            log.trace(\"Migration {} will be skipped as it precedes baseline version {}\",\n+                    current,\n+                    context.getConfiguration().getBaselineVersion());\n+            return;\n+        }\n+\n+        doMigrate();\n+    }\n+\n+    /**\n+     * Determine whether a java migration should be skipped based on version and isIgnoreMissingMigrations setting\n+     *\n+     * @param current                The current java migration version\n+     * @param migrationConfiguration flyway Configuration\n+     * @return\n+     */\n+    private boolean skipMigrationVersion(MigrationVersion current, Configuration migrationConfiguration) {\n+        MigrationVersion baselineVersion = migrationConfiguration.getBaselineVersion();\n+        if (baselineVersion.isNewerThan(current.getVersion()) && migrationConfiguration.isIgnoreMissingMigrations()) {", "originalCommit": "62a6a669ebdc55bb5559a8cc5eba479aa7aa8641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwMDMyNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540500325", "bodyText": "Will remove.\nAlso adding target logic as a nice to have", "author": "Nana-EC", "createdAt": "2020-12-10T21:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1ODIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwNzkwOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540507909", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-12-10T21:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1ODIzOQ=="}], "type": "inlineReview"}, {"oid": "f9965c481e72057b18cc607c97d891cbb2db30e4", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f9965c481e72057b18cc607c97d891cbb2db30e4", "message": "Added and cleaned up tests and migration logic\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-10T21:25:25Z", "type": "commit"}, {"oid": "5dc975a49211f7f0ea5a59bfc0404e7d245e332b", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/5dc975a49211f7f0ea5a59bfc0404e7d245e332b", "message": "Removed code smell from MirrorBaseJavaMigration\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-10T21:44:44Z", "type": "commit"}, {"oid": "b379797f31134382713f3a99fb5a2dcbf464795a", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/b379797f31134382713f3a99fb5a2dcbf464795a", "message": "Fixed fixable code smells\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-10T22:42:04Z", "type": "commit"}, {"oid": "07adc3c6377bb5dcfde1577b49e0423c67703838", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/07adc3c6377bb5dcfde1577b49e0423c67703838", "message": "Added SchemaMigrationException\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-10T22:43:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2MzIzNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540563235", "bodyText": "This should test migrate's invocation of skipMigrationVersion both to ensure it's correctly invoked and provide coverage to that method.", "author": "steven-sheehy", "createdAt": "2020-12-10T23:01:41Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V0_0_1__MirrorBaseJavaMigrationTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.ClassicConfiguration;\n+import org.junit.jupiter.api.Test;\n+\n+// flyway requires class name conforms with naming convention\n+class V0_0_1__MirrorBaseJavaMigrationTest extends MirrorBaseJavaMigration {\n+    @Override\n+    public void doMigrate() {\n+        // do nothing\n+    }\n+\n+    @Test\n+    void verifySkipMigrationVersionCurrentEmpty() {\n+        assertThat(skipMigrationVersion(MigrationVersion.EMPTY, getConfiguration(\"1\", \"2\"))).isTrue();", "originalCommit": "07adc3c6377bb5dcfde1577b49e0423c67703838", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYxNjM2Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540616366", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-12-11T01:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2MzIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2Mzg0Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540563846", "bodyText": "Should just be named MirrorBaseJavaMigrationTest and not extend anything. You should create a custom private nested class to do the actual testing against.", "author": "steven-sheehy", "createdAt": "2020-12-10T23:02:20Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V0_0_1__MirrorBaseJavaMigrationTest.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.flywaydb.core.api.MigrationVersion;\n+import org.flywaydb.core.api.configuration.ClassicConfiguration;\n+import org.junit.jupiter.api.Test;\n+\n+// flyway requires class name conforms with naming convention\n+class V0_0_1__MirrorBaseJavaMigrationTest extends MirrorBaseJavaMigration {", "originalCommit": "07adc3c6377bb5dcfde1577b49e0423c67703838", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYxNjMyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540616323", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-12-11T01:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2Mzg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2ODc0NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540568744", "bodyText": "You don't need to declare runtime exceptions (as Sonar also attests).", "author": "steven-sheehy", "createdAt": "2020-12-10T23:10:41Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_11_6__Missing_Entities.java", "diffHunk": "@@ -54,14 +53,14 @@\n     // break it.\n     // Correct way is to not use repositories and construct manually: new JdbcTemplate(context.getConnection())\n     public V1_11_6__Missing_Entities(MirrorProperties mirrorProperties, @Lazy EntityRepository entityRepository,\n-            @Lazy JdbcOperations jdbcOperations) {\n+                                     @Lazy JdbcOperations jdbcOperations) {\n         this.mirrorProperties = mirrorProperties;\n         this.entityRepository = entityRepository;\n         this.jdbcOperations = jdbcOperations;\n     }\n \n     @Override\n-    public void migrate(Context context) throws Exception {\n+    public void doMigrate() throws SchemaMigrationException {", "originalCommit": "07adc3c6377bb5dcfde1577b49e0423c67703838", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYxNjI3Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540616276", "bodyText": "Updated it to IOException as that's what's thrown and FileNotFoundException inherits from IOException.\nThis also requires the abstract class be updated with the throws", "author": "Nana-EC", "createdAt": "2020-12-11T01:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2ODc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MDU5MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540570590", "bodyText": "These two debugs should be info since this is ran once per lifetime.", "author": "steven-sheehy", "createdAt": "2020-12-10T23:14:46Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/addressbook/AddressBookServiceImpl.java", "diffHunk": "@@ -111,13 +132,50 @@ public boolean isAddressBook(EntityId entityId) {\n         return ADDRESS_BOOK_101_ENTITY_ID.equals(entityId) || ADDRESS_BOOK_102_ENTITY_ID.equals(entityId);\n     }\n \n+    /**\n+     * Migrates address book data by searching file_data table for applicable 101 and 102 files. These files are\n+     * converted to AddressBook objects and used to populate address_book and address_book_entry tables\n+     *\n+     * @return Latest AddressBook from historical files\n+     */\n+    private synchronized AddressBook migrate() {\n+        Instant now = Instant.now();\n+        long consensusTimestamp = Utility.convertToNanosMax(now.getEpochSecond(), now.getNano());\n+        AddressBook currentAddressBook = addressBookRepository\n+                .findLatestAddressBook(consensusTimestamp, ADDRESS_BOOK_102_ENTITY_ID.getId())\n+                .orElse(null);\n+\n+        if (currentAddressBook != null) {\n+            if (log.isTraceEnabled()) {\n+                log.trace(\"Valid address books exist in db, skipping migration\");\n+            }\n+            return currentAddressBook;\n+        }\n+\n+        log.debug(\"No address book found in db, proceeding with migration\");", "originalCommit": "07adc3c6377bb5dcfde1577b49e0423c67703838", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYxNjI2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1340#discussion_r540616264", "bodyText": "Made info", "author": "Nana-EC", "createdAt": "2020-12-11T01:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU3MDU5MA=="}], "type": "inlineReview"}, {"oid": "f67c7b7e589287179e9fa162ee151b2b19219fda", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f67c7b7e589287179e9fa162ee151b2b19219fda", "message": "Improved MirrorBaseJavaMigrationTest coverage\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-11T01:07:25Z", "type": "commit"}, {"oid": "570ca3d8677a020d91db156de89cb29ade5517cd", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/570ca3d8677a020d91db156de89cb29ade5517cd", "message": "Added migration caused by update call\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-12-11T01:33:48Z", "type": "commit"}]}