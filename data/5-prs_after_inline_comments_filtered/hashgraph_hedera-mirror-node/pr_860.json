{"pr_number": 860, "pr_title": "Add a NotifyingTopicListener", "pr_createdAt": "2020-07-10T17:09:05Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/860", "timeline": [{"oid": "9d35f8459215b060fe10d10492fb35d55a8f3563", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9d35f8459215b060fe10d10492fb35d55a8f3563", "message": "Add a NotifyingTopicListener\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-07-10T15:55:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3NzEwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452977105", "bodyText": "If this logic is shared by all the Listeners should we move it to the CompositeTopicListener()?\nThen the CompositeTopicListener.listen() could call the filter method.", "author": "Nana-EC", "createdAt": "2020-07-10T17:28:28Z", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {", "originalCommit": "9d35f8459215b060fe10d10492fb35d55a8f3563", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAyMDEzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r453020138", "bodyText": "I did have that change, but then some listeners don't need it filtered like PollingTopicListener and wanted to keep this PR tightly focused on notify.", "author": "steven-sheehy", "createdAt": "2020-07-10T18:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk3NzEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk4MDk4Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452980986", "bodyText": "Similar to Shared poller maybe we should have a log for total messages and rate\n\"Finished listen with {} messages in {} ({}/s)\"", "author": "Nana-EC", "createdAt": "2020-07-10T17:36:40Z", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {\n+        return message.getRealmNum() == filter.getRealmNum() &&\n+                message.getTopicNum() == filter.getTopicNum() &&\n+                message.getConsensusTimestamp() >= filter.getStartTimeLong();\n+    }\n+\n+    private Flux<String> listen() {\n+        EmitterProcessor<String> emitterProcessor = EmitterProcessor.create();\n+        channel.handler(json -> emitterProcessor.onNext(json));\n+        log.info(\"Listening for messages\");\n+        return emitterProcessor;\n+    }\n+\n+    private void unlisten() {\n+        channel.handler(null);\n+        log.info(\"Stopped listening for messages\");", "originalCommit": "9d35f8459215b060fe10d10492fb35d55a8f3563", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAxNDM4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r453014380", "bodyText": "But shared poller is polling so it is showing that log for that poll period that is common to all subscribers. Notify poller is an asynchronous, streaming publisher so there's no gap in messages at which to record messages. We could potentially keep track per subscriber what the rate is but we have similar info in the service layer. But maybe if we find that latter log useful we can add it at CompositeTopicListener at a later point in time.", "author": "steven-sheehy", "createdAt": "2020-07-10T18:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk4MDk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk5MDAwNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r452990004", "bodyText": "If there's a way to pull the notify time from this handler as part of it's in-built API that would be useful for metrics.\nIf not then consider my other suggestion to explore adding the approximate insert time to the notify operation.", "author": "Nana-EC", "createdAt": "2020-07-10T17:55:34Z", "path": "hedera-mirror-grpc/src/main/java/com/hedera/mirror/grpc/listener/NotifyingTopicListener.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.hedera.mirror.grpc.listener;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import io.vertx.core.Vertx;\n+import io.vertx.pgclient.PgConnectOptions;\n+import io.vertx.pgclient.pubsub.PgChannel;\n+import io.vertx.pgclient.pubsub.PgSubscriber;\n+import java.time.Duration;\n+import javax.inject.Named;\n+import lombok.extern.log4j.Log4j2;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.util.retry.Retry;\n+\n+import com.hedera.mirror.grpc.DbProperties;\n+import com.hedera.mirror.grpc.domain.TopicMessage;\n+import com.hedera.mirror.grpc.domain.TopicMessageFilter;\n+\n+@Named\n+@Log4j2\n+public class NotifyingTopicListener implements TopicListener {\n+\n+    private final ObjectMapper objectMapper;\n+    private final Flux<TopicMessage> topicMessages;\n+    private final PgChannel channel;\n+\n+    public NotifyingTopicListener(DbProperties dbProperties, ListenerProperties listenerProperties) {\n+        this.objectMapper = new ObjectMapper().setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n+        PgConnectOptions connectOptions = new PgConnectOptions()\n+                .setDatabase(dbProperties.getName())\n+                .setHost(dbProperties.getHost())\n+                .setPassword(dbProperties.getPassword())\n+                .setPort(dbProperties.getPort())\n+                .setUser(dbProperties.getUsername());\n+\n+        Duration frequency = listenerProperties.getFrequency();\n+        Vertx vertx = Vertx.vertx();\n+        PgSubscriber subscriber = PgSubscriber.subscriber(vertx, connectOptions)\n+                .reconnectPolicy(retries -> {\n+                    log.warn(\"Attempting reconnect\");\n+                    return frequency.toMillis();\n+                });\n+\n+        // Connect asynchronously to avoid crashing the application on startup if the database is down\n+        vertx.setTimer(100L, v -> subscriber.connect(connectResult -> {\n+            if (connectResult.failed()) {\n+                throw new RuntimeException(connectResult.cause());\n+            }\n+            log.info(\"Connected to database\");\n+        }));\n+\n+        channel = subscriber.channel(\"topic_message\");\n+\n+        topicMessages = Flux.defer(() -> listen())\n+                .publishOn(Schedulers.boundedElastic())\n+                .map(this::toTopicMessage)\n+                .name(\"notify\")\n+                .metrics()\n+                .doFinally(s -> unlisten())\n+                .doOnError(t -> log.error(\"Error listening for messages\", t))\n+                .retryWhen(Retry.backoff(Long.MAX_VALUE, frequency).maxBackoff(frequency.multipliedBy(4L)))\n+                .share();\n+    }\n+\n+    @Override\n+    public Flux<TopicMessage> listen(TopicMessageFilter filter) {\n+        return topicMessages.filter(t -> filterMessage(t, filter))\n+                .doOnSubscribe(s -> log.info(\"Subscribing: {}\", filter));\n+    }\n+\n+    private boolean filterMessage(TopicMessage message, TopicMessageFilter filter) {\n+        return message.getRealmNum() == filter.getRealmNum() &&\n+                message.getTopicNum() == filter.getTopicNum() &&\n+                message.getConsensusTimestamp() >= filter.getStartTimeLong();\n+    }\n+\n+    private Flux<String> listen() {\n+        EmitterProcessor<String> emitterProcessor = EmitterProcessor.create();\n+        channel.handler(json -> emitterProcessor.onNext(json));", "originalCommit": "9d35f8459215b060fe10d10492fb35d55a8f3563", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzAxMjUyOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/860#discussion_r453012528", "bodyText": "We already have a metric for notify time in CompositeTopicListener called hedera.mirror.publish.latency. That's why I had you add it there so it's reusable.", "author": "steven-sheehy", "createdAt": "2020-07-10T18:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk5MDAwNA=="}], "type": "inlineReview"}, {"oid": "482eee54c0478d40c58e78dbd37c74d672d32ff2", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/482eee54c0478d40c58e78dbd37c74d672d32ff2", "message": "Fix chunk info not in notifications\n\nSigned-off-by: Steven Sheehy <steven.sheehy@hedera.com>", "committedDate": "2020-07-10T17:58:53Z", "type": "commit"}]}