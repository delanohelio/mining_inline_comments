{"pr_number": 639, "pr_title": "Add TransactionBody to RecordItem", "pr_createdAt": "2020-04-01T01:55:45Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/639", "timeline": [{"oid": "6356420542b2fcf1a510bee36b1cec3891ca726e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6356420542b2fcf1a510bee36b1cec3891ca726e", "message": "Add TransactionBody to RecordItem\n\n- Functionality in all TransactionHandlers (to be added in followups) require TransactionBody.\n  Transaction.bodyBytes needs to be deserialized only once and stored somewhere accessible to\n  TransactionHandlers. Transaction.body field is not good candidate since it is deprecated.\n  RecordItem is the best place to keep it.\n- RecordItem has uniform ctor pattern now. Can be constructed from either:\n  - transaction & record proto instances\n  - transaction & record bytes\n- Deserialization is done in RecordItem constructor because:\n  - Passing both Transaction (which has body) and TransactionBody to ctor\n    (two sources of truth) would be bad\n  - Don't have to change 50+ places in tests\n- Side benefit: Removed duplicate deserialization that was happening in RecordFileParser.\n\nSide benefit: Removed duplicate deserialization that was happening in RecordFileParser.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-01T01:57:49Z", "type": "forcePushed"}, {"oid": "fb8bfc562cc9ced4d12ce4067bd29343d8d3b18c", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fb8bfc562cc9ced4d12ce4067bd29343d8d3b18c", "message": "Add TransactionBody to RecordItem\n\n- Functionality in all TransactionHandlers (to be added in followups) require TransactionBody.\n  Transaction.bodyBytes needs to be deserialized only once and stored somewhere accessible to\n  TransactionHandlers. Transaction.body field is not good candidate since it is deprecated.\n  RecordItem is the best place to keep it.\n- RecordItem has uniform ctor pattern now. Can be constructed from either:\n  - transaction & record proto instances\n  - transaction & record bytes\n- Deserialization is done in RecordItem constructor because:\n  - Passing both Transaction (which has body) and TransactionBody to ctor\n    (two sources of truth) would be bad\n  - Don't have to change 50+ places in tests\n- Side benefit: Removed duplicate deserialization that was happening in RecordFileParser.\n\nSide benefit: Removed duplicate deserialization that was happening in RecordFileParser.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-01T02:02:33Z", "type": "forcePushed"}, {"oid": "b7b56bc860c77ea2a507c9965dd0a6c86e995520", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/b7b56bc860c77ea2a507c9965dd0a6c86e995520", "message": "Add TransactionBody to RecordItem\n\n- Functionality in all TransactionHandlers (to be added in followups) require TransactionBody.\n  Transaction.bodyBytes needs to be deserialized only once and stored somewhere accessible to\n  TransactionHandlers. Transaction.body field is not good candidate since it is deprecated.\n  RecordItem is the best place to keep it.\n- RecordItem has uniform ctor pattern now. Can be constructed from either:\n  - transaction & record proto instances\n  - transaction & record bytes\n- Deserialization is done in RecordItem constructor because:\n  - Passing both Transaction (which has body) and TransactionBody to ctor\n    (two sources of truth) would be bad\n  - Don't have to change 50+ places in tests\n- Side benefit: Removed duplicate deserialization that was happening in RecordFileParser.\n\nSide benefit: Removed duplicate deserialization that was happening in RecordFileParser.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-01T02:19:35Z", "type": "commit"}, {"oid": "b7b56bc860c77ea2a507c9965dd0a6c86e995520", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/b7b56bc860c77ea2a507c9965dd0a6c86e995520", "message": "Add TransactionBody to RecordItem\n\n- Functionality in all TransactionHandlers (to be added in followups) require TransactionBody.\n  Transaction.bodyBytes needs to be deserialized only once and stored somewhere accessible to\n  TransactionHandlers. Transaction.body field is not good candidate since it is deprecated.\n  RecordItem is the best place to keep it.\n- RecordItem has uniform ctor pattern now. Can be constructed from either:\n  - transaction & record proto instances\n  - transaction & record bytes\n- Deserialization is done in RecordItem constructor because:\n  - Passing both Transaction (which has body) and TransactionBody to ctor\n    (two sources of truth) would be bad\n  - Don't have to change 50+ places in tests\n- Side benefit: Removed duplicate deserialization that was happening in RecordFileParser.\n\nSide benefit: Removed duplicate deserialization that was happening in RecordFileParser.\n\nSigned-off-by: Apekshit Sharma <apekshit.sharma@hedera.com>", "committedDate": "2020-04-01T02:19:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc1MjQ3NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/639#discussion_r401752474", "bodyText": "Nit: Use assert4j chaining. You also don't need helper testException method with this approach, imo:\nassertThatThrownBy(() -> { throw new IllegalArgumentException(\"boom!\"); })\n                     .isInstanceOf(IllegalArgumentException.class)\n                     .hasMessageContaining(\"boom\");", "author": "steven-sheehy", "createdAt": "2020-04-01T16:35:40Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/domain/RecordItemTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.hedera.mirror.importer.parser.domain;\n+\n+/*\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.protobuf.ByteString;\n+\n+import com.hedera.mirror.importer.exception.ParserException;\n+import com.hedera.mirror.importer.parser.record.transactionhandler.AbstractTransactionHandlerTest;\n+\n+import com.hederahashgraph.api.proto.java.SignatureMap;\n+import com.hederahashgraph.api.proto.java.SignaturePair;\n+import com.hederahashgraph.api.proto.java.Transaction;\n+import com.hederahashgraph.api.proto.java.TransactionBody;\n+import com.hederahashgraph.api.proto.java.TransactionReceipt;\n+import com.hederahashgraph.api.proto.java.TransactionRecord;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class RecordItemTest extends AbstractTransactionHandlerTest {\n+\n+    private static final Transaction DEFAULT_TRANSACTION = Transaction.newBuilder()\n+            .setBodyBytes(TransactionBody.getDefaultInstance().toByteString())\n+            .build();\n+    private static final byte[] DEFAULT_TRANSACTION_BYTES = DEFAULT_TRANSACTION.toByteArray();\n+    private static final TransactionRecord DEFAULT_RECORD = TransactionRecord.getDefaultInstance();\n+    private static final byte[] DEFAULT_RECORD_BYTES = DEFAULT_RECORD.toByteArray();\n+\n+    // 'body' and 'bodyBytes' feilds left empty\n+    private static final Transaction TRANSACTION = Transaction.newBuilder()\n+            .setSigMap(SignatureMap.newBuilder()\n+                    .addSigPair(SignaturePair.newBuilder()\n+                            .setEd25519(ByteString.copyFromUtf8(\"ed25519\"))\n+                            .setPubKeyPrefix(ByteString.copyFromUtf8(\"pubKeyPrefix\"))\n+                            .build())\n+                    .build())\n+            .build();\n+\n+    private static final TransactionBody TRANSACTION_BODY = TransactionBody.newBuilder()\n+            .setTransactionFee(10L)\n+            .setMemo(\"memo\")\n+            .build();\n+\n+    private static final TransactionRecord TRANSACTION_RECORD = TransactionRecord.newBuilder()\n+            .setReceipt(TransactionReceipt.newBuilder().setStatusValue(22).build())\n+            .setMemo(\"memo\")\n+            .build();\n+\n+    @Test\n+    public void testBadTransactionBytesThrowException() {\n+        testException(new byte[] {0x0, 0x1}, DEFAULT_RECORD_BYTES, RecordItem.BAD_TRANSACTION_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testBadRecordBytesThrowException() {\n+        testException(DEFAULT_TRANSACTION_BYTES, new byte[] {0x0, 0x1}, RecordItem.BAD_RECORD_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testTransactionBytesWithoutTransactionBodyThrowException() {\n+        testException(Transaction.newBuilder().build().toByteArray(),\n+                DEFAULT_RECORD_BYTES, RecordItem.BAD_TRANSACTION_BODY_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testWithBody() {\n+        Transaction transaction = TRANSACTION.toBuilder().setBody(TRANSACTION_BODY).build();\n+        RecordItem recordItem = new RecordItem(transaction.toByteArray(), TRANSACTION_RECORD.toByteArray());\n+        assertRecordItem(transaction, recordItem);\n+    }\n+\n+    @Test\n+    public void testWithBodyBytes() {\n+        Transaction transaction = TRANSACTION.toBuilder().setBodyBytes(TRANSACTION_BODY.toByteString()).build();\n+        RecordItem recordItem = new RecordItem(transaction.toByteArray(), TRANSACTION_RECORD.toByteArray());\n+        assertRecordItem(transaction, recordItem);\n+    }\n+\n+    private void testException(byte[] transactionBytes, byte[] recordBytes, String expectedMessage) {\n+        Exception exception = assertThrows(ParserException.class, () -> {", "originalCommit": "b7b56bc860c77ea2a507c9965dd0a6c86e995520", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc1Mjk1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/639#discussion_r401752958", "bodyText": "nit: Recommend always using assert4j assertThat() for cleaner approach, consistency with other code and ability to chain", "author": "steven-sheehy", "createdAt": "2020-04-01T16:36:22Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/domain/RecordItemTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.hedera.mirror.importer.parser.domain;\n+\n+/*\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.protobuf.ByteString;\n+\n+import com.hedera.mirror.importer.exception.ParserException;\n+import com.hedera.mirror.importer.parser.record.transactionhandler.AbstractTransactionHandlerTest;\n+\n+import com.hederahashgraph.api.proto.java.SignatureMap;\n+import com.hederahashgraph.api.proto.java.SignaturePair;\n+import com.hederahashgraph.api.proto.java.Transaction;\n+import com.hederahashgraph.api.proto.java.TransactionBody;\n+import com.hederahashgraph.api.proto.java.TransactionReceipt;\n+import com.hederahashgraph.api.proto.java.TransactionRecord;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class RecordItemTest extends AbstractTransactionHandlerTest {\n+\n+    private static final Transaction DEFAULT_TRANSACTION = Transaction.newBuilder()\n+            .setBodyBytes(TransactionBody.getDefaultInstance().toByteString())\n+            .build();\n+    private static final byte[] DEFAULT_TRANSACTION_BYTES = DEFAULT_TRANSACTION.toByteArray();\n+    private static final TransactionRecord DEFAULT_RECORD = TransactionRecord.getDefaultInstance();\n+    private static final byte[] DEFAULT_RECORD_BYTES = DEFAULT_RECORD.toByteArray();\n+\n+    // 'body' and 'bodyBytes' feilds left empty\n+    private static final Transaction TRANSACTION = Transaction.newBuilder()\n+            .setSigMap(SignatureMap.newBuilder()\n+                    .addSigPair(SignaturePair.newBuilder()\n+                            .setEd25519(ByteString.copyFromUtf8(\"ed25519\"))\n+                            .setPubKeyPrefix(ByteString.copyFromUtf8(\"pubKeyPrefix\"))\n+                            .build())\n+                    .build())\n+            .build();\n+\n+    private static final TransactionBody TRANSACTION_BODY = TransactionBody.newBuilder()\n+            .setTransactionFee(10L)\n+            .setMemo(\"memo\")\n+            .build();\n+\n+    private static final TransactionRecord TRANSACTION_RECORD = TransactionRecord.newBuilder()\n+            .setReceipt(TransactionReceipt.newBuilder().setStatusValue(22).build())\n+            .setMemo(\"memo\")\n+            .build();\n+\n+    @Test\n+    public void testBadTransactionBytesThrowException() {\n+        testException(new byte[] {0x0, 0x1}, DEFAULT_RECORD_BYTES, RecordItem.BAD_TRANSACTION_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testBadRecordBytesThrowException() {\n+        testException(DEFAULT_TRANSACTION_BYTES, new byte[] {0x0, 0x1}, RecordItem.BAD_RECORD_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testTransactionBytesWithoutTransactionBodyThrowException() {\n+        testException(Transaction.newBuilder().build().toByteArray(),\n+                DEFAULT_RECORD_BYTES, RecordItem.BAD_TRANSACTION_BODY_BYTES_MESSAGE);\n+    }\n+\n+    @Test\n+    public void testWithBody() {\n+        Transaction transaction = TRANSACTION.toBuilder().setBody(TRANSACTION_BODY).build();\n+        RecordItem recordItem = new RecordItem(transaction.toByteArray(), TRANSACTION_RECORD.toByteArray());\n+        assertRecordItem(transaction, recordItem);\n+    }\n+\n+    @Test\n+    public void testWithBodyBytes() {\n+        Transaction transaction = TRANSACTION.toBuilder().setBodyBytes(TRANSACTION_BODY.toByteString()).build();\n+        RecordItem recordItem = new RecordItem(transaction.toByteArray(), TRANSACTION_RECORD.toByteArray());\n+        assertRecordItem(transaction, recordItem);\n+    }\n+\n+    private void testException(byte[] transactionBytes, byte[] recordBytes, String expectedMessage) {\n+        Exception exception = assertThrows(ParserException.class, () -> {\n+            new RecordItem(transactionBytes, recordBytes);\n+        });\n+        assertEquals(expectedMessage, exception.getMessage());\n+    }\n+\n+    private void assertRecordItem(Transaction transaction, RecordItem recordItem) {\n+        assertEquals(transaction, recordItem.getTransaction());", "originalCommit": "b7b56bc860c77ea2a507c9965dd0a6c86e995520", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}