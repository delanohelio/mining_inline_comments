{"pr_number": 1089, "pr_title": "HTS: Add support for token transactions to Importer", "pr_createdAt": "2020-09-30T00:02:20Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4OTcyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497789723", "bodyText": "Removing this so as not to conflict w Ian's PR", "author": "Nana-EC", "createdAt": "2020-09-30T20:46:05Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenBalance.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.annotation.JsonUnwrapped;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import java.io.Serializable;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import org.springframework.data.domain.Persistable;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@AllArgsConstructor\n+@NoArgsConstructor\n+@Entity\n+\n+public class TokenBalance implements Persistable<TokenBalance.Id> {", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5MTQ4MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497791480", "bodyText": "Add a tokenUpdate tests in EntityRecordItemListenerTokenTest.java", "author": "Nana-EC", "createdAt": "2020-09-30T20:49:21Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -166,6 +190,32 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n                         txRecord.getReceipt().getFileID(), transactionType);\n             } else if (body.hasFileUpdate()) {\n                 insertFileUpdate(consensusNs, body.getFileUpdate(), transactionType);\n+            } else if (body.hasTokenAssociate()) {\n+                insertTokenAssociate(consensusNs, body);\n+            } else if (body.hasTokenBurn()) {\n+                insertTokenBurn(consensusNs, body);\n+            } else if (body.hasTokenCreation()) {\n+                insertTokenCreate(consensusNs, txRecord, body);\n+            } else if (body.hasTokenDeletion()) {\n+                insertTokenDelete(consensusNs, body);\n+            } else if (body.hasTokenDissociate()) {\n+                insertTokenDissociate(consensusNs, body);\n+            } else if (body.hasTokenFreeze()) {\n+                insertTokenAccountFreezeBody(consensusNs, body);\n+            } else if (body.hasTokenGrantKyc()) {\n+                insertTokenAccountGrantKyc(consensusNs, body);\n+            } else if (body.hasTokenMint()) {\n+                insertTokenMint(consensusNs, body);\n+            } else if (body.hasTokenRevokeKyc()) {\n+                insertTokenAccountRevokeKyc(consensusNs, body);\n+            } else if (body.hasTokenTransfers()) {\n+                insertTokenTransfers(consensusNs, txRecord);\n+            } else if (body.hasTokenUnfreeze()) {\n+                insertTokenAccountUnfreeze(consensusNs, body);\n+            } else if (body.hasTokenUpdate()) {\n+                insertTokenUpdate(consensusNs, body);", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgwNzI0NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497807244", "bodyText": "remove and use enum. Here and below", "author": "Nana-EC", "createdAt": "2020-09-30T21:20:13Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +430,262 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxMzA4OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497813088", "bodyText": "remove tokens and tokenAccounts lists for now as we save immediately", "author": "Nana-EC", "createdAt": "2020-09-30T21:32:29Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java", "diffHunk": "@@ -124,6 +139,9 @@ public SqlEntityListener(SqlProperties sqlProperties, DataSource dataSource,\n         liveHashes = new ArrayList<>();\n         entityIds = new HashSet<>();\n         topicMessages = new ArrayList<>();\n+        tokens = new ArrayList<>();", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNDU1NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497814554", "bodyText": "Add conditional check and add expiry set", "author": "Nana-EC", "createdAt": "2020-09-30T21:35:47Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod());", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNTMwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497815305", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (txMessage.getExpiry() != 0) {\n          \n          \n            \n                    if (txMessage.getAutoRenewPeriod() != 0) {", "author": "Nana-EC", "createdAt": "2020-09-30T21:37:29Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenUpdateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenUpdateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenUpdate().getToken());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenUpdateTransactionBody txMessage = recordItem.getTransactionBody().getTokenUpdate();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        if (txMessage.getExpiry() != 0) {", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgxNTUyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r497815523", "bodyText": "Delete to not conflict with Ian", "author": "Nana-EC", "createdAt": "2020-09-30T21:38:00Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/repository/TokenBalanceRepository.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.hedera.mirror.importer.repository;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import org.springframework.data.repository.CrudRepository;\n+\n+import com.hedera.mirror.importer.domain.TokenBalance;\n+\n+public interface TokenBalanceRepository extends CrudRepository<TokenBalance, TokenBalance.Id> {", "originalCommit": "cebbfc8b815fdf4ca4df8ea34334fb75f2113434", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3NDcwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498374705", "bodyText": "Should exclude the hex form as well as it will be quite large. Might be simpler to put the @ToString.Exclude annotation on the fields with this many.", "author": "steven-sheehy", "createdAt": "2020-10-01T16:31:36Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDMyNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094326", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3NDcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5MzYxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498393614", "bodyText": "Since both clients that use this catch and return null, let's just change the Utility implementation to do so. Then you can use utility directly and don't need wrapper convertByteKeyToHex", "author": "steven-sheehy", "createdAt": "2020-10-01T17:05:40Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")\n+    private String wipeKeyEd25519Hex;\n+\n+    public void setInitialSupply(Long initialSupply) {\n+        this.initialSupply = initialSupply;\n+\n+        // default totalSupply to initial supply\n+        totalSupply = initialSupply;\n+    }\n+\n+    public void setFreezeKey(byte[] key) {\n+        freezeKey = key;\n+        freezeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setKycKey(byte[] key) {\n+        kycKey = key;\n+        kycKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setSupplyKey(byte[] key) {\n+        supplyKey = key;\n+        supplyKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setWipeKey(byte[] key) {\n+        wipeKey = key;\n+        wipeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+    // If the token does not have Freeze key, FreezeNotApplicable is returned, if not take value of freezeDefault\n+\n+    /**\n+     * Get initial freeze status for an account being associated with this token. If the token does not have a\n+     * freezeKey, FreezeNotApplicable is returned, if it does account frozen status is set based on freezeDefault.\n+     * FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+     *\n+     * @return Freeze status code\n+     */\n+    public int getNewAccountFreezeStatus() {\n+        if (freezeKey == null) {\n+            return TokenFreezeStatus.FreezeNotApplicable_VALUE;\n+        }\n+\n+        return freezeDefault ? TokenFreezeStatus.Frozen_VALUE : TokenFreezeStatus.Unfrozen_VALUE;\n+    }\n+\n+    /**\n+     * Get initial kyc status for an account being associated with this token. If the token does not have a kycKey,\n+     * KycNotApplicable is returned, if it does account should be set to Revoked as kyc must be performed.\n+     * KycNotApplicable = 0, Granted = 1, Revoked = 2\n+     *\n+     * @return Kyc status code\n+     */\n+    public int getNewAccountKycStatus() {\n+        if (kycKey == null) {\n+            return TokenKycStatus.KycNotApplicable_VALUE;\n+        }\n+\n+        return TokenKycStatus.Revoked_VALUE;\n+    }\n+\n+    private String convertByteKeyToHex(byte[] key) {\n+        try {\n+            return Utility.protobufKeyToHexIfEd25519OrNull(key);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDMzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094338", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5MzYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDI4OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498394289", "bodyText": "We don't need an embedded id if it's not a composite key. Just use EntityId directly.", "author": "steven-sheehy", "createdAt": "2020-10-01T17:07:06Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")\n+    private String wipeKeyEd25519Hex;\n+\n+    public void setInitialSupply(Long initialSupply) {\n+        this.initialSupply = initialSupply;\n+\n+        // default totalSupply to initial supply\n+        totalSupply = initialSupply;\n+    }\n+\n+    public void setFreezeKey(byte[] key) {\n+        freezeKey = key;\n+        freezeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setKycKey(byte[] key) {\n+        kycKey = key;\n+        kycKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setSupplyKey(byte[] key) {\n+        supplyKey = key;\n+        supplyKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setWipeKey(byte[] key) {\n+        wipeKey = key;\n+        wipeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+    // If the token does not have Freeze key, FreezeNotApplicable is returned, if not take value of freezeDefault\n+\n+    /**\n+     * Get initial freeze status for an account being associated with this token. If the token does not have a\n+     * freezeKey, FreezeNotApplicable is returned, if it does account frozen status is set based on freezeDefault.\n+     * FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+     *\n+     * @return Freeze status code\n+     */\n+    public int getNewAccountFreezeStatus() {\n+        if (freezeKey == null) {\n+            return TokenFreezeStatus.FreezeNotApplicable_VALUE;\n+        }\n+\n+        return freezeDefault ? TokenFreezeStatus.Frozen_VALUE : TokenFreezeStatus.Unfrozen_VALUE;\n+    }\n+\n+    /**\n+     * Get initial kyc status for an account being associated with this token. If the token does not have a kycKey,\n+     * KycNotApplicable is returned, if it does account should be set to Revoked as kyc must be performed.\n+     * KycNotApplicable = 0, Granted = 1, Revoked = 2\n+     *\n+     * @return Kyc status code\n+     */\n+    public int getNewAccountKycStatus() {\n+        if (kycKey == null) {\n+            return TokenKycStatus.KycNotApplicable_VALUE;\n+        }\n+\n+        return TokenKycStatus.Revoked_VALUE;\n+    }\n+\n+    private String convertByteKeyToHex(byte[] key) {\n+        try {\n+            return Utility.protobufKeyToHexIfEd25519OrNull(key);\n+        } catch (Exception e) {\n+            log.error(\"Invalid ED25519 key could not be translated to hex text for entity {}. Field \" +\n+                    \"will be nulled\", tokenId, e);\n+            return null;\n+        }\n+    }\n+\n+    @Data\n+    @Embeddable\n+    @AllArgsConstructor\n+    @NoArgsConstructor\n+    public static class Id implements Serializable {\n+\n+        private static final long serialVersionUID = -4595724698253758379L;\n+\n+        @Convert(converter = TokenIdConverter.class)\n+        @JsonSerialize(using = EntityIdSerializer.class)\n+        private EntityId tokenId;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5NjgwOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498996808", "bodyText": "Left over logic, meant to change", "author": "Nana-EC", "createdAt": "2020-10-02T18:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDM2Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094362", "bodyText": "Remembered now, hit the issue last week where the Converter wasn't getting honored for @id.\nLeaving as is as discussed offline since as you noted it's not possible with JPA spec - eclipse-ee4j/jpa-api#207", "author": "Nana-EC", "createdAt": "2020-10-03T00:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NDI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NTE1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498395153", "bodyText": "We shouldn't import protobuf classes into domain classes. We should create our own enum for kyc status and  freeze status and make the domain classes use those.", "author": "steven-sheehy", "createdAt": "2020-10-01T17:08:42Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")\n+    private String wipeKeyEd25519Hex;\n+\n+    public void setInitialSupply(Long initialSupply) {\n+        this.initialSupply = initialSupply;\n+\n+        // default totalSupply to initial supply\n+        totalSupply = initialSupply;\n+    }\n+\n+    public void setFreezeKey(byte[] key) {\n+        freezeKey = key;\n+        freezeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setKycKey(byte[] key) {\n+        kycKey = key;\n+        kycKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setSupplyKey(byte[] key) {\n+        supplyKey = key;\n+        supplyKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    public void setWipeKey(byte[] key) {\n+        wipeKey = key;\n+        wipeKeyEd25519Hex = convertByteKeyToHex(key);\n+    }\n+\n+    // FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+    // If the token does not have Freeze key, FreezeNotApplicable is returned, if not take value of freezeDefault\n+\n+    /**\n+     * Get initial freeze status for an account being associated with this token. If the token does not have a\n+     * freezeKey, FreezeNotApplicable is returned, if it does account frozen status is set based on freezeDefault.\n+     * FreezeNotApplicable = 0, Frozen = 1, Unfrozen = 2\n+     *\n+     * @return Freeze status code\n+     */\n+    public int getNewAccountFreezeStatus() {\n+        if (freezeKey == null) {\n+            return TokenFreezeStatus.FreezeNotApplicable_VALUE;\n+        }\n+\n+        return freezeDefault ? TokenFreezeStatus.Frozen_VALUE : TokenFreezeStatus.Unfrozen_VALUE;\n+    }\n+\n+    /**\n+     * Get initial kyc status for an account being associated with this token. If the token does not have a kycKey,\n+     * KycNotApplicable is returned, if it does account should be set to Revoked as kyc must be performed.\n+     * KycNotApplicable = 0, Granted = 1, Revoked = 2\n+     *\n+     * @return Kyc status code\n+     */\n+    public int getNewAccountKycStatus() {", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDQwMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094401", "bodyText": "Done. Created our own TokenFreezeStatusEnum and TokenKycStatusEnum", "author": "Nana-EC", "createdAt": "2020-10-03T00:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5NTE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTIyMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498421222", "bodyText": "We should use primitives for non-null numbers like initialSupply and totalSupply.", "author": "steven-sheehy", "createdAt": "2020-10-01T17:56:17Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDQxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094419", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTM1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498421353", "bodyText": "Would prefer fields sorted by name.", "author": "steven-sheehy", "createdAt": "2020-10-01T17:56:30Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDQzNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094437", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTgxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498421814", "bodyText": "This is a bigint in the schema. Should the schema be changed or this changed to long?", "author": "steven-sheehy", "createdAt": "2020-10-01T17:57:22Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MzUzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498953538", "bodyText": "This should be a long, schema is right", "author": "Nana-EC", "createdAt": "2020-10-02T17:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDQ1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094458", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMjU2MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498422561", "bodyText": "Should we rename as wipe_key_ed_25519_hex so we don't have to manually map?", "author": "steven-sheehy", "createdAt": "2020-10-01T17:58:46Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/Token.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.hederahashgraph.api.proto.java.TokenFreezeStatus;\n+import com.hederahashgraph.api.proto.java.TokenKycStatus;\n+import java.io.Serializable;\n+import javax.persistence.Column;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.ToString;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+@ToString(exclude = {\"freezeKey\", \"kycKey\", \"supplyKey\", \"wipeKey\"})\n+public class Token {\n+    @EmbeddedId\n+    private Token.Id tokenId;\n+\n+    private long createdTimestamp;\n+\n+    private int decimals;\n+\n+    private boolean freezeDefault;\n+\n+    private byte[] freezeKey;\n+\n+    private Long initialSupply;\n+\n+    private Long totalSupply; // Increment with initialSupply and mint amounts, decrement with burn amount\n+\n+    private byte[] kycKey;\n+\n+    private long modifiedTimestamp;\n+\n+    private String name;\n+\n+    private byte[] supplyKey;\n+\n+    private String symbol;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId treasuryAccountId;\n+\n+    private byte[] wipeKey;\n+\n+    @Column(name = \"freeze_key_ed25519_hex\")\n+    private String freezeKeyEd25519Hex;\n+\n+    @Column(name = \"kyc_key_ed25519_hex\")\n+    private String kycKeyEd25519Hex;\n+\n+    @Column(name = \"supply_key_ed25519_hex\")\n+    private String supplyKeyEd25519Hex;\n+\n+    @Column(name = \"wipe_key_ed25519_hex\")", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1Mzg4OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498953889", "bodyText": "Yes, that would be cleaner", "author": "Nana-EC", "createdAt": "2020-10-02T17:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMjU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5Mjg4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498992883", "bodyText": "wipe_key_ed_25519_hex would actually still require a mapping as hibernate translates wipeKeyEd25519Hex to wipe_key_ed25519hex.\nIf we want to avoid manual mapping we either set the schema to wipe_key_ed25519hex or rename the member to be wipeKeyHexEd25519 and schema to be wipe_key_hex_ed25519", "author": "Nana-EC", "createdAt": "2020-10-02T18:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQyMjU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTYxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498531619", "bodyText": "Should use enums for status", "author": "steven-sheehy", "createdAt": "2020-10-01T21:52:34Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@Entity\n+@Log4j2\n+public class TokenAccount {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;\n+\n+    @Convert(converter = AccountIdConverter.class)\n+    private EntityId accountId;\n+\n+    private boolean associated;\n+\n+    private long createdTimestamp;\n+\n+    private int freezeStatus;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDUxNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094516", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzODU3Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498538576", "bodyText": "We should avoid doing conditional logic based upon nulls. Would prefer taking advantage of the optional returned by the repo and chaining to ifPresent().", "author": "steven-sheehy", "createdAt": "2020-10-01T22:14:02Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDU2NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094565", "bodyText": "Can do", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzODU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMzUxOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498913518", "bodyText": "This should probably return the account id being associated to allow clients to filter transactions by that entity id and relate it to the transaction.entity_id.", "author": "steven-sheehy", "createdAt": "2020-10-02T16:05:31Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenAssociateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenAssociateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return null;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NDYxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498954614", "bodyText": "Can't return one account Id since TokenAssociate can be applied to multiple accounts at a time", "author": "Nana-EC", "createdAt": "2020-10-02T17:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMzUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MTU1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498961553", "bodyText": "Actually, it's the opposite. 1 Account -> Many tokens.\nWill return the Account entity in this case then.", "author": "Nana-EC", "createdAt": "2020-10-02T17:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMzUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDU3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094578", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxMzUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNDM1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498914353", "bodyText": "This should probably return the account id being associated to allow clients to filter transactions by that entity id and relate it to the transaction.entity_id.", "author": "steven-sheehy", "createdAt": "2020-10-02T16:07:14Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenDissociateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenDissociateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return null;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NDkyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498954929", "bodyText": "Can't return one account Id since TokenDissociate can be applied to multiple accounts at a time", "author": "Nana-EC", "createdAt": "2020-10-02T17:29:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNDM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MTYyNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498961624", "bodyText": "Actually, it's the opposite. 1 Account -> Many tokens.\nWill return the Account entity in this case then.", "author": "Nana-EC", "createdAt": "2020-10-02T17:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNDM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDU4NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094584", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNDM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNTA0NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498915045", "bodyText": "nit: Would prefer a variable name that represents the thing it's holding. e.g. tokenCreateTransactionBody, transactionBody, body.", "author": "steven-sheehy", "createdAt": "2020-10-02T16:08:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDYwMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094602", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNTA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNjcyOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498916728", "bodyText": "Not an issue with your code, but autoRenewPeriod is modeled as a Duration in ConsensusCreateTopic and a uint64 here. Can we ask Michael if this can be switched to Duration?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:11:52Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        if (txMessage.getAutoRenewPeriod() != 0) {", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxMzQ3Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499913472", "bodyText": "Requested", "author": "Nana-EC", "createdAt": "2020-10-05T22:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNjcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNzcyNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498917727", "bodyText": "Should we ask services to model this as a Timestamp?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:13:49Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));\n+        }\n+\n+        if (txMessage.getAutoRenewPeriod() != 0) {\n+            entity.setAutoRenewPeriod(txMessage.getAutoRenewPeriod());\n+        }\n+\n+        if (txMessage.getExpiry() != 0) {", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1ODU2Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498958562", "bodyText": "Yeah, probably better for consistency across entities to just do Timestamp.\nI also need to change this to pull ns as looks like expiry is in epoch seconds", "author": "Nana-EC", "createdAt": "2020-10-02T17:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNzcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkxMzUxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499913514", "bodyText": "Requested", "author": "Nana-EC", "createdAt": "2020-10-05T22:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxNzcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxODUzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498918536", "bodyText": "Should this be the token or the account? We're not freezing the token we're freezing the account's use of this token. Or more generically, this action is modifying the account not the token.", "author": "steven-sheehy", "createdAt": "2020-10-02T16:15:23Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenFreezeTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenFreezeTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenFreeze().getToken());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2Nzg3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498967878", "bodyText": "Yeah, I think the confusion comes from the fact that the real thing being modified is the TokenAccount not the Account or the Token in the Freeze/Kyc cases. That's the info that should be extracted on a getEntity.\nNeither Account nor Token are modified by these cases and so it's a toss up in terms of which one to return.\nEither ways you'd need the other for full visibility.\nI think the right thing in a future refactor would be to return the appropriate entity of TokenAccount.", "author": "Nana-EC", "createdAt": "2020-10-02T17:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxODUzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDYzMQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094631", "bodyText": "Went ahead and returned Account type", "author": "Nana-EC", "createdAt": "2020-10-03T00:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxODUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxOTM5OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498919399", "bodyText": "Should this be the token or the account for the same reasons as above?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:17:00Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenGrantKycTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenGrantKycTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenGrantKyc().getToken());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDY5NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094695", "bodyText": "Changed to Account", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkxOTM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMTQyMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498921422", "bodyText": "Should this be the token or the account for the same reasons as above?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:20:57Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenRevokeKycTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenRevokeKycTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenRevokeKyc().getToken());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDcwOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094709", "bodyText": "Changed to Account", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMTQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjI0Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498922247", "bodyText": "Should this be the token or the account for the same reasons as above?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:22:34Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUnfreezeTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenUnfreezeTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenUnfreeze().getToken());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDcyMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094722", "bodyText": "Changed to Account", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjc4MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498922781", "bodyText": "Move to transactionHandler.getAutoRenewAccount()", "author": "steven-sheehy", "createdAt": "2020-10-02T16:23:40Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenUpdateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenUpdateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenUpdateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenUpdate().getToken());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenUpdateTransactionBody txMessage = recordItem.getTransactionBody().getTokenUpdate();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDczNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094735", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjg2NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498922865", "bodyText": "Move to transactionHandler.getAutoRenewAccount()", "author": "steven-sheehy", "createdAt": "2020-10-02T16:23:51Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenCreateTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.hederahashgraph.api.proto.java.TokenCreateTransactionBody;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenCreateTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getRecord().getReceipt().getTokenId());\n+    }\n+\n+    @Override\n+    public boolean updatesEntity() {\n+        return true;\n+    }\n+\n+    @Override\n+    public void updateEntity(Entities entity, RecordItem recordItem) {\n+        TokenCreateTransactionBody txMessage = recordItem.getTransactionBody().getTokenCreation();\n+        if (txMessage.hasAdminKey()) {\n+            entity.setKey(txMessage.getAdminKey().toByteArray());\n+        }\n+\n+        if (txMessage.hasAutoRenewAccount()) {\n+            entity.setAutoRenewAccountId(EntityId.of(txMessage.getAutoRenewAccount()));", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDc0NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094744", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMjg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMzM1MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498923351", "bodyText": "Should this be the token or the account for the same reasons as above?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:24:53Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/transactionhandler/TokenWipeTransactionsHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.hedera.mirror.importer.parser.record.transactionhandler;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.parser.domain.RecordItem;\n+\n+@Named\n+@AllArgsConstructor\n+public class TokenWipeTransactionsHandler implements TransactionHandler {\n+    @Override\n+    public EntityId getEntity(RecordItem recordItem) {\n+        return EntityId.of(recordItem.getTransactionBody().getTokenWipe().getToken());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5Mzk1Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499093956", "bodyText": "This one is honestly both. So not sure.\nWipe will burn the number of tokens an account has but also deplore the totalSupply of the actual Token", "author": "Nana-EC", "createdAt": "2020-10-03T00:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMzM1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3NTYxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499775619", "bodyText": "Left this as token", "author": "Nana-EC", "createdAt": "2020-10-05T17:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyMzM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNjAyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498926023", "bodyText": "We don't make use of this id, right? To save space and time it might be better to switch to a composite primary key.", "author": "steven-sheehy", "createdAt": "2020-10-02T16:30:05Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import javax.persistence.Convert;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@Entity\n+@Log4j2\n+public class TokenAccount {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.IDENTITY)\n+    private Long id;", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2ODU4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498968583", "bodyText": "Yeah, it's unused. Composite would be more appropriate.", "author": "Nana-EC", "createdAt": "2020-10-02T17:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNjAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NDc1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499094758", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-03T00:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkyNjAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNzcxNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498937716", "bodyText": "This is brittle. What's wrong with using assertThat(expected).isEqualTo(actual) and using ignoringGivenFields if needed?", "author": "steven-sheehy", "createdAt": "2020-10-02T16:53:57Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/repository/TokenRepositoryTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package com.hedera.mirror.importer.repository;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.google.protobuf.ByteString;\n+import com.hederahashgraph.api.proto.java.Key;\n+import javax.annotation.Resource;\n+import org.apache.commons.codec.DecoderException;\n+import org.apache.commons.codec.binary.Hex;\n+import org.junit.jupiter.api.Test;\n+\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Token;\n+\n+public class TokenRepositoryTest extends AbstractRepositoryTest {\n+    @Resource\n+    protected TokenRepository tokenRepository;\n+\n+    private final EntityId FOO_COIN_ID = EntityId.of(\"0.0.101\", EntityTypeEnum.TOKEN);\n+    String key = \"0011223344556677889900aabbccddeeff0011223344556677889900aabbccddeeff\";\n+    private final EntityId treasuryAccount = EntityId.of(\"0.0.102\", EntityTypeEnum.ACCOUNT);\n+\n+    @Test\n+    void save() throws DecoderException {\n+        Token token = tokenRepository.save(token(1));\n+        tokenMatch(token, tokenRepository.findById(token.getTokenId())\n+                .get());\n+    }\n+\n+    private Token token(long consensusTimestamp) throws DecoderException {\n+        var hexKey = Key.newBuilder().setEd25519(ByteString.copyFrom(Hex.decodeHex(key))).build().toByteArray();\n+        Token token = new Token();\n+        token.setCreatedTimestamp(1L);\n+        token.setDecimals(1000);\n+        token.setFreezeDefault(false);\n+        token.setFreezeKey(hexKey);\n+        token.setInitialSupply(1_000_000_000L);\n+        token.setKycKey(hexKey);\n+        token.setModifiedTimestamp(3L);\n+        token.setName(\"FOO COIN TOKEN\");\n+        token.setSupplyKey(hexKey);\n+        token.setSymbol(\"FOOTOK\");\n+        token.setTokenId(new Token.Id(FOO_COIN_ID));\n+        token.setTreasuryAccountId(treasuryAccount);\n+        token.setWipeKey(hexKey);\n+        return token;\n+    }\n+\n+    private void tokenMatch(Token expected, Token actual) {\n+        assertAll(\n+                () -> assertNotNull(actual),", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NTU5MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499095591", "bodyText": "Actually can just do a isEqualTo without ignoring anything", "author": "Nana-EC", "createdAt": "2020-10-03T00:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNzcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NTg1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498945853", "bodyText": "These two repository calls will definitely slow things down. I haven't had time to verify if multiple calls to save will be internally batched. This might be fine for now but we'll need to revisit this next sprint.", "author": "steven-sheehy", "createdAt": "2020-10-02T17:10:40Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/sql/SqlEntityListener.java", "diffHunk": "@@ -239,6 +255,21 @@ public void onLiveHash(LiveHash liveHash) throws ImporterException {\n         liveHashes.add(liveHash);\n     }\n \n+    @Override\n+    public void onToken(Token token) throws ImporterException {\n+        tokenRepository.save(token);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODQ5Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499098492", "bodyText": "Agreed. This is best path to get the ball rolling but we definitely need to scale.\nChallenge is each update needs to ensure it has the correct information  from current state before updating.\ne.g. A token gets created with a freeze and Kyc settings to default to FROZEN and REVOKED.\nAn account then Associates itself with the token, it will be frozen and revoked.\nSay accounts it gets Unfrozen and then soon after gets GrantedKyc.\nWe need to make sure the persistence for the KycGrant picks the fact that it was unfrozen and doesn't accidentally revert the freeze state change.\nThat's why for now I'm just saving immediately, just like Entity updates do.\nCurrently using Spring cache so this should give us some breathing room to explore the right solution for Accounts and Tokens", "author": "Nana-EC", "createdAt": "2020-10-03T00:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NTg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MDE0OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r498960148", "bodyText": "Would be cleaner to pass only RecordItem to all methods as it already contains the necessary fields and will be more encapsulated for future refactoring. I was tempted to do that for existing methods at one point but didn't want the code churn at the time, but since this is new it might make more sense to start here.", "author": "steven-sheehy", "createdAt": "2020-10-02T17:40:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -166,6 +192,32 @@ public void onItem(RecordItem recordItem) throws ImporterException {\n                         txRecord.getReceipt().getFileID(), transactionType);\n             } else if (body.hasFileUpdate()) {\n                 insertFileUpdate(consensusNs, body.getFileUpdate(), transactionType);\n+            } else if (body.hasTokenAssociate()) {\n+                insertTokenAssociate(consensusNs, body);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5OTQwOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499099409", "bodyText": "Was trying to stick to the best practice of passing only the necessary objects in and not redoing conversion work that was already done e.g consensus time extraction.\nRecordItem contains SignatureMap, and not all transactions need the TransactionRecord.\nThough making it more uniform does set the ground work for encapsulating these methods in the appropriate classes later on.\nHow about a shared signature of the below?\nprivate void insertTransactionType(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {", "author": "Nana-EC", "createdAt": "2020-10-03T00:46:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MDE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTExMjI1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499112253", "bodyText": "All the methods in RecordItem are already converted at this point as it's an immutable object. There's no penalty to pay for calling any of its getters. The getConsensusTimestamp() is a lazy getter and the protos are parsed.\nThere's a slight difference in that consensusNs = Utility.timeStampInNanos(txRecord.getConsensusTimestamp()) and recordItem.getConsensusTimestamp() is Utility.timestampInNanosMax(record.getConsensusTimestamp()), but either approach is equivalent for consensus timestamp in records.", "author": "steven-sheehy", "createdAt": "2020-10-03T03:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MDE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE4OTA4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499189083", "bodyText": "Works for me. Will update them to all to take in RecordItem.", "author": "Nana-EC", "createdAt": "2020-10-03T23:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MDE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499063065", "bodyText": "All token Ids need to be passed to onEntityId(). All accounts do as well but that should be taken care of by generic handler.", "author": "steven-sheehy", "createdAt": "2020-10-02T21:43:40Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5OTYzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499099636", "bodyText": "They already are by the OnItem(). That's how the Entity is added to t_entities.\nSo far as the TransactionHandler implements the getEntity() method then it's covered in that sense", "author": "Nana-EC", "createdAt": "2020-10-03T00:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMzI3MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499103270", "bodyText": "So with my original configuration all these transaction handlers would have had the Token Entity passed to the OnEntityId in the OnItem().\nMy guess is you're going off of your previous suggestions to change some of them to return the Account not Token. In which case I would now have to explicitly  can OnEntityId for which ever of the 2 wasn't covered.", "author": "Nana-EC", "createdAt": "2020-10-03T01:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMzYyNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499103624", "bodyText": "This makes me think TransactionHandler interfaces getEntity(RecordItem recordItem) should be swapped/updated to either return all applicable entities or return an entity of a requested type for a given RecordItem. i.e.\nList<EntityId> getEntities(RecordItem recordItem);\n\nor\nEntityId getEntity(RecordItem recordItem, EntityTypeEnum entityTypeEnum);", "author": "Nana-EC", "createdAt": "2020-10-03T01:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTExMjU4Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499112586", "bodyText": "While the current approach is not ideal, I don't think that is a good approach either since it's a Ask Don't Tell. What we eventually want is for the transaction handlers to extract the domain objects and call EntityListener for each one.", "author": "steven-sheehy", "createdAt": "2020-10-03T03:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MTMwNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499771307", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:52:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2MzA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTE2Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499065167", "bodyText": "I don't think we should waste performance updating a timestamp when no other fields on that tokenaccount changed. We should treat the timestamp as audit info that only gets updated when a field on it changes.", "author": "steven-sheehy", "createdAt": "2020-10-02T21:51:09Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5OTgxMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499099812", "bodyText": "Fair enough. In that case Wipe operations will be a no-op for TokenAccounts", "author": "Nana-EC", "createdAt": "2020-10-03T00:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg4NjY2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499886660", "bodyText": "Actually wipe has an amount which currently needs to be deducted from the token totalSupply. Updating that.", "author": "Nana-EC", "createdAt": "2020-10-05T21:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTUyMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499065522", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T21:52:22Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMDAyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499100023", "bodyText": "Token is already passed through in OnItem.\nWe shouldn't need to repass Account because it will always be a valid already create account and no Token transactions affect the actual Hedera account", "author": "Nana-EC", "createdAt": "2020-10-03T00:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MTY4MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499771681", "bodyText": "Updating to have all TokenId's/AccountId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NTUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjAxMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499066010", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T21:54:02Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMDA4OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499100088", "bodyText": "Token is already passed through in OnItem.\nWe shouldn't need to repass Account because it will always be a valid already create account and no Token transactions affect the actual Hedera account", "author": "Nana-EC", "createdAt": "2020-10-03T00:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MTc3OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499771779", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:53:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjY1NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499066655", "bodyText": "We should create it if it's not returned from the database. All methods that use this object should remove null check. This is how we handle the only other updateable object Entities. In theory it should never happen that we get a freeze/grant/revoke/unfreeze without an associate first, but if we have a stream reset like at OA it is possible.", "author": "steven-sheehy", "createdAt": "2020-10-02T21:56:23Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private TokenAccount retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+        return tokenAccountRepository\n+                .findByTokenIdAndAccountId(EntityId.of(tokenID), EntityId.of(accountID))\n+                .orElse(null);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMTY0MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499101640", "bodyText": "Hmm, as is we won't have sufficient information to create an appropriate TokenAccount.\nfreeze/grant/revoke/unfreeze/burn only have the tokenId.\nThis would result in unexpected kyc & freeze behavior for accounts as initial freeze and kyc statuses after this shallow creation will likely be wrong for many cases.", "author": "Nana-EC", "createdAt": "2020-10-03T01:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg4OTQwOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499889409", "bodyText": "Per internal discussions we'll go with logging in these cases to avoid unexpected issues. Expectation is 3rd party should have a mirror node start time that covers the creation of desired tokens.", "author": "Nana-EC", "createdAt": "2020-10-05T21:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NjY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2Njc4Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499066782", "bodyText": "We should create it if it's not returned from the database. All methods that use this object should remove null check. This is how we handle the only other updateable object Entities. In theory it should never happen that we get a update/delete/etc without a create first, but if we have a stream reset like at OA it is possible.", "author": "steven-sheehy", "createdAt": "2020-10-02T21:56:52Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountUnfreeze(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUnfreezeAccountTransactionBody tokenUnfreezeAccountTransactionBody = txBody.getTokenUnfreeze();\n+            TokenID tokenID = tokenUnfreezeAccountTransactionBody.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenUnfreezeAccountTransactionBody\n+                    .getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Unfrozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountWipe(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenWipeAccountTransactionBody tokenWipeAccountTransactionBody = txBody.getTokenWipe();\n+\n+            // update token total supply similar to TokenBurn transaction\n+            Token token = retrieveToken(tokenWipeAccountTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                token.setTotalSupply(token.getTotalSupply() - tokenWipeAccountTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+\n+            // Mirror relies on CSV balances change from network, flag change with modified update\n+            TokenID tokenID = tokenWipeAccountTransactionBody.getToken();\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenWipeAccountTransactionBody.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private TokenAccount retrieveTokenAccount(TokenID tokenID, AccountID accountID) {\n+        return tokenAccountRepository\n+                .findByTokenIdAndAccountId(EntityId.of(tokenID), EntityId.of(accountID))\n+                .orElse(null);\n+    }\n+\n+    private Token retrieveToken(TokenID tokenID) {\n+        return tokenRepository\n+                .findById(new Token.Id(EntityId.of(tokenID)))\n+                .orElse(null);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMTMzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499101338", "bodyText": "Hmm, as is we won't have sufficient information to create an appropriate Token.\nUpdate has the largest amount of info but doesn't have initialSupply, decimals etc.\ndelete/wipe/mint/burn only have the tokenId.\nThis would result in unexpected kyc & freeze behavior for accounts onboarded after this shallow creation.", "author": "Nana-EC", "createdAt": "2020-10-03T01:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2Njc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg4OTQ2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499889469", "bodyText": "Per internal discussions we'll go with logging in these cases to avoid unexpected issues. Expectation is 3rd party should have a mirror node start time that covers the creation of desired tokens.", "author": "Nana-EC", "createdAt": "2020-10-05T21:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2Njc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzIyNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499067226", "bodyText": "Token and treasury should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T21:58:18Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = txBody.getTokenUpdate();\n+            Token token = retrieveToken(tokenUpdateTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    token.setTreasuryAccountId(EntityId.of(tokenUpdateTransactionBody.getTreasury()));", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMTg2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499101860", "bodyText": "Token is. Treasury will be an already created account.\nI'm guessing this is also the Pre OA case that we need to cover", "author": "Nana-EC", "createdAt": "2020-10-03T01:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MjAwNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499772004", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzY2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499067669", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T21:59:58Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenTransfers(long consensusTimestamp, TransactionRecord txRecord) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            txRecord.getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(consensusTimestamp, accountAmount", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3Njk4NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499776984", "bodyText": "Will add for token, missed on last commit", "author": "Nana-EC", "createdAt": "2020-10-05T18:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzgzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499067838", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T22:00:30Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Granted_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenMint(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = txBody.getTokenMint();\n+            Token token = retrieveToken(tokenMintTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() + tokenMintTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKyc = txBody.getTokenRevokeKyc();\n+            TokenID tokenID = tokenRevokeKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenRevokeKyc.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setKycStatus(TokenKycStatus.Revoked_VALUE);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MzIxMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499773213", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2NzgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODM2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068360", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T22:02:23Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());\n+            if (tokenAccount != null) {\n+                tokenAccount.setFreezeStatus(TokenFreezeStatus.Frozen_VALUE);\n+                tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onTokenAccount(tokenAccount);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKyc = txBody.getTokenGrantKyc();\n+            TokenID tokenID = tokenGrantKyc.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenGrantKyc.getAccount());\n+            if (tokenAccount != null) {", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MzI5MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499773291", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:55:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODQwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068405", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T22:02:35Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);\n+                if (tokenAccount != null) {\n+                    tokenAccount.setAssociated(false);\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreeze = txBody.getTokenFreeze();\n+            TokenID tokenID = tokenFreeze.getToken();\n+\n+            TokenAccount tokenAccount = retrieveTokenAccount(tokenID, tokenFreeze.getAccount());", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MzMzOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499773339", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODUxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068514", "bodyText": "Account and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T22:02:57Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociate = txBody.getTokenDissociate();\n+            AccountID accountID = tokenDissociate.getAccount();\n+            tokenDissociate.getTokensList().forEach(token -> {\n+                TokenAccount tokenAccount = retrieveTokenAccount(token, accountID);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc3MzQwMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499773402", "bodyText": "Updating to have all TokenId's be passed to OnEntityId where the OnItem() method doesn't already handle this", "author": "Nana-EC", "createdAt": "2020-10-05T17:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODY5NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068694", "bodyText": "Should we also have a delete flag on token?", "author": "steven-sheehy", "createdAt": "2020-10-02T22:03:38Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));\n+            }\n+\n+            if (tokenCreation.hasWipeKey()) {\n+                token.setWipeKey(tokenCreation.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeletion = txBody.getTokenDeletion();\n+            Token token = retrieveToken(tokenDeletion.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMjAwMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499102002", "bodyText": "This already exists on the Entities object.\nThe assumption is any API call filtering on deleted will do the necessary join to pull that info.\nOtherwise it'll be a duplication of data between the tables.", "author": "Nana-EC", "createdAt": "2020-10-03T01:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODk2Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499068963", "bodyText": "Treasury and token should be passed to onEntityId either here or in handler", "author": "steven-sheehy", "createdAt": "2020-10-02T22:04:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +432,260 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociate = txBody.getTokenAssociate();\n+            AccountID accountID = tokenAssociate.getAccount();\n+            tokenAssociate.getTokensList().forEach(token -> {\n+                if (retrieveTokenAccount(token, accountID) == null) {\n+                    Token storedToken = retrieveToken(token);\n+                    TokenAccount tokenAccount = new TokenAccount();\n+                    tokenAccount.setAssociated(true);\n+                    tokenAccount.setCreatedTimestamp(consensusTimestamp);\n+                    tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                    tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+                    tokenAccount.setAccountId(EntityId.of(accountID));\n+                    tokenAccount.setTokenId(EntityId.of(token));\n+                    entityListener.onTokenAccount(tokenAccount);\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(long consensusTimestamp, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = txBody.getTokenBurn();\n+            Token token = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (token != null) {\n+                token.setModifiedTimestamp(consensusTimestamp);\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(long consensusTimestamp, TransactionRecord txRecord, TransactionBody txBody) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreation = txBody.getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(consensusTimestamp);\n+            token.setDecimals(tokenCreation.getDecimals());\n+            token.setFreezeDefault(tokenCreation.getFreezeDefault());\n+            token.setInitialSupply(tokenCreation.getInitialSupply());\n+            token.setModifiedTimestamp(consensusTimestamp);\n+            token.setName(tokenCreation.getName());\n+            token.setSymbol(tokenCreation.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(txRecord.getReceipt().getTokenId())));\n+\n+            if (tokenCreation.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreation.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasKycKey()) {\n+                token.setKycKey(tokenCreation.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreation.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreation.hasTreasury()) {\n+                token.setTreasuryAccountId(EntityId.of(tokenCreation.getTreasury()));", "originalCommit": "f2bd2dc85bf7b2bb76bf4d56de12dc3a3fa0fc53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMyMDA2OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499320068", "bodyText": "Done", "author": "Nana-EC", "createdAt": "2020-10-05T02:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA2ODk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NTU4Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499755586", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // if not onboarded create create TokenAccount based off of Token details\n          \n          \n            \n                                // if not onboarded create TokenAccount based on Token details", "author": "Nana-EC", "createdAt": "2020-10-05T17:22:35Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDEwNw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499760107", "bodyText": "Remove a already handled in OnItem()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        entityListener.onEntityId(accountEntityId);", "author": "Nana-EC", "createdAt": "2020-10-05T17:30:55Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDk3MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499760970", "bodyText": "Remove since covered by OnItem()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        entityListener.onEntityId(accountEntityId);", "author": "Nana-EC", "createdAt": "2020-10-05T17:32:38Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MTQ4Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499761487", "bodyText": "Add OnEntityId for every Token\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n          \n          \n            \n                            entityListener.onEntityId(EntityId.of(token));\n          \n          \n            \n                            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);", "author": "Nana-EC", "createdAt": "2020-10-05T17:33:32Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2Mjc4Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499762782", "bodyText": "Swap to do for Token since Account is covered by OnItem()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        entityListener.onEntityId(accountEntityId);\n          \n          \n            \n            TokenID tokenID = tokenFreezeAccountTransactionBody.getToken();\n          \n          \n            \n            EntityId.of(tokenID)", "author": "Nana-EC", "createdAt": "2020-10-05T17:35:58Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenFreeze();\n+            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2Mzg5NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499763895", "bodyText": "Swap to do token", "author": "Nana-EC", "createdAt": "2020-10-05T17:38:06Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +431,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+                Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(token, accountID);\n+                TokenAccount tokenAccount = null;\n+                if (retrieveTokenAccount(token, accountID).isPresent()) {\n+                    tokenAccount = optionalTokenAccount.get();\n+                } else {\n+                    // if not onboarded create create TokenAccount based off of Token details\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        tokenAccount = new TokenAccount(EntityId.of(token), accountEntityId);\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                    }\n+                }\n+\n+                tokenAccount.setAssociated(true);\n+                tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onTokenAccount(tokenAccount);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            Optional<Token> optionalToken = retrieveToken(tokenBurnTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                // mirror will calculate new totalSupply as an interim solution until network returns it\n+                token.setTotalSupply(token.getTotalSupply() - tokenBurnTransactionBody.getAmount());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            Optional<Token> optionalToken = retrieveToken(tokenDeleteTransactionBody.getToken());\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                entityListener.onToken(token);\n+            }\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), token, accountID, true, false, false);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenFreeze();\n+            AccountID accountID = tokenFreezeAccountTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n+                    .getToken(), accountID, false, true, false);\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenGrantKyc();\n+            AccountID accountID = tokenGrantKycTransactionBody.getAccount();\n+            EntityId accountEntityId = EntityId.of(accountID);\n+            entityListener.onEntityId(accountEntityId);", "originalCommit": "b1055f75c69e20a1a63c3fd59c595f2181f71acb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMjcwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499922705", "bodyText": "nit: Generally enum values are named like static constants in upper snake case, so NOT_APPLICABLE.", "author": "steven-sheehy", "createdAt": "2020-10-05T23:18:53Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenKycStatusEnum.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@Getter\n+@RequiredArgsConstructor\n+public enum TokenKycStatusEnum {\n+\n+    NOTAPPLICABLE(0),", "originalCommit": "4a40fbc3922abf545401ad950fb7a2d610708b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3Mjk0Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500472947", "bodyText": "Changing to NOT_APPLICABLE", "author": "Nana-EC", "createdAt": "2020-10-06T17:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyMjcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyNTEyOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r499925128", "bodyText": "I'm not a fan of these toggle methods. If we get two freeze accounts transactions back to back (not sure if possible), then it would be unfrozen. Would prefer simpler setters to avoid this even if platform makes this impossible.", "author": "steven-sheehy", "createdAt": "2020-10-05T23:26:49Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/TokenAccount.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.hedera.mirror.importer.domain;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.fasterxml.jackson.annotation.JsonUnwrapped;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import java.io.Serializable;\n+import javax.persistence.Convert;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EmbeddedId;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+\n+import com.hedera.mirror.importer.converter.AccountIdConverter;\n+import com.hedera.mirror.importer.converter.EntityIdSerializer;\n+import com.hedera.mirror.importer.converter.TokenIdConverter;\n+\n+@Data\n+@Entity\n+@Log4j2\n+@NoArgsConstructor\n+public class TokenAccount {\n+    @EmbeddedId\n+    @JsonUnwrapped\n+    private TokenAccount.Id id;\n+\n+    private boolean associated;\n+\n+    private long createdTimestamp;\n+\n+    @Enumerated(EnumType.ORDINAL)\n+    private TokenFreezeStatusEnum freezeStatus;\n+\n+    @Enumerated(EnumType.ORDINAL)\n+    private TokenKycStatusEnum kycStatus;\n+\n+    private long modifiedTimestamp;\n+\n+    public TokenAccount(EntityId tokenId, EntityId accountId) {\n+        id = new TokenAccount.Id(tokenId, accountId);\n+    }\n+\n+    public void toggleAssociatedStatus() {\n+        associated = !associated;", "originalCommit": "4a40fbc3922abf545401ad950fb7a2d610708b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQzMzIxOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500433218", "bodyText": "That's a good point. Can change it back to simple sets", "author": "Nana-EC", "createdAt": "2020-10-06T16:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyNTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODc0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500408741", "bodyText": "Not a fan of these generic methods that then have transaction specific checks within them. Also not ideal because it denormalizes the token account object into a bunch of parameters, which is less maintainable when those change. Code reuse should not be done at the expense of maintainability and encapsulation.\nTransaction specific logic should be contained within the insertToken... methods.  This encapsulates the logic and will allow us to lift and shift it to the transaction handlers later. You can achieve something similar without this by pushing most of this common logic into the retrieve method.\nWe can always change this in a follow up or when we move to transaction handlers, though.", "author": "steven-sheehy", "createdAt": "2020-10-06T15:49:53Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +435,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+\n+                long consensusTimeStamp = recordItem.getConsensusTimestamp();\n+                if (!insertTokenAccountUpdate(consensusTimeStamp, token, accountID,\n+                        TransactionTypeEnum.TOKENASSOCIATE)) {\n+                    // if not onboarded create TokenAccount based on Token details\n+                    EntityId tokenID = EntityId.of(token);\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        TokenAccount tokenAccount = new TokenAccount(tokenID, EntityId.of(accountID));\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+                        tokenAccount.setFreezeStatus(storedToken.getNewAccountFreezeStatus());\n+                        tokenAccount.setKycStatus(storedToken.getNewAccountKycStatus());\n+                        tokenAccount.setAssociated(true);\n+                        tokenAccount.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+                        entityListener.onTokenAccount(tokenAccount);\n+                    } else {\n+                        log.warn(MISSING_TOKEN_MESSAGE, tokenID, TransactionTypeEnum.TOKENASSOCIATE,\n+                                consensusTimeStamp);\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    private void insertTokenBurn(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenBurnTransactionBody tokenBurnTransactionBody = recordItem.getTransactionBody().getTokenBurn();\n+            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenBurnTransactionBody\n+                    .getToken(), tokenBurnTransactionBody.getAmount(), TransactionTypeEnum.TOKENBURN);\n+        }\n+    }\n+\n+    private void insertTokenCreate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            // pull token details from TokenCreation body and TokenId from receipt\n+            TokenCreateTransactionBody tokenCreateTransactionBody = recordItem.getTransactionBody().getTokenCreation();\n+            Token token = new Token();\n+            token.setCreatedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setDecimals(tokenCreateTransactionBody.getDecimals());\n+            token.setFreezeDefault(tokenCreateTransactionBody.getFreezeDefault());\n+            token.setInitialSupply(tokenCreateTransactionBody.getInitialSupply());\n+            token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+            token.setName(tokenCreateTransactionBody.getName());\n+            token.setSymbol(tokenCreateTransactionBody.getSymbol());\n+            token.setTokenId(new Token.Id(EntityId.of(recordItem.getRecord().getReceipt().getTokenId())));\n+\n+            if (tokenCreateTransactionBody.hasFreezeKey()) {\n+                token.setFreezeKey(tokenCreateTransactionBody.getFreezeKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasKycKey()) {\n+                token.setKycKey(tokenCreateTransactionBody.getKycKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasSupplyKey()) {\n+                token.setSupplyKey(tokenCreateTransactionBody.getSupplyKey().toByteArray());\n+            }\n+\n+            if (tokenCreateTransactionBody.hasTreasury()) {\n+                EntityId treasuryEntityId = EntityId.of(tokenCreateTransactionBody.getTreasury());\n+                entityListener.onEntityId(treasuryEntityId);\n+                token.setTreasuryAccountId(treasuryEntityId);\n+            }\n+\n+            if (tokenCreateTransactionBody.hasWipeKey()) {\n+                token.setWipeKey(tokenCreateTransactionBody.getWipeKey().toByteArray());\n+            }\n+\n+            entityListener.onToken(token);\n+        }\n+    }\n+\n+    private void insertTokenDelete(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDeleteTransactionBody tokenDeleteTransactionBody = recordItem.getTransactionBody().getTokenDeletion();\n+            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenDeleteTransactionBody\n+                    .getToken(), 0, TransactionTypeEnum.TOKENDELETION);\n+        }\n+    }\n+\n+    private void insertTokenDissociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenDissociateTransactionBody tokenDissociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenDissociate();\n+            AccountID accountID = tokenDissociateTransactionBody.getAccount();\n+\n+            tokenDissociateTransactionBody.getTokensList().forEach(token -> {\n+                insertTokenAccountUpdate(recordItem\n+                        .getConsensusTimestamp(), token, accountID, TransactionTypeEnum.TOKENDISSOCIATE);\n+            });\n+        }\n+    }\n+\n+    private void insertTokenAccountFreezeBody(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenFreezeAccountTransactionBody tokenFreezeAccountTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenFreeze();\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenFreezeAccountTransactionBody\n+                    .getToken(), tokenFreezeAccountTransactionBody.getAccount(), TransactionTypeEnum.TOKENFREEZE);\n+        }\n+    }\n+\n+    private void insertTokenAccountGrantKyc(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenGrantKycTransactionBody tokenGrantKycTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenGrantKyc();\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenGrantKycTransactionBody\n+                    .getToken(), tokenGrantKycTransactionBody.getAccount(), TransactionTypeEnum.TOKENGRANTKYC);\n+        }\n+    }\n+\n+    private void insertTokenMint(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenMintTransactionBody tokenMintTransactionBody = recordItem.getTransactionBody().getTokenMint();\n+            insertSingleTokenPropertyUpdate(recordItem.getConsensusTimestamp(), tokenMintTransactionBody\n+                    .getToken(), tokenMintTransactionBody.getAmount(), TransactionTypeEnum.TOKENMINT);\n+        }\n+    }\n+\n+    private void insertTokenAccountRevokeKyc(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenRevokeKycTransactionBody tokenRevokeKycTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenRevokeKyc();\n+\n+            insertTokenAccountUpdate(recordItem.getConsensusTimestamp(), tokenRevokeKycTransactionBody\n+                    .getToken(), tokenRevokeKycTransactionBody.getAccount(), TransactionTypeEnum.TOKENREVOKEKYC);\n+        }\n+    }\n+\n+    private void insertTokenTransfers(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            recordItem.getRecord().getTokenTransferListsList().forEach(tokenTransferList -> {\n+                EntityId tokenId = EntityId.of(tokenTransferList.getToken());\n+                entityListener.onEntityId(tokenId);\n+\n+                tokenTransferList.getTransfersList().forEach(accountAmount -> {\n+                    EntityId accountId = EntityId.of(accountAmount.getAccountID());\n+                    entityListener.onEntityId(accountId);\n+\n+                    entityListener.onTokenTransfer(new TokenTransfer(recordItem.getConsensusTimestamp(), accountAmount\n+                            .getAmount(), tokenId, accountId));\n+                });\n+            });\n+        }\n+    }\n+\n+    private void insertTokenUpdate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenUpdateTransactionBody tokenUpdateTransactionBody = recordItem.getTransactionBody().getTokenUpdate();\n+            TokenID tokenID = tokenUpdateTransactionBody.getToken();\n+\n+            Optional<Token> optionalToken = retrieveToken(tokenID);\n+            if (optionalToken.isPresent()) {\n+                Token token = optionalToken.get();\n+                token.setModifiedTimestamp(recordItem.getConsensusTimestamp());\n+\n+                if (tokenUpdateTransactionBody.hasFreezeKey()) {\n+                    token.setFreezeKey(tokenUpdateTransactionBody.getFreezeKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasKycKey()) {\n+                    token.setKycKey(tokenUpdateTransactionBody.getKycKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasSupplyKey()) {\n+                    token.setSupplyKey(tokenUpdateTransactionBody.getSupplyKey().toByteArray());\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasTreasury()) {\n+                    EntityId treasuryEntityId = EntityId.of(tokenUpdateTransactionBody.getTreasury());\n+                    entityListener.onEntityId(treasuryEntityId);\n+                    token.setTreasuryAccountId(treasuryEntityId);\n+                }\n+\n+                if (tokenUpdateTransactionBody.hasWipeKey()) {\n+                    token.setWipeKey(tokenUpdateTransactionBody.getWipeKey().toByteArray());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getName().isEmpty()) {\n+                    token.setName(tokenUpdateTransactionBody.getName());\n+                }\n+\n+                if (!tokenUpdateTransactionBody.getSymbol().isEmpty()) {\n+                    token.setSymbol(tokenUpdateTransactionBody.getSymbol());\n+                }\n+\n+                entityListener.onToken(token);\n+            } else {\n+                log.warn(MISSING_TOKEN_MESSAGE, tokenID, TransactionTypeEnum.TOKENDELETION, recordItem\n+                        .getConsensusTimestamp());\n+            }\n+        }\n+    }\n+\n+    private boolean insertTokenAccountUpdate(long consensusTimestamp, TokenID tokenID, AccountID accountID,\n+                                             TransactionTypeEnum transactionTypeEnum) {\n+        entityListener.onEntityId(EntityId.of(tokenID));\n+\n+        Optional<TokenAccount> optionalTokenAccount = retrieveTokenAccount(tokenID, accountID);\n+        boolean tokenAccountFound = optionalTokenAccount.isPresent();\n+        if (tokenAccountFound) {\n+\n+            TokenAccount tokenAccount = optionalTokenAccount.get();\n+            tokenAccount.setModifiedTimestamp(consensusTimestamp);\n+\n+            if (transactionTypeEnum == TransactionTypeEnum.TOKENASSOCIATE || transactionTypeEnum == TransactionTypeEnum.TOKENDISSOCIATE) {", "originalCommit": "4a40fbc3922abf545401ad950fb7a2d610708b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQzMjU3MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500432571", "bodyText": "Yeah my hope was this would leave mostly boiler plate code to copy and paste into the transaction handlers when we made that move", "author": "Nana-EC", "createdAt": "2020-10-06T16:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1Nzc4OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500457788", "bodyText": "Changing now", "author": "Nana-EC", "createdAt": "2020-10-06T17:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3ODQ2Mg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500478462", "bodyText": "Moved logic back into insertToken...\nMoved missing Token or TokenAccount to retrieveMethod, but had to pass current transactionType and timestamp to make long informational", "author": "Nana-EC", "createdAt": "2020-10-06T17:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwODc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMTYyOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500411629", "bodyText": "nit: Already have consensusTimeStamp variable extracted that you can use for both timestamps.", "author": "steven-sheehy", "createdAt": "2020-10-06T15:53:52Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/parser/record/entity/EntityRecordItemListener.java", "diffHunk": "@@ -380,4 +435,292 @@ private void updateEntity(\n         }\n         entityRepository.save(entity);\n     }\n+\n+    private void insertTokenAssociate(RecordItem recordItem) {\n+        if (entityProperties.getPersist().isTokens()) {\n+            TokenAssociateTransactionBody tokenAssociateTransactionBody = recordItem.getTransactionBody()\n+                    .getTokenAssociate();\n+            AccountID accountID = tokenAssociateTransactionBody.getAccount();\n+\n+            tokenAssociateTransactionBody.getTokensList().forEach(token -> {\n+\n+                long consensusTimeStamp = recordItem.getConsensusTimestamp();\n+                if (!insertTokenAccountUpdate(consensusTimeStamp, token, accountID,\n+                        TransactionTypeEnum.TOKENASSOCIATE)) {\n+                    // if not onboarded create TokenAccount based on Token details\n+                    EntityId tokenID = EntityId.of(token);\n+                    Optional<Token> optionalToken = retrieveToken(token);\n+                    if (optionalToken.isPresent()) {\n+                        Token storedToken = optionalToken.get();\n+                        TokenAccount tokenAccount = new TokenAccount(tokenID, EntityId.of(accountID));\n+                        tokenAccount.setCreatedTimestamp(recordItem.getConsensusTimestamp());", "originalCommit": "4a40fbc3922abf545401ad950fb7a2d610708b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3NzcwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1089#discussion_r500477705", "bodyText": "Picking this up and other places", "author": "Nana-EC", "createdAt": "2020-10-06T17:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxMTYyOQ=="}], "type": "inlineReview"}, {"oid": "462dad70ae7386a570bca26efaff4a8246c9952c", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/462dad70ae7386a570bca26efaff4a8246c9952c", "message": "Add Importer Logic to Persist HTS transactions\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:47Z", "type": "commit"}, {"oid": "4055e58777092ee0d6f00f2c5d71c2c34e1acafc", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4055e58777092ee0d6f00f2c5d71c2c34e1acafc", "message": "Fixing and adding tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:47Z", "type": "commit"}, {"oid": "d1d6863fcbc487d35cd94f10523608f55f872086", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d1d6863fcbc487d35cd94f10523608f55f872086", "message": "Added TransactionsHandlerTests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:47Z", "type": "commit"}, {"oid": "c9b9afd3b98119183404d1ba2935334479e4aa28", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c9b9afd3b98119183404d1ba2935334479e4aa28", "message": "Updated transaction handler tests and Added repository tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:47Z", "type": "commit"}, {"oid": "fb322f88d90f8442fd8063bb9d4653416b2b02e0", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/fb322f88d90f8442fd8063bb9d4653416b2b02e0", "message": "Fixed transaction handler tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:47Z", "type": "commit"}, {"oid": "68db9fe273bf04ab9d8d4214484493adcc913013", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/68db9fe273bf04ab9d8d4214484493adcc913013", "message": "Fixing merge conflicts with alpha5\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "93c9d48c4dba6f2f62f186c9e881c0625575d8b3", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/93c9d48c4dba6f2f62f186c9e881c0625575d8b3", "message": "Added caching to token and token_account repo calls\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "4923866fa05ab8dd6cd479f3ae2edee59d29b866", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4923866fa05ab8dd6cd479f3ae2edee59d29b866", "message": "Removed tokenBalance domain and repo and added tokenUpdate test\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "6ec96df9ed8aa4d7a428399ef725c508839cedc4", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6ec96df9ed8aa4d7a428399ef725c508839cedc4", "message": "Added tests to increase coverage\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "327505df3664012ca17684df155a3cb47ac9615e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/327505df3664012ca17684df155a3cb47ac9615e", "message": "Addressed initial round of feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "d17c1e90444e83e77d5b84eb00fcb944cc740b2b", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d17c1e90444e83e77d5b84eb00fcb944cc740b2b", "message": "Addresed feedback 2 around EntityRecordItemListener\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "cbfde0c55c1e1e0b126ada028ef5dca910a16c24", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cbfde0c55c1e1e0b126ada028ef5dca910a16c24", "message": "Updating to have all TokenId's and AccountId's be passed to OnEntityId\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "f7b5f6aa4a191b47345c0a8c69531aad7da0d0d2", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f7b5f6aa4a191b47345c0a8c69531aad7da0d0d2", "message": "Cleaned up and added logs message where missing token or token_account\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "67738e1ff0c53481b5fba389d226f0ceb1f981d0", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/67738e1ff0c53481b5fba389d226f0ceb1f981d0", "message": "Pulled in TokenBalance changes and addressed feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "8057ddeb11ff23051738f7b887e57c3041c9ba97", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8057ddeb11ff23051738f7b887e57c3041c9ba97", "message": "Add Importer Logic to Persist HTS transactions\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "d1b1530b732bcc2cb8413c04047d51f567f62e10", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/d1b1530b732bcc2cb8413c04047d51f567f62e10", "message": "Fixing and adding tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "bdb341700207fbd55431276bf7e6d1835ce7959f", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/bdb341700207fbd55431276bf7e6d1835ce7959f", "message": "Added TransactionsHandlerTests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "13a3db327004fcb200aa1e768d1363950e61206e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/13a3db327004fcb200aa1e768d1363950e61206e", "message": "Updated transaction handler tests and Added repository tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "837657ffa53fc6fa5291f886272b1d8cc2e874f0", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/837657ffa53fc6fa5291f886272b1d8cc2e874f0", "message": "Fixed transaction handler tests\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "34bc0786a4a60bfc52c211543a792cd2319b1eb1", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/34bc0786a4a60bfc52c211543a792cd2319b1eb1", "message": "Fixing merge conflicts with alpha5\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "f11b44341b886c0417e25c0c1a092c6a035f9f2a", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f11b44341b886c0417e25c0c1a092c6a035f9f2a", "message": "Added caching to token and token_account repo calls\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:48Z", "type": "commit"}, {"oid": "878f7d75528c7156a3cf432b5c2ced0e4c97dd63", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/878f7d75528c7156a3cf432b5c2ced0e4c97dd63", "message": "Removed tokenBalance domain and repo and added tokenUpdate test\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "commit"}, {"oid": "ed01943c39423880777ea583f49be45f6b5fbdab", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/ed01943c39423880777ea583f49be45f6b5fbdab", "message": "Added tests to increase coverage\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "commit"}, {"oid": "85b2ba5a4db4171c6084457864416dad07b97626", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/85b2ba5a4db4171c6084457864416dad07b97626", "message": "Addressed initial round of feedback\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "commit"}, {"oid": "c26d0c6c6c5487468db55677cae1164acae833b7", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/c26d0c6c6c5487468db55677cae1164acae833b7", "message": "Addresed feedback 2 around EntityRecordItemListener\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "commit"}, {"oid": "80d726b39e21a825c8c9a7b6ca608af8fd653013", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/80d726b39e21a825c8c9a7b6ca608af8fd653013", "message": "Cleaned up and added logs message where missing token or token_account\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "commit"}, {"oid": "80d726b39e21a825c8c9a7b6ca608af8fd653013", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/80d726b39e21a825c8c9a7b6ca608af8fd653013", "message": "Cleaned up and added logs message where missing token or token_account\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T19:09:49Z", "type": "forcePushed"}, {"oid": "814c1fb8589220de2b0afe01e883dc949edea521", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/814c1fb8589220de2b0afe01e883dc949edea521", "message": "Fixed mad merge\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T20:04:14Z", "type": "commit"}, {"oid": "6c61ddd9e1432033b274041f62defb9e0b9c8c36", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/6c61ddd9e1432033b274041f62defb9e0b9c8c36", "message": "Removed merge artifcats and toggle methods\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-10-06T20:27:54Z", "type": "commit"}]}