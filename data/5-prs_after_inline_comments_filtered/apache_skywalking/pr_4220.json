{"pr_number": 4220, "pr_title": "sniffer processing profile task and report status and snapshot", "pr_createdAt": "2020-01-12T13:55:56Z", "pr_url": "https://github.com/apache/skywalking/pull/4220", "timeline": [{"oid": "5bee88ee7ba23dd1a19de6bf2568eef17a4a3a14", "url": "https://github.com/apache/skywalking/commit/5bee88ee7ba23dd1a19de6bf2568eef17a4a3a14", "message": "sniffer processing profile task and report status and snapshot", "committedDate": "2020-01-12T13:46:02Z", "type": "commit"}, {"oid": "a3ac8441f5dc612681c2f9bbc2e283a22b8c79d5", "url": "https://github.com/apache/skywalking/commit/a3ac8441f5dc612681c2f9bbc2e283a22b8c79d5", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-12T13:56:11Z", "type": "commit"}, {"oid": "28b26712fd8b7415fd0b1f928de4fe313278c84c", "url": "https://github.com/apache/skywalking/commit/28b26712fd8b7415fd0b1f928de4fe313278c84c", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-12T14:14:14Z", "type": "commit"}, {"oid": "617f8d4dfe8fe7ff3aaffe285e8b3437bc388d51", "url": "https://github.com/apache/skywalking/commit/617f8d4dfe8fe7ff3aaffe285e8b3437bc388d51", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-13T00:59:32Z", "type": "commit"}, {"oid": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "url": "https://github.com/apache/skywalking/commit/3b051f5c72119fffaad513e0d6c07b787cc2f447", "message": "resolve testServiceDependencies test case error, use same register with `TraceSegmentServiceClient`", "committedDate": "2020-01-13T05:03:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5NzU1Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365697557", "bodyText": "MAX_MONITOR_TIME -> MAX_DURATION", "author": "wu-sheng", "createdAt": "2020-01-13T09:09:00Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5ODA1NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365698054", "bodyText": "MAX_DUMP_STACK_DEPTH -> DUMP_MAX_STACK_DEPTH", "author": "wu-sheng", "createdAt": "2020-01-13T09:10:28Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;\n+\n+        /**\n+         * Max dump thread stack depth\n+         */\n+        public static int MAX_DUMP_STACK_DEPTH = 500;", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5ODU4Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365698587", "bodyText": "SEND -> TRANSPORT", "author": "wu-sheng", "createdAt": "2020-01-13T09:11:47Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;\n+\n+        /**\n+         * Max dump thread stack depth\n+         */\n+        public static int MAX_DUMP_STACK_DEPTH = 500;\n+\n+        /**\n+         * Snapshot send to backend channel size\n+         */\n+        public static int SNAPSHOT_SEND_CHANNEL_SIZE = 2;", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwMDcwOA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365700708", "bodyText": "Same about the name. And is 50 enough? From my understanding, we do thread dump every 10ms, then we could have 100 in one second. I think as we could collect 5 parallel, you will highly trigger queue abandon mode easily.\nI suggest at least 5 * 500. @kezhenxu94 What do you think?", "author": "wu-sheng", "createdAt": "2020-01-13T09:17:33Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;\n+\n+        /**\n+         * Max monitor segment time(minutes), if current segment monitor time out of limit, then stop it.\n+         */\n+        public static int MAX_MONITOR_TIME = 10;\n+\n+        /**\n+         * Max dump thread stack depth\n+         */\n+        public static int MAX_DUMP_STACK_DEPTH = 500;\n+\n+        /**\n+         * Snapshot send to backend channel size\n+         */\n+        public static int SNAPSHOT_SEND_CHANNEL_SIZE = 2;\n+\n+        /**\n+         * Snapshot send to backend buffer size\n+         */\n+        public static int SNAPSHOT_SEND_BUFFER_SIZE = 50;", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkwMTY2Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365901662", "bodyText": "Change to only one thread to process the profile task. So don't use DataCarrier anymore. Change to using LinkedBlockingQueue such as sniffer JVMService. using buffer size 500.", "author": "mrproliu", "createdAt": "2020-01-13T16:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwMDcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwMzMxNQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365703315", "bodyText": "-> Check whether the new segment suitable for profiling.", "author": "wu-sheng", "createdAt": "2020-01-13T09:24:16Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java", "diffHunk": "@@ -115,4 +115,10 @@\n      * @param span to be stopped.\n      */\n     void asyncStop(AsyncSpan span);\n+\n+    /**\n+     * Check current creating operation can add profiling, if true, it will start profiling", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwNDEwOQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365704109", "bodyText": "Rename to prepareProfiling(String firstSpanOPName)", "author": "wu-sheng", "createdAt": "2020-01-13T09:26:05Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/AbstractTracerContext.java", "diffHunk": "@@ -115,4 +115,10 @@\n      * @param span to be stopped.\n      */\n     void asyncStop(AsyncSpan span);\n+\n+    /**\n+     * Check current creating operation can add profiling, if true, it will start profiling\n+     * @param operationName\n+     */\n+    void checkAndAddProfiling(String operationName);", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwNjIyMA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365706220", "bodyText": "PARALLELS_THREAD_COUNT -> MAX_PARALLEL", "author": "wu-sheng", "createdAt": "2020-01-13T09:30:41Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/conf/Config.java", "diffHunk": "@@ -148,6 +148,31 @@\n          * If true, skywalking agent will enable profile when user create a new profile task. Otherwise disable profile.\n          */\n         public static boolean ACTIVE = true;\n+\n+        /**\n+         * Parallel monitor segment thread count\n+         */\n+        public static int PARALLELS_THREAD_COUNT = 5;", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwODk4NQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365708985", "bodyText": "Using PROFILING_THREAD_SELECTOR as index, I assume there is out of bound risk.", "author": "wu-sheng", "createdAt": "2020-01-13T09:37:22Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -84,6 +95,33 @@ public void run() {\n         }, timeToProcessMills, TimeUnit.MILLISECONDS);\n     }\n \n+    /**\n+     * check and add {@link TraceSegment} profiling\n+     * @param segment\n+     * @param operationName\n+     * @return has add to profiling\n+     */\n+    public boolean addProfiling(TraceSegment segment, String operationName) {\n+        // get current monitoring task and check endpoint name, is need profiling\n+        final ProfileTaskExecutionContext executionContext = taskExecutionContext.get();\n+        if (executionContext == null) {\n+            return false;\n+        }\n+        if (!Objects.equal(executionContext.getTask().getEndpointName(), operationName)) {\n+            return false;\n+        }\n+\n+        // check has slot to add\n+        final ProfilingThread profilingThread = PROFILING_THREADS[PROFILING_THREAD_SELECTOR.getAndIncrement()];", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxMDcwNQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365710705", "bodyText": "Are you creating so many threads for profiling tasks? I prefer to do this by using only one thread only. And don't create and dispose the thread every time. This is dangerous for JVM from my understanding. @kezhenxu94 @arugal what do you think?", "author": "wu-sheng", "createdAt": "2020-01-13T09:41:19Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -38,13 +45,17 @@\n  * @author MrPro\n  */\n @DefaultImplementor\n-public class ProfileTaskExecutionService implements BootService {\n+public class ProfileTaskExecutionService implements BootService, TracingContextListener {\n \n     private static final ILog logger = LogManager.getLogger(ProfileTaskExecutionService.class);\n \n     // add a schedule while waiting for the task to start or finish\n     private final static ScheduledExecutorService PROFILE_TASK_SCHEDULE = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"PROFILE-TASK-SCHEDULE\"));\n \n+    // profiling segment thread array, Config.Profile.PARALLELS_THREAD_COUNT\n+    private final static ProfilingThread[] PROFILING_THREADS = new ProfilingThread[Config.Profile.PARALLELS_THREAD_COUNT];", "originalCommit": "3b051f5c72119fffaad513e0d6c07b787cc2f447", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5OTkxOA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r365899918", "bodyText": "Change profile using the single one thread to process. Please check.", "author": "mrproliu", "createdAt": "2020-01-13T16:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxMDcwNQ=="}], "type": "inlineReview"}, {"oid": "078f6b8a7994e386ca72c77627d96f2e97e3d0bb", "url": "https://github.com/apache/skywalking/commit/078f6b8a7994e386ca72c77627d96f2e97e3d0bb", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-13T10:51:18Z", "type": "commit"}, {"oid": "2a4eee23662706757ca46d0ce0837677b93251da", "url": "https://github.com/apache/skywalking/commit/2a4eee23662706757ca46d0ce0837677b93251da", "message": "resolve names", "committedDate": "2020-01-13T12:14:07Z", "type": "commit"}, {"oid": "44b6873eaacecc9fca954ad7a30d7cc270cd2dcd", "url": "https://github.com/apache/skywalking/commit/44b6873eaacecc9fca954ad7a30d7cc270cd2dcd", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-13T12:15:21Z", "type": "commit"}, {"oid": "286d221ea2b54023798ae863a0222cc7f28ad865", "url": "https://github.com/apache/skywalking/commit/286d221ea2b54023798ae863a0222cc7f28ad865", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-13T13:33:28Z", "type": "commit"}, {"oid": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "url": "https://github.com/apache/skywalking/commit/4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "message": "change profile to single one thread run.", "committedDate": "2020-01-13T16:28:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxNzgzMA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366317830", "bodyText": "Why use full class name?", "author": "wu-sheng", "createdAt": "2020-01-14T12:46:03Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.agent.Downstream;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.LinkedList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<ProfileTaskSegmentSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     * @param snapshot\n+     */\n+    public void addProfilingSnapshot(ProfileTaskSegmentSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);\n+    }\n+\n+    /**\n+     * notify backend profile task has finish\n+     * @param task\n+     */\n+    public void notifyProfileTaskFinish(ProfileTask task) {\n+        try {\n+            final ProfileTaskFinishReport.Builder reportBuilder = ProfileTaskFinishReport.newBuilder();\n+            // sniffer info\n+            reportBuilder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+            // task info\n+            reportBuilder.setTaskId(task.getTaskId());\n+\n+            // send data\n+            profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).reportTaskFinish(reportBuilder.build());\n+        } catch (Throwable e) {\n+            logger.error(e, \"Notify profile task finish to backend fail.\");\n+        }\n+    }\n+\n+    /**\n+     * send segment snapshot\n+     */\n+    private class SnapshotSender implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    LinkedList<ProfileTaskSegmentSnapshot> buffer = new LinkedList<ProfileTaskSegmentSnapshot>();\n+                    snapshotQueue.drainTo(buffer);\n+                    if (buffer.size() > 0) {\n+                        final GRPCStreamServiceStatus status = new GRPCStreamServiceStatus(false);\n+                        StreamObserver<org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot> snapshotStreamObserver = profileTaskStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).collectSnapshot(new StreamObserver<Downstream>() {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxNzk1Mw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366317953", "bodyText": "Same here.", "author": "wu-sheng", "createdAt": "2020-01-14T12:46:24Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.agent.Downstream;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.LinkedList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<ProfileTaskSegmentSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     * @param snapshot\n+     */\n+    public void addProfilingSnapshot(ProfileTaskSegmentSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);\n+    }\n+\n+    /**\n+     * notify backend profile task has finish\n+     * @param task\n+     */\n+    public void notifyProfileTaskFinish(ProfileTask task) {\n+        try {\n+            final ProfileTaskFinishReport.Builder reportBuilder = ProfileTaskFinishReport.newBuilder();\n+            // sniffer info\n+            reportBuilder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+            // task info\n+            reportBuilder.setTaskId(task.getTaskId());\n+\n+            // send data\n+            profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).reportTaskFinish(reportBuilder.build());\n+        } catch (Throwable e) {\n+            logger.error(e, \"Notify profile task finish to backend fail.\");\n+        }\n+    }\n+\n+    /**\n+     * send segment snapshot\n+     */\n+    private class SnapshotSender implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    LinkedList<ProfileTaskSegmentSnapshot> buffer = new LinkedList<ProfileTaskSegmentSnapshot>();\n+                    snapshotQueue.drainTo(buffer);\n+                    if (buffer.size() > 0) {\n+                        final GRPCStreamServiceStatus status = new GRPCStreamServiceStatus(false);\n+                        StreamObserver<org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot> snapshotStreamObserver = profileTaskStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).collectSnapshot(new StreamObserver<Downstream>() {\n+                            @Override\n+                            public void onNext(Downstream downstream) {\n+                            }\n+\n+                            @Override\n+                            public void onError(Throwable throwable) {\n+                                status.finished();\n+                                if (logger.isErrorEnable()) {\n+                                    logger.error(throwable, \"Send profile segment snapshot to collector fail with a grpc internal exception.\");\n+                                }\n+                                ServiceManager.INSTANCE.findService(GRPCChannelManager.class).reportError(throwable);\n+                            }\n+\n+                            @Override\n+                            public void onCompleted() {\n+                                status.finished();\n+                            }\n+                        });\n+                        for (ProfileTaskSegmentSnapshot snapshot : buffer) {\n+                            final org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot transformSnapshot = snapshot.transform();", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMxODEzNQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366318135", "bodyText": "You have known the max size, using ArrayList please.", "author": "wu-sheng", "createdAt": "2020-01-14T12:46:49Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.agent.Downstream;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.LinkedList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<ProfileTaskSegmentSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     * @param snapshot\n+     */\n+    public void addProfilingSnapshot(ProfileTaskSegmentSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);\n+    }\n+\n+    /**\n+     * notify backend profile task has finish\n+     * @param task\n+     */\n+    public void notifyProfileTaskFinish(ProfileTask task) {\n+        try {\n+            final ProfileTaskFinishReport.Builder reportBuilder = ProfileTaskFinishReport.newBuilder();\n+            // sniffer info\n+            reportBuilder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+            // task info\n+            reportBuilder.setTaskId(task.getTaskId());\n+\n+            // send data\n+            profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).reportTaskFinish(reportBuilder.build());\n+        } catch (Throwable e) {\n+            logger.error(e, \"Notify profile task finish to backend fail.\");\n+        }\n+    }\n+\n+    /**\n+     * send segment snapshot\n+     */\n+    private class SnapshotSender implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    LinkedList<ProfileTaskSegmentSnapshot> buffer = new LinkedList<ProfileTaskSegmentSnapshot>();", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyMzE3Mw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366323173", "bodyText": "Don't use Config.Profile.MAX_DURATION in the initial codes. Move this initialization into the constructor. Because there may be a chance, someone accidentally loads this class before Config initialization.", "author": "wu-sheng", "createdAt": "2020-01-14T12:58:51Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyMzQ4NQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366323485", "bodyText": "Don't use Config.Profile.MAX_DURATION in the initial codes. Move this initialization into the constructor. Because there may be a chance, someone accidentally loads this class before Config initialization.", "author": "wu-sheng", "createdAt": "2020-01-14T12:59:38Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyNDMxOQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366324319", "bodyText": "PROFILE-MONITOR-THREAD -> PROFILING-THREAD . We don't use the word monitor, because SkyWalking is monitoring many places :)", "author": "wu-sheng", "createdAt": "2020-01-14T13:01:41Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -108,36 +139,49 @@ public void run() {\n     /**\n      * stop profile task, remove context data\n      */\n-    private synchronized void stopCurrentProfileTask(ProfileTaskExecutionContext needToStop) {\n+    synchronized void stopCurrentProfileTask(ProfileTaskExecutionContext needToStop) {\n         // stop same context only\n         if (needToStop == null || !taskExecutionContext.compareAndSet(needToStop, null)) {\n             return;\n         }\n \n+        // current execution stop running\n+        needToStop.setRunning(false);\n+\n         // remove task\n         profileTaskList.remove(needToStop.getTask());\n \n-        // TODO notify OAP current profile task execute finish\n+        // notify profiling task has finished\n+        ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class).notifyProfileTaskFinish(needToStop.getTask());\n     }\n \n     @Override\n     public void prepare() throws Throwable {\n-\n     }\n \n     @Override\n     public void boot() throws Throwable {\n-\n+        // init PROFILE_THREAD and start\n+        profileThread = new ProfileThread();\n+        profileThread.setDaemon(true);\n+        profileThread.setName(\"PROFILE-MONITOR-THREAD\");", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyNDkyNg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366324926", "bodyText": "checkSegmentProfilingCanContinue -> isSegmentProfilingContinuable. Let's reduce the usage of check.", "author": "wu-sheng", "createdAt": "2020-01-14T13:03:06Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();\n+\n+        // stack depth is zero, means thread is already run finished\n+        if (stackTrace.length == 0) {\n+            return false;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        // build snapshot and send\n+        ProfileTaskSegmentSnapshot snapshot = new ProfileTaskSegmentSnapshot(segmentContext, segmentContext.getCurrentAndIncrementSequence(), currentTime, stackList);\n+        profileTaskChannelService.addProfilingSnapshot(snapshot);\n+        return true;\n+    }\n+\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        // className.methodName:lineNumber\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * check segment profiling is should continue\n+     * @param context\n+     * @return\n+     */\n+    private boolean checkSegmentProfilingCanContinue(ProfilingSegmentContext context) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyNzYzOA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366327638", "bodyText": "Why all these are full names?", "author": "wu-sheng", "createdAt": "2020-01-14T13:09:20Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskSegmentSnapshot.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentStack;\n+\n+import java.util.List;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfileTaskSegmentSnapshot {\n+\n+    // profiling segment context\n+    private final ProfilingSegmentContext segmentContext;\n+\n+    // dump info\n+    private final int sequence;\n+    private final long time;\n+    private final List<String> stackList;\n+\n+    public ProfileTaskSegmentSnapshot(ProfilingSegmentContext segmentContext, int sequence, long time, List<String> stackList) {\n+        this.segmentContext = segmentContext;\n+        this.sequence = sequence;\n+        this.time = time;\n+        this.stackList = stackList;\n+    }\n+\n+    /**\n+     * transform to gRPC data\n+     * @return\n+     */\n+    public org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot transform() {\n+        final org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot.Builder builder = org.apache.skywalking.apm.network.language.profile.ProfileTaskSegmentSnapshot.newBuilder();", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyODMwMw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366328303", "bodyText": "#profiling is inside #run, why check this again?", "author": "wu-sheng", "createdAt": "2020-01-14T13:10:50Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyOTI0Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366329242", "bodyText": "TracingContext#finish has a listener mechanism, you don't need to check every time, you should set up a listener, then you could remove when you get the notification.\nBut you should notice, there is a segment finish event right now, but tracing context has an async mode today, so you need to add a notification, named as notifyAfterMainThreadFinish.", "author": "wu-sheng", "createdAt": "2020-01-14T13:12:43Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();\n+\n+        // stack depth is zero, means thread is already run finished\n+        if (stackTrace.length == 0) {\n+            return false;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        // build snapshot and send\n+        ProfileTaskSegmentSnapshot snapshot = new ProfileTaskSegmentSnapshot(segmentContext, segmentContext.getCurrentAndIncrementSequence(), currentTime, stackList);\n+        profileTaskChannelService.addProfilingSnapshot(snapshot);\n+        return true;\n+    }\n+\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        // className.methodName:lineNumber\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * check segment profiling is should continue\n+     * @param context\n+     * @return\n+     */\n+    private boolean checkSegmentProfilingCanContinue(ProfilingSegmentContext context) {\n+        // check segment still executing\n+        if (!context.getSegmentIsRunning()) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzMDg0Ng==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366330846", "bodyText": "Don't check this every time, once you don't get the notification event(notifyAfterMainThreadFinish), it is safe to continue.", "author": "wu-sheng", "createdAt": "2020-01-14T13:16:18Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();\n+\n+        // stack depth is zero, means thread is already run finished\n+        if (stackTrace.length == 0) {\n+            return false;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        // build snapshot and send\n+        ProfileTaskSegmentSnapshot snapshot = new ProfileTaskSegmentSnapshot(segmentContext, segmentContext.getCurrentAndIncrementSequence(), currentTime, stackList);\n+        profileTaskChannelService.addProfilingSnapshot(snapshot);\n+        return true;\n+    }\n+\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        // className.methodName:lineNumber\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * check segment profiling is should continue\n+     * @param context\n+     * @return\n+     */\n+    private boolean checkSegmentProfilingCanContinue(ProfilingSegmentContext context) {\n+        // check segment still executing\n+        if (!context.getSegmentIsRunning()) {\n+            return false;\n+        }\n+\n+        // check is out of limit monitor time\n+        if (System.currentTimeMillis() - context.getProfilingStartTime() > MAX_PROFILING_TIME_MILLS) {\n+            return false;\n+        }\n+\n+        // check segment executing thread is still running\n+        if (!context.getProfilingThread().isAlive()) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNjIxNA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366336214", "bodyText": "Renaming to ThreadProfiler. Don't use context always. You need to avoid two similar names in one place, it is very confusing when reading the codes.", "author": "wu-sheng", "createdAt": "2020-01-14T13:27:52Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNjMwNQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366336305", "bodyText": "Rename to nextSeq", "author": "wu-sheng", "createdAt": "2020-01-14T13:28:05Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {\n+\n+    // current segment id\n+    private final TraceSegment segment;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // current segment running status, each dump will judge it. Will set false when trace notification\n+    private volatile boolean segmentIsRunning = true;\n+    // profiling start time\n+    private long profilingStartTime;\n+\n+    // after min duration threshold check, it will start dump\n+    private boolean startDump = false;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ProfilingSegmentContext(TraceSegment segment, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.segment = segment;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingStartTime = System.currentTimeMillis();\n+    }\n+\n+    public TraceSegment getSegment() {\n+        return segment;\n+    }\n+\n+    public Thread getProfilingThread() {\n+        return profilingThread;\n+    }\n+\n+    public boolean getSegmentIsRunning() {\n+        return segmentIsRunning;\n+    }\n+\n+    public void setSegmentIsRunning(boolean segmentIsRunning) {\n+        this.segmentIsRunning = segmentIsRunning;\n+    }\n+\n+    public ProfileTaskExecutionContext getExecutionContext() {\n+        return executionContext;\n+    }\n+\n+    public long getProfilingStartTime() {\n+        return profilingStartTime;\n+    }\n+\n+    public boolean getStartDump() {\n+        return startDump;\n+    }\n+\n+    public void setStartDump(boolean startDump) {\n+        this.startDump = startDump;\n+    }\n+\n+    /**\n+     * get current sequence then increment it\n+     * @return\n+     */\n+    public int getCurrentAndIncrementSequence() {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNzUyMQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366337521", "bodyText": "You should be able to use segment#equal, right? Also, you should begin to move the logic method into the entity.\nThis should be profilingSegmentSlot[slot].matchWith(segment.", "author": "wu-sheng", "createdAt": "2020-01-14T13:30:33Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzNzk3Ng==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366337976", "bodyText": "What is segmentIsRunning=false?", "author": "wu-sheng", "createdAt": "2020-01-14T13:31:25Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzODc0NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366338744", "bodyText": "No matter how many times you check the thread#isAlive, you still could face the thread is not inactive or dead at here. Try/catch this, and remove all unnecessary check.", "author": "wu-sheng", "createdAt": "2020-01-14T13:33:00Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {\n+                        slot.setStartDump(true);\n+                    }\n+\n+                }\n+            }\n+\n+            // sleep to next period\n+            // if out of period, sleep one period\n+            long needToSleep = (currentLoopStartTime + maxSleepPeriod) - System.currentTimeMillis();\n+            needToSleep = needToSleep > 0 ? needToSleep : maxSleepPeriod;\n+            Thread.sleep(needToSleep);\n+        }\n+    }\n+\n+    /**\n+     * dump segemnt thread stack\n+     * @param segmentContext\n+     * @return\n+     */\n+    private boolean dumpSegment(ProfilingSegmentContext segmentContext) {\n+        // dump stack\n+        if (!checkSegmentProfilingCanContinue(segmentContext)) {\n+            return false;\n+        }\n+\n+        return dumpThread(segmentContext);\n+    }\n+\n+    /**\n+     * dump thread stack, and push data to backend\n+     * @param segmentContext\n+     * @return still can dump\n+     */\n+    private boolean dumpThread(ProfilingSegmentContext segmentContext) {\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        final StackTraceElement[] stackTrace = segmentContext.getProfilingThread().getStackTrace();", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzOTM1Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366339357", "bodyText": "This doesn't match the profilingStartTime. Is that a bug?", "author": "wu-sheng", "createdAt": "2020-01-14T13:34:15Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {\n+\n+    // current segment id\n+    private final TraceSegment segment;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // current segment running status, each dump will judge it. Will set false when trace notification\n+    private volatile boolean segmentIsRunning = true;\n+    // profiling start time\n+    private long profilingStartTime;\n+\n+    // after min duration threshold check, it will start dump\n+    private boolean startDump = false;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ProfilingSegmentContext(TraceSegment segment, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.segment = segment;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingStartTime = System.currentTimeMillis();\n+    }\n+\n+    public TraceSegment getSegment() {\n+        return segment;\n+    }\n+\n+    public Thread getProfilingThread() {\n+        return profilingThread;\n+    }\n+\n+    public boolean getSegmentIsRunning() {\n+        return segmentIsRunning;\n+    }\n+\n+    public void setSegmentIsRunning(boolean segmentIsRunning) {\n+        this.segmentIsRunning = segmentIsRunning;\n+    }\n+\n+    public ProfileTaskExecutionContext getExecutionContext() {\n+        return executionContext;\n+    }\n+\n+    public long getProfilingStartTime() {\n+        return profilingStartTime;\n+    }\n+\n+    public boolean getStartDump() {\n+        return startDump;\n+    }\n+\n+    public void setStartDump(boolean startDump) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMzOTgxNg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366339816", "bodyText": "This should compare to segment startTime. slot#startTIme is not necessary.", "author": "wu-sheng", "createdAt": "2020-01-14T13:35:16Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {\n+        // check has available slot\n+        AtomicInteger currentProfilingCount = taskExecutionContext.getCurrentProfilingCount();\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return null;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return null;\n+        }\n+\n+        ProfilingSegmentContext[] profilingSegmentSlot = taskExecutionContext.getProfilingSegmentSlot();\n+        final ProfilingSegmentContext segmentContext = new ProfilingSegmentContext(segment, Thread.currentThread(), taskExecutionContext);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return segmentContext;\n+    }\n+\n+    /**\n+     * find segment and clear on slot\n+     *\n+     * @param segment\n+     */\n+    public void stopSegmentProfile(TraceSegment segment) {\n+        ProfileTaskExecutionContext currentExecutionContext = profileTaskExecutionService.getCurrentTaskExecutionContext();\n+        if (currentExecutionContext == null) {\n+            return;\n+        }\n+\n+        // find current segment and clear it\n+        boolean find = false;\n+        ProfilingSegmentContext[] profilingSegmentSlot = currentExecutionContext.getProfilingSegmentSlot();\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ProfilingSegmentContext currentSlotSegment = profilingSegmentSlot[slot];\n+            if (currentSlotSegment != null && Objects.equal(profilingSegmentSlot[slot].getSegment().getTraceSegmentId(), segment.getTraceSegmentId())) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentSlotSegment.setSegmentIsRunning(false);\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentExecutionContext.getCurrentProfilingCount().addAndGet(-1);\n+        }\n+    }\n+\n+    /**\n+     * shutdown profiling thread\n+     */\n+    public void shutdown() {\n+        running = false;\n+    }\n+\n+    /**\n+     * start profiling\n+     * @param executionContext\n+     */\n+    private void profiling(ProfileTaskExecutionContext executionContext) throws InterruptedException {\n+\n+        int maxSleepPeriod = executionContext.getTask().getThreadDumpPeriod();\n+        int minDurationThreshold = executionContext.getTask().getMinDurationThreshold();\n+\n+        // run loop when current task still running\n+        long currentLoopStartTime = -1;\n+        while (checkCanKeepRunning(executionContext)) {\n+            currentLoopStartTime = System.currentTimeMillis();\n+\n+            // each all slot\n+            for (ProfilingSegmentContext slot : executionContext.getProfilingSegmentSlot()) {\n+                if (slot == null) {\n+                    continue;\n+                }\n+\n+                // check is already start dump stack\n+                if (slot.getStartDump()) {\n+\n+                    // dump stack\n+                    if (!dumpSegment(slot)) {\n+                        stopSegmentProfile(slot.getSegment());\n+                        continue;\n+                    }\n+\n+                } else {\n+\n+                    // check segment running time\n+                    if (System.currentTimeMillis() - slot.getProfilingStartTime() > minDurationThreshold) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MDQwMg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366340402", "bodyText": "startDump -> enum profilingStatus, which has values(READY/PROFILING/STOPPED)", "author": "wu-sheng", "createdAt": "2020-01-14T13:36:24Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfilingSegmentContext.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfilingSegmentContext {\n+\n+    // current segment id\n+    private final TraceSegment segment;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // current segment running status, each dump will judge it. Will set false when trace notification\n+    private volatile boolean segmentIsRunning = true;\n+    // profiling start time\n+    private long profilingStartTime;\n+\n+    // after min duration threshold check, it will start dump\n+    private boolean startDump = false;", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MDk2NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366340964", "bodyText": "checkAndAddSegmentContext -> attempProfiling", "author": "wu-sheng", "createdAt": "2020-01-14T13:37:30Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.trace.TraceSegment;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread extends Thread {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // per segment max profiling time (millisecond)\n+    private static final long MAX_PROFILING_TIME_MILLS = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+\n+    // current thread running status\n+    private volatile boolean running = true;\n+\n+    // wait and notify has new profile task\n+    private final LinkedBlockingQueue<ProfileTaskExecutionContext> executionContextListener = new LinkedBlockingQueue<>();\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread() {\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        while (running) {\n+            // waiting new profile task\n+            ProfileTaskExecutionContext taskExecutionContext = null;\n+            try {\n+                taskExecutionContext = executionContextListener.take();\n+            } catch (InterruptedException e) {\n+                continue;\n+            }\n+\n+            try {\n+                profiling(taskExecutionContext);\n+            } catch (InterruptedException e) {\n+                // ignore interrupted\n+                continue;\n+            } catch (Exception e) {\n+                logger.error(e, \"Profiling task fail. taskId:{}\", taskExecutionContext.getTask().getTaskId());\n+            } finally {\n+                // finally stop current profiling task, tell execution service task has stop\n+                profileTaskExecutionService.stopCurrentProfileTask(taskExecutionContext);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * notify have new task need to process\n+     */\n+    void processNewProfileTask(ProfileTaskExecutionContext context) {\n+        executionContextListener.add(context);\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param segment\n+     * @return\n+     */\n+    public ProfilingSegmentContext checkAndAddSegmentContext(TraceSegment segment, ProfileTaskExecutionContext taskExecutionContext) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MTY5OQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366341699", "bodyText": "You should use TracingContext rather than segment as the parameter. segment is a collection of spans, only tracingContext has status.", "author": "wu-sheng", "createdAt": "2020-01-14T13:38:57Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,6 +463,17 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void prepareProfiling(String firstSpanOPName) {\n+        if (segment.getProfiling()) {\n+            return;\n+        }\n+\n+        // update profiling status\n+        final ProfileTaskExecutionService profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        segment.setProfiling(profileTaskExecutionService.addProfiling(segment, firstSpanOPName));", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MTk1OQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366341959", "bodyText": "Why need this check?", "author": "wu-sheng", "createdAt": "2020-01-14T13:39:29Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,6 +463,17 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void prepareProfiling(String firstSpanOPName) {\n+        if (segment.getProfiling()) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDA3MA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366344070", "bodyText": "Why need this method? I think we just need to add a parameter in the TracingContext constructor.", "author": "wu-sheng", "createdAt": "2020-01-14T13:43:28Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,6 +463,17 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void prepareProfiling(String firstSpanOPName) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDU5Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366344597", "bodyText": "If no available slot, you don't need the following steps.", "author": "wu-sheng", "createdAt": "2020-01-14T13:44:33Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -84,6 +92,27 @@ public void run() {\n         }, timeToProcessMills, TimeUnit.MILLISECONDS);\n     }\n \n+    /**\n+     * check and add {@link TraceSegment} profiling\n+     * @param segment\n+     * @param operationName\n+     * @return has add to profiling\n+     */\n+    public boolean addProfiling(TraceSegment segment, String operationName) {\n+        // get current monitoring task and check endpoint name, is need profiling\n+        final ProfileTaskExecutionContext executionContext = taskExecutionContext.get();\n+        if (executionContext == null) {\n+            return false;\n+        }\n+        if (!Objects.equal(executionContext.getTask().getEndpointName(), operationName)) {", "originalCommit": "4ff1c2bdbfc9f4991702b5c609631412ed938b7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDg0Mw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366344843", "bodyText": "This is not must be endpoint name. This is only first span OP name.", "author": "wu-sheng", "createdAt": "2020-01-14T13:45:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDU5Nw=="}], "type": "inlineReview"}, {"oid": "12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "url": "https://github.com/apache/skywalking/commit/12edb7da0c07ef7e0c5841a85e42fb13451c2e72", "message": "1. change to the ArrayList, because known the max size\n2. rename issue resolved", "committedDate": "2020-01-15T02:14:05Z", "type": "commit"}, {"oid": "40aaf568a866786d171915baf59f53ed688d6ea4", "url": "https://github.com/apache/skywalking/commit/40aaf568a866786d171915baf59f53ed688d6ea4", "message": "add profiling status enum", "committedDate": "2020-01-15T02:37:36Z", "type": "commit"}, {"oid": "3f1d8fcca5b8091cee094b6cc59400713960491b", "url": "https://github.com/apache/skywalking/commit/3f1d8fcca5b8091cee094b6cc59400713960491b", "message": "change sniffer use full name issue", "committedDate": "2020-01-15T02:54:19Z", "type": "commit"}, {"oid": "c164f0d2fb2bcc5a852b95c7b29dfba98f3e072e", "url": "https://github.com/apache/skywalking/commit/c164f0d2fb2bcc5a852b95c7b29dfba98f3e072e", "message": "1. remove `prepareProfiling` method, build profiling status when construct `TracingContext`\n2. add `TracingThreadListenerManager`, notify when tracing main thread finish\n3. change ProfileThread start when process new profile task", "committedDate": "2020-01-15T09:15:37Z", "type": "commit"}, {"oid": "1b7b5fc8bbe7192ac9ff00dec946e8c5d7bc8cc6", "url": "https://github.com/apache/skywalking/commit/1b7b5fc8bbe7192ac9ff00dec946e8c5d7bc8cc6", "message": "remove unnecessary getter", "committedDate": "2020-01-15T09:31:26Z", "type": "commit"}, {"oid": "98dca63fd760af13060c8c36aaa4505330c80dd6", "url": "https://github.com/apache/skywalking/commit/98dca63fd760af13060c8c36aaa4505330c80dd6", "message": "add test assert error message", "committedDate": "2020-01-15T09:52:44Z", "type": "commit"}, {"oid": "e59c4e41fb77f2bf25ab1c600d18fc15aa3db52b", "url": "https://github.com/apache/skywalking/commit/e59c4e41fb77f2bf25ab1c600d18fc15aa3db52b", "message": "adding `AgentServiceRule`", "committedDate": "2020-01-15T10:09:48Z", "type": "commit"}, {"oid": "39a8b2eac33fc27007aed11ffee529143928de16", "url": "https://github.com/apache/skywalking/commit/39a8b2eac33fc27007aed11ffee529143928de16", "message": "revert original assert", "committedDate": "2020-01-15T10:21:12Z", "type": "commit"}, {"oid": "c2275c99449726366732c65c1444f996796bc32b", "url": "https://github.com/apache/skywalking/commit/c2275c99449726366732c65c1444f996796bc32b", "message": "remove unnecessary getter", "committedDate": "2020-01-15T12:16:20Z", "type": "commit"}, {"oid": "ff34355adf6cbb90b444a8543be816c55d3da913", "url": "https://github.com/apache/skywalking/commit/ff34355adf6cbb90b444a8543be816c55d3da913", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-15T12:25:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1Mzk0OQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366853949", "bodyText": "You don't need to findService every time. Please add a field to hold the ref.", "author": "wu-sheng", "createdAt": "2020-01-15T12:40:24Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -92,15 +93,27 @@\n \n     private volatile boolean running;\n \n+    private final long createTime;\n+\n+    /**\n+     * profiling status\n+     */\n+    private final boolean profiling;\n+\n     /**\n      * Initialize all fields with default value.\n      */\n-    TracingContext() {\n+    TracingContext(String firstOPName) {\n         this.segment = new TraceSegment();\n         this.spanIdGenerator = 0;\n         samplingService = ServiceManager.INSTANCE.findService(SamplingService.class);\n         isRunningInAsyncMode = false;\n+        createTime = System.currentTimeMillis();\n         running = true;\n+\n+        // profiling status\n+        final ProfileTaskExecutionService profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NDQyMg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366854422", "bodyText": "Notify current tracing context main thread has already execute finished. -> Notify after tracing finished in the main thread.", "author": "wu-sheng", "createdAt": "2020-01-15T12:41:42Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -497,6 +510,11 @@ private void finish() {\n                 TracingContext.ListenerManager.notifyFinish(finishedSegment);\n \n                 running = false;\n+\n+                /**\n+                 * Notify current tracing context main thread has already execute finished.", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NDg1MQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366854851", "bodyText": "This notification should not be in (!isRunningInAsyncMode || asyncSpanCounter.get() == 0)). The condition means async finished.  You just need activeSpanStack.isEmpty() && running.", "author": "wu-sheng", "createdAt": "2020-01-15T12:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NDQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTMwNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366855307", "bodyText": "Why does the segment still need this? This should be moved into TracingContext.", "author": "wu-sheng", "createdAt": "2020-01-15T12:44:10Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/TraceSegment.java", "diffHunk": "@@ -74,6 +74,9 @@\n \n     private final long createTime;\n \n+    // segment is profiling\n+    private volatile boolean profiling;", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2MjEyNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366862127", "bodyText": "threadProfilerSlot  -> threadProfilerSlots", "author": "wu-sheng", "createdAt": "2020-01-15T13:00:55Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +37,101 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2Mjg3Mw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366862873", "bodyText": "Why don't move this into L118, then you don't need find flag and related codes.", "author": "wu-sheng", "createdAt": "2020-01-15T13:02:38Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +37,101 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     */\n+    public void stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean find = false;\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlot[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlot[slot] = null;\n+\n+                // setting stop running\n+                currentProfiler.stopProfiling();\n+                find = true;\n+                break;\n+            }\n+        }\n+\n+        // decrease profile count\n+        if (find) {\n+            currentProfilingCount.addAndGet(-1);", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2NDIyOA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366864228", "bodyText": "As this method could be called in another thread, you need to set the whole array again, and add volatile, read solution 2, https://www.javamex.com/tutorials/volatile_arrays.shtml", "author": "wu-sheng", "createdAt": "2020-01-15T13:05:51Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +37,101 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private final ThreadProfiler[] profilingSegmentSlot = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            if (profilingSegmentSlot[slot] == null) {\n+                profilingSegmentSlot[slot] = segmentContext;\n+                break;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     */\n+    public void stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean find = false;\n+        for (int slot = 0; slot < profilingSegmentSlot.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlot[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlot[slot] = null;", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2NzU3NQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366867575", "bodyText": "segment should not exist. Dump the executing thread stack.", "author": "wu-sheng", "createdAt": "2020-01-15T13:13:39Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MjUyNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r366872527", "bodyText": "Is this for shutdown process only?", "author": "wu-sheng", "createdAt": "2020-01-15T13:25:00Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileThread.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+\n+/**\n+ * Profile task process thread, dump segment executing thread stack.\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileThread implements Runnable {\n+\n+    private static final ILog logger = LogManager.getLogger(ProfileThread.class);\n+\n+    // profiling task context\n+    private final ProfileTaskExecutionContext taskExecutionContext;\n+\n+    private final ProfileTaskExecutionService profileTaskExecutionService;\n+    private final ProfileTaskChannelService profileTaskChannelService;\n+\n+    public ProfileThread(ProfileTaskExecutionContext taskExecutionContext) {\n+        this.taskExecutionContext = taskExecutionContext;\n+        profileTaskExecutionService = ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class);\n+        profileTaskChannelService = ServiceManager.INSTANCE.findService(ProfileTaskChannelService.class);\n+    }\n+\n+    @Override\n+    public void run() {\n+\n+        try {\n+            profiling(taskExecutionContext);\n+        } catch (InterruptedException e) {\n+            // ignore interrupted\n+            // means current task has stopped", "originalCommit": "ff34355adf6cbb90b444a8543be816c55d3da913", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5NTA2NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367195064", "bodyText": "Yes, I think it will only end when other threads notify him, unless he actively raises an exception.", "author": "mrproliu", "createdAt": "2020-01-16T01:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MjUyNw=="}], "type": "inlineReview"}, {"oid": "88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "url": "https://github.com/apache/skywalking/commit/88c1bd1ffd7c43b8e2c1e6fccf9ad5240ec983e2", "message": "resolve issues", "committedDate": "2020-01-16T02:13:29Z", "type": "commit"}, {"oid": "089245dedac4311d02abb431f9bd8a4224f88beb", "url": "https://github.com/apache/skywalking/commit/089245dedac4311d02abb431f9bd8a4224f88beb", "message": "reduce findService invoke", "committedDate": "2020-01-16T02:15:47Z", "type": "commit"}, {"oid": "901d867c2e2782f2ceaaf45e6ce9464c2296ec65", "url": "https://github.com/apache/skywalking/commit/901d867c2e2782f2ceaaf45e6ce9464c2296ec65", "message": "resolve style error", "committedDate": "2020-01-16T02:25:21Z", "type": "commit"}, {"oid": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "url": "https://github.com/apache/skywalking/commit/5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "message": "recheck profiling when change first span operatin name", "committedDate": "2020-01-16T06:07:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2NTA3MQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367265071", "bodyText": "tracingFinishInMainThread -> isFinishedInMainThread", "author": "wu-sheng", "createdAt": "2020-01-16T07:26:25Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/TracingContext.java", "diffHunk": "@@ -462,16 +485,34 @@ public boolean stopSpan(AbstractSpan span) {\n         finish();\n     }\n \n+    @Override\n+    public void profilingRecheck(AbstractSpan span, String operationName) {\n+        // only recheck first span\n+        if (span.getSpanId() != 0) {\n+            return;\n+        }\n+\n+        profiling = PROFILE_TASK_EXECUTION_SERVICE.profilingRecheck(this, segment.getTraceSegmentId(), operationName);\n+    }\n+\n     /**\n      * Finish this context, and notify all {@link TracingContextListener}s, managed by {@link\n-     * TracingContext.ListenerManager}\n+     * TracingContext.ListenerManager} and {@link TracingContext.TracingThreadListenerManager}\n      */\n     private void finish() {\n         if (isRunningInAsyncMode) {\n             asyncFinishLock.lock();\n         }\n         try {\n-            if (activeSpanStack.isEmpty() && running && (!isRunningInAsyncMode || asyncSpanCounter.get() == 0)) {\n+            boolean tracingFinishInMainThread = activeSpanStack.isEmpty() && running;", "originalCommit": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2NjAxMQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367266011", "bodyText": "I think we don't need ContextManager#profilingRecheck. There is a ref of tracingContext in the span, check AbstractTracingSpan. You should use it, it is better to keep profilingRecheck in private, right?", "author": "wu-sheng", "createdAt": "2020-01-16T07:29:43Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/context/trace/AbstractTracingSpan.java", "diffHunk": "@@ -203,6 +203,9 @@ public AbstractTracingSpan errorOccurred() {\n     public AbstractTracingSpan setOperationName(String operationName) {\n         this.operationName = operationName;\n         this.operationId = DictionaryUtil.nullValue();\n+\n+        // recheck profiling status\n+        ContextManager.profilingRecheck(this, operationName);", "originalCommit": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI3MjIzMA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367272230", "bodyText": "I think you missed the profilingSegmentSlots resign to make volatile works.", "author": "wu-sheng", "createdAt": "2020-01-16T07:50:27Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +163,20 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            if (profilingSegmentSlots[slot] == null) {\n+                profilingSegmentSlots[slot] = segmentContext;", "originalCommit": "5ce68bb1f8848bd6b9b9f26362847497f187a1fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2eb35150e7e9b12b5db8da725b547ea805a66b10", "url": "https://github.com/apache/skywalking/commit/2eb35150e7e9b12b5db8da725b547ea805a66b10", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-16T08:36:59Z", "type": "commit"}, {"oid": "9454d3fa28ca7469c1d5f04ef78a64d27144b11f", "url": "https://github.com/apache/skywalking/commit/9454d3fa28ca7469c1d5f04ef78a64d27144b11f", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-16T13:10:19Z", "type": "commit"}, {"oid": "b39a45d97d15928b2f274b0ac01a2cccf67b3b62", "url": "https://github.com/apache/skywalking/commit/b39a45d97d15928b2f274b0ac01a2cccf67b3b62", "message": "resolve issues\n1. remove `ContextManager#profilingRecheck`, only check on `TracingContext`\n2. rename comments\n3. resolve volatile array setting", "committedDate": "2020-01-17T02:41:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NzEyNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367747127", "bodyText": "Don't put the link here. The article is just reference, we don't have the license to broadcast it.", "author": "wu-sheng", "createdAt": "2020-01-17T02:47:37Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -174,6 +174,9 @@ private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSeg\n         for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n             if (profilingSegmentSlots[slot] == null) {\n                 profilingSegmentSlots[slot] = segmentContext;\n+\n+                // see https://www.javamex.com/tutorials/volatile_arrays.shtml, solution 2", "originalCommit": "b39a45d97d15928b2f274b0ac01a2cccf67b3b62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8821e0f98f0f6b93ea4d58f69ff370b1646f61d0", "url": "https://github.com/apache/skywalking/commit/8821e0f98f0f6b93ea4d58f69ff370b1646f61d0", "message": "remove article link", "committedDate": "2020-01-17T02:50:02Z", "type": "commit"}, {"oid": "5945c884724387215f5d417e4763aa4c8dc61812", "url": "https://github.com/apache/skywalking/commit/5945c884724387215f5d417e4763aa4c8dc61812", "message": "add `ProfileTask#maxSamplingCount` check", "committedDate": "2020-01-17T03:49:02Z", "type": "commit"}, {"oid": "5279c53b8eb6770c2e9b557f2257370fb3e37267", "url": "https://github.com/apache/skywalking/commit/5279c53b8eb6770c2e9b557f2257370fb3e37267", "message": "resolve conflict (Downstream -> Commands)", "committedDate": "2020-01-17T12:52:51Z", "type": "commit"}, {"oid": "ec08e2648fef30ccb477d72619fdcd787eaec713", "url": "https://github.com/apache/skywalking/commit/ec08e2648fef30ccb477d72619fdcd787eaec713", "message": "Merge branch 'master' into profile_monitor", "committedDate": "2020-01-17T12:53:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxODE1Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367918152", "bodyText": "Same as before, don't use Config in the field initialization. Use it in the constructor.", "author": "wu-sheng", "createdAt": "2020-01-17T12:45:47Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];", "originalCommit": "5945c884724387215f5d417e4763aa4c8dc61812", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyNDc5Ng==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367924796", "bodyText": "Merge tryToAttemptProfiling -> attemptProfiling. Similar name, always use in the same time.", "author": "wu-sheng", "createdAt": "2020-01-17T13:03:35Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +182,27 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyOTkwMg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367929902", "bodyText": "Why does this check happen at the start stage? I think when totalStartedProfilingCount reaches max count, this profile should be at the profiling stage. Do I miss anything?", "author": "wu-sheng", "createdAt": "2020-01-17T13:16:58Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     * @param tracingContext\n+     * @param traceSegmentId\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        boolean alreadyProfiling = tracingContext.isProfiling();\n+\n+        // not profiling and not available slot don't check anymore\n+        int usingSlotCount = currentProfilingCount.get();\n+        if (!alreadyProfiling && usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            if (alreadyProfiling) {\n+                if (stopTracingProfile(tracingContext)) {\n+                    // reduce total started profiling count when status is profiling\n+                    totalStartedProfilingCount.addAndGet(-1);\n+                }\n+            }\n+            return false;\n+        } else if (alreadyProfiling) {\n+            return true;\n+        }\n+\n+        // not profiling, try to occupy slot\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     *\n+     * @return current profiler is already start profiling\n+     */\n+    public boolean stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean isProfilingStarted = false;\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlots[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlots[slot] = null;\n+\n+                // setting stop running\n+                isProfilingStarted = currentProfiler.stopProfiling();\n+                currentProfilingCount.addAndGet(-1);\n+\n+                profilingSegmentSlots = profilingSegmentSlots;\n+                break;\n+            }\n+        }\n+\n+        return isProfilingStarted;\n     }\n \n     public ProfileTask getTask() {\n         return task;\n     }\n \n-    public long getStartTime() {\n-        return startTime;\n+    public ThreadProfiler[] threadProfilerSlots() {\n+        return profilingSegmentSlots;\n     }\n \n+    public boolean isStartProfileable(ThreadProfiler profiler) {\n+        // check is out of max sampling count check\n+        if (totalStartedProfilingCount.incrementAndGet() > task.getMaxSamplingCount()) {", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NDM4MA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367954380", "bodyText": "You are right, the check happens on the profiling stage. Maybe name as you feel confused, I change the name to isProfileable. It will invoke on ThreadProfiler#startProfilingIfNeed. When the tracing context starts time bigger than profile task minDurationThresold, It will have a check.", "author": "mrproliu", "createdAt": "2020-01-17T14:13:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkyOTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDMwNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367930307", "bodyText": "Once the profile starts, it should not stop.", "author": "wu-sheng", "createdAt": "2020-01-17T13:18:02Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     * @param tracingContext\n+     * @param traceSegmentId\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        boolean alreadyProfiling = tracingContext.isProfiling();\n+\n+        // not profiling and not available slot don't check anymore\n+        int usingSlotCount = currentProfilingCount.get();\n+        if (!alreadyProfiling && usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            if (alreadyProfiling) {", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDU1Ng==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367930556", "bodyText": "Otherwise, if I set a profiling task targeting a Tomcat endpoint name, it will never execute as SpringMVC must override it", "author": "wu-sheng", "createdAt": "2020-01-17T13:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMzUxMA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367933510", "bodyText": "This isn't segmentContext, please rename.", "author": "wu-sheng", "createdAt": "2020-01-17T13:26:22Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +182,27 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n+        // if out limit started profiling count then stop add profiling\n+        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dc86d725a8ea60be80e9b579c6e451ae50244933", "url": "https://github.com/apache/skywalking/commit/dc86d725a8ea60be80e9b579c6e451ae50244933", "message": "1. change profilingSegmentSlots init on construct\n2. if is profiling, recheck dont need to stop\n3. total profiling count increment on first dump", "committedDate": "2020-01-17T14:44:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367943992", "bodyText": "This line is really confusing, what does it do?", "author": "kezhenxu94", "createdAt": "2020-01-17T13:50:44Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     * @param tracingContext\n+     * @param traceSegmentId\n+     * @param firstSpanOPName\n+     * @return\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        boolean alreadyProfiling = tracingContext.isProfiling();\n+\n+        // not profiling and not available slot don't check anymore\n+        int usingSlotCount = currentProfilingCount.get();\n+        if (!alreadyProfiling && usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            if (alreadyProfiling) {\n+                if (stopTracingProfile(tracingContext)) {\n+                    // reduce total started profiling count when status is profiling\n+                    totalStartedProfilingCount.addAndGet(-1);\n+                }\n+            }\n+            return false;\n+        } else if (alreadyProfiling) {\n+            return true;\n+        }\n+\n+        // not profiling, try to occupy slot\n+        return tryToAttemptProfiling(tracingContext, traceSegmentId, firstSpanOPName, usingSlotCount);\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext\n+     *\n+     * @return current profiler is already start profiling\n+     */\n+    public boolean stopTracingProfile(TracingContext tracingContext) {\n+        // find current tracingContext and clear it\n+        boolean isProfilingStarted = false;\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            ThreadProfiler currentProfiler = profilingSegmentSlots[slot];\n+            if (currentProfiler != null && currentProfiler.matches(tracingContext)) {\n+                profilingSegmentSlots[slot] = null;\n+\n+                // setting stop running\n+                isProfilingStarted = currentProfiler.stopProfiling();\n+                currentProfilingCount.addAndGet(-1);\n+\n+                profilingSegmentSlots = profilingSegmentSlots;", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk3OTY4Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367979687", "bodyText": "You need to follow prefer review comments :) This is for activating volatile :P", "author": "wu-sheng", "createdAt": "2020-01-17T15:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4MDc2MA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367980760", "bodyText": "You are changing the element of an array, the volatile would work unless we do this.", "author": "wu-sheng", "createdAt": "2020-01-17T15:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5NjUwOQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367996509", "bodyText": "You need to follow prefer review comments :) This is for activating volatile :P\nYou are changing the element of an array, the volatile would work unless we do this.\n\nWell sorry I indeed lose the context here, but why not simply use java.util.concurrent.atomic.AtomicReferenceArray, it does the same thing, even if we cannot use this class, for some reasons, it should be documented, later contributors may be hard to follow the review comments, especially when this gets merged, and people like you and me may forget the reason in some day, and the IDE is \"too enthusiastic\u201c to hint that one should remove it:", "author": "kezhenxu94", "createdAt": "2020-01-17T15:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxNTA1MQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368015051", "bodyText": "I remember that did this in different way. Can't remember the detail.Personally, I just use the easy way.\n@mrproliu you could add doc, but don't use the link to that blog.", "author": "wu-sheng", "createdAt": "2020-01-17T16:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMjE3Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368032172", "bodyText": "I just use the easy way.\n\nIMHO, your meaning by saying \"easy\" is the data structure (array) itself, but in this case, we're tackling the thread-visibilities, I'd say it would be much more straightforward to use java.util.concurrent.atomic.AtomicReferenceArray than assigning the field to it self, Java programmers should be familiar with the former after all, my personal thought;\nAnd you just brought me the interest to do a benchmark on the two solutions, in terms of the performance, check the following benchmark and results:\nBenchmark Codes\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.apache.skywalking.apm.plugin.dubbo;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\nimport org.openjdk.jmh.annotations.Benchmark;\nimport org.openjdk.jmh.annotations.BenchmarkMode;\nimport org.openjdk.jmh.annotations.Fork;\nimport org.openjdk.jmh.annotations.Measurement;\nimport org.openjdk.jmh.annotations.Mode;\nimport org.openjdk.jmh.annotations.OutputTimeUnit;\nimport org.openjdk.jmh.annotations.Scope;\nimport org.openjdk.jmh.annotations.State;\nimport org.openjdk.jmh.annotations.Warmup;\nimport org.openjdk.jmh.runner.Runner;\nimport org.openjdk.jmh.runner.RunnerException;\nimport org.openjdk.jmh.runner.options.Options;\nimport org.openjdk.jmh.runner.options.OptionsBuilder;\n\n@BenchmarkMode(Mode.Throughput)\n@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@State(Scope.Thread)\n@Fork(2)\n@Warmup(iterations = 4)\n@Measurement(iterations = 5)\npublic class AtomicArrayBenchmarkTest {\n    final int arraySize = 50;\n    final AtomicReferenceArray<Object> atomicReferenceArray = new AtomicReferenceArray<>(arraySize);\n\n    @Benchmark\n    public void testAtomicArray() {\n        for (int i = 0; i < arraySize; i++) {\n            atomicReferenceArray.set(i, new Object());\n        }\n    }\n\n    volatile Object[] volatileArray = new Object[arraySize];\n\n    @Benchmark\n    public void testRawArray() {\n        for (int i = 0; i < arraySize; i++) {\n            volatileArray[i] = new Object();\n            volatileArray = volatileArray;\n        }\n    }\n\n    @BenchmarkMode(Mode.AverageTime)\n    @OutputTimeUnit(TimeUnit.MICROSECONDS)\n    public static void main(String[] args) throws RunnerException {\n        Options options = new OptionsBuilder().include(AtomicArrayBenchmarkTest.class.getSimpleName()).build();\n        new Runner(options).run();\n    }\n}\n\nResult\nBenchmark                                                Mode  Samples     Score  Score error   Units\no.a.s.a.p.d.AtomicArrayBenchmarkTest.testAtomicArray    thrpt       25  3003.470       37.575  ops/ms\no.a.s.a.p.d.AtomicArrayBenchmarkTest.testRawArray       thrpt       25  2766.009       27.934  ops/ms\n\nit may be not that precise, but I'm with it :) since you said\n\nProfiling is happening in a high payload scenario\n\nperformance matters", "author": "kezhenxu94", "createdAt": "2020-01-17T16:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5Mjc2MQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368192761", "bodyText": "Make sense for switching to AtomicReferenceArray in this case.", "author": "wu-sheng", "createdAt": "2020-01-18T01:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMjcxMg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368202712", "bodyText": "Change slot to the AtomicReferenceArray, please recheck. @wu-sheng @kezhenxu94", "author": "mrproliu", "createdAt": "2020-01-18T03:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0Mzk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NDI3Nw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367944277", "bodyText": "And this one", "author": "kezhenxu94", "createdAt": "2020-01-17T13:51:23Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -58,4 +182,27 @@ public boolean equals(Object o) {\n     public int hashCode() {\n         return Objects.hash(task);\n     }\n+\n+    private boolean tryToAttemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName, int currentUsingSlotCount) {\n+        // if out limit started profiling count then stop add profiling\n+        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(currentUsingSlotCount, currentUsingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler segmentContext = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        for (int slot = 0; slot < profilingSegmentSlots.length; slot++) {\n+            if (profilingSegmentSlots[slot] == null) {\n+                profilingSegmentSlots[slot] = segmentContext;\n+\n+                profilingSegmentSlots = profilingSegmentSlots;", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NzA5OA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367947098", "bodyText": "I prefer to let this method return an Exception, maybe java.lang.IllegalStateException, simply return a string is no so semantic, and you may want to print the stack trace there, since it's a kind of \"exception\", in some degree", "author": "kezhenxu94", "createdAt": "2020-01-17T13:57:45Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -151,7 +202,7 @@ public long getLastCommandCreateTime() {\n      */\n     private String checkProfileTaskSuccess(ProfileTask task) {", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk4MDM3Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367980372", "bodyText": "In this case, I prefer to return a Result class, rather than exception. Profiling is happening in a high payload scenario, but Exception is a heavy OP. We should avoid it.", "author": "wu-sheng", "createdAt": "2020-01-17T15:03:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NzA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNzQ4NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368027484", "bodyText": "In this case, I prefer to return a Result class, rather than exception. Profiling is happening in a high payload scenario, but Exception is a heavy OP. We should avoid it.\n\nSounds good to me", "author": "kezhenxu94", "createdAt": "2020-01-17T16:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NzA5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwMjY3NA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368202674", "bodyText": "@kezhenxu94 @wu-sheng resolved, please check", "author": "mrproliu", "createdAt": "2020-01-18T03:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk0NzA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1MDgxNA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r367950814", "bodyText": "You have so many JavaDocs like this, please add corresponding descriptions, or remove the @param and @return, although it can compile, it produces uncountable warnings in CI (javadoc:javadoc), and many many warnings in the IDE, making it hard to discover warnings that really matters:", "author": "kezhenxu94", "createdAt": "2020-01-17T14:05:44Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,22 +37,139 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile ThreadProfiler[] profilingSegmentSlots = new ThreadProfiler[Config.Profile.MAX_PARALLEL];\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n+\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+    }\n+\n+    /**\n+     * start profiling this task\n+     * @param executorService\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     * @param tracingContext\n+     * @param firstSpanOPName\n+     * @return\n+     */", "originalCommit": "ec08e2648fef30ccb477d72619fdcd787eaec713", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b29dcad201c54295b4443bc53eaaad25db25d136", "url": "https://github.com/apache/skywalking/commit/b29dcad201c54295b4443bc53eaaad25db25d136", "message": "remove unused return val", "committedDate": "2020-01-17T15:00:51Z", "type": "commit"}, {"oid": "a96d3ccd381c6a24500e4bb4f1dc7b50edff7599", "url": "https://github.com/apache/skywalking/commit/a96d3ccd381c6a24500e4bb4f1dc7b50edff7599", "message": "remove some `@param` and `@return`", "committedDate": "2020-01-17T15:08:44Z", "type": "commit"}, {"oid": "914021a0f5611a3963b89b03cd2e54bb8157cefb", "url": "https://github.com/apache/skywalking/commit/914021a0f5611a3963b89b03cd2e54bb8157cefb", "message": "add profile task check result data bean", "committedDate": "2020-01-18T02:42:20Z", "type": "commit"}, {"oid": "d455464c9a7d2977e803db2e99a7101ddb3cb452", "url": "https://github.com/apache/skywalking/commit/d455464c9a7d2977e803db2e99a7101ddb3cb452", "message": "change profiler slot to `AtomicReferenceArray`", "committedDate": "2020-01-18T03:04:14Z", "type": "commit"}, {"oid": "01bfafb695de56c7cc13d9d92db93dbb194d0c19", "url": "https://github.com/apache/skywalking/commit/01bfafb695de56c7cc13d9d92db93dbb194d0c19", "message": "resolved java doc error", "committedDate": "2020-01-18T03:22:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDg3MQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368204871", "bodyText": "You don't return anything at all", "author": "kezhenxu94", "createdAt": "2020-01-18T04:17:34Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionContext.java", "diffHunk": "@@ -30,20 +38,129 @@\n     // task data\n     private final ProfileTask task;\n \n-    // task real start time\n-    private final long startTime;\n+    // record current profiling count, use this to check has available profile slot\n+    private final AtomicInteger currentProfilingCount = new AtomicInteger(0);\n+\n+    // profiling segment slot\n+    private volatile AtomicReferenceArray<ThreadProfiler> profilingSegmentSlots;\n+\n+    // current profiling execution future\n+    private volatile Future profilingFuture;\n \n-    public ProfileTaskExecutionContext(ProfileTask task, long startTime) {\n+    // total started profiling tracing context count\n+    private final AtomicInteger totalStartedProfilingCount = new AtomicInteger(0);\n+\n+    public ProfileTaskExecutionContext(ProfileTask task) {\n         this.task = task;\n-        this.startTime = startTime;\n+        profilingSegmentSlots = new AtomicReferenceArray<>(Config.Profile.MAX_PARALLEL);\n+    }\n+\n+    /**\n+     * start profiling this task\n+     *\n+     * @param executorService start profiling to appoint thread pool\n+     */\n+    public void startProfiling(ExecutorService executorService) {\n+        profilingFuture = executorService.submit(new ProfileThread(this));\n+    }\n+\n+    /**\n+     * stop profiling\n+     */\n+    public void stopProfiling() {\n+        if (profilingFuture != null) {\n+            profilingFuture.cancel(true);\n+        }\n+    }\n+\n+    /**\n+     * check have available slot to profile and add it\n+     *\n+     * @param tracingContext need to profiling trace\n+     * @param traceSegmentId current trace segment id\n+     * @param firstSpanOPName first span operation name\n+     * @return is add profile success\n+     */\n+    public boolean attemptProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // check has available slot\n+        final int usingSlotCount = currentProfilingCount.get();\n+        if (usingSlotCount >= Config.Profile.MAX_PARALLEL) {\n+            return false;\n+        }\n+\n+        // check first operation name matches\n+        if (!Objects.equals(task.getFistSpanOPName(), firstSpanOPName)) {\n+            return false;\n+        }\n+\n+        // if out limit started profiling count then stop add profiling\n+        if (totalStartedProfilingCount.get() > task.getMaxSamplingCount()) {\n+            return false;\n+        }\n+\n+        // try to occupy slot\n+        if (!currentProfilingCount.compareAndSet(usingSlotCount, usingSlotCount + 1)) {\n+            return false;\n+        }\n+\n+        final ThreadProfiler threadProfiler = new ThreadProfiler(tracingContext, traceSegmentId, Thread.currentThread(), this);\n+        int slotLength = profilingSegmentSlots.length();\n+        for (int slot = 0; slot < slotLength; slot++) {\n+            if (profilingSegmentSlots.compareAndSet(slot, null, threadProfiler)) {\n+                break;\n+            }\n+        }\n+        return true;\n+    }\n+\n+\n+    /**\n+     * profiling recheck\n+     *\n+     * @return is recheck to add profile success\n+     */\n+    public boolean profilingRecheck(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // if started, keep profiling\n+        if (tracingContext.isProfiling()) {\n+            return true;\n+        }\n+\n+        return attemptProfiling(tracingContext, traceSegmentId, firstSpanOPName);\n+    }\n+\n+    /**\n+     * find tracing context and clear on slot\n+     *\n+     * @param tracingContext stop profiling appoint trace\n+     * @return current profiler is already start profiling", "originalCommit": "01bfafb695de56c7cc13d9d92db93dbb194d0c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwNDg5Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368204892", "bodyText": "Same here", "author": "kezhenxu94", "createdAt": "2020-01-18T04:18:01Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     *\n+     * @return current profiler is already start profiling", "originalCommit": "01bfafb695de56c7cc13d9d92db93dbb194d0c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "url": "https://github.com/apache/skywalking/commit/7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "message": "fix doc error, remove meaningless descriptions", "committedDate": "2020-01-18T04:37:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwODIwNw==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368208207", "bodyText": "if Config.Profile.ACTIVE ==  false TracingThreadSnapshot should be ignored, right?", "author": "arugal", "createdAt": "2020-01-18T05:42:08Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskChannelService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import io.grpc.Channel;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.stub.StreamObserver;\n+import org.apache.skywalking.apm.agent.core.boot.BootService;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultImplementor;\n+import org.apache.skywalking.apm.agent.core.boot.DefaultNamedThreadFactory;\n+import org.apache.skywalking.apm.agent.core.boot.ServiceManager;\n+import org.apache.skywalking.apm.agent.core.commands.CommandService;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.conf.RemoteDownstreamConfig;\n+import org.apache.skywalking.apm.agent.core.dictionary.DictionaryUtil;\n+import org.apache.skywalking.apm.agent.core.logging.api.ILog;\n+import org.apache.skywalking.apm.agent.core.logging.api.LogManager;\n+import org.apache.skywalking.apm.agent.core.remote.*;\n+import org.apache.skywalking.apm.network.common.Commands;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskCommandQuery;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskFinishReport;\n+import org.apache.skywalking.apm.network.language.profile.ProfileTaskGrpc;\n+import org.apache.skywalking.apm.network.language.profile.ThreadSnapshot;\n+import org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.skywalking.apm.agent.core.conf.Config.Collector.GRPC_UPSTREAM_TIMEOUT;\n+\n+/**\n+ * Sniffer and backend, about the communication service of profile task protocol.\n+ * 1. Sniffer will check has new profile task list every {@link Config.Collector#GET_PROFILE_TASK_INTERVAL} second.\n+ * 2. When there is a new profile task snapshot, the data is transferred to the back end. use {@link LinkedBlockingQueue}\n+ * 3. When profiling task finish, it will send task finish status to backend\n+ *\n+ * @author MrPro\n+ */\n+@DefaultImplementor\n+public class ProfileTaskChannelService implements BootService, Runnable, GRPCChannelListener {\n+    private static final ILog logger = LogManager.getLogger(ProfileTaskChannelService.class);\n+\n+    // channel status\n+    private volatile GRPCChannelStatus status = GRPCChannelStatus.DISCONNECT;\n+\n+    // gRPC stub\n+    private volatile ProfileTaskGrpc.ProfileTaskBlockingStub profileTaskBlockingStub;\n+    private volatile ProfileTaskGrpc.ProfileTaskStub profileTaskStub;\n+\n+    // segment snapshot sender\n+    private final LinkedBlockingQueue<TracingThreadSnapshot> snapshotQueue = new LinkedBlockingQueue<>(Config.Profile.SNAPSHOT_TRANSPORT_BUFFER_SIZE);\n+    private volatile ScheduledFuture<?> sendSnapshotFuture;\n+\n+    // query task list schedule\n+    private volatile ScheduledFuture<?> getTaskListFuture;\n+\n+    @Override\n+    public void run() {\n+        if (RemoteDownstreamConfig.Agent.SERVICE_ID != DictionaryUtil.nullValue()\n+                && RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID != DictionaryUtil.nullValue()\n+        ) {\n+            if (status == GRPCChannelStatus.CONNECTED) {\n+                try {\n+                    ProfileTaskCommandQuery.Builder builder = ProfileTaskCommandQuery.newBuilder();\n+\n+                    // sniffer info\n+                    builder.setServiceId(RemoteDownstreamConfig.Agent.SERVICE_ID).setInstanceId(RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID);\n+\n+                    // last command create time\n+                    builder.setLastCommandTime(ServiceManager.INSTANCE.findService(ProfileTaskExecutionService.class).getLastCommandCreateTime());\n+\n+                    Commands commands = profileTaskBlockingStub.withDeadlineAfter(GRPC_UPSTREAM_TIMEOUT, TimeUnit.SECONDS).getProfileTaskCommands(builder.build());\n+                    ServiceManager.INSTANCE.findService(CommandService.class).receiveCommand(commands);\n+                } catch (Throwable t) {\n+                    if (!(t instanceof StatusRuntimeException)) {\n+                        logger.error(t, \"Query profile task from backend fail.\");\n+                        return;\n+                    }\n+                    final StatusRuntimeException statusRuntimeException = (StatusRuntimeException) t;\n+                    if (statusRuntimeException.getStatus().getCode() == Status.Code.UNIMPLEMENTED) {\n+                        logger.warn(\"Backend doesn't support profiling, profiling will be disabled\");\n+                        if (getTaskListFuture != null) {\n+                            getTaskListFuture.cancel(true);\n+                        }\n+\n+                        // stop snapshot sender\n+                        if (sendSnapshotFuture != null) {\n+                            sendSnapshotFuture.cancel(true);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void prepare() throws Throwable {\n+        ServiceManager.INSTANCE.findService(GRPCChannelManager.class).addChannelListener(this);\n+    }\n+\n+    @Override\n+    public void boot() throws Throwable {\n+        if (Config.Profile.ACTIVE) {\n+            // query task list\n+            getTaskListFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileGetTaskService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(this, new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override\n+                        public void handle(Throwable t) {\n+                            logger.error(\"Query profile task list failure.\", t);\n+                        }\n+                    }), 0, Config.Collector.GET_PROFILE_TASK_INTERVAL, TimeUnit.SECONDS);\n+\n+            sendSnapshotFuture = Executors.newSingleThreadScheduledExecutor(new DefaultNamedThreadFactory(\"ProfileSendSnapshotService\"))\n+                    .scheduleWithFixedDelay(new RunnableWithExceptionProtection(new SnapshotSender(), new RunnableWithExceptionProtection.CallbackWhenException() {\n+                        @Override public void handle(Throwable t) {\n+                            logger.error(\"Profile segment snapshot upload failure.\", t);\n+                        }\n+                    }), 0, 500, TimeUnit.MILLISECONDS);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() throws Throwable {\n+    }\n+\n+    @Override\n+    public void shutdown() throws Throwable {\n+        if (getTaskListFuture != null) {\n+            getTaskListFuture.cancel(true);\n+        }\n+\n+        if (sendSnapshotFuture != null) {\n+            sendSnapshotFuture.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void statusChanged(GRPCChannelStatus status) {\n+        if (GRPCChannelStatus.CONNECTED.equals(status)) {\n+            Channel channel = ServiceManager.INSTANCE.findService(GRPCChannelManager.class).getChannel();\n+            profileTaskBlockingStub = ProfileTaskGrpc.newBlockingStub(channel);\n+            profileTaskStub = ProfileTaskGrpc.newStub(channel);\n+        } else {\n+            profileTaskBlockingStub = null;\n+            profileTaskStub = null;\n+        }\n+        this.status = status;\n+    }\n+\n+    /**\n+     * add a new profiling snapshot, send to {@link #snapshotQueue}\n+     */\n+    public void addProfilingSnapshot(TracingThreadSnapshot snapshot) {\n+        snapshotQueue.add(snapshot);", "originalCommit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwODU3Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368208572", "bodyText": "If not active profile, there will not going to happen.  I think it is useless to add judgment here, and it will also increase the cost of judgment.", "author": "mrproliu", "createdAt": "2020-01-18T05:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwODcyNA==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368208724", "bodyText": "sorry, I was wrong.", "author": "arugal", "createdAt": "2020-01-18T05:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIwODIwNw=="}], "type": "inlineReview"}, {"oid": "85f557c3790290d4a597e11eb84165b169cae032", "url": "https://github.com/apache/skywalking/commit/85f557c3790290d4a597e11eb84165b169cae032", "message": "resolve missed profile receiver on oap starter", "committedDate": "2020-01-18T08:19:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxMzY3Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368213672", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Re-check current trace need profiling, encase third part plugin change the operation name.\n          \n          \n            \n                 * Re-check current trace need profiling, in case that third-party plugins change the operation name.", "author": "kezhenxu94", "createdAt": "2020-01-18T08:02:04Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ProfileTaskExecutionService.java", "diffHunk": "@@ -84,19 +90,46 @@ public void run() {\n         }, timeToProcessMills, TimeUnit.MILLISECONDS);\n     }\n \n+    /**\n+     * check and add {@link TracingContext} profiling\n+     */\n+    public boolean addProfiling(TracingContext tracingContext, ID traceSegmentId, String firstSpanOPName) {\n+        // get current profiling task, check need profiling\n+        final ProfileTaskExecutionContext executionContext = taskExecutionContext.get();\n+        if (executionContext == null) {\n+            return false;\n+        }\n+\n+        return executionContext.attemptProfiling(tracingContext, traceSegmentId, firstSpanOPName);\n+    }\n+\n+    /**\n+     * Re-check current trace need profiling, encase third part plugin change the operation name.", "originalCommit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDA5NQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368214095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean isProfilingProfilingContinuable() {\n          \n          \n            \n                private boolean isProfilingContinuable() {", "author": "kezhenxu94", "createdAt": "2020-01-18T08:12:33Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     */\n+    public void stopProfiling() {\n+        this.profilingStatus = ProfilingStatus.STOPPED;\n+    }\n+\n+    /**\n+     * dump tracing thread and build thread snapshot\n+     *\n+     * @return snapshot, if null means dump snapshot error, should stop it\n+     */\n+    public TracingThreadSnapshot buildSnapshot() {\n+        if (!isProfilingProfilingContinuable()) {\n+            return null;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        StackTraceElement[] stackTrace;\n+        try {\n+            stackTrace = profilingThread.getStackTrace();\n+\n+            // stack depth is zero, means thread is already run finished\n+            if (stackTrace.length == 0) {\n+                return null;\n+            }\n+        } catch (Exception e) {\n+            // dump error ignore and make this profiler stop\n+            return null;\n+        }\n+\n+        // if is first dump, check is can start profiling\n+        if (dumpSequence == 0 && (!executionContext.isStartProfileable())) {\n+            return null;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        String taskId = executionContext.getTask().getTaskId();\n+        return new TracingThreadSnapshot(taskId, traceSegmentId, dumpSequence++, currentTime, stackList);\n+    }\n+\n+    /**\n+     * build thread stack element code signature\n+     *\n+     * @return code sign: className.methodName:lineNumber\n+     */\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * matches profiling tracing context\n+     */\n+    public boolean matches(TracingContext context) {\n+        // match trace id\n+        return Objects.equal(context.getReadableGlobalTraceId(), tracingContext.getReadableGlobalTraceId());\n+    }\n+\n+    /**\n+     * check profiling is should continue\n+     *\n+     * @return if true means this thread profiling is continuable\n+     */\n+    private boolean isProfilingProfilingContinuable() {", "originalCommit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDExMg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368214112", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * check profiling is should continue\n          \n          \n            \n                 * check whether profiling should continue", "author": "kezhenxu94", "createdAt": "2020-01-18T08:12:49Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     */\n+    public void stopProfiling() {\n+        this.profilingStatus = ProfilingStatus.STOPPED;\n+    }\n+\n+    /**\n+     * dump tracing thread and build thread snapshot\n+     *\n+     * @return snapshot, if null means dump snapshot error, should stop it\n+     */\n+    public TracingThreadSnapshot buildSnapshot() {\n+        if (!isProfilingProfilingContinuable()) {\n+            return null;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        StackTraceElement[] stackTrace;\n+        try {\n+            stackTrace = profilingThread.getStackTrace();\n+\n+            // stack depth is zero, means thread is already run finished\n+            if (stackTrace.length == 0) {\n+                return null;\n+            }\n+        } catch (Exception e) {\n+            // dump error ignore and make this profiler stop\n+            return null;\n+        }\n+\n+        // if is first dump, check is can start profiling\n+        if (dumpSequence == 0 && (!executionContext.isStartProfileable())) {\n+            return null;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        String taskId = executionContext.getTask().getTaskId();\n+        return new TracingThreadSnapshot(taskId, traceSegmentId, dumpSequence++, currentTime, stackList);\n+    }\n+\n+    /**\n+     * build thread stack element code signature\n+     *\n+     * @return code sign: className.methodName:lineNumber\n+     */\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();\n+    }\n+\n+    /**\n+     * matches profiling tracing context\n+     */\n+    public boolean matches(TracingContext context) {\n+        // match trace id\n+        return Objects.equal(context.getReadableGlobalTraceId(), tracingContext.getReadableGlobalTraceId());\n+    }\n+\n+    /**\n+     * check profiling is should continue", "originalCommit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDI4Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368214282", "bodyText": "Maybe take the case when element.getLineNumber() < 0 into consideration? Make it Unknown Source?", "author": "kezhenxu94", "createdAt": "2020-01-18T08:15:20Z", "path": "apm-sniffer/apm-agent-core/src/main/java/org/apache/skywalking/apm/agent/core/profile/ThreadProfiler.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.apm.agent.core.profile;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.apm.agent.core.conf.Config;\n+import org.apache.skywalking.apm.agent.core.context.TracingContext;\n+import org.apache.skywalking.apm.agent.core.context.ids.ID;\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ThreadProfiler {\n+\n+    // current tracing context\n+    private final TracingContext tracingContext;\n+    // current tracing segment id\n+    private final ID traceSegmentId;\n+    // need to profiling thread\n+    private final Thread profilingThread;\n+    // profiling execution context\n+    private final ProfileTaskExecutionContext executionContext;\n+\n+    // profiling time\n+    private long profilingStartTime;\n+    private long profilingMaxTimeMills;\n+\n+    // after min duration threshold check, it will start dump\n+    private ProfilingStatus profilingStatus = ProfilingStatus.READY;\n+    // thread dump sequence\n+    private int dumpSequence = 0;\n+\n+    public ThreadProfiler(TracingContext tracingContext, ID traceSegmentId, Thread profilingThread, ProfileTaskExecutionContext executionContext) {\n+        this.tracingContext = tracingContext;\n+        this.traceSegmentId = traceSegmentId;\n+        this.profilingThread = profilingThread;\n+        this.executionContext = executionContext;\n+        this.profilingMaxTimeMills = TimeUnit.MINUTES.toMillis(Config.Profile.MAX_DURATION);\n+    }\n+\n+    /**\n+     * If tracing start time greater than {@link ProfileTask#getMinDurationThreshold()}, then start to profiling trace\n+     */\n+    public void startProfilingIfNeed() {\n+        if (System.currentTimeMillis() - tracingContext.createTime() > executionContext.getTask().getMinDurationThreshold()) {\n+            this.profilingStartTime = System.currentTimeMillis();\n+            this.profilingStatus = ProfilingStatus.PROFILING;\n+        }\n+    }\n+\n+    /**\n+     * Stop profiling status\n+     */\n+    public void stopProfiling() {\n+        this.profilingStatus = ProfilingStatus.STOPPED;\n+    }\n+\n+    /**\n+     * dump tracing thread and build thread snapshot\n+     *\n+     * @return snapshot, if null means dump snapshot error, should stop it\n+     */\n+    public TracingThreadSnapshot buildSnapshot() {\n+        if (!isProfilingProfilingContinuable()) {\n+            return null;\n+        }\n+\n+        long currentTime = System.currentTimeMillis();\n+        // dump thread\n+        StackTraceElement[] stackTrace;\n+        try {\n+            stackTrace = profilingThread.getStackTrace();\n+\n+            // stack depth is zero, means thread is already run finished\n+            if (stackTrace.length == 0) {\n+                return null;\n+            }\n+        } catch (Exception e) {\n+            // dump error ignore and make this profiler stop\n+            return null;\n+        }\n+\n+        // if is first dump, check is can start profiling\n+        if (dumpSequence == 0 && (!executionContext.isStartProfileable())) {\n+            return null;\n+        }\n+\n+        int dumpElementCount = Math.min(stackTrace.length, Config.Profile.DUMP_MAX_STACK_DEPTH);\n+\n+        // use inverted order, because thread dump is start with bottom\n+        final ArrayList<String> stackList = new ArrayList<>(dumpElementCount);\n+        for (int i = dumpElementCount - 1; i >= 0; i--) {\n+            stackList.add(buildStackElementCodeSignature(stackTrace[i]));\n+        }\n+\n+        String taskId = executionContext.getTask().getTaskId();\n+        return new TracingThreadSnapshot(taskId, traceSegmentId, dumpSequence++, currentTime, stackList);\n+    }\n+\n+    /**\n+     * build thread stack element code signature\n+     *\n+     * @return code sign: className.methodName:lineNumber\n+     */\n+    private String buildStackElementCodeSignature(StackTraceElement element) {\n+        return element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber();", "originalCommit": "7c098c5e014f2ecaaaadffdfa5124493f6f79b68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNTQzNQ==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368215435", "bodyText": "I am OK with line number = -1. :) Both are fine to me.", "author": "wu-sheng", "createdAt": "2020-01-18T08:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDI4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNTU1Mg==", "url": "https://github.com/apache/skywalking/pull/4220#discussion_r368215552", "bodyText": "It's ok to me, \"Unknown Source\" takes more bandwidth then \"-1\" after all", "author": "kezhenxu94", "createdAt": "2020-01-18T08:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIxNDI4Mg=="}], "type": "inlineReview"}, {"oid": "9c5eeed53b2126733b6a61db41a3e9920ef5117f", "url": "https://github.com/apache/skywalking/commit/9c5eeed53b2126733b6a61db41a3e9920ef5117f", "message": "update comment\n\nCo-Authored-By: kezhenxu94 <kezhenxu94@163.com>", "committedDate": "2020-01-18T08:52:44Z", "type": "commit"}, {"oid": "a3e954ce87bbd33dc5cc26e8bf08a5b94fd59601", "url": "https://github.com/apache/skywalking/commit/a3e954ce87bbd33dc5cc26e8bf08a5b94fd59601", "message": "update isProfilingContinuable method name\n\nCo-Authored-By: kezhenxu94 <kezhenxu94@163.com>", "committedDate": "2020-01-18T08:57:42Z", "type": "commit"}, {"oid": "659d794b9ed25c916990f60802d500b4d163e54d", "url": "https://github.com/apache/skywalking/commit/659d794b9ed25c916990f60802d500b4d163e54d", "message": "update comment\n\nCo-Authored-By: kezhenxu94 <kezhenxu94@163.com>", "committedDate": "2020-01-18T09:00:59Z", "type": "commit"}, {"oid": "8d3dc9b7e90525f225b76b2ffc9caa057404efb7", "url": "https://github.com/apache/skywalking/commit/8d3dc9b7e90525f225b76b2ffc9caa057404efb7", "message": "resolve method invoke error", "committedDate": "2020-01-18T09:08:53Z", "type": "commit"}]}