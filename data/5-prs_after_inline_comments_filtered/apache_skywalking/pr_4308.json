{"pr_number": 4308, "pr_title": "provide thread stack analyzes", "pr_createdAt": "2020-02-02T10:07:28Z", "pr_url": "https://github.com/apache/skywalking/pull/4308", "timeline": [{"oid": "a89ab300ceb2164561c4e8c9ddef4f77600d11b5", "url": "https://github.com/apache/skywalking/commit/a89ab300ceb2164561c4e8c9ddef4f77600d11b5", "message": "provide thread analyze", "committedDate": "2020-02-02T10:03:04Z", "type": "commit"}, {"oid": "0fd37cfa1260e96dcdb86f57b6772e4164dcaa17", "url": "https://github.com/apache/skywalking/commit/0fd37cfa1260e96dcdb86f57b6772e4164dcaa17", "message": "Merge branch 'master' into profile_analyze_data", "committedDate": "2020-02-02T10:07:36Z", "type": "commit"}, {"oid": "19bcd18a38cc55b926da4279a97a8d5059d56a16", "url": "https://github.com/apache/skywalking/commit/19bcd18a38cc55b926da4279a97a8d5059d56a16", "message": "fix style error", "committedDate": "2020-02-02T10:37:39Z", "type": "commit"}, {"oid": "e9ed1b9e9db10ae959fa0f3651ab3b3144b44bf1", "url": "https://github.com/apache/skywalking/commit/e9ed1b9e9db10ae959fa0f3651ab3b3144b44bf1", "message": "fix style error", "committedDate": "2020-02-02T10:49:36Z", "type": "commit"}, {"oid": "50c9875e66ef1a580f5f21b22e8fa4c157a6493c", "url": "https://github.com/apache/skywalking/commit/50c9875e66ef1a580f5f21b22e8fa4c157a6493c", "message": "Adding flow charts", "committedDate": "2020-02-02T11:00:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNDUwNg==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373834506", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        new IllegalArgumentException(\"wrong stack data\");\n          \n          \n            \n                        throw new IllegalArgumentException(\"wrong stack data\");", "author": "kezhenxu94", "createdAt": "2020-02-02T10:18:27Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStack.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import lombok.Data;\n+import org.apache.skywalking.apm.network.language.profile.ThreadStack;\n+import org.apache.skywalking.oap.server.core.profile.ProfileTaskSegmentSnapshotRecord;\n+\n+import java.util.List;\n+\n+/**\n+ * Deserialize from {@link ProfileTaskSegmentSnapshotRecord}\n+ *\n+ * @author MrPro\n+ */\n+@Data\n+public class ProfileStack implements Comparable<ProfileStack> {\n+\n+    private int sequence;\n+    private long dumpTime;\n+    private List<String> stack;\n+\n+    public static ProfileStack deserialize(ProfileTaskSegmentSnapshotRecord record) {\n+        ThreadStack threadStack = null;\n+        try {\n+            threadStack = ThreadStack.parseFrom(record.getStackBinary());\n+        } catch (InvalidProtocolBufferException e) {\n+            new IllegalArgumentException(\"wrong stack data\");", "originalCommit": "0fd37cfa1260e96dcdb86f57b6772e4164dcaa17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNDY4Ng==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373834686", "bodyText": "childes -> children", "author": "kezhenxu94", "createdAt": "2020-02-02T10:21:55Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> childes;", "originalCommit": "0fd37cfa1260e96dcdb86f57b6772e4164dcaa17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNDgxNg==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373834816", "bodyText": "too many nested blocks, better to refactor/extract some short methods", "author": "kezhenxu94", "createdAt": "2020-02-02T10:24:59Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> childes;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.owners = new LinkedList<>();\n+        emptyNode.childes = new LinkedList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // increase self\n+        this.increase(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int childDepth = 1; childDepth < stackList.size(); childDepth++) {\n+            String elementCodeSign = stackList.get(childDepth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.childes) {\n+                if (Objects.equal(child.codeSignature, elementCodeSign)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // increase child node\n+                childElement.increase(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = createEmptyNode();\n+                childNode.codeSignature = elementCodeSign;\n+                childNode.increase(stack);\n+\n+                parent.childes.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineThisNode(node);\n+\n+        // merge tree using pre order\n+        LinkedList<Pair<ProfileStackNode, List<ProfileStackNode>>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node.childes));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, List<ProfileStackNode>> needCombineNode = stack.pop();\n+            ProfileStackNode combineTo = needCombineNode.key;\n+\n+            // merge node\n+            for (ProfileStackNode needCombineChildren : needCombineNode.value) {\n+                boolean sameReference = false;\n+                // find node\n+                ProfileStackNode combinedNode = null;\n+                for (ProfileStackNode combineNodeChildren : combineTo.childes) {\n+                    // same code signature\n+                    if (Objects.equal(needCombineChildren.codeSignature, combineNodeChildren.codeSignature)) {\n+                        // if same reference, dont need to combine anymore\n+                        if (needCombineChildren == combineNodeChildren) {\n+                            sameReference = true;\n+                        } else {\n+                            combineNodeChildren.combineThisNode(needCombineChildren);\n+                        }\n+                        combinedNode = combineNodeChildren;\n+                        break;\n+                    }\n+                }\n+\n+                if (combinedNode == null) {\n+                    combineTo.childes.add(needCombineChildren);\n+                    combinedNode = needCombineChildren;\n+                }\n+\n+                if (!sameReference) {\n+                    stack.add(new Pair(combinedNode, needCombineChildren.childes));\n+                }\n+            }", "originalCommit": "0fd37cfa1260e96dcdb86f57b6772e4164dcaa17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNTQ0Nw==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373835447", "bodyText": "Inner class 'Pair' may be 'static'", "author": "kezhenxu94", "createdAt": "2020-02-02T10:37:19Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> childes;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.owners = new LinkedList<>();\n+        emptyNode.childes = new LinkedList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // increase self\n+        this.increase(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int childDepth = 1; childDepth < stackList.size(); childDepth++) {\n+            String elementCodeSign = stackList.get(childDepth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.childes) {\n+                if (Objects.equal(child.codeSignature, elementCodeSign)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // increase child node\n+                childElement.increase(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = createEmptyNode();\n+                childNode.codeSignature = elementCodeSign;\n+                childNode.increase(stack);\n+\n+                parent.childes.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineThisNode(node);\n+\n+        // merge tree using pre order\n+        LinkedList<Pair<ProfileStackNode, List<ProfileStackNode>>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node.childes));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, List<ProfileStackNode>> needCombineNode = stack.pop();\n+            ProfileStackNode combineTo = needCombineNode.key;\n+\n+            // merge node\n+            for (ProfileStackNode needCombineChildren : needCombineNode.value) {\n+                boolean sameReference = false;\n+                // find node\n+                ProfileStackNode combinedNode = null;\n+                for (ProfileStackNode combineNodeChildren : combineTo.childes) {\n+                    // same code signature\n+                    if (Objects.equal(needCombineChildren.codeSignature, combineNodeChildren.codeSignature)) {\n+                        // if same reference, dont need to combine anymore\n+                        if (needCombineChildren == combineNodeChildren) {\n+                            sameReference = true;\n+                        } else {\n+                            combineNodeChildren.combineThisNode(needCombineChildren);\n+                        }\n+                        combinedNode = combineNodeChildren;\n+                        break;\n+                    }\n+                }\n+\n+                if (combinedNode == null) {\n+                    combineTo.childes.add(needCombineChildren);\n+                    combinedNode = needCombineChildren;\n+                }\n+\n+                if (!sameReference) {\n+                    stack.add(new Pair(combinedNode, needCombineChildren.childes));\n+                }\n+            }\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * build GraphQL result, calculate duration and count data using parallels\n+     * @return\n+     */\n+    public ProfileStackElement buildAnalyzeResult() {\n+        // all nodes add to one list, work for parallel calculating\n+        LinkedList<Pair<ProfileStackNode, ProfileStackElement>> allNodes = new LinkedList<>();\n+        ProfileStackElement root = buildElement();\n+        allNodes.add(new Pair<>(this, root));\n+\n+        // using pre order, build element tree\n+        LinkedList<Pair<ProfileStackElement, List<ProfileStackNode>>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(root, this.childes));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackElement, List<ProfileStackNode>> needCombineNode = stack.pop();\n+            ProfileStackElement combineTo = needCombineNode.key;\n+\n+            combineTo.setChilds(needCombineNode.value.stream().map((c) -> {\n+                ProfileStackElement element = c.buildElement();\n+                stack.add(new Pair<>(element, c.childes));\n+\n+                allNodes.add(new Pair<>(c, element));\n+\n+                return element;\n+            }).collect(Collectors.toList()));\n+        }\n+\n+        // calculate durations\n+        allNodes.parallelStream().forEach(t -> t.key.calculateDuration(t.value));\n+        allNodes.parallelStream().forEach(t -> t.key.calculateDurationExcludeChild(t.value));\n+\n+        return root;\n+    }\n+\n+    private void increase(ProfileStack stack) {\n+        this.owners.add(stack);\n+    }\n+\n+    private void combineThisNode(ProfileStackNode node) {\n+        this.owners.addAll(node.owners);\n+    }\n+\n+    private ProfileStackElement buildElement() {\n+        ProfileStackElement element = new ProfileStackElement();\n+        element.setCodeSignature(this.codeSignature);\n+        element.setChilds(new LinkedList<>());\n+        element.setCount(this.owners.size());\n+        return element;\n+    }\n+\n+    /**\n+     * calculate duration to {@link ProfileStackElement#getDuration()}\n+     */\n+    private void calculateDuration(ProfileStackElement element) {\n+        if (this.owners.size() <= 1) {\n+            element.setDuration(0);\n+            return;\n+        }\n+\n+        // sort owners\n+        Collections.sort(this.owners);\n+\n+        // calculate time windows duration\n+        ProfileStack currentTimeWindowStartStack = owners.get(0);\n+        ProfileStack currentTimeWindowEndTack = owners.get(0);\n+        long duration = 0;\n+        for (ListIterator<ProfileStack> it = owners.listIterator(1); it.hasNext(); ) {\n+            ProfileStack currentStack = it.next();\n+\n+            // is continuity\n+            if (currentTimeWindowEndTack.getSequence() + 1 != currentStack.getSequence()) {\n+                duration += currentTimeWindowEndTack.getDumpTime() - currentTimeWindowStartStack.getDumpTime();\n+                currentTimeWindowStartStack = currentTimeWindowEndTack;\n+            }\n+\n+            currentTimeWindowEndTack = currentStack;\n+        }\n+\n+        // calculate last one time windows\n+        duration += currentTimeWindowEndTack.getDumpTime() - currentTimeWindowStartStack.getDumpTime();\n+\n+        this.duration = Math.toIntExact(duration);\n+        element.setDuration(this.duration);\n+    }\n+\n+    /**\n+     * calculate duration to {@link ProfileStackElement#getDurationChildExcluded()}, expends on {@link #calculateDuration(ProfileStackElement)}\n+     * @param element\n+     */\n+    private void calculateDurationExcludeChild(ProfileStackElement element) {\n+        element.setDurationChildExcluded(element.getDuration() - childes.stream().mapToInt(t->t.duration).sum());\n+    }\n+\n+    private class Pair<K, V> {", "originalCommit": "0fd37cfa1260e96dcdb86f57b6772e4164dcaa17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNTQ2Mw==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373835463", "bodyText": "Raw use of parameterized class 'Pair'", "author": "kezhenxu94", "createdAt": "2020-02-02T10:37:47Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> childes;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.owners = new LinkedList<>();\n+        emptyNode.childes = new LinkedList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // increase self\n+        this.increase(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int childDepth = 1; childDepth < stackList.size(); childDepth++) {\n+            String elementCodeSign = stackList.get(childDepth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.childes) {\n+                if (Objects.equal(child.codeSignature, elementCodeSign)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // increase child node\n+                childElement.increase(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = createEmptyNode();\n+                childNode.codeSignature = elementCodeSign;\n+                childNode.increase(stack);\n+\n+                parent.childes.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineThisNode(node);\n+\n+        // merge tree using pre order\n+        LinkedList<Pair<ProfileStackNode, List<ProfileStackNode>>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node.childes));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, List<ProfileStackNode>> needCombineNode = stack.pop();\n+            ProfileStackNode combineTo = needCombineNode.key;\n+\n+            // merge node\n+            for (ProfileStackNode needCombineChildren : needCombineNode.value) {\n+                boolean sameReference = false;\n+                // find node\n+                ProfileStackNode combinedNode = null;\n+                for (ProfileStackNode combineNodeChildren : combineTo.childes) {\n+                    // same code signature\n+                    if (Objects.equal(needCombineChildren.codeSignature, combineNodeChildren.codeSignature)) {\n+                        // if same reference, dont need to combine anymore\n+                        if (needCombineChildren == combineNodeChildren) {\n+                            sameReference = true;\n+                        } else {\n+                            combineNodeChildren.combineThisNode(needCombineChildren);\n+                        }\n+                        combinedNode = combineNodeChildren;\n+                        break;\n+                    }\n+                }\n+\n+                if (combinedNode == null) {\n+                    combineTo.childes.add(needCombineChildren);\n+                    combinedNode = needCombineChildren;\n+                }\n+\n+                if (!sameReference) {\n+                    stack.add(new Pair(combinedNode, needCombineChildren.childes));", "originalCommit": "0fd37cfa1260e96dcdb86f57b6772e4164dcaa17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNTcxOQ==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373835719", "bodyText": "Lambda can be replaced with method reference", "author": "kezhenxu94", "createdAt": "2020-02-02T10:42:28Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileAnalyzeCollector.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfileAnalyzeCollector implements Collector<ProfileStack, ProfileStackNode, ProfileStackElement> {\n+    @Override\n+    public Supplier<ProfileStackNode> supplier() {\n+        return ProfileStackNode::createEmptyNode;\n+    }\n+\n+    @Override\n+    public BiConsumer<ProfileStackNode, ProfileStack> accumulator() {\n+        return (node, stack) -> node.accumulateFrom(stack);", "originalCommit": "19bcd18a38cc55b926da4279a97a8d5059d56a16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNTcyMw==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373835723", "bodyText": "Lambda can be replaced with method reference", "author": "kezhenxu94", "createdAt": "2020-02-02T10:42:34Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileAnalyzeCollector.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+\n+/**\n+ * @author MrPro\n+ */\n+public class ProfileAnalyzeCollector implements Collector<ProfileStack, ProfileStackNode, ProfileStackElement> {\n+    @Override\n+    public Supplier<ProfileStackNode> supplier() {\n+        return ProfileStackNode::createEmptyNode;\n+    }\n+\n+    @Override\n+    public BiConsumer<ProfileStackNode, ProfileStack> accumulator() {\n+        return (node, stack) -> node.accumulateFrom(stack);\n+    }\n+\n+    @Override\n+    public BinaryOperator<ProfileStackNode> combiner() {\n+        return (node1, node2) -> node1.combine(node2);", "originalCommit": "19bcd18a38cc55b926da4279a97a8d5059d56a16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgzNTc2Nw==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373835767", "bodyText": "no need to create a new ProfileAnalyzeCollector every time, just extract it as a field, or constant", "author": "kezhenxu94", "createdAt": "2020-02-02T10:43:12Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileAnalyzer.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileAnalyzation;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+import org.apache.skywalking.oap.server.library.util.CollectionUtils;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Analyze {@link ProfileStack} data to {@link ProfileAnalyzation}\n+ *\n+ * @author MrPro\n+ */\n+public class ProfileAnalyzer {\n+\n+    /**\n+     * Analyze records\n+     * @param stacks\n+     * @return\n+     */\n+    public static ProfileAnalyzation analyze(List<ProfileStack> stacks) {\n+        if (CollectionUtils.isEmpty(stacks)) {\n+            return null;\n+        }\n+\n+        // using parallel stream\n+        Map<String, ProfileStackElement> stackTrees = stacks.parallelStream()\n+                // stack list cannot be empty\n+                .filter(s -> CollectionUtils.isNotEmpty(s.getStack()))\n+                .collect(Collectors.groupingBy(s -> s.getStack().get(0), new ProfileAnalyzeCollector()));", "originalCommit": "19bcd18a38cc55b926da4279a97a8d5059d56a16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d978bdd740cda8e9c5cac0fa83f79cfb65679d69", "url": "https://github.com/apache/skywalking/commit/d978bdd740cda8e9c5cac0fa83f79cfb65679d69", "message": "move profile md file path, add link from code", "committedDate": "2020-02-02T11:27:35Z", "type": "commit"}, {"oid": "d47427fad68c10cf09bda2d9915b6f26e8aa7a47", "url": "https://github.com/apache/skywalking/commit/d47427fad68c10cf09bda2d9915b6f26e8aa7a47", "message": "fix issues", "committedDate": "2020-02-02T11:48:37Z", "type": "commit"}, {"oid": "29c13bb61a529c434f43bb1a8b48c04c51963f71", "url": "https://github.com/apache/skywalking/commit/29c13bb61a529c434f43bb1a8b48c04c51963f71", "message": "remove @author tag", "committedDate": "2020-02-02T11:52:08Z", "type": "commit"}, {"oid": "a289b9e80168b35672eb01a5408f1d43edf5b044", "url": "https://github.com/apache/skywalking/commit/a289b9e80168b35672eb01a5408f1d43edf5b044", "message": "fix style error", "committedDate": "2020-02-02T11:53:31Z", "type": "commit"}, {"oid": "7e52d1a92bca57172c8d1fe3a8dc9dd75e2c7e0a", "url": "https://github.com/apache/skywalking/commit/7e52d1a92bca57172c8d1fe3a8dc9dd75e2c7e0a", "message": "adding doc README link to backend-profile.md", "committedDate": "2020-02-02T12:06:34Z", "type": "commit"}, {"oid": "74d22fe25799bce0fd7ca49e2cca79b62e0107ce", "url": "https://github.com/apache/skywalking/commit/74d22fe25799bce0fd7ca49e2cca79b62e0107ce", "message": "Update backend-profile.md\n\nUpdate the description documents", "committedDate": "2020-02-02T12:56:10Z", "type": "commit"}, {"oid": "c7e2c4da099458596ddf017c10542609690e4654", "url": "https://github.com/apache/skywalking/commit/c7e2c4da099458596ddf017c10542609690e4654", "message": "Update README.md\n\nChange dev doc for profile.", "committedDate": "2020-02-02T13:05:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg0NTYwOQ==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373845609", "bodyText": "Rename owners -> detectedStacks", "author": "wu-sheng", "createdAt": "2020-02-02T13:22:42Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;", "originalCommit": "c7e2c4da099458596ddf017c10542609690e4654", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg0NTYzOQ==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373845639", "bodyText": "Use ArrayList to replace LinkedList as you are doing iteration, array is faster.", "author": "wu-sheng", "createdAt": "2020-02-02T13:23:21Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> children;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.owners = new LinkedList<>();\n+        emptyNode.children = new LinkedList<>();", "originalCommit": "c7e2c4da099458596ddf017c10542609690e4654", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkwMTg2OA==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373901868", "bodyText": "change children field to ArrayList.", "author": "mrproliu", "createdAt": "2020-02-03T02:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg0NTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg0NTY4NQ==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373845685", "bodyText": "increase -> detectedBy.", "author": "wu-sheng", "createdAt": "2020-02-02T13:24:03Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> children;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.owners = new LinkedList<>();\n+        emptyNode.children = new LinkedList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // increase self\n+        this.increase(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int childDepth = 1; childDepth < stackList.size(); childDepth++) {\n+            String elementCodeSign = stackList.get(childDepth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSign)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // increase child node\n+                childElement.increase(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = createEmptyNode();\n+                childNode.codeSignature = elementCodeSign;\n+                childNode.increase(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineThisNode(node);\n+\n+        // merge tree using pre order\n+        LinkedList<Pair<ProfileStackNode, List<ProfileStackNode>>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node.children));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, List<ProfileStackNode>> needCombineNode = stack.pop();\n+            ProfileStackNode combineTo = needCombineNode.key;\n+\n+            // merge node\n+            for (ProfileStackNode needCombineChildren : needCombineNode.value) {\n+                boolean sameReference = false;\n+                // find node\n+                ProfileStackNode combinedNode = combineTo.children.stream().filter(n -> needCombineChildren.matches(n)).findFirst().orElse(null);\n+\n+                if (combinedNode == null) {\n+                    combineTo.children.add(needCombineChildren);\n+                    combinedNode = needCombineChildren;\n+                } else if (needCombineChildren != combinedNode) {\n+                    combinedNode.combineThisNode(needCombineChildren);\n+                } else {\n+                    // if same reference, dont need to combine anymore\n+                    sameReference = true;\n+                }\n+\n+                if (!sameReference) {\n+                    stack.add(new Pair<>(combinedNode, needCombineChildren.children));\n+                }\n+            }\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * build GraphQL result, calculate duration and count data using parallels\n+     * @return\n+     */\n+    public ProfileStackElement buildAnalyzeResult() {\n+        // all nodes add to one list, work for parallel calculating\n+        LinkedList<Pair<ProfileStackNode, ProfileStackElement>> allNodes = new LinkedList<>();\n+        ProfileStackElement root = buildElement();\n+        allNodes.add(new Pair<>(this, root));\n+\n+        // using pre order, build element tree\n+        LinkedList<Pair<ProfileStackElement, List<ProfileStackNode>>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(root, this.children));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackElement, List<ProfileStackNode>> needCombineNode = stack.pop();\n+            ProfileStackElement combineTo = needCombineNode.key;\n+\n+            combineTo.setChilds(needCombineNode.value.stream().map(c -> {\n+                ProfileStackElement element = c.buildElement();\n+                stack.add(new Pair<>(element, c.children));\n+\n+                allNodes.add(new Pair<>(c, element));\n+\n+                return element;\n+            }).collect(Collectors.toList()));\n+        }\n+\n+        // calculate durations\n+        allNodes.parallelStream().forEach(t -> t.key.calculateDuration(t.value));\n+        allNodes.parallelStream().forEach(t -> t.key.calculateDurationExcludeChild(t.value));\n+\n+        return root;\n+    }\n+\n+    private void increase(ProfileStack stack) {", "originalCommit": "c7e2c4da099458596ddf017c10542609690e4654", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg0NTczMQ==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373845731", "bodyText": "createEmptyNode -> newNode", "author": "wu-sheng", "createdAt": "2020-02-02T13:24:40Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> children;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {", "originalCommit": "c7e2c4da099458596ddf017c10542609690e4654", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg0NTc2OQ==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373845769", "bodyText": "elementCodeSign -> elementCodeSignature", "author": "wu-sheng", "createdAt": "2020-02-02T13:25:14Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> children;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.owners = new LinkedList<>();\n+        emptyNode.children = new LinkedList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // increase self\n+        this.increase(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int childDepth = 1; childDepth < stackList.size(); childDepth++) {\n+            String elementCodeSign = stackList.get(childDepth);", "originalCommit": "c7e2c4da099458596ddf017c10542609690e4654", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg0NTc4NA==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373845784", "bodyText": "childDepth -> depth.", "author": "wu-sheng", "createdAt": "2020-02-02T13:25:29Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> children;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.owners = new LinkedList<>();\n+        emptyNode.children = new LinkedList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // increase self\n+        this.increase(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int childDepth = 1; childDepth < stackList.size(); childDepth++) {", "originalCommit": "c7e2c4da099458596ddf017c10542609690e4654", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg0NTkwMw==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373845903", "bodyText": "combineThisNode -> combineDetectedStacks", "author": "wu-sheng", "createdAt": "2020-02-02T13:27:24Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> children;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.owners = new LinkedList<>();\n+        emptyNode.children = new LinkedList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // increase self\n+        this.increase(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int childDepth = 1; childDepth < stackList.size(); childDepth++) {\n+            String elementCodeSign = stackList.get(childDepth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSign)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // increase child node\n+                childElement.increase(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = createEmptyNode();\n+                childNode.codeSignature = elementCodeSign;\n+                childNode.increase(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineThisNode(node);\n+\n+        // merge tree using pre order\n+        LinkedList<Pair<ProfileStackNode, List<ProfileStackNode>>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node.children));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, List<ProfileStackNode>> needCombineNode = stack.pop();\n+            ProfileStackNode combineTo = needCombineNode.key;\n+\n+            // merge node\n+            for (ProfileStackNode needCombineChildren : needCombineNode.value) {\n+                boolean sameReference = false;\n+                // find node\n+                ProfileStackNode combinedNode = combineTo.children.stream().filter(n -> needCombineChildren.matches(n)).findFirst().orElse(null);\n+\n+                if (combinedNode == null) {\n+                    combineTo.children.add(needCombineChildren);\n+                    combinedNode = needCombineChildren;\n+                } else if (needCombineChildren != combinedNode) {\n+                    combinedNode.combineThisNode(needCombineChildren);\n+                } else {\n+                    // if same reference, dont need to combine anymore\n+                    sameReference = true;\n+                }\n+\n+                if (!sameReference) {\n+                    stack.add(new Pair<>(combinedNode, needCombineChildren.children));\n+                }\n+            }\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * build GraphQL result, calculate duration and count data using parallels\n+     * @return\n+     */\n+    public ProfileStackElement buildAnalyzeResult() {\n+        // all nodes add to one list, work for parallel calculating\n+        LinkedList<Pair<ProfileStackNode, ProfileStackElement>> allNodes = new LinkedList<>();\n+        ProfileStackElement root = buildElement();\n+        allNodes.add(new Pair<>(this, root));\n+\n+        // using pre order, build element tree\n+        LinkedList<Pair<ProfileStackElement, List<ProfileStackNode>>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(root, this.children));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackElement, List<ProfileStackNode>> needCombineNode = stack.pop();\n+            ProfileStackElement combineTo = needCombineNode.key;\n+\n+            combineTo.setChilds(needCombineNode.value.stream().map(c -> {\n+                ProfileStackElement element = c.buildElement();\n+                stack.add(new Pair<>(element, c.children));\n+\n+                allNodes.add(new Pair<>(c, element));\n+\n+                return element;\n+            }).collect(Collectors.toList()));\n+        }\n+\n+        // calculate durations\n+        allNodes.parallelStream().forEach(t -> t.key.calculateDuration(t.value));\n+        allNodes.parallelStream().forEach(t -> t.key.calculateDurationExcludeChild(t.value));\n+\n+        return root;\n+    }\n+\n+    private void increase(ProfileStack stack) {\n+        this.owners.add(stack);\n+    }\n+\n+    private void combineThisNode(ProfileStackNode node) {", "originalCommit": "c7e2c4da099458596ddf017c10542609690e4654", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg0OTg2MA==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373849860", "bodyText": "Q1. Which algorithm are you using for tree merging?\nQ2. Are you using the stack to avoid recursion? The codes seem understandable, but not very clear.", "author": "wu-sheng", "createdAt": "2020-02-02T14:23:31Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> children;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.owners = new LinkedList<>();\n+        emptyNode.children = new LinkedList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // increase self\n+        this.increase(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int childDepth = 1; childDepth < stackList.size(); childDepth++) {\n+            String elementCodeSign = stackList.get(childDepth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSign)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // increase child node\n+                childElement.increase(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = createEmptyNode();\n+                childNode.codeSignature = elementCodeSign;\n+                childNode.increase(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineThisNode(node);\n+\n+        // merge tree using pre order\n+        LinkedList<Pair<ProfileStackNode, List<ProfileStackNode>>> stack = new LinkedList<>();", "originalCommit": "c7e2c4da099458596ddf017c10542609690e4654", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkwNTQ5Ng==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373905496", "bodyText": "Q1: Using LDR to traversal tree node, and merge children nodes to the parent node.\nQ2: Yes. If the stack has large tree stack depth, It will throw StackOverflowError.", "author": "mrproliu", "createdAt": "2020-02-03T02:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg0OTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg1MDUwNg==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373850506", "bodyText": "Why same reference happens?", "author": "wu-sheng", "createdAt": "2020-02-02T14:32:59Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> children;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.owners = new LinkedList<>();\n+        emptyNode.children = new LinkedList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // increase self\n+        this.increase(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int childDepth = 1; childDepth < stackList.size(); childDepth++) {\n+            String elementCodeSign = stackList.get(childDepth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSign)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // increase child node\n+                childElement.increase(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = createEmptyNode();\n+                childNode.codeSignature = elementCodeSign;\n+                childNode.increase(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineThisNode(node);\n+\n+        // merge tree using pre order\n+        LinkedList<Pair<ProfileStackNode, List<ProfileStackNode>>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node.children));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, List<ProfileStackNode>> needCombineNode = stack.pop();\n+            ProfileStackNode combineTo = needCombineNode.key;\n+\n+            // merge node\n+            for (ProfileStackNode needCombineChildren : needCombineNode.value) {\n+                boolean sameReference = false;\n+                // find node\n+                ProfileStackNode combinedNode = combineTo.children.stream().filter(n -> needCombineChildren.matches(n)).findFirst().orElse(null);\n+\n+                if (combinedNode == null) {\n+                    combineTo.children.add(needCombineChildren);\n+                    combinedNode = needCombineChildren;\n+                } else if (needCombineChildren != combinedNode) {\n+                    combinedNode.combineThisNode(needCombineChildren);\n+                } else {\n+                    // if same reference, dont need to combine anymore\n+                    sameReference = true;", "originalCommit": "c7e2c4da099458596ddf017c10542609690e4654", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkwMTc3NA==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373901774", "bodyText": "It's a bug, has fixed. If combine node from B -> A, A node not found, just need to add children node, don't need to keep merge child.", "author": "mrproliu", "createdAt": "2020-02-03T02:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg1MDUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg1MDg5OA==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373850898", "bodyText": "Why don't you use the same depth of key and value? In the following codes, you always use combineTo.children.", "author": "wu-sheng", "createdAt": "2020-02-02T14:38:57Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    // stack code signature\n+    private String codeSignature;\n+    // owner list\n+    private List<ProfileStack> owners;\n+    // children nodes\n+    private List<ProfileStackNode> children;\n+    // include the execution time of children\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode createEmptyNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.owners = new LinkedList<>();\n+        emptyNode.children = new LinkedList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // increase self\n+        this.increase(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int childDepth = 1; childDepth < stackList.size(); childDepth++) {\n+            String elementCodeSign = stackList.get(childDepth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSign)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // increase child node\n+                childElement.increase(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = createEmptyNode();\n+                childNode.codeSignature = elementCodeSign;\n+                childNode.increase(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineThisNode(node);\n+\n+        // merge tree using pre order\n+        LinkedList<Pair<ProfileStackNode, List<ProfileStackNode>>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node.children));", "originalCommit": "c7e2c4da099458596ddf017c10542609690e4654", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9f6f05925dfcb958c07b481c74d0300ebd245d1d", "url": "https://github.com/apache/skywalking/commit/9f6f05925dfcb958c07b481c74d0300ebd245d1d", "message": "1. fix name issue\n2. remove same reference, if merge to add node, dont need to keep combine again", "committedDate": "2020-02-03T02:30:30Z", "type": "commit"}, {"oid": "baf98d7149d16e439fc144b82548f613addf4357", "url": "https://github.com/apache/skywalking/commit/baf98d7149d16e439fc144b82548f613addf4357", "message": "add comments to make easy to understand", "committedDate": "2020-02-03T02:48:37Z", "type": "commit"}, {"oid": "987a995cfb49089919fa49919bdb216014ea9d1a", "url": "https://github.com/apache/skywalking/commit/987a995cfb49089919fa49919bdb216014ea9d1a", "message": "Merge branch 'master' into profile_analyze_data", "committedDate": "2020-02-03T03:07:58Z", "type": "commit"}, {"oid": "c0d2a4f33e8f86a1aa456613746359cb65666a1f", "url": "https://github.com/apache/skywalking/commit/c0d2a4f33e8f86a1aa456613746359cb65666a1f", "message": "change merge and build analyzation logic", "committedDate": "2020-02-03T03:09:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkwODEwMw==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373908103", "bodyText": "Fix comment too.", "author": "wu-sheng", "createdAt": "2020-02-03T03:14:41Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    private String codeSignature;\n+    private List<ProfileStack> detectedStacks;\n+    private List<ProfileStackNode> children;\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode newNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.detectedStacks = new LinkedList<>();\n+        emptyNode.children = new ArrayList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // increase self", "originalCommit": "987a995cfb49089919fa49919bdb216014ea9d1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f12ebd8836803f5d3f8da473ccf69979e28514df", "url": "https://github.com/apache/skywalking/commit/f12ebd8836803f5d3f8da473ccf69979e28514df", "message": "Merge remote-tracking branch 'origin/profile_analyze_data' into profile_analyze_data", "committedDate": "2020-02-03T04:02:29Z", "type": "commit"}, {"oid": "43712a9b8e1d545e55f5a63d3fcaa761064b6117", "url": "https://github.com/apache/skywalking/commit/43712a9b8e1d545e55f5a63d3fcaa761064b6117", "message": "rewrite merge tree, make merge tree algorithm more clearly", "committedDate": "2020-02-03T04:36:26Z", "type": "commit"}, {"oid": "2a1cfc308447910ece13f98b06c383d8ab640d93", "url": "https://github.com/apache/skywalking/commit/2a1cfc308447910ece13f98b06c383d8ab640d93", "message": "fix comment", "committedDate": "2020-02-03T04:39:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzODEwMg==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373938102", "bodyText": "needKeepEach -> continueChildrenMerging", "author": "wu-sheng", "createdAt": "2020-02-03T06:27:29Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    private String codeSignature;\n+    private List<ProfileStack> detectedStacks;\n+    private List<ProfileStackNode> children;\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode newNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.detectedStacks = new LinkedList<>();\n+        emptyNode.children = new ArrayList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // add detected stack\n+        this.detectedBy(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int depth = 1; depth < stackList.size(); depth++) {\n+            String elementCodeSignature = stackList.get(depth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSignature)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // add detected stack\n+                childElement.detectedBy(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = newNode();\n+                childNode.codeSignature = elementCodeSignature;\n+                childNode.detectedBy(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineDetectedStacks(node);\n+\n+        // merge tree using LDR to traversal tree node\n+        // using stack to avoid recursion\n+        // merge key.children <- value.children\n+        LinkedList<Pair<ProfileStackNode, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, ProfileStackNode> needCombineNode = stack.pop();\n+\n+            // merge value children to key\n+            // add to stack if need to keep traversal\n+            combineChildrenNodes(needCombineNode.key, needCombineNode.value, stack::add);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * merge all children nodes to appoint node\n+     * @param mergeTo\n+     * @param combineNode\n+     * @param needKeepEach if keep traversal, need report\n+     */\n+    private void combineChildrenNodes(ProfileStackNode mergeTo, ProfileStackNode combineNode, Consumer<Pair<ProfileStackNode, ProfileStackNode>> needKeepEach) {", "originalCommit": "2a1cfc308447910ece13f98b06c383d8ab640d93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkzOTUxMg==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r373939512", "bodyText": "You are iterating combineNode and process found or not, but\n\nOnce it is found, it has not been removed from mergeTo, then all elements all been process multiple times.\nYou seem missing node left in mergeTo#children, if some of them are not included in combineNode", "author": "wu-sheng", "createdAt": "2020-02-03T06:34:14Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    private String codeSignature;\n+    private List<ProfileStack> detectedStacks;\n+    private List<ProfileStackNode> children;\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode newNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.detectedStacks = new LinkedList<>();\n+        emptyNode.children = new ArrayList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // add detected stack\n+        this.detectedBy(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int depth = 1; depth < stackList.size(); depth++) {\n+            String elementCodeSignature = stackList.get(depth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSignature)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // add detected stack\n+                childElement.detectedBy(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = newNode();\n+                childNode.codeSignature = elementCodeSignature;\n+                childNode.detectedBy(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineDetectedStacks(node);\n+\n+        // merge tree using LDR to traversal tree node\n+        // using stack to avoid recursion\n+        // merge key.children <- value.children\n+        LinkedList<Pair<ProfileStackNode, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, ProfileStackNode> needCombineNode = stack.pop();\n+\n+            // merge value children to key\n+            // add to stack if need to keep traversal\n+            combineChildrenNodes(needCombineNode.key, needCombineNode.value, stack::add);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * merge all children nodes to appoint node\n+     * @param mergeTo\n+     * @param combineNode\n+     * @param needKeepEach if keep traversal, need report\n+     */\n+    private void combineChildrenNodes(ProfileStackNode mergeTo, ProfileStackNode combineNode, Consumer<Pair<ProfileStackNode, ProfileStackNode>> needKeepEach) {\n+        for (ProfileStackNode childrenNode : combineNode.children) {\n+            // find node from mergeTo children\n+            ProfileStackNode combinedNode = mergeTo.children.stream().filter(n -> childrenNode.matches(n)).findFirst().orElse(null);\n+\n+            if (combinedNode == null) {\n+                mergeTo.children.add(childrenNode);\n+            } else {\n+                combinedNode.combineDetectedStacks(childrenNode);\n+                needKeepEach.accept(new Pair<>(combinedNode, childrenNode));\n+            }", "originalCommit": "2a1cfc308447910ece13f98b06c383d8ab640d93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6a3d994284d5983b958bcacf3401d47002b1e242", "url": "https://github.com/apache/skywalking/commit/6a3d994284d5983b958bcacf3401d47002b1e242", "message": "add more test case and combine test cases to single file", "committedDate": "2020-02-03T07:00:43Z", "type": "commit"}, {"oid": "72c6cb7929d30a10c40dfc1b98db32aa76ecbf50", "url": "https://github.com/apache/skywalking/commit/72c6cb7929d30a10c40dfc1b98db32aa76ecbf50", "message": "fix name issue", "committedDate": "2020-02-03T07:02:02Z", "type": "commit"}, {"oid": "6f1a8106163b07d3d2f87022e2b0f7595b203b19", "url": "https://github.com/apache/skywalking/commit/6f1a8106163b07d3d2f87022e2b0f7595b203b19", "message": "fix style error", "committedDate": "2020-02-03T07:38:15Z", "type": "commit"}, {"oid": "f7fa324c152ffbeffd01aab8d97613ab5e3612d8", "url": "https://github.com/apache/skywalking/commit/f7fa324c152ffbeffd01aab8d97613ab5e3612d8", "message": "change name issue", "committedDate": "2020-02-03T08:20:55Z", "type": "commit"}, {"oid": "268edc3bb4e4e8d98102ce3928d63648ec638348", "url": "https://github.com/apache/skywalking/commit/268edc3bb4e4e8d98102ce3928d63648ec638348", "message": "optimize combine node algorithm", "committedDate": "2020-02-03T10:59:14Z", "type": "commit"}, {"oid": "7f2e5b744ed9678381fecb798a0a0fb7f6b6530b", "url": "https://github.com/apache/skywalking/commit/7f2e5b744ed9678381fecb798a0a0fb7f6b6530b", "message": "fix wrong name", "committedDate": "2020-02-03T11:41:46Z", "type": "commit"}, {"oid": "222bcaedd4dbf9c934cc3adcb2e815d4e541b1be", "url": "https://github.com/apache/skywalking/commit/222bcaedd4dbf9c934cc3adcb2e815d4e541b1be", "message": "change logic", "committedDate": "2020-02-03T12:57:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA5MzUyOA==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r374093528", "bodyText": "needCombineNode -> MergingPair", "author": "wu-sheng", "createdAt": "2020-02-03T13:13:29Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    private String codeSignature;\n+    private List<ProfileStack> detectedStacks;\n+    private List<ProfileStackNode> children;\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode newNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.detectedStacks = new LinkedList<>();\n+        emptyNode.children = new ArrayList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // add detected stack\n+        this.detectedBy(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int depth = 1; depth < stackList.size(); depth++) {\n+            String elementCodeSignature = stackList.get(depth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSignature)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // add detected stack\n+                childElement.detectedBy(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = newNode();\n+                childNode.codeSignature = elementCodeSignature;\n+                childNode.detectedBy(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineDetectedStacks(node);\n+\n+        // merge tree using LDR to traversal tree node\n+        // using stack to avoid recursion\n+        // merge key.children <- value.children\n+        LinkedList<Pair<ProfileStackNode, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, ProfileStackNode> needCombineNode = stack.pop();\n+\n+            // merge value children to key\n+            // add to stack if need to keep traversal\n+            combineChildrenNodes(needCombineNode.key, needCombineNode.value, stack::add);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * merge all children nodes to appoint node\n+     * @param targetNode\n+     * @param beingMergedNode\n+     * @param continueChildrenMerging\n+     */\n+    private void combineChildrenNodes(ProfileStackNode targetNode, ProfileStackNode beingMergedNode, Consumer<Pair<ProfileStackNode, ProfileStackNode>> continueChildrenMerging) {\n+        if (beingMergedNode.children.isEmpty()) {\n+            return;\n+        }\n+\n+        for (ProfileStackNode childrenNode : targetNode.children) {\n+            // find node from being merged node children\n+            for (ListIterator<ProfileStackNode> it = beingMergedNode.children.listIterator(); it.hasNext();) {\n+                ProfileStackNode node = it.next();\n+                if (node != null && node.matches(childrenNode)) {\n+                    childrenNode.combineDetectedStacks(node);\n+                    continueChildrenMerging.accept(new Pair<>(childrenNode, node));\n+\n+                    it.set(null);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // targetNode.children add to beingMergedNode.children, merge children to single list\n+        int searchingIndex = 0;\n+        int beingMergeChildrenCount = beingMergedNode.children.size();\n+        for (int nodeInx = 0; nodeInx < targetNode.children.size(); ) {\n+            if (searchingIndex >= beingMergeChildrenCount) {\n+                beingMergedNode.children.addAll(targetNode.children.subList(nodeInx, targetNode.children.size()));\n+                break;\n+            }\n+            for (; searchingIndex < beingMergeChildrenCount; searchingIndex++) {\n+                if (beingMergedNode.children.get(searchingIndex) == null) {\n+                    beingMergedNode.children.set(searchingIndex, targetNode.children.get(nodeInx));\n+                    nodeInx++;\n+                    break;\n+                }\n+            }\n+        }\n+        targetNode.children = beingMergedNode.children;\n+    }\n+\n+    /**\n+     * build GraphQL result, calculate duration and count data using parallels\n+     * @return\n+     */\n+    public ProfileStackElement buildAnalyzeResult() {\n+        // all nodes add to single-level list (such as flat), work for parallel calculating\n+        LinkedList<Pair<ProfileStackElement, ProfileStackNode>> nodeMapping = new LinkedList<>();\n+        ProfileStackElement root = buildElement();\n+        nodeMapping.add(new Pair<>(root, this));\n+\n+        // same with combine logic\n+        LinkedList<Pair<ProfileStackElement, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(root, this));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackElement, ProfileStackNode> needCombineNode = stack.pop();", "originalCommit": "7f2e5b744ed9678381fecb798a0a0fb7f6b6530b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA5MzY4NA==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r374093684", "bodyText": "combineTo -> respElement", "author": "wu-sheng", "createdAt": "2020-02-03T13:13:54Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    private String codeSignature;\n+    private List<ProfileStack> detectedStacks;\n+    private List<ProfileStackNode> children;\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode newNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.detectedStacks = new LinkedList<>();\n+        emptyNode.children = new ArrayList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // add detected stack\n+        this.detectedBy(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int depth = 1; depth < stackList.size(); depth++) {\n+            String elementCodeSignature = stackList.get(depth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSignature)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // add detected stack\n+                childElement.detectedBy(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = newNode();\n+                childNode.codeSignature = elementCodeSignature;\n+                childNode.detectedBy(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineDetectedStacks(node);\n+\n+        // merge tree using LDR to traversal tree node\n+        // using stack to avoid recursion\n+        // merge key.children <- value.children\n+        LinkedList<Pair<ProfileStackNode, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, ProfileStackNode> needCombineNode = stack.pop();\n+\n+            // merge value children to key\n+            // add to stack if need to keep traversal\n+            combineChildrenNodes(needCombineNode.key, needCombineNode.value, stack::add);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * merge all children nodes to appoint node\n+     * @param targetNode\n+     * @param beingMergedNode\n+     * @param continueChildrenMerging\n+     */\n+    private void combineChildrenNodes(ProfileStackNode targetNode, ProfileStackNode beingMergedNode, Consumer<Pair<ProfileStackNode, ProfileStackNode>> continueChildrenMerging) {\n+        if (beingMergedNode.children.isEmpty()) {\n+            return;\n+        }\n+\n+        for (ProfileStackNode childrenNode : targetNode.children) {\n+            // find node from being merged node children\n+            for (ListIterator<ProfileStackNode> it = beingMergedNode.children.listIterator(); it.hasNext();) {\n+                ProfileStackNode node = it.next();\n+                if (node != null && node.matches(childrenNode)) {\n+                    childrenNode.combineDetectedStacks(node);\n+                    continueChildrenMerging.accept(new Pair<>(childrenNode, node));\n+\n+                    it.set(null);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // targetNode.children add to beingMergedNode.children, merge children to single list\n+        int searchingIndex = 0;\n+        int beingMergeChildrenCount = beingMergedNode.children.size();\n+        for (int nodeInx = 0; nodeInx < targetNode.children.size(); ) {\n+            if (searchingIndex >= beingMergeChildrenCount) {\n+                beingMergedNode.children.addAll(targetNode.children.subList(nodeInx, targetNode.children.size()));\n+                break;\n+            }\n+            for (; searchingIndex < beingMergeChildrenCount; searchingIndex++) {\n+                if (beingMergedNode.children.get(searchingIndex) == null) {\n+                    beingMergedNode.children.set(searchingIndex, targetNode.children.get(nodeInx));\n+                    nodeInx++;\n+                    break;\n+                }\n+            }\n+        }\n+        targetNode.children = beingMergedNode.children;\n+    }\n+\n+    /**\n+     * build GraphQL result, calculate duration and count data using parallels\n+     * @return\n+     */\n+    public ProfileStackElement buildAnalyzeResult() {\n+        // all nodes add to single-level list (such as flat), work for parallel calculating\n+        LinkedList<Pair<ProfileStackElement, ProfileStackNode>> nodeMapping = new LinkedList<>();\n+        ProfileStackElement root = buildElement();\n+        nodeMapping.add(new Pair<>(root, this));\n+\n+        // same with combine logic\n+        LinkedList<Pair<ProfileStackElement, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(root, this));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackElement, ProfileStackNode> needCombineNode = stack.pop();\n+            ProfileStackElement combineTo = needCombineNode.key;", "originalCommit": "7f2e5b744ed9678381fecb798a0a0fb7f6b6530b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA5NjQ3NQ==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r374096475", "bodyText": "Why require ProfileStackNode(t.value) to calculate duration? Using List should be enough", "author": "wu-sheng", "createdAt": "2020-02-03T13:20:07Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    private String codeSignature;\n+    private List<ProfileStack> detectedStacks;\n+    private List<ProfileStackNode> children;\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode newNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.detectedStacks = new LinkedList<>();\n+        emptyNode.children = new ArrayList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // add detected stack\n+        this.detectedBy(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int depth = 1; depth < stackList.size(); depth++) {\n+            String elementCodeSignature = stackList.get(depth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSignature)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // add detected stack\n+                childElement.detectedBy(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = newNode();\n+                childNode.codeSignature = elementCodeSignature;\n+                childNode.detectedBy(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineDetectedStacks(node);\n+\n+        // merge tree using LDR to traversal tree node\n+        // using stack to avoid recursion\n+        // merge key.children <- value.children\n+        LinkedList<Pair<ProfileStackNode, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, ProfileStackNode> needCombineNode = stack.pop();\n+\n+            // merge value children to key\n+            // add to stack if need to keep traversal\n+            combineChildrenNodes(needCombineNode.key, needCombineNode.value, stack::add);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * merge all children nodes to appoint node\n+     * @param targetNode\n+     * @param beingMergedNode\n+     * @param continueChildrenMerging\n+     */\n+    private void combineChildrenNodes(ProfileStackNode targetNode, ProfileStackNode beingMergedNode, Consumer<Pair<ProfileStackNode, ProfileStackNode>> continueChildrenMerging) {\n+        if (beingMergedNode.children.isEmpty()) {\n+            return;\n+        }\n+\n+        for (ProfileStackNode childrenNode : targetNode.children) {\n+            // find node from being merged node children\n+            for (ListIterator<ProfileStackNode> it = beingMergedNode.children.listIterator(); it.hasNext();) {\n+                ProfileStackNode node = it.next();\n+                if (node != null && node.matches(childrenNode)) {\n+                    childrenNode.combineDetectedStacks(node);\n+                    continueChildrenMerging.accept(new Pair<>(childrenNode, node));\n+\n+                    it.set(null);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // targetNode.children add to beingMergedNode.children, merge children to single list\n+        int searchingIndex = 0;\n+        int beingMergeChildrenCount = beingMergedNode.children.size();\n+        for (int nodeInx = 0; nodeInx < targetNode.children.size(); ) {\n+            if (searchingIndex >= beingMergeChildrenCount) {\n+                beingMergedNode.children.addAll(targetNode.children.subList(nodeInx, targetNode.children.size()));\n+                break;\n+            }\n+            for (; searchingIndex < beingMergeChildrenCount; searchingIndex++) {\n+                if (beingMergedNode.children.get(searchingIndex) == null) {\n+                    beingMergedNode.children.set(searchingIndex, targetNode.children.get(nodeInx));\n+                    nodeInx++;\n+                    break;\n+                }\n+            }\n+        }\n+        targetNode.children = beingMergedNode.children;\n+    }\n+\n+    /**\n+     * build GraphQL result, calculate duration and count data using parallels\n+     * @return\n+     */\n+    public ProfileStackElement buildAnalyzeResult() {\n+        // all nodes add to single-level list (such as flat), work for parallel calculating\n+        LinkedList<Pair<ProfileStackElement, ProfileStackNode>> nodeMapping = new LinkedList<>();\n+        ProfileStackElement root = buildElement();\n+        nodeMapping.add(new Pair<>(root, this));\n+\n+        // same with combine logic\n+        LinkedList<Pair<ProfileStackElement, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(root, this));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackElement, ProfileStackNode> needCombineNode = stack.pop();\n+            ProfileStackElement combineTo = needCombineNode.key;\n+\n+            // generate children node and add to stack and all node mapping\n+            combineTo.setChilds(needCombineNode.value.children.stream().map(c -> {\n+                ProfileStackElement element = c.buildElement();\n+                Pair<ProfileStackElement, ProfileStackNode> pair = new Pair<>(element, c);\n+                stack.add(pair);\n+                nodeMapping.add(pair);\n+\n+                return element;\n+            }).collect(Collectors.toList()));\n+        }\n+\n+        // calculate durations\n+        nodeMapping.parallelStream().forEach(t -> t.value.calculateDuration(t.key));", "originalCommit": "7f2e5b744ed9678381fecb798a0a0fb7f6b6530b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA5NjcyMw==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r374096723", "bodyText": "Why run parallelStream twice? Calculating two kinds of duration should be faster.", "author": "wu-sheng", "createdAt": "2020-02-03T13:20:41Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    private String codeSignature;\n+    private List<ProfileStack> detectedStacks;\n+    private List<ProfileStackNode> children;\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode newNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.detectedStacks = new LinkedList<>();\n+        emptyNode.children = new ArrayList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // add detected stack\n+        this.detectedBy(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int depth = 1; depth < stackList.size(); depth++) {\n+            String elementCodeSignature = stackList.get(depth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSignature)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // add detected stack\n+                childElement.detectedBy(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = newNode();\n+                childNode.codeSignature = elementCodeSignature;\n+                childNode.detectedBy(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineDetectedStacks(node);\n+\n+        // merge tree using LDR to traversal tree node\n+        // using stack to avoid recursion\n+        // merge key.children <- value.children\n+        LinkedList<Pair<ProfileStackNode, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, ProfileStackNode> needCombineNode = stack.pop();\n+\n+            // merge value children to key\n+            // add to stack if need to keep traversal\n+            combineChildrenNodes(needCombineNode.key, needCombineNode.value, stack::add);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * merge all children nodes to appoint node\n+     * @param targetNode\n+     * @param beingMergedNode\n+     * @param continueChildrenMerging\n+     */\n+    private void combineChildrenNodes(ProfileStackNode targetNode, ProfileStackNode beingMergedNode, Consumer<Pair<ProfileStackNode, ProfileStackNode>> continueChildrenMerging) {\n+        if (beingMergedNode.children.isEmpty()) {\n+            return;\n+        }\n+\n+        for (ProfileStackNode childrenNode : targetNode.children) {\n+            // find node from being merged node children\n+            for (ListIterator<ProfileStackNode> it = beingMergedNode.children.listIterator(); it.hasNext();) {\n+                ProfileStackNode node = it.next();\n+                if (node != null && node.matches(childrenNode)) {\n+                    childrenNode.combineDetectedStacks(node);\n+                    continueChildrenMerging.accept(new Pair<>(childrenNode, node));\n+\n+                    it.set(null);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // targetNode.children add to beingMergedNode.children, merge children to single list\n+        int searchingIndex = 0;\n+        int beingMergeChildrenCount = beingMergedNode.children.size();\n+        for (int nodeInx = 0; nodeInx < targetNode.children.size(); ) {\n+            if (searchingIndex >= beingMergeChildrenCount) {\n+                beingMergedNode.children.addAll(targetNode.children.subList(nodeInx, targetNode.children.size()));\n+                break;\n+            }\n+            for (; searchingIndex < beingMergeChildrenCount; searchingIndex++) {\n+                if (beingMergedNode.children.get(searchingIndex) == null) {\n+                    beingMergedNode.children.set(searchingIndex, targetNode.children.get(nodeInx));\n+                    nodeInx++;\n+                    break;\n+                }\n+            }\n+        }\n+        targetNode.children = beingMergedNode.children;\n+    }\n+\n+    /**\n+     * build GraphQL result, calculate duration and count data using parallels\n+     * @return\n+     */\n+    public ProfileStackElement buildAnalyzeResult() {\n+        // all nodes add to single-level list (such as flat), work for parallel calculating\n+        LinkedList<Pair<ProfileStackElement, ProfileStackNode>> nodeMapping = new LinkedList<>();\n+        ProfileStackElement root = buildElement();\n+        nodeMapping.add(new Pair<>(root, this));\n+\n+        // same with combine logic\n+        LinkedList<Pair<ProfileStackElement, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(root, this));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackElement, ProfileStackNode> needCombineNode = stack.pop();\n+            ProfileStackElement combineTo = needCombineNode.key;\n+\n+            // generate children node and add to stack and all node mapping\n+            combineTo.setChilds(needCombineNode.value.children.stream().map(c -> {\n+                ProfileStackElement element = c.buildElement();\n+                Pair<ProfileStackElement, ProfileStackNode> pair = new Pair<>(element, c);\n+                stack.add(pair);\n+                nodeMapping.add(pair);\n+\n+                return element;\n+            }).collect(Collectors.toList()));\n+        }\n+\n+        // calculate durations\n+        nodeMapping.parallelStream().forEach(t -> t.value.calculateDuration(t.key));\n+        nodeMapping.parallelStream().forEach(t -> t.value.calculateDurationExcludeChild(t.key));", "originalCommit": "7f2e5b744ed9678381fecb798a0a0fb7f6b6530b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f32bde462d35af3f49c167b2490eb3fd3c2a373", "url": "https://github.com/apache/skywalking/commit/0f32bde462d35af3f49c167b2490eb3fd3c2a373", "message": "fix name issue", "committedDate": "2020-02-03T13:55:45Z", "type": "commit"}, {"oid": "c8729919759e6fe3eda254b7c7f0e12173e508fc", "url": "https://github.com/apache/skywalking/commit/c8729919759e6fe3eda254b7c7f0e12173e508fc", "message": "fix name issue", "committedDate": "2020-02-03T13:58:34Z", "type": "commit"}, {"oid": "4070afa008349e605faf6fd47bad8ea70c1fda81", "url": "https://github.com/apache/skywalking/commit/4070afa008349e605faf6fd47bad8ea70c1fda81", "message": "add new test case", "committedDate": "2020-02-04T01:50:44Z", "type": "commit"}, {"oid": "c3ab10f3ccfddfd812234a7f51f4e0803f9222dc", "url": "https://github.com/apache/skywalking/commit/c3ab10f3ccfddfd812234a7f51f4e0803f9222dc", "message": "Merge branch 'master' into profile_analyze_data", "committedDate": "2020-02-04T02:02:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ1NzY4MQ==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r374457681", "bodyText": "owners -> detectedStacks, but I think the code itself is documentation already", "author": "kezhenxu94", "createdAt": "2020-02-04T03:25:33Z", "path": "oap-server/server-core/src/main/java/org/apache/skywalking/oap/server/core/profile/analyze/ProfileStackNode.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.apache.skywalking.oap.server.core.profile.analyze;\n+\n+import com.google.common.base.Objects;\n+import org.apache.skywalking.oap.server.core.query.entity.ProfileStackElement;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Work for profiling stacks, intermediate state of the {@link ProfileStackElement} and {@link ProfileStack}\n+ */\n+public class ProfileStackNode {\n+\n+    private String codeSignature;\n+    private List<ProfileStack> detectedStacks;\n+    private List<ProfileStackNode> children;\n+    private int duration;\n+\n+    /**\n+     * create new empty, un-init node\n+     * @return\n+     */\n+    public static ProfileStackNode newNode() {\n+        ProfileStackNode emptyNode = new ProfileStackNode();\n+        emptyNode.detectedStacks = new LinkedList<>();\n+        emptyNode.children = new ArrayList<>();\n+        return emptyNode;\n+    }\n+\n+    /**\n+     * accumulate {@link ProfileStack} to this tree, it will invoke on the tree root node\n+     * @param stack\n+     */\n+    public void accumulateFrom(ProfileStack stack) {\n+        List<String> stackList = stack.getStack();\n+        if (codeSignature == null) {\n+            codeSignature = stackList.get(0);\n+        }\n+        // add detected stack\n+        this.detectedBy(stack);\n+\n+        // handle stack children\n+        ProfileStackNode parent = this;\n+        for (int depth = 1; depth < stackList.size(); depth++) {\n+            String elementCodeSignature = stackList.get(depth);\n+\n+            // find same code signature children\n+            ProfileStackNode childElement = null;\n+            for (ProfileStackNode child : parent.children) {\n+                if (Objects.equal(child.codeSignature, elementCodeSignature)) {\n+                    childElement = child;\n+                    break;\n+                }\n+            }\n+\n+            if (childElement != null) {\n+                // add detected stack\n+                childElement.detectedBy(stack);\n+                parent = childElement;\n+            } else {\n+                // add children\n+                ProfileStackNode childNode = newNode();\n+                childNode.codeSignature = elementCodeSignature;\n+                childNode.detectedBy(stack);\n+\n+                parent.children.add(childNode);\n+                parent = childNode;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * combine from other {@link ProfileStackNode}\n+     * @param node\n+     * @return\n+     */\n+    public ProfileStackNode combine(ProfileStackNode node) {\n+        // combine this node\n+        this.combineDetectedStacks(node);\n+\n+        // merge tree using LDR to traversal tree node\n+        // using stack to avoid recursion\n+        // merge key.children <- value.children\n+        LinkedList<Pair<ProfileStackNode, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(this, node));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackNode, ProfileStackNode> needCombineNode = stack.pop();\n+\n+            // merge value children to key\n+            // add to stack if need to keep traversal\n+            combineChildrenNodes(needCombineNode.key, needCombineNode.value, stack::add);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * merge all children nodes to appoint node\n+     * @param targetNode\n+     * @param beingMergedNode\n+     * @param continueChildrenMerging\n+     */\n+    private void combineChildrenNodes(ProfileStackNode targetNode, ProfileStackNode beingMergedNode, Consumer<Pair<ProfileStackNode, ProfileStackNode>> continueChildrenMerging) {\n+        if (beingMergedNode.children.isEmpty()) {\n+            return;\n+        }\n+\n+        for (ProfileStackNode childrenNode : targetNode.children) {\n+            // find node from being merged node children\n+            for (ListIterator<ProfileStackNode> it = beingMergedNode.children.listIterator(); it.hasNext();) {\n+                ProfileStackNode node = it.next();\n+                if (node != null && node.matches(childrenNode)) {\n+                    childrenNode.combineDetectedStacks(node);\n+                    continueChildrenMerging.accept(new Pair<>(childrenNode, node));\n+\n+                    it.set(null);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        for (ProfileStackNode node : beingMergedNode.children) {\n+            if (node != null) {\n+                targetNode.children.add(node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * build GraphQL result, calculate duration and count data using parallels\n+     * @return\n+     */\n+    public ProfileStackElement buildAnalyzeResult() {\n+        // all nodes add to single-level list (such as flat), work for parallel calculating\n+        LinkedList<Pair<ProfileStackElement, ProfileStackNode>> nodeMapping = new LinkedList<>();\n+        ProfileStackElement root = buildElement();\n+        nodeMapping.add(new Pair<>(root, this));\n+\n+        // same with combine logic\n+        LinkedList<Pair<ProfileStackElement, ProfileStackNode>> stack = new LinkedList<>();\n+        stack.add(new Pair<>(root, this));\n+        while (!stack.isEmpty()) {\n+            Pair<ProfileStackElement, ProfileStackNode> mergingPair = stack.pop();\n+            ProfileStackElement respElement = mergingPair.key;\n+\n+            // generate children node and add to stack and all node mapping\n+            respElement.setChildren(mergingPair.value.children.stream().map(c -> {\n+                ProfileStackElement element = c.buildElement();\n+                Pair<ProfileStackElement, ProfileStackNode> pair = new Pair<>(element, c);\n+                stack.add(pair);\n+                nodeMapping.add(pair);\n+\n+                return element;\n+            }).collect(Collectors.toList()));\n+        }\n+\n+        // calculate durations\n+        nodeMapping.parallelStream().forEach(t -> t.value.calculateDuration(t.key));\n+        nodeMapping.parallelStream().forEach(t -> t.value.calculateDurationExcludeChild(t.key));\n+\n+        return root;\n+    }\n+\n+    private void detectedBy(ProfileStack stack) {\n+        this.detectedStacks.add(stack);\n+    }\n+\n+    private void combineDetectedStacks(ProfileStackNode node) {\n+        this.detectedStacks.addAll(node.detectedStacks);\n+    }\n+\n+    private ProfileStackElement buildElement() {\n+        ProfileStackElement element = new ProfileStackElement();\n+        element.setCodeSignature(this.codeSignature);\n+        element.setChildren(new LinkedList<>());\n+        element.setCount(this.detectedStacks.size());\n+        return element;\n+    }\n+\n+    /**\n+     * calculate duration to {@link ProfileStackElement#getDuration()}\n+     */\n+    private void calculateDuration(ProfileStackElement element) {\n+        if (this.detectedStacks.size() <= 1) {\n+            element.setDuration(0);\n+            return;\n+        }\n+\n+        // sort owners", "originalCommit": "c3ab10f3ccfddfd812234a7f51f4e0803f9222dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ1ODcyOA==", "url": "https://github.com/apache/skywalking/pull/4308#discussion_r374458728", "bodyText": "Ok, I understand. I will delete this comment", "author": "mrproliu", "createdAt": "2020-02-04T03:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ1NzY4MQ=="}], "type": "inlineReview"}, {"oid": "ea99cdda2eb5b742c7f50d9f44001334d6b87a35", "url": "https://github.com/apache/skywalking/commit/ea99cdda2eb5b742c7f50d9f44001334d6b87a35", "message": "delete useless comment", "committedDate": "2020-02-04T03:32:25Z", "type": "commit"}, {"oid": "fd6d945b9811c2e6061ed3a011a3bf26c38dd5e5", "url": "https://github.com/apache/skywalking/commit/fd6d945b9811c2e6061ed3a011a3bf26c38dd5e5", "message": "Merge branch 'profile_analyze_data' of https://github.com/mrproliu/skywalking into profile_analyze_data", "committedDate": "2020-02-04T03:38:23Z", "type": "commit"}, {"oid": "14af0f2c8a512b9afed33916d546700ecf244cec", "url": "https://github.com/apache/skywalking/commit/14af0f2c8a512b9afed33916d546700ecf244cec", "message": "update the logic describe", "committedDate": "2020-02-04T04:30:37Z", "type": "commit"}, {"oid": "bf15455d065af84c14ecd3016468ebe2ac1e5f36", "url": "https://github.com/apache/skywalking/commit/bf15455d065af84c14ecd3016468ebe2ac1e5f36", "message": "Update backend-profile.md", "committedDate": "2020-02-04T06:38:35Z", "type": "commit"}, {"oid": "e139fe0df62e5e4e15d797002edff5da369f889a", "url": "https://github.com/apache/skywalking/commit/e139fe0df62e5e4e15d797002edff5da369f889a", "message": "add group by doc", "committedDate": "2020-02-04T07:38:29Z", "type": "commit"}]}