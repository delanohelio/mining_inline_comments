{"pr_number": 467, "pr_title": "Add support message templates in EmitEachSelector", "pr_createdAt": "2020-06-15T07:02:17Z", "pr_url": "https://github.com/awslabs/smithy/pull/467", "timeline": [{"oid": "507a7d1f99da6ee5a04cc706b622b61513aa56b4", "url": "https://github.com/awslabs/smithy/commit/507a7d1f99da6ee5a04cc706b622b61513aa56b4", "message": "Add support message templates in EmitEachSelector\n\nThis commit adds support for templated messages in the EmitEachSelector\nthat are able to reference variables captured while shapes are matched.\nThis allows for very rich and descriptive error messages that generally\nare as good as error messages in code-driven Smithy validators.\n\nIn order to pull this, it required that attribute value selector context\nvalues could be parsed from a message template. Since context values are\nalready parsed as part of parsing selectors, this motivated me to reuse\nthe existing selector's parsing functionality. To do this, I created a\nSimpleParser abstraction that extracts out lots of the duplicate parsing\ncode in Smithy into a single class. This allowed parsing of attributes\nto be shared, but it was also an opportunity to trim down duplicate code\nand reuse parsing logic across the IDL and selectors.", "committedDate": "2020-06-15T17:00:14Z", "type": "forcePushed"}, {"oid": "7b6a77f56ff0656d571abf77fdbaa28cdeb02115", "url": "https://github.com/awslabs/smithy/commit/7b6a77f56ff0656d571abf77fdbaa28cdeb02115", "message": "Add support message templates in EmitEachSelector\n\nThis commit adds support for templated messages in the EmitEachSelector\nthat are able to reference variables captured while shapes are matched.\nThis allows for very rich and descriptive error messages that generally\nare as good as error messages in code-driven Smithy validators.\n\nIn order to pull this, it required that attribute value selector context\nvalues could be parsed from a message template. Since context values are\nalready parsed as part of parsing selectors, this motivated me to reuse\nthe existing selector's parsing functionality. To do this, I created a\nSimpleParser abstraction that extracts out lots of the duplicate parsing\ncode in Smithy into a single class. This allowed parsing of attributes\nto be shared, but it was also an opportunity to trim down duplicate code\nand reuse parsing logic across the IDL and selectors.", "committedDate": "2020-06-15T18:36:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0MTQ0MA==", "url": "https://github.com/awslabs/smithy/pull/467#discussion_r441041440", "bodyText": "must be", "author": "kstich", "createdAt": "2020-06-16T18:02:28Z", "path": "smithy-utils/src/main/java/software/amazon/smithy/utils/SimpleParser.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.utils;\n+\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A simple expression parser that can be extended to implement parsers\n+ * for small domain specific languages.\n+ *\n+ * <p>This parser consumes characters of an in-memory string while tracking\n+ * the current 0-based position, 1-based line, and 1-based column.\n+ * Expectations can be made on the parser to require specific characters,\n+ * and when those expectations are not met, a syntax exception is thrown.\n+ */\n+public class SimpleParser {\n+\n+    private final String expression;\n+    private final int length;\n+    private final int maxNestingLevel;\n+    private int position = 0;\n+    private int line = 1;\n+    private int column = 1;\n+    private int nestingLevel = 0;\n+\n+    /**\n+     * Creates a new SimpleParser and sets the expression to parse.\n+     *\n+     * @param expression Expression to parser.\n+     */\n+    public SimpleParser(String expression) {\n+        this(expression, 0);\n+    }\n+\n+    /**\n+     * Creates a new SimpleParser and sets the expression to parse.\n+     *\n+     * <p>By default, no maximum parsing level is enforced. Setting the\n+     * {@code maxParsingLevel} to 0 disables the enforcement of a\n+     * maximum parsing level.\n+     *\n+     * @param expression Expression to parser.\n+     * @param maxNestingLevel The maximum allowed nesting level of the parser.\n+     */\n+    public SimpleParser(String expression, int maxNestingLevel) {\n+        this.expression = Objects.requireNonNull(expression, \"expression must not be null\");\n+        this.length = expression.length();\n+\n+        if (maxNestingLevel < 0) {\n+            throw new IllegalArgumentException(\"maxNestingLevel be >= 0\");", "originalCommit": "7b6a77f56ff0656d571abf77fdbaa28cdeb02115", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0MjM0Nw==", "url": "https://github.com/awslabs/smithy/pull/467#discussion_r441042347", "bodyText": "This is a duplicate check with the constructor.", "author": "kstich", "createdAt": "2020-06-16T18:04:09Z", "path": "smithy-utils/src/main/java/software/amazon/smithy/utils/SimpleParser.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.utils;\n+\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A simple expression parser that can be extended to implement parsers\n+ * for small domain specific languages.\n+ *\n+ * <p>This parser consumes characters of an in-memory string while tracking\n+ * the current 0-based position, 1-based line, and 1-based column.\n+ * Expectations can be made on the parser to require specific characters,\n+ * and when those expectations are not met, a syntax exception is thrown.\n+ */\n+public class SimpleParser {\n+\n+    private final String expression;\n+    private final int length;\n+    private final int maxNestingLevel;\n+    private int position = 0;\n+    private int line = 1;\n+    private int column = 1;\n+    private int nestingLevel = 0;\n+\n+    /**\n+     * Creates a new SimpleParser and sets the expression to parse.\n+     *\n+     * @param expression Expression to parser.\n+     */\n+    public SimpleParser(String expression) {\n+        this(expression, 0);\n+    }\n+\n+    /**\n+     * Creates a new SimpleParser and sets the expression to parse.\n+     *\n+     * <p>By default, no maximum parsing level is enforced. Setting the\n+     * {@code maxParsingLevel} to 0 disables the enforcement of a\n+     * maximum parsing level.\n+     *\n+     * @param expression Expression to parser.\n+     * @param maxNestingLevel The maximum allowed nesting level of the parser.\n+     */\n+    public SimpleParser(String expression, int maxNestingLevel) {\n+        this.expression = Objects.requireNonNull(expression, \"expression must not be null\");\n+        this.length = expression.length();\n+\n+        if (maxNestingLevel < 0) {\n+            throw new IllegalArgumentException(\"maxNestingLevel be >= 0\");\n+        }\n+\n+        this.maxNestingLevel = maxNestingLevel;\n+    }\n+\n+    /**\n+     * Gets the expression being parsed.\n+     *\n+     * @return Returns the expression being parsed.\n+     * @throws NullPointerException if the expression has not been set.\n+     */\n+    public final String expression() {\n+        return Objects.requireNonNull(expression, \"Expression has not been set on \" + getClass());", "originalCommit": "7b6a77f56ff0656d571abf77fdbaa28cdeb02115", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "09822e827771087396b2c5c8f0f28e63385b540b", "url": "https://github.com/awslabs/smithy/commit/09822e827771087396b2c5c8f0f28e63385b540b", "message": "Add support message templates in EmitEachSelector\n\nThis commit adds support for templated messages in the EmitEachSelector\nthat are able to reference variables captured while shapes are matched.\nThis allows for very rich and descriptive error messages that generally\nare as good as error messages in code-driven Smithy validators.\n\nIn order to pull this, it required that attribute value selector context\nvalues could be parsed from a message template. Since context values are\nalready parsed as part of parsing selectors, this motivated me to reuse\nthe existing selector's parsing functionality. To do this, I created a\nSimpleParser abstraction that extracts out lots of the duplicate parsing\ncode in Smithy into a single class. This allowed parsing of attributes\nto be shared, but it was also an opportunity to trim down duplicate code\nand reuse parsing logic across the IDL and selectors.", "committedDate": "2020-06-16T19:13:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMDE5Mw==", "url": "https://github.com/awslabs/smithy/pull/467#discussion_r441210193", "bodyText": "Would it be useful to say what the max nesting level is?", "author": "JordonPhillips", "createdAt": "2020-06-17T00:14:36Z", "path": "smithy-utils/src/main/java/software/amazon/smithy/utils/SimpleParser.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.utils;\n+\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A simple expression parser that can be extended to implement parsers\n+ * for small domain specific languages.\n+ *\n+ * <p>This parser consumes characters of an in-memory string while tracking\n+ * the current 0-based position, 1-based line, and 1-based column.\n+ * Expectations can be made on the parser to require specific characters,\n+ * and when those expectations are not met, a syntax exception is thrown.\n+ */\n+public class SimpleParser {\n+\n+    private final String expression;\n+    private final int length;\n+    private final int maxNestingLevel;\n+    private int position = 0;\n+    private int line = 1;\n+    private int column = 1;\n+    private int nestingLevel = 0;\n+\n+    /**\n+     * Creates a new SimpleParser and sets the expression to parse.\n+     *\n+     * @param expression Expression to parser.\n+     */\n+    public SimpleParser(String expression) {\n+        this(expression, 0);\n+    }\n+\n+    /**\n+     * Creates a new SimpleParser and sets the expression to parse.\n+     *\n+     * <p>By default, no maximum parsing level is enforced. Setting the\n+     * {@code maxParsingLevel} to 0 disables the enforcement of a\n+     * maximum parsing level.\n+     *\n+     * @param expression Expression to parse that must not be null.\n+     * @param maxNestingLevel The maximum allowed nesting level of the parser.\n+     */\n+    public SimpleParser(String expression, int maxNestingLevel) {\n+        this.expression = Objects.requireNonNull(expression, \"expression must not be null\");\n+        this.length = expression.length();\n+\n+        if (maxNestingLevel < 0) {\n+            throw new IllegalArgumentException(\"maxNestingLevel must be >= 0\");\n+        }\n+\n+        this.maxNestingLevel = maxNestingLevel;\n+    }\n+\n+    /**\n+     * Gets the expression being parsed.\n+     *\n+     * @return Returns the expression being parsed.\n+     */\n+    public final String expression() {\n+        return expression;\n+    }\n+\n+    /**\n+     * Gets the current 0-based position of the parser.\n+     *\n+     * @return Returns the parser character position.\n+     */\n+    public final int position() {\n+        return position;\n+    }\n+\n+    /**\n+     * Gets the current 1-based line number of the parser.\n+     *\n+     * @return Returns the current line number.\n+     */\n+    public final int line() {\n+        return line;\n+    }\n+\n+    /**\n+     * Gets the current 1-based column number of the parser.\n+     *\n+     * @return Returns the current column number.\n+     */\n+    public final int column() {\n+        return column;\n+    }\n+\n+    /**\n+     * Checks if the parser has reached the end of the expression.\n+     *\n+     * @return Returns true if the parser has reached the end.\n+     */\n+    public final boolean eof() {\n+        return position >= length;\n+    }\n+\n+    /**\n+     * Returns the current character of the expression, but does not consume it.\n+     *\n+     * @return Returns the peeked character.\n+     */\n+    public final char peek() {\n+        return peek(0);\n+    }\n+\n+    /**\n+     * Returns the current character of the expression + {@code offset}\n+     * characters, but does not consume it.\n+     *\n+     * <p>If the end of the expression is reached or if the peeked offset is\n+     * calculated to be less than 0, {@link Character#MIN_VALUE} is returned\n+     * (that is, '\\0').\n+     *\n+     * @param offset The number of characters to peek ahead (positive or negative).\n+     * @return Returns the peeked character.\n+     */\n+    public final char peek(int offset) {\n+        int target = position + offset;\n+        if (target >= length || target < 0) {\n+            return Character.MIN_VALUE;\n+        }\n+\n+        return expression.charAt(target);\n+    }\n+\n+    /**\n+     * Expects that the next character is the given character and consumes it.\n+     *\n+     * @param token The character to expect.\n+     * @return Returns the expected character.\n+     */\n+    public final char expect(char token) {\n+        if (peek() == token) {\n+            skip();\n+            return token;\n+        }\n+\n+        throw syntax(String.format(\"Expected: '%s', but found '%s'\", token, peekSingleCharForMessage()));\n+    }\n+\n+    /**\n+     * Peeks the next character and returns [EOF] if the next character is past\n+     * the end of the expression.\n+     *\n+     * @return Returns the peeked next character.\n+     */\n+    public final String peekSingleCharForMessage() {\n+        char peek = peek();\n+        return peek == Character.MIN_VALUE ? \"[EOF]\" : String.valueOf(peek);\n+    }\n+\n+    /**\n+     * Expects that the next character is one of a fixed set of possible characters.\n+     *\n+     * @param tokens Characters to expect.\n+     * @return Returns the consumed character.\n+\n+     */\n+    public final char expect(char... tokens) {\n+        for (char token : tokens) {\n+            if (peek() == token) {\n+                skip();\n+                return token;\n+            }\n+        }\n+\n+        StringBuilder message = new StringBuilder(\"Found '\")\n+                                .append(peekSingleCharForMessage())\n+                                .append(\"', but expected one of the following tokens:\");\n+        for (char c : tokens) {\n+            message.append(' ').append('\\'').append(c).append('\\'');\n+        }\n+\n+        throw syntax(message.toString());\n+    }\n+\n+    /**\n+     * Creates a syntax error that adds some context to the given message.\n+     *\n+     * @param message Message for why the error occurred.\n+     * @return Returns the created syntax error.\n+     */\n+    public RuntimeException syntax(String message) {\n+        return new RuntimeException(\"Syntax error at line \" + line() + \" column \" + column() + \": \" + message);\n+    }\n+\n+    /**\n+     * Skip 0 or more whitespace characters (that is, ' ', '\\t', '\\r', and '\\n').\n+     */\n+    public void ws() {\n+        while (!eof()) {\n+            char c = peek();\n+            if (!(c == ' ' || c == '\\t' || c == '\\r' || c == '\\n')) {\n+                break;\n+            } else {\n+                skip();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Skip 0 or more spaces (that is, ' ' and '\\t').\n+     */\n+    public void sp() {\n+        while (!eof()) {\n+            char c = peek();\n+            if (!(c == ' ' || c == '\\t')) {\n+                break;\n+            }\n+            skip();\n+        }\n+    }\n+\n+    /**\n+     * Skips spaces then expects that the next character is either the end of\n+     * the expression or a line break (\\n, \\r\\n, or \\r).\n+     *\n+     * @throws RuntimeException if the next non-space character is not EOF or a line break.\n+     */\n+    public void br() {\n+        sp();\n+\n+        // EOF can also be considered a line break to end a file.\n+        if (eof()) {\n+            return;\n+        }\n+\n+        char c = peek();\n+        if (c == '\\n' || c == '\\r') {\n+            skip();\n+        } else {\n+            throw syntax(\"Expected a line break, but found '\" + c + \"'\");\n+        }\n+    }\n+\n+    /**\n+     * Skips a single character while tracking lines and columns.\n+     */\n+    public void skip() {\n+        if (eof()) {\n+            return;\n+        }\n+\n+        switch (expression.charAt(position)) {\n+            case '\\r':\n+                if (peek(1) == '\\n') {\n+                    position++;\n+                }\n+                line++;\n+                column = 1;\n+                break;\n+            case '\\n':\n+                line++;\n+                column = 1;\n+                break;\n+            default:\n+                column++;\n+        }\n+\n+        position++;\n+    }\n+\n+    /**\n+     * Skips over the remaining characters on a line but does not consume\n+     * the newline character (\\n or \\r\\n).\n+     *\n+     * <p>This method will also terminate when the end of the expression\n+     * is encountered.\n+     *\n+     * <p>This method is useful, for example, for skipping the text of a\n+     * commented out line in an expression. If the contents of the skipped\n+     * line are required, then store the current position before invoking\n+     * this method using {@link #position()}, then call this method, then get\n+     * the contents of the skipped characters using {@link #sliceFrom(int)}.\n+     */\n+    public void consumeRemainingCharactersOnLine() {\n+        consumeUntilNoLongerMatches(c -> c != '\\n' && c != '\\r');\n+    }\n+\n+    /**\n+     * Gets a slice of the expression starting from the given 0-based\n+     * character position, read all the way through to the current\n+     * position of the parser.\n+     *\n+     * @param start Position to slice from, ending at the current position.\n+     * @return Returns the slice of the expression from {@code start} to {@link #position}.\n+     */\n+    public final String sliceFrom(int start) {\n+        return expression().substring(start, position);\n+    }\n+\n+    /**\n+     * Reads a lexeme from the expression while the given {@code predicate}\n+     * matches each peeked character.\n+     *\n+     * @param predicate Predicate that filters characters.\n+     * @return Returns the consumed lexeme (or an empty string on no matches).\n+     */\n+    public final int consumeUntilNoLongerMatches(Predicate<Character> predicate) {\n+        int startPosition = position;\n+        while (!eof()) {\n+            char peekedChar = peek();\n+            if (!predicate.test(peekedChar)) {\n+                break;\n+            }\n+            skip();\n+        }\n+\n+        return position - startPosition;\n+    }\n+\n+    /**\n+     * Increases the current nesting level of the parser.\n+     *\n+     * <p>This method can be manually invoked when parsing in order to\n+     * prevent parsing too deeply using recursive descent parsers.\n+     *\n+     * @throws RuntimeException if the nesting level is deeper than the max allowed nesting.\n+     */\n+    public final void increaseNestingLevel() {\n+        nestingLevel++;\n+\n+        if (maxNestingLevel > 0 && nestingLevel > maxNestingLevel) {\n+            throw syntax(\"Parser nesting level too deep\");", "originalCommit": "09822e827771087396b2c5c8f0f28e63385b540b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d5b2f6484e536f88a0f189cd5f43a7b46bde7250", "url": "https://github.com/awslabs/smithy/commit/d5b2f6484e536f88a0f189cd5f43a7b46bde7250", "message": "Add support message templates in EmitEachSelector\n\nThis commit adds support for templated messages in the EmitEachSelector\nthat are able to reference variables captured while shapes are matched.\nThis allows for very rich and descriptive error messages that generally\nare as good as error messages in code-driven Smithy validators.\n\nIn order to pull this, it required that attribute value selector context\nvalues could be parsed from a message template. Since context values are\nalready parsed as part of parsing selectors, this motivated me to reuse\nthe existing selector's parsing functionality. To do this, I created a\nSimpleParser abstraction that extracts out lots of the duplicate parsing\ncode in Smithy into a single class. This allowed parsing of attributes\nto be shared, but it was also an opportunity to trim down duplicate code\nand reuse parsing logic across the IDL and selectors.", "committedDate": "2020-06-17T02:24:43Z", "type": "commit"}, {"oid": "d5b2f6484e536f88a0f189cd5f43a7b46bde7250", "url": "https://github.com/awslabs/smithy/commit/d5b2f6484e536f88a0f189cd5f43a7b46bde7250", "message": "Add support message templates in EmitEachSelector\n\nThis commit adds support for templated messages in the EmitEachSelector\nthat are able to reference variables captured while shapes are matched.\nThis allows for very rich and descriptive error messages that generally\nare as good as error messages in code-driven Smithy validators.\n\nIn order to pull this, it required that attribute value selector context\nvalues could be parsed from a message template. Since context values are\nalready parsed as part of parsing selectors, this motivated me to reuse\nthe existing selector's parsing functionality. To do this, I created a\nSimpleParser abstraction that extracts out lots of the duplicate parsing\ncode in Smithy into a single class. This allowed parsing of attributes\nto be shared, but it was also an opportunity to trim down duplicate code\nand reuse parsing logic across the IDL and selectors.", "committedDate": "2020-06-17T02:24:43Z", "type": "forcePushed"}]}