{"pr_number": 284, "pr_title": "[0.10] Support Smithy IDL Serialization", "pr_createdAt": "2020-02-21T21:32:53Z", "pr_url": "https://github.com/awslabs/smithy/pull/284", "timeline": [{"oid": "543857c269ee78779635a2eec7e414d2de694cdb", "url": "https://github.com/awslabs/smithy/commit/543857c269ee78779635a2eec7e414d2de694cdb", "message": "Add writeInline method to CodeWriter\n\nThis adds a method to CodeWriter which allow for writing without\nhaving a trailing newline or leading indentation inserted. This can\nbe very useful when you want to write part of a line without knowing\nwhat the whole line will contain.\n\nThis does preserve some safety in that it will intercept newlines to\ntreat them as normal, but it is still potentially dangerous if not\nused carefully.", "committedDate": "2020-02-21T21:26:22Z", "type": "commit"}, {"oid": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "url": "https://github.com/awslabs/smithy/commit/c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "message": "Support Smithy IDL serialization\n\nThis adds support for serializing a Smithy model into the IDL format.", "committedDate": "2020-02-21T21:26:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0Mjc2Mg==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382942762", "bodyText": "Can you add some predicates to this, similar to the SmithyModelSerializer?\nThese kinds of predicates are different than model transformations because they are only controlling what gets serialized and not removing shapes from the model. This is important because when the transformer removes shapes, it actually ensures that any references to the shape are automatically removed. This is super important because if a shape that defines a trait is removed, all instances of that trait being applied to other shapes is also removed. There are use cases where we might want to serialize all trait applications but not trait definitions (like maybe you're pulling the traits in as a dependency, but still using the traits).", "author": "mtdowling", "createdAt": "2020-02-22T21:27:06Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MjgzMw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382942833", "bodyText": "This seems like it could use some more description -- what's in the map? Are the paths relative?", "author": "mtdowling", "createdAt": "2020-02-22T21:28:33Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0Mjk1Ng==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382942956", "bodyText": "What happens if a model only contains metadata? Seems like it would do nothing.", "author": "mtdowling", "createdAt": "2020-02-22T21:31:02Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MzAxMA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382943010", "bodyText": "Note that a model might contain only metadata, and metadata occurs before a namespace is declared.", "author": "mtdowling", "createdAt": "2020-02-22T21:31:45Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MzE3Nw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382943177", "bodyText": "namespace should either be omitted somehow or just set to null. There's no \"current namespace\" when control statements or metadata statements are being defined. All shape IDs referenced in metadata need to be absolute actually, otherwise they refer to the prelude. With the current setup, I think metadata that contains shape IDs that refer to shapes in the passed in namespace would be converted to relative shape IDs, thus making them invalid.", "author": "mtdowling", "createdAt": "2020-02-22T21:34:49Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MzUxMw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382943513", "bodyText": "Would a case-insensitive order make the result non-deterministic for keys with the same case-insenstive value?", "author": "mtdowling", "createdAt": "2020-02-22T21:40:38Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MzY4NA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382943684", "bodyText": "I thought blank line trimming defaulted to allowing one blank line? Maybe there's a bug in the CodeWriter?", "author": "mtdowling", "createdAt": "2020-02-22T21:43:08Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        codeWriter.write(\"namespace \" + namespace)\n+                .trimBlankLines(-1)", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4MTM0NA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r383481344", "bodyText": "This would be two blank lines effectively, \"\\n\\n\"", "author": "JordonPhillips", "createdAt": "2020-02-24T19:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MzY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MzcwNw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382943707", "bodyText": "This probably needs docs to describe how it works.\nAlso, should we use nested directories, or just flat files like what you have here?", "author": "mtdowling", "createdAt": "2020-02-22T21:43:26Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        codeWriter.write(\"namespace \" + namespace)\n+                .trimBlankLines(-1)\n+                .write(\"\");\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Path placeShapesByNamespace(Shape shape) {", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4ODM3OA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r383488378", "bodyText": "I'm 0 either way. A flat directory is nicer when you don't have a lot of namespaces. We could include a hierarchical version but not use it by default.", "author": "JordonPhillips", "createdAt": "2020-02-24T20:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MzcwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUzODczNg==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r383538736", "bodyText": "We talked about this offline. We'll keep this strategy for now, and we can introduce others later on.", "author": "JordonPhillips", "createdAt": "2020-02-24T21:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MzcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0Mzc1NA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382943754", "bodyText": "Does this need to be public?", "author": "mtdowling", "createdAt": "2020-02-22T21:44:28Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        codeWriter.write(\"namespace \" + namespace)\n+                .trimBlankLines(-1)\n+                .write(\"\");\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    public static final class ShapeComparator implements Comparator<Shape>, Serializable {", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MzgxNA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382943814", "bodyText": "I think structures should come before unions... Ideally, input and output structures, followed by errors, followed by other structures? I dunno... maybe there's a nice way to implement a kind of newspaper sorting where there first time a shape is referred to be an aggregate shape it's the next shape written?", "author": "mtdowling", "createdAt": "2020-02-22T21:45:41Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        codeWriter.write(\"namespace \" + namespace)\n+                .trimBlankLines(-1)\n+                .write(\"\");\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    public static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.UNION,\n+                ShapeType.STRUCTURE,", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MjU4Ng==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r383492586", "bodyText": "Unfortunately the comparator interface doesn't really support that level of granularity. We'd have to implement something on top. If you think I should go for it I can.", "author": "JordonPhillips", "createdAt": "2020-02-24T20:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MzgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUzODk4NQ==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r383538985", "bodyText": "We talked about this offline. This can be done as a follow-up.", "author": "JordonPhillips", "createdAt": "2020-02-24T21:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0MzgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0Mzg1Mw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382943853", "bodyText": "Nit: there's usually a space between description and params/return value.", "author": "mtdowling", "createdAt": "2020-02-22T21:46:22Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        codeWriter.write(\"namespace \" + namespace)\n+                .trimBlankLines(-1)\n+                .write(\"\");\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    public static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.UNION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0Mzg4MA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382943880", "bodyText": "Why not public?", "author": "mtdowling", "createdAt": "2020-02-22T21:46:37Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        codeWriter.write(\"namespace \" + namespace)\n+                .trimBlankLines(-1)\n+                .write(\"\");\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    public static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.UNION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.\n+         * @param shapePlacer Function that accepts a shape and returns file path.\n+         * @return Returns the builder.\n+         */\n+        Builder shapePlacer(Function<Shape, Path> shapePlacer) {", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5Mzk2NA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r383493964", "bodyText": "Ah I think this was a result of a mis-interpretation of some linter message that I forgot to undo.", "author": "JordonPhillips", "createdAt": "2020-02-24T20:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0Mzg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0Mzk1OQ==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382943959", "bodyText": "Nice! I didn't know this existed", "author": "mtdowling", "createdAt": "2020-02-22T21:48:01Z", "path": "smithy-model/src/test/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializerTest.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package software.amazon.smithy.model.shapes;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.DynamicTest;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestFactory;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.utils.IoUtils;\n+\n+public class SmithyIdlModelSerializerTest {\n+    @TestFactory", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NDIxNw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382944217", "bodyText": "Do you need to escape \"///\" when writing these too? Probably rare, but could potentially occur.", "author": "mtdowling", "createdAt": "2020-02-22T21:52:14Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        codeWriter.write(\"namespace \" + namespace)\n+                .trimBlankLines(-1)\n+                .write(\"\");\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    public static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.UNION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.\n+         * @param shapePlacer Function that accepts a shape and returns file path.\n+         * @return Returns the builder.\n+         */\n+        Builder shapePlacer(Function<Shape, Path> shapePlacer) {\n+            this.shapePlacer = Objects.requireNonNull(shapePlacer);\n+            return this;\n+        }\n+\n+        @Override\n+        public SmithyIdlModelSerializer build() {\n+            return new SmithyIdlModelSerializer(this);\n+        }\n+    }\n+\n+    /**\n+     * Serializes shapes in the IDL format.\n+     */\n+    private static final class ShapeSerializer extends ShapeVisitor.Default<Void> {\n+        private final SmithyCodeWriter codeWriter;\n+        private final NodeSerializer nodeSerializer;\n+        private final Model model;\n+\n+        ShapeSerializer(SmithyCodeWriter codeWriter, NodeSerializer nodeSerializer, Model model) {\n+            this.codeWriter = codeWriter;\n+            this.nodeSerializer = nodeSerializer;\n+            this.model = model;\n+        }\n+\n+        @Override\n+        protected Void getDefault(Shape shape) {\n+            serializeTraits(shape);\n+            codeWriter.write(\"$L $L\", shape.getType(), shape.getId().getName()).write(\"\");\n+            return null;\n+        }\n+\n+        private void shapeWithMembers(Shape shape, List<MemberShape> members) {\n+            serializeTraits(shape);\n+            if (members.isEmpty()) {\n+                // If there are no members then we don't want to introduce an unnecessary newline by opening a block.\n+                codeWriter.write(\"$L $L {}\", shape.getType(), shape.getId().getName()).write(\"\");\n+                return;\n+            }\n+\n+            codeWriter.openBlock(\"$L $L {\", shape.getType(), shape.getId().getName());\n+            for (MemberShape member : members) {\n+                serializeTraits(member);\n+                codeWriter.write(\"$L: $I,\", member.getMemberName(), member.getTarget());\n+            }\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+        }\n+\n+        private void serializeTraits(Shape shape) {\n+            // The documentation trait always needs to be serialized first since it uses special syntax.\n+            shape.getTrait(DocumentationTrait.class).ifPresent(this::serializeDocumentationTrait);\n+            shape.getAllTraits().values().stream()\n+                    .filter(trait -> !(trait instanceof DocumentationTrait))\n+                    .sorted(Comparator.comparing(trait -> trait.toShapeId().toString(), String.CASE_INSENSITIVE_ORDER))\n+                    .forEach(this::serializeTrait);\n+        }\n+\n+        private void serializeDocumentationTrait(DocumentationTrait trait) {\n+            // The documentation trait has a special syntax, which we always want to use.\n+            codeWriter.setNewlinePrefix(\"/// \")\n+                    .write(trait.getValue().replace(\"$\", \"$$\"))", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMTYzMw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r383501633", "bodyText": "Do I? That doesn't end the doc comment, does it?", "author": "JordonPhillips", "createdAt": "2020-02-24T20:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NDIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0MDEzOA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r383540138", "bodyText": "Double checked, and yeah you don't need to escape it.", "author": "JordonPhillips", "createdAt": "2020-02-24T21:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NDIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NDUyMg==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382944522", "bodyText": "Since the class is private, these don't need to be public, right?", "author": "mtdowling", "createdAt": "2020-02-22T21:57:05Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        codeWriter.write(\"namespace \" + namespace)\n+                .trimBlankLines(-1)\n+                .write(\"\");\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    public static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.UNION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.\n+         * @param shapePlacer Function that accepts a shape and returns file path.\n+         * @return Returns the builder.\n+         */\n+        Builder shapePlacer(Function<Shape, Path> shapePlacer) {\n+            this.shapePlacer = Objects.requireNonNull(shapePlacer);\n+            return this;\n+        }\n+\n+        @Override\n+        public SmithyIdlModelSerializer build() {\n+            return new SmithyIdlModelSerializer(this);\n+        }\n+    }\n+\n+    /**\n+     * Serializes shapes in the IDL format.\n+     */\n+    private static final class ShapeSerializer extends ShapeVisitor.Default<Void> {\n+        private final SmithyCodeWriter codeWriter;\n+        private final NodeSerializer nodeSerializer;\n+        private final Model model;\n+\n+        ShapeSerializer(SmithyCodeWriter codeWriter, NodeSerializer nodeSerializer, Model model) {\n+            this.codeWriter = codeWriter;\n+            this.nodeSerializer = nodeSerializer;\n+            this.model = model;\n+        }\n+\n+        @Override\n+        protected Void getDefault(Shape shape) {\n+            serializeTraits(shape);\n+            codeWriter.write(\"$L $L\", shape.getType(), shape.getId().getName()).write(\"\");\n+            return null;\n+        }\n+\n+        private void shapeWithMembers(Shape shape, List<MemberShape> members) {\n+            serializeTraits(shape);\n+            if (members.isEmpty()) {\n+                // If there are no members then we don't want to introduce an unnecessary newline by opening a block.\n+                codeWriter.write(\"$L $L {}\", shape.getType(), shape.getId().getName()).write(\"\");\n+                return;\n+            }\n+\n+            codeWriter.openBlock(\"$L $L {\", shape.getType(), shape.getId().getName());\n+            for (MemberShape member : members) {\n+                serializeTraits(member);\n+                codeWriter.write(\"$L: $I,\", member.getMemberName(), member.getTarget());\n+            }\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+        }\n+\n+        private void serializeTraits(Shape shape) {\n+            // The documentation trait always needs to be serialized first since it uses special syntax.\n+            shape.getTrait(DocumentationTrait.class).ifPresent(this::serializeDocumentationTrait);\n+            shape.getAllTraits().values().stream()\n+                    .filter(trait -> !(trait instanceof DocumentationTrait))\n+                    .sorted(Comparator.comparing(trait -> trait.toShapeId().toString(), String.CASE_INSENSITIVE_ORDER))\n+                    .forEach(this::serializeTrait);\n+        }\n+\n+        private void serializeDocumentationTrait(DocumentationTrait trait) {\n+            // The documentation trait has a special syntax, which we always want to use.\n+            codeWriter.setNewlinePrefix(\"/// \")\n+                    .write(trait.getValue().replace(\"$\", \"$$\"))\n+                    .setNewlinePrefix(\"\");\n+        }\n+\n+        private void serializeTrait(Trait trait) {\n+            Node node = trait.toNode();\n+            Shape shape = model.expectShape(trait.toShapeId());\n+\n+            if (trait instanceof BooleanTrait || isEmptyStructure(node, shape)) {\n+                // Traits that inherit from BooleanTrait specifically can omit a value.\n+                // Traits that are simply boolean shapes which don't implement BooleanTrait cannot.\n+                // Additionally, empty structure traits can omit a value.\n+                codeWriter.write(\"@$I\", trait.toShapeId());\n+            } else if (node.isObjectNode()) {\n+                codeWriter.writeIndent().openBlockInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serializeKeyValuePairs(node.expectObjectNode(), shape);\n+                codeWriter.closeBlock(\")\");\n+            } else {\n+                codeWriter.writeIndent().writeInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serialize(node, shape);\n+                codeWriter.write(\")\");\n+            }\n+        }\n+\n+        private boolean isEmptyStructure(Node node, Shape shape) {\n+            return !shape.isDocumentShape() && node.asObjectNode().map(ObjectNode::isEmpty).orElse(false);\n+        }\n+\n+        @Override\n+        public Void listShape(ListShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void setShape(SetShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void mapShape(MapShape shape) {\n+            shapeWithMembers(shape, ListUtils.of(shape.getKey(), shape.getValue()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void structureShape(StructureShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void unionShape(UnionShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        private List<MemberShape> sortMembers(Collection<MemberShape> members) {\n+            return members.stream()\n+                    .sorted(Comparator.comparing(MemberShape::getMemberName, String.CASE_INSENSITIVE_ORDER))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public Void serviceShape(ServiceShape shape) {\n+            serializeTraits(shape);\n+            codeWriter.openBlock(\"service $L {\", shape.getId().getName())\n+                    .write(\"version: $S,\", shape.getVersion());\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+            return null;\n+        }\n+\n+        @Override\n+        public Void resourceShape(ResourceShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyResource(shape)) {\n+                codeWriter.write(\"resource $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"resource $L {\", shape.getId().getName());\n+            if (!shape.getIdentifiers().isEmpty()) {\n+                codeWriter.openBlock(\"identifiers: {\");\n+                shape.getIdentifiers().entrySet().stream()\n+                        .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                        .forEach(entry -> codeWriter.write(\n+                                \"$L: $I,\", entry.getKey(), entry.getValue()));\n+                codeWriter.closeBlock(\"},\");\n+            }\n+\n+            shape.getPut().ifPresent(shapeId -> codeWriter.write(\"put: $I,\", shapeId));\n+            shape.getCreate().ifPresent(shapeId -> codeWriter.write(\"create: $I,\", shapeId));\n+            shape.getRead().ifPresent(shapeId -> codeWriter.write(\"read: $I,\", shapeId));\n+            shape.getUpdate().ifPresent(shapeId -> codeWriter.write(\"update: $I,\", shapeId));\n+            shape.getDelete().ifPresent(shapeId -> codeWriter.write(\"delete: $I,\", shapeId));\n+            shape.getList().ifPresent(shapeId -> codeWriter.write(\"list: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"collectionOperations\", shape.getCollectionOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyResource(ResourceShape shape) {\n+            return !(!shape.getIdentifiers().isEmpty()\n+                    || !shape.getOperations().isEmpty()\n+                    || !shape.getCollectionOperations().isEmpty()\n+                    || !shape.getResources().isEmpty()\n+                    || shape.getPut().isPresent()\n+                    || shape.getCreate().isPresent()\n+                    || shape.getRead().isPresent()\n+                    || shape.getUpdate().isPresent()\n+                    || shape.getDelete().isPresent()\n+                    || shape.getList().isPresent());\n+        }\n+\n+        @Override\n+        public Void operationShape(OperationShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyOperation(shape)) {\n+                codeWriter.write(\"operation $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"operation $L {\", shape.getId().getName());\n+            shape.getInput().ifPresent(shapeId -> codeWriter.write(\"input: $I,\", shapeId));\n+            shape.getOutput().ifPresent(shapeId -> codeWriter.write(\"output: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"errors\", shape.getErrors());\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyOperation(OperationShape shape) {\n+            return !(shape.getInput().isPresent() || shape.getOutput().isPresent() || !shape.getErrors().isEmpty());\n+        }\n+    }\n+\n+    /**\n+     * Serializes nodes into the Smithy IDL format.\n+     */\n+    private static final class NodeSerializer {\n+        private final SmithyCodeWriter codeWriter;\n+        private final Model model;\n+\n+        NodeSerializer(SmithyCodeWriter codeWriter, Model model) {\n+            this.codeWriter = codeWriter;\n+            this.model = model;\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * @param node The node to serialize.\n+         */\n+        public void serialize(Node node) {\n+            serialize(node, null);\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * <p>This uses the given shape to influence serialization. For example, a string shape marked with the idRef\n+         * trait will be serialized as a shape id rather than a string.\n+         *\n+         * @param node The node to serialize.\n+         * @param shape The shape of the node.\n+         */\n+        public void serialize(Node node, Shape shape) {\n+            // ShapeIds are represented differently than strings, so if a shape looks like it's\n+            // representing a shapeId we need to serialize it without quotes.\n+            if (isShapeId(shape)) {\n+                serializeShapeId(node.expectStringNode());\n+                return;\n+            }\n+\n+            if (shape != null && shape.isMemberShape()) {\n+                shape = model.expectShape(shape.asMemberShape().get().getTarget());\n+            }\n+\n+            if (node.isStringNode()) {\n+                serializeString(node.expectStringNode());\n+            } else if (node.isNumberNode()) {\n+                serializeNumber(node.expectNumberNode());\n+            } else if (node.isBooleanNode()) {\n+                serializeBoolean(node.expectBooleanNode());\n+            } else if (node.isNullNode()) {\n+                serializeNull();\n+            } else if (node.isArrayNode()) {\n+                serializeArray(node.expectArrayNode(), shape);\n+            } else if (node.isObjectNode()) {\n+                serializeObject(node.expectObjectNode(), shape);\n+            }\n+        }\n+\n+        private boolean isShapeId(Shape shape) {\n+            if (shape == null) {\n+                return false;\n+            }\n+            if (shape.isMemberShape()) {\n+                return shape.asMemberShape()\n+                        .flatMap(member -> member.getMemberTrait(model, IdRefTrait.class)).isPresent();\n+            }\n+            return shape.hasTrait(IdRefTrait.class);\n+        }\n+\n+        private void serializeString(StringNode node) {\n+            codeWriter.writeInline(\"$S\", node.getValue());\n+        }\n+\n+        private void serializeShapeId(StringNode node) {\n+            codeWriter.writeInline(\"$I\", node.getValue());\n+        }\n+\n+        private void serializeNumber(NumberNode node) {\n+            codeWriter.writeInline(\"$L\", node.getValue());\n+        }\n+\n+        private void serializeBoolean(BooleanNode node) {\n+            codeWriter.writeInline(String.valueOf(node.getValue()));\n+        }\n+\n+        private void serializeNull() {\n+            codeWriter.writeInline(\"null\");\n+        }\n+\n+        private void serializeArray(ArrayNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                codeWriter.writeInline(\"[]\");\n+                return;\n+            }\n+\n+            codeWriter.openBlockInline(\"[\");\n+\n+            // If it's not a collection shape, it'll be a document shape or null\n+            Shape member = shape;\n+            if (shape instanceof CollectionShape) {\n+                member = ((CollectionShape) shape).getMember();\n+            }\n+\n+            for (Node element : node.getElements()) {\n+                // Elements will be written inline to enable them being written as values.\n+                // So here we need to ensure that they're written on a new line that's properly indented.\n+                codeWriter.write(\"\");\n+                codeWriter.writeIndent();\n+                serialize(element, member);\n+                codeWriter.writeInline(\",\");\n+            }\n+            codeWriter.write(\"\");\n+\n+            // We want to make sure to close without inserting a newline, as this could itself be a list element\n+            //or an object value.\n+            codeWriter.closeBlockWithoutNewline(\"]\");\n+        }\n+\n+        private void serializeObject(ObjectNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                codeWriter.writeInline(\"{}\");\n+                return;\n+            }\n+\n+            codeWriter.openBlockInline(\"{\");\n+            serializeKeyValuePairs(node, shape);\n+            codeWriter.closeBlockWithoutNewline(\"}\");\n+        }\n+\n+        /**\n+         * Serialize an object node without the surrounding brackets.\n+         *\n+         * <p>This is mainly useful for serializing trait value nodes.\n+         *\n+         * @param node The node to serialize.\n+         * @param shape The shape of the node.\n+         */\n+        public void serializeKeyValuePairs(ObjectNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                return;\n+            }\n+\n+            // If we're looking at a structure or union shape, we'll need to get the member shape based on the\n+            // node key. Here we pre-compute a mapping so we don't have to traverse the member list every time.\n+            Map<String, MemberShape> members;\n+            if (shape == null) {\n+                members = Collections.emptyMap();\n+            } else {\n+                members = shape.members().stream().distinct()\n+                        .collect(Collectors.toMap(MemberShape::getMemberName, Function.identity()));\n+            }\n+\n+            node.getMembers().forEach((name, value) -> {\n+                // Try to find the member shape.\n+                Shape member;\n+                if (shape != null && shape.isMapShape()) {\n+                    // For maps the value member will always be the same.\n+                    member = shape.asMapShape().get().getValue();\n+                } else if (shape instanceof NamedMembersShape) {\n+                    member = members.get(name.getValue());\n+                } else {\n+                    // At this point the shape is either null or a document shape.\n+                    member = shape;\n+                }\n+\n+                codeWriter.writeInline(\"\\n$M: \", name.getValue());\n+                serialize(value, member);\n+                codeWriter.writeInline(\",\");\n+            });\n+            codeWriter.write(\"\");\n+        }\n+    }\n+\n+    /**\n+     * Extension of {@link CodeWriter} that provides additional convenience methods.\n+     *\n+     * <p>Provides a built in $I formatter that formats shape ids, automatically trimming namespace where possible.\n+     */\n+    private static final class SmithyCodeWriter extends CodeWriter {\n+        private static final Pattern UNQUOTED_STRING = Pattern.compile(\"[a-zA-Z_][\\\\w$.#]*\");\n+        private final String namespace;\n+        private final Model model;\n+        private final Set<ShapeId> imports;\n+\n+        SmithyCodeWriter(String namespace, Model model) {\n+            super();\n+            this.namespace = namespace;\n+            this.model = model;\n+            this.imports = new HashSet<>();\n+            trimTrailingSpaces();\n+            trimBlankLines();\n+            putFormatter('I', (s, i) -> formatShapeId(s));\n+            putFormatter('M', this::optionallyQuoteString);\n+        }\n+\n+        /**\n+         * Opens a block without writing indentation whitespace or inserting a newline.\n+         */\n+        public SmithyCodeWriter openBlockInline(String content, Object... args) {", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NDU3Mg==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382944572", "bodyText": "You could potentially use the push and pop features of the codewriter", "author": "mtdowling", "createdAt": "2020-02-22T21:58:05Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        codeWriter.write(\"namespace \" + namespace)\n+                .trimBlankLines(-1)\n+                .write(\"\");\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    public static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.UNION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.\n+         * @param shapePlacer Function that accepts a shape and returns file path.\n+         * @return Returns the builder.\n+         */\n+        Builder shapePlacer(Function<Shape, Path> shapePlacer) {\n+            this.shapePlacer = Objects.requireNonNull(shapePlacer);\n+            return this;\n+        }\n+\n+        @Override\n+        public SmithyIdlModelSerializer build() {\n+            return new SmithyIdlModelSerializer(this);\n+        }\n+    }\n+\n+    /**\n+     * Serializes shapes in the IDL format.\n+     */\n+    private static final class ShapeSerializer extends ShapeVisitor.Default<Void> {\n+        private final SmithyCodeWriter codeWriter;\n+        private final NodeSerializer nodeSerializer;\n+        private final Model model;\n+\n+        ShapeSerializer(SmithyCodeWriter codeWriter, NodeSerializer nodeSerializer, Model model) {\n+            this.codeWriter = codeWriter;\n+            this.nodeSerializer = nodeSerializer;\n+            this.model = model;\n+        }\n+\n+        @Override\n+        protected Void getDefault(Shape shape) {\n+            serializeTraits(shape);\n+            codeWriter.write(\"$L $L\", shape.getType(), shape.getId().getName()).write(\"\");\n+            return null;\n+        }\n+\n+        private void shapeWithMembers(Shape shape, List<MemberShape> members) {\n+            serializeTraits(shape);\n+            if (members.isEmpty()) {\n+                // If there are no members then we don't want to introduce an unnecessary newline by opening a block.\n+                codeWriter.write(\"$L $L {}\", shape.getType(), shape.getId().getName()).write(\"\");\n+                return;\n+            }\n+\n+            codeWriter.openBlock(\"$L $L {\", shape.getType(), shape.getId().getName());\n+            for (MemberShape member : members) {\n+                serializeTraits(member);\n+                codeWriter.write(\"$L: $I,\", member.getMemberName(), member.getTarget());\n+            }\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+        }\n+\n+        private void serializeTraits(Shape shape) {\n+            // The documentation trait always needs to be serialized first since it uses special syntax.\n+            shape.getTrait(DocumentationTrait.class).ifPresent(this::serializeDocumentationTrait);\n+            shape.getAllTraits().values().stream()\n+                    .filter(trait -> !(trait instanceof DocumentationTrait))\n+                    .sorted(Comparator.comparing(trait -> trait.toShapeId().toString(), String.CASE_INSENSITIVE_ORDER))\n+                    .forEach(this::serializeTrait);\n+        }\n+\n+        private void serializeDocumentationTrait(DocumentationTrait trait) {\n+            // The documentation trait has a special syntax, which we always want to use.\n+            codeWriter.setNewlinePrefix(\"/// \")\n+                    .write(trait.getValue().replace(\"$\", \"$$\"))\n+                    .setNewlinePrefix(\"\");\n+        }\n+\n+        private void serializeTrait(Trait trait) {\n+            Node node = trait.toNode();\n+            Shape shape = model.expectShape(trait.toShapeId());\n+\n+            if (trait instanceof BooleanTrait || isEmptyStructure(node, shape)) {\n+                // Traits that inherit from BooleanTrait specifically can omit a value.\n+                // Traits that are simply boolean shapes which don't implement BooleanTrait cannot.\n+                // Additionally, empty structure traits can omit a value.\n+                codeWriter.write(\"@$I\", trait.toShapeId());\n+            } else if (node.isObjectNode()) {\n+                codeWriter.writeIndent().openBlockInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serializeKeyValuePairs(node.expectObjectNode(), shape);\n+                codeWriter.closeBlock(\")\");\n+            } else {\n+                codeWriter.writeIndent().writeInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serialize(node, shape);\n+                codeWriter.write(\")\");\n+            }\n+        }\n+\n+        private boolean isEmptyStructure(Node node, Shape shape) {\n+            return !shape.isDocumentShape() && node.asObjectNode().map(ObjectNode::isEmpty).orElse(false);\n+        }\n+\n+        @Override\n+        public Void listShape(ListShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void setShape(SetShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void mapShape(MapShape shape) {\n+            shapeWithMembers(shape, ListUtils.of(shape.getKey(), shape.getValue()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void structureShape(StructureShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void unionShape(UnionShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        private List<MemberShape> sortMembers(Collection<MemberShape> members) {\n+            return members.stream()\n+                    .sorted(Comparator.comparing(MemberShape::getMemberName, String.CASE_INSENSITIVE_ORDER))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public Void serviceShape(ServiceShape shape) {\n+            serializeTraits(shape);\n+            codeWriter.openBlock(\"service $L {\", shape.getId().getName())\n+                    .write(\"version: $S,\", shape.getVersion());\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+            return null;\n+        }\n+\n+        @Override\n+        public Void resourceShape(ResourceShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyResource(shape)) {\n+                codeWriter.write(\"resource $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"resource $L {\", shape.getId().getName());\n+            if (!shape.getIdentifiers().isEmpty()) {\n+                codeWriter.openBlock(\"identifiers: {\");\n+                shape.getIdentifiers().entrySet().stream()\n+                        .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                        .forEach(entry -> codeWriter.write(\n+                                \"$L: $I,\", entry.getKey(), entry.getValue()));\n+                codeWriter.closeBlock(\"},\");\n+            }\n+\n+            shape.getPut().ifPresent(shapeId -> codeWriter.write(\"put: $I,\", shapeId));\n+            shape.getCreate().ifPresent(shapeId -> codeWriter.write(\"create: $I,\", shapeId));\n+            shape.getRead().ifPresent(shapeId -> codeWriter.write(\"read: $I,\", shapeId));\n+            shape.getUpdate().ifPresent(shapeId -> codeWriter.write(\"update: $I,\", shapeId));\n+            shape.getDelete().ifPresent(shapeId -> codeWriter.write(\"delete: $I,\", shapeId));\n+            shape.getList().ifPresent(shapeId -> codeWriter.write(\"list: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"collectionOperations\", shape.getCollectionOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyResource(ResourceShape shape) {\n+            return !(!shape.getIdentifiers().isEmpty()\n+                    || !shape.getOperations().isEmpty()\n+                    || !shape.getCollectionOperations().isEmpty()\n+                    || !shape.getResources().isEmpty()\n+                    || shape.getPut().isPresent()\n+                    || shape.getCreate().isPresent()\n+                    || shape.getRead().isPresent()\n+                    || shape.getUpdate().isPresent()\n+                    || shape.getDelete().isPresent()\n+                    || shape.getList().isPresent());\n+        }\n+\n+        @Override\n+        public Void operationShape(OperationShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyOperation(shape)) {\n+                codeWriter.write(\"operation $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"operation $L {\", shape.getId().getName());\n+            shape.getInput().ifPresent(shapeId -> codeWriter.write(\"input: $I,\", shapeId));\n+            shape.getOutput().ifPresent(shapeId -> codeWriter.write(\"output: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"errors\", shape.getErrors());\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyOperation(OperationShape shape) {\n+            return !(shape.getInput().isPresent() || shape.getOutput().isPresent() || !shape.getErrors().isEmpty());\n+        }\n+    }\n+\n+    /**\n+     * Serializes nodes into the Smithy IDL format.\n+     */\n+    private static final class NodeSerializer {\n+        private final SmithyCodeWriter codeWriter;\n+        private final Model model;\n+\n+        NodeSerializer(SmithyCodeWriter codeWriter, Model model) {\n+            this.codeWriter = codeWriter;\n+            this.model = model;\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * @param node The node to serialize.\n+         */\n+        public void serialize(Node node) {\n+            serialize(node, null);\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * <p>This uses the given shape to influence serialization. For example, a string shape marked with the idRef\n+         * trait will be serialized as a shape id rather than a string.\n+         *\n+         * @param node The node to serialize.\n+         * @param shape The shape of the node.\n+         */\n+        public void serialize(Node node, Shape shape) {\n+            // ShapeIds are represented differently than strings, so if a shape looks like it's\n+            // representing a shapeId we need to serialize it without quotes.\n+            if (isShapeId(shape)) {\n+                serializeShapeId(node.expectStringNode());\n+                return;\n+            }\n+\n+            if (shape != null && shape.isMemberShape()) {\n+                shape = model.expectShape(shape.asMemberShape().get().getTarget());\n+            }\n+\n+            if (node.isStringNode()) {\n+                serializeString(node.expectStringNode());\n+            } else if (node.isNumberNode()) {\n+                serializeNumber(node.expectNumberNode());\n+            } else if (node.isBooleanNode()) {\n+                serializeBoolean(node.expectBooleanNode());\n+            } else if (node.isNullNode()) {\n+                serializeNull();\n+            } else if (node.isArrayNode()) {\n+                serializeArray(node.expectArrayNode(), shape);\n+            } else if (node.isObjectNode()) {\n+                serializeObject(node.expectObjectNode(), shape);\n+            }\n+        }\n+\n+        private boolean isShapeId(Shape shape) {\n+            if (shape == null) {\n+                return false;\n+            }\n+            if (shape.isMemberShape()) {\n+                return shape.asMemberShape()\n+                        .flatMap(member -> member.getMemberTrait(model, IdRefTrait.class)).isPresent();\n+            }\n+            return shape.hasTrait(IdRefTrait.class);\n+        }\n+\n+        private void serializeString(StringNode node) {\n+            codeWriter.writeInline(\"$S\", node.getValue());\n+        }\n+\n+        private void serializeShapeId(StringNode node) {\n+            codeWriter.writeInline(\"$I\", node.getValue());\n+        }\n+\n+        private void serializeNumber(NumberNode node) {\n+            codeWriter.writeInline(\"$L\", node.getValue());\n+        }\n+\n+        private void serializeBoolean(BooleanNode node) {\n+            codeWriter.writeInline(String.valueOf(node.getValue()));\n+        }\n+\n+        private void serializeNull() {\n+            codeWriter.writeInline(\"null\");\n+        }\n+\n+        private void serializeArray(ArrayNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                codeWriter.writeInline(\"[]\");\n+                return;\n+            }\n+\n+            codeWriter.openBlockInline(\"[\");\n+\n+            // If it's not a collection shape, it'll be a document shape or null\n+            Shape member = shape;\n+            if (shape instanceof CollectionShape) {\n+                member = ((CollectionShape) shape).getMember();\n+            }\n+\n+            for (Node element : node.getElements()) {\n+                // Elements will be written inline to enable them being written as values.\n+                // So here we need to ensure that they're written on a new line that's properly indented.\n+                codeWriter.write(\"\");\n+                codeWriter.writeIndent();\n+                serialize(element, member);\n+                codeWriter.writeInline(\",\");\n+            }\n+            codeWriter.write(\"\");\n+\n+            // We want to make sure to close without inserting a newline, as this could itself be a list element\n+            //or an object value.\n+            codeWriter.closeBlockWithoutNewline(\"]\");\n+        }\n+\n+        private void serializeObject(ObjectNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                codeWriter.writeInline(\"{}\");\n+                return;\n+            }\n+\n+            codeWriter.openBlockInline(\"{\");\n+            serializeKeyValuePairs(node, shape);\n+            codeWriter.closeBlockWithoutNewline(\"}\");\n+        }\n+\n+        /**\n+         * Serialize an object node without the surrounding brackets.\n+         *\n+         * <p>This is mainly useful for serializing trait value nodes.\n+         *\n+         * @param node The node to serialize.\n+         * @param shape The shape of the node.\n+         */\n+        public void serializeKeyValuePairs(ObjectNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                return;\n+            }\n+\n+            // If we're looking at a structure or union shape, we'll need to get the member shape based on the\n+            // node key. Here we pre-compute a mapping so we don't have to traverse the member list every time.\n+            Map<String, MemberShape> members;\n+            if (shape == null) {\n+                members = Collections.emptyMap();\n+            } else {\n+                members = shape.members().stream().distinct()\n+                        .collect(Collectors.toMap(MemberShape::getMemberName, Function.identity()));\n+            }\n+\n+            node.getMembers().forEach((name, value) -> {\n+                // Try to find the member shape.\n+                Shape member;\n+                if (shape != null && shape.isMapShape()) {\n+                    // For maps the value member will always be the same.\n+                    member = shape.asMapShape().get().getValue();\n+                } else if (shape instanceof NamedMembersShape) {\n+                    member = members.get(name.getValue());\n+                } else {\n+                    // At this point the shape is either null or a document shape.\n+                    member = shape;\n+                }\n+\n+                codeWriter.writeInline(\"\\n$M: \", name.getValue());\n+                serialize(value, member);\n+                codeWriter.writeInline(\",\");\n+            });\n+            codeWriter.write(\"\");\n+        }\n+    }\n+\n+    /**\n+     * Extension of {@link CodeWriter} that provides additional convenience methods.\n+     *\n+     * <p>Provides a built in $I formatter that formats shape ids, automatically trimming namespace where possible.\n+     */\n+    private static final class SmithyCodeWriter extends CodeWriter {\n+        private static final Pattern UNQUOTED_STRING = Pattern.compile(\"[a-zA-Z_][\\\\w$.#]*\");\n+        private final String namespace;\n+        private final Model model;\n+        private final Set<ShapeId> imports;\n+\n+        SmithyCodeWriter(String namespace, Model model) {\n+            super();\n+            this.namespace = namespace;\n+            this.model = model;\n+            this.imports = new HashSet<>();\n+            trimTrailingSpaces();\n+            trimBlankLines();\n+            putFormatter('I', (s, i) -> formatShapeId(s));\n+            putFormatter('M', this::optionallyQuoteString);\n+        }\n+\n+        /**\n+         * Opens a block without writing indentation whitespace or inserting a newline.\n+         */\n+        public SmithyCodeWriter openBlockInline(String content, Object... args) {\n+            writeInline(content, args).indent();\n+            return this;\n+        }\n+\n+        /**\n+         * Closes a block without inserting a newline.\n+         */\n+        public SmithyCodeWriter closeBlockWithoutNewline(String content, Object... args) {\n+            setNewline(\"\");\n+            closeBlock(content, args);\n+            setNewline(\"\\n\");\n+            return this;\n+        }\n+\n+        /**\n+         * Writes an empty line that contains only indentation appropriate to the current indentation level.\n+         *\n+         * <p> This does not insert a trailing newline.\n+         */\n+        public SmithyCodeWriter writeIndent() {\n+            setNewline(\"\");", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4NzU1NQ==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r383587555", "bodyText": "Unfortunately that only stores one piece of state I'm modifying here, so it wouldn't really save me much.", "author": "JordonPhillips", "createdAt": "2020-02-25T00:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NDU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NDYxNA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382944614", "bodyText": "Smart", "author": "mtdowling", "createdAt": "2020-02-22T21:58:33Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>This does not write the models to disk.\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        return model.shapes()\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(namespace, fullModel) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(String namespace, Model fullModel) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        codeWriter.write(\"namespace \" + namespace)\n+                .trimBlankLines(-1)\n+                .write(\"\");\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    public static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.UNION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.\n+         * @param shapePlacer Function that accepts a shape and returns file path.\n+         * @return Returns the builder.\n+         */\n+        Builder shapePlacer(Function<Shape, Path> shapePlacer) {\n+            this.shapePlacer = Objects.requireNonNull(shapePlacer);\n+            return this;\n+        }\n+\n+        @Override\n+        public SmithyIdlModelSerializer build() {\n+            return new SmithyIdlModelSerializer(this);\n+        }\n+    }\n+\n+    /**\n+     * Serializes shapes in the IDL format.\n+     */\n+    private static final class ShapeSerializer extends ShapeVisitor.Default<Void> {\n+        private final SmithyCodeWriter codeWriter;\n+        private final NodeSerializer nodeSerializer;\n+        private final Model model;\n+\n+        ShapeSerializer(SmithyCodeWriter codeWriter, NodeSerializer nodeSerializer, Model model) {\n+            this.codeWriter = codeWriter;\n+            this.nodeSerializer = nodeSerializer;\n+            this.model = model;\n+        }\n+\n+        @Override\n+        protected Void getDefault(Shape shape) {\n+            serializeTraits(shape);\n+            codeWriter.write(\"$L $L\", shape.getType(), shape.getId().getName()).write(\"\");\n+            return null;\n+        }\n+\n+        private void shapeWithMembers(Shape shape, List<MemberShape> members) {\n+            serializeTraits(shape);\n+            if (members.isEmpty()) {\n+                // If there are no members then we don't want to introduce an unnecessary newline by opening a block.\n+                codeWriter.write(\"$L $L {}\", shape.getType(), shape.getId().getName()).write(\"\");\n+                return;\n+            }\n+\n+            codeWriter.openBlock(\"$L $L {\", shape.getType(), shape.getId().getName());\n+            for (MemberShape member : members) {\n+                serializeTraits(member);\n+                codeWriter.write(\"$L: $I,\", member.getMemberName(), member.getTarget());\n+            }\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+        }\n+\n+        private void serializeTraits(Shape shape) {\n+            // The documentation trait always needs to be serialized first since it uses special syntax.\n+            shape.getTrait(DocumentationTrait.class).ifPresent(this::serializeDocumentationTrait);\n+            shape.getAllTraits().values().stream()\n+                    .filter(trait -> !(trait instanceof DocumentationTrait))\n+                    .sorted(Comparator.comparing(trait -> trait.toShapeId().toString(), String.CASE_INSENSITIVE_ORDER))\n+                    .forEach(this::serializeTrait);\n+        }\n+\n+        private void serializeDocumentationTrait(DocumentationTrait trait) {\n+            // The documentation trait has a special syntax, which we always want to use.\n+            codeWriter.setNewlinePrefix(\"/// \")\n+                    .write(trait.getValue().replace(\"$\", \"$$\"))\n+                    .setNewlinePrefix(\"\");\n+        }\n+\n+        private void serializeTrait(Trait trait) {\n+            Node node = trait.toNode();\n+            Shape shape = model.expectShape(trait.toShapeId());\n+\n+            if (trait instanceof BooleanTrait || isEmptyStructure(node, shape)) {\n+                // Traits that inherit from BooleanTrait specifically can omit a value.\n+                // Traits that are simply boolean shapes which don't implement BooleanTrait cannot.\n+                // Additionally, empty structure traits can omit a value.\n+                codeWriter.write(\"@$I\", trait.toShapeId());\n+            } else if (node.isObjectNode()) {\n+                codeWriter.writeIndent().openBlockInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serializeKeyValuePairs(node.expectObjectNode(), shape);\n+                codeWriter.closeBlock(\")\");\n+            } else {\n+                codeWriter.writeIndent().writeInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serialize(node, shape);\n+                codeWriter.write(\")\");\n+            }\n+        }\n+\n+        private boolean isEmptyStructure(Node node, Shape shape) {\n+            return !shape.isDocumentShape() && node.asObjectNode().map(ObjectNode::isEmpty).orElse(false);\n+        }\n+\n+        @Override\n+        public Void listShape(ListShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void setShape(SetShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void mapShape(MapShape shape) {\n+            shapeWithMembers(shape, ListUtils.of(shape.getKey(), shape.getValue()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void structureShape(StructureShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void unionShape(UnionShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        private List<MemberShape> sortMembers(Collection<MemberShape> members) {\n+            return members.stream()\n+                    .sorted(Comparator.comparing(MemberShape::getMemberName, String.CASE_INSENSITIVE_ORDER))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public Void serviceShape(ServiceShape shape) {\n+            serializeTraits(shape);\n+            codeWriter.openBlock(\"service $L {\", shape.getId().getName())\n+                    .write(\"version: $S,\", shape.getVersion());\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+            return null;\n+        }\n+\n+        @Override\n+        public Void resourceShape(ResourceShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyResource(shape)) {\n+                codeWriter.write(\"resource $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"resource $L {\", shape.getId().getName());\n+            if (!shape.getIdentifiers().isEmpty()) {\n+                codeWriter.openBlock(\"identifiers: {\");\n+                shape.getIdentifiers().entrySet().stream()\n+                        .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                        .forEach(entry -> codeWriter.write(\n+                                \"$L: $I,\", entry.getKey(), entry.getValue()));\n+                codeWriter.closeBlock(\"},\");\n+            }\n+\n+            shape.getPut().ifPresent(shapeId -> codeWriter.write(\"put: $I,\", shapeId));\n+            shape.getCreate().ifPresent(shapeId -> codeWriter.write(\"create: $I,\", shapeId));\n+            shape.getRead().ifPresent(shapeId -> codeWriter.write(\"read: $I,\", shapeId));\n+            shape.getUpdate().ifPresent(shapeId -> codeWriter.write(\"update: $I,\", shapeId));\n+            shape.getDelete().ifPresent(shapeId -> codeWriter.write(\"delete: $I,\", shapeId));\n+            shape.getList().ifPresent(shapeId -> codeWriter.write(\"list: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"collectionOperations\", shape.getCollectionOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyResource(ResourceShape shape) {\n+            return !(!shape.getIdentifiers().isEmpty()\n+                    || !shape.getOperations().isEmpty()\n+                    || !shape.getCollectionOperations().isEmpty()\n+                    || !shape.getResources().isEmpty()\n+                    || shape.getPut().isPresent()\n+                    || shape.getCreate().isPresent()\n+                    || shape.getRead().isPresent()\n+                    || shape.getUpdate().isPresent()\n+                    || shape.getDelete().isPresent()\n+                    || shape.getList().isPresent());\n+        }\n+\n+        @Override\n+        public Void operationShape(OperationShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyOperation(shape)) {\n+                codeWriter.write(\"operation $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"operation $L {\", shape.getId().getName());\n+            shape.getInput().ifPresent(shapeId -> codeWriter.write(\"input: $I,\", shapeId));\n+            shape.getOutput().ifPresent(shapeId -> codeWriter.write(\"output: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"errors\", shape.getErrors());\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyOperation(OperationShape shape) {\n+            return !(shape.getInput().isPresent() || shape.getOutput().isPresent() || !shape.getErrors().isEmpty());\n+        }\n+    }\n+\n+    /**\n+     * Serializes nodes into the Smithy IDL format.\n+     */\n+    private static final class NodeSerializer {\n+        private final SmithyCodeWriter codeWriter;\n+        private final Model model;\n+\n+        NodeSerializer(SmithyCodeWriter codeWriter, Model model) {\n+            this.codeWriter = codeWriter;\n+            this.model = model;\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * @param node The node to serialize.\n+         */\n+        public void serialize(Node node) {\n+            serialize(node, null);\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * <p>This uses the given shape to influence serialization. For example, a string shape marked with the idRef\n+         * trait will be serialized as a shape id rather than a string.\n+         *\n+         * @param node The node to serialize.\n+         * @param shape The shape of the node.\n+         */\n+        public void serialize(Node node, Shape shape) {\n+            // ShapeIds are represented differently than strings, so if a shape looks like it's\n+            // representing a shapeId we need to serialize it without quotes.\n+            if (isShapeId(shape)) {\n+                serializeShapeId(node.expectStringNode());\n+                return;\n+            }\n+\n+            if (shape != null && shape.isMemberShape()) {\n+                shape = model.expectShape(shape.asMemberShape().get().getTarget());\n+            }\n+\n+            if (node.isStringNode()) {\n+                serializeString(node.expectStringNode());\n+            } else if (node.isNumberNode()) {\n+                serializeNumber(node.expectNumberNode());\n+            } else if (node.isBooleanNode()) {\n+                serializeBoolean(node.expectBooleanNode());\n+            } else if (node.isNullNode()) {\n+                serializeNull();\n+            } else if (node.isArrayNode()) {\n+                serializeArray(node.expectArrayNode(), shape);\n+            } else if (node.isObjectNode()) {\n+                serializeObject(node.expectObjectNode(), shape);\n+            }\n+        }\n+\n+        private boolean isShapeId(Shape shape) {\n+            if (shape == null) {\n+                return false;\n+            }\n+            if (shape.isMemberShape()) {\n+                return shape.asMemberShape()\n+                        .flatMap(member -> member.getMemberTrait(model, IdRefTrait.class)).isPresent();\n+            }\n+            return shape.hasTrait(IdRefTrait.class);\n+        }\n+\n+        private void serializeString(StringNode node) {\n+            codeWriter.writeInline(\"$S\", node.getValue());\n+        }\n+\n+        private void serializeShapeId(StringNode node) {\n+            codeWriter.writeInline(\"$I\", node.getValue());\n+        }\n+\n+        private void serializeNumber(NumberNode node) {\n+            codeWriter.writeInline(\"$L\", node.getValue());\n+        }\n+\n+        private void serializeBoolean(BooleanNode node) {\n+            codeWriter.writeInline(String.valueOf(node.getValue()));\n+        }\n+\n+        private void serializeNull() {\n+            codeWriter.writeInline(\"null\");\n+        }\n+\n+        private void serializeArray(ArrayNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                codeWriter.writeInline(\"[]\");\n+                return;\n+            }\n+\n+            codeWriter.openBlockInline(\"[\");\n+\n+            // If it's not a collection shape, it'll be a document shape or null\n+            Shape member = shape;\n+            if (shape instanceof CollectionShape) {\n+                member = ((CollectionShape) shape).getMember();\n+            }\n+\n+            for (Node element : node.getElements()) {\n+                // Elements will be written inline to enable them being written as values.\n+                // So here we need to ensure that they're written on a new line that's properly indented.\n+                codeWriter.write(\"\");\n+                codeWriter.writeIndent();\n+                serialize(element, member);\n+                codeWriter.writeInline(\",\");\n+            }\n+            codeWriter.write(\"\");\n+\n+            // We want to make sure to close without inserting a newline, as this could itself be a list element\n+            //or an object value.\n+            codeWriter.closeBlockWithoutNewline(\"]\");\n+        }\n+\n+        private void serializeObject(ObjectNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                codeWriter.writeInline(\"{}\");\n+                return;\n+            }\n+\n+            codeWriter.openBlockInline(\"{\");\n+            serializeKeyValuePairs(node, shape);\n+            codeWriter.closeBlockWithoutNewline(\"}\");\n+        }\n+\n+        /**\n+         * Serialize an object node without the surrounding brackets.\n+         *\n+         * <p>This is mainly useful for serializing trait value nodes.\n+         *\n+         * @param node The node to serialize.\n+         * @param shape The shape of the node.\n+         */\n+        public void serializeKeyValuePairs(ObjectNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                return;\n+            }\n+\n+            // If we're looking at a structure or union shape, we'll need to get the member shape based on the\n+            // node key. Here we pre-compute a mapping so we don't have to traverse the member list every time.\n+            Map<String, MemberShape> members;\n+            if (shape == null) {\n+                members = Collections.emptyMap();\n+            } else {\n+                members = shape.members().stream().distinct()\n+                        .collect(Collectors.toMap(MemberShape::getMemberName, Function.identity()));\n+            }\n+\n+            node.getMembers().forEach((name, value) -> {\n+                // Try to find the member shape.\n+                Shape member;\n+                if (shape != null && shape.isMapShape()) {\n+                    // For maps the value member will always be the same.\n+                    member = shape.asMapShape().get().getValue();\n+                } else if (shape instanceof NamedMembersShape) {\n+                    member = members.get(name.getValue());\n+                } else {\n+                    // At this point the shape is either null or a document shape.\n+                    member = shape;\n+                }\n+\n+                codeWriter.writeInline(\"\\n$M: \", name.getValue());\n+                serialize(value, member);\n+                codeWriter.writeInline(\",\");\n+            });\n+            codeWriter.write(\"\");\n+        }\n+    }\n+\n+    /**\n+     * Extension of {@link CodeWriter} that provides additional convenience methods.\n+     *\n+     * <p>Provides a built in $I formatter that formats shape ids, automatically trimming namespace where possible.\n+     */\n+    private static final class SmithyCodeWriter extends CodeWriter {\n+        private static final Pattern UNQUOTED_STRING = Pattern.compile(\"[a-zA-Z_][\\\\w$.#]*\");\n+        private final String namespace;\n+        private final Model model;\n+        private final Set<ShapeId> imports;\n+\n+        SmithyCodeWriter(String namespace, Model model) {\n+            super();\n+            this.namespace = namespace;\n+            this.model = model;\n+            this.imports = new HashSet<>();\n+            trimTrailingSpaces();\n+            trimBlankLines();\n+            putFormatter('I', (s, i) -> formatShapeId(s));\n+            putFormatter('M', this::optionallyQuoteString);\n+        }\n+\n+        /**\n+         * Opens a block without writing indentation whitespace or inserting a newline.\n+         */\n+        public SmithyCodeWriter openBlockInline(String content, Object... args) {\n+            writeInline(content, args).indent();\n+            return this;\n+        }\n+\n+        /**\n+         * Closes a block without inserting a newline.\n+         */\n+        public SmithyCodeWriter closeBlockWithoutNewline(String content, Object... args) {\n+            setNewline(\"\");\n+            closeBlock(content, args);\n+            setNewline(\"\\n\");\n+            return this;\n+        }\n+\n+        /**\n+         * Writes an empty line that contains only indentation appropriate to the current indentation level.\n+         *\n+         * <p> This does not insert a trailing newline.\n+         */\n+        public SmithyCodeWriter writeIndent() {\n+            setNewline(\"\");\n+            // We explicitly want the trailing spaces, so disable trimming for this call.\n+            trimTrailingSpaces(false);\n+            write(\"\");\n+            trimTrailingSpaces();\n+            setNewline(\"\\n\");\n+            return this;\n+        }\n+\n+        private String formatShapeId(Object value) {\n+            if (value == null) {\n+                return \"\";\n+            }\n+            ShapeId shapeId = ShapeId.from(String.valueOf(value));\n+            if (!shouldWriteNamespace(shapeId)) {\n+                return shapeId.asRelativeReference();\n+            }\n+            return shapeId.toString();\n+        }\n+\n+        private boolean shouldWriteNamespace(ShapeId shapeId) {\n+            if (shapeId.getNamespace().equals(namespace)) {\n+                return false;\n+            }\n+            if (Prelude.isPublicPreludeShape(shapeId)) {\n+                return conflictsWithLocalNamespace(shapeId);\n+            }\n+            if (shouldImport(shapeId)) {\n+                imports.add(shapeId.withoutMember());\n+            }\n+            return !imports.contains(shapeId);\n+        }\n+\n+        private boolean conflictsWithLocalNamespace(ShapeId shapeId) {\n+            return model.getShape(ShapeId.fromParts(namespace, shapeId.getName())).isPresent();\n+        }\n+\n+        private boolean shouldImport(ShapeId shapeId) {\n+            return !conflictsWithLocalNamespace(shapeId)", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk0NTExOQ==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r382945119", "bodyText": "(Probably) nit: Does this need to materialize a List? It's probably not a big deal, but if this is called a lot, then it's a lot of unnecessary garbage to collect. Or could this even just change to replace the newline with the newline current indentation + string? We're already loading the whole thing into memory in a string.", "author": "mtdowling", "createdAt": "2020-02-22T22:06:34Z", "path": "smithy-utils/src/main/java/software/amazon/smithy/utils/CodeWriter.java", "diffHunk": "@@ -944,6 +945,43 @@ public final CodeWriter write(Object content, Object... args) {\n         return this;\n     }\n \n+    /**\n+     * Writes text to the CodeWriter without appending a newline or prefixing indentation.\n+     *\n+     * <p>If newlines are present in the given string, each of those lines will receive proper indentation.\n+     *\n+     * @param content Content to write.\n+     * @param args String arguments to use for formatting.\n+     * @return Returns the CodeWriter.\n+     */\n+    public final CodeWriter writeInline(Object content, Object... args) {\n+        String value = formatter.format(content, currentState.indentText, this, args);\n+        ArrayList<String> lines = new ArrayList<>(Arrays.asList(value.split(newlineRegexQuoted, -1)));", "originalCommit": "c0b8ce5ceccfbe17c6a10c7e028f1e48d2282846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e8097964862335d775b6628fef9c4b7fbdbec746", "url": "https://github.com/awslabs/smithy/commit/e8097964862335d775b6628fef9c4b7fbdbec746", "message": "Add filtering predicates to idl serializer", "committedDate": "2020-02-24T18:36:40Z", "type": "commit"}, {"oid": "675b7d12d1a2ec9da32c5f2fb74f4c951ae341d9", "url": "https://github.com/awslabs/smithy/commit/675b7d12d1a2ec9da32c5f2fb74f4c951ae341d9", "message": "Don't filter metadata case-insensitively\n\nShapes can be filtered case-insensitively because they are required\nto be case-insensitively unique. Metadata doesn't have that same\nconstraint though, so filtering them as such would lead to a non-\ndeterministic ordering.", "committedDate": "2020-02-24T18:40:29Z", "type": "commit"}, {"oid": "0f8205a2f5da508ed4ab106afd25772aaf38aae1", "url": "https://github.com/awslabs/smithy/commit/0f8205a2f5da508ed4ab106afd25772aaf38aae1", "message": "Serialize metadata-only models", "committedDate": "2020-02-24T19:00:34Z", "type": "commit"}, {"oid": "6fca073114eb353a7a859cc3b960bd40e3e634ce", "url": "https://github.com/awslabs/smithy/commit/6fca073114eb353a7a859cc3b960bd40e3e634ce", "message": "Clarify documentation on IDL serializer outputs", "committedDate": "2020-02-24T20:08:40Z", "type": "commit"}, {"oid": "5555a4e01f96d5006cc5ef7172da4ade3d5bf921", "url": "https://github.com/awslabs/smithy/commit/5555a4e01f96d5006cc5ef7172da4ade3d5bf921", "message": "Make IDL shape comparator private", "committedDate": "2020-02-24T20:09:17Z", "type": "commit"}, {"oid": "9397ca41929ced18c2c8e94fa2fae56ddd11d3f7", "url": "https://github.com/awslabs/smithy/commit/9397ca41929ced18c2c8e94fa2fae56ddd11d3f7", "message": "Sort structures before unions in serialized IDL", "committedDate": "2020-02-24T20:13:04Z", "type": "commit"}, {"oid": "496f43add49ad6c5631fd05a4aa017d57f86236e", "url": "https://github.com/awslabs/smithy/commit/496f43add49ad6c5631fd05a4aa017d57f86236e", "message": "touch up docs", "committedDate": "2020-02-24T20:22:05Z", "type": "commit"}, {"oid": "a96403acfe997bb20d864a7c755f5cc5984a0afa", "url": "https://github.com/awslabs/smithy/commit/a96403acfe997bb20d864a7c755f5cc5984a0afa", "message": "Make shapeplacer public", "committedDate": "2020-02-24T20:22:45Z", "type": "commit"}, {"oid": "9ef38f40b941a7029d36c403f889d0a60aa5a645", "url": "https://github.com/awslabs/smithy/commit/9ef38f40b941a7029d36c403f889d0a60aa5a645", "message": "Privatize everything that can be", "committedDate": "2020-02-24T22:02:22Z", "type": "commit"}, {"oid": "dd4396b7932d324e93c9318e0f26e58cef0317e1", "url": "https://github.com/awslabs/smithy/commit/dd4396b7932d324e93c9318e0f26e58cef0317e1", "message": "Use string array for writeInline", "committedDate": "2020-02-24T22:12:29Z", "type": "commit"}, {"oid": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "url": "https://github.com/awslabs/smithy/commit/b57193f74cf3dad4ad982569af0d4e1b26e954be", "message": "remove unused import", "committedDate": "2020-02-25T00:10:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMzQyNg==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384813426", "bodyText": "ShapeId and Shapes are already comparable.", "author": "mtdowling", "createdAt": "2020-02-26T22:44:40Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Predicate<String> metadataFilter;\n+    private final Predicate<Shape> shapeFilter;\n+    private final Predicate<Trait> traitFilter;\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        metadataFilter = builder.metadataFilter;\n+        shapeFilter = builder.shapeFilter.and(FunctionalUtils.not(Prelude::isPreludeShape));\n+        traitFilter = builder.traitFilter;\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>The output is a mapping\n+     *\n+     * <p>By default the paths are relative paths where each namespace is given its own file in the form\n+     * \"namespace.smithy\". This is configurable via the shape placer, which can place shapes into absolute\n+     * paths.\n+     *\n+     * <p>If the model contains no shapes, or all shapes are filtered out, then a single path \"metadata.smithy\"\n+     * will be present. This will contain only any defined metadata.\n+     *\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        List<Shape> shapes = model.shapes()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .filter(shapeFilter)\n+                .collect(Collectors.toList());\n+        if (shapes.isEmpty()) {\n+            return Collections.singletonMap(Paths.get(\"metadata.smithy\"), serializeHeader(model, null));\n+        }\n+        return shapes.stream()\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, traitFilter, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(fullModel, namespace) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(Model fullModel, String namespace) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(null, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .filter(entry -> metadataFilter.test(entry.getKey()))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        if (namespace != null) {\n+            codeWriter.write(\"namespace $L\", namespace)\n+                    .write(\"\")\n+                    // We want the extra blank line to separate the header and the model contents.\n+                    .trimBlankLines(-1);\n+        }\n+\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Sorts shapes into files based on their namespace, where each file is named {namespace}.smithy.\n+     */\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    private static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.UNION,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());", "originalCommit": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyMTE5NA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384821194", "bodyText": "They are, but they end up delegating to a case-sensitive comparison on the string representation of the shape id.", "author": "JordonPhillips", "createdAt": "2020-02-26T23:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMzQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDMzMw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384830333", "bodyText": "Case sensitivity FTW", "author": "mtdowling", "createdAt": "2020-02-26T23:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMzQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMjA0Nw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384832047", "bodyText": "This could be pretty annoying for large services with mixed casing", "author": "JordonPhillips", "createdAt": "2020-02-26T23:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMzQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMzkxMQ==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384813911", "bodyText": "Maybe just set a prority index for both then do the comparisons? This is having to do an O(N) scan multiple times for the same information, and this is used for sorting, so it's called a bunch.", "author": "mtdowling", "createdAt": "2020-02-26T22:45:48Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Predicate<String> metadataFilter;\n+    private final Predicate<Shape> shapeFilter;\n+    private final Predicate<Trait> traitFilter;\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        metadataFilter = builder.metadataFilter;\n+        shapeFilter = builder.shapeFilter.and(FunctionalUtils.not(Prelude::isPreludeShape));\n+        traitFilter = builder.traitFilter;\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>The output is a mapping\n+     *\n+     * <p>By default the paths are relative paths where each namespace is given its own file in the form\n+     * \"namespace.smithy\". This is configurable via the shape placer, which can place shapes into absolute\n+     * paths.\n+     *\n+     * <p>If the model contains no shapes, or all shapes are filtered out, then a single path \"metadata.smithy\"\n+     * will be present. This will contain only any defined metadata.\n+     *\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        List<Shape> shapes = model.shapes()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .filter(shapeFilter)\n+                .collect(Collectors.toList());\n+        if (shapes.isEmpty()) {\n+            return Collections.singletonMap(Paths.get(\"metadata.smithy\"), serializeHeader(model, null));\n+        }\n+        return shapes.stream()\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, traitFilter, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(fullModel, namespace) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(Model fullModel, String namespace) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(null, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .filter(entry -> metadataFilter.test(entry.getKey()))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        if (namespace != null) {\n+            codeWriter.write(\"namespace $L\", namespace)\n+                    .write(\"\")\n+                    // We want the extra blank line to separate the header and the model contents.\n+                    .trimBlankLines(-1);\n+        }\n+\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Sorts shapes into files based on their namespace, where each file is named {namespace}.smithy.\n+     */\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    private static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.UNION,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {", "originalCommit": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNDIzOA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384814238", "bodyText": "Should we accept a \"base path\" to make this easier to root somewhere?", "author": "mtdowling", "createdAt": "2020-02-26T22:46:34Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Predicate<String> metadataFilter;\n+    private final Predicate<Shape> shapeFilter;\n+    private final Predicate<Trait> traitFilter;\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {", "originalCommit": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNTA1Mw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384815053", "bodyText": "nit: you could create the grouped mapping here, check if it's empty or not, and then not need to materialize this intermediate list just to check if you're serializing shapes.", "author": "mtdowling", "createdAt": "2020-02-26T22:48:33Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Predicate<String> metadataFilter;\n+    private final Predicate<Shape> shapeFilter;\n+    private final Predicate<Trait> traitFilter;\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        metadataFilter = builder.metadataFilter;\n+        shapeFilter = builder.shapeFilter.and(FunctionalUtils.not(Prelude::isPreludeShape));\n+        traitFilter = builder.traitFilter;\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>The output is a mapping\n+     *\n+     * <p>By default the paths are relative paths where each namespace is given its own file in the form\n+     * \"namespace.smithy\". This is configurable via the shape placer, which can place shapes into absolute\n+     * paths.\n+     *\n+     * <p>If the model contains no shapes, or all shapes are filtered out, then a single path \"metadata.smithy\"\n+     * will be present. This will contain only any defined metadata.\n+     *\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        List<Shape> shapes = model.shapes()", "originalCommit": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNTY1MQ==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384815651", "bodyText": "nit: typically you filter before sorting to reduce the work sorting has to do", "author": "mtdowling", "createdAt": "2020-02-26T22:50:10Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Predicate<String> metadataFilter;\n+    private final Predicate<Shape> shapeFilter;\n+    private final Predicate<Trait> traitFilter;\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        metadataFilter = builder.metadataFilter;\n+        shapeFilter = builder.shapeFilter.and(FunctionalUtils.not(Prelude::isPreludeShape));\n+        traitFilter = builder.traitFilter;\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>The output is a mapping\n+     *\n+     * <p>By default the paths are relative paths where each namespace is given its own file in the form\n+     * \"namespace.smithy\". This is configurable via the shape placer, which can place shapes into absolute\n+     * paths.\n+     *\n+     * <p>If the model contains no shapes, or all shapes are filtered out, then a single path \"metadata.smithy\"\n+     * will be present. This will contain only any defined metadata.\n+     *\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        List<Shape> shapes = model.shapes()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .filter(shapeFilter)\n+                .collect(Collectors.toList());\n+        if (shapes.isEmpty()) {\n+            return Collections.singletonMap(Paths.get(\"metadata.smithy\"), serializeHeader(model, null));\n+        }\n+        return shapes.stream()\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, traitFilter, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(fullModel, namespace) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(Model fullModel, String namespace) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(null, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .filter(entry -> metadataFilter.test(entry.getKey()))", "originalCommit": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNzIyOQ==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384817229", "bodyText": "Why call distinct here?", "author": "mtdowling", "createdAt": "2020-02-26T22:54:08Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Predicate<String> metadataFilter;\n+    private final Predicate<Shape> shapeFilter;\n+    private final Predicate<Trait> traitFilter;\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        metadataFilter = builder.metadataFilter;\n+        shapeFilter = builder.shapeFilter.and(FunctionalUtils.not(Prelude::isPreludeShape));\n+        traitFilter = builder.traitFilter;\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>The output is a mapping\n+     *\n+     * <p>By default the paths are relative paths where each namespace is given its own file in the form\n+     * \"namespace.smithy\". This is configurable via the shape placer, which can place shapes into absolute\n+     * paths.\n+     *\n+     * <p>If the model contains no shapes, or all shapes are filtered out, then a single path \"metadata.smithy\"\n+     * will be present. This will contain only any defined metadata.\n+     *\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        List<Shape> shapes = model.shapes()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .filter(shapeFilter)\n+                .collect(Collectors.toList());\n+        if (shapes.isEmpty()) {\n+            return Collections.singletonMap(Paths.get(\"metadata.smithy\"), serializeHeader(model, null));\n+        }\n+        return shapes.stream()\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, traitFilter, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(fullModel, namespace) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(Model fullModel, String namespace) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(null, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .filter(entry -> metadataFilter.test(entry.getKey()))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        if (namespace != null) {\n+            codeWriter.write(\"namespace $L\", namespace)\n+                    .write(\"\")\n+                    // We want the extra blank line to separate the header and the model contents.\n+                    .trimBlankLines(-1);\n+        }\n+\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Sorts shapes into files based on their namespace, where each file is named {namespace}.smithy.\n+     */\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    private static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.UNION,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Predicate<String> metadataFilter = pair -> true;\n+        private Predicate<Shape> shapeFilter = shape -> true;\n+        private Predicate<Trait> traitFilter = trait -> true;\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Predicate that determines if a metadata is serialized.\n+         *\n+         * @param metadataFilter Predicate that accepts a metadata key.\n+         * @return Returns the builder.\n+         */\n+        public Builder metadataFilter(Predicate<String> metadataFilter) {\n+            this.metadataFilter = Objects.requireNonNull(metadataFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Predicate that determines if a shape and its traits are serialized.\n+         *\n+         * @param shapeFilter Predicate that accepts a shape.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapeFilter(Predicate<Shape> shapeFilter) {\n+            this.shapeFilter = Objects.requireNonNull(shapeFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets a predicate that can be used to filter trait values from\n+         * appearing in the serialized model.\n+         *\n+         * <p>Note that this does not filter out trait definitions. It only filters\n+         * out instances of traits from being serialized on shapes.\n+         *\n+         * @param traitFilter Predicate that filters out trait definitions.\n+         * @return Returns the builder.\n+         */\n+        public Builder traitFilter(Predicate<Trait> traitFilter) {\n+            this.traitFilter = traitFilter;\n+            return this;\n+        }\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>The returned paths may be absolute or relative.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.\n+         *\n+         * @param shapePlacer Function that accepts a shape and returns file path.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapePlacer(Function<Shape, Path> shapePlacer) {\n+            this.shapePlacer = Objects.requireNonNull(shapePlacer);\n+            return this;\n+        }\n+\n+        @Override\n+        public SmithyIdlModelSerializer build() {\n+            return new SmithyIdlModelSerializer(this);\n+        }\n+    }\n+\n+    /**\n+     * Serializes shapes in the IDL format.\n+     */\n+    private static final class ShapeSerializer extends ShapeVisitor.Default<Void> {\n+        private final SmithyCodeWriter codeWriter;\n+        private final NodeSerializer nodeSerializer;\n+        private final Predicate<Trait> traitFilter;\n+        private final Model model;\n+\n+        ShapeSerializer(\n+                SmithyCodeWriter codeWriter,\n+                NodeSerializer nodeSerializer,\n+                Predicate<Trait> traitFilter,\n+                Model model\n+        ) {\n+            this.codeWriter = codeWriter;\n+            this.nodeSerializer = nodeSerializer;\n+            this.traitFilter = traitFilter;\n+            this.model = model;\n+        }\n+\n+        @Override\n+        protected Void getDefault(Shape shape) {\n+            serializeTraits(shape);\n+            codeWriter.write(\"$L $L\", shape.getType(), shape.getId().getName()).write(\"\");\n+            return null;\n+        }\n+\n+        private void shapeWithMembers(Shape shape, List<MemberShape> members) {\n+            serializeTraits(shape);\n+            if (members.isEmpty()) {\n+                // If there are no members then we don't want to introduce an unnecessary newline by opening a block.\n+                codeWriter.write(\"$L $L {}\", shape.getType(), shape.getId().getName()).write(\"\");\n+                return;\n+            }\n+\n+            codeWriter.openBlock(\"$L $L {\", shape.getType(), shape.getId().getName());\n+            for (MemberShape member : members) {\n+                serializeTraits(member);\n+                codeWriter.write(\"$L: $I,\", member.getMemberName(), member.getTarget());\n+            }\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+        }\n+\n+        private void serializeTraits(Shape shape) {\n+            // The documentation trait always needs to be serialized first since it uses special syntax.\n+            shape.getTrait(DocumentationTrait.class).filter(traitFilter).ifPresent(this::serializeDocumentationTrait);\n+            shape.getAllTraits().values().stream()\n+                    .filter(trait -> !(trait instanceof DocumentationTrait))\n+                    .filter(traitFilter)\n+                    .sorted(Comparator.comparing(trait -> trait.toShapeId().toString(), String.CASE_INSENSITIVE_ORDER))\n+                    .forEach(this::serializeTrait);\n+        }\n+\n+        private void serializeDocumentationTrait(DocumentationTrait trait) {\n+            // The documentation trait has a special syntax, which we always want to use.\n+            codeWriter.setNewlinePrefix(\"/// \")\n+                    .write(trait.getValue().replace(\"$\", \"$$\"))\n+                    .setNewlinePrefix(\"\");\n+        }\n+\n+        private void serializeTrait(Trait trait) {\n+            Node node = trait.toNode();\n+            Shape shape = model.expectShape(trait.toShapeId());\n+\n+            if (trait instanceof BooleanTrait || isEmptyStructure(node, shape)) {\n+                // Traits that inherit from BooleanTrait specifically can omit a value.\n+                // Traits that are simply boolean shapes which don't implement BooleanTrait cannot.\n+                // Additionally, empty structure traits can omit a value.\n+                codeWriter.write(\"@$I\", trait.toShapeId());\n+            } else if (node.isObjectNode()) {\n+                codeWriter.writeIndent().openBlockInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serializeKeyValuePairs(node.expectObjectNode(), shape);\n+                codeWriter.closeBlock(\")\");\n+            } else {\n+                codeWriter.writeIndent().writeInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serialize(node, shape);\n+                codeWriter.write(\")\");\n+            }\n+        }\n+\n+        private boolean isEmptyStructure(Node node, Shape shape) {\n+            return !shape.isDocumentShape() && node.asObjectNode().map(ObjectNode::isEmpty).orElse(false);\n+        }\n+\n+        @Override\n+        public Void listShape(ListShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void setShape(SetShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void mapShape(MapShape shape) {\n+            shapeWithMembers(shape, ListUtils.of(shape.getKey(), shape.getValue()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void structureShape(StructureShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void unionShape(UnionShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        private List<MemberShape> sortMembers(Collection<MemberShape> members) {\n+            return members.stream()\n+                    .sorted(Comparator.comparing(MemberShape::getMemberName, String.CASE_INSENSITIVE_ORDER))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public Void serviceShape(ServiceShape shape) {\n+            serializeTraits(shape);\n+            codeWriter.openBlock(\"service $L {\", shape.getId().getName())\n+                    .write(\"version: $S,\", shape.getVersion());\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+            return null;\n+        }\n+\n+        @Override\n+        public Void resourceShape(ResourceShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyResource(shape)) {\n+                codeWriter.write(\"resource $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"resource $L {\", shape.getId().getName());\n+            if (!shape.getIdentifiers().isEmpty()) {\n+                codeWriter.openBlock(\"identifiers: {\");\n+                shape.getIdentifiers().entrySet().stream()\n+                        .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                        .forEach(entry -> codeWriter.write(\n+                                \"$L: $I,\", entry.getKey(), entry.getValue()));\n+                codeWriter.closeBlock(\"},\");\n+            }\n+\n+            shape.getPut().ifPresent(shapeId -> codeWriter.write(\"put: $I,\", shapeId));\n+            shape.getCreate().ifPresent(shapeId -> codeWriter.write(\"create: $I,\", shapeId));\n+            shape.getRead().ifPresent(shapeId -> codeWriter.write(\"read: $I,\", shapeId));\n+            shape.getUpdate().ifPresent(shapeId -> codeWriter.write(\"update: $I,\", shapeId));\n+            shape.getDelete().ifPresent(shapeId -> codeWriter.write(\"delete: $I,\", shapeId));\n+            shape.getList().ifPresent(shapeId -> codeWriter.write(\"list: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"collectionOperations\", shape.getCollectionOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyResource(ResourceShape shape) {\n+            return !(!shape.getIdentifiers().isEmpty()\n+                    || !shape.getOperations().isEmpty()\n+                    || !shape.getCollectionOperations().isEmpty()\n+                    || !shape.getResources().isEmpty()\n+                    || shape.getPut().isPresent()\n+                    || shape.getCreate().isPresent()\n+                    || shape.getRead().isPresent()\n+                    || shape.getUpdate().isPresent()\n+                    || shape.getDelete().isPresent()\n+                    || shape.getList().isPresent());\n+        }\n+\n+        @Override\n+        public Void operationShape(OperationShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyOperation(shape)) {\n+                codeWriter.write(\"operation $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"operation $L {\", shape.getId().getName());\n+            shape.getInput().ifPresent(shapeId -> codeWriter.write(\"input: $I,\", shapeId));\n+            shape.getOutput().ifPresent(shapeId -> codeWriter.write(\"output: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"errors\", shape.getErrors());\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyOperation(OperationShape shape) {\n+            return !(shape.getInput().isPresent() || shape.getOutput().isPresent() || !shape.getErrors().isEmpty());\n+        }\n+    }\n+\n+    /**\n+     * Serializes nodes into the Smithy IDL format.\n+     */\n+    private static final class NodeSerializer {\n+        private final SmithyCodeWriter codeWriter;\n+        private final Model model;\n+\n+        NodeSerializer(SmithyCodeWriter codeWriter, Model model) {\n+            this.codeWriter = codeWriter;\n+            this.model = model;\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * @param node The node to serialize.\n+         */\n+        private void serialize(Node node) {\n+            serialize(node, null);\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * <p>This uses the given shape to influence serialization. For example, a string shape marked with the idRef\n+         * trait will be serialized as a shape id rather than a string.\n+         *\n+         * @param node The node to serialize.\n+         * @param shape The shape of the node.\n+         */\n+        private void serialize(Node node, Shape shape) {\n+            // ShapeIds are represented differently than strings, so if a shape looks like it's\n+            // representing a shapeId we need to serialize it without quotes.\n+            if (isShapeId(shape)) {\n+                serializeShapeId(node.expectStringNode());\n+                return;\n+            }\n+\n+            if (shape != null && shape.isMemberShape()) {\n+                shape = model.expectShape(shape.asMemberShape().get().getTarget());\n+            }\n+\n+            if (node.isStringNode()) {\n+                serializeString(node.expectStringNode());\n+            } else if (node.isNumberNode()) {\n+                serializeNumber(node.expectNumberNode());\n+            } else if (node.isBooleanNode()) {\n+                serializeBoolean(node.expectBooleanNode());\n+            } else if (node.isNullNode()) {\n+                serializeNull();\n+            } else if (node.isArrayNode()) {\n+                serializeArray(node.expectArrayNode(), shape);\n+            } else if (node.isObjectNode()) {\n+                serializeObject(node.expectObjectNode(), shape);\n+            }\n+        }\n+\n+        private boolean isShapeId(Shape shape) {\n+            if (shape == null) {\n+                return false;\n+            }\n+            if (shape.isMemberShape()) {\n+                return shape.asMemberShape()\n+                        .flatMap(member -> member.getMemberTrait(model, IdRefTrait.class)).isPresent();\n+            }\n+            return shape.hasTrait(IdRefTrait.class);\n+        }\n+\n+        private void serializeString(StringNode node) {\n+            codeWriter.writeInline(\"$S\", node.getValue());\n+        }\n+\n+        private void serializeShapeId(StringNode node) {\n+            codeWriter.writeInline(\"$I\", node.getValue());\n+        }\n+\n+        private void serializeNumber(NumberNode node) {\n+            codeWriter.writeInline(\"$L\", node.getValue());\n+        }\n+\n+        private void serializeBoolean(BooleanNode node) {\n+            codeWriter.writeInline(String.valueOf(node.getValue()));\n+        }\n+\n+        private void serializeNull() {\n+            codeWriter.writeInline(\"null\");\n+        }\n+\n+        private void serializeArray(ArrayNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                codeWriter.writeInline(\"[]\");\n+                return;\n+            }\n+\n+            codeWriter.openBlockInline(\"[\");\n+\n+            // If it's not a collection shape, it'll be a document shape or null\n+            Shape member = shape;\n+            if (shape instanceof CollectionShape) {\n+                member = ((CollectionShape) shape).getMember();\n+            }\n+\n+            for (Node element : node.getElements()) {\n+                // Elements will be written inline to enable them being written as values.\n+                // So here we need to ensure that they're written on a new line that's properly indented.\n+                codeWriter.write(\"\");\n+                codeWriter.writeIndent();\n+                serialize(element, member);\n+                codeWriter.writeInline(\",\");\n+            }\n+            codeWriter.write(\"\");\n+\n+            // We want to make sure to close without inserting a newline, as this could itself be a list element\n+            //or an object value.\n+            codeWriter.closeBlockWithoutNewline(\"]\");\n+        }\n+\n+        private void serializeObject(ObjectNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                codeWriter.writeInline(\"{}\");\n+                return;\n+            }\n+\n+            codeWriter.openBlockInline(\"{\");\n+            serializeKeyValuePairs(node, shape);\n+            codeWriter.closeBlockWithoutNewline(\"}\");\n+        }\n+\n+        /**\n+         * Serialize an object node without the surrounding brackets.\n+         *\n+         * <p>This is mainly useful for serializing trait value nodes.\n+         *\n+         * @param node The node to serialize.\n+         * @param shape The shape of the node.\n+         */\n+        private void serializeKeyValuePairs(ObjectNode node, Shape shape) {\n+            if (node.isEmpty()) {\n+                return;\n+            }\n+\n+            // If we're looking at a structure or union shape, we'll need to get the member shape based on the\n+            // node key. Here we pre-compute a mapping so we don't have to traverse the member list every time.\n+            Map<String, MemberShape> members;\n+            if (shape == null) {\n+                members = Collections.emptyMap();\n+            } else {\n+                members = shape.members().stream().distinct()", "originalCommit": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxNzc4NQ==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384817785", "bodyText": "You can call getMemberTrait on any shape, so no need to first get it as a memberShape.", "author": "mtdowling", "createdAt": "2020-02-26T22:55:28Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Predicate<String> metadataFilter;\n+    private final Predicate<Shape> shapeFilter;\n+    private final Predicate<Trait> traitFilter;\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        metadataFilter = builder.metadataFilter;\n+        shapeFilter = builder.shapeFilter.and(FunctionalUtils.not(Prelude::isPreludeShape));\n+        traitFilter = builder.traitFilter;\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>The output is a mapping\n+     *\n+     * <p>By default the paths are relative paths where each namespace is given its own file in the form\n+     * \"namespace.smithy\". This is configurable via the shape placer, which can place shapes into absolute\n+     * paths.\n+     *\n+     * <p>If the model contains no shapes, or all shapes are filtered out, then a single path \"metadata.smithy\"\n+     * will be present. This will contain only any defined metadata.\n+     *\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        List<Shape> shapes = model.shapes()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .filter(shapeFilter)\n+                .collect(Collectors.toList());\n+        if (shapes.isEmpty()) {\n+            return Collections.singletonMap(Paths.get(\"metadata.smithy\"), serializeHeader(model, null));\n+        }\n+        return shapes.stream()\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, traitFilter, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(fullModel, namespace) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(Model fullModel, String namespace) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(null, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .filter(entry -> metadataFilter.test(entry.getKey()))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        if (namespace != null) {\n+            codeWriter.write(\"namespace $L\", namespace)\n+                    .write(\"\")\n+                    // We want the extra blank line to separate the header and the model contents.\n+                    .trimBlankLines(-1);\n+        }\n+\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Sorts shapes into files based on their namespace, where each file is named {namespace}.smithy.\n+     */\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    private static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.UNION,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Predicate<String> metadataFilter = pair -> true;\n+        private Predicate<Shape> shapeFilter = shape -> true;\n+        private Predicate<Trait> traitFilter = trait -> true;\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Predicate that determines if a metadata is serialized.\n+         *\n+         * @param metadataFilter Predicate that accepts a metadata key.\n+         * @return Returns the builder.\n+         */\n+        public Builder metadataFilter(Predicate<String> metadataFilter) {\n+            this.metadataFilter = Objects.requireNonNull(metadataFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Predicate that determines if a shape and its traits are serialized.\n+         *\n+         * @param shapeFilter Predicate that accepts a shape.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapeFilter(Predicate<Shape> shapeFilter) {\n+            this.shapeFilter = Objects.requireNonNull(shapeFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets a predicate that can be used to filter trait values from\n+         * appearing in the serialized model.\n+         *\n+         * <p>Note that this does not filter out trait definitions. It only filters\n+         * out instances of traits from being serialized on shapes.\n+         *\n+         * @param traitFilter Predicate that filters out trait definitions.\n+         * @return Returns the builder.\n+         */\n+        public Builder traitFilter(Predicate<Trait> traitFilter) {\n+            this.traitFilter = traitFilter;\n+            return this;\n+        }\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>The returned paths may be absolute or relative.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.\n+         *\n+         * @param shapePlacer Function that accepts a shape and returns file path.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapePlacer(Function<Shape, Path> shapePlacer) {\n+            this.shapePlacer = Objects.requireNonNull(shapePlacer);\n+            return this;\n+        }\n+\n+        @Override\n+        public SmithyIdlModelSerializer build() {\n+            return new SmithyIdlModelSerializer(this);\n+        }\n+    }\n+\n+    /**\n+     * Serializes shapes in the IDL format.\n+     */\n+    private static final class ShapeSerializer extends ShapeVisitor.Default<Void> {\n+        private final SmithyCodeWriter codeWriter;\n+        private final NodeSerializer nodeSerializer;\n+        private final Predicate<Trait> traitFilter;\n+        private final Model model;\n+\n+        ShapeSerializer(\n+                SmithyCodeWriter codeWriter,\n+                NodeSerializer nodeSerializer,\n+                Predicate<Trait> traitFilter,\n+                Model model\n+        ) {\n+            this.codeWriter = codeWriter;\n+            this.nodeSerializer = nodeSerializer;\n+            this.traitFilter = traitFilter;\n+            this.model = model;\n+        }\n+\n+        @Override\n+        protected Void getDefault(Shape shape) {\n+            serializeTraits(shape);\n+            codeWriter.write(\"$L $L\", shape.getType(), shape.getId().getName()).write(\"\");\n+            return null;\n+        }\n+\n+        private void shapeWithMembers(Shape shape, List<MemberShape> members) {\n+            serializeTraits(shape);\n+            if (members.isEmpty()) {\n+                // If there are no members then we don't want to introduce an unnecessary newline by opening a block.\n+                codeWriter.write(\"$L $L {}\", shape.getType(), shape.getId().getName()).write(\"\");\n+                return;\n+            }\n+\n+            codeWriter.openBlock(\"$L $L {\", shape.getType(), shape.getId().getName());\n+            for (MemberShape member : members) {\n+                serializeTraits(member);\n+                codeWriter.write(\"$L: $I,\", member.getMemberName(), member.getTarget());\n+            }\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+        }\n+\n+        private void serializeTraits(Shape shape) {\n+            // The documentation trait always needs to be serialized first since it uses special syntax.\n+            shape.getTrait(DocumentationTrait.class).filter(traitFilter).ifPresent(this::serializeDocumentationTrait);\n+            shape.getAllTraits().values().stream()\n+                    .filter(trait -> !(trait instanceof DocumentationTrait))\n+                    .filter(traitFilter)\n+                    .sorted(Comparator.comparing(trait -> trait.toShapeId().toString(), String.CASE_INSENSITIVE_ORDER))\n+                    .forEach(this::serializeTrait);\n+        }\n+\n+        private void serializeDocumentationTrait(DocumentationTrait trait) {\n+            // The documentation trait has a special syntax, which we always want to use.\n+            codeWriter.setNewlinePrefix(\"/// \")\n+                    .write(trait.getValue().replace(\"$\", \"$$\"))\n+                    .setNewlinePrefix(\"\");\n+        }\n+\n+        private void serializeTrait(Trait trait) {\n+            Node node = trait.toNode();\n+            Shape shape = model.expectShape(trait.toShapeId());\n+\n+            if (trait instanceof BooleanTrait || isEmptyStructure(node, shape)) {\n+                // Traits that inherit from BooleanTrait specifically can omit a value.\n+                // Traits that are simply boolean shapes which don't implement BooleanTrait cannot.\n+                // Additionally, empty structure traits can omit a value.\n+                codeWriter.write(\"@$I\", trait.toShapeId());\n+            } else if (node.isObjectNode()) {\n+                codeWriter.writeIndent().openBlockInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serializeKeyValuePairs(node.expectObjectNode(), shape);\n+                codeWriter.closeBlock(\")\");\n+            } else {\n+                codeWriter.writeIndent().writeInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serialize(node, shape);\n+                codeWriter.write(\")\");\n+            }\n+        }\n+\n+        private boolean isEmptyStructure(Node node, Shape shape) {\n+            return !shape.isDocumentShape() && node.asObjectNode().map(ObjectNode::isEmpty).orElse(false);\n+        }\n+\n+        @Override\n+        public Void listShape(ListShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void setShape(SetShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void mapShape(MapShape shape) {\n+            shapeWithMembers(shape, ListUtils.of(shape.getKey(), shape.getValue()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void structureShape(StructureShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void unionShape(UnionShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        private List<MemberShape> sortMembers(Collection<MemberShape> members) {\n+            return members.stream()\n+                    .sorted(Comparator.comparing(MemberShape::getMemberName, String.CASE_INSENSITIVE_ORDER))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public Void serviceShape(ServiceShape shape) {\n+            serializeTraits(shape);\n+            codeWriter.openBlock(\"service $L {\", shape.getId().getName())\n+                    .write(\"version: $S,\", shape.getVersion());\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+            return null;\n+        }\n+\n+        @Override\n+        public Void resourceShape(ResourceShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyResource(shape)) {\n+                codeWriter.write(\"resource $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"resource $L {\", shape.getId().getName());\n+            if (!shape.getIdentifiers().isEmpty()) {\n+                codeWriter.openBlock(\"identifiers: {\");\n+                shape.getIdentifiers().entrySet().stream()\n+                        .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                        .forEach(entry -> codeWriter.write(\n+                                \"$L: $I,\", entry.getKey(), entry.getValue()));\n+                codeWriter.closeBlock(\"},\");\n+            }\n+\n+            shape.getPut().ifPresent(shapeId -> codeWriter.write(\"put: $I,\", shapeId));\n+            shape.getCreate().ifPresent(shapeId -> codeWriter.write(\"create: $I,\", shapeId));\n+            shape.getRead().ifPresent(shapeId -> codeWriter.write(\"read: $I,\", shapeId));\n+            shape.getUpdate().ifPresent(shapeId -> codeWriter.write(\"update: $I,\", shapeId));\n+            shape.getDelete().ifPresent(shapeId -> codeWriter.write(\"delete: $I,\", shapeId));\n+            shape.getList().ifPresent(shapeId -> codeWriter.write(\"list: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"collectionOperations\", shape.getCollectionOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyResource(ResourceShape shape) {\n+            return !(!shape.getIdentifiers().isEmpty()\n+                    || !shape.getOperations().isEmpty()\n+                    || !shape.getCollectionOperations().isEmpty()\n+                    || !shape.getResources().isEmpty()\n+                    || shape.getPut().isPresent()\n+                    || shape.getCreate().isPresent()\n+                    || shape.getRead().isPresent()\n+                    || shape.getUpdate().isPresent()\n+                    || shape.getDelete().isPresent()\n+                    || shape.getList().isPresent());\n+        }\n+\n+        @Override\n+        public Void operationShape(OperationShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyOperation(shape)) {\n+                codeWriter.write(\"operation $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"operation $L {\", shape.getId().getName());\n+            shape.getInput().ifPresent(shapeId -> codeWriter.write(\"input: $I,\", shapeId));\n+            shape.getOutput().ifPresent(shapeId -> codeWriter.write(\"output: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"errors\", shape.getErrors());\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyOperation(OperationShape shape) {\n+            return !(shape.getInput().isPresent() || shape.getOutput().isPresent() || !shape.getErrors().isEmpty());\n+        }\n+    }\n+\n+    /**\n+     * Serializes nodes into the Smithy IDL format.\n+     */\n+    private static final class NodeSerializer {\n+        private final SmithyCodeWriter codeWriter;\n+        private final Model model;\n+\n+        NodeSerializer(SmithyCodeWriter codeWriter, Model model) {\n+            this.codeWriter = codeWriter;\n+            this.model = model;\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * @param node The node to serialize.\n+         */\n+        private void serialize(Node node) {\n+            serialize(node, null);\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * <p>This uses the given shape to influence serialization. For example, a string shape marked with the idRef\n+         * trait will be serialized as a shape id rather than a string.\n+         *\n+         * @param node The node to serialize.\n+         * @param shape The shape of the node.\n+         */\n+        private void serialize(Node node, Shape shape) {\n+            // ShapeIds are represented differently than strings, so if a shape looks like it's\n+            // representing a shapeId we need to serialize it without quotes.\n+            if (isShapeId(shape)) {\n+                serializeShapeId(node.expectStringNode());\n+                return;\n+            }\n+\n+            if (shape != null && shape.isMemberShape()) {\n+                shape = model.expectShape(shape.asMemberShape().get().getTarget());\n+            }\n+\n+            if (node.isStringNode()) {\n+                serializeString(node.expectStringNode());\n+            } else if (node.isNumberNode()) {\n+                serializeNumber(node.expectNumberNode());\n+            } else if (node.isBooleanNode()) {\n+                serializeBoolean(node.expectBooleanNode());\n+            } else if (node.isNullNode()) {\n+                serializeNull();\n+            } else if (node.isArrayNode()) {\n+                serializeArray(node.expectArrayNode(), shape);\n+            } else if (node.isObjectNode()) {\n+                serializeObject(node.expectObjectNode(), shape);\n+            }\n+        }\n+\n+        private boolean isShapeId(Shape shape) {\n+            if (shape == null) {\n+                return false;\n+            }\n+            if (shape.isMemberShape()) {\n+                return shape.asMemberShape()", "originalCommit": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxODAzMw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384818033", "bodyText": "A NodeVisitor might make this look a bit nicer.", "author": "mtdowling", "createdAt": "2020-02-26T22:56:01Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Predicate<String> metadataFilter;\n+    private final Predicate<Shape> shapeFilter;\n+    private final Predicate<Trait> traitFilter;\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        metadataFilter = builder.metadataFilter;\n+        shapeFilter = builder.shapeFilter.and(FunctionalUtils.not(Prelude::isPreludeShape));\n+        traitFilter = builder.traitFilter;\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>The output is a mapping\n+     *\n+     * <p>By default the paths are relative paths where each namespace is given its own file in the form\n+     * \"namespace.smithy\". This is configurable via the shape placer, which can place shapes into absolute\n+     * paths.\n+     *\n+     * <p>If the model contains no shapes, or all shapes are filtered out, then a single path \"metadata.smithy\"\n+     * will be present. This will contain only any defined metadata.\n+     *\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        List<Shape> shapes = model.shapes()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .filter(shapeFilter)\n+                .collect(Collectors.toList());\n+        if (shapes.isEmpty()) {\n+            return Collections.singletonMap(Paths.get(\"metadata.smithy\"), serializeHeader(model, null));\n+        }\n+        return shapes.stream()\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, traitFilter, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(fullModel, namespace) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(Model fullModel, String namespace) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(null, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .filter(entry -> metadataFilter.test(entry.getKey()))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        if (namespace != null) {\n+            codeWriter.write(\"namespace $L\", namespace)\n+                    .write(\"\")\n+                    // We want the extra blank line to separate the header and the model contents.\n+                    .trimBlankLines(-1);\n+        }\n+\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Sorts shapes into files based on their namespace, where each file is named {namespace}.smithy.\n+     */\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    private static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.UNION,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Predicate<String> metadataFilter = pair -> true;\n+        private Predicate<Shape> shapeFilter = shape -> true;\n+        private Predicate<Trait> traitFilter = trait -> true;\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Predicate that determines if a metadata is serialized.\n+         *\n+         * @param metadataFilter Predicate that accepts a metadata key.\n+         * @return Returns the builder.\n+         */\n+        public Builder metadataFilter(Predicate<String> metadataFilter) {\n+            this.metadataFilter = Objects.requireNonNull(metadataFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Predicate that determines if a shape and its traits are serialized.\n+         *\n+         * @param shapeFilter Predicate that accepts a shape.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapeFilter(Predicate<Shape> shapeFilter) {\n+            this.shapeFilter = Objects.requireNonNull(shapeFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets a predicate that can be used to filter trait values from\n+         * appearing in the serialized model.\n+         *\n+         * <p>Note that this does not filter out trait definitions. It only filters\n+         * out instances of traits from being serialized on shapes.\n+         *\n+         * @param traitFilter Predicate that filters out trait definitions.\n+         * @return Returns the builder.\n+         */\n+        public Builder traitFilter(Predicate<Trait> traitFilter) {\n+            this.traitFilter = traitFilter;\n+            return this;\n+        }\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>The returned paths may be absolute or relative.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.\n+         *\n+         * @param shapePlacer Function that accepts a shape and returns file path.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapePlacer(Function<Shape, Path> shapePlacer) {\n+            this.shapePlacer = Objects.requireNonNull(shapePlacer);\n+            return this;\n+        }\n+\n+        @Override\n+        public SmithyIdlModelSerializer build() {\n+            return new SmithyIdlModelSerializer(this);\n+        }\n+    }\n+\n+    /**\n+     * Serializes shapes in the IDL format.\n+     */\n+    private static final class ShapeSerializer extends ShapeVisitor.Default<Void> {\n+        private final SmithyCodeWriter codeWriter;\n+        private final NodeSerializer nodeSerializer;\n+        private final Predicate<Trait> traitFilter;\n+        private final Model model;\n+\n+        ShapeSerializer(\n+                SmithyCodeWriter codeWriter,\n+                NodeSerializer nodeSerializer,\n+                Predicate<Trait> traitFilter,\n+                Model model\n+        ) {\n+            this.codeWriter = codeWriter;\n+            this.nodeSerializer = nodeSerializer;\n+            this.traitFilter = traitFilter;\n+            this.model = model;\n+        }\n+\n+        @Override\n+        protected Void getDefault(Shape shape) {\n+            serializeTraits(shape);\n+            codeWriter.write(\"$L $L\", shape.getType(), shape.getId().getName()).write(\"\");\n+            return null;\n+        }\n+\n+        private void shapeWithMembers(Shape shape, List<MemberShape> members) {\n+            serializeTraits(shape);\n+            if (members.isEmpty()) {\n+                // If there are no members then we don't want to introduce an unnecessary newline by opening a block.\n+                codeWriter.write(\"$L $L {}\", shape.getType(), shape.getId().getName()).write(\"\");\n+                return;\n+            }\n+\n+            codeWriter.openBlock(\"$L $L {\", shape.getType(), shape.getId().getName());\n+            for (MemberShape member : members) {\n+                serializeTraits(member);\n+                codeWriter.write(\"$L: $I,\", member.getMemberName(), member.getTarget());\n+            }\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+        }\n+\n+        private void serializeTraits(Shape shape) {\n+            // The documentation trait always needs to be serialized first since it uses special syntax.\n+            shape.getTrait(DocumentationTrait.class).filter(traitFilter).ifPresent(this::serializeDocumentationTrait);\n+            shape.getAllTraits().values().stream()\n+                    .filter(trait -> !(trait instanceof DocumentationTrait))\n+                    .filter(traitFilter)\n+                    .sorted(Comparator.comparing(trait -> trait.toShapeId().toString(), String.CASE_INSENSITIVE_ORDER))\n+                    .forEach(this::serializeTrait);\n+        }\n+\n+        private void serializeDocumentationTrait(DocumentationTrait trait) {\n+            // The documentation trait has a special syntax, which we always want to use.\n+            codeWriter.setNewlinePrefix(\"/// \")\n+                    .write(trait.getValue().replace(\"$\", \"$$\"))\n+                    .setNewlinePrefix(\"\");\n+        }\n+\n+        private void serializeTrait(Trait trait) {\n+            Node node = trait.toNode();\n+            Shape shape = model.expectShape(trait.toShapeId());\n+\n+            if (trait instanceof BooleanTrait || isEmptyStructure(node, shape)) {\n+                // Traits that inherit from BooleanTrait specifically can omit a value.\n+                // Traits that are simply boolean shapes which don't implement BooleanTrait cannot.\n+                // Additionally, empty structure traits can omit a value.\n+                codeWriter.write(\"@$I\", trait.toShapeId());\n+            } else if (node.isObjectNode()) {\n+                codeWriter.writeIndent().openBlockInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serializeKeyValuePairs(node.expectObjectNode(), shape);\n+                codeWriter.closeBlock(\")\");\n+            } else {\n+                codeWriter.writeIndent().writeInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serialize(node, shape);\n+                codeWriter.write(\")\");\n+            }\n+        }\n+\n+        private boolean isEmptyStructure(Node node, Shape shape) {\n+            return !shape.isDocumentShape() && node.asObjectNode().map(ObjectNode::isEmpty).orElse(false);\n+        }\n+\n+        @Override\n+        public Void listShape(ListShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void setShape(SetShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void mapShape(MapShape shape) {\n+            shapeWithMembers(shape, ListUtils.of(shape.getKey(), shape.getValue()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void structureShape(StructureShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void unionShape(UnionShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        private List<MemberShape> sortMembers(Collection<MemberShape> members) {\n+            return members.stream()\n+                    .sorted(Comparator.comparing(MemberShape::getMemberName, String.CASE_INSENSITIVE_ORDER))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public Void serviceShape(ServiceShape shape) {\n+            serializeTraits(shape);\n+            codeWriter.openBlock(\"service $L {\", shape.getId().getName())\n+                    .write(\"version: $S,\", shape.getVersion());\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+            return null;\n+        }\n+\n+        @Override\n+        public Void resourceShape(ResourceShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyResource(shape)) {\n+                codeWriter.write(\"resource $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"resource $L {\", shape.getId().getName());\n+            if (!shape.getIdentifiers().isEmpty()) {\n+                codeWriter.openBlock(\"identifiers: {\");\n+                shape.getIdentifiers().entrySet().stream()\n+                        .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                        .forEach(entry -> codeWriter.write(\n+                                \"$L: $I,\", entry.getKey(), entry.getValue()));\n+                codeWriter.closeBlock(\"},\");\n+            }\n+\n+            shape.getPut().ifPresent(shapeId -> codeWriter.write(\"put: $I,\", shapeId));\n+            shape.getCreate().ifPresent(shapeId -> codeWriter.write(\"create: $I,\", shapeId));\n+            shape.getRead().ifPresent(shapeId -> codeWriter.write(\"read: $I,\", shapeId));\n+            shape.getUpdate().ifPresent(shapeId -> codeWriter.write(\"update: $I,\", shapeId));\n+            shape.getDelete().ifPresent(shapeId -> codeWriter.write(\"delete: $I,\", shapeId));\n+            shape.getList().ifPresent(shapeId -> codeWriter.write(\"list: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"collectionOperations\", shape.getCollectionOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyResource(ResourceShape shape) {\n+            return !(!shape.getIdentifiers().isEmpty()\n+                    || !shape.getOperations().isEmpty()\n+                    || !shape.getCollectionOperations().isEmpty()\n+                    || !shape.getResources().isEmpty()\n+                    || shape.getPut().isPresent()\n+                    || shape.getCreate().isPresent()\n+                    || shape.getRead().isPresent()\n+                    || shape.getUpdate().isPresent()\n+                    || shape.getDelete().isPresent()\n+                    || shape.getList().isPresent());\n+        }\n+\n+        @Override\n+        public Void operationShape(OperationShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyOperation(shape)) {\n+                codeWriter.write(\"operation $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"operation $L {\", shape.getId().getName());\n+            shape.getInput().ifPresent(shapeId -> codeWriter.write(\"input: $I,\", shapeId));\n+            shape.getOutput().ifPresent(shapeId -> codeWriter.write(\"output: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"errors\", shape.getErrors());\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyOperation(OperationShape shape) {\n+            return !(shape.getInput().isPresent() || shape.getOutput().isPresent() || !shape.getErrors().isEmpty());\n+        }\n+    }\n+\n+    /**\n+     * Serializes nodes into the Smithy IDL format.\n+     */\n+    private static final class NodeSerializer {\n+        private final SmithyCodeWriter codeWriter;\n+        private final Model model;\n+\n+        NodeSerializer(SmithyCodeWriter codeWriter, Model model) {\n+            this.codeWriter = codeWriter;\n+            this.model = model;\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * @param node The node to serialize.\n+         */\n+        private void serialize(Node node) {\n+            serialize(node, null);\n+        }\n+\n+        /**\n+         * Serialize a node into the Smithy IDL format.\n+         *\n+         * <p>This uses the given shape to influence serialization. For example, a string shape marked with the idRef\n+         * trait will be serialized as a shape id rather than a string.\n+         *\n+         * @param node The node to serialize.\n+         * @param shape The shape of the node.\n+         */\n+        private void serialize(Node node, Shape shape) {\n+            // ShapeIds are represented differently than strings, so if a shape looks like it's\n+            // representing a shapeId we need to serialize it without quotes.\n+            if (isShapeId(shape)) {\n+                serializeShapeId(node.expectStringNode());\n+                return;\n+            }\n+\n+            if (shape != null && shape.isMemberShape()) {\n+                shape = model.expectShape(shape.asMemberShape().get().getTarget());\n+            }\n+\n+            if (node.isStringNode()) {", "originalCommit": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyNTE1OA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384825158", "bodyText": "I need to co-traverse the model so I can identify IdRef shapes. If I were to use a node visitor I'd probably have to try to manage some global state to do that, which I think is worse than an if-else chain.", "author": "JordonPhillips", "createdAt": "2020-02-26T23:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxODAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxODU1OA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384818558", "bodyText": "You can simplify this using getAllOperations and checking if it's empty or not", "author": "mtdowling", "createdAt": "2020-02-26T22:57:13Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Predicate<String> metadataFilter;\n+    private final Predicate<Shape> shapeFilter;\n+    private final Predicate<Trait> traitFilter;\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        metadataFilter = builder.metadataFilter;\n+        shapeFilter = builder.shapeFilter.and(FunctionalUtils.not(Prelude::isPreludeShape));\n+        traitFilter = builder.traitFilter;\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>The output is a mapping\n+     *\n+     * <p>By default the paths are relative paths where each namespace is given its own file in the form\n+     * \"namespace.smithy\". This is configurable via the shape placer, which can place shapes into absolute\n+     * paths.\n+     *\n+     * <p>If the model contains no shapes, or all shapes are filtered out, then a single path \"metadata.smithy\"\n+     * will be present. This will contain only any defined metadata.\n+     *\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        List<Shape> shapes = model.shapes()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .filter(shapeFilter)\n+                .collect(Collectors.toList());\n+        if (shapes.isEmpty()) {\n+            return Collections.singletonMap(Paths.get(\"metadata.smithy\"), serializeHeader(model, null));\n+        }\n+        return shapes.stream()\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, traitFilter, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(fullModel, namespace) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(Model fullModel, String namespace) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(null, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .filter(entry -> metadataFilter.test(entry.getKey()))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        if (namespace != null) {\n+            codeWriter.write(\"namespace $L\", namespace)\n+                    .write(\"\")\n+                    // We want the extra blank line to separate the header and the model contents.\n+                    .trimBlankLines(-1);\n+        }\n+\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Sorts shapes into files based on their namespace, where each file is named {namespace}.smithy.\n+     */\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    private static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.UNION,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Predicate<String> metadataFilter = pair -> true;\n+        private Predicate<Shape> shapeFilter = shape -> true;\n+        private Predicate<Trait> traitFilter = trait -> true;\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Predicate that determines if a metadata is serialized.\n+         *\n+         * @param metadataFilter Predicate that accepts a metadata key.\n+         * @return Returns the builder.\n+         */\n+        public Builder metadataFilter(Predicate<String> metadataFilter) {\n+            this.metadataFilter = Objects.requireNonNull(metadataFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Predicate that determines if a shape and its traits are serialized.\n+         *\n+         * @param shapeFilter Predicate that accepts a shape.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapeFilter(Predicate<Shape> shapeFilter) {\n+            this.shapeFilter = Objects.requireNonNull(shapeFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets a predicate that can be used to filter trait values from\n+         * appearing in the serialized model.\n+         *\n+         * <p>Note that this does not filter out trait definitions. It only filters\n+         * out instances of traits from being serialized on shapes.\n+         *\n+         * @param traitFilter Predicate that filters out trait definitions.\n+         * @return Returns the builder.\n+         */\n+        public Builder traitFilter(Predicate<Trait> traitFilter) {\n+            this.traitFilter = traitFilter;\n+            return this;\n+        }\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>The returned paths may be absolute or relative.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.\n+         *\n+         * @param shapePlacer Function that accepts a shape and returns file path.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapePlacer(Function<Shape, Path> shapePlacer) {\n+            this.shapePlacer = Objects.requireNonNull(shapePlacer);\n+            return this;\n+        }\n+\n+        @Override\n+        public SmithyIdlModelSerializer build() {\n+            return new SmithyIdlModelSerializer(this);\n+        }\n+    }\n+\n+    /**\n+     * Serializes shapes in the IDL format.\n+     */\n+    private static final class ShapeSerializer extends ShapeVisitor.Default<Void> {\n+        private final SmithyCodeWriter codeWriter;\n+        private final NodeSerializer nodeSerializer;\n+        private final Predicate<Trait> traitFilter;\n+        private final Model model;\n+\n+        ShapeSerializer(\n+                SmithyCodeWriter codeWriter,\n+                NodeSerializer nodeSerializer,\n+                Predicate<Trait> traitFilter,\n+                Model model\n+        ) {\n+            this.codeWriter = codeWriter;\n+            this.nodeSerializer = nodeSerializer;\n+            this.traitFilter = traitFilter;\n+            this.model = model;\n+        }\n+\n+        @Override\n+        protected Void getDefault(Shape shape) {\n+            serializeTraits(shape);\n+            codeWriter.write(\"$L $L\", shape.getType(), shape.getId().getName()).write(\"\");\n+            return null;\n+        }\n+\n+        private void shapeWithMembers(Shape shape, List<MemberShape> members) {\n+            serializeTraits(shape);\n+            if (members.isEmpty()) {\n+                // If there are no members then we don't want to introduce an unnecessary newline by opening a block.\n+                codeWriter.write(\"$L $L {}\", shape.getType(), shape.getId().getName()).write(\"\");\n+                return;\n+            }\n+\n+            codeWriter.openBlock(\"$L $L {\", shape.getType(), shape.getId().getName());\n+            for (MemberShape member : members) {\n+                serializeTraits(member);\n+                codeWriter.write(\"$L: $I,\", member.getMemberName(), member.getTarget());\n+            }\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+        }\n+\n+        private void serializeTraits(Shape shape) {\n+            // The documentation trait always needs to be serialized first since it uses special syntax.\n+            shape.getTrait(DocumentationTrait.class).filter(traitFilter).ifPresent(this::serializeDocumentationTrait);\n+            shape.getAllTraits().values().stream()\n+                    .filter(trait -> !(trait instanceof DocumentationTrait))\n+                    .filter(traitFilter)\n+                    .sorted(Comparator.comparing(trait -> trait.toShapeId().toString(), String.CASE_INSENSITIVE_ORDER))\n+                    .forEach(this::serializeTrait);\n+        }\n+\n+        private void serializeDocumentationTrait(DocumentationTrait trait) {\n+            // The documentation trait has a special syntax, which we always want to use.\n+            codeWriter.setNewlinePrefix(\"/// \")\n+                    .write(trait.getValue().replace(\"$\", \"$$\"))\n+                    .setNewlinePrefix(\"\");\n+        }\n+\n+        private void serializeTrait(Trait trait) {\n+            Node node = trait.toNode();\n+            Shape shape = model.expectShape(trait.toShapeId());\n+\n+            if (trait instanceof BooleanTrait || isEmptyStructure(node, shape)) {\n+                // Traits that inherit from BooleanTrait specifically can omit a value.\n+                // Traits that are simply boolean shapes which don't implement BooleanTrait cannot.\n+                // Additionally, empty structure traits can omit a value.\n+                codeWriter.write(\"@$I\", trait.toShapeId());\n+            } else if (node.isObjectNode()) {\n+                codeWriter.writeIndent().openBlockInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serializeKeyValuePairs(node.expectObjectNode(), shape);\n+                codeWriter.closeBlock(\")\");\n+            } else {\n+                codeWriter.writeIndent().writeInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serialize(node, shape);\n+                codeWriter.write(\")\");\n+            }\n+        }\n+\n+        private boolean isEmptyStructure(Node node, Shape shape) {\n+            return !shape.isDocumentShape() && node.asObjectNode().map(ObjectNode::isEmpty).orElse(false);\n+        }\n+\n+        @Override\n+        public Void listShape(ListShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void setShape(SetShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void mapShape(MapShape shape) {\n+            shapeWithMembers(shape, ListUtils.of(shape.getKey(), shape.getValue()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void structureShape(StructureShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void unionShape(UnionShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        private List<MemberShape> sortMembers(Collection<MemberShape> members) {\n+            return members.stream()\n+                    .sorted(Comparator.comparing(MemberShape::getMemberName, String.CASE_INSENSITIVE_ORDER))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public Void serviceShape(ServiceShape shape) {\n+            serializeTraits(shape);\n+            codeWriter.openBlock(\"service $L {\", shape.getId().getName())\n+                    .write(\"version: $S,\", shape.getVersion());\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+            return null;\n+        }\n+\n+        @Override\n+        public Void resourceShape(ResourceShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyResource(shape)) {\n+                codeWriter.write(\"resource $L {}\", shape.getId().getName()).write(\"\");\n+                return null;\n+            }\n+\n+            codeWriter.openBlock(\"resource $L {\", shape.getId().getName());\n+            if (!shape.getIdentifiers().isEmpty()) {\n+                codeWriter.openBlock(\"identifiers: {\");\n+                shape.getIdentifiers().entrySet().stream()\n+                        .sorted(Map.Entry.comparingByKey(String.CASE_INSENSITIVE_ORDER))\n+                        .forEach(entry -> codeWriter.write(\n+                                \"$L: $I,\", entry.getKey(), entry.getValue()));\n+                codeWriter.closeBlock(\"},\");\n+            }\n+\n+            shape.getPut().ifPresent(shapeId -> codeWriter.write(\"put: $I,\", shapeId));\n+            shape.getCreate().ifPresent(shapeId -> codeWriter.write(\"create: $I,\", shapeId));\n+            shape.getRead().ifPresent(shapeId -> codeWriter.write(\"read: $I,\", shapeId));\n+            shape.getUpdate().ifPresent(shapeId -> codeWriter.write(\"update: $I,\", shapeId));\n+            shape.getDelete().ifPresent(shapeId -> codeWriter.write(\"delete: $I,\", shapeId));\n+            shape.getList().ifPresent(shapeId -> codeWriter.write(\"list: $I,\", shapeId));\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"collectionOperations\", shape.getCollectionOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+\n+            codeWriter.closeBlock(\"}\");\n+            codeWriter.write(\"\");\n+            return null;\n+        }\n+\n+        private boolean isEmptyResource(ResourceShape shape) {\n+            return !(!shape.getIdentifiers().isEmpty()\n+                    || !shape.getOperations().isEmpty()\n+                    || !shape.getCollectionOperations().isEmpty()\n+                    || !shape.getResources().isEmpty()\n+                    || shape.getPut().isPresent()", "originalCommit": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxOTA1NA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384819054", "bodyText": "nit: empty resources are fairly pointless... is this special casing for a fringe case worth it?", "author": "mtdowling", "createdAt": "2020-02-26T22:58:26Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Predicate<String> metadataFilter;\n+    private final Predicate<Shape> shapeFilter;\n+    private final Predicate<Trait> traitFilter;\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        metadataFilter = builder.metadataFilter;\n+        shapeFilter = builder.shapeFilter.and(FunctionalUtils.not(Prelude::isPreludeShape));\n+        traitFilter = builder.traitFilter;\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>The output is a mapping\n+     *\n+     * <p>By default the paths are relative paths where each namespace is given its own file in the form\n+     * \"namespace.smithy\". This is configurable via the shape placer, which can place shapes into absolute\n+     * paths.\n+     *\n+     * <p>If the model contains no shapes, or all shapes are filtered out, then a single path \"metadata.smithy\"\n+     * will be present. This will contain only any defined metadata.\n+     *\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        List<Shape> shapes = model.shapes()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .filter(shapeFilter)\n+                .collect(Collectors.toList());\n+        if (shapes.isEmpty()) {\n+            return Collections.singletonMap(Paths.get(\"metadata.smithy\"), serializeHeader(model, null));\n+        }\n+        return shapes.stream()\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, traitFilter, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(fullModel, namespace) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(Model fullModel, String namespace) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(null, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .filter(entry -> metadataFilter.test(entry.getKey()))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        if (namespace != null) {\n+            codeWriter.write(\"namespace $L\", namespace)\n+                    .write(\"\")\n+                    // We want the extra blank line to separate the header and the model contents.\n+                    .trimBlankLines(-1);\n+        }\n+\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Sorts shapes into files based on their namespace, where each file is named {namespace}.smithy.\n+     */\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    private static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.UNION,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Predicate<String> metadataFilter = pair -> true;\n+        private Predicate<Shape> shapeFilter = shape -> true;\n+        private Predicate<Trait> traitFilter = trait -> true;\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Predicate that determines if a metadata is serialized.\n+         *\n+         * @param metadataFilter Predicate that accepts a metadata key.\n+         * @return Returns the builder.\n+         */\n+        public Builder metadataFilter(Predicate<String> metadataFilter) {\n+            this.metadataFilter = Objects.requireNonNull(metadataFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Predicate that determines if a shape and its traits are serialized.\n+         *\n+         * @param shapeFilter Predicate that accepts a shape.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapeFilter(Predicate<Shape> shapeFilter) {\n+            this.shapeFilter = Objects.requireNonNull(shapeFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets a predicate that can be used to filter trait values from\n+         * appearing in the serialized model.\n+         *\n+         * <p>Note that this does not filter out trait definitions. It only filters\n+         * out instances of traits from being serialized on shapes.\n+         *\n+         * @param traitFilter Predicate that filters out trait definitions.\n+         * @return Returns the builder.\n+         */\n+        public Builder traitFilter(Predicate<Trait> traitFilter) {\n+            this.traitFilter = traitFilter;\n+            return this;\n+        }\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>The returned paths may be absolute or relative.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.\n+         *\n+         * @param shapePlacer Function that accepts a shape and returns file path.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapePlacer(Function<Shape, Path> shapePlacer) {\n+            this.shapePlacer = Objects.requireNonNull(shapePlacer);\n+            return this;\n+        }\n+\n+        @Override\n+        public SmithyIdlModelSerializer build() {\n+            return new SmithyIdlModelSerializer(this);\n+        }\n+    }\n+\n+    /**\n+     * Serializes shapes in the IDL format.\n+     */\n+    private static final class ShapeSerializer extends ShapeVisitor.Default<Void> {\n+        private final SmithyCodeWriter codeWriter;\n+        private final NodeSerializer nodeSerializer;\n+        private final Predicate<Trait> traitFilter;\n+        private final Model model;\n+\n+        ShapeSerializer(\n+                SmithyCodeWriter codeWriter,\n+                NodeSerializer nodeSerializer,\n+                Predicate<Trait> traitFilter,\n+                Model model\n+        ) {\n+            this.codeWriter = codeWriter;\n+            this.nodeSerializer = nodeSerializer;\n+            this.traitFilter = traitFilter;\n+            this.model = model;\n+        }\n+\n+        @Override\n+        protected Void getDefault(Shape shape) {\n+            serializeTraits(shape);\n+            codeWriter.write(\"$L $L\", shape.getType(), shape.getId().getName()).write(\"\");\n+            return null;\n+        }\n+\n+        private void shapeWithMembers(Shape shape, List<MemberShape> members) {\n+            serializeTraits(shape);\n+            if (members.isEmpty()) {\n+                // If there are no members then we don't want to introduce an unnecessary newline by opening a block.\n+                codeWriter.write(\"$L $L {}\", shape.getType(), shape.getId().getName()).write(\"\");\n+                return;\n+            }\n+\n+            codeWriter.openBlock(\"$L $L {\", shape.getType(), shape.getId().getName());\n+            for (MemberShape member : members) {\n+                serializeTraits(member);\n+                codeWriter.write(\"$L: $I,\", member.getMemberName(), member.getTarget());\n+            }\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+        }\n+\n+        private void serializeTraits(Shape shape) {\n+            // The documentation trait always needs to be serialized first since it uses special syntax.\n+            shape.getTrait(DocumentationTrait.class).filter(traitFilter).ifPresent(this::serializeDocumentationTrait);\n+            shape.getAllTraits().values().stream()\n+                    .filter(trait -> !(trait instanceof DocumentationTrait))\n+                    .filter(traitFilter)\n+                    .sorted(Comparator.comparing(trait -> trait.toShapeId().toString(), String.CASE_INSENSITIVE_ORDER))\n+                    .forEach(this::serializeTrait);\n+        }\n+\n+        private void serializeDocumentationTrait(DocumentationTrait trait) {\n+            // The documentation trait has a special syntax, which we always want to use.\n+            codeWriter.setNewlinePrefix(\"/// \")\n+                    .write(trait.getValue().replace(\"$\", \"$$\"))\n+                    .setNewlinePrefix(\"\");\n+        }\n+\n+        private void serializeTrait(Trait trait) {\n+            Node node = trait.toNode();\n+            Shape shape = model.expectShape(trait.toShapeId());\n+\n+            if (trait instanceof BooleanTrait || isEmptyStructure(node, shape)) {\n+                // Traits that inherit from BooleanTrait specifically can omit a value.\n+                // Traits that are simply boolean shapes which don't implement BooleanTrait cannot.\n+                // Additionally, empty structure traits can omit a value.\n+                codeWriter.write(\"@$I\", trait.toShapeId());\n+            } else if (node.isObjectNode()) {\n+                codeWriter.writeIndent().openBlockInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serializeKeyValuePairs(node.expectObjectNode(), shape);\n+                codeWriter.closeBlock(\")\");\n+            } else {\n+                codeWriter.writeIndent().writeInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serialize(node, shape);\n+                codeWriter.write(\")\");\n+            }\n+        }\n+\n+        private boolean isEmptyStructure(Node node, Shape shape) {\n+            return !shape.isDocumentShape() && node.asObjectNode().map(ObjectNode::isEmpty).orElse(false);\n+        }\n+\n+        @Override\n+        public Void listShape(ListShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void setShape(SetShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void mapShape(MapShape shape) {\n+            shapeWithMembers(shape, ListUtils.of(shape.getKey(), shape.getValue()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void structureShape(StructureShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void unionShape(UnionShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        private List<MemberShape> sortMembers(Collection<MemberShape> members) {\n+            return members.stream()\n+                    .sorted(Comparator.comparing(MemberShape::getMemberName, String.CASE_INSENSITIVE_ORDER))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        @Override\n+        public Void serviceShape(ServiceShape shape) {\n+            serializeTraits(shape);\n+            codeWriter.openBlock(\"service $L {\", shape.getId().getName())\n+                    .write(\"version: $S,\", shape.getVersion());\n+            codeWriter.writeOptionalIdList(\"operations\", shape.getOperations());\n+            codeWriter.writeOptionalIdList(\"resources\", shape.getResources());\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+            return null;\n+        }\n+\n+        @Override\n+        public Void resourceShape(ResourceShape shape) {\n+            serializeTraits(shape);\n+            if (isEmptyResource(shape)) {", "originalCommit": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyNjQ1Mw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384826453", "bodyText": "It's not much effort, and the output looks a bit nicer so eh? I'm +0 on keeping it", "author": "JordonPhillips", "createdAt": "2020-02-26T23:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxOTA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDIyOA==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384830228", "bodyText": "I say kill it. As long as we do this for structures, that's all I care about.", "author": "mtdowling", "createdAt": "2020-02-26T23:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxOTA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxOTI4OQ==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384819289", "bodyText": "Members are already stored in a TreeMap.", "author": "mtdowling", "createdAt": "2020-02-26T22:59:00Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/SmithyIdlModelSerializer.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.shapes;\n+\n+import java.io.Serializable;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.node.ArrayNode;\n+import software.amazon.smithy.model.node.BooleanNode;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.node.NumberNode;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.node.StringNode;\n+import software.amazon.smithy.model.traits.BooleanTrait;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.IdRefTrait;\n+import software.amazon.smithy.model.traits.Trait;\n+import software.amazon.smithy.model.traits.TraitDefinition;\n+import software.amazon.smithy.utils.CodeWriter;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.SmithyBuilder;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Serializes a {@link Model} into a set of Smithy IDL files.\n+ */\n+public final class SmithyIdlModelSerializer {\n+    private final Predicate<String> metadataFilter;\n+    private final Predicate<Shape> shapeFilter;\n+    private final Predicate<Trait> traitFilter;\n+    private final Function<Shape, Path> shapePlacer;\n+\n+    private SmithyIdlModelSerializer(Builder builder) {\n+        metadataFilter = builder.metadataFilter;\n+        shapeFilter = builder.shapeFilter.and(FunctionalUtils.not(Prelude::isPreludeShape));\n+        traitFilter = builder.traitFilter;\n+        shapePlacer = builder.shapePlacer;\n+    }\n+\n+    /**\n+     * Serializes a {@link Model} into a set of Smithy IDL files.\n+     *\n+     * <p>The output is a mapping\n+     *\n+     * <p>By default the paths are relative paths where each namespace is given its own file in the form\n+     * \"namespace.smithy\". This is configurable via the shape placer, which can place shapes into absolute\n+     * paths.\n+     *\n+     * <p>If the model contains no shapes, or all shapes are filtered out, then a single path \"metadata.smithy\"\n+     * will be present. This will contain only any defined metadata.\n+     *\n+     * @param model The model to serialize.\n+     * @return A map of (possibly relative) file paths to Smithy IDL strings.\n+     */\n+    public Map<Path, String> serialize(Model model) {\n+        List<Shape> shapes = model.shapes()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .filter(shapeFilter)\n+                .collect(Collectors.toList());\n+        if (shapes.isEmpty()) {\n+            return Collections.singletonMap(Paths.get(\"metadata.smithy\"), serializeHeader(model, null));\n+        }\n+        return shapes.stream()\n+                .collect(Collectors.groupingBy(shapePlacer)).entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, entry -> serialize(model, entry.getValue())));\n+    }\n+\n+    private String serialize(Model fullModel, Collection<Shape> shapes) {\n+        Set<String> namespaces = shapes.stream()\n+                .map(shape -> shape.getId().getNamespace())\n+                .collect(Collectors.toSet());\n+        if (namespaces.size() != 1) {\n+            throw new RuntimeException(\"All shapes in a single file must share a namespace.\");\n+        }\n+\n+        // There should only be one namespace at this point, so grab it.\n+        String namespace = namespaces.iterator().next();\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(namespace, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        ShapeSerializer shapeSerializer = new ShapeSerializer(codeWriter, nodeSerializer, traitFilter, fullModel);\n+        shapes.stream()\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                .sorted(new ShapeComparator())\n+                .forEach(shape -> shape.accept(shapeSerializer));\n+\n+        return serializeHeader(fullModel, namespace) + codeWriter.toString();\n+    }\n+\n+    private String serializeHeader(Model fullModel, String namespace) {\n+        SmithyCodeWriter codeWriter = new SmithyCodeWriter(null, fullModel);\n+        NodeSerializer nodeSerializer = new NodeSerializer(codeWriter, fullModel);\n+\n+        codeWriter.write(\"$$version: \\\"$L\\\"\", Model.MODEL_VERSION).write(\"\");\n+\n+        // Write the full metadata into every output. When loaded back together the conflicts will be ignored,\n+        // but if they're separated out then each file will still have all the context.\n+        fullModel.getMetadata().entrySet().stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .filter(entry -> metadataFilter.test(entry.getKey()))\n+                .forEach(entry -> {\n+                    codeWriter.trimTrailingSpaces(false)\n+                            .writeInline(\"metadata $M = \", entry.getKey())\n+                            .trimTrailingSpaces();\n+                    nodeSerializer.serialize(entry.getValue());\n+                    codeWriter.write(\"\");\n+                });\n+\n+        if (!fullModel.getMetadata().isEmpty()) {\n+            codeWriter.write(\"\");\n+        }\n+\n+        if (namespace != null) {\n+            codeWriter.write(\"namespace $L\", namespace)\n+                    .write(\"\")\n+                    // We want the extra blank line to separate the header and the model contents.\n+                    .trimBlankLines(-1);\n+        }\n+\n+        return codeWriter.toString();\n+    }\n+\n+    /**\n+     * @return Returns a builder used to create a {@link SmithyIdlModelSerializer}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Sorts shapes into files based on their namespace, where each file is named {namespace}.smithy.\n+     */\n+    public static Path placeShapesByNamespace(Shape shape) {\n+        return Paths.get(shape.getId().getNamespace() + \".smithy\");\n+    }\n+\n+    /**\n+     * Comparator used to sort shapes.\n+     */\n+    private static final class ShapeComparator implements Comparator<Shape>, Serializable {\n+        private static final List<ShapeType> PRIORITY = ListUtils.of(\n+                ShapeType.SERVICE,\n+                ShapeType.RESOURCE,\n+                ShapeType.OPERATION,\n+                ShapeType.STRUCTURE,\n+                ShapeType.UNION,\n+                ShapeType.LIST,\n+                ShapeType.SET,\n+                ShapeType.MAP\n+        );\n+\n+        @Override\n+        public int compare(Shape s1, Shape s2) {\n+            // Traits go first\n+            if (s1.hasTrait(TraitDefinition.class) || s2.hasTrait(TraitDefinition.class)) {\n+                if (!s1.hasTrait(TraitDefinition.class)) {\n+                    return 1;\n+                }\n+                if (!s2.hasTrait(TraitDefinition.class)) {\n+                    return -1;\n+                }\n+                // The other sorting rules don't matter for traits.\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If the shapes are the same type, just compare their shape ids.\n+            if (s1.getType().equals(s2.getType())) {\n+                return compareCaseInsensitive(s1, s2);\n+            }\n+            // If one shape is prioritized, compare by priority.\n+            if (PRIORITY.contains(s1.getType()) || PRIORITY.contains(s2.getType())) {\n+                // If only one shape is prioritized, that shape is \"greater\".\n+                if (!PRIORITY.contains(s1.getType())) {\n+                    return 1;\n+                }\n+                if (!PRIORITY.contains(s2.getType())) {\n+                    return -1;\n+                }\n+                return PRIORITY.indexOf(s1.getType()) - PRIORITY.indexOf(s2.getType());\n+            }\n+            return compareCaseInsensitive(s1, s2);\n+        }\n+\n+        /**\n+         * Compare two shapes by id case-insensitively.\n+         */\n+        private int compareCaseInsensitive(Shape s1, Shape s2) {\n+            return s1.toShapeId().toString().toLowerCase().compareTo(s2.toShapeId().toString().toLowerCase());\n+        }\n+    }\n+\n+    /**\n+     * Builder used to create {@link SmithyIdlModelSerializer}.\n+     */\n+    public static final class Builder implements SmithyBuilder<SmithyIdlModelSerializer> {\n+        private Predicate<String> metadataFilter = pair -> true;\n+        private Predicate<Shape> shapeFilter = shape -> true;\n+        private Predicate<Trait> traitFilter = trait -> true;\n+        private Function<Shape, Path> shapePlacer = SmithyIdlModelSerializer::placeShapesByNamespace;\n+\n+        public Builder() {}\n+\n+        /**\n+         * Predicate that determines if a metadata is serialized.\n+         *\n+         * @param metadataFilter Predicate that accepts a metadata key.\n+         * @return Returns the builder.\n+         */\n+        public Builder metadataFilter(Predicate<String> metadataFilter) {\n+            this.metadataFilter = Objects.requireNonNull(metadataFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Predicate that determines if a shape and its traits are serialized.\n+         *\n+         * @param shapeFilter Predicate that accepts a shape.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapeFilter(Predicate<Shape> shapeFilter) {\n+            this.shapeFilter = Objects.requireNonNull(shapeFilter);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets a predicate that can be used to filter trait values from\n+         * appearing in the serialized model.\n+         *\n+         * <p>Note that this does not filter out trait definitions. It only filters\n+         * out instances of traits from being serialized on shapes.\n+         *\n+         * @param traitFilter Predicate that filters out trait definitions.\n+         * @return Returns the builder.\n+         */\n+        public Builder traitFilter(Predicate<Trait> traitFilter) {\n+            this.traitFilter = traitFilter;\n+            return this;\n+        }\n+\n+        /**\n+         * Function that determines what output file a shape should go in.\n+         *\n+         * <p>The returned paths may be absolute or relative.\n+         *\n+         * <p>NOTE: the Smithy IDL only supports one namespace per file.\n+         *\n+         * @param shapePlacer Function that accepts a shape and returns file path.\n+         * @return Returns the builder.\n+         */\n+        public Builder shapePlacer(Function<Shape, Path> shapePlacer) {\n+            this.shapePlacer = Objects.requireNonNull(shapePlacer);\n+            return this;\n+        }\n+\n+        @Override\n+        public SmithyIdlModelSerializer build() {\n+            return new SmithyIdlModelSerializer(this);\n+        }\n+    }\n+\n+    /**\n+     * Serializes shapes in the IDL format.\n+     */\n+    private static final class ShapeSerializer extends ShapeVisitor.Default<Void> {\n+        private final SmithyCodeWriter codeWriter;\n+        private final NodeSerializer nodeSerializer;\n+        private final Predicate<Trait> traitFilter;\n+        private final Model model;\n+\n+        ShapeSerializer(\n+                SmithyCodeWriter codeWriter,\n+                NodeSerializer nodeSerializer,\n+                Predicate<Trait> traitFilter,\n+                Model model\n+        ) {\n+            this.codeWriter = codeWriter;\n+            this.nodeSerializer = nodeSerializer;\n+            this.traitFilter = traitFilter;\n+            this.model = model;\n+        }\n+\n+        @Override\n+        protected Void getDefault(Shape shape) {\n+            serializeTraits(shape);\n+            codeWriter.write(\"$L $L\", shape.getType(), shape.getId().getName()).write(\"\");\n+            return null;\n+        }\n+\n+        private void shapeWithMembers(Shape shape, List<MemberShape> members) {\n+            serializeTraits(shape);\n+            if (members.isEmpty()) {\n+                // If there are no members then we don't want to introduce an unnecessary newline by opening a block.\n+                codeWriter.write(\"$L $L {}\", shape.getType(), shape.getId().getName()).write(\"\");\n+                return;\n+            }\n+\n+            codeWriter.openBlock(\"$L $L {\", shape.getType(), shape.getId().getName());\n+            for (MemberShape member : members) {\n+                serializeTraits(member);\n+                codeWriter.write(\"$L: $I,\", member.getMemberName(), member.getTarget());\n+            }\n+            codeWriter.closeBlock(\"}\").write(\"\");\n+        }\n+\n+        private void serializeTraits(Shape shape) {\n+            // The documentation trait always needs to be serialized first since it uses special syntax.\n+            shape.getTrait(DocumentationTrait.class).filter(traitFilter).ifPresent(this::serializeDocumentationTrait);\n+            shape.getAllTraits().values().stream()\n+                    .filter(trait -> !(trait instanceof DocumentationTrait))\n+                    .filter(traitFilter)\n+                    .sorted(Comparator.comparing(trait -> trait.toShapeId().toString(), String.CASE_INSENSITIVE_ORDER))\n+                    .forEach(this::serializeTrait);\n+        }\n+\n+        private void serializeDocumentationTrait(DocumentationTrait trait) {\n+            // The documentation trait has a special syntax, which we always want to use.\n+            codeWriter.setNewlinePrefix(\"/// \")\n+                    .write(trait.getValue().replace(\"$\", \"$$\"))\n+                    .setNewlinePrefix(\"\");\n+        }\n+\n+        private void serializeTrait(Trait trait) {\n+            Node node = trait.toNode();\n+            Shape shape = model.expectShape(trait.toShapeId());\n+\n+            if (trait instanceof BooleanTrait || isEmptyStructure(node, shape)) {\n+                // Traits that inherit from BooleanTrait specifically can omit a value.\n+                // Traits that are simply boolean shapes which don't implement BooleanTrait cannot.\n+                // Additionally, empty structure traits can omit a value.\n+                codeWriter.write(\"@$I\", trait.toShapeId());\n+            } else if (node.isObjectNode()) {\n+                codeWriter.writeIndent().openBlockInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serializeKeyValuePairs(node.expectObjectNode(), shape);\n+                codeWriter.closeBlock(\")\");\n+            } else {\n+                codeWriter.writeIndent().writeInline(\"@$I(\", trait.toShapeId());\n+                nodeSerializer.serialize(node, shape);\n+                codeWriter.write(\")\");\n+            }\n+        }\n+\n+        private boolean isEmptyStructure(Node node, Shape shape) {\n+            return !shape.isDocumentShape() && node.asObjectNode().map(ObjectNode::isEmpty).orElse(false);\n+        }\n+\n+        @Override\n+        public Void listShape(ListShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void setShape(SetShape shape) {\n+            shapeWithMembers(shape, Collections.singletonList(shape.getMember()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void mapShape(MapShape shape) {\n+            shapeWithMembers(shape, ListUtils.of(shape.getKey(), shape.getValue()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void structureShape(StructureShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        @Override\n+        public Void unionShape(UnionShape shape) {\n+            shapeWithMembers(shape, sortMembers(shape.getAllMembers().values()));\n+            return null;\n+        }\n+\n+        private List<MemberShape> sortMembers(Collection<MemberShape> members) {", "originalCommit": "b57193f74cf3dad4ad982569af0d4e1b26e954be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyOTA3MQ==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384829071", "bodyText": "Yes, but since their compareTo is case-sensitive then the order in the map will be too. I guess all this case-insensitivity doesn't really matter, but I personally hate trying to find something in a case-sensitive list.", "author": "JordonPhillips", "createdAt": "2020-02-26T23:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxOTI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMDEzMQ==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384830131", "bodyText": "Case sensitivity is preferred IMO, and it would simplify some of this code. I'm not sure how an insensitive ordering makes things easier to find.", "author": "mtdowling", "createdAt": "2020-02-26T23:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxOTI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzMTc3Nw==", "url": "https://github.com/awslabs/smithy/pull/284#discussion_r384831777", "bodyText": "It's not as big a deal for members, but it's a pretty hefty downside for shapes in some cases.", "author": "JordonPhillips", "createdAt": "2020-02-26T23:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxOTI4OQ=="}], "type": "inlineReview"}, {"oid": "8ea2e2f6476a052f9e8d9af455eaf36ba24576fb", "url": "https://github.com/awslabs/smithy/commit/8ea2e2f6476a052f9e8d9af455eaf36ba24576fb", "message": "Simplify IDL serializer\n\nThis simplifies various bits of the internals, for instance by\ndiscarding much manual tinkering of sorting.", "committedDate": "2020-02-27T00:02:42Z", "type": "commit"}, {"oid": "92a4eaa1a1cb59e08b17059e32e5a659715ef95a", "url": "https://github.com/awslabs/smithy/commit/92a4eaa1a1cb59e08b17059e32e5a659715ef95a", "message": "Add a base path to the idl serializer", "committedDate": "2020-02-27T00:32:12Z", "type": "commit"}, {"oid": "1811d0a36f7add497a15d0be73836a7436057a33", "url": "https://github.com/awslabs/smithy/commit/1811d0a36f7add497a15d0be73836a7436057a33", "message": "Compare ShapeId's case-insensitively\n\nThis updates the `compareTo` on shapeIds to be case-insensitve by\ndefault, with a case-sensitive tie-breaker. Though technically that\nmeans we could be comparing a given shape twice, practically the\nlikelihood is low since ShapeId's in a model must be\ncase-insensitively unique.", "committedDate": "2020-02-27T01:23:42Z", "type": "commit"}]}