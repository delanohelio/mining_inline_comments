{"pr_number": 621, "pr_title": "Add smithy-jmespath for parsing JMESPath", "pr_createdAt": "2020-10-30T22:20:40Z", "pr_url": "https://github.com/awslabs/smithy/pull/621", "timeline": [{"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "url": "https://github.com/awslabs/smithy/commit/05b0728331d653844be567dbf3fcc9f07d79a8ba", "message": "Add smithy-jmespath for parsing JMESPath\n\nWe will be using JMESPath in things like waiters, so we need a JMESPath\nparser that has no dependencies, exposes a rich AST that can be used in\ncode generation, and performs static analysis of expressions.", "committedDate": "2020-10-31T05:35:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0MTA0Nw==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516141047", "bodyText": "Can you add docs here and/or in the expression classes showing an example of the expression and possibly a link to the spec? The naming and layout here isn't 1-1 with the spec so it's a bit difficult to cross-reference. There are some small examples in the parser but people working with the AST aren't gonna be looking there.", "author": "JordonPhillips", "createdAt": "2020-11-02T17:30:45Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ExpressionVisitor.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+/**\n+ * Visits each type of AST node.\n+ *\n+ * @param <T> Value returned from the visitor.\n+ */\n+public interface ExpressionVisitor<T> {", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1MDMxNQ==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516150315", "bodyText": "This needs docs", "author": "JordonPhillips", "createdAt": "2020-11-02T17:46:04Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/FunctionDefinition.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+\n+final class FunctionDefinition {", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1NjE2MQ==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516156161", "bodyText": "This is unused", "author": "JordonPhillips", "createdAt": "2020-11-02T17:55:56Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/LinterResult.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LinterResult {", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMzOTA5OA==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516339098", "bodyText": "It's returned from JmespathExpression#lint", "author": "mtdowling", "createdAt": "2020-11-02T23:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1NjE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2NzU0Mw==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516267543", "bodyText": "There is a difference between a sub expression and a pipe expression. I'm not seeing how this materializes that in the AST", "author": "JordonPhillips", "createdAt": "2020-11-02T21:34:50Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/Parser.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+/**\n+ * A top-down operator precedence parser (aka Pratt parser) for JMESPath.\n+ */\n+final class Parser {\n+\n+    /** The maximum binding power for a token that can stop a projection. */\n+    private static final int PROJECTION_STOP = 10;\n+\n+    /** Tokens that can start an expression. */\n+    private static final TokenType[] NUD_TOKENS = {\n+            TokenType.CURRENT,\n+            TokenType.IDENTIFIER,\n+            TokenType.LITERAL,\n+            TokenType.STAR,\n+            TokenType.LBRACE,\n+            TokenType.LBRACKET,\n+            TokenType.FLATTEN,\n+            TokenType.EXPREF,\n+            TokenType.NOT,\n+            TokenType.FILTER,\n+            TokenType.LPAREN\n+    };\n+\n+    /** Tokens that can follow led tokens. */\n+    private static final TokenType[] LED_TOKENS = {\n+            TokenType.DOT,\n+            TokenType.LBRACKET,\n+            TokenType.OR,\n+            TokenType.AND,\n+            TokenType.PIPE,\n+            TokenType.LPAREN,\n+            TokenType.FLATTEN,\n+            TokenType.FILTER,\n+            TokenType.EQUAL,\n+            TokenType.NOT_EQUAL,\n+            TokenType.GREATER_THAN,\n+            TokenType.GREATER_THAN_EQUAL,\n+            TokenType.LESS_THAN,\n+            TokenType.LESS_THAN_EQUAL\n+    };\n+\n+    private final String expression;\n+    private final TokenIterator iterator;\n+\n+    private Parser(String expression) {\n+        this.expression = expression;\n+        iterator = Lexer.tokenize(expression);\n+    }\n+\n+    static JmespathExpression parse(String expression) {\n+        Parser parser = new Parser(expression);\n+        JmespathExpression result = parser.expression(0);\n+        parser.iterator.expect(TokenType.EOF);\n+        return result;\n+    }\n+\n+    private JmespathExpression expression(int rbp) {\n+        JmespathExpression left = nud();\n+        while (iterator.hasNext() && rbp < iterator.peek().type.lbp) {\n+            left = led(left);\n+        }\n+        return left;\n+    }\n+\n+    private JmespathExpression nud() {\n+        Token token = iterator.expect(NUD_TOKENS);\n+        switch (token.type) {\n+            case CURRENT: // Example: @\n+                return new CurrentExpression(token.line, token.column);\n+            case IDENTIFIER: // Example: foo\n+                // For example, \"foo(\" starts a function expression.\n+                if (iterator.peek().type == TokenType.LPAREN) {\n+                    iterator.expect(TokenType.LPAREN);\n+                    List<JmespathExpression> arguments = parseList(TokenType.RPAREN);\n+                    return new FunctionExpression(token.value.asStringValue(), arguments, token.line, token.column);\n+                } else {\n+                    return new FieldExpression(token.value.asStringValue(), token.line, token.column);\n+                }\n+            case STAR: // Example: *\n+                return parseWildcardObject(new CurrentExpression(token.line, token.column));\n+            case LITERAL: // Example: `true`\n+                return new LiteralExpression(token.value.getValue(), token.line, token.column);\n+            case LBRACKET: // Example: [1]\n+                return parseNudLbracket();\n+            case LBRACE:  // Example: {foo: bar}\n+                return parseNudLbrace();\n+            case FLATTEN: // Example: [].bar\n+                return parseFlatten(new CurrentExpression(token.line, token.column));\n+            case EXPREF:  // Example: sort_by(@, &foo)\n+                JmespathExpression expressionRef = expression(token.type.lbp);\n+                return new ExpressionReferenceExpression(expressionRef, token.line, token.column);\n+            case NOT: // Example: !foo\n+                JmespathExpression notNode = expression(token.type.lbp);\n+                return new NotExpression(notNode, token.line, token.column);\n+            case FILTER: // Example: [?foo == bar]\n+                return parseFilter(new CurrentExpression(token.line, token.column));\n+            case LPAREN: // Example (foo)\n+                JmespathExpression insideParens = expression(0);\n+                iterator.expect(TokenType.RPAREN);\n+                return insideParens;\n+            default:\n+                throw iterator.syntax(\"Invalid nud token: \" + token);\n+        }\n+    }\n+\n+    private JmespathExpression led(JmespathExpression left) {\n+        Token token = iterator.expect(LED_TOKENS);\n+\n+        switch (token.type) {\n+            case DOT:\n+                // For example, \"foo.bar\"\n+                if (iterator.peek().type == TokenType.STAR) {\n+                    // \"Example: foo.*\". This is mostly an optimization of the\n+                    // generated AST to not need a subexpression to contain the\n+                    // projection.\n+                    iterator.expect(TokenType.STAR); // skip the \"*\".\n+                    return parseWildcardObject(left);\n+                } else {\n+                    // \"foo.*\", \"foo.bar\", \"foo.[bar]\", \"foo.length(@)\", etc.\n+                    JmespathExpression dotRhs = parseDotRhs(TokenType.DOT.lbp);\n+                    return new Subexpression(left, dotRhs, token.line, token.column);\n+                }\n+            case FLATTEN: // Example: a[].b\n+                return parseFlatten(left);\n+            case OR: // Example: a || b\n+                return new OrExpression(left, expression(token.type.lbp), token.line, token.column);\n+            case AND: // Example: a && b\n+                return new AndExpression(left, expression(token.type.lbp), token.line, token.column);\n+            case PIPE: // Example: a | b\n+                return new Subexpression(left, expression(token.type.lbp), token.line, token.column);", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMzODEwNA==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516338104", "bodyText": "This difference is intentionally omitted. The AST is not intended to be a parse tree, so it does take liberties to simplify the representation of an expression.", "author": "mtdowling", "createdAt": "2020-11-02T23:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2NzU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzkwMA==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516273900", "bodyText": "oh no", "author": "JordonPhillips", "createdAt": "2020-11-02T21:48:11Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/TypeChecker.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import static software.amazon.smithy.jmespath.FunctionDefinition.isType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.listOfType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.oneOf;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ANY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ARRAY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.BOOLEAN;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.EXPREF;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NULL;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NUMBER;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.OBJECT;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.STRING;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+final class TypeChecker implements ExpressionVisitor<LiteralExpression> {\n+\n+    private static final Map<String, FunctionDefinition> FUNCTIONS = new HashMap<>();\n+\n+    static {\n+        FunctionDefinition.ArgValidator isAny = isType(RuntimeType.ANY);\n+        FunctionDefinition.ArgValidator isString = isType(RuntimeType.STRING);\n+        FunctionDefinition.ArgValidator isNumber = isType(RuntimeType.NUMBER);\n+        FunctionDefinition.ArgValidator isArray = isType(RuntimeType.ARRAY);\n+\n+        FUNCTIONS.put(\"abs\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"avg\", new FunctionDefinition(NUMBER, listOfType(RuntimeType.NUMBER)));\n+        FUNCTIONS.put(\"contains\", new FunctionDefinition(\n+                BOOLEAN, oneOf(RuntimeType.ARRAY, RuntimeType.STRING), isAny));\n+        FUNCTIONS.put(\"ceil\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"ends_with\", new FunctionDefinition(NUMBER, isString, isString));\n+        FUNCTIONS.put(\"floor\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"join\", new FunctionDefinition(STRING, isString, listOfType(RuntimeType.STRING)));\n+        FUNCTIONS.put(\"keys\", new FunctionDefinition(ARRAY, isType(RuntimeType.OBJECT)));\n+        FUNCTIONS.put(\"length\", new FunctionDefinition(\n+                NUMBER, oneOf(RuntimeType.STRING, RuntimeType.ARRAY, RuntimeType.OBJECT)));\n+        // TODO: Support expression reference return type validation?\n+        FUNCTIONS.put(\"map\", new FunctionDefinition(ARRAY, isType(RuntimeType.EXPRESSION_REFERENCE), isArray));\n+        // TODO: support array<X|Y>\n+        FUNCTIONS.put(\"max\", new FunctionDefinition(NUMBER, isArray));\n+        FUNCTIONS.put(\"max_by\", new FunctionDefinition(NUMBER, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"merge\", new FunctionDefinition(OBJECT, Collections.emptyList(), isType(RuntimeType.OBJECT)));\n+        FUNCTIONS.put(\"min\", new FunctionDefinition(NUMBER, isArray));\n+        FUNCTIONS.put(\"min_by\", new FunctionDefinition(NUMBER, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"not_null\", new FunctionDefinition(ANY, Collections.singletonList(isAny), isAny));\n+        FUNCTIONS.put(\"reverse\", new FunctionDefinition(ARRAY, oneOf(RuntimeType.ARRAY, RuntimeType.STRING)));\n+        FUNCTIONS.put(\"sort\", new FunctionDefinition(ARRAY, isArray));\n+        FUNCTIONS.put(\"sort_by\", new FunctionDefinition(ARRAY, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"starts_with\", new FunctionDefinition(BOOLEAN, isString, isString));\n+        FUNCTIONS.put(\"sum\", new FunctionDefinition(NUMBER, listOfType(RuntimeType.NUMBER)));\n+        FUNCTIONS.put(\"to_array\", new FunctionDefinition(ARRAY, isAny));\n+        FUNCTIONS.put(\"to_string\", new FunctionDefinition(STRING, isAny));\n+        FUNCTIONS.put(\"to_number\", new FunctionDefinition(NUMBER, isAny));\n+        FUNCTIONS.put(\"type\", new FunctionDefinition(STRING, isAny));\n+        FUNCTIONS.put(\"values\", new FunctionDefinition(ARRAY, isType(RuntimeType.OBJECT)));\n+    }\n+\n+    private final LiteralExpression current;\n+    private final Set<ExpressionProblem> problems;\n+    private LiteralExpression knownFunctionType = ANY;\n+\n+    TypeChecker(LiteralExpression current, Set<ExpressionProblem> problems) {\n+        this.current = current;\n+        this.problems = problems;\n+    }\n+\n+    @Override\n+    public LiteralExpression visitComparison(ComparisonExpression expression) {\n+        LiteralExpression left = expression.getLeft().accept(this);\n+        LiteralExpression right = expression.getRight().accept(this);\n+\n+        // Different types always cause a comparison to not match.\n+        if (left.getType() != right.getType()) {\n+            return BOOLEAN;\n+        }\n+\n+        // I'm so sorry for the following code.", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjMxNA==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516352314", "bodyText": "Any reason not to break this out in to functions per type? None of the cases on the left.getType() switch have non-terminal states.", "author": "kstich", "createdAt": "2020-11-03T00:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ2OTMyOA==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516469328", "bodyText": "Refactored", "author": "mtdowling", "createdAt": "2020-11-03T07:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyMjg1OA==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516222858", "bodyText": "nit: two spaces after enum", "author": "kstich", "createdAt": "2020-11-02T20:02:39Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/ComparatorType.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+/**\n+ * A comparator in a comparison expression.\n+ */\n+public enum  ComparatorType {", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyOTI3MQ==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516229271", "bodyText": "Should the equals check and hashCode generation consider the position? This looks like it would apply to everything that extends JmespathExpression.", "author": "kstich", "createdAt": "2020-11-02T20:15:55Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/BinaryExpression.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.Objects;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+\n+/**\n+ * Abstract class representing expressions that have a left and right side.\n+ */\n+public abstract class BinaryExpression extends JmespathExpression {\n+\n+    private final JmespathExpression left;\n+    private final JmespathExpression right;\n+\n+    public BinaryExpression(JmespathExpression left, JmespathExpression right, int line, int column) {\n+        super(line, column);\n+        this.left = left;\n+        this.right = right;\n+    }\n+\n+    /**\n+     * Gets the left side of the expression.\n+     *\n+     * @return Returns the expression on the left.\n+     */\n+    public final JmespathExpression getLeft() {\n+        return left;\n+    }\n+\n+    /**\n+     * Gets the right side of the expression.\n+     *\n+     * @return Returns the expression on the right.\n+     */\n+    public final JmespathExpression getRight() {\n+        return right;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NjU2Ng==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516446566", "bodyText": "No, I intentionally left that out since the AST is not a parse tree, but rather more abstract.", "author": "mtdowling", "createdAt": "2020-11-03T06:21:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyOTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIzMjA5Ng==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516232096", "bodyText": "Missing a class comment.", "author": "kstich", "createdAt": "2020-11-02T20:21:24Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/FilterProjectionExpression.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.Objects;\n+import software.amazon.smithy.jmespath.ExpressionVisitor;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+\n+public final class FilterProjectionExpression extends JmespathExpression {", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2OTMwNw==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516269307", "bodyText": "Should these be expect for alignment with the methods on the Node implementations that throw?", "author": "kstich", "createdAt": "2020-11-02T21:38:38Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/LiteralExpression.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import software.amazon.smithy.jmespath.ExpressionVisitor;\n+import software.amazon.smithy.jmespath.JmespathException;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+import software.amazon.smithy.jmespath.RuntimeType;\n+\n+/**\n+ * Represents a literal value.\n+ */\n+public final class LiteralExpression extends JmespathExpression {\n+\n+    /** Sentinel value to represent ANY. */\n+    public static final LiteralExpression ANY = new LiteralExpression(new Object());\n+\n+    /** Sentinel value to represent any ARRAY. */\n+    public static final LiteralExpression ARRAY = new LiteralExpression(new ArrayList<>());\n+\n+    /** Sentinel value to represent any OBJECT. */\n+    public static final LiteralExpression OBJECT = new LiteralExpression(new HashMap<>());\n+\n+    /** Sentinel value to represent any BOOLEAN. */\n+    public static final LiteralExpression BOOLEAN = new LiteralExpression(false);\n+\n+    /** Sentinel value to represent any STRING. */\n+    public static final LiteralExpression STRING = new LiteralExpression(\"\");\n+\n+    /** Sentinel value to represent any NULL. */\n+    public static final LiteralExpression NUMBER = new LiteralExpression(0);\n+\n+    /** Sentinel value to represent an expression reference. */\n+    public static final LiteralExpression EXPREF = new LiteralExpression((Function<Object, Void>) o -> null);\n+\n+    /** Sentinel value to represent null. */\n+    public static final LiteralExpression NULL = new LiteralExpression(null);\n+\n+    private final Object value;\n+\n+    public LiteralExpression(Object value) {\n+        this(value, 1, 1);\n+    }\n+\n+    public LiteralExpression(Object value, int line, int column) {\n+        super(line, column);\n+\n+        // Unwrapped any wrapping that would mess up type checking.\n+        if (value instanceof LiteralExpression) {\n+            this.value = ((LiteralExpression) value).getValue();\n+        } else {\n+            this.value = value;\n+        }\n+    }\n+\n+    /**\n+     * Creates a LiteralExpression from {@code value}, unwrapping it if necessary.\n+     *\n+     * @param value Value to create the expression from.\n+     * @return Returns the LiteralExpression of the given {@code value}.\n+     */\n+    public static LiteralExpression from(Object value) {\n+        if (value instanceof LiteralExpression) {\n+            return (LiteralExpression) value;\n+        } else {\n+            return new LiteralExpression(value);\n+        }\n+    }\n+\n+    @Override\n+    public <T> T accept(ExpressionVisitor<T> visitor) {\n+        return visitor.visitLiteral(this);\n+    }\n+\n+    /**\n+     * Gets the nullable value contained in the literal value.\n+     *\n+     * @return Returns the contained value.\n+     */\n+    public Object getValue() {\n+        return value;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        } else if (!(o instanceof LiteralExpression)) {\n+            return false;\n+        } else {\n+            return Objects.equals(value, ((LiteralExpression) o).value);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"LiteralExpression{value=\" + value + '}';\n+    }\n+\n+    /**\n+     * Gets the type of the value.\n+     *\n+     * @return Returns the literal expression's runtime type.\n+     */\n+    public RuntimeType getType() {\n+        if (isArrayValue()) {\n+            return RuntimeType.ARRAY;\n+        } else if (isObjectValue()) {\n+            return RuntimeType.OBJECT;\n+        } else if (isStringValue()) {\n+            return RuntimeType.STRING;\n+        } else if (isBooleanValue()) {\n+            return RuntimeType.BOOLEAN;\n+        } else if (isNumberValue()) {\n+            return RuntimeType.NUMBER;\n+        } else if (isNullValue()) {\n+            return RuntimeType.NULL;\n+        } else if (this == EXPREF) {\n+            return RuntimeType.EXPRESSION_REFERENCE;\n+        } else {\n+            return RuntimeType.ANY;\n+        }\n+    }\n+\n+    /**\n+     * Expects the value to be an object and gets a field by\n+     * name. If the field does not exist, then a\n+     * {@link LiteralExpression} with a null value is returned.\n+     *\n+     * @param name Field to get from the expected object.\n+     * @return Returns the object field value.\n+     */\n+    public LiteralExpression getObjectField(String name) {\n+        Map<String, Object> values = asObjectValue();\n+        return values.containsKey(name)\n+               ? new LiteralExpression(values.get(name))\n+               : new LiteralExpression(null);\n+    }\n+\n+    /**\n+     * Expects the value to be an object and checks if it contains\n+     * a field by name.\n+     *\n+     * @param name Field to get from the expected object.\n+     * @return Returns true if the object contains the given key.\n+     */\n+    public boolean hasObjectField(String name) {\n+        return asObjectValue().containsKey(name);\n+    }\n+\n+    /**\n+     * Expects the value to be an array and gets the value at the given\n+     * index. If the index is negative, it is computed to the array\n+     * length minus the index. If the computed index does not exist,\n+     * a {@link LiteralExpression} with a null value is returned.\n+     *\n+     * @param index Index to get from the array.\n+     * @return Returns the array value.\n+     */\n+    public LiteralExpression getArrayIndex(int index) {\n+        List<Object> values = asArrayValue();\n+\n+        if (index < 0) {\n+            index = values.size() + index;\n+        }\n+\n+        return index >= 0 && values.size() > index\n+               ? new LiteralExpression(values.get(index))\n+               : new LiteralExpression(null);\n+    }\n+\n+    /**\n+     * Checks if the value is a string.\n+     *\n+     * @return Returns true if the value is a string.\n+     */\n+    public boolean isStringValue() {\n+        return value instanceof String;\n+    }\n+\n+    /**\n+     * Checks if the value is a number.\n+     *\n+     * @return Returns true if the value is a number.\n+     */\n+    public boolean isNumberValue() {\n+        return value instanceof Number;\n+    }\n+\n+    /**\n+     * Checks if the value is a boolean.\n+     *\n+     * @return Returns true if the value is a boolean.\n+     */\n+    public boolean isBooleanValue() {\n+        return value instanceof Boolean;\n+    }\n+\n+    /**\n+     * Checks if the value is an array.\n+     *\n+     * @return Returns true if the value is an array.\n+     */\n+    public boolean isArrayValue() {\n+        return value instanceof List;\n+    }\n+\n+    /**\n+     * Checks if the value is an object.\n+     *\n+     * @return Returns true if the value is an object.\n+     */\n+    public boolean isObjectValue() {\n+        return value instanceof Map;\n+    }\n+\n+    /**\n+     * Checks if the value is null.\n+     *\n+     * @return Returns true if the value is null.\n+     */\n+    public boolean isNullValue() {\n+        return value == null;\n+    }\n+\n+    /**\n+     * Gets the value as a string.\n+     *\n+     * @return Returns the string value.\n+     * @throws JmespathException if the value is not a string.\n+     */\n+    public String asStringValue() {", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NjkwMQ==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516446901", "bodyText": "Sure, done", "author": "mtdowling", "createdAt": "2020-11-03T06:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2OTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MDkxOQ==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516270919", "bodyText": "Should be expressions for consistency.", "author": "kstich", "createdAt": "2020-11-02T21:42:04Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/MultiSelectHashExpression.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import software.amazon.smithy.jmespath.ExpressionVisitor;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+\n+/**\n+ * Creates an object using key-value pairs.\n+ */\n+public final class MultiSelectHashExpression extends JmespathExpression {\n+\n+    private final Map<String, JmespathExpression> expressions;\n+\n+    public MultiSelectHashExpression(Map<String, JmespathExpression> entries) {", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzYzMQ==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516273631", "bodyText": "Should be expression for consistency.", "author": "kstich", "createdAt": "2020-11-02T21:47:36Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/NotExpression.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.Objects;\n+import software.amazon.smithy.jmespath.ExpressionVisitor;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+\n+/**\n+ * Negates an expression based on if the wrapped expression is truthy.\n+ */\n+public final class NotExpression extends JmespathExpression {\n+\n+    private final JmespathExpression expression;\n+\n+    public NotExpression(JmespathExpression wrapped) {", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5MTQ4Mg==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516291482", "bodyText": "Doesn't appear in the led() below.", "author": "kstich", "createdAt": "2020-11-02T22:24:05Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/Parser.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+/**\n+ * A top-down operator precedence parser (aka Pratt parser) for JMESPath.\n+ */\n+final class Parser {\n+\n+    /** The maximum binding power for a token that can stop a projection. */\n+    private static final int PROJECTION_STOP = 10;\n+\n+    /** Tokens that can start an expression. */\n+    private static final TokenType[] NUD_TOKENS = {\n+            TokenType.CURRENT,\n+            TokenType.IDENTIFIER,\n+            TokenType.LITERAL,\n+            TokenType.STAR,\n+            TokenType.LBRACE,\n+            TokenType.LBRACKET,\n+            TokenType.FLATTEN,\n+            TokenType.EXPREF,\n+            TokenType.NOT,\n+            TokenType.FILTER,\n+            TokenType.LPAREN\n+    };\n+\n+    /** Tokens that can follow led tokens. */\n+    private static final TokenType[] LED_TOKENS = {\n+            TokenType.DOT,\n+            TokenType.LBRACKET,\n+            TokenType.OR,\n+            TokenType.AND,\n+            TokenType.PIPE,\n+            TokenType.LPAREN,", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0ODUwMg==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516448502", "bodyText": "Added a comment to explain this:\n// While not found in the led() method, a led LPAREN is handled\n// when parsing a nud identifier because it creates a function.", "author": "mtdowling", "createdAt": "2020-11-03T06:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5MTQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwNTU5MA==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516305590", "bodyText": "Should this else be removed?", "author": "kstich", "createdAt": "2020-11-02T22:49:28Z", "path": "smithy-jmespath/src/test/java/software/amazon/smithy/jmespath/RunnerTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package software.amazon.smithy.jmespath;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * This test loads invalid and valid files, to ensure that they\n+ * are either able to be parsed or not able to be parsed.\n+ */\n+public class RunnerTest {\n+    @Test\n+    public void validTests() {\n+        for (String line : readFile(getClass().getResourceAsStream(\"valid\"))) {\n+            try {\n+                JmespathExpression expression = JmespathExpression.parse(line);\n+                for (ExpressionProblem problem : expression.lint().getProblems()) {\n+                    if (problem.severity == ExpressionProblem.Severity.ERROR) {\n+                        Assertions.fail(\"Did not expect an ERROR for line: \" + line + \"\\n\" + problem);\n+                    } else {", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMjY0NQ==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516312645", "bodyText": "0 being truthy surprised me and I couldn't find it in the spec, can you provide the source?", "author": "kstich", "createdAt": "2020-11-02T23:01:50Z", "path": "smithy-jmespath/src/test/java/software/amazon/smithy/jmespath/ast/LiteralExpressionTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import software.amazon.smithy.jmespath.JmespathException;\n+import software.amazon.smithy.jmespath.RuntimeType;\n+\n+public class LiteralExpressionTest {\n+    @Test\n+    public void containsNullValues() {\n+        LiteralExpression node = new LiteralExpression(null);\n+\n+        assertThat(node.isNullValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.NULL));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotString() {\n+        LiteralExpression node = new LiteralExpression(10);\n+\n+        Assertions.assertThrows(JmespathException.class, node::asStringValue);\n+    }\n+\n+    @Test\n+    public void getsAsString() {\n+        LiteralExpression node = new LiteralExpression(\"foo\");\n+\n+        node.asStringValue();\n+        assertThat(node.isStringValue(), is(true));\n+        assertThat(node.isNullValue(), is(false)); // not null\n+        assertThat(node.getType(), equalTo(RuntimeType.STRING));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotArray() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asArrayValue);\n+    }\n+\n+    @Test\n+    public void getsAsArray() {\n+        LiteralExpression node = new LiteralExpression(Collections.emptyList());\n+\n+        node.asArrayValue();\n+        assertThat(node.isArrayValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.ARRAY));\n+    }\n+\n+    @Test\n+    public void getsNegativeArrayIndex() {\n+        LiteralExpression node = new LiteralExpression(Arrays.asList(1, 2, 3));\n+\n+        assertThat(node.getArrayIndex(-1).getValue(), equalTo(3));\n+        assertThat(node.getArrayIndex(-2).getValue(), equalTo(2));\n+        assertThat(node.getArrayIndex(-3).getValue(), equalTo(1));\n+        assertThat(node.getArrayIndex(-4).getValue(), equalTo(null));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotNumber() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asNumberValue);\n+    }\n+\n+    @Test\n+    public void getsAsNumber() {\n+        LiteralExpression node = new LiteralExpression(10);\n+\n+        node.asNumberValue();\n+        assertThat(node.isNumberValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.NUMBER));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotBoolean() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asBooleanValue);\n+    }\n+\n+    @Test\n+    public void getsAsBoolean() {\n+        LiteralExpression node = new LiteralExpression(true);\n+\n+        node.asBooleanValue();\n+        assertThat(node.isBooleanValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.BOOLEAN));\n+    }\n+\n+    @Test\n+    public void getsAsBoxedBoolean() {\n+        LiteralExpression node = new LiteralExpression(new Boolean(true));\n+\n+        node.asBooleanValue();\n+        assertThat(node.isBooleanValue(), is(true));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotMap() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asObjectValue);\n+    }\n+\n+    @Test\n+    public void getsAsMap() {\n+        LiteralExpression node = new LiteralExpression(Collections.emptyMap());\n+\n+        node.asObjectValue();\n+        assertThat(node.isObjectValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.OBJECT));\n+    }\n+\n+    @Test\n+    public void expressionReferenceTypeIsExpref() {\n+        assertThat(LiteralExpression.EXPREF.getType(), equalTo(RuntimeType.EXPRESSION_REFERENCE));\n+    }\n+\n+    @Test\n+    public void anyValueIsAnyType() {\n+        assertThat(LiteralExpression.ANY.getType(), equalTo(RuntimeType.ANY));\n+    }\n+\n+    @Test\n+    public void determinesTruthyValues() {\n+        assertThat(new LiteralExpression(0).isTruthy(), is(true));", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MTE0Nw==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516441147", "bodyText": "https://jmespath.org/specification.html#or-expressions", "author": "mtdowling", "createdAt": "2020-11-03T05:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMjY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM0NjgxNg==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516346816", "bodyText": "This seems like it can be resolved with the tools available in the PR and is relevant for multiple functions in the list.", "author": "kstich", "createdAt": "2020-11-03T00:00:30Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/TypeChecker.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import static software.amazon.smithy.jmespath.FunctionDefinition.isType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.listOfType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.oneOf;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ANY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ARRAY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.BOOLEAN;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.EXPREF;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NULL;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NUMBER;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.OBJECT;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.STRING;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+final class TypeChecker implements ExpressionVisitor<LiteralExpression> {\n+\n+    private static final Map<String, FunctionDefinition> FUNCTIONS = new HashMap<>();\n+\n+    static {\n+        FunctionDefinition.ArgValidator isAny = isType(RuntimeType.ANY);\n+        FunctionDefinition.ArgValidator isString = isType(RuntimeType.STRING);\n+        FunctionDefinition.ArgValidator isNumber = isType(RuntimeType.NUMBER);\n+        FunctionDefinition.ArgValidator isArray = isType(RuntimeType.ARRAY);\n+\n+        FUNCTIONS.put(\"abs\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"avg\", new FunctionDefinition(NUMBER, listOfType(RuntimeType.NUMBER)));\n+        FUNCTIONS.put(\"contains\", new FunctionDefinition(\n+                BOOLEAN, oneOf(RuntimeType.ARRAY, RuntimeType.STRING), isAny));\n+        FUNCTIONS.put(\"ceil\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"ends_with\", new FunctionDefinition(NUMBER, isString, isString));\n+        FUNCTIONS.put(\"floor\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"join\", new FunctionDefinition(STRING, isString, listOfType(RuntimeType.STRING)));\n+        FUNCTIONS.put(\"keys\", new FunctionDefinition(ARRAY, isType(RuntimeType.OBJECT)));\n+        FUNCTIONS.put(\"length\", new FunctionDefinition(\n+                NUMBER, oneOf(RuntimeType.STRING, RuntimeType.ARRAY, RuntimeType.OBJECT)));\n+        // TODO: Support expression reference return type validation?\n+        FUNCTIONS.put(\"map\", new FunctionDefinition(ARRAY, isType(RuntimeType.EXPRESSION_REFERENCE), isArray));\n+        // TODO: support array<X|Y>", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ2MDcyOA==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516460728", "bodyText": "Eh, I'm comfortable leaving this as a todo for now. It's probably several hours of work and testing to implement, and it's not all that important.", "author": "mtdowling", "createdAt": "2020-11-03T07:12:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM0NjgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM0ODQwNg==", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516348406", "bodyText": "This should explain - as used for from end, instead of just -1 being possible.", "author": "kstich", "createdAt": "2020-11-03T00:03:52Z", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/IndexExpression.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.Objects;\n+import software.amazon.smithy.jmespath.ExpressionVisitor;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+\n+/**\n+ * Gets a specific element by zero-based index. Use -1 to get the", "originalCommit": "05b0728331d653844be567dbf3fcc9f07d79a8ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fda9d1c156da88a37f7f3b9d4f0cdaaac7e179d7", "url": "https://github.com/awslabs/smithy/commit/fda9d1c156da88a37f7f3b9d4f0cdaaac7e179d7", "message": "Add smithy-jmespath for parsing JMESPath\n\nWe will be using JMESPath in things like waiters, so we need a JMESPath\nparser that has no dependencies, exposes a rich AST that can be used in\ncode generation, and performs static analysis of expressions.", "committedDate": "2020-11-10T20:55:38Z", "type": "commit"}, {"oid": "a8974c5eb9344341cab2b251085e64b8a53f9219", "url": "https://github.com/awslabs/smithy/commit/a8974c5eb9344341cab2b251085e64b8a53f9219", "message": "Address PR feedback", "committedDate": "2020-11-10T20:55:38Z", "type": "commit"}, {"oid": "cc78e21346ab79aa29aaf3ab9ad7b06321d2087b", "url": "https://github.com/awslabs/smithy/commit/cc78e21346ab79aa29aaf3ab9ad7b06321d2087b", "message": "Add support for \"waiters\"\n\nWaiters are a client-side abstraction used to poll a resource until a\ndesired state is reached, or until it is determined that the resource\nwill never enter into the desired state.\n\nWaiters have been available in AWS SDKs since around 2012, and are now\npart of Smithy as an additional specification. Note that this PR relies\non smithy-jmespath.", "committedDate": "2020-11-10T20:55:38Z", "type": "commit"}, {"oid": "2cf182319590b1ed7a05063b170b32748df05dfc", "url": "https://github.com/awslabs/smithy/commit/2cf182319590b1ed7a05063b170b32748df05dfc", "message": "Refactor waiters\n\nThis commit makes a few changes to waiters:\n\n1. I removed and, or, and not. I couldn't think of a real use case for\n   these as I was documenting them, so I am erring on the side of\n   simplicity.\n2. I removed the emptyArray comparator. This need more work to properly\n   validate and specify it, and it can actually be acheived using a\n   booleanEquals comparator by checking if a returned length of a value\n   in JMESPath is equal to 0. No need for an extra comparator.\n3. I added a new matcher named `inputOutput` that has two top level\n   keys: input and output. This allows both input and output data to be\n   queried *together* for successful operations, solving a longstanding\n   use case we've had for things like making sure the number of\n   autoscaling groups on input matches the number returned on output.\n4. Given that and, or, and not was removed, there's no purpose for a\n   standalone \"input\" matcher, particularly since there's now an\n   \"inputOutput\" matcher.", "committedDate": "2020-11-10T20:55:38Z", "type": "commit"}, {"oid": "c425b28f6237837813fddd7aa330efd524683e47", "url": "https://github.com/awslabs/smithy/commit/c425b28f6237837813fddd7aa330efd524683e47", "message": "Incorporate waiters PR feedback", "committedDate": "2020-11-10T20:55:38Z", "type": "forcePushed"}, {"oid": "5b72625af7dfc4a1abba251dffcd13ffd40ac374", "url": "https://github.com/awslabs/smithy/commit/5b72625af7dfc4a1abba251dffcd13ffd40ac374", "message": "Incorporate waiters PR feedback", "committedDate": "2020-11-11T00:22:24Z", "type": "commit"}, {"oid": "5b72625af7dfc4a1abba251dffcd13ffd40ac374", "url": "https://github.com/awslabs/smithy/commit/5b72625af7dfc4a1abba251dffcd13ffd40ac374", "message": "Incorporate waiters PR feedback", "committedDate": "2020-11-11T00:22:24Z", "type": "forcePushed"}]}