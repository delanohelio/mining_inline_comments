{"pr_number": 274, "pr_title": "Rewrite JSON schema conversion", "pr_createdAt": "2020-02-12T22:02:08Z", "pr_url": "https://github.com/awslabs/smithy/pull/274", "timeline": [{"oid": "5bafc1460e60c9a8d8153a28dff1604ac4e4776d", "url": "https://github.com/awslabs/smithy/commit/5bafc1460e60c9a8d8153a28dff1604ac4e4776d", "message": "Rewrite JSON schema conversion\n\nThis commit significantly cleans up the JSON schema conversion and\nautomatically inlines primitive references rather than inlining them\nthrough a mapper.\n\nThe previous JSON schema implementation code had several issues:\n\n1. It did not do a good job at handling shape ID conflicts when using\n   namespace stripping. We had to add some pretty bad hacks to achieve\n   this. For examplem, it had implicit state that was tricky to handle\n   (like temporarily setting a ref strategy based on a converted shape\n   index).\n2. It didn't detect errors early in the process, resulting in strange\n   errors when you try to use the schema.\n3. It exposed too much public API (for example RefStrategy should not be\n   public). Ideally with this trimmed down API surface area, we won't\n   need another breaking change.\n4. JSON schema names by default should not include a namespace.\n5. Simple shapes by default should always be inlined. Things like list\n   and set shapes aren't that important for generating good JSON\n   schema or OpenAPI schemas. By inlining them, we also ensure that\n   any member documentation attached to members that target list or\n   set shapes isn't lost since that documentation comes from either\n   the member or the targeted shape. This also reduces the possibility\n   for naming conflicts when dropping the namespace from the Smithy\n   shape ID and converting it to JSON Schema.\n6. We were dropping member traits in some scenarios like\n   documentation, pattern, range, length. This is now fixed.\n\nBecause converting shape IDs to JSON pointers can now result in a nested\nJSON pointer, the ability to select schemas from a SchemaDocument using a\nJSON pointer has been implemented.\n\nFurther, the Smithy document shape is actually meant to be a simple type,\nbut it was correctly subclassing SimpleShape, resulting in JSON schema\nconversions not working correctly (document types were creating distinct\nnamed shapes, whereas they are intended to be inlined).\n\nFinally, this commit fixes a bug where JSON schema extensions weren't\nbeing injected.", "committedDate": "2020-02-13T06:31:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE3NjM0MQ==", "url": "https://github.com/awslabs/smithy/pull/274#discussion_r379176341", "bodyText": "Can this be a filter before the sorted call? Will end up in significantly less to sort.", "author": "kstich", "createdAt": "2020-02-13T23:28:42Z", "path": "smithy-jsonschema/src/main/java/software/amazon/smithy/jsonschema/DeconflictingStrategy.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jsonschema;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.logging.Logger;\n+import java.util.regex.Pattern;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.shapes.CollectionShape;\n+import software.amazon.smithy.model.shapes.MapShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.SimpleShape;\n+import software.amazon.smithy.model.traits.EnumTrait;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * Automatically de-conflicts map shapes, list shapes, and set shapes\n+ * by sorting conflicting shapes by ID and then appending a formatted\n+ * version of the shape ID namespace to the colliding shape.\n+ *\n+ * <p>Simple types are never generated at the top level because they\n+ * are always inlined into complex shapes; however, string shapes\n+ * marked with the enum trait are never allowed to conflict since\n+ * they can easily drift away from compatibility over time.\n+ * Structures and unions are not allowed to conflict either.\n+ */\n+final class DeconflictingStrategy implements RefStrategy {\n+\n+    private static final Logger LOGGER = Logger.getLogger(DeconflictingStrategy.class.getName());\n+    private static final Pattern SPLIT_PATTERN = Pattern.compile(\"\\\\.\");\n+\n+    private final RefStrategy delegate;\n+    private final Map<ShapeId, String> pointers = new HashMap<>();\n+    private final Map<String, ShapeId> reversePointers = new HashMap<>();\n+\n+    DeconflictingStrategy(Model model, RefStrategy delegate) {\n+        this.delegate = delegate;\n+\n+        // Pre-compute a map of all converted shape refs. Sort the shapes\n+        // to make the result deterministic.\n+        model.shapes().sorted().forEach(shape -> {\n+            if (isIgnoredShape(shape)) {", "originalCommit": "5bafc1460e60c9a8d8153a28dff1604ac4e4776d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE3OTQzMw==", "url": "https://github.com/awslabs/smithy/pull/274#discussion_r379179433", "bodyText": "s/Members of lists and sets Lists/Lists", "author": "kstich", "createdAt": "2020-02-13T23:37:25Z", "path": "smithy-jsonschema/src/main/java/software/amazon/smithy/jsonschema/DefaultRefStrategy.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jsonschema;\n+\n+import java.util.regex.Pattern;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.shapes.CollectionShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.SimpleShape;\n+import software.amazon.smithy.model.traits.EnumTrait;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * This ref strategy converts Smithy shapes into the following:\n+ *\n+ * <ul>\n+ *     <li>\n+ *         Structures, unions, maps, and enums are always created as a top-level\n+ *         JSON schema definition.\n+ *     </li>\n+ *     <li>\n+ *         <p>Members that target structures, unions, enums, and maps use a $ref to the\n+ *         targeted shape. With the exception of maps, these kinds of shapes are almost\n+ *         always generated as concrete types by code generators, so it's useful to reuse\n+ *         them throughout the schema. However, this means that member documentation\n+ *         and other member traits need to be moved in some way to the containing\n+ *         shape (for example, documentation needs to be appended to the container\n+ *         shape).</p>\n+ *         <p>Maps are included here because they are represented as objects in\n+ *         JSON schema, and many tools will generate a type or require an explicit\n+ *         name for all objects. For example, API Gateway will auto-generate a\n+ *         non-deterministic name for a map if one is not provided.</p>\n+ *     </li>\n+ *     <li>\n+ *         Members that target a collection or simple type are inlined into the generated\n+ *         container (that is, shapes that do not have the enum trait).\n+ *     </li>\n+ * </ul>\n+ */\n+final class DefaultRefStrategy implements RefStrategy {\n+\n+    private static final Pattern SPLIT_PATTERN = Pattern.compile(\"\\\\.\");\n+    private static final Pattern NON_ALPHA_NUMERIC = Pattern.compile(\"[^A-Za-z0-9]\");\n+\n+    private final Model model;\n+    private final boolean alphanumericOnly;\n+    private final boolean keepNamespaces;\n+    private final String rootPointer;\n+    private final PropertyNamingStrategy propertyNamingStrategy;\n+    private final ObjectNode config;\n+\n+    DefaultRefStrategy(Model model, ObjectNode config, PropertyNamingStrategy propertyNamingStrategy) {\n+        this.model = model;\n+        this.propertyNamingStrategy = propertyNamingStrategy;\n+        this.config = config;\n+        rootPointer = computePointer(config);\n+        alphanumericOnly = config.getBooleanMemberOrDefault(JsonSchemaConstants.ALPHANUMERIC_ONLY_REFS);\n+        keepNamespaces = config.getBooleanMemberOrDefault(JsonSchemaConstants.KEEP_NAMESPACES);\n+    }\n+\n+    private static String computePointer(ObjectNode config) {\n+        String pointer = config.getStringMemberOrDefault(JsonSchemaConstants.DEFINITION_POINTER, DEFAULT_POINTER);\n+        if (!pointer.endsWith(\"/\")) {\n+            pointer += \"/\";\n+        }\n+        return pointer;\n+    }\n+\n+    @Override\n+    public String toPointer(ShapeId id) {\n+        if (id.getMember().isPresent()) {\n+            MemberShape member = model.expectShape(id, MemberShape.class);\n+            return createMemberPointer(member);\n+        }\n+\n+        StringBuilder builder = new StringBuilder();\n+        appendNamespace(builder, id);\n+        builder.append(id.getName());\n+        return rootPointer + stripNonAlphaNumericCharsIfNecessary(builder.toString());\n+    }\n+\n+    private String createMemberPointer(MemberShape member) {\n+        if (!isInlined(member)) {\n+            return toPointer(member.getTarget());\n+        }\n+\n+        Shape container = model.expectShape(member.getContainer());\n+        String parentPointer = toPointer(container.getId());\n+\n+        switch (container.getType()) {\n+            case LIST:\n+            case SET:\n+                return parentPointer + \"/items\";\n+            case MAP:\n+                return member.getMemberName().equals(\"key\")\n+                       ? parentPointer + \"/propertyNames\"\n+                       : parentPointer + \"/additionalProperties\";\n+            default: // union | structure\n+                return parentPointer + \"/properties/\" + propertyNamingStrategy.toPropertyName(\n+                        container, member, config);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isInlined(Shape shape) {\n+        // We could add more logic here in the future if needed to account for\n+        // member shapes that absolutely must generate a synthesized schema.\n+        if (shape.asMemberShape().isPresent()) {\n+            MemberShape member = shape.asMemberShape().get();\n+            Shape target = model.expectShape(member.getTarget());\n+            return isInlined(target);\n+        }\n+\n+        // Collections (lists and sets) are always inlined. Most importantly,\n+        // this is done to expose any important traits of list and set members\n+        // in the generated JSON schema document (for example, documentation).\n+        // Without this inlining, list and set member documentation would be\n+        // lost since the items property in the generated JSON schema would\n+        // just be a $ref pointing to the target of the member. The more\n+        // things that can be inlined that don't matter the better since it\n+        // means traits like documentation aren't lost.\n+        //\n+        // Members of lists and sets Lists and sets are basically never a", "originalCommit": "5bafc1460e60c9a8d8153a28dff1604ac4e4776d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE3OTYyNA==", "url": "https://github.com/awslabs/smithy/pull/274#discussion_r379179624", "bodyText": "s/Smithy -> JSON Schema -> Schema/Smithy -> JSON Schema -> Smithy", "author": "kstich", "createdAt": "2020-02-13T23:38:02Z", "path": "smithy-jsonschema/src/main/java/software/amazon/smithy/jsonschema/DefaultRefStrategy.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jsonschema;\n+\n+import java.util.regex.Pattern;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.node.ObjectNode;\n+import software.amazon.smithy.model.shapes.CollectionShape;\n+import software.amazon.smithy.model.shapes.MemberShape;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.SimpleShape;\n+import software.amazon.smithy.model.traits.EnumTrait;\n+import software.amazon.smithy.utils.StringUtils;\n+\n+/**\n+ * This ref strategy converts Smithy shapes into the following:\n+ *\n+ * <ul>\n+ *     <li>\n+ *         Structures, unions, maps, and enums are always created as a top-level\n+ *         JSON schema definition.\n+ *     </li>\n+ *     <li>\n+ *         <p>Members that target structures, unions, enums, and maps use a $ref to the\n+ *         targeted shape. With the exception of maps, these kinds of shapes are almost\n+ *         always generated as concrete types by code generators, so it's useful to reuse\n+ *         them throughout the schema. However, this means that member documentation\n+ *         and other member traits need to be moved in some way to the containing\n+ *         shape (for example, documentation needs to be appended to the container\n+ *         shape).</p>\n+ *         <p>Maps are included here because they are represented as objects in\n+ *         JSON schema, and many tools will generate a type or require an explicit\n+ *         name for all objects. For example, API Gateway will auto-generate a\n+ *         non-deterministic name for a map if one is not provided.</p>\n+ *     </li>\n+ *     <li>\n+ *         Members that target a collection or simple type are inlined into the generated\n+ *         container (that is, shapes that do not have the enum trait).\n+ *     </li>\n+ * </ul>\n+ */\n+final class DefaultRefStrategy implements RefStrategy {\n+\n+    private static final Pattern SPLIT_PATTERN = Pattern.compile(\"\\\\.\");\n+    private static final Pattern NON_ALPHA_NUMERIC = Pattern.compile(\"[^A-Za-z0-9]\");\n+\n+    private final Model model;\n+    private final boolean alphanumericOnly;\n+    private final boolean keepNamespaces;\n+    private final String rootPointer;\n+    private final PropertyNamingStrategy propertyNamingStrategy;\n+    private final ObjectNode config;\n+\n+    DefaultRefStrategy(Model model, ObjectNode config, PropertyNamingStrategy propertyNamingStrategy) {\n+        this.model = model;\n+        this.propertyNamingStrategy = propertyNamingStrategy;\n+        this.config = config;\n+        rootPointer = computePointer(config);\n+        alphanumericOnly = config.getBooleanMemberOrDefault(JsonSchemaConstants.ALPHANUMERIC_ONLY_REFS);\n+        keepNamespaces = config.getBooleanMemberOrDefault(JsonSchemaConstants.KEEP_NAMESPACES);\n+    }\n+\n+    private static String computePointer(ObjectNode config) {\n+        String pointer = config.getStringMemberOrDefault(JsonSchemaConstants.DEFINITION_POINTER, DEFAULT_POINTER);\n+        if (!pointer.endsWith(\"/\")) {\n+            pointer += \"/\";\n+        }\n+        return pointer;\n+    }\n+\n+    @Override\n+    public String toPointer(ShapeId id) {\n+        if (id.getMember().isPresent()) {\n+            MemberShape member = model.expectShape(id, MemberShape.class);\n+            return createMemberPointer(member);\n+        }\n+\n+        StringBuilder builder = new StringBuilder();\n+        appendNamespace(builder, id);\n+        builder.append(id.getName());\n+        return rootPointer + stripNonAlphaNumericCharsIfNecessary(builder.toString());\n+    }\n+\n+    private String createMemberPointer(MemberShape member) {\n+        if (!isInlined(member)) {\n+            return toPointer(member.getTarget());\n+        }\n+\n+        Shape container = model.expectShape(member.getContainer());\n+        String parentPointer = toPointer(container.getId());\n+\n+        switch (container.getType()) {\n+            case LIST:\n+            case SET:\n+                return parentPointer + \"/items\";\n+            case MAP:\n+                return member.getMemberName().equals(\"key\")\n+                       ? parentPointer + \"/propertyNames\"\n+                       : parentPointer + \"/additionalProperties\";\n+            default: // union | structure\n+                return parentPointer + \"/properties/\" + propertyNamingStrategy.toPropertyName(\n+                        container, member, config);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isInlined(Shape shape) {\n+        // We could add more logic here in the future if needed to account for\n+        // member shapes that absolutely must generate a synthesized schema.\n+        if (shape.asMemberShape().isPresent()) {\n+            MemberShape member = shape.asMemberShape().get();\n+            Shape target = model.expectShape(member.getTarget());\n+            return isInlined(target);\n+        }\n+\n+        // Collections (lists and sets) are always inlined. Most importantly,\n+        // this is done to expose any important traits of list and set members\n+        // in the generated JSON schema document (for example, documentation).\n+        // Without this inlining, list and set member documentation would be\n+        // lost since the items property in the generated JSON schema would\n+        // just be a $ref pointing to the target of the member. The more\n+        // things that can be inlined that don't matter the better since it\n+        // means traits like documentation aren't lost.\n+        //\n+        // Members of lists and sets Lists and sets are basically never a\n+        // generated type in any programming language because most just use\n+        // some kind of standard library feature. This essentially means that\n+        // the names of lists or sets changing when round-tripping\n+        // Smithy -> JSON Schema -> Schema doesn't matter that much.", "originalCommit": "5bafc1460e60c9a8d8153a28dff1604ac4e4776d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU4MDE3Ng==", "url": "https://github.com/awslabs/smithy/pull/274#discussion_r379580176", "bodyText": "This is doing the same work as this line, just without going to the function.", "author": "kstich", "createdAt": "2020-02-14T18:29:27Z", "path": "smithy-jsonschema/src/main/java/software/amazon/smithy/jsonschema/JsonSchemaConverter.java", "diffHunk": "@@ -109,216 +151,270 @@ public ObjectNode getConfig() {\n         return config;\n     }\n \n-    /**\n-     * Sets a custom property naming strategy.\n-     *\n-     * <p>This method overrides an configuration values specified by\n-     * the configuration object.\n-     *\n-     * @param propertyNamingStrategy Property name strategy to use.\n-     * @return Returns the converter.\n-     */\n-    public JsonSchemaConverter propertyNamingStrategy(PropertyNamingStrategy propertyNamingStrategy) {\n-        this.propertyNamingStrategy = propertyNamingStrategy;\n-        return this;\n-    }\n-\n     /**\n      * Gets the property naming strategy of the converter.\n      *\n+     * @param member Member to convert to a property name.\n      * @return Returns the PropertyNamingStrategy.\n      */\n-    public PropertyNamingStrategy getPropertyNamingStrategy() {\n-        if (propertyNamingStrategy == null) {\n-            propertyNamingStrategy = PropertyNamingStrategy.createDefaultStrategy();\n-        }\n-        return propertyNamingStrategy;\n+    public String toPropertyName(MemberShape member) {\n+        Shape containingShape = model.getShape(member.getContainer())\n+                .orElseThrow(() -> new SmithyJsonSchemaException(\"Invalid member: \" + member));\n+        return propertyNamingStrategy.toPropertyName(containingShape, member, config);\n     }\n \n     /**\n-     * Sets a custom reference naming strategy.\n+     * Given a shape ID, returns the value used in a $ref to refer to it.\n      *\n-     * <p>This method overrides an configuration values specified by\n-     * the settings object.\n+     * <p>The return value is expected to be a JSON pointer.\n      *\n-     * @param refStrategy Reference naming strategy to use.\n-     * @return Returns the converter.\n+     * @param id Shape ID to convert to a $ref string.\n+     * @return Returns the $ref string (e.g., \"#/responses/MyShape\").\n      */\n-    public JsonSchemaConverter refStrategy(RefStrategy refStrategy) {\n-        softRefStrategy = false;\n-        this.refStrategy = refStrategy;\n-        return this;\n+    public String toPointer(ToShapeId id) {\n+        return refStrategy.toPointer(id.toShapeId());\n     }\n \n     /**\n-     * Gets the RefStrategy used by the converter.\n+     * Checks if the given JSON pointer points to a top-level definition.\n      *\n-     * @return Reference naming strategy to use.\n-     */\n-    public RefStrategy getRefStrategy() {\n-        return refStrategy != null ? refStrategy : DEFAULT_REF_STRATEGY;\n-    }\n-\n-    /**\n-     * Adds a mapper used to update schema builders.\n+     * <p>Note that this expects the pointer to exactly start with the same\n+     * string that is configured as {@link JsonSchemaConstants#DEFINITION_POINTER},\n+     * or the default value of \"#/definitions\". If the number of segments\n+     * in the provided pointer is also equal to the number of segments\n+     * in the default pointer + 1, then it is considered a top-level pointer.\n      *\n-     * @param jsonSchemaMapper Mapper to add.\n-     * @return Returns the converter.\n+     * @param pointer Pointer to check.\n+     * @return Returns true if this is a top-level definition pointer.\n      */\n-    public JsonSchemaConverter addMapper(JsonSchemaMapper jsonSchemaMapper) {\n-        mappers.add(jsonSchemaMapper);\n-        return this;\n+    public boolean isTopLevelPointer(String pointer) {\n+        return pointer.startsWith(rootDefinitionPointer)\n+               && countSegments(pointer) == rootDefinitionSegments + 1;\n     }\n \n     /**\n-     * Perform the conversion of the entire model.\n+     * Checks if the given shape is inlined into its container when targeted\n+     * by a member.\n      *\n-     * @param model Model to convert.\n-     * @return Returns the created SchemaDocument.\n+     * @param shape Shape to check.\n+     * @return Returns true if this shape is inlined into its containing shape.\n      */\n-    public SchemaDocument convert(Model model) {\n-        return doConversion(model, null);\n+    public boolean isInlined(Shape shape) {\n+        return refStrategy.isInlined(shape);\n     }\n \n     /**\n-     * Perform the conversion of a single shape.\n-     *\n-     * <p>The root shape of the created document is set to the given shape,\n-     * and only shapes connected to the given shape are added as a definition.\n+     * Perform the conversion of the entire shape index.\n      *\n-     * @param model Model to convert.\n-     * @param shape Shape to convert.\n      * @return Returns the created SchemaDocument.\n      */\n-    public SchemaDocument convert(Model model, Shape shape) {\n-        return doConversion(model, shape);\n-    }\n-\n-    private SchemaDocument doConversion(Model model, Shape rootShape) {\n-        // TODO: break this API to make this work more reliably.\n-        //\n-        // Temporarily set a de-conflicting ref strategy. This is the\n-        // minimal change needed to fix a reported bug, but it is a hack\n-        // and we should break this API before GA.\n-        //\n-        // We want to do the right thing by default. However, the default\n-        // that was previously chosen didn't account for the possibility\n-        // of shape name conflicts when converting members to JSON schema\n-        // pointers. For example, consider the following shapes:\n-        //\n-        // - A member of a list, foo.baz#PageScripts$member\n-        // - A member of a structure, foo.baz#Page$scripts\n-        //\n-        // If we only rely on the RefStrategy#createDefaultStrategy, then\n-        // we would actually generate the same JSON schema shape name for\n-        // both of the above member shapes: FooBazPageScriptsMember. To\n-        // avoid this, we need to know the model being converted and\n-        // automatically handle conflicts. However, because this class is\n-        // mutable, we have to do some funky stuff with state to \"do the\n-        // right thing\" by lazily creating a RefStrategy#createDefaultDeconflictingStrategy\n-        // in this method once a model is available\n-        // (given as an argument).\n-        //\n-        // A better API would use a builder that builds a JsonSchemaConverter\n-        // that has a fixed model, ref strategy, etc. This would allow\n-        // ref strategies to do more up-front computations, and allow them to\n-        // even become implementation details of JsonSchemaConverter by exposing\n-        // a similar API that delegates from a converter into the strategy.\n-        //\n-        // There's also quite a bit of awkward code in the OpenAPI conversion code\n-        // base that tries to deal with merging configuration values and deriving\n-        // a default JsonSchemaConverter if one isn't set. A better API there would\n-        // be to not even allow the injection of a custom JsonSchemaConverter at all.\n-        if (softRefStrategy || refStrategy == null) {\n-            softRefStrategy = true;\n-            refStrategy = RefStrategy.createDefaultDeconflictingStrategy(model, getConfig());\n-        }\n-\n-        // Combine custom mappers with the discovered mappers and sort them.\n-        mappers.sort(Comparator.comparing(JsonSchemaMapper::getOrder));\n-\n+    public SchemaDocument convert() {\n+        LOGGER.fine(\"Converting to JSON schema\");\n         SchemaDocument.Builder builder = SchemaDocument.builder();\n-        JsonSchemaShapeVisitor visitor = new JsonSchemaShapeVisitor(\n-                model, getConfig(), getRefStrategy(), getPropertyNamingStrategy(), mappers);\n \n         if (rootShape != null && !(rootShape instanceof ServiceShape)) {\n+            LOGGER.fine(() -> \"Setting root schema to \" + rootShape);\n             builder.rootSchema(rootShape.accept(visitor));\n         }\n \n         addExtensions(builder);\n-        Predicate<Shape> predicate = composePredicate(model, rootShape);\n+\n+        // Create a model that strips out traits and disconnected shapes.\n+        Model updatedModel = createUpdatedModel(model, rootShape, shapePredicate);\n+\n         model.shapes()\n-                .filter(predicate)\n-                // Don't include members if their container was excluded.\n-                .filter(shape -> memberDefinitionPredicate(model, shape, predicate))\n+                // Only generate shapes that passed through each predicate.\n+                .filter(shape -> updatedModel.getShape(shape.getId()).isPresent())\n+                // Don't generate members.\n+                .filter(FunctionalUtils.not(Shape::isMemberShape))\n+                // Don't write the root shape to the definitions.\n+                .filter((shape -> rootShape == null || !shape.getId().equals(rootShape.getId())))\n+                // Don't convert unsupported shapes.\n+                .filter(FunctionalUtils.not(this::isUnsupportedShapeType))\n+                // Ignore prelude shapes.\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                // Do not generate inlined shapes in the definitions map.\n+                .filter(FunctionalUtils.not(refStrategy::isInlined))\n+                // Create a pair of pointer and shape.\n+                .map(shape -> Pair.of(toPointer(shape), shape))\n+                // Only add definitions if they are at the top-level and not inlined.\n+                .filter(pair -> isTopLevelPointer(pair.getLeft()))\n                 // Create the pointer to the shape and schema object.\n-                .map(shape -> Pair.of(\n-                        getRefStrategy().toPointer(shape.getId(), getConfig()),\n-                        shape.accept(visitor)))\n+                .map(pair -> {\n+                    LOGGER.fine(() -> \"Converting \" + pair.getRight() + \" to JSON schema at \" + pair.getLeft());\n+                    return Pair.of(pair.getLeft(), pair.getRight().accept(visitor));\n+                })\n                 .forEach(pair -> builder.putDefinition(pair.getLeft(), pair.getRight()));\n \n+        LOGGER.fine(() -> \"Completed JSON schema document conversion (root shape: \" + rootShape + \")\");\n+\n+        // Add extensions if present.\n+        config.getObjectMember(JsonSchemaConstants.SCHEMA_DOCUMENT_EXTENSIONS).ifPresent(builder::extensions);", "originalCommit": "5bafc1460e60c9a8d8153a28dff1604ac4e4776d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f6b45a4b0e6b705b4e4dc5f1f8077c9942a9f4e6", "url": "https://github.com/awslabs/smithy/commit/f6b45a4b0e6b705b4e4dc5f1f8077c9942a9f4e6", "message": "Rewrite JSON schema conversion\n\nThis commit significantly cleans up the JSON schema conversion and\nautomatically inlines primitive references rather than inlining them\nthrough a mapper.\n\nThe previous JSON schema implementation code had several issues:\n\n1. It did not do a good job at handling shape ID conflicts when using\n   namespace stripping. We had to add some pretty bad hacks to achieve\n   this. For examplem, it had implicit state that was tricky to handle\n   (like temporarily setting a ref strategy based on a converted shape\n   index).\n2. It didn't detect errors early in the process, resulting in strange\n   errors when you try to use the schema.\n3. It exposed too much public API (for example RefStrategy should not be\n   public). Ideally with this trimmed down API surface area, we won't\n   need another breaking change.\n4. JSON schema names by default should not include a namespace.\n5. Simple shapes by default should always be inlined. Things like list\n   and set shapes aren't that important for generating good JSON\n   schema or OpenAPI schemas. By inlining them, we also ensure that\n   any member documentation attached to members that target list or\n   set shapes isn't lost since that documentation comes from either\n   the member or the targeted shape. This also reduces the possibility\n   for naming conflicts when dropping the namespace from the Smithy\n   shape ID and converting it to JSON Schema.\n6. We were dropping member traits in some scenarios like\n   documentation, pattern, range, length. This is now fixed.\n\nBecause converting shape IDs to JSON pointers can now result in a nested\nJSON pointer, the ability to select schemas from a SchemaDocument using a\nJSON pointer has been implemented.\n\nFurther, the Smithy document shape is actually meant to be a simple type,\nbut it was correctly subclassing SimpleShape, resulting in JSON schema\nconversions not working correctly (document types were creating distinct\nnamed shapes, whereas they are intended to be inlined).\n\nFinally, this commit fixes a bug where JSON schema extensions weren't\nbeing injected.", "committedDate": "2020-02-14T21:03:48Z", "type": "commit"}, {"oid": "f6b45a4b0e6b705b4e4dc5f1f8077c9942a9f4e6", "url": "https://github.com/awslabs/smithy/commit/f6b45a4b0e6b705b4e4dc5f1f8077c9942a9f4e6", "message": "Rewrite JSON schema conversion\n\nThis commit significantly cleans up the JSON schema conversion and\nautomatically inlines primitive references rather than inlining them\nthrough a mapper.\n\nThe previous JSON schema implementation code had several issues:\n\n1. It did not do a good job at handling shape ID conflicts when using\n   namespace stripping. We had to add some pretty bad hacks to achieve\n   this. For examplem, it had implicit state that was tricky to handle\n   (like temporarily setting a ref strategy based on a converted shape\n   index).\n2. It didn't detect errors early in the process, resulting in strange\n   errors when you try to use the schema.\n3. It exposed too much public API (for example RefStrategy should not be\n   public). Ideally with this trimmed down API surface area, we won't\n   need another breaking change.\n4. JSON schema names by default should not include a namespace.\n5. Simple shapes by default should always be inlined. Things like list\n   and set shapes aren't that important for generating good JSON\n   schema or OpenAPI schemas. By inlining them, we also ensure that\n   any member documentation attached to members that target list or\n   set shapes isn't lost since that documentation comes from either\n   the member or the targeted shape. This also reduces the possibility\n   for naming conflicts when dropping the namespace from the Smithy\n   shape ID and converting it to JSON Schema.\n6. We were dropping member traits in some scenarios like\n   documentation, pattern, range, length. This is now fixed.\n\nBecause converting shape IDs to JSON pointers can now result in a nested\nJSON pointer, the ability to select schemas from a SchemaDocument using a\nJSON pointer has been implemented.\n\nFurther, the Smithy document shape is actually meant to be a simple type,\nbut it was correctly subclassing SimpleShape, resulting in JSON schema\nconversions not working correctly (document types were creating distinct\nnamed shapes, whereas they are intended to be inlined).\n\nFinally, this commit fixes a bug where JSON schema extensions weren't\nbeing injected.", "committedDate": "2020-02-14T21:03:48Z", "type": "forcePushed"}]}