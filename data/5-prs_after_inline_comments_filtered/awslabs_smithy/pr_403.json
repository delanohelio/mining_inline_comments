{"pr_number": 403, "pr_title": "Rewrite selectors to be push-based with more features", "pr_createdAt": "2020-04-30T00:09:49Z", "pr_url": "https://github.com/awslabs/smithy/pull/403", "timeline": [{"oid": "da096153864666785e0607e381b7284cf1544c96", "url": "https://github.com/awslabs/smithy/commit/da096153864666785e0607e381b7284cf1544c96", "message": "Rewrite selectors spec and impl to be push-based\n\nSelectors are now push-based. A shape is pushed through a selector, one\nat a time, and a terminal listener is used to receive the matched shapes\n(e.g., put them in a set, react on matches, etc). This simplifies how\nselectors are implemented and opens up lots of possibilities like\ndistributing the work of matching a selector to a model across threads.\n\nNew selector features were added too:\n\n1. Projection comparators\n2. Selector$Runner to build more complex evaluations\n3. Selector variables", "committedDate": "2020-04-30T00:04:15Z", "type": "commit"}, {"oid": "54b3b19835c6dd818279a3a51438e070b6d52992", "url": "https://github.com/awslabs/smithy/commit/54b3b19835c6dd818279a3a51438e070b6d52992", "message": "Add reverse neighbors, remove `:of`\n\nThis commit adds support for reverse undirected neighbors, reverse\ndirected neighbors, and removes the `:of` selector since it's behavior\nis now obsolete from reverse neighbors.", "committedDate": "2020-04-30T00:04:15Z", "type": "commit"}, {"oid": "784f43e85a557a8cef5be85472d0664b83a98466", "url": "https://github.com/awslabs/smithy/commit/784f43e85a557a8cef5be85472d0664b83a98466", "message": "Update selectors changelog", "committedDate": "2020-04-30T00:08:32Z", "type": "commit"}, {"oid": "9c924dfd54ebd4bd8378eed384abfcada2e80209", "url": "https://github.com/awslabs/smithy/commit/9c924dfd54ebd4bd8378eed384abfcada2e80209", "message": "Add JMH benchmarks and some optimizations\n\nI was able to figure out that things I thought were improving selector\nperformance but weren't (like unrolling the AndSelector), and I was able to\nidentify things that significantly improve selector performance (like\ndetecting when the first internal selector is a shape type filter and\nusing `Model#shapes(Class<? extends Shape>)` to reduce the number of\nshapes that need to be pushed through a selector).", "committedDate": "2020-04-30T05:59:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwOTc1Mg==", "url": "https://github.com/awslabs/smithy/pull/403#discussion_r418309752", "bodyText": "There's no equivalent createsIdValue() test. We should probably validate it for the defaulting behavior on member.", "author": "kstich", "createdAt": "2020-04-30T21:51:42Z", "path": "smithy-model/src/test/java/software/amazon/smithy/model/selector/AttributeValueTest.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package software.amazon.smithy.model.selector;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.Test;\n+import software.amazon.smithy.model.node.Node;\n+import software.amazon.smithy.model.shapes.ServiceShape;\n+import software.amazon.smithy.model.shapes.StringShape;\n+import software.amazon.smithy.model.traits.DocumentationTrait;\n+import software.amazon.smithy.model.traits.TagsTrait;\n+import software.amazon.smithy.utils.ListUtils;\n+import software.amazon.smithy.utils.MapUtils;\n+import software.amazon.smithy.utils.SetUtils;\n+\n+public class AttributeValueTest {\n+    @Test\n+    public void checksProjectionSubsetEquality() {\n+        AttributeValue a = AttributeValue.literal(\"a\");\n+        AttributeValue b = AttributeValue.literal(\"b\");\n+        AttributeValue c = AttributeValue.literal(\"c\");\n+\n+        AttributeValue p1 = AttributeValue.projection(ListUtils.of(b));\n+        AttributeValue p2 = AttributeValue.projection(ListUtils.of(b, c));\n+        AttributeValue p3 = AttributeValue.projection(ListUtils.of(a, b, c));\n+        AttributeValue p4 = AttributeValue.projection(ListUtils.of(a));\n+        AttributeComparator comparator = AttributeComparator.SUBSET;\n+\n+        assertThat(comparator.compare(p1, p2, false), equalTo(true));\n+        assertThat(comparator.compare(p3, p3, false), equalTo(true));\n+        assertThat(comparator.compare(p3, p2, false), equalTo(false));\n+        assertThat(comparator.compare(p4, p2, false), equalTo(false));\n+        assertThat(comparator.compare(p1, AttributeValue.literal(\"hi\"), false), equalTo(false));\n+    }\n+\n+    @Test\n+    public void checksProjectionProperSubsetEquality() {\n+        AttributeValue a = AttributeValue.literal(\"a\");\n+        AttributeValue b = AttributeValue.literal(\"b\");\n+        AttributeValue c = AttributeValue.literal(\"c\");\n+\n+        AttributeValue p1 = AttributeValue.projection(ListUtils.of(b));\n+        AttributeValue p2 = AttributeValue.projection(ListUtils.of(b, c));\n+        AttributeValue p3 = AttributeValue.projection(ListUtils.of(a, b, c));\n+        AttributeValue p4 = AttributeValue.projection(ListUtils.of(a));\n+        AttributeComparator comparator = AttributeComparator.PROPER_SUBSET;\n+\n+        assertThat(comparator.compare(p1, p2, false), equalTo(true));\n+        assertThat(comparator.compare(p3, p3, false), equalTo(false));\n+        assertThat(comparator.compare(p3, p2, false), equalTo(false));\n+        assertThat(comparator.compare(p4, p2, false), equalTo(false));\n+        assertThat(comparator.compare(p1, AttributeValue.literal(\"hi\"), false), equalTo(false));\n+    }\n+\n+    @Test\n+    public void checksProjectionEquality() {\n+        AttributeValue a = AttributeValue.literal(\"a\");\n+        AttributeValue b = AttributeValue.literal(\"b\");\n+        AttributeValue c = AttributeValue.literal(\"c\");\n+\n+        AttributeValue p1 = AttributeValue.projection(ListUtils.of(b));\n+        AttributeValue p2 = AttributeValue.projection(ListUtils.of(b, c));\n+        AttributeValue p3 = AttributeValue.projection(ListUtils.of(a, b, c));\n+        AttributeValue p4 = AttributeValue.projection(ListUtils.of(a));\n+        AttributeComparator comparator = AttributeComparator.PROJECTION_EQUALS;\n+\n+        assertThat(comparator.compare(p1, p2, false), equalTo(false));\n+        assertThat(comparator.compare(p3, p3, false), equalTo(true));\n+        assertThat(comparator.compare(p3, p2, false), equalTo(false));\n+        assertThat(comparator.compare(p4, p2, false), equalTo(false));\n+        assertThat(comparator.compare(p1, AttributeValue.literal(\"hi\"), false), equalTo(false));\n+    }\n+\n+    @Test\n+    public void checksProjectionInequality() {\n+        AttributeValue a = AttributeValue.literal(\"a\");\n+        AttributeValue b = AttributeValue.literal(\"b\");\n+        AttributeValue c = AttributeValue.literal(\"c\");\n+\n+        AttributeValue p1 = AttributeValue.projection(ListUtils.of(b));\n+        AttributeValue p2 = AttributeValue.projection(ListUtils.of(b, c));\n+        AttributeValue p3 = AttributeValue.projection(ListUtils.of(a, b, c));\n+        AttributeValue p4 = AttributeValue.projection(ListUtils.of(a));\n+        AttributeComparator comparator = AttributeComparator.PROJECTION_NOT_EQUALS;\n+\n+        assertThat(comparator.compare(p1, p2, false), equalTo(true));\n+        assertThat(comparator.compare(p3, p3, false), equalTo(false));\n+        assertThat(comparator.compare(p3, p2, false), equalTo(true));\n+        assertThat(comparator.compare(p4, p2, false), equalTo(true));\n+        assertThat(comparator.compare(p1, AttributeValue.literal(\"hi\"), false), equalTo(true));\n+    }\n+\n+    @Test\n+    public void checksProjectionEqualityWithEquals() {\n+        AttributeValue a = AttributeValue.literal(\"a\");\n+        AttributeValue b = AttributeValue.literal(\"b\");\n+        AttributeValue c = AttributeValue.literal(\"c\");\n+\n+        AttributeValue p1 = AttributeValue.projection(ListUtils.of(b));\n+        AttributeValue p2 = AttributeValue.projection(ListUtils.of(b, c));\n+        AttributeValue p3 = AttributeValue.projection(ListUtils.of(a, b, c));\n+        AttributeValue p4 = AttributeValue.projection(ListUtils.of(a));\n+        AttributeComparator comparator = AttributeComparator.EQUALS;\n+\n+        assertThat(comparator.compare(p1, p2, false), equalTo(true));\n+        assertThat(comparator.compare(p3, p3, false), equalTo(true));\n+        assertThat(comparator.compare(p3, p2, false), equalTo(true));\n+        assertThat(comparator.compare(p4, p2, false), equalTo(false));\n+    }\n+\n+    @Test\n+    public void checksProjectionNotEquality() {\n+        AttributeValue a = AttributeValue.literal(\"a\");\n+        AttributeValue b = AttributeValue.literal(\"b\");\n+        AttributeValue c = AttributeValue.literal(\"c\");\n+\n+        AttributeValue p1 = AttributeValue.projection(ListUtils.of(b));\n+        AttributeValue p2 = AttributeValue.projection(ListUtils.of(b, c));\n+        AttributeValue p3 = AttributeValue.projection(ListUtils.of(a, b, c));\n+        AttributeValue p4 = AttributeValue.projection(ListUtils.of(a));\n+        AttributeComparator comparator = AttributeComparator.NOT_EQUALS;\n+\n+        // != is a bit useless for projections. It just states if any\n+        // value is not equal to any other value. It doesn't tell you\n+        // if one is a subset, one is a superset, etc.\n+        assertThat(comparator.compare(p1, p2, false), equalTo(true));\n+        assertThat(comparator.compare(p3, p3, false), equalTo(true));\n+        assertThat(comparator.compare(p3, p2, false), equalTo(true));\n+        assertThat(comparator.compare(p4, p2, false), equalTo(true));\n+\n+        // This tells us that all the elements of both projections are\n+        // the same, so it returns false.\n+        assertThat(comparator.compare(p4, p4, false), equalTo(false));\n+    }\n+\n+    @Test\n+    public void checksProjectionContains() {\n+        AttributeValue a = AttributeValue.literal(\"a\");\n+        AttributeValue b = AttributeValue.literal(\"b\");\n+        AttributeValue c = AttributeValue.literal(\"c\");\n+\n+        AttributeValue p1 = AttributeValue.projection(ListUtils.of(b));\n+        AttributeValue p2 = AttributeValue.projection(ListUtils.of(b, c));\n+        AttributeValue p3 = AttributeValue.projection(ListUtils.of(a, b, c));\n+        AttributeValue p4 = AttributeValue.projection(ListUtils.of(a));\n+        AttributeComparator comparator = AttributeComparator.CONTAINS;\n+\n+        assertThat(comparator.compare(p1, p2, false), equalTo(true));\n+        assertThat(comparator.compare(p3, p3, false), equalTo(true));\n+        assertThat(comparator.compare(p3, p2, false), equalTo(true));\n+        assertThat(comparator.compare(p4, p2, false), equalTo(false));\n+    }\n+\n+    @Test\n+    public void projectionsExistIfTheyHaveValues() {\n+        AttributeComparator comparator = AttributeComparator.EXISTS;\n+        AttributeValue trueValue = AttributeValue.literal(\"true\");\n+        AttributeValue a = AttributeValue.literal(\"a\");\n+\n+        assertThat(comparator.compare(AttributeValue.projection(ListUtils.of(a)), trueValue, false), equalTo(true));\n+        assertThat(comparator.compare(AttributeValue.projection(ListUtils.of()), trueValue, false), equalTo(false));\n+    }\n+\n+    @Test\n+    public void projectionsReturnsFirstValue() {\n+        AttributeValue a = AttributeValue.literal(\"a\");\n+        AttributeValue projection = AttributeValue.projection(ListUtils.of(a));\n+\n+        assertThat(projection.getProperty(\"(first)\").toString(), equalTo(a.toString()));\n+    }\n+\n+    @Test\n+    public void projectionsFirstValueReturnsEmptyWhenEmpty() {\n+        AttributeValue projection = AttributeValue.projection(ListUtils.of());\n+\n+        assertThat(projection.getProperty(\"(first)\"), is(AttributeValue.emptyValue()));\n+    }\n+\n+    @Test\n+    public void projectionReturnsResultOfEachContainedValue() {\n+        AttributeValue a = AttributeValue.node(Node.objectNode().withMember(\"foo\", 1));\n+        AttributeValue b = AttributeValue.node(Node.objectNode().withMember(\"foo\", 2));\n+        AttributeValue c = AttributeValue.node(Node.objectNode().withMember(\"foo\", 3));\n+        AttributeValue projection = AttributeValue.projection(ListUtils.of(a, b, c));\n+        Collection<? extends AttributeValue> values = projection.getProperty(\"foo\").getFlattenedValues();\n+        List<String> strings = values.stream().map(AttributeValue::toString).collect(Collectors.toList());\n+\n+        assertThat(strings, contains(\"1\", \"2\", \"3\"));\n+    }\n+\n+    @Test\n+    public void createsServiceValue() {", "originalCommit": "933fedd8edd3821e0c42b31151d5ed5766b6488d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyNTc4MA==", "url": "https://github.com/awslabs/smithy/pull/403#discussion_r418325780", "bodyText": "Comment seems wrong, these enums aren't empty in the model.", "author": "kstich", "createdAt": "2020-04-30T22:30:46Z", "path": "smithy-model/src/test/java/software/amazon/smithy/model/selector/SpecIntegTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package software.amazon.smithy.model.selector;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+\n+import java.util.Set;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import software.amazon.smithy.model.Model;\n+\n+/**\n+ * This is a kind of integration test of the examples in the\n+ * specification.\n+ *\n+ * Each test \"category\" is prefixed with \"[name]_\" to group them.\n+ *\n+ * TODO: It would be great to consolidate other tests from SelectorTest here to better organize tests.\n+ */\n+public class SpecIntegTest {\n+\n+    private static Model allowedTagsModel;\n+    private static Model attributeExistenceModel;\n+\n+    @BeforeAll\n+    public static void before() {\n+        attributeExistenceModel =  Model.assembler()\n+                .addImport(SelectorTest.class.getResource(\"attribute-existence.smithy\"))\n+                .assemble()\n+                .unwrap();\n+        allowedTagsModel = Model.assembler()\n+                .addImport(SelectorTest.class.getResource(\"allowed-tags-example.smithy\"))\n+                .assemble()\n+                .unwrap();\n+    }\n+\n+    @Test\n+    public void attributeExistence_MatchesShapesWithTrait() {\n+        // Simple existence check.\n+        assertThat(SelectorTest.exampleIds(attributeExistenceModel, \"[trait|deprecated]\"),\n+                   containsInAnyOrder(\"smithy.example#DeprecatedString\"));\n+\n+        // Empty tags traits still exist.\n+        assertThat(SelectorTest.exampleIds(attributeExistenceModel, \"[trait|tags]\"),\n+                   containsInAnyOrder(\"smithy.example#MyString2\"));\n+\n+        // Empty enum traits still exist.", "originalCommit": "933fedd8edd3821e0c42b31151d5ed5766b6488d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyNjI2MQ==", "url": "https://github.com/awslabs/smithy/pull/403#discussion_r418326261", "bodyText": "Does this model need to contain a string with an enum that has an empty tags array in its definition to properly test this?", "author": "kstich", "createdAt": "2020-04-30T22:32:05Z", "path": "smithy-model/src/test/java/software/amazon/smithy/model/selector/SpecIntegTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package software.amazon.smithy.model.selector;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+\n+import java.util.Set;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import software.amazon.smithy.model.Model;\n+\n+/**\n+ * This is a kind of integration test of the examples in the\n+ * specification.\n+ *\n+ * Each test \"category\" is prefixed with \"[name]_\" to group them.\n+ *\n+ * TODO: It would be great to consolidate other tests from SelectorTest here to better organize tests.\n+ */\n+public class SpecIntegTest {\n+\n+    private static Model allowedTagsModel;\n+    private static Model attributeExistenceModel;\n+\n+    @BeforeAll\n+    public static void before() {\n+        attributeExistenceModel =  Model.assembler()\n+                .addImport(SelectorTest.class.getResource(\"attribute-existence.smithy\"))\n+                .assemble()\n+                .unwrap();\n+        allowedTagsModel = Model.assembler()\n+                .addImport(SelectorTest.class.getResource(\"allowed-tags-example.smithy\"))\n+                .assemble()\n+                .unwrap();\n+    }\n+\n+    @Test\n+    public void attributeExistence_MatchesShapesWithTrait() {\n+        // Simple existence check.\n+        assertThat(SelectorTest.exampleIds(attributeExistenceModel, \"[trait|deprecated]\"),\n+                   containsInAnyOrder(\"smithy.example#DeprecatedString\"));\n+\n+        // Empty tags traits still exist.\n+        assertThat(SelectorTest.exampleIds(attributeExistenceModel, \"[trait|tags]\"),\n+                   containsInAnyOrder(\"smithy.example#MyString2\"));\n+\n+        // Empty enum traits still exist.\n+        assertThat(SelectorTest.exampleIds(attributeExistenceModel, \"[trait|enum]\"),\n+                   containsInAnyOrder(\"smithy.example#MyString3\",\n+                                      \"smithy.example#MyString4\",\n+                                      \"smithy.example#MyString5\"));\n+    }\n+\n+    @Test\n+    public void attributeExistence_MatchesShapesWithProjection() {\n+        // Empty projections don't exist.\n+        assertThat(SelectorTest.exampleIds(attributeExistenceModel, \"[trait|tags|(values)]\"), empty());\n+\n+        // An empty projection does not exist.\n+        assertThat(SelectorTest.exampleIds(attributeExistenceModel, \"[trait|enum|(values)]\"),\n+                   containsInAnyOrder(\"smithy.example#MyString3\",\n+                                      \"smithy.example#MyString4\",\n+                                      \"smithy.example#MyString5\"));\n+\n+        assertThat(SelectorTest.exampleIds(attributeExistenceModel, \"[trait|enum|(values)|tags]\"),\n+                   containsInAnyOrder(\"smithy.example#MyString5\"));\n+\n+        // An empty projection does not exist.", "originalCommit": "933fedd8edd3821e0c42b31151d5ed5766b6488d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM4MDU5Ng==", "url": "https://github.com/awslabs/smithy/pull/403#discussion_r418380596", "bodyText": "Eh, this is a grey area -- lots of traits will omit an array if the array is empty, meaning that it's not going to match a selector.", "author": "mtdowling", "createdAt": "2020-05-01T01:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyNjI2MQ=="}], "type": "inlineReview"}, {"oid": "f30ea4ee1e37657a0f8b6062f8f2b3aadb89a272", "url": "https://github.com/awslabs/smithy/commit/f30ea4ee1e37657a0f8b6062f8f2b3aadb89a272", "message": "Optimize AndSelector and clean up JMH\n\nThe benchmark wasn't previously actually matching any shapes, som that's\nbeen addressed. Further, I found that unrolling cases of the AndSelector\nwhen it's created resulted in a 40% performance improvement.", "committedDate": "2020-05-01T00:42:52Z", "type": "commit"}, {"oid": "6ca7d78045562b9ef9ae6393428eca6452c8f8eb", "url": "https://github.com/awslabs/smithy/commit/6ca7d78045562b9ef9ae6393428eca6452c8f8eb", "message": "Address selector CR feedback, cache toString\n\nThic commit addresses Selector CR feedback and also caches converting an\nAttributeValue to a String or to a message string (renamed debugString\nto toMessageString). This commit also further cuts down the kinds of\nvalues that can be converted to a message string (e.g., a\nVariableAttribute now returns \"\" instead of the JSON representation to\nmake this easier to specify later when we add support for templated\nerror messages in EmitEachSelector).", "committedDate": "2020-05-01T02:27:24Z", "type": "commit"}, {"oid": "6ca7d78045562b9ef9ae6393428eca6452c8f8eb", "url": "https://github.com/awslabs/smithy/commit/6ca7d78045562b9ef9ae6393428eca6452c8f8eb", "message": "Address selector CR feedback, cache toString\n\nThic commit addresses Selector CR feedback and also caches converting an\nAttributeValue to a String or to a message string (renamed debugString\nto toMessageString). This commit also further cuts down the kinds of\nvalues that can be converted to a message string (e.g., a\nVariableAttribute now returns \"\" instead of the JSON representation to\nmake this easier to specify later when we add support for templated\nerror messages in EmitEachSelector).", "committedDate": "2020-05-01T02:27:24Z", "type": "forcePushed"}, {"oid": "1ec65379714ba22df31f440cedac4789a5680781", "url": "https://github.com/awslabs/smithy/commit/1ec65379714ba22df31f440cedac4789a5680781", "message": "Make JMH selector comparisons more fair\n\nThe updated selector now avoids needing to capture an intermediate\nvariable and use projection scoped attribute comparisons.", "committedDate": "2020-05-01T02:52:16Z", "type": "commit"}, {"oid": "90c35765a7b60899744960601b0a4ed52b7a2719", "url": "https://github.com/awslabs/smithy/commit/90c35765a7b60899744960601b0a4ed52b7a2719", "message": "Terminate predicates on the first result\n\nSelectors weren't terminating :not and :test selector predicates early when\nthey matched their first result. They don't care about more than one result,\nbut previously, their predicates could continue to emit shapes even after\nthe first match. InternalSelectors now return false to instruct senders\nthat they no longer need additional shapes.", "committedDate": "2020-05-01T04:05:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxOTYzMQ==", "url": "https://github.com/awslabs/smithy/pull/403#discussion_r418619631", "bodyText": "Should this be final and non-public?", "author": "kstich", "createdAt": "2020-05-01T16:29:19Z", "path": "smithy-model/src/main/java/software/amazon/smithy/model/selector/VariableStoreSelector.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.model.selector;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import software.amazon.smithy.model.shapes.Shape;\n+\n+/**\n+ * Stores a variable in the {@link Context} object using a selector.\n+ *\n+ * <p>The result of evaluating the selector is stored in the {@code Context}\n+ * using the given variable name. This selector is much like the ':test()'\n+ * function in that it does not change the current node. Selectors run after\n+ * a {@code VariableStoreSelector} start processing shapes from the same\n+ * point that the variable capture occurred.\n+ */\n+public class VariableStoreSelector implements InternalSelector {", "originalCommit": "90c35765a7b60899744960601b0a4ed52b7a2719", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "52c7d39b4a381653ab59b094f20c6b6d1e19f89f", "url": "https://github.com/awslabs/smithy/commit/52c7d39b4a381653ab59b094f20c6b6d1e19f89f", "message": "Make VariableStoreSelector package-private final", "committedDate": "2020-05-01T17:02:37Z", "type": "commit"}]}