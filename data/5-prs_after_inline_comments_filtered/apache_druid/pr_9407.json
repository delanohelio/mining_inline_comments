{"pr_number": 9407, "pr_title": "query laning and load shedding", "pr_createdAt": "2020-02-26T12:21:22Z", "pr_url": "https://github.com/apache/druid/pull/9407", "timeline": [{"oid": "6220985559b4fa941e25e61caa5846c7ce8e368a", "url": "https://github.com/apache/druid/commit/6220985559b4fa941e25e61caa5846c7ce8e368a", "message": "prototype", "committedDate": "2020-02-25T10:48:47Z", "type": "commit"}, {"oid": "3f410014da090c7df66df293a1894da3486cabaa", "url": "https://github.com/apache/druid/commit/3f410014da090c7df66df293a1894da3486cabaa", "message": "merge QueryScheduler and QueryManager", "committedDate": "2020-02-25T10:48:47Z", "type": "commit"}, {"oid": "feae8b193d73354366ce683c0ef405e366c8e31b", "url": "https://github.com/apache/druid/commit/feae8b193d73354366ce683c0ef405e366c8e31b", "message": "everything in its right place", "committedDate": "2020-02-25T10:48:47Z", "type": "commit"}, {"oid": "554b8b514a6c92d04f806960eaf33ebb366ab21a", "url": "https://github.com/apache/druid/commit/554b8b514a6c92d04f806960eaf33ebb366ab21a", "message": "adjustments", "committedDate": "2020-02-25T18:41:00Z", "type": "commit"}, {"oid": "0597c3f87117a8f35785a3cea7ba8f9b4e7e8511", "url": "https://github.com/apache/druid/commit/0597c3f87117a8f35785a3cea7ba8f9b4e7e8511", "message": "docs", "committedDate": "2020-02-26T12:15:34Z", "type": "commit"}, {"oid": "405c94e52988ebb1381b3e9337e1d6ff11331ada", "url": "https://github.com/apache/druid/commit/405c94e52988ebb1381b3e9337e1d6ff11331ada", "message": "fixes", "committedDate": "2020-02-27T11:38:39Z", "type": "commit"}, {"oid": "e22ece12861765ec3eeccc6531c283e717785969", "url": "https://github.com/apache/druid/commit/e22ece12861765ec3eeccc6531c283e717785969", "message": "doc fixes", "committedDate": "2020-02-28T00:11:50Z", "type": "commit"}, {"oid": "e98cad76992ced1659ab75834bab7a8967eaa33e", "url": "https://github.com/apache/druid/commit/e98cad76992ced1659ab75834bab7a8967eaa33e", "message": "use resilience4j instead of semaphore", "committedDate": "2020-02-28T05:48:15Z", "type": "commit"}, {"oid": "2069437298c6b111804d0fd18034514c47ae8f1b", "url": "https://github.com/apache/druid/commit/2069437298c6b111804d0fd18034514c47ae8f1b", "message": "more tests", "committedDate": "2020-02-28T06:59:43Z", "type": "commit"}, {"oid": "eaf1449a360506a85257f16abe25201875af8387", "url": "https://github.com/apache/druid/commit/eaf1449a360506a85257f16abe25201875af8387", "message": "simplify", "committedDate": "2020-02-28T08:42:09Z", "type": "commit"}, {"oid": "688ca43af1f246dd6578e2ace96778cdb3571cff", "url": "https://github.com/apache/druid/commit/688ca43af1f246dd6578e2ace96778cdb3571cff", "message": "checkstyle", "committedDate": "2020-02-28T11:09:06Z", "type": "commit"}, {"oid": "f0b3f9f02be406e42e8fa523716c630d2b21aa36", "url": "https://github.com/apache/druid/commit/f0b3f9f02be406e42e8fa523716c630d2b21aa36", "message": "spelling", "committedDate": "2020-02-28T19:11:38Z", "type": "commit"}, {"oid": "87c6cbd1660d4981fc3618feed9210f91a218ca5", "url": "https://github.com/apache/druid/commit/87c6cbd1660d4981fc3618feed9210f91a218ca5", "message": "oops heh", "committedDate": "2020-02-28T22:15:22Z", "type": "commit"}, {"oid": "5e91bcba6661334d8b6d6dc745ce2cd68037ca0e", "url": "https://github.com/apache/druid/commit/5e91bcba6661334d8b6d6dc745ce2cd68037ca0e", "message": "remove unused", "committedDate": "2020-02-28T22:17:34Z", "type": "commit"}, {"oid": "912b7bc43d5406114f85e85918e04b8c01a9bf7f", "url": "https://github.com/apache/druid/commit/912b7bc43d5406114f85e85918e04b8c01a9bf7f", "message": "simplify", "committedDate": "2020-02-29T03:07:33Z", "type": "commit"}, {"oid": "1e384bf9e4d8c2cae1cf12e894aa2afa00e9a9c1", "url": "https://github.com/apache/druid/commit/1e384bf9e4d8c2cae1cf12e894aa2afa00e9a9c1", "message": "concurrency tests", "committedDate": "2020-03-02T11:48:27Z", "type": "commit"}, {"oid": "60861a43fd25bca15aa3215988252bc392b3ad3f", "url": "https://github.com/apache/druid/commit/60861a43fd25bca15aa3215988252bc392b3ad3f", "message": "add SqlResource tests, refactor error response", "committedDate": "2020-03-03T06:02:13Z", "type": "commit"}, {"oid": "9aed16e6ca23d413d30554ebfd8157210849e67b", "url": "https://github.com/apache/druid/commit/9aed16e6ca23d413d30554ebfd8157210849e67b", "message": "add json config tests", "committedDate": "2020-03-04T01:13:23Z", "type": "commit"}, {"oid": "419ab98ef48eb0a7590bb064393c424a553d3544", "url": "https://github.com/apache/druid/commit/419ab98ef48eb0a7590bb064393c424a553d3544", "message": "use LongAdder instead of AtomicLong", "committedDate": "2020-03-04T01:19:13Z", "type": "commit"}, {"oid": "f0d39e1dd4108c9ee803fd6335c515813a892d14", "url": "https://github.com/apache/druid/commit/f0d39e1dd4108c9ee803fd6335c515813a892d14", "message": "remove test only stuffs from scheduler", "committedDate": "2020-03-04T02:04:05Z", "type": "commit"}, {"oid": "2afaaf1150b7808e8543e87eecf45ecd9bf8b9fe", "url": "https://github.com/apache/druid/commit/2afaaf1150b7808e8543e87eecf45ecd9bf8b9fe", "message": "javadocs, etc", "committedDate": "2020-03-04T11:45:53Z", "type": "commit"}, {"oid": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "url": "https://github.com/apache/druid/commit/ef029c4a894aafd4b17ca903e77ae497e41034ba", "message": "style", "committedDate": "2020-03-04T12:13:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTc4NA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r387991784", "bodyText": "Was this added to the docs?", "author": "ccaominh", "createdAt": "2020-03-04T23:16:48Z", "path": "processing/src/main/java/org/apache/druid/query/QueryContexts.java", "diffHunk": "@@ -35,6 +35,7 @@\n public class QueryContexts\n {\n   public static final String PRIORITY_KEY = \"priority\";\n+  public static final String LANE_KEY = \"lane\";", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1NTUzNA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388755534", "bodyText": "No, I hadn't documented since I hadn't decided the behavior of whether or not a lane specified in the query context by the user should override the laning strategy, or if it should be laning strategy specific, see other comment about this", "author": "clintropolis", "createdAt": "2020-03-06T07:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5MTc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5OTE0OA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r387999148", "bodyText": "There's some similarity between this and QueryInterruptedException and ResourceLimitExceededException and at first glance it may be unclear when to use which (perhaps mitigated by adding javadocs to this class). Is there a way to incorporate this into the same pattern in the QueryInterruptedException implementation?", "author": "ccaominh", "createdAt": "2020-03-04T23:38:35Z", "path": "server/src/main/java/org/apache/druid/server/QueryCapacityExceededException.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.QueryException;\n+\n+public class QueryCapacityExceededException extends QueryException", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1MjQzMQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388752431", "bodyText": "I think I would agree that this area probably needs a refactor, maybe more suitable to be done in a follow-up PR, but will try to at least add some javadocs to clarify that the QueryExceptions are intended to be the main exceptions we surface from the API provided by QueryResource and SqlResource. Currently QueryInterruptedException is specifically caught and tied to HTTP 500 errors in these classes, so I split out QueryCapacityExceededException so that I could catch it separately and respond with the 429 status code (or 503, whatever we end up going with).", "author": "clintropolis", "createdAt": "2020-03-06T07:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk5OTE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMjk5OQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388012999", "bodyText": "Is it useful to test when QueryContexts.LANE_KEY is set?", "author": "ccaominh", "createdAt": "2020-03-05T00:23:34Z", "path": "server/src/test/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategyTest.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.query.Druids;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.timeseries.TimeseriesQuery;\n+import org.apache.druid.server.QueryLaningStrategy;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+public class HiLoQueryLaningStrategyTest\n+{\n+  @Rule\n+  public ExpectedException expectedException = ExpectedException.none();\n+\n+  private Druids.TimeseriesQueryBuilder queryBuilder;\n+  private HiLoQueryLaningStrategy strategy;\n+\n+  @Before\n+  public void setup()\n+  {\n+    this.queryBuilder = Druids.newTimeseriesQueryBuilder()\n+                              .dataSource(\"test\")\n+                              .intervals(ImmutableList.of(Intervals.ETERNITY))\n+                              .granularity(Granularities.DAY)\n+                              .aggregators(new CountAggregatorFactory(\"count\"));\n+\n+    this.strategy = new HiLoQueryLaningStrategy(10);\n+  }\n+\n+  @Test\n+  public void testMaxLowThreadsRequired()\n+  {\n+    expectedException.expect(NullPointerException.class);\n+    expectedException.expectMessage(\"maxLowThreads must be set\");\n+    QueryLaningStrategy strategy = new HiLoQueryLaningStrategy(null);\n+  }\n+\n+  @Test\n+  public void testLaneLimits()\n+  {\n+    Object2IntMap<String> laneConfig = strategy.getLaneLimits();\n+    Assert.assertEquals(1, laneConfig.size());\n+    Assert.assertTrue(laneConfig.containsKey(HiLoQueryLaningStrategy.LOW));\n+    Assert.assertEquals(10, laneConfig.getInt(HiLoQueryLaningStrategy.LOW));\n+  }\n+\n+  @Test\n+  public void testLaningNoPriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.build();\n+    Assert.assertFalse(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+  }\n+\n+  @Test\n+  public void testLaningZeroPriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.context(ImmutableMap.of(QueryContexts.PRIORITY_KEY, 0)).build();\n+    Assert.assertFalse(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+  }\n+\n+  @Test\n+  public void testLaningInteractivePriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.context(ImmutableMap.of(QueryContexts.PRIORITY_KEY, 100)).build();\n+    Assert.assertFalse(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+  }\n+\n+  @Test\n+  public void testLaningLowPriority()\n+  {\n+    TimeseriesQuery query = queryBuilder.context(ImmutableMap.of(QueryContexts.PRIORITY_KEY, -1)).build();\n+    Assert.assertTrue(strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).isPresent());\n+    Assert.assertEquals(\n+        HiLoQueryLaningStrategy.LOW,\n+        strategy.computeLane(QueryPlus.wrap(query), ImmutableSet.of()).get()\n+    );\n+  }\n+}", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1NDE4Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388754187", "bodyText": "Hmm, I'm not yet quite sure if not allowing a laning strategy to override the manually set context value is the correct behavior yet, so I didn't add a test.\nDo you have any thoughts on whether or not to replace an explicit, user specified lane be delegated to the laning strategy? The more I think about it the more I think the laning strategy should get to choose, so I think I'm going to change the behavior. If we still think that hilo should honor the user specified lane, then I can add a test for that (or add a test that it is overridden if we decide to go in the other direction).", "author": "clintropolis", "createdAt": "2020-03-06T07:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMjk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3Mjg0OQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389072849", "bodyText": "Since the user can select a lane by setting the priority in the query context, I'm not sure of the benefit of also having a lane in the query context. Later, when there's automatic setting of the lane/priority, I think it should first respect the value in the query context if there's one before applying the automatic behavior.", "author": "ccaominh", "createdAt": "2020-03-06T18:35:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMjk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MTA5Mw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389161093", "bodyText": "I think there are a few reasons to put it on the query context. For one to propagate the value downstream to historical and realtime tasks so they can utilize that information in the future to also make load management decisions.\nBut also, I'm not sure that lane necessarily has to be related to priority just because the current implementation I have provided is. It is really just a label used to enforce limits.\nIn my list of potential follow-up work, I wanted to support a manual laning strategy that only supports explicit use defined lanes on the context both to make integration tests easier but also just to account for scenarios where an external application drives these decisions and still wishes to enforce limits on classes of queries. I also suggested a tier based laning strategy, which would not be related to priority, but rather the set of servers it is going to be querying.", "author": "clintropolis", "createdAt": "2020-03-06T21:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxMjk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAxNjU0Ng==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388016546", "bodyText": "Left a comment in the docs about the property name", "author": "ccaominh", "createdAt": "2020-03-05T00:35:56Z", "path": "server/src/main/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Query laning strategy which associates all {@link Query} with priority lower than 0 into a 'low' lane\n+ */\n+public class HiLoQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  public static final String LOW = \"low\";\n+\n+  @JsonProperty\n+  private final int maxLowThreads;\n+\n+  @JsonCreator\n+  public HiLoQueryLaningStrategy(\n+      @JsonProperty(\"maxLowThreads\") Integer maxLowThreads", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMTg1MQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388631851", "bodyText": "Thanks for adding all the javadocs that were missing before!", "author": "ccaominh", "createdAt": "2020-03-05T23:51:24Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjI1Ng==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388632256", "bodyText": "Consider adding a named constant for the -1 (similar for getLaneAvailableCapacity)", "author": "ccaominh", "createdAt": "2020-03-05T23:52:49Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1OTcyMw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388659723", "bodyText": "May be better to do this in a exception handler in case there's an unexpected error between the two acquisitions. I don't think there's a test for this scenario?", "author": "ccaominh", "createdAt": "2020-03-06T01:05:11Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  public int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want\n+    // to check for total capacity exceeded and release the lane (if present) before throwing capacity exceeded\n+    totalConfig.ifPresent(config -> {\n+      Bulkhead totalLimiter = laneRegistry.bulkhead(TOTAL, config);\n+      if (!totalLimiter.tryAcquirePermission()) {\n+        releaseLanes(hallPasses);", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1OTIyMA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388759220", "bodyText": "Hmm, I couldn't find an exception that would be thrown in this block, tryAcquirePermission eats InterruptedException and also the timeout is configured to 0 so the underlying semaphore call takes a code path that shouldn't explode, so I imagined any exception that happens where would be indicative of a catastrophic failure or the jetty server shutting down.\nThat said, I guess it doesn't harm much to wrap in a try catch and rethrow after releasing.\nThis isn't explicitly tested for, but a shadow of it being tested is visible in the concurrency tests which flex the case where a lane was acquired but the total could not be in this assert that the 'lane released' count is equal to the 'lane acquired' + 'lane not acquired' count which fails if we don't consider the 'lane not acquired' count.", "author": "clintropolis", "createdAt": "2020-03-06T08:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY1OTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2MjA1MQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388662051", "bodyText": "Maybe rename to \"bulkhead\"", "author": "ccaominh", "createdAt": "2020-03-06T01:08:33Z", "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.inject.Injector;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import org.apache.druid.guice.GuiceInjectors;\n+import org.apache.druid.guice.JsonConfigProvider;\n+import org.apache.druid.guice.JsonConfigurator;\n+import org.apache.druid.guice.annotations.Global;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.BaseSequence;\n+import org.apache.druid.java.util.common.guava.LazySequence;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.java.util.common.guava.SequenceWrapper;\n+import org.apache.druid.java.util.common.guava.Sequences;\n+import org.apache.druid.java.util.common.guava.Yielder;\n+import org.apache.druid.java.util.common.guava.Yielders;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.topn.TopNQuery;\n+import org.apache.druid.query.topn.TopNQueryBuilder;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class QuerySchedulerTest\n+{\n+  private static final int NUM_CONCURRENT_QUERIES = 10000;\n+  private static final int NUM_ROWS = 10000;\n+\n+  @Rule\n+  public ExpectedException expected = ExpectedException.none();\n+\n+  private ListeningExecutorService executorService;\n+  private QueryScheduler scheduler;\n+\n+  private AtomicLong totalAcquired;\n+  private AtomicLong totalReleased;\n+  private AtomicLong laneAcquired;\n+  private AtomicLong laneNotAcquired;\n+  private AtomicLong laneReleased;\n+\n+  @Before\n+  public void setup()\n+  {\n+    executorService = MoreExecutors.listeningDecorator(\n+        Execs.multiThreaded(8, \"test_query_scheduler_%s\")\n+    );\n+    totalAcquired = new AtomicLong();\n+    totalReleased = new AtomicLong();\n+    laneAcquired = new AtomicLong();\n+    laneNotAcquired = new AtomicLong();\n+    laneReleased = new AtomicLong();\n+    scheduler = new QueryScheduler(5, new HiLoQueryLaningStrategy(2)) {\n+      @Override\n+      List<Bulkhead> acquireLanes(Query<?> query)\n+      {\n+        List<Bulkhead> bulkheads = super.acquireLanes(query);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalAcquired.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneAcquired.incrementAndGet();\n+        }\n+\n+        return bulkheads;\n+      }\n+\n+      @Override\n+      void releaseLanes(List<Bulkhead> bulkheads)\n+      {\n+        super.releaseLanes(bulkheads);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalReleased.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneReleased.incrementAndGet();\n+          if (bulkheads.size() == 1) {\n+            laneNotAcquired.incrementAndGet();\n+          }\n+        }\n+      }\n+    };\n+  }\n+\n+  @After\n+  public void teardown()\n+  {\n+    executorService.shutdownNow();\n+  }\n+\n+  @Test\n+  public void testHiLoHi() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery interactive = makeInteractiveQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduled = scheduler.laneQuery(QueryPlus.wrap(interactive), ImmutableSet.of());\n+\n+        Assert.assertNotNull(scheduled);\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduled, underlyingSequence);\n+        int rowCount = consumeAndCloseSequence(results);\n+\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+  }\n+\n+  @Test\n+  public void testHiLoLo() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery report = makeReportQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduledReport = scheduler.laneQuery(QueryPlus.wrap(report), ImmutableSet.of());\n+        Assert.assertNotNull(scheduledReport);\n+        Assert.assertEquals(HiLoQueryLaningStrategy.LOW, QueryContexts.getLane(scheduledReport));\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduledReport, underlyingSequence);\n+\n+        int rowCount = consumeAndCloseSequence(results);\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+  }\n+\n+  @Test\n+  public void testHiLoReleaseSemaphoreWhenSequenceExplodes() throws Exception", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2MzE4Ng==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388663186", "bodyText": "This assert is not executed. Maybe use an exception handler instead of expected?", "author": "ccaominh", "createdAt": "2020-03-06T01:11:05Z", "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -0,0 +1,566 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.ListeningExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.inject.Injector;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import org.apache.druid.guice.GuiceInjectors;\n+import org.apache.druid.guice.JsonConfigProvider;\n+import org.apache.druid.guice.JsonConfigurator;\n+import org.apache.druid.guice.annotations.Global;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.BaseSequence;\n+import org.apache.druid.java.util.common.guava.LazySequence;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.java.util.common.guava.SequenceWrapper;\n+import org.apache.druid.java.util.common.guava.Sequences;\n+import org.apache.druid.java.util.common.guava.Yielder;\n+import org.apache.druid.java.util.common.guava.Yielders;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.topn.TopNQuery;\n+import org.apache.druid.query.topn.TopNQueryBuilder;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class QuerySchedulerTest\n+{\n+  private static final int NUM_CONCURRENT_QUERIES = 10000;\n+  private static final int NUM_ROWS = 10000;\n+\n+  @Rule\n+  public ExpectedException expected = ExpectedException.none();\n+\n+  private ListeningExecutorService executorService;\n+  private QueryScheduler scheduler;\n+\n+  private AtomicLong totalAcquired;\n+  private AtomicLong totalReleased;\n+  private AtomicLong laneAcquired;\n+  private AtomicLong laneNotAcquired;\n+  private AtomicLong laneReleased;\n+\n+  @Before\n+  public void setup()\n+  {\n+    executorService = MoreExecutors.listeningDecorator(\n+        Execs.multiThreaded(8, \"test_query_scheduler_%s\")\n+    );\n+    totalAcquired = new AtomicLong();\n+    totalReleased = new AtomicLong();\n+    laneAcquired = new AtomicLong();\n+    laneNotAcquired = new AtomicLong();\n+    laneReleased = new AtomicLong();\n+    scheduler = new QueryScheduler(5, new HiLoQueryLaningStrategy(2)) {\n+      @Override\n+      List<Bulkhead> acquireLanes(Query<?> query)\n+      {\n+        List<Bulkhead> bulkheads = super.acquireLanes(query);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalAcquired.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneAcquired.incrementAndGet();\n+        }\n+\n+        return bulkheads;\n+      }\n+\n+      @Override\n+      void releaseLanes(List<Bulkhead> bulkheads)\n+      {\n+        super.releaseLanes(bulkheads);\n+        if (bulkheads.stream().anyMatch(b -> b.getName().equals(QueryScheduler.TOTAL))) {\n+          totalReleased.incrementAndGet();\n+        }\n+        if (bulkheads.stream().anyMatch(b -> !b.getName().equals(QueryScheduler.TOTAL))) {\n+          laneReleased.incrementAndGet();\n+          if (bulkheads.size() == 1) {\n+            laneNotAcquired.incrementAndGet();\n+          }\n+        }\n+      }\n+    };\n+  }\n+\n+  @After\n+  public void teardown()\n+  {\n+    executorService.shutdownNow();\n+  }\n+\n+  @Test\n+  public void testHiLoHi() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery interactive = makeInteractiveQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduled = scheduler.laneQuery(QueryPlus.wrap(interactive), ImmutableSet.of());\n+\n+        Assert.assertNotNull(scheduled);\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduled, underlyingSequence);\n+        int rowCount = consumeAndCloseSequence(results);\n+\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+  }\n+\n+  @Test\n+  public void testHiLoLo() throws ExecutionException, InterruptedException\n+  {\n+    TopNQuery report = makeReportQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduledReport = scheduler.laneQuery(QueryPlus.wrap(report), ImmutableSet.of());\n+        Assert.assertNotNull(scheduledReport);\n+        Assert.assertEquals(HiLoQueryLaningStrategy.LOW, QueryContexts.getLane(scheduledReport));\n+\n+        Sequence<Integer> underlyingSequence = makeSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+            Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduledReport, underlyingSequence);\n+\n+        int rowCount = consumeAndCloseSequence(results);\n+        Assert.assertEquals(10, rowCount);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(HiLoQueryLaningStrategy.LOW));\n+  }\n+\n+  @Test\n+  public void testHiLoReleaseSemaphoreWhenSequenceExplodes() throws Exception\n+  {\n+    expected.expectMessage(\"exploded\");\n+    expected.expect(ExecutionException.class);\n+    TopNQuery interactive = makeInteractiveQuery();\n+    ListenableFuture<?> future = executorService.submit(() -> {\n+      try {\n+        Query<?> scheduled = scheduler.laneQuery(QueryPlus.wrap(interactive), ImmutableSet.of());\n+\n+        Assert.assertNotNull(scheduled);\n+\n+        Sequence<Integer> underlyingSequence = makeExplodingSequence(10);\n+        underlyingSequence = Sequences.wrap(underlyingSequence, new SequenceWrapper()\n+        {\n+          @Override\n+          public void before()\n+          {\n+            Assert.assertEquals(4, scheduler.getTotalAvailableCapacity());\n+          }\n+        });\n+        Sequence<Integer> results = scheduler.run(scheduled, underlyingSequence);\n+\n+        consumeAndCloseSequence(results);\n+      }\n+      catch (IOException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+    });\n+    future.get();\n+    Assert.assertEquals(5, scheduler.getTotalAvailableCapacity());", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MTkxNA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388761914", "bodyText": "Ah, i think that was a leftover from copying another test to make this one, but I think it does seem useful to assert that the token was released after the exception so will change", "author": "clintropolis", "createdAt": "2020-03-06T08:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2MzE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NTY1NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388665655", "bodyText": "This and the method below are public but they appear to just be used in the unit test.", "author": "ccaominh", "createdAt": "2020-03-06T01:20:30Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjM1OA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388666358", "bodyText": "What's the purpose of the TOTAL bulkhead if each lane has a bulkhead?", "author": "ccaominh", "createdAt": "2020-03-06T01:23:02Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(totalNumThreads));\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  public int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  public int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1NDU2OQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388754569", "bodyText": "the total is to control overall query throughput, and is tied to druid.query.scheduler.numThreads. Even queries without a lane are subject to this limit, if configured. I'll try to make this more clear in the javadocs or comments.", "author": "clintropolis", "createdAt": "2020-03-06T07:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3Mzc4Mg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389073782", "bodyText": "I was thinking that if there are only counters per lane, then the code would be simpler as the lane and total counter would not have to be kept consistent.", "author": "ccaominh", "createdAt": "2020-03-06T18:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1OTIzMw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389159233", "bodyText": "that is true, but I wanted to dual purpose this to also be able to set total limits to protect the rest of the service from the query processing system, and save room for health checks and the like.\nAs I discussed in the description, I considered that the total counter specifically might be suitable as a jetty QoSFilter, which also is using a semaphore, however we would need to ensure that we set the request timeout high enough to give the laned queries time to fail and release the semaphore since the total would now be getting acquired before the lane. It seemed easier to me to track here than to precisely determine that interval, however the discussion is worth having I think.", "author": "clintropolis", "createdAt": "2020-03-06T21:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NjU4Mg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388666582", "bodyText": "Missing blank line", "author": "ccaominh", "createdAt": "2020-03-06T01:23:44Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/CalciteTests.java", "diffHunk": "@@ -700,6 +701,14 @@ public static SpecificSegmentsQuerySegmentWalker createMockWalker(\n       final QueryRunnerFactoryConglomerate conglomerate,\n       final File tmpDir\n   )\n+  {\n+    return createMockWalker(conglomerate, tmpDir, null);\n+  }\n+  public static SpecificSegmentsQuerySegmentWalker createMockWalker(", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NzA4Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388667087", "bodyText": "Which tests cover this block?", "author": "ccaominh", "createdAt": "2020-03-06T01:25:28Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/SpecificSegmentsQuerySegmentWalker.java", "diffHunk": "@@ -388,13 +410,33 @@ public SegmentDescriptor getDescriptor()\n           toolChest\n       );\n \n+\n       // Wrap baseRunner in a runner that rewrites the QuerySegmentSpec to mention the specific segments.\n       // This mimics what CachingClusteredClient on the Broker does, and is required for certain queries (like Scan)\n       // to function properly.\n-      return (theQuery, responseContext) -> baseRunner.run(\n-          theQuery.withQuery(Queries.withSpecificSegments(theQuery.getQuery(), ImmutableList.copyOf(specs))),\n-          responseContext\n-      );\n+      return (theQuery, responseContext) -> {\n+        if (scheduler != null) {\n+          Set<SegmentServerSelector> segments = new HashSet<>();\n+          specs.forEach(spec -> segments.add(new SegmentServerSelector(null, spec)));\n+          return scheduler.run(\n+              scheduler.laneQuery(theQuery, segments),\n+              new LazySequence<>(\n+                  () -> baseRunner.run(\n+                      theQuery.withQuery(Queries.withSpecificSegments(\n+                          theQuery.getQuery(),\n+                          ImmutableList.copyOf(specs)\n+                      )),\n+                      responseContext\n+                  )\n+              )\n+          );", "originalCommit": "ef029c4a894aafd4b17ca903e77ae497e41034ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc2MTIyOA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r388761228", "bodyText": "If you mean which tests use this block, then it is the SqlResourceTest which create this thing with a scheduler.\nNo laning strategy is currently using the set of SegmentServerSelector to make decisions at this time, I just went ahead and wired it up because we do have the set of SegmentDescriptors available here, in anticipation of some future usage. With the ServerSelector part of that set to null though, we would probably want to either have a mock or artifical set of servers to pretend to serve the test segments, so it might still need some future work?", "author": "clintropolis", "createdAt": "2020-03-06T08:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2NzA4Nw=="}], "type": "inlineReview"}, {"oid": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "url": "https://github.com/apache/druid/commit/059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "message": "partial review stuffs", "committedDate": "2020-03-06T12:59:58Z", "type": "commit"}, {"oid": "0ec8a2657e9f10e84fcd41cf42fef22063fe89ac", "url": "https://github.com/apache/druid/commit/0ec8a2657e9f10e84fcd41cf42fef22063fe89ac", "message": "adjust", "committedDate": "2020-03-06T21:04:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA1MDMyOQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389050329", "bodyText": "Provide a map?", "author": "jihoonson", "createdAt": "2020-03-06T17:47:52Z", "path": "server/src/main/java/org/apache/druid/server/QueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"strategy\", defaultImpl = NoQueryLaningStrategy.class)\n+@JsonSubTypes(value = {\n+    @JsonSubTypes.Type(name = \"none\", value = NoQueryLaningStrategy.class),\n+    @JsonSubTypes.Type(name = \"hilo\", value = HiLoQueryLaningStrategy.class)\n+})\n+public interface QueryLaningStrategy\n+{\n+  /**\n+   * Provide map of lane names to the limit on the number of concurrent queries for that lane", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2NDkwMA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389064900", "bodyText": "Probably the javadoc of this method (or this class) should say that this class is used in QueryScheduler and should be thread-safe.", "author": "jihoonson", "createdAt": "2020-03-06T18:19:33Z", "path": "server/src/main/java/org/apache/druid/server/QueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"strategy\", defaultImpl = NoQueryLaningStrategy.class)\n+@JsonSubTypes(value = {\n+    @JsonSubTypes.Type(name = \"none\", value = NoQueryLaningStrategy.class),\n+    @JsonSubTypes.Type(name = \"hilo\", value = HiLoQueryLaningStrategy.class)\n+})\n+public interface QueryLaningStrategy\n+{\n+  /**\n+   * Provide map of lane names to the limit on the number of concurrent queries for that lane\n+   * @param totalLimit\n+   */\n+  Object2IntMap<String> getLaneLimits(int totalLimit);\n+\n+  /**\n+   * For a given {@link QueryPlus} and set of {@link SegmentServerSelector}, compute if a query belongs to a lane\n+   */\n+  <T> Optional<String> computeLane(QueryPlus<T> query, Set<SegmentServerSelector> segments);", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxOTIzMg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389219232", "bodyText": "added", "author": "clintropolis", "createdAt": "2020-03-07T02:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2NDkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2NjE4NA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389066184", "bodyText": "Please add a comment what the key and the value are.", "author": "jihoonson", "createdAt": "2020-03-06T18:22:16Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxOTIxNQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389219215", "bodyText": "added javadoc", "author": "clintropolis", "createdAt": "2020-03-07T02:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2NjE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3NzgyMg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389077822", "bodyText": "I find this comment confusing. There will be multiple futures of the same ID in historicals most of the time unless the query reads only one segment in a historical. Probably better to comment about what could happen in brokers and historicals.", "author": "jihoonson", "createdAt": "2020-03-06T18:46:07Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1NzUwNw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389157507", "bodyText": "Oh nvm, I thought that the historical can register multiple futures per segment for the same query which is not true. They always register only one future for one query.", "author": "jihoonson", "createdAt": "2020-03-06T21:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3NzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MjI1MA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389162250", "bodyText": "Ah, the comment was referring to the fact that query id can be manually set, like if you and I both send queries with the same id, one of us cancelling would cancel both I think.", "author": "clintropolis", "createdAt": "2020-03-06T21:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3NzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxOTIxMQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389219211", "bodyText": "I adjusted the comment to try and clear up what i was talking about", "author": "clintropolis", "createdAt": "2020-03-07T02:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3NzgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4ODYwMw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389088603", "bodyText": "Please comment that this class is used in everywhere including historicals and tasks.", "author": "jihoonson", "createdAt": "2020-03-06T19:09:14Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMTc1Ng==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389121756", "bodyText": "It seems racy that two queries can compete on a particular lane and the total lane separately. I guess it would be a better behavior if it guarantees the first-come, first-served basis.", "author": "jihoonson", "createdAt": "2020-03-06T20:13:54Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  @VisibleForTesting\n+  int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  @VisibleForTesting\n+  int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1MzMxMA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389153310", "bodyText": "yeah, it is definitely racy, but didn't seem especially harmful, is it worth the extra lock (not sure what would be most appropriate, striped on lane i guess?) we would have to hold to grab both and have truly fair behavior?", "author": "clintropolis", "createdAt": "2020-03-06T21:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMTc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3Nzk3NA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389177974", "bodyText": "Hmm I can imagine that a user issues a high-priority query immediately followed by a low-priority query. Due to the nature of concurrent execution, even if the high-priority query reached to here first, the low-priority query could execute the code before the high-priority one does. Then the high-priority query could be rejected if the low-priority query took the last available slot in the total lane.\nI guess the upside is the more deterministic and thus predictable behavior while the downside is the overhead of the extra lock. How bad is the extra lock? It seems ok?", "author": "jihoonson", "createdAt": "2020-03-06T22:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMTc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNDIwMQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389214201", "bodyText": "The lock overhead doesn't seem like it would be too much, but it also doesn't seem like it would change much, especially when queries are not in the same lane. I added some comments that discuss how the lane acquiring is not fair", "author": "clintropolis", "createdAt": "2020-03-07T01:35:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMTc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNTQxNw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389215417", "bodyText": "The comment sounds good to me. Thanks.", "author": "jihoonson", "createdAt": "2020-03-07T01:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyMTc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNDg5Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389124897", "bodyText": "nit: the javadoc of releasePermission says:\n    /**\n     * Releases a permission and increases the number of available permits by one.\n     * <p>\n     * Should only be used when a permission was acquired but not used. Otherwise use {@link\n     * Bulkhead#onComplete()} to signal a completed call and release a permission.\n     */\n    void releasePermission();\nreleasePermission() and onComplete() of SemaphoreBulkhead are:\n    @Override\n    public void releasePermission() {\n        semaphore.release();\n    }\n\n    @Override\n    public void onComplete() {\n        semaphore.release();\n        publishBulkheadEvent(() -> new BulkheadOnCallFinishedEvent(name));\n    }\nI think it's safe to call releasePermission() for now since we don't use the EventPublisher, but it still wouldn't harm to use onComplete(). It would also probably be better to avoid potential bugs if we want to use EventPublisher in the future.", "author": "jihoonson", "createdAt": "2020-03-06T20:21:23Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  @VisibleForTesting\n+  int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  @VisibleForTesting\n+  int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want\n+    // to check for total capacity exceeded and release the lane (if present) before throwing capacity exceeded\n+    totalConfig.ifPresent(config -> {\n+      Bulkhead totalLimiter = laneRegistry.bulkhead(TOTAL, config);\n+      if (!totalLimiter.tryAcquirePermission()) {\n+        releaseLanes(hallPasses);\n+        throw new QueryCapacityExceededException();\n+      }\n+      hallPasses.add(totalLimiter);\n+    });\n+    return hallPasses;\n+  }\n+\n+  /**\n+   * Release all {@link Bulkhead} semaphores in the list\n+   */\n+  @VisibleForTesting\n+  void releaseLanes(List<Bulkhead> bulkheads)\n+  {\n+    bulkheads.forEach(Bulkhead::releasePermission);", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MTg3MA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389161870", "bodyText": "good catch", "author": "clintropolis", "createdAt": "2020-03-06T21:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNDg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyNTQzNg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389125436", "bodyText": "hastotalLimit -> hasTotalLimit", "author": "jihoonson", "createdAt": "2020-03-06T20:22:36Z", "path": "server/src/main/java/org/apache/druid/server/QueryScheduler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.SetMultimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import io.github.resilience4j.bulkhead.Bulkhead;\n+import io.github.resilience4j.bulkhead.BulkheadConfig;\n+import io.github.resilience4j.bulkhead.BulkheadRegistry;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.java.util.common.concurrent.Execs;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.QueryWatcher;\n+import org.apache.druid.server.initialization.ServerConfig;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * QueryScheduler (potentially) assigns any {@link Query} that is to be executed to a 'query lane' using the\n+ * {@link QueryLaningStrategy} that is defined in {@link QuerySchedulerConfig}.\n+ *\n+ * As a {@link QueryWatcher}, it also provides cancellation facilities.\n+ *\n+ * This class is shared by all requests on the Jetty HTTP theadpool and must be thread safe.\n+ */\n+public class QueryScheduler implements QueryWatcher\n+{\n+  static final String TOTAL = \"default\";\n+  private final int totalCapacity;\n+  private final QueryLaningStrategy laningStrategy;\n+  private final BulkheadRegistry laneRegistry;\n+  private final SetMultimap<String, ListenableFuture<?>> queryFutures;\n+  private final SetMultimap<String, String> queryDatasources;\n+\n+  public QueryScheduler(int totalNumThreads, QueryLaningStrategy laningStrategy, ServerConfig serverConfig)\n+  {\n+    this.laningStrategy = laningStrategy;\n+    this.queryFutures = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    this.queryDatasources = Multimaps.synchronizedSetMultimap(HashMultimap.create());\n+    // if totalNumThreads is above 0 and less than druid.server.http.numThreads, enforce total limit\n+    final boolean limitTotal;\n+    if (totalNumThreads > 0 && totalNumThreads < serverConfig.getNumThreads()) {\n+      limitTotal = true;\n+      this.totalCapacity = totalNumThreads;\n+    } else {\n+      limitTotal = false;\n+      this.totalCapacity = serverConfig.getNumThreads();\n+    }\n+    this.laneRegistry = BulkheadRegistry.of(getLaneConfigs(limitTotal));\n+  }\n+\n+  @Override\n+  public void registerQueryFuture(Query<?> query, ListenableFuture<?> future)\n+  {\n+    final String id = query.getId();\n+    final Set<String> datasources = query.getDataSource().getTableNames();\n+    queryFutures.put(id, future);\n+    queryDatasources.putAll(id, datasources);\n+    future.addListener(\n+        () -> {\n+          queryFutures.remove(id, future);\n+          for (String datasource : datasources) {\n+            queryDatasources.remove(id, datasource);\n+          }\n+        },\n+        Execs.directExecutor()\n+    );\n+  }\n+\n+  /**\n+   * Assign a query a lane (if not set)\n+   */\n+  public <T> Query<T> laneQuery(QueryPlus<T> queryPlus, Set<SegmentServerSelector> segments)\n+  {\n+    Query<T> query = queryPlus.getQuery();\n+    // man wins over machine.. for now.\n+    if (QueryContexts.getLane(query) != null) {\n+      return query;\n+    }\n+    Optional<String> lane = laningStrategy.computeLane(queryPlus, segments);\n+    return lane.map(query::withLane).orElse(query);\n+  }\n+\n+  /**\n+   * Run a query with the scheduler, attempting to acquire a semaphore from the total and lane specific query capacities\n+   *\n+   * Note that {@link #cancelQuery} should not interrupt the thread that calls run, in all current usages it only\n+   * cancels any {@link ListenableFuture} created downstream. If this ever commonly changes, we should add\n+   * synchronization between {@link #cancelQuery} and the acquisition of the {@link Bulkhead} to continue to ensure that\n+   * anything acquired is also released.\n+   *\n+   * In the meantime, if a {@link ListenableFuture} is registered for the query that calls this method, it MUST handle\n+   * this synchronization itself to ensure that no {@link Bulkhead} is acquired without releasing it.\n+   */\n+  public <T> Sequence<T> run(Query<?> query, Sequence<T> resultSequence)\n+  {\n+    List<Bulkhead> bulkheads = acquireLanes(query);\n+    return resultSequence.withBaggage(() -> releaseLanes(bulkheads));\n+  }\n+\n+  /**\n+   * Forcibly cancel all futures that have been registered to a specific query id\n+   */\n+  public boolean cancelQuery(String id)\n+  {\n+    // if you re-use queryId and cancel queries... you are going to have a bad time\n+    queryDatasources.removeAll(id);\n+    Set<ListenableFuture<?>> futures = queryFutures.removeAll(id);\n+    boolean success = true;\n+    for (ListenableFuture<?> future : futures) {\n+      success = success && future.cancel(true);\n+    }\n+    return success;\n+  }\n+\n+  /**\n+   * Get a {@link Set} of datasource names for a {@link Query} id, used by {@link QueryResource#cancelQuery} to\n+   * authorize that a user may call {@link #cancelQuery} for the given id and datasources\n+   */\n+  public Set<String> getQueryDatasources(final String queryId)\n+  {\n+    return queryDatasources.get(queryId);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support\n+   */\n+  @VisibleForTesting\n+  int getTotalAvailableCapacity()\n+  {\n+    return laneRegistry.getConfiguration(TOTAL)\n+                       .map(config -> laneRegistry.bulkhead(TOTAL, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Get the maximum number of concurrent queries that {@link #run} can support for a given lane\n+   */\n+  @VisibleForTesting\n+  int getLaneAvailableCapacity(String lane)\n+  {\n+    return laneRegistry.getConfiguration(lane)\n+                       .map(config -> laneRegistry.bulkhead(lane, config).getMetrics().getAvailableConcurrentCalls())\n+                       .orElse(-1);\n+  }\n+\n+  /**\n+   * Acquire a semaphore for both the 'total' and a lane, if any is associated with a query\n+   */\n+  @VisibleForTesting\n+  List<Bulkhead> acquireLanes(Query<?> query)\n+  {\n+    final String lane = QueryContexts.getLane(query);\n+    final Optional<BulkheadConfig> laneConfig = lane == null ? Optional.empty() : laneRegistry.getConfiguration(lane);\n+    List<Bulkhead> hallPasses = new ArrayList<>(2);\n+    final Optional<BulkheadConfig> totalConfig = laneRegistry.getConfiguration(TOTAL);\n+    // if we have a lane, get it first\n+    laneConfig.ifPresent(config -> {\n+      Bulkhead laneLimiter = laneRegistry.bulkhead(lane, config);\n+      if (!laneLimiter.tryAcquirePermission()) {\n+        throw new QueryCapacityExceededException(lane);\n+      }\n+      hallPasses.add(laneLimiter);\n+    });\n+\n+    // everyone needs to take one from the total lane; to ensure we don't acquire a lane and never release it, we want\n+    // to check for total capacity exceeded and release the lane (if present) before throwing capacity exceeded\n+    totalConfig.ifPresent(config -> {\n+      Bulkhead totalLimiter = laneRegistry.bulkhead(TOTAL, config);\n+      if (!totalLimiter.tryAcquirePermission()) {\n+        releaseLanes(hallPasses);\n+        throw new QueryCapacityExceededException();\n+      }\n+      hallPasses.add(totalLimiter);\n+    });\n+    return hallPasses;\n+  }\n+\n+  /**\n+   * Release all {@link Bulkhead} semaphores in the list\n+   */\n+  @VisibleForTesting\n+  void releaseLanes(List<Bulkhead> bulkheads)\n+  {\n+    bulkheads.forEach(Bulkhead::releasePermission);\n+  }\n+\n+  /**\n+   * With a total thread count and {@link QueryLaningStrategy#getLaneLimits}, create a map of lane name to\n+   * {@link BulkheadConfig} to be used to create the {@link #laneRegistry}. This accepts the configured value of\n+   * numThreads rather than using {@link #totalCapacity} so that we only have a total {@link Bulkhead} if\n+   * {@link QuerySchedulerConfig#getNumThreads()} is set\n+   */\n+  private Map<String, BulkheadConfig> getLaneConfigs(boolean hastotalLimit)", "originalCommit": "059a2d40c9b011068b6aaef93a6dd02f4f372fbd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389160387", "bodyText": "Does it make sense to add maxCapacity as well?", "author": "jihoonson", "createdAt": "2020-03-06T21:47:35Z", "path": "server/src/main/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.Ints;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Query laning strategy which associates all {@link Query} with priority lower than 0 into a 'low' lane\n+ */\n+public class HiLoQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  public static final String LOW = \"low\";\n+\n+  @JsonProperty\n+  private final int maxLowPercent;", "originalCommit": "0ec8a2657e9f10e84fcd41cf42fef22063fe89ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MTcxOQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389161719", "bodyText": "hmm, this is the maximum number of concurrent queries for this lane.\ndruid.query.scheduler.numThreads or druid.server.http.numThreads define the maximum number of concurrent running queries, but it's not lane specific.", "author": "clintropolis", "createdAt": "2020-03-06T21:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3MzQyNQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389173425", "bodyText": "I mean, sometimes you may want to increase the total capacity, but keep it as it is for the low lane. In that case, maxCapacity would be more convenient because you don't have to change the configuration.", "author": "jihoonson", "createdAt": "2020-03-06T22:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NTM5NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389175395", "bodyText": "Ah, so do you mean the lane limit should be the min or (or max?) of maxCapacity and maxLowPercent of totalLimit when computing the lane limits?", "author": "clintropolis", "createdAt": "2020-03-06T22:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3Njg1Mg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389176852", "bodyText": "We could do that. Or we can allow either maxLowPercent or maxCapacity to be set.", "author": "jihoonson", "createdAt": "2020-03-06T22:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxOTE1Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389219157", "bodyText": "Would it be ok to do this addition in a follow-up PR? Originally this setting was maxLowThreads, but i switched to being percent based to be more versatile. However, it does seem maybe useful to allow one or the other to be set.", "author": "clintropolis", "createdAt": "2020-03-07T02:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxOTc2NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389219765", "bodyText": "Sounds good to me.", "author": "jihoonson", "createdAt": "2020-03-07T02:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE2MDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjIyNQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389176225", "bodyText": "Maybe worth to say what configuration is related to this error. See https://github.com/apache/druid/blob/master/processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/Groupers.java#L39 as an example.", "author": "jihoonson", "createdAt": "2020-03-06T22:32:59Z", "path": "server/src/main/java/org/apache/druid/server/QueryCapacityExceededException.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.QueryException;\n+\n+public class QueryCapacityExceededException extends QueryException\n+{\n+  private static final String ERROR_CLASS = QueryCapacityExceededException.class.getName();\n+  public static final String ERROR_CODE = \"Query capacity exceeded\";\n+  public static final String ERROR_MESSAGE = \"Total query capacity exceeded\";\n+  public static final String ERROR_MESSAGE_TEMPLATE = \"Query capacity exceeded for lane %s\";", "originalCommit": "0ec8a2657e9f10e84fcd41cf42fef22063fe89ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNDA4Nw==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389214087", "bodyText": "This seems like maybe a good idea, but I am also afraid it might be a little chatty. I think people would expect to see these error messages if they configure limits, especially since there are no default limits. I think is maybe a bit different than the message you referenced, which I think is more likely something that would be bumped into by accident while trying to query something too big. Maybe if i document the error responses to expect in the configuration documentation that would be useful enough?", "author": "clintropolis", "createdAt": "2020-03-07T01:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxNTI3OA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389215278", "bodyText": "That sounds good to me.", "author": "jihoonson", "createdAt": "2020-03-07T01:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxODg1MA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389218850", "bodyText": "Added docs to querying.md with the other error response documentation", "author": "clintropolis", "createdAt": "2020-03-07T02:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjIyNQ=="}], "type": "inlineReview"}, {"oid": "5711fce706bbd23a5f7b559ff91e4288ea8ad96d", "url": "https://github.com/apache/druid/commit/5711fce706bbd23a5f7b559ff91e4288ea8ad96d", "message": "review stuffs", "committedDate": "2020-03-07T01:14:28Z", "type": "commit"}, {"oid": "aa73a14a056e61f14a0927e8a029da999f95fc1c", "url": "https://github.com/apache/druid/commit/aa73a14a056e61f14a0927e8a029da999f95fc1c", "message": "more javadoc", "committedDate": "2020-03-07T01:22:25Z", "type": "commit"}, {"oid": "50847af1a17bb2fa2a8bff12ee32e4476fe67a86", "url": "https://github.com/apache/druid/commit/50847af1a17bb2fa2a8bff12ee32e4476fe67a86", "message": "error response documentation", "committedDate": "2020-03-07T02:20:05Z", "type": "commit"}, {"oid": "abe3631be329e40c5a3fbdbd904f4867a00ec6ee", "url": "https://github.com/apache/druid/commit/abe3631be329e40c5a3fbdbd904f4867a00ec6ee", "message": "spelling", "committedDate": "2020-03-07T03:00:40Z", "type": "commit"}, {"oid": "86501ef4bbe2f1d2b425b75e697b55e32571b2b1", "url": "https://github.com/apache/druid/commit/86501ef4bbe2f1d2b425b75e697b55e32571b2b1", "message": "preserve user specified lane for NoSchedulingStrategy", "committedDate": "2020-03-07T03:12:01Z", "type": "commit"}, {"oid": "8b7b70d16c6da7347d12718f4db3720114c17fec", "url": "https://github.com/apache/druid/commit/8b7b70d16c6da7347d12718f4db3720114c17fec", "message": "more test, why not", "committedDate": "2020-03-07T03:14:09Z", "type": "commit"}, {"oid": "91ad9d97fc3d416801204bd3d19f10205d3b6283", "url": "https://github.com/apache/druid/commit/91ad9d97fc3d416801204bd3d19f10205d3b6283", "message": "doc adjustment", "committedDate": "2020-03-07T03:17:21Z", "type": "commit"}, {"oid": "373fd1158f13c9f7a77ac6ba1748aa2b2cbb8b99", "url": "https://github.com/apache/druid/commit/373fd1158f13c9f7a77ac6ba1748aa2b2cbb8b99", "message": "style", "committedDate": "2020-03-07T05:08:54Z", "type": "commit"}, {"oid": "274150174fabd07646fe87a01dea67dc714172c7", "url": "https://github.com/apache/druid/commit/274150174fabd07646fe87a01dea67dc714172c7", "message": "missed review for make a thing a constant", "committedDate": "2020-03-09T17:12:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1NjA0NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389956045", "bodyText": "Behavior here is a bit different from the docs, which say the value is rounded up.\nSince this allows a lane limit of zero or the total limit, it is a bit inconsistent with disallowing maxLowPercent from being 0 or 100 percent.", "author": "ccaominh", "createdAt": "2020-03-09T20:55:02Z", "path": "server/src/main/java/org/apache/druid/server/scheduling/HiLoQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.Ints;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Query laning strategy which associates all {@link Query} with priority lower than 0 into a 'low' lane\n+ */\n+public class HiLoQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  public static final String LOW = \"low\";\n+\n+  @JsonProperty\n+  private final int maxLowPercent;\n+\n+  @JsonCreator\n+  public HiLoQueryLaningStrategy(\n+      @JsonProperty(\"maxLowPercent\") Integer maxLowPercent\n+  )\n+  {\n+    this.maxLowPercent = Preconditions.checkNotNull(maxLowPercent, \"maxLowPercent must be set\");\n+    Preconditions.checkArgument(\n+        0 < maxLowPercent && maxLowPercent < 100,\n+        \"maxLowPercent must be between 0 and 100\"\n+    );\n+  }\n+\n+  @Override\n+  public Object2IntMap<String> getLaneLimits(int totalLimit)\n+  {\n+    Object2IntMap<String> onlyLow = new Object2IntArrayMap<>(1);\n+    onlyLow.put(LOW, Ints.checkedCast(Math.round(totalLimit * ((double) maxLowPercent / 100))));", "originalCommit": "274150174fabd07646fe87a01dea67dc714172c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2MTEzMA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389961130", "bodyText": "Oops, I meant to round up, will adjust", "author": "clintropolis", "createdAt": "2020-03-09T21:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1NjA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2NjA3NQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r389966075", "bodyText": "thanks, good catch. fixed, clarified error and docs, and added some tests", "author": "clintropolis", "createdAt": "2020-03-09T21:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1NjA0NQ=="}], "type": "inlineReview"}, {"oid": "8575cf8dc1a3e4fbedb46b1f7d36985e984b991c", "url": "https://github.com/apache/druid/commit/8575cf8dc1a3e4fbedb46b1f7d36985e984b991c", "message": "fixes and tests", "committedDate": "2020-03-09T21:14:59Z", "type": "commit"}, {"oid": "25a8bda9fa2dd456b23598390c94c1a39e1a70a3", "url": "https://github.com/apache/druid/commit/25a8bda9fa2dd456b23598390c94c1a39e1a70a3", "message": "fix test", "committedDate": "2020-03-10T00:37:20Z", "type": "commit"}, {"oid": "32965a4fa92d60c46f4296a5f387b9b29484712b", "url": "https://github.com/apache/druid/commit/32965a4fa92d60c46f4296a5f387b9b29484712b", "message": "Update docs/configuration/index.md\n\nCo-Authored-By: sthetland <steve.hetland@imply.io>", "committedDate": "2020-03-10T00:43:25Z", "type": "commit"}, {"oid": "361e06e80186835be87e69b0001ddc84d5838e16", "url": "https://github.com/apache/druid/commit/361e06e80186835be87e69b0001ddc84d5838e16", "message": "Merge remote-tracking branch 'upstream/master' into query-laning-and-load-shedding", "committedDate": "2020-03-10T00:44:16Z", "type": "commit"}, {"oid": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8", "url": "https://github.com/apache/druid/commit/3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8", "message": "doc update", "committedDate": "2020-03-10T00:46:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA5ODAxMQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390098011", "bodyText": "why is this  Integer and not int considering it has a default non-null value?", "author": "himanshug", "createdAt": "2020-03-10T05:10:42Z", "path": "server/src/main/java/org/apache/druid/server/QuerySchedulerConfig.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+public class QuerySchedulerConfig\n+{\n+  @JsonProperty\n+  private Integer numThreads = 0;", "originalCommit": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE5NDIxNg==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390194216", "bodyText": "Hmm, that is a good point, will change in one of the follow-up PRs.", "author": "clintropolis", "createdAt": "2020-03-10T09:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA5ODAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMjIwMQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390132201", "bodyText": "is it expected that sum(returned_map.values) < totalLimit ?\nnit:  Also wonder why limits returned here  were not percentages but absolute counts given that each implementation would probably end up doing that calculation.", "author": "himanshug", "createdAt": "2020-03-10T07:29:51Z", "path": "server/src/main/java/org/apache/druid/server/QueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.scheduling.HiLoQueryLaningStrategy;\n+import org.apache.druid.server.scheduling.NoQueryLaningStrategy;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+\n+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"strategy\", defaultImpl = NoQueryLaningStrategy.class)\n+@JsonSubTypes(value = {\n+    @JsonSubTypes.Type(name = \"none\", value = NoQueryLaningStrategy.class),\n+    @JsonSubTypes.Type(name = \"hilo\", value = HiLoQueryLaningStrategy.class)\n+})\n+public interface QueryLaningStrategy\n+{\n+  /**\n+   * Provide a map of lane names to the limit on the number of concurrent queries for that lane\n+   * @param totalLimit\n+   */\n+  Object2IntMap<String> getLaneLimits(int totalLimit);", "originalCommit": "3ba7808e32bdeeef603fa3e4b6665bd927ce9bb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIwMTE3MQ==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390201171", "bodyText": "is it expected that sum(returned_map.values) < totalLimit ?\n\nRight now I am not requiring this needs to be true since the limits are not guaranteed capacity, but rather maximums. It seemed more flexible to leave it to individual QueryLaningStrategy implementations to enforce that if they wish.\n\nnit: Also wonder why limits returned here were not percentages but absolute counts given that each implementation would probably end up doing that calculation.\n\nHmm, I think that is definitely worth considering, though @jihoonson was asking for absolute limits in this comment #9407 (comment), so in the very least I will add a utility method to the QueryLaningStrategy interface for doing this conversion.", "author": "clintropolis", "createdAt": "2020-03-10T09:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMjIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2OTEwMA==", "url": "https://github.com/apache/druid/pull/9407#discussion_r390469100", "bodyText": "Hehe, that happens with multiple reviewers. Yeah, having a utility method is equally good.", "author": "himanshug", "createdAt": "2020-03-10T17:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMjIwMQ=="}], "type": "inlineReview"}]}