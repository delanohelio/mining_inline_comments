{"pr_number": 10304, "pr_title": "Add vectorization for druid-histogram extension", "pr_createdAt": "2020-08-20T13:39:07Z", "pr_url": "https://github.com/apache/druid/pull/10304", "timeline": [{"oid": "cc38ecc5454d09b7966b87b9c1569ac930d697e6", "url": "https://github.com/apache/druid/commit/cc38ecc5454d09b7966b87b9c1569ac930d697e6", "message": "First draft", "committedDate": "2020-08-19T18:17:31Z", "type": "commit"}, {"oid": "55401cde3715db3baec2d617cbcef7131713fee2", "url": "https://github.com/apache/druid/commit/55401cde3715db3baec2d617cbcef7131713fee2", "message": "Merge branch 'master' of github.com:apache/druid into histogram-vectorization", "committedDate": "2020-08-20T13:05:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA0MDcwNQ==", "url": "https://github.com/apache/druid/pull/10304#discussion_r474040705", "bodyText": "I might have carried forward a bug here. This if/else should most likely be inverted. cc @jon-wei", "author": "abhishekagarwal87", "createdAt": "2020-08-20T14:47:53Z", "path": "extensions-core/histogram/src/main/java/org/apache/druid/query/aggregation/histogram/FixedBucketsHistogramBufferAggregatorInternal.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.histogram;\n+\n+import org.apache.druid.common.config.NullHandling;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public class FixedBucketsHistogramBufferAggregatorInternal\n+{\n+  private final double lowerLimit;\n+  private final double upperLimit;\n+  private final int numBuckets;\n+  private final FixedBucketsHistogram.OutlierHandlingMode outlierHandlingMode;\n+\n+  public FixedBucketsHistogramBufferAggregatorInternal(\n+      double lowerLimit,\n+      double upperLimit,\n+      int numBuckets,\n+      FixedBucketsHistogram.OutlierHandlingMode outlierHandlingMode\n+  )\n+  {\n+\n+    this.lowerLimit = lowerLimit;\n+    this.upperLimit = upperLimit;\n+    this.numBuckets = numBuckets;\n+    this.outlierHandlingMode = outlierHandlingMode;\n+  }\n+\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    ByteBuffer mutationBuffer = buf.duplicate();\n+    mutationBuffer.position(position);\n+    FixedBucketsHistogram histogram = new FixedBucketsHistogram(\n+        lowerLimit,\n+        upperLimit,\n+        numBuckets,\n+        outlierHandlingMode\n+    );\n+    mutationBuffer.put(histogram.toBytesFull(false));\n+  }\n+\n+  public void aggregate(ByteBuffer buf, int position, @Nullable Object val)\n+  {\n+    ByteBuffer mutationBuffer = buf.duplicate();\n+    mutationBuffer.position(position);\n+\n+    FixedBucketsHistogram h0 = FixedBucketsHistogram.fromByteBufferFullNoSerdeHeader(mutationBuffer);\n+    combine(h0, val);\n+\n+    mutationBuffer.position(position);\n+    mutationBuffer.put(h0.toBytesFull(false));\n+  }\n+\n+  public void combine(FixedBucketsHistogram histogram, @Nullable Object next)\n+  {\n+    if (next == null) {\n+      if (NullHandling.replaceWithDefault()) {", "originalCommit": "55401cde3715db3baec2d617cbcef7131713fee2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "30aa2515ad0efe45d598b871f596063e9d24dfc7", "url": "https://github.com/apache/druid/commit/30aa2515ad0efe45d598b871f596063e9d24dfc7", "message": "Remove redundant code from FixedBucketsHistogramAggregator classes", "committedDate": "2020-08-20T15:30:18Z", "type": "commit"}, {"oid": "b47c90634c746d66812736b6202a976ea7dc7cb2", "url": "https://github.com/apache/druid/commit/b47c90634c746d66812736b6202a976ea7dc7cb2", "message": "Add test cases for new classes", "committedDate": "2020-08-21T15:23:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MDM5OA==", "url": "https://github.com/apache/druid/pull/10304#discussion_r474780398", "bodyText": "this looks unnecessary", "author": "abhishekagarwal87", "createdAt": "2020-08-21T15:45:58Z", "path": "extensions-core/histogram/src/main/java/org/apache/druid/query/aggregation/histogram/ApproximateHistogramFoldingBufferAggregatorInternal.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.histogram;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * A helper class used by {@link ApproximateHistogramFoldingBufferAggregator} and\n+ * {@link ApproximateHistogramFoldingVectorAggregator} for aggregation operations on byte buffers.\n+ * Getting the object from value selectors is outside this class.\n+ */\n+final class ApproximateHistogramFoldingBufferAggregatorInternal\n+{\n+  private final int resolution;\n+  private final float upperLimit;\n+  private final float lowerLimit;\n+\n+  private float[] tmpBufferA;\n+  private long[] tmpBufferB;\n+\n+  public ApproximateHistogramFoldingBufferAggregatorInternal(\n+      int resolution,\n+      float lowerLimit,\n+      float upperLimit\n+  )\n+  {\n+    this.resolution = resolution;\n+    this.lowerLimit = lowerLimit;\n+    this.upperLimit = upperLimit;\n+\n+    tmpBufferA = new float[resolution];\n+    tmpBufferB = new long[resolution];\n+  }\n+\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    ApproximateHistogram h = new ApproximateHistogram(resolution, lowerLimit, upperLimit);\n+\n+    ByteBuffer mutationBuffer = buf.duplicate();\n+    mutationBuffer.position(position);\n+    // use dense storage for aggregation\n+    h.toBytesDense(mutationBuffer);\n+  }\n+\n+  public void aggregate(ByteBuffer buf, int position, @Nullable ApproximateHistogram hNext)\n+  {\n+    if (hNext == null) {\n+      return;\n+    }\n+    ByteBuffer mutationBuffer = buf.duplicate();\n+    mutationBuffer.position(position);\n+\n+    ApproximateHistogram h0 = ApproximateHistogram.fromBytesDense(mutationBuffer);\n+    foldFast(h0, hNext);\n+\n+    mutationBuffer.position(position);\n+    h0.toBytesDense(mutationBuffer);\n+  }\n+\n+  public void foldFast(ApproximateHistogram left, ApproximateHistogram right)\n+  {\n+    //TODO: do these have to set in every call\n+    left.setLowerLimit(lowerLimit);", "originalCommit": "b47c90634c746d66812736b6202a976ea7dc7cb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwOTM5MQ==", "url": "https://github.com/apache/druid/pull/10304#discussion_r477209391", "bodyText": "A quick look and I think I agree, but am not totally certain. Can you try to find out if it is needed so we can remove this TODO and either remove the code, or add a comment on why it needs to be here?", "author": "clintropolis", "createdAt": "2020-08-26T10:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MDM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4MTMyNg==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478281326", "bodyText": "Ack", "author": "abhishekagarwal87", "createdAt": "2020-08-27T09:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MDM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc4MjkyNQ==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478782925", "bodyText": "I think it's necessary, the fromBytesDense call ends up using this constructor which uses a default lower/upper limit:\n public ApproximateHistogram(int binCount, float[] positions, long[] bins, float min, float max)\n  {\n    this(\n        positions.length,        //size\n        positions,               //positions\n        bins,                    //bins\n        binCount,                //binCount\n        min,                     //min\n        max,                     //max\n        sumBins(bins, binCount), //count\n        Float.NEGATIVE_INFINITY, //lowerLimit\n        Float.POSITIVE_INFINITY  //upperLimit\n    );\n  }", "author": "jon-wei", "createdAt": "2020-08-28T01:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MDM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MzI5NQ==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478863295", "bodyText": "Thanks for the explanation. I didn't realize that these limits are transient.  I will add a similar comment here for future reference.", "author": "abhishekagarwal87", "createdAt": "2020-08-28T06:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MDM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MjI3Ng==", "url": "https://github.com/apache/druid/pull/10304#discussion_r474782276", "bodyText": "This is a copy of old implementation. However, I noticed that ApproximateHistogramAggregator has the following implementation instead which looks more correct. calling foldFast with inadequate space results in an exception.\n if (left.binCount() + right.binCount() <= tmpBufferB.length) {\n      left.foldFast(right, tmpBufferA, tmpBufferB);\n    } else {\n      left.foldFast(right);\n    }", "author": "abhishekagarwal87", "createdAt": "2020-08-21T15:49:31Z", "path": "extensions-core/histogram/src/main/java/org/apache/druid/query/aggregation/histogram/ApproximateHistogramFoldingBufferAggregatorInternal.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.histogram;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * A helper class used by {@link ApproximateHistogramFoldingBufferAggregator} and\n+ * {@link ApproximateHistogramFoldingVectorAggregator} for aggregation operations on byte buffers.\n+ * Getting the object from value selectors is outside this class.\n+ */\n+final class ApproximateHistogramFoldingBufferAggregatorInternal\n+{\n+  private final int resolution;\n+  private final float upperLimit;\n+  private final float lowerLimit;\n+\n+  private float[] tmpBufferA;\n+  private long[] tmpBufferB;\n+\n+  public ApproximateHistogramFoldingBufferAggregatorInternal(\n+      int resolution,\n+      float lowerLimit,\n+      float upperLimit\n+  )\n+  {\n+    this.resolution = resolution;\n+    this.lowerLimit = lowerLimit;\n+    this.upperLimit = upperLimit;\n+\n+    tmpBufferA = new float[resolution];\n+    tmpBufferB = new long[resolution];\n+  }\n+\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    ApproximateHistogram h = new ApproximateHistogram(resolution, lowerLimit, upperLimit);\n+\n+    ByteBuffer mutationBuffer = buf.duplicate();\n+    mutationBuffer.position(position);\n+    // use dense storage for aggregation\n+    h.toBytesDense(mutationBuffer);\n+  }\n+\n+  public void aggregate(ByteBuffer buf, int position, @Nullable ApproximateHistogram hNext)\n+  {\n+    if (hNext == null) {\n+      return;\n+    }\n+    ByteBuffer mutationBuffer = buf.duplicate();\n+    mutationBuffer.position(position);\n+\n+    ApproximateHistogram h0 = ApproximateHistogram.fromBytesDense(mutationBuffer);\n+    foldFast(h0, hNext);\n+\n+    mutationBuffer.position(position);\n+    h0.toBytesDense(mutationBuffer);\n+  }\n+\n+  public void foldFast(ApproximateHistogram left, ApproximateHistogram right)\n+  {\n+    //TODO: do these have to set in every call\n+    left.setLowerLimit(lowerLimit);\n+    left.setUpperLimit(upperLimit);\n+    left.foldFast(right, tmpBufferA, tmpBufferB);", "originalCommit": "b47c90634c746d66812736b6202a976ea7dc7cb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc5MzYxNA==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478793614", "bodyText": "Hm, what was the exception you saw?\nFrom looking at the code it seems like the buffers allocated in ApproximateHistogram.foldRule when foldFast is called with a single argument should be the same size as tmpBufferA and tmpBufferB.", "author": "jon-wei", "createdAt": "2020-08-28T02:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MjI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2NTYxNQ==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478865615", "bodyText": "can't reproduce it now. I am not sure either why ApproximateHistogramAggregator will have a different implementation. Will leave it as it is.", "author": "abhishekagarwal87", "createdAt": "2020-08-28T06:50:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDc4MjI3Ng=="}], "type": "inlineReview"}, {"oid": "81e72a51acadeebf324ee133f22b15ce5d63e5d4", "url": "https://github.com/apache/druid/commit/81e72a51acadeebf324ee133f22b15ce5d63e5d4", "message": "Fix tests in sql compatible mode", "committedDate": "2020-08-25T12:49:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5ODg0Nw==", "url": "https://github.com/apache/druid/pull/10304#discussion_r477198847", "bodyText": "Did you consider making the shared functionality just be static methods to be more consistent with how HyperUniquesBufferAggregator and HyperUniquesVectorAggregator are implemented? This is totally nitpicking, but something just seems off about these things having a thing called 'innerAggregator' that doesn't implement any of the aggregator interfaces.", "author": "clintropolis", "createdAt": "2020-08-26T10:28:01Z", "path": "extensions-core/histogram/src/main/java/org/apache/druid/query/aggregation/histogram/ApproximateHistogramBufferAggregator.java", "diffHunk": "@@ -28,54 +28,30 @@\n public class ApproximateHistogramBufferAggregator implements BufferAggregator\n {\n   private final BaseFloatColumnValueSelector selector;\n-  private final int resolution;\n+  private final ApproximateHistogramBufferAggregatorInternal innerAggregator;", "originalCommit": "81e72a51acadeebf324ee133f22b15ce5d63e5d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4MDUwMg==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478280502", "bodyText": "Yes but decided against it as static methods are not so good when it comes to unit testing. I can pass mock dependencies in the constructor, unlike the static methods. Then, some classes also have temporary buffers as a state which I can put inside the instances with common functionality. E.g. ApproximateHistogramFoldingBufferAggregatorInternal  has temporary buffers created just once.  I could make these temp buffers static too but then synchronization issues kick in.", "author": "abhishekagarwal87", "createdAt": "2020-08-27T09:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5ODg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwMDQ5Mg==", "url": "https://github.com/apache/druid/pull/10304#discussion_r477200492", "bodyText": "typo: 'datapoin' -> 'datapoint'", "author": "clintropolis", "createdAt": "2020-08-26T10:31:12Z", "path": "extensions-core/histogram/src/main/java/org/apache/druid/query/aggregation/histogram/FixedBucketsHistogram.java", "diffHunk": "@@ -431,6 +433,33 @@ public void incrementMissing()\n     }\n   }\n \n+  /**\n+   * Merge another datapoint into this one. The other datapoin could be", "originalCommit": "81e72a51acadeebf324ee133f22b15ce5d63e5d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwMDg2Nw==", "url": "https://github.com/apache/druid/pull/10304#discussion_r477200867", "bodyText": "I think this isn't possible since canVectorize checks that capabilities isn't null", "author": "clintropolis", "createdAt": "2020-08-26T10:31:55Z", "path": "extensions-core/histogram/src/main/java/org/apache/druid/query/aggregation/histogram/FixedBucketsHistogramAggregatorFactory.java", "diffHunk": "@@ -99,6 +105,34 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     );\n   }\n \n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory columnSelectorFactory)\n+  {\n+    ColumnCapabilities capabilities = columnSelectorFactory.getColumnCapabilities(fieldName);\n+    if (null == capabilities) {", "originalCommit": "81e72a51acadeebf324ee133f22b15ce5d63e5d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4MzAyMw==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478283023", "bodyText": "I have seen this trend in a few places where an extra guard is put up. That the caller may not call canVectorize before factorizeVector.  I can remove it ifs unnecessarily defensive.", "author": "abhishekagarwal87", "createdAt": "2020-08-27T09:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwMDg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwMzYyMg==", "url": "https://github.com/apache/druid/pull/10304#discussion_r477203622", "bodyText": "I'm not sure this function should be shared between the vectorized and non-vectorized aggregator. For the vector aggregator the if should probably be outside of the for loop i think, because the contents of the vector will be consistent throughout the loop.\nAlso, I think you might need different selectors depending on if the inputs to the aggregator are numeric primitives (value selector to get double vector and null boolean vector), or if the input is other fixed bucket histogram sketches (object selector to get array of histogram objects). The fixed bucket histogram aggregator is a combined primitive and sketch merging aggregator, unlike the approximate histogram aggregators which are split and handles the sketch inputs and result merges with the 'fold' aggregators.", "author": "clintropolis", "createdAt": "2020-08-26T10:37:27Z", "path": "extensions-core/histogram/src/main/java/org/apache/druid/query/aggregation/histogram/FixedBucketsHistogram.java", "diffHunk": "@@ -431,6 +433,33 @@ public void incrementMissing()\n     }\n   }\n \n+  /**\n+   * Merge another datapoint into this one. The other datapoin could be\n+   *  - base64 encoded string of {@code FixedBucketsHistogram}\n+   *  - {@code FixedBucketsHistogram} object\n+   *  - Numeric value\n+   *\n+   * @param val\n+   */\n+  void combine(@Nullable Object val)", "originalCommit": "81e72a51acadeebf324ee133f22b15ce5d63e5d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5MzI5NQ==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478293295", "bodyText": "Good point. I will let this method remain here. Since I am only tackling numeric values for now, my vector implementation can call add directly on fixed histogram. will make that change.", "author": "abhishekagarwal87", "createdAt": "2020-08-27T09:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwMzYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwODQ3Mw==", "url": "https://github.com/apache/druid/pull/10304#discussion_r477208473", "bodyText": "you can also ignore null checks entirely if NullHandling.sqlCompatible() is true, would suggest saving it as a private final field in the constructor and then maybe add something like final boolean checkNulls = hasNulls && isValueNull != null", "author": "clintropolis", "createdAt": "2020-08-26T10:47:43Z", "path": "extensions-core/histogram/src/main/java/org/apache/druid/query/aggregation/histogram/ApproximateHistogramVectorAggregator.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.histogram;\n+\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public class ApproximateHistogramVectorAggregator implements VectorAggregator\n+{\n+\n+  private final VectorValueSelector selector;\n+  private final ApproximateHistogramBufferAggregatorInternal innerAggregator;\n+\n+  public ApproximateHistogramVectorAggregator(\n+      VectorValueSelector selector,\n+      int resolution\n+  )\n+  {\n+    this.selector = selector;\n+    this.innerAggregator = new ApproximateHistogramBufferAggregatorInternal(resolution);\n+  }\n+\n+  @Override\n+  public void init(final ByteBuffer buf, final int position)\n+  {\n+    innerAggregator.init(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(final ByteBuffer buf, final int position, final int startRow, final int endRow)\n+  {\n+    final boolean[] isValueNull = selector.getNullVector();\n+    final float[] vector = selector.getFloatVector();\n+    ApproximateHistogram histogram = innerAggregator.get(buf, position);\n+\n+    for (int i = startRow; i < endRow; i++) {\n+      if (isValueNull != null && isValueNull[i]) {", "originalCommit": "81e72a51acadeebf324ee133f22b15ce5d63e5d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5MDU5Nw==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478290597", "bodyText": "How about if I take isValueNull != null out of loop and line L57 becomes\nboolean hasNulls = isValueNull != null;\nfor (int i = startRow; i < endRow; i++) {\n   if (hasNulls && isValueNull[i]) {\n\nThis way, I don't need to introduce another predicate in my if condition and number of null checks will still be reduced somewhat.", "author": "abhishekagarwal87", "createdAt": "2020-08-27T09:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwODQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk1NTg3Ng==", "url": "https://github.com/apache/druid/pull/10304#discussion_r481955876", "bodyText": "Ah yeah i wasn't imagining checking all the conditions in the loop, the checkNulls value I was thinking of would be in the loop, similar to hasNulls in your example. Thinking further about it though, there is no real need/advantage to checking NullHandling.sqlCompatible().", "author": "clintropolis", "createdAt": "2020-09-02T10:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwODQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxMTY2Nw==", "url": "https://github.com/apache/druid/pull/10304#discussion_r477211667", "bodyText": "Did you mean to only handle numeric primitive inputs? The input type could also be complex if you handle fixed bucket histogram inputs, but you would need another vector aggregator implementation I think that takes an object selector instead of value selector", "author": "clintropolis", "createdAt": "2020-08-26T10:54:11Z", "path": "extensions-core/histogram/src/main/java/org/apache/druid/query/aggregation/histogram/FixedBucketsHistogramAggregatorFactory.java", "diffHunk": "@@ -99,6 +105,34 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     );\n   }\n \n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory columnSelectorFactory)\n+  {\n+    ColumnCapabilities capabilities = columnSelectorFactory.getColumnCapabilities(fieldName);\n+    if (null == capabilities) {\n+      throw new IAE(\"could not find the column type for column %s\", fieldName);\n+    }\n+    ValueType type = capabilities.getType();\n+    if (type.isNumeric()) {\n+      return new FixedBucketsHistogramVectorAggregator(\n+          columnSelectorFactory.makeValueSelector(fieldName),\n+          lowerLimit,\n+          upperLimit,\n+          numBuckets,\n+          outlierHandlingMode\n+      );\n+    } else {\n+      throw new IAE(\"cannot vectorize fixed bucket histogram aggregation for type %s\", type);\n+    }\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    ColumnCapabilities capabilities = columnInspector.getColumnCapabilities(fieldName);\n+    return (capabilities != null) && capabilities.getType().isNumeric();", "originalCommit": "81e72a51acadeebf324ee133f22b15ce5d63e5d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI4NTk5Ng==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478285996", "bodyText": "Yes. I only meant to handle numeric types for now. It seems it can also take String (base64) as well as complex objects. I decided to not do that in the current PR given these extensions are also deprecated and not recommended for use anymore.", "author": "abhishekagarwal87", "createdAt": "2020-08-27T09:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxMTY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNDUzOA==", "url": "https://github.com/apache/druid/pull/10304#discussion_r477214538", "bodyText": "nit: suggest ColumnCapabilitiesImpl.createSimpleNumericColumnCapabilities(ValueType.DOUBLE) since it will create realistic double capabilities (numbers are not dictionary encoded for example)", "author": "clintropolis", "createdAt": "2020-08-26T10:59:56Z", "path": "extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/ApproximateHistogramVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.histogram;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.column.ColumnCapabilities;\n+import org.apache.druid.segment.column.ColumnCapabilitiesImpl;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.easymock.EasyMock;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.nio.ByteBuffer;\n+\n+import static org.easymock.EasyMock.createMock;\n+import static org.easymock.EasyMock.expect;\n+\n+public class ApproximateHistogramVectorAggregatorTest\n+{\n+  private static final float[] FLOATS = {23, 19, 10, 16, 36, 2, 9, 32, 30, 45, 33};   // Last value is never included\n+  private static final boolean[] NULL_VECTOR =\n+      {false, false, false, false, false, false, false, false, false, false, true};\n+  private VectorColumnSelectorFactory vectorColumnSelectorFactory;\n+\n+  @Before\n+  public void setup()\n+  {\n+    NullHandling.initializeForTests();\n+    VectorValueSelector vectorValueSelector_1 = createMock(VectorValueSelector.class);\n+    expect(vectorValueSelector_1.getFloatVector()).andReturn(FLOATS).anyTimes();\n+    expect(vectorValueSelector_1.getNullVector()).andReturn(NULL_VECTOR).anyTimes();\n+\n+    VectorValueSelector vectorValueSelector_2 = createMock(VectorValueSelector.class);\n+    expect(vectorValueSelector_2.getFloatVector()).andReturn(FLOATS).anyTimes();\n+    expect(vectorValueSelector_2.getNullVector()).andReturn(null).anyTimes();\n+\n+    EasyMock.replay(vectorValueSelector_1);\n+    EasyMock.replay(vectorValueSelector_2);\n+\n+    ColumnCapabilities columnCapabilities\n+        = new ColumnCapabilitiesImpl().setType(ValueType.DOUBLE).setDictionaryEncoded(true);", "originalCommit": "81e72a51acadeebf324ee133f22b15ce5d63e5d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5NDYyMg==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478294622", "bodyText": "Ack", "author": "abhishekagarwal87", "createdAt": "2020-08-27T09:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNDUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNDgxMQ==", "url": "https://github.com/apache/druid/pull/10304#discussion_r477214811", "bodyText": "nit: same comment about capabilities", "author": "clintropolis", "createdAt": "2020-08-26T11:00:33Z", "path": "extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/FixedBucketsHistogramVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.histogram;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.column.ColumnCapabilities;\n+import org.apache.druid.segment.column.ColumnCapabilitiesImpl;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.easymock.EasyMock;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.nio.ByteBuffer;\n+\n+import static org.easymock.EasyMock.createMock;\n+import static org.easymock.EasyMock.expect;\n+\n+public class FixedBucketsHistogramVectorAggregatorTest\n+{\n+  private static final double[] DOUBLES = {1.0, 12.0, 3.0, 14.0, 15.0, 16.0};\n+  private static final boolean[] NULL_VECTOR = {false, false, false, false, true, false};\n+  private VectorColumnSelectorFactory vectorColumnSelectorFactory;\n+\n+  @Before\n+  public void setup()\n+  {\n+    NullHandling.initializeForTests();\n+    VectorValueSelector vectorValueSelector_1 = createMock(VectorValueSelector.class);\n+    expect(vectorValueSelector_1.getDoubleVector()).andReturn(DOUBLES).anyTimes();\n+    expect(vectorValueSelector_1.getNullVector()).andReturn(NULL_VECTOR).anyTimes();\n+\n+    VectorValueSelector vectorValueSelector_2 = createMock(VectorValueSelector.class);\n+    expect(vectorValueSelector_2.getDoubleVector()).andReturn(DOUBLES).anyTimes();\n+    expect(vectorValueSelector_2.getNullVector()).andReturn(null).anyTimes();\n+\n+    EasyMock.replay(vectorValueSelector_1);\n+    EasyMock.replay(vectorValueSelector_2);\n+\n+    ColumnCapabilities columnCapabilities\n+        = new ColumnCapabilitiesImpl().setType(ValueType.DOUBLE).setDictionaryEncoded(true);", "originalCommit": "81e72a51acadeebf324ee133f22b15ce5d63e5d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNjYyMQ==", "url": "https://github.com/apache/druid/pull/10304#discussion_r477216621", "bodyText": "should this check if the column is numeric or complex similar to the fixed buckets aggregator factory? I don't think we have a good way for aggregators to handle string inputs in vectorized engine yet either, unless you use SingleValueDimensionVectorSelector or MultiValueDimensionVectorSelector and lookup the string values for the int arrays yourself, so should probably exclude strings at least (not that they make much sense as an input anyway).", "author": "clintropolis", "createdAt": "2020-08-26T11:04:21Z", "path": "extensions-core/histogram/src/main/java/org/apache/druid/query/aggregation/histogram/ApproximateHistogramAggregatorFactory.java", "diffHunk": "@@ -102,6 +105,21 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     );\n   }\n \n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory metricVectorFactory)\n+  {\n+    return new ApproximateHistogramVectorAggregator(\n+        metricVectorFactory.makeValueSelector(fieldName),\n+        resolution\n+    );\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;", "originalCommit": "81e72a51acadeebf324ee133f22b15ce5d63e5d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMyNzI1MA==", "url": "https://github.com/apache/druid/pull/10304#discussion_r478327250", "bodyText": "The approximate histogram aggregators do not handle the strings. The way I see it, canVectorize only indicates when the aggregation cannot be vectorized. E.g. fixed bucket aggregator factory can aggregate complex objects but not with vectorization and this is what canVectorize in fixedBucket**Factory checks.\nIn this class, any type that can be aggregated in regular aggregators, is supported by vector aggregator as well. Any type that is not supported by regular aggregator is not supported by vector aggregator as well. Hence the method canVectorize just returns true.\ndo you think it would still make sense to check for input type?", "author": "abhishekagarwal87", "createdAt": "2020-08-27T10:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNjYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk1MzE0NQ==", "url": "https://github.com/apache/druid/pull/10304#discussion_r481953145", "bodyText": "We need to handle it somehow because if not it will fail when making the value selector (because there is no string value selector) org.apache.druid.query.QueryInterruptedException: Cannot make VectorValueSelector for column with class[org.apache.druid.segment.column.StringDictionaryEncodedColumn]. This is inconsistent with the non-vectorized behavior, which treats the input as 0 from the dimension selectors.\nThe ways it can be handled are with either the canVectorize method checking explicitly for numeric types, or special handling in factorizeVector to use a nil vector selector instead of trying to make a value selector. You probably want similar checks for other agg factories, as is appropriate for the types they handle.", "author": "clintropolis", "createdAt": "2020-09-02T10:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNjYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4OTAxNA==", "url": "https://github.com/apache/druid/pull/10304#discussion_r482189014", "bodyText": "Ack", "author": "abhishekagarwal87", "createdAt": "2020-09-02T16:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNjYyMQ=="}], "type": "inlineReview"}, {"oid": "a294a91caa28adb7df949de86ea2d6ff5b91b51c", "url": "https://github.com/apache/druid/commit/a294a91caa28adb7df949de86ea2d6ff5b91b51c", "message": "Typo fix", "committedDate": "2020-08-27T14:08:07Z", "type": "commit"}, {"oid": "19b2b72f061c0373dc7910e201999a62b557b2c5", "url": "https://github.com/apache/druid/commit/19b2b72f061c0373dc7910e201999a62b557b2c5", "message": "Typo fix", "committedDate": "2020-08-27T14:23:19Z", "type": "commit"}, {"oid": "db59ddd104cd2fed2e82db5780bf9d54d4a6b188", "url": "https://github.com/apache/druid/commit/db59ddd104cd2fed2e82db5780bf9d54d4a6b188", "message": "Fix comment", "committedDate": "2020-08-28T06:57:22Z", "type": "commit"}, {"oid": "182b6102d774eddb1ef06383ae79c1c30c9df115", "url": "https://github.com/apache/druid/commit/182b6102d774eddb1ef06383ae79c1c30c9df115", "message": "Add spelling", "committedDate": "2020-08-28T08:59:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk1MzkzNQ==", "url": "https://github.com/apache/druid/pull/10304#discussion_r481953935", "bodyText": "super nitpick, feel free to ignore, but maybe consider naming this (and similar classes) to something like ApproximateHistogramBufferAggregatorHelper instead of ApproximateHistogramBufferAggregatorInternal to be more consistent with the naming of this style of class with the rest of the codebase. I looked around and this PR has the only classes with an Internal suffix but there are many with the Helper suffix, and is consistent with the javadoc for this class.", "author": "clintropolis", "createdAt": "2020-09-02T10:05:59Z", "path": "extensions-core/histogram/src/main/java/org/apache/druid/query/aggregation/histogram/ApproximateHistogramBufferAggregatorInternal.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.histogram;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * A helper class used by {@link ApproximateHistogramBufferAggregator} and {@link ApproximateHistogramVectorAggregator}\n+ * for aggregation operations on byte buffers. Getting the object from value selectors is outside this class.\n+ */\n+final class ApproximateHistogramBufferAggregatorInternal", "originalCommit": "182b6102d774eddb1ef06383ae79c1c30c9df115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE4OTMyMw==", "url": "https://github.com/apache/druid/pull/10304#discussion_r482189323", "bodyText": "Its good to be consistent. I will rename these classes.", "author": "abhishekagarwal87", "createdAt": "2020-09-02T16:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk1MzkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxMTUyMw==", "url": "https://github.com/apache/druid/pull/10304#discussion_r482011523", "bodyText": "it isn't obvious from this PR, but out of curiosity are there any tests which confirm that the vectorized aggregator results match the non-vectorized output?", "author": "clintropolis", "createdAt": "2020-09-02T11:55:31Z", "path": "extensions-core/histogram/src/test/java/org/apache/druid/query/aggregation/histogram/ApproximateHistogramVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.histogram;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.column.ColumnCapabilities;\n+import org.apache.druid.segment.column.ColumnCapabilitiesImpl;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.easymock.EasyMock;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.nio.ByteBuffer;\n+\n+import static org.easymock.EasyMock.createMock;\n+import static org.easymock.EasyMock.expect;\n+\n+public class ApproximateHistogramVectorAggregatorTest", "originalCommit": "182b6102d774eddb1ef06383ae79c1c30c9df115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE5MDU5MQ==", "url": "https://github.com/apache/druid/pull/10304#discussion_r482190591", "bodyText": "There isn't a test that runs on both non-vectorized and vectorized at the same time. Though the input/output used in vector aggregator tests is almost same as what is used in tests for non-vector aggregator.", "author": "abhishekagarwal87", "createdAt": "2020-09-02T16:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxMTUyMw=="}], "type": "inlineReview"}, {"oid": "44f276f3e4c74a755a0e28ee4c5d560d03fc6ac6", "url": "https://github.com/apache/druid/commit/44f276f3e4c74a755a0e28ee4c5d560d03fc6ac6", "message": "Vectorize only for supported types", "committedDate": "2020-09-03T09:57:06Z", "type": "commit"}, {"oid": "09ace2d0b9aaf40082891b7f34e2b4420a3c8a3d", "url": "https://github.com/apache/druid/commit/09ace2d0b9aaf40082891b7f34e2b4420a3c8a3d", "message": "Rename internal aggregator files", "committedDate": "2020-09-03T09:58:29Z", "type": "commit"}, {"oid": "adfb1353cb2b0fb7c8f52232f5c14e06b74f3496", "url": "https://github.com/apache/druid/commit/adfb1353cb2b0fb7c8f52232f5c14e06b74f3496", "message": "Fix tests", "committedDate": "2020-09-03T11:32:56Z", "type": "commit"}]}