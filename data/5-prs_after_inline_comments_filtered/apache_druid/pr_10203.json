{"pr_number": 10203, "pr_title": "Support unit on byte-related properties", "pr_createdAt": "2020-07-22T05:44:54Z", "pr_url": "https://github.com/apache/druid/pull/10203", "timeline": [{"oid": "2e1cc2b7444598257c9dcb24db30df02a1e6a31a", "url": "https://github.com/apache/druid/commit/2e1cc2b7444598257c9dcb24db30df02a1e6a31a", "message": "support unit suffix on byte-related properties", "committedDate": "2020-07-22T04:16:16Z", "type": "commit"}, {"oid": "b1fd4a6eda026ab74bf1ee2f9a0b81bbae7b8579", "url": "https://github.com/apache/druid/commit/b1fd4a6eda026ab74bf1ee2f9a0b81bbae7b8579", "message": "add doc", "committedDate": "2020-07-22T04:17:39Z", "type": "commit"}, {"oid": "0549e2bc71b91ed7c48454b4836ca6c21aab8062", "url": "https://github.com/apache/druid/commit/0549e2bc71b91ed7c48454b4836ca6c21aab8062", "message": "change default value of byte-related properites in example files", "committedDate": "2020-07-22T05:18:25Z", "type": "commit"}, {"oid": "115580a2282b333b2625409b29f378ea1461080c", "url": "https://github.com/apache/druid/commit/115580a2282b333b2625409b29f378ea1461080c", "message": "fix coding style", "committedDate": "2020-07-22T05:18:39Z", "type": "commit"}, {"oid": "2858729489126c4ece6a93cfbb72b9ece536d22e", "url": "https://github.com/apache/druid/commit/2858729489126c4ece6a93cfbb72b9ece536d22e", "message": "fix doc", "committedDate": "2020-07-22T05:47:38Z", "type": "commit"}, {"oid": "52e2aeaa8caaa7f4eafa91e62a275a1186ee38a6", "url": "https://github.com/apache/druid/commit/52e2aeaa8caaa7f4eafa91e62a275a1186ee38a6", "message": "fix CI", "committedDate": "2020-07-23T01:21:52Z", "type": "commit"}, {"oid": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "url": "https://github.com/apache/druid/commit/3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "message": "suppress spelling errors", "committedDate": "2020-07-23T02:34:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1Mjg0Mw==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459852843", "bodyText": "Please use StringUtils.toLowerCase() instead.", "author": "jihoonson", "createdAt": "2020-07-24T05:01:53Z", "path": "core/src/main/java/org/apache/druid/java/util/common/Bytes.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+@JsonSerialize(using = BytesSerializer.class)\n+public class Bytes implements Serializable\n+{\n+  public static final Bytes ZERO = new Bytes(0L);\n+\n+  private long value;\n+\n+  public Bytes(String value)\n+  {\n+    this.value = Bytes.parse(value);\n+  }\n+\n+  public Bytes(long value)\n+  {\n+    this.value = value;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Override\n+  public boolean equals(Object thatObj)\n+  {\n+    if (thatObj == null) {\n+      return false;\n+    }\n+    if (thatObj instanceof Bytes) {\n+      return value == ((Bytes) thatObj).value;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Long.hashCode(value);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return String.valueOf(value);\n+  }\n+\n+  public static Bytes valueOf(int bytes)\n+  {\n+    return new Bytes(bytes);\n+  }\n+\n+  public static Bytes valueOf(long bytes)\n+  {\n+    return new Bytes(bytes);\n+  }\n+\n+  public static long parse(String number)\n+  {\n+    if (number == null) {\n+      throw new IAE(\"number is null\");\n+    }\n+\n+    number = number.trim().toLowerCase(Locale.getDefault());", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1MjkzMg==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459852932", "bodyText": "Please use StringUtils.toLowerCase() instead.", "author": "jihoonson", "createdAt": "2020-07-24T05:02:25Z", "path": "core/src/main/java/org/apache/druid/java/util/common/Bytes.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+@JsonSerialize(using = BytesSerializer.class)\n+public class Bytes implements Serializable\n+{\n+  public static final Bytes ZERO = new Bytes(0L);\n+\n+  private long value;\n+\n+  public Bytes(String value)\n+  {\n+    this.value = Bytes.parse(value);\n+  }\n+\n+  public Bytes(long value)\n+  {\n+    this.value = value;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Override\n+  public boolean equals(Object thatObj)\n+  {\n+    if (thatObj == null) {\n+      return false;\n+    }\n+    if (thatObj instanceof Bytes) {\n+      return value == ((Bytes) thatObj).value;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Long.hashCode(value);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return String.valueOf(value);\n+  }\n+\n+  public static Bytes valueOf(int bytes)\n+  {\n+    return new Bytes(bytes);\n+  }\n+\n+  public static Bytes valueOf(long bytes)\n+  {\n+    return new Bytes(bytes);\n+  }\n+\n+  public static long parse(String number)\n+  {\n+    if (number == null) {\n+      throw new IAE(\"number is null\");\n+    }\n+\n+    number = number.trim().toLowerCase(Locale.getDefault());\n+    int len = number.length();\n+    if (len == 0) {\n+      throw new IAE(\"number is empty\");\n+    }\n+\n+    return parseInner(number);\n+  }\n+\n+  /**\n+   * parse the case-insensitive string number, which is either:\n+   * <p>\n+   * a number string\n+   * <p>\n+   * or\n+   * <p>\n+   * a number string with a suffix which indicates the unit the of number\n+   * the unit must be one of following\n+   * k - kilobyte = 1000\n+   * m - megabyte = 1,000,000\n+   * g - gigabyte = 1,000,000,000\n+   * t - terabyte = 1,000,000,000,000\n+   * p - petabyte = 1,000,000,000,000,000\n+   * KiB - kilo binary byte = 1024\n+   * MiB - mega binary byte = 1024*1204\n+   * GiB - giga binary byte = 1024*1024*1024\n+   * TiB - tera binary byte = 1024*1024*1024*1024\n+   * PiB - peta binary byte = 1024*1024*1024*1024*1024\n+   * <p>\n+   *\n+   * @param nullValue to be returned when given number is null or empty\n+   * @return nullValue if input is null or empty\n+   * value of number\n+   * @throws IAE if the input is invalid\n+   */\n+  public static long parse(String number, long nullValue)\n+  {\n+    if (number == null) {\n+      return nullValue;\n+    }\n+\n+    number = number.trim().toLowerCase(Locale.getDefault());", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NTYzOQ==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459855639", "bodyText": "nit: Bytes seems too broad. For example, Bytes.getValue() doesn't seem intuitive enough to me what it would return. Maybe HumanReadableBytes could be a more readable name.", "author": "jihoonson", "createdAt": "2020-07-24T05:16:32Z", "path": "core/src/main/java/org/apache/druid/java/util/common/Bytes.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+@JsonSerialize(using = BytesSerializer.class)\n+public class Bytes implements Serializable", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcwNzY0NA==", "url": "https://github.com/apache/druid/pull/10203#discussion_r460707644", "bodyText": "I didn't come up with a nice name at first. Bytes is really wide used and has no specific meaning. Your suggestion is great.", "author": "FrankChen021", "createdAt": "2020-07-27T07:51:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NjY0NQ==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459856645", "bodyText": "This wouldn't cause integer overflow because the max is limited as Integer.MAX_VALUE, but this seems fragile and easy to make a mistake. How about adding asInt() which has a check for integer overflow?", "author": "jihoonson", "createdAt": "2020-07-24T05:21:27Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/config/RemoteTaskRunnerConfig.java", "diffHunk": "@@ -81,15 +83,14 @@ public Period getTaskCleanupTimeout()\n \n   public int getMaxZnodeBytes()\n   {\n-    return maxZnodeBytes;\n+    return (int) maxZnodeBytes.getValue();", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcxMzMxNQ==", "url": "https://github.com/apache/druid/pull/10203#discussion_r460713315", "bodyText": "A new getBytesInInt is provided to check the potential overflow.", "author": "FrankChen021", "createdAt": "2020-07-27T08:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NjY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NzIwMQ==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459857201", "bodyText": "I guess we can call Bytes.parse() without default value since bufferSizeConfigured() has default?", "author": "jihoonson", "createdAt": "2020-07-24T05:24:15Z", "path": "processing/src/main/java/org/apache/druid/query/DruidProcessingConfig.java", "diffHunk": "@@ -40,9 +41,14 @@\n   private AtomicReference<Integer> computedBufferSizeBytes = new AtomicReference<>();\n \n   @Config({\"druid.computation.buffer.size\", \"${base_path}.buffer.sizeBytes\"})\n+  public String bufferSizeConfigured()\n+  {\n+    return \"-1\";\n+  }\n+\n   public int intermediateComputeSizeBytesConfigured()\n   {\n-    return DEFAULT_PROCESSING_BUFFER_SIZE_BYTES;\n+    return (int) Bytes.parse(bufferSizeConfigured(), DEFAULT_PROCESSING_BUFFER_SIZE_BYTES);", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1OTEzNA==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459859134", "bodyText": "Hmm, this method can be called several times during processing a query. Why not returning Bytes in bufferSizeConfigured() instead of String?", "author": "jihoonson", "createdAt": "2020-07-24T05:32:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NzIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcwOTIyNg==", "url": "https://github.com/apache/druid/pull/10203#discussion_r460709226", "bodyText": "Yes, it should return an instance of Bytes. I didn't understand how @Config works at first, so String was used.", "author": "FrankChen021", "createdAt": "2020-07-27T07:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NzIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NzI4Nw==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459857287", "bodyText": "Please make it as a static variable.", "author": "jihoonson", "createdAt": "2020-07-24T05:24:42Z", "path": "processing/src/main/java/org/apache/druid/query/DruidProcessingConfig.java", "diffHunk": "@@ -40,9 +41,14 @@\n   private AtomicReference<Integer> computedBufferSizeBytes = new AtomicReference<>();\n \n   @Config({\"druid.computation.buffer.size\", \"${base_path}.buffer.sizeBytes\"})\n+  public String bufferSizeConfigured()\n+  {\n+    return \"-1\";", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NzUxNA==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459857514", "bodyText": "Please add simple javadoc about what this annotation is and how it is used.", "author": "jihoonson", "createdAt": "2020-07-24T05:25:39Z", "path": "core/src/main/java/org/apache/druid/java/util/common/BytesRange.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import javax.validation.Constraint;\n+import javax.validation.ConstraintValidator;\n+import javax.validation.ConstraintValidatorContext;\n+import javax.validation.Payload;\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({\n+    ElementType.FIELD,\n+    ElementType.PARAMETER\n+})\n+@Retention(RetentionPolicy.RUNTIME)\n+@Documented\n+@Constraint(validatedBy = BytesRange.DateRangeValidator.class)\n+public @interface BytesRange", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MDA4Mw==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459860083", "bodyText": "nit: ExpectedException is preferred since you can verify the error message as well as the exception type. This is useful since even when the same type of exception is thrown, exceptions from different area of code can have different messages.", "author": "jihoonson", "createdAt": "2020-07-24T05:37:02Z", "path": "core/src/test/java/org/apache/druid/java/util/common/BytesTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.Validation;\n+import javax.validation.Validator;\n+import javax.validation.groups.Default;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class BytesTest\n+{\n+  @Test\n+  public void testNumberString()\n+  {\n+    Assert.assertEquals(1, Bytes.parse(\"1\", 0L));\n+    Assert.assertEquals(10000000, Bytes.parse(\"10000000\", 0));\n+  }\n+\n+  @Test\n+  public void testWithWhiteSpace()\n+  {\n+    Assert.assertEquals(12345, Bytes.parse(\" 12345 \", 0));\n+    Assert.assertEquals(12345, Bytes.parse(\"\\t12345\\t\", 0));\n+  }\n+\n+  @Test\n+  public void testK()\n+  {\n+    Assert.assertEquals(1000, Bytes.parse(\"1k\", 0));\n+    Assert.assertEquals(1000, Bytes.parse(\"1K\", 0));\n+  }\n+\n+  @Test\n+  public void testM()\n+  {\n+    Assert.assertEquals(1000_000, Bytes.parse(\"1m\", 0));\n+    Assert.assertEquals(1000_000, Bytes.parse(\"1M\", 0));\n+  }\n+\n+  @Test\n+  public void testG()\n+  {\n+    Assert.assertEquals(1000_000_000, Bytes.parse(\"1g\", 0));\n+    Assert.assertEquals(1000_000_000, Bytes.parse(\"1G\", 0));\n+  }\n+\n+  @Test\n+  public void testT()\n+  {\n+    Assert.assertEquals(1000_000_000_000L, Bytes.parse(\"1t\", 0));\n+    Assert.assertEquals(1000_000_000_000L, Bytes.parse(\"1T\", 0));\n+  }\n+\n+  @Test\n+  public void testKiB()\n+  {\n+    Assert.assertEquals(1024, Bytes.parse(\"1kib\", 0));\n+    Assert.assertEquals(9 * 1024, Bytes.parse(\"9KiB\", 0));\n+    Assert.assertEquals(9 * 1024, Bytes.parse(\"9Kib\", 0));\n+  }\n+\n+  @Test\n+  public void testMb()\n+  {\n+    Assert.assertEquals(1024 * 1024, Bytes.parse(\"1mib\", 0));\n+    Assert.assertEquals(9 * 1024 * 1024, Bytes.parse(\"9MiB\", 0));\n+    Assert.assertEquals(9 * 1024 * 1024, Bytes.parse(\"9Mib\", 0));\n+  }\n+\n+  @Test\n+  public void testGiB()\n+  {\n+    Assert.assertEquals(1024 * 1024 * 1024, Bytes.parse(\"1gib\", 0));\n+    Assert.assertEquals(1024 * 1024 * 1024, Bytes.parse(\"1GiB\", 0));\n+    Assert.assertEquals(9L * 1024 * 1024 * 1024, Bytes.parse(\"9Gib\", 0));\n+  }\n+\n+  @Test\n+  public void testTiB()\n+  {\n+    Assert.assertEquals(1024 * 1024 * 1024 * 1024L, Bytes.parse(\"1tib\", 0));\n+    Assert.assertEquals(9L * 1024 * 1024 * 1024 * 1024, Bytes.parse(\"9TiB\", 0));\n+    Assert.assertEquals(9L * 1024 * 1024 * 1024 * 1024, Bytes.parse(\"9Tib\", 0));\n+  }\n+\n+  @Test\n+  public void testPiB()\n+  {\n+    Assert.assertEquals(1024L * 1024 * 1024 * 1024 * 1024, Bytes.parse(\"1pib\", 0));\n+    Assert.assertEquals(9L * 1024 * 1024 * 1024 * 1024 * 1024, Bytes.parse(\"9PiB\", 0));\n+    Assert.assertEquals(9L * 1024 * 1024 * 1024 * 1024 * 1024, Bytes.parse(\"9Pib\", 0));\n+  }\n+\n+  @Test\n+  public void testDefault()\n+  {\n+    Assert.assertEquals(-123, Bytes.parse(\" \", -123));\n+    Assert.assertEquals(-456, Bytes.parse(null, -456));\n+    Assert.assertEquals(-789, Bytes.parse(\"\\t\", -789));\n+  }\n+\n+  @Test\n+  public void testException()\n+  {\n+    try {\n+      Bytes.parse(\"b\", 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MDU3Mg==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459860572", "bodyText": "We usually name a test class to have the Test suffix if it has unit tests. How about TestBytesRange?", "author": "jihoonson", "createdAt": "2020-07-24T05:39:08Z", "path": "core/src/test/java/org/apache/druid/java/util/common/BytesTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.validation.ConstraintViolation;\n+import javax.validation.Validation;\n+import javax.validation.Validator;\n+import javax.validation.groups.Default;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class BytesTest\n+{\n+  @Test\n+  public void testNumberString()\n+  {\n+    Assert.assertEquals(1, Bytes.parse(\"1\", 0L));\n+    Assert.assertEquals(10000000, Bytes.parse(\"10000000\", 0));\n+  }\n+\n+  @Test\n+  public void testWithWhiteSpace()\n+  {\n+    Assert.assertEquals(12345, Bytes.parse(\" 12345 \", 0));\n+    Assert.assertEquals(12345, Bytes.parse(\"\\t12345\\t\", 0));\n+  }\n+\n+  @Test\n+  public void testK()\n+  {\n+    Assert.assertEquals(1000, Bytes.parse(\"1k\", 0));\n+    Assert.assertEquals(1000, Bytes.parse(\"1K\", 0));\n+  }\n+\n+  @Test\n+  public void testM()\n+  {\n+    Assert.assertEquals(1000_000, Bytes.parse(\"1m\", 0));\n+    Assert.assertEquals(1000_000, Bytes.parse(\"1M\", 0));\n+  }\n+\n+  @Test\n+  public void testG()\n+  {\n+    Assert.assertEquals(1000_000_000, Bytes.parse(\"1g\", 0));\n+    Assert.assertEquals(1000_000_000, Bytes.parse(\"1G\", 0));\n+  }\n+\n+  @Test\n+  public void testT()\n+  {\n+    Assert.assertEquals(1000_000_000_000L, Bytes.parse(\"1t\", 0));\n+    Assert.assertEquals(1000_000_000_000L, Bytes.parse(\"1T\", 0));\n+  }\n+\n+  @Test\n+  public void testKiB()\n+  {\n+    Assert.assertEquals(1024, Bytes.parse(\"1kib\", 0));\n+    Assert.assertEquals(9 * 1024, Bytes.parse(\"9KiB\", 0));\n+    Assert.assertEquals(9 * 1024, Bytes.parse(\"9Kib\", 0));\n+  }\n+\n+  @Test\n+  public void testMb()\n+  {\n+    Assert.assertEquals(1024 * 1024, Bytes.parse(\"1mib\", 0));\n+    Assert.assertEquals(9 * 1024 * 1024, Bytes.parse(\"9MiB\", 0));\n+    Assert.assertEquals(9 * 1024 * 1024, Bytes.parse(\"9Mib\", 0));\n+  }\n+\n+  @Test\n+  public void testGiB()\n+  {\n+    Assert.assertEquals(1024 * 1024 * 1024, Bytes.parse(\"1gib\", 0));\n+    Assert.assertEquals(1024 * 1024 * 1024, Bytes.parse(\"1GiB\", 0));\n+    Assert.assertEquals(9L * 1024 * 1024 * 1024, Bytes.parse(\"9Gib\", 0));\n+  }\n+\n+  @Test\n+  public void testTiB()\n+  {\n+    Assert.assertEquals(1024 * 1024 * 1024 * 1024L, Bytes.parse(\"1tib\", 0));\n+    Assert.assertEquals(9L * 1024 * 1024 * 1024 * 1024, Bytes.parse(\"9TiB\", 0));\n+    Assert.assertEquals(9L * 1024 * 1024 * 1024 * 1024, Bytes.parse(\"9Tib\", 0));\n+  }\n+\n+  @Test\n+  public void testPiB()\n+  {\n+    Assert.assertEquals(1024L * 1024 * 1024 * 1024 * 1024, Bytes.parse(\"1pib\", 0));\n+    Assert.assertEquals(9L * 1024 * 1024 * 1024 * 1024 * 1024, Bytes.parse(\"9PiB\", 0));\n+    Assert.assertEquals(9L * 1024 * 1024 * 1024 * 1024 * 1024, Bytes.parse(\"9Pib\", 0));\n+  }\n+\n+  @Test\n+  public void testDefault()\n+  {\n+    Assert.assertEquals(-123, Bytes.parse(\" \", -123));\n+    Assert.assertEquals(-456, Bytes.parse(null, -456));\n+    Assert.assertEquals(-789, Bytes.parse(\"\\t\", -789));\n+  }\n+\n+  @Test\n+  public void testException()\n+  {\n+    try {\n+      Bytes.parse(\"b\", 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+      Assert.assertTrue(true);\n+    }\n+\n+    try {\n+      Bytes.parse(\"1 b\", 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+      Assert.assertTrue(true);\n+    }\n+\n+    try {\n+      Bytes.parse(\"tb\", 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+      Assert.assertTrue(true);\n+    }\n+\n+    try {\n+      Bytes.parse(\"1 mb\", 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+      Assert.assertTrue(true);\n+    }\n+\n+    try {\n+      Bytes.parse(\"gb\", 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+      Assert.assertTrue(true);\n+    }\n+\n+    try {\n+      Bytes.parse(\"tb\", 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+      Assert.assertTrue(true);\n+    }\n+  }\n+\n+  @Test\n+  public void testOverflow()\n+  {\n+    try {\n+      Bytes.parse(\"123456789123456789123\", 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+    }\n+\n+    try {\n+      String max = (Long.MAX_VALUE / 1000 + 1) + \"k\";\n+      Bytes.parse(max, 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+    }\n+\n+    try {\n+      String max = (Long.MAX_VALUE / 1000_000 + 1) + \"m\";\n+      Bytes.parse(max, 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+    }\n+\n+    try {\n+      String max = (Long.MAX_VALUE / 1000_000_000L + 1) + \"g\";\n+      Bytes.parse(max, 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+    }\n+\n+    try {\n+      String max = (Long.MAX_VALUE / 1000_000_000_000L + 1) + \"t\";\n+      Bytes.parse(max, 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+    }\n+\n+    try {\n+      String max = (Long.MAX_VALUE / 1024 + 1) + \"kb\";\n+      Bytes.parse(max, 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+    }\n+\n+    try {\n+      String max = (Long.MAX_VALUE / (1024 * 1024) + 1) + \"mb\";\n+      Bytes.parse(max, 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+    }\n+\n+    try {\n+      String max = (Long.MAX_VALUE / (1024L * 1024 * 1024) + 1) + \"gb\";\n+      Bytes.parse(max, 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+    }\n+\n+    try {\n+      String max = (Long.MAX_VALUE / (1024L * 1024 * 1024 * 1024) + 1) + \"tb\";\n+      Bytes.parse(max, 0);\n+      Assert.assertFalse(\"IAE should be thrown\", true);\n+    }\n+    catch (IAE e) {\n+    }\n+  }\n+\n+  @Test\n+  public void testJSON() throws JsonProcessingException\n+  {\n+    ObjectMapper mapper = new ObjectMapper();\n+    Bytes bytes = new Bytes(\"5m\");\n+    String serialized = mapper.writeValueAsString(bytes);\n+    Bytes deserialized = mapper.readValue(serialized, Bytes.class);\n+    Assert.assertEquals(bytes, deserialized);\n+  }\n+\n+  public static class BytesRangeTest", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MzI2NQ==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459863265", "bodyText": "Why not checking overflow here too?", "author": "jihoonson", "createdAt": "2020-07-24T05:50:38Z", "path": "core/src/main/java/org/apache/druid/java/util/common/Bytes.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+@JsonSerialize(using = BytesSerializer.class)\n+public class Bytes implements Serializable\n+{\n+  public static final Bytes ZERO = new Bytes(0L);\n+\n+  private long value;\n+\n+  public Bytes(String value)\n+  {\n+    this.value = Bytes.parse(value);\n+  }\n+\n+  public Bytes(long value)\n+  {\n+    this.value = value;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Override\n+  public boolean equals(Object thatObj)\n+  {\n+    if (thatObj == null) {\n+      return false;\n+    }\n+    if (thatObj instanceof Bytes) {\n+      return value == ((Bytes) thatObj).value;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Long.hashCode(value);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return String.valueOf(value);\n+  }\n+\n+  public static Bytes valueOf(int bytes)\n+  {\n+    return new Bytes(bytes);\n+  }\n+\n+  public static Bytes valueOf(long bytes)\n+  {\n+    return new Bytes(bytes);\n+  }\n+\n+  public static long parse(String number)\n+  {\n+    if (number == null) {\n+      throw new IAE(\"number is null\");\n+    }\n+\n+    number = number.trim().toLowerCase(Locale.getDefault());\n+    int len = number.length();\n+    if (len == 0) {\n+      throw new IAE(\"number is empty\");\n+    }\n+\n+    return parseInner(number);\n+  }\n+\n+  /**\n+   * parse the case-insensitive string number, which is either:\n+   * <p>\n+   * a number string\n+   * <p>\n+   * or\n+   * <p>\n+   * a number string with a suffix which indicates the unit the of number\n+   * the unit must be one of following\n+   * k - kilobyte = 1000\n+   * m - megabyte = 1,000,000\n+   * g - gigabyte = 1,000,000,000\n+   * t - terabyte = 1,000,000,000,000\n+   * p - petabyte = 1,000,000,000,000,000\n+   * KiB - kilo binary byte = 1024\n+   * MiB - mega binary byte = 1024*1204\n+   * GiB - giga binary byte = 1024*1024*1024\n+   * TiB - tera binary byte = 1024*1024*1024*1024\n+   * PiB - peta binary byte = 1024*1024*1024*1024*1024\n+   * <p>\n+   *\n+   * @param nullValue to be returned when given number is null or empty\n+   * @return nullValue if input is null or empty\n+   * value of number\n+   * @throws IAE if the input is invalid\n+   */\n+  public static long parse(String number, long nullValue)\n+  {\n+    if (number == null) {\n+      return nullValue;\n+    }\n+\n+    number = number.trim().toLowerCase(Locale.getDefault());\n+    if (number.length() == 0) {\n+      return nullValue;\n+    }\n+    return parseInner(number);\n+  }\n+\n+  private static long parseInner(String number)\n+  {\n+    int index = number.length() - 1;\n+    boolean isBinary = false;\n+    char unit = number.charAt(index--);\n+    if (unit == 'b') {\n+      if (index < 2) {\n+        throw new IAE(\"invalid format of number[%s]\", number);\n+      }\n+      if (number.charAt(index--) != 'i') {\n+        throw new IAE(\"invalid format of number[%s]\", number);\n+      }\n+\n+      unit = number.charAt(index--);\n+      isBinary = true;\n+    }\n+    long base = 1;\n+    switch (unit) {\n+      case 'k':\n+        base = isBinary ? 1024 : 1_000;\n+        break;\n+\n+      case 'm':\n+        base = isBinary ? 1024 * 1024 : 1_000_000;\n+        break;\n+\n+      case 'g':\n+        base = isBinary ? 1024 * 1024 * 1024 : 1_000_000_000;\n+        break;\n+\n+      case 't':\n+        base = isBinary ? 1024 * 1024 * 1024 * 1024L : 1_000_000_000_000L;\n+        break;\n+\n+      case 'p':\n+        base = isBinary ? 1024L * 1024 * 1024 * 1024 * 1024 : 1_000_000_000_000_000L;\n+        break;\n+\n+      default:\n+        if (!Character.isDigit(unit)) {\n+          throw new IAE(\"invalid character in number[%s]\", number);\n+        }\n+        break;\n+    }\n+\n+    try {\n+      if (base > 1 && index >= 0) {\n+        long value = Long.parseLong(number.substring(0, index + 1)) * base;\n+        if (value < base) {\n+          throw new IAE(\"number [%s] overflow\", number);\n+        }\n+        return value;\n+      } else {\n+        return Long.parseLong(number);", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcxMjkzMg==", "url": "https://github.com/apache/druid/pull/10203#discussion_r460712932", "bodyText": "Overflow has been checked inside parseLong . If overflowed, NumberFormatException will be thrown. I've add a comment in the new code.", "author": "FrankChen021", "createdAt": "2020-07-27T08:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MzI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MzY1Ng==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459863656", "bodyText": "Out of curiosity, why does this compare against base instead of 0?", "author": "jihoonson", "createdAt": "2020-07-24T05:52:15Z", "path": "core/src/main/java/org/apache/druid/java/util/common/Bytes.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+@JsonSerialize(using = BytesSerializer.class)\n+public class Bytes implements Serializable\n+{\n+  public static final Bytes ZERO = new Bytes(0L);\n+\n+  private long value;\n+\n+  public Bytes(String value)\n+  {\n+    this.value = Bytes.parse(value);\n+  }\n+\n+  public Bytes(long value)\n+  {\n+    this.value = value;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Override\n+  public boolean equals(Object thatObj)\n+  {\n+    if (thatObj == null) {\n+      return false;\n+    }\n+    if (thatObj instanceof Bytes) {\n+      return value == ((Bytes) thatObj).value;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Long.hashCode(value);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return String.valueOf(value);\n+  }\n+\n+  public static Bytes valueOf(int bytes)\n+  {\n+    return new Bytes(bytes);\n+  }\n+\n+  public static Bytes valueOf(long bytes)\n+  {\n+    return new Bytes(bytes);\n+  }\n+\n+  public static long parse(String number)\n+  {\n+    if (number == null) {\n+      throw new IAE(\"number is null\");\n+    }\n+\n+    number = number.trim().toLowerCase(Locale.getDefault());\n+    int len = number.length();\n+    if (len == 0) {\n+      throw new IAE(\"number is empty\");\n+    }\n+\n+    return parseInner(number);\n+  }\n+\n+  /**\n+   * parse the case-insensitive string number, which is either:\n+   * <p>\n+   * a number string\n+   * <p>\n+   * or\n+   * <p>\n+   * a number string with a suffix which indicates the unit the of number\n+   * the unit must be one of following\n+   * k - kilobyte = 1000\n+   * m - megabyte = 1,000,000\n+   * g - gigabyte = 1,000,000,000\n+   * t - terabyte = 1,000,000,000,000\n+   * p - petabyte = 1,000,000,000,000,000\n+   * KiB - kilo binary byte = 1024\n+   * MiB - mega binary byte = 1024*1204\n+   * GiB - giga binary byte = 1024*1024*1024\n+   * TiB - tera binary byte = 1024*1024*1024*1024\n+   * PiB - peta binary byte = 1024*1024*1024*1024*1024\n+   * <p>\n+   *\n+   * @param nullValue to be returned when given number is null or empty\n+   * @return nullValue if input is null or empty\n+   * value of number\n+   * @throws IAE if the input is invalid\n+   */\n+  public static long parse(String number, long nullValue)\n+  {\n+    if (number == null) {\n+      return nullValue;\n+    }\n+\n+    number = number.trim().toLowerCase(Locale.getDefault());\n+    if (number.length() == 0) {\n+      return nullValue;\n+    }\n+    return parseInner(number);\n+  }\n+\n+  private static long parseInner(String number)\n+  {\n+    int index = number.length() - 1;\n+    boolean isBinary = false;\n+    char unit = number.charAt(index--);\n+    if (unit == 'b') {\n+      if (index < 2) {\n+        throw new IAE(\"invalid format of number[%s]\", number);\n+      }\n+      if (number.charAt(index--) != 'i') {\n+        throw new IAE(\"invalid format of number[%s]\", number);\n+      }\n+\n+      unit = number.charAt(index--);\n+      isBinary = true;\n+    }\n+    long base = 1;\n+    switch (unit) {\n+      case 'k':\n+        base = isBinary ? 1024 : 1_000;\n+        break;\n+\n+      case 'm':\n+        base = isBinary ? 1024 * 1024 : 1_000_000;\n+        break;\n+\n+      case 'g':\n+        base = isBinary ? 1024 * 1024 * 1024 : 1_000_000_000;\n+        break;\n+\n+      case 't':\n+        base = isBinary ? 1024 * 1024 * 1024 * 1024L : 1_000_000_000_000L;\n+        break;\n+\n+      case 'p':\n+        base = isBinary ? 1024L * 1024 * 1024 * 1024 * 1024 : 1_000_000_000_000_000L;\n+        break;\n+\n+      default:\n+        if (!Character.isDigit(unit)) {\n+          throw new IAE(\"invalid character in number[%s]\", number);\n+        }\n+        break;\n+    }\n+\n+    try {\n+      if (base > 1 && index >= 0) {\n+        long value = Long.parseLong(number.substring(0, index + 1)) * base;\n+        if (value < base) {", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcxMTk5MA==", "url": "https://github.com/apache/druid/pull/10203#discussion_r460711990", "bodyText": "it's tricky here, because when base equals to 1, index, substring should not be called. I've made some changes to eliminate the confusing code.", "author": "FrankChen021", "createdAt": "2020-07-27T07:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2MzY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NDUzMA==", "url": "https://github.com/apache/druid/pull/10203#discussion_r459864530", "bodyText": "All error messages should start with a capital letter. Please fix other places too.", "author": "jihoonson", "createdAt": "2020-07-24T05:55:44Z", "path": "core/src/main/java/org/apache/druid/java/util/common/Bytes.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+@JsonSerialize(using = BytesSerializer.class)\n+public class Bytes implements Serializable\n+{\n+  public static final Bytes ZERO = new Bytes(0L);\n+\n+  private long value;\n+\n+  public Bytes(String value)\n+  {\n+    this.value = Bytes.parse(value);\n+  }\n+\n+  public Bytes(long value)\n+  {\n+    this.value = value;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Override\n+  public boolean equals(Object thatObj)\n+  {\n+    if (thatObj == null) {\n+      return false;\n+    }\n+    if (thatObj instanceof Bytes) {\n+      return value == ((Bytes) thatObj).value;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Long.hashCode(value);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return String.valueOf(value);\n+  }\n+\n+  public static Bytes valueOf(int bytes)\n+  {\n+    return new Bytes(bytes);\n+  }\n+\n+  public static Bytes valueOf(long bytes)\n+  {\n+    return new Bytes(bytes);\n+  }\n+\n+  public static long parse(String number)\n+  {\n+    if (number == null) {\n+      throw new IAE(\"number is null\");", "originalCommit": "3f64c7b55ff10e36f64c198b363f8ca65f3a59b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fbc61c2ace7cd2d5166cce2806d3bfa52ea1b497", "url": "https://github.com/apache/druid/commit/fbc61c2ace7cd2d5166cce2806d3bfa52ea1b497", "message": "improve code according to comments", "committedDate": "2020-07-27T03:13:50Z", "type": "commit"}, {"oid": "f58d268a81e27066f4970c3468fefc8351394bdd", "url": "https://github.com/apache/druid/commit/f58d268a81e27066f4970c3468fefc8351394bdd", "message": "rename Bytes to HumanReadableBytes", "committedDate": "2020-07-27T03:26:44Z", "type": "commit"}, {"oid": "023b908d76192c6387dae54a6aeb900a2e0ea893", "url": "https://github.com/apache/druid/commit/023b908d76192c6387dae54a6aeb900a2e0ea893", "message": "add getBytesInInt to get value safely", "committedDate": "2020-07-27T06:53:20Z", "type": "commit"}, {"oid": "8464960c40d1a44bb732d404b116899b474a3d7b", "url": "https://github.com/apache/druid/commit/8464960c40d1a44bb732d404b116899b474a3d7b", "message": "improve doc", "committedDate": "2020-07-27T08:09:38Z", "type": "commit"}, {"oid": "2dfb1360ca2c21430b3ea4fd7ce9d4dc23bd9301", "url": "https://github.com/apache/druid/commit/2dfb1360ca2c21430b3ea4fd7ce9d4dc23bd9301", "message": "fix problem reported by CI", "committedDate": "2020-07-27T08:11:36Z", "type": "commit"}, {"oid": "c86454be59a1f3f34f2d596a82ea9a3c1a009114", "url": "https://github.com/apache/druid/commit/c86454be59a1f3f34f2d596a82ea9a3c1a009114", "message": "fix problem reported by CI", "committedDate": "2020-07-27T10:04:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4ODU0Nw==", "url": "https://github.com/apache/druid/pull/10203#discussion_r461388547", "bodyText": "I missed this before. Does Serializable do anything here? It doesn't seem so.", "author": "jihoonson", "createdAt": "2020-07-28T07:53:49Z", "path": "core/src/main/java/org/apache/druid/java/util/common/HumanReadableBytes.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.io.Serializable;\n+\n+@JsonSerialize(using = HumanReadableBytesSerializer.class)\n+public class HumanReadableBytes implements Serializable", "originalCommit": "c86454be59a1f3f34f2d596a82ea9a3c1a009114", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwNjk1Ng==", "url": "https://github.com/apache/druid/pull/10203#discussion_r461406956", "bodyText": "It would be nice to log that the number might be out of range of long.", "author": "jihoonson", "createdAt": "2020-07-28T08:25:51Z", "path": "core/src/main/java/org/apache/druid/java/util/common/HumanReadableBytes.java", "diffHunk": "@@ -128,71 +135,76 @@ public static long parse(String number, long nullValue)\n       return nullValue;\n     }\n \n-    number = number.trim().toLowerCase(Locale.getDefault());\n+    number = number.trim();\n     if (number.length() == 0) {\n       return nullValue;\n     }\n     return parseInner(number);\n   }\n \n-  private static long parseInner(String number)\n+  private static long parseInner(String rawNumber)\n   {\n-    int index = number.length() - 1;\n-    boolean isBinary = false;\n-    char unit = number.charAt(index--);\n+    String number = StringUtils.toLowerCase(rawNumber);\n+    if (number.charAt(0) == '-') {\n+      throw new IAE(\"Invalid format of number: %s. Negative value is not allowed.\", rawNumber);\n+    }\n+\n+    int lastDigitIndex = number.length() - 1;\n+    boolean isBinaryByte = false;\n+    char unit = number.charAt(lastDigitIndex--);\n     if (unit == 'b') {\n-      if (index < 2) {\n-        throw new IAE(\"invalid format of number[%s]\", number);\n+      //unit ends with 'b' must be format of KiB/MiB/GiB/TiB/PiB, so at least 3 extra characters are required\n+      if (lastDigitIndex < 2) {\n+        throw new IAE(\"Invalid format of number: %s\", rawNumber);\n       }\n-      if (number.charAt(index--) != 'i') {\n-        throw new IAE(\"invalid format of number[%s]\", number);\n+      if (number.charAt(lastDigitIndex--) != 'i') {\n+        throw new IAE(\"Invalid format of number: %s\", rawNumber);\n       }\n \n-      unit = number.charAt(index--);\n-      isBinary = true;\n+      unit = number.charAt(lastDigitIndex--);\n+      isBinaryByte = true;\n     }\n+\n     long base = 1;\n     switch (unit) {\n       case 'k':\n-        base = isBinary ? 1024 : 1_000;\n+        base = isBinaryByte ? 1024 : 1_000;\n         break;\n \n       case 'm':\n-        base = isBinary ? 1024 * 1024 : 1_000_000;\n+        base = isBinaryByte ? 1024 * 1024 : 1_000_000;\n         break;\n \n       case 'g':\n-        base = isBinary ? 1024 * 1024 * 1024 : 1_000_000_000;\n+        base = isBinaryByte ? 1024 * 1024 * 1024 : 1_000_000_000;\n         break;\n \n       case 't':\n-        base = isBinary ? 1024 * 1024 * 1024 * 1024L : 1_000_000_000_000L;\n+        base = isBinaryByte ? 1024 * 1024 * 1024 * 1024L : 1_000_000_000_000L;\n         break;\n \n       case 'p':\n-        base = isBinary ? 1024L * 1024 * 1024 * 1024 * 1024 : 1_000_000_000_000_000L;\n+        base = isBinaryByte ? 1024L * 1024 * 1024 * 1024 * 1024 : 1_000_000_000_000_000L;\n         break;\n \n       default:\n+        lastDigitIndex++;\n         if (!Character.isDigit(unit)) {\n-          throw new IAE(\"invalid character in number[%s]\", number);\n+          throw new IAE(\"Invalid format of number: %s\", rawNumber);\n         }\n         break;\n     }\n \n     try {\n-      if (base > 1 && index >= 0) {\n-        long value = Long.parseLong(number.substring(0, index + 1)) * base;\n-        if (value < base) {\n-          throw new IAE(\"number [%s] overflow\", number);\n-        }\n-        return value;\n-      } else {\n-        return Long.parseLong(number);\n+      long value = Long.parseLong(number.substring(0, lastDigitIndex + 1)) * base;\n+      if (base > 1 && value < base) {\n+        //for base == 1, overflow has been checked in parseLong\n+        throw new IAE(\"Number overflow: %s\", rawNumber);\n       }\n+      return value;\n     }\n     catch (NumberFormatException e) {\n-      throw new IAE(\"invalid format of number[%s]\", number);\n+      throw new IAE(\"Invalid format of number: %s\", rawNumber);", "originalCommit": "c86454be59a1f3f34f2d596a82ea9a3c1a009114", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMDgwMg==", "url": "https://github.com/apache/druid/pull/10203#discussion_r462010802", "bodyText": "NumberFormatException throws when 1) there're invalid characters ; 2) number overflows. It's unknown for us which case it is when it's thrown.", "author": "FrankChen021", "createdAt": "2020-07-29T03:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwNjk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAzMjEzMA==", "url": "https://github.com/apache/druid/pull/10203#discussion_r462032130", "bodyText": "I meant the error message should be correct so that Druid operators can fix the issue. The current message can be misleading since it doesn't mention another possibility for out of range. Perhaps it's better to be Invalid number format or out of range of long: %s.", "author": "jihoonson", "createdAt": "2020-07-29T04:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwNjk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcxNjA2Mg==", "url": "https://github.com/apache/druid/pull/10203#discussion_r461716062", "bodyText": "Can be final.", "author": "jihoonson", "createdAt": "2020-07-28T16:31:44Z", "path": "core/src/main/java/org/apache/druid/java/util/common/HumanReadableBytes.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.io.Serializable;\n+\n+@JsonSerialize(using = HumanReadableBytesSerializer.class)\n+public class HumanReadableBytes implements Serializable\n+{\n+  public static final HumanReadableBytes ZERO = new HumanReadableBytes(0L);\n+\n+  private long bytes;", "originalCommit": "c86454be59a1f3f34f2d596a82ea9a3c1a009114", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NjA1MQ==", "url": "https://github.com/apache/druid/pull/10203#discussion_r461766051", "bodyText": "The custom serializer doesn't seem necessary. AFAIT, this class never gets serialized. In deserializing, Jackson will magically finds the proper constructor depending on the parameter type.", "author": "jihoonson", "createdAt": "2020-07-28T17:53:50Z", "path": "core/src/main/java/org/apache/druid/java/util/common/HumanReadableBytes.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.io.Serializable;\n+\n+@JsonSerialize(using = HumanReadableBytesSerializer.class)", "originalCommit": "c86454be59a1f3f34f2d596a82ea9a3c1a009114", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAxMDkzNQ==", "url": "https://github.com/apache/druid/pull/10203#discussion_r462010935", "bodyText": "HumanReadableBytes is referenced by other classes such as ServerConfig. The test cases of the latter ones test serialization and deserialization. So this serializer annotation currently works for test cases only.", "author": "FrankChen021", "createdAt": "2020-07-29T03:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NjA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAzMjIyNA==", "url": "https://github.com/apache/druid/pull/10203#discussion_r462032224", "bodyText": "Hmm, I'm not sure why we have ServerConfigTest.testSerde() even though ServerConfig doesn't seem to be serialized/deserialized. @jon-wei do you have any idea?", "author": "jihoonson", "createdAt": "2020-07-29T04:34:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NjA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUwNzM1Ng==", "url": "https://github.com/apache/druid/pull/10203#discussion_r462507356", "bodyText": "It's deserialized from configs in JettyServerModule:\nJsonConfigProvider.bind(binder, \"druid.server.http\", ServerConfig.class);", "author": "jon-wei", "createdAt": "2020-07-29T18:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NjA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5OTE2NA==", "url": "https://github.com/apache/druid/pull/10203#discussion_r462599164", "bodyText": "Ah I see. It's used in another Jackson magic. Thanks.", "author": "jihoonson", "createdAt": "2020-07-29T21:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NjA1MQ=="}], "type": "inlineReview"}, {"oid": "e43e17a5dccf9dc952565196a2e2e0178c28a786", "url": "https://github.com/apache/druid/commit/e43e17a5dccf9dc952565196a2e2e0178c28a786", "message": "resolve code review comments", "committedDate": "2020-07-29T03:05:21Z", "type": "commit"}, {"oid": "8d971695482878cd7262c5c5921340cd55380ff0", "url": "https://github.com/apache/druid/commit/8d971695482878cd7262c5c5921340cd55380ff0", "message": "improve error message", "committedDate": "2020-07-29T10:27:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MzU0MA==", "url": "https://github.com/apache/druid/pull/10203#discussion_r462263540", "bodyText": "The error message is best to be consistent with the previous one. In addition, perhaps it is more appropriate to use blank instead of empty here.", "author": "asdf2014", "createdAt": "2020-07-29T12:34:41Z", "path": "core/src/main/java/org/apache/druid/java/util/common/HumanReadableBytes.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.java.util.common;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+@JsonSerialize(using = HumanReadableBytesSerializer.class)\n+public class HumanReadableBytes\n+{\n+  public static final HumanReadableBytes ZERO = new HumanReadableBytes(0L);\n+\n+  private final long bytes;\n+\n+  public HumanReadableBytes(String bytes)\n+  {\n+    this.bytes = HumanReadableBytes.parse(bytes);\n+  }\n+\n+  public HumanReadableBytes(long bytes)\n+  {\n+    this.bytes = bytes;\n+  }\n+\n+  public long getBytes()\n+  {\n+    return bytes;\n+  }\n+\n+  public int getBytesInInt()\n+  {\n+    if (bytes > Integer.MAX_VALUE) {\n+      throw new ISE(\"Number overflow\");\n+    }\n+\n+    return (int) bytes;\n+  }\n+\n+  @Override\n+  public boolean equals(Object thatObj)\n+  {\n+    if (thatObj == null) {\n+      return false;\n+    }\n+    if (thatObj instanceof HumanReadableBytes) {\n+      return bytes == ((HumanReadableBytes) thatObj).bytes;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Long.hashCode(bytes);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return String.valueOf(bytes);\n+  }\n+\n+  public static HumanReadableBytes valueOf(int bytes)\n+  {\n+    return new HumanReadableBytes(bytes);\n+  }\n+\n+  public static HumanReadableBytes valueOf(long bytes)\n+  {\n+    return new HumanReadableBytes(bytes);\n+  }\n+\n+  public static long parse(String number)\n+  {\n+    if (number == null) {\n+      throw new IAE(\"Invalid format of number: number is null\");\n+    }\n+\n+    number = number.trim();\n+    if (number.length() == 0) {\n+      throw new IAE(\"Invalid format of number: Number is empty\");", "originalCommit": "8d971695482878cd7262c5c5921340cd55380ff0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "75da8c606a2ef74b5e143b3043bb25e3866f9e5c", "url": "https://github.com/apache/druid/commit/75da8c606a2ef74b5e143b3043bb25e3866f9e5c", "message": "improve code & doc according to comments", "committedDate": "2020-07-29T13:46:41Z", "type": "commit"}, {"oid": "0123e93f7a0d2a1f3de08daafbb8459ec212d618", "url": "https://github.com/apache/druid/commit/0123e93f7a0d2a1f3de08daafbb8459ec212d618", "message": "fix CI problem", "committedDate": "2020-07-29T15:55:40Z", "type": "commit"}, {"oid": "a78b55cb8fcfc65554f17eabffd8bae821d07026", "url": "https://github.com/apache/druid/commit/a78b55cb8fcfc65554f17eabffd8bae821d07026", "message": "improve doc", "committedDate": "2020-07-30T05:29:10Z", "type": "commit"}, {"oid": "36638034e16a2c40235062385fb6b09e842d3f71", "url": "https://github.com/apache/druid/commit/36638034e16a2c40235062385fb6b09e842d3f71", "message": "suppress spelling check errors", "committedDate": "2020-07-30T09:43:14Z", "type": "commit"}]}