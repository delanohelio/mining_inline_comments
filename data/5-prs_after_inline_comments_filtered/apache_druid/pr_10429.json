{"pr_number": 10429, "pr_title": "vectorize remaining math expressions", "pr_createdAt": "2020-09-23T22:13:39Z", "pr_url": "https://github.com/apache/druid/pull/10429", "timeline": [{"oid": "53e23d64996d46241e00f712cd33f7f6c275b64d", "url": "https://github.com/apache/druid/commit/53e23d64996d46241e00f712cd33f7f6c275b64d", "message": "vectorize remaining math expressions", "committedDate": "2020-09-23T22:06:03Z", "type": "commit"}, {"oid": "b27fca67d6bc793aaec438138b4d7e6eb2382e83", "url": "https://github.com/apache/druid/commit/b27fca67d6bc793aaec438138b4d7e6eb2382e83", "message": "fixes", "committedDate": "2020-09-24T11:59:01Z", "type": "commit"}, {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c", "url": "https://github.com/apache/druid/commit/f132d71b1e26ce3a2089b27b2f2f8dcaee68166c", "message": "remove cannotVectorize() where no longer true", "committedDate": "2020-09-24T18:45:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMDA4Nw==", "url": "https://github.com/apache/druid/pull/10429#discussion_r494620087", "bodyText": "The return value is not nullable.", "author": "jihoonson", "createdAt": "2020-09-24T21:26:32Z", "path": "core/src/main/java/org/apache/druid/math/expr/ExprType.java", "diffHunk": "@@ -216,11 +226,44 @@ public static ExprType functionAutoTypeConversion(@Nullable ExprType type, @Null\n       return STRING;\n     }\n \n-    return numericAutoTypeConversion(type, other);\n+    return doubleNumericAutoTypeConversion(type, other);\n   }\n \n+  /**\n+   * Given 2 'input' types, choose the most appropriate combined type, if possible\n+   *\n+   * arrays must be the same type\n+   * if either type is {@link #STRING}, the output type will be preserved as string\n+   * any number will be coerced to {@link #LONG}\n+   */\n+  @Nullable\n+  public static ExprType integerMathFunctionAutoTypeConversion(@Nullable ExprType type, @Nullable ExprType other)\n+  {\n+    if (type == null || other == null) {\n+      // cannot auto conversion unknown types\n+      return null;\n+    }\n+    // arrays cannot be auto converted\n+    if (isArray(type) || isArray(other)) {\n+      if (!type.equals(other)) {\n+        throw new IAE(\"Cannot implicitly cast %s to %s\", type, other);\n+      }\n+      return type;\n+    }\n+    // if either argument is a string, type becomes a string\n+    if (STRING.equals(type) || STRING.equals(other)) {\n+      return STRING;\n+    }\n+\n+    // any number is long\n+    return LONG;\n+  }\n+\n+  /**\n+   * If both types are {@link #LONG}, returns {@link #LONG}, else {@link #DOUBLE}\n+   */\n   @Nullable", "originalCommit": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5NjYzNg==", "url": "https://github.com/apache/druid/pull/10429#discussion_r494696636", "bodyText": "oops, will fix (this whole area in general needs some improvement, but I think maybe will save for a future PR)", "author": "clintropolis", "createdAt": "2020-09-25T01:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMDA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MDcwOQ==", "url": "https://github.com/apache/druid/pull/10429#discussion_r494660709", "bodyText": "Hmm, do we need a sanity check after a casting if the right value is still valid?", "author": "jihoonson", "createdAt": "2020-09-24T23:15:49Z", "path": "core/src/main/java/org/apache/druid/math/expr/vector/VectorMathProcessors.java", "diffHunk": "@@ -632,170 +793,812 @@ public double apply(double left, double right)\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> atan(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> atan2(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cos(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> cosh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> copySign(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cot(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> sin(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> hypot(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> sinh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n-            inputTypes.getMaxVectorSize()\n-        )\n-        {\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> remainder(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> nextAfter(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.nextAfter((double) left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.nextAfter((double) left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.nextAfter(left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.nextAfter(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> scalb(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.scalb((double) left, (int) right);", "originalCommit": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MTMzNg==", "url": "https://github.com/apache/druid/pull/10429#discussion_r494661336", "bodyText": "Same comment for other places where it does narrowing casting.", "author": "jihoonson", "createdAt": "2020-09-24T23:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MDcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5NjUyMQ==", "url": "https://github.com/apache/druid/pull/10429#discussion_r494696521", "bodyText": "Ah, we probably should? Although the non-vectorized expressions are just using Number.intValue() and the like, which just do a straight cast afaict.", "author": "clintropolis", "createdAt": "2020-09-25T01:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MDcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc4NzkzMA==", "url": "https://github.com/apache/druid/pull/10429#discussion_r494787930", "bodyText": "Heh, we should clean up this later.", "author": "jihoonson", "createdAt": "2020-09-25T07:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MDcwOQ=="}], "type": "inlineReview"}, {"oid": "3d6a279977c90a4057e3b48340812f16bef3dc97", "url": "https://github.com/apache/druid/commit/3d6a279977c90a4057e3b48340812f16bef3dc97", "message": "disable vectorized groupby for numeric columns with nulls", "committedDate": "2020-09-25T01:48:00Z", "type": "commit"}, {"oid": "2fc940bd69f8cd97c81297aabdc999a314f936ec", "url": "https://github.com/apache/druid/commit/2fc940bd69f8cd97c81297aabdc999a314f936ec", "message": "fixes", "committedDate": "2020-09-25T05:07:50Z", "type": "commit"}]}