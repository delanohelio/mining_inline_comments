{"pr_number": 9187, "pr_title": "Implement ANY aggregator", "pr_createdAt": "2020-01-15T00:38:15Z", "pr_url": "https://github.com/apache/druid/pull/9187", "timeline": [{"oid": "5da72a07a34384236f6d7220e53f44d182de327d", "url": "https://github.com/apache/druid/commit/5da72a07a34384236f6d7220e53f44d182de327d", "message": "Implement ANY aggregator", "committedDate": "2020-01-15T00:37:54Z", "type": "commit"}, {"oid": "57dd3cb426c713ba91aee41a974ad08a784bf92c", "url": "https://github.com/apache/druid/commit/57dd3cb426c713ba91aee41a974ad08a784bf92c", "message": "Add copyright headers", "committedDate": "2020-01-15T01:28:21Z", "type": "commit"}, {"oid": "b6d1dbb790311a995457f48f8f1e50b9f00226a2", "url": "https://github.com/apache/druid/commit/b6d1dbb790311a995457f48f8f1e50b9f00226a2", "message": "Add unit tests", "committedDate": "2020-01-15T03:27:40Z", "type": "commit"}, {"oid": "ebd8fc0b75cd3269ab54863bd71b9224263d580d", "url": "https://github.com/apache/druid/commit/ebd8fc0b75cd3269ab54863bd71b9224263d580d", "message": "fix BufferAggregator", "committedDate": "2020-01-15T05:39:21Z", "type": "commit"}, {"oid": "e3579d34d2ff0bb2bdc3f85950067d6564147339", "url": "https://github.com/apache/druid/commit/e3579d34d2ff0bb2bdc3f85950067d6564147339", "message": "Fix bug in BufferAggregator", "committedDate": "2020-01-15T06:45:46Z", "type": "commit"}, {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "url": "https://github.com/apache/druid/commit/d27db11b6db196d2f09295a6419fb593a8ddbffa", "message": "hook up the SQL command", "committedDate": "2020-01-15T17:20:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwOTY4NQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r366709685", "bodyText": "I think you need a different byte for each type id here.\nAlso nitpicking here - can you add a comment above the group saying this is for the any aggregators", "author": "suneet-s", "createdAt": "2020-01-15T06:14:09Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/AggregatorUtil.java", "diffHunk": "@@ -121,6 +121,11 @@\n \n   public static final byte MEAN_CACHE_TYPE_ID = 0x41;\n \n+  public static final byte LONG_ANY_CACHE_TYPE_ID = 0x42;\n+  public static final byte DOUBLE_ANY_CACHE_TYPE_ID = 0x42;", "originalCommit": "ebd8fc0b75cd3269ab54863bd71b9224263d580d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMDg2MQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367110861", "bodyText": "yes these need to be different values", "author": "clintropolis", "createdAt": "2020-01-15T21:16:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwOTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NDY1Mg==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367154652", "bodyText": "Copy+Paste and forgot to change the value. Done.", "author": "maytasm", "createdAt": "2020-01-15T23:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwOTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMDIxMA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367020210", "bodyText": "nit: javadocs please - I know most of the aggregators don't have docs, but I think explaining how nulls should be handled in this class is valuable", "author": "suneet-s", "createdAt": "2020-01-15T17:53:42Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NDkwMw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367154903", "bodyText": "Done.", "author": "maytasm", "createdAt": "2020-01-15T23:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMDIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367024014", "bodyText": "I think you should store this as a primitive so we don't have to do un-necessary boxing. Also I think we need another variable in here to track whether the value is null or not. We would need to implement isNull for the aggregator.", "author": "suneet-s", "createdAt": "2020-01-15T18:01:49Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA2MDE1Mw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367060153", "bodyText": "As mentioned before we don't have to worry about null. This is just considering which is more optimize between checking if Double is null or checking if boolean is T/F (and I guess memory for storing one Double vs. storing one double and one Boolean)", "author": "maytasm", "createdAt": "2020-01-15T19:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExOTk3Nw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367119977", "bodyText": "Since this is created by NullableNumericAggregatorFactory it can be a primitive. NullableNumericAggregator and NullableNumericBufferAggregator will initialize to a null value, so aggregate will never be called unless you encounter a not null value.", "author": "clintropolis", "createdAt": "2020-01-15T21:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyNjA5MA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367126090", "bodyText": "I would also go with primitive double and a boolean found, we can avoid the boxing and I don't think using one Double object would save memory compared to double+boolean", "author": "jon-wei", "createdAt": "2020-01-15T21:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NzQ4MA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367157480", "bodyText": "Done.", "author": "maytasm", "createdAt": "2020-01-15T23:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjE2Nw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367026167", "bodyText": "This can throw an NPE if isNull is true. I can't tell if this is called from a hot loop or not. @clintropolis or @jon-wei might know how we should deal with this. I see this potential NPE in other aggregators as well.\nIf you switch to using a primitive in the class, then all these getters can simply cast the local variable", "author": "suneet-s", "createdAt": "2020-01-15T18:06:41Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {\n+      foundValue = valueSelector.getDouble();\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public float getFloat()\n+  {\n+    return foundValue.floatValue();", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA1OTIzMw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367059233", "bodyText": "(Double/Float/Long)AnyAggregators are created by the (Double/Float/Long)AnyAggregatorFactory. The (Double/Float/Long)AnyAggregatorFactory extends from NullableNumericAggregatorFactory. NullableNumericAggregatorFactory will handle the Null for the (Double/Float/Long)AnyAggregators. If useDefaultValueForNull=true then we don't have to worry about null since all null will be convert to non-null (i.e. 0) before aggregation. If useDefaultValueForNull=false then the NullableNumericAggregatorFactory will wrap the AnyAggregators in NullableNumericAggregator which already have isNull check. (Those methods like getFloat also won't be call if isNull is true)", "author": "maytasm", "createdAt": "2020-01-15T19:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjU5Mg==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367026592", "bodyText": "nit: Add a comment explaining why this function is empty to indicate it is intentional", "author": "suneet-s", "createdAt": "2020-01-15T18:07:43Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {\n+      foundValue = valueSelector.getDouble();\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public float getFloat()\n+  {\n+    return foundValue.floatValue();\n+  }\n+\n+  @Override\n+  public long getLong()\n+  {\n+    return foundValue.longValue();\n+  }\n+\n+  @Override\n+  public double getDouble()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public void close()\n+  {\n+", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1Nzg4Ng==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367157886", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-01-15T23:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDk2NQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367030965", "bodyText": "Shouldn't we be looking at storeDoubleAsFloat  as well for equalsAndHashCode?\nCan we add an EqualsVerifierTest for this?", "author": "suneet-s", "createdAt": "2020-01-15T18:17:21Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    DoubleAnyAggregatorFactory that = (DoubleAnyAggregatorFactory) o;\n+\n+    return name.equals(that.name) && fieldName.equals(that.fieldName);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(name, fieldName);\n+  }", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1ODMyNg==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367158326", "bodyText": "No idea. DoubleFirstAggregatorFactory does not look at storeDoubleAsFloat for hashCode.", "author": "maytasm", "createdAt": "2020-01-15T23:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDk2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NTA1Nw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367165057", "bodyText": "Actually gonna remove storeDoubleAsFloat", "author": "maytasm", "createdAt": "2020-01-15T23:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMTI1Nw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367031257", "bodyText": "Similar comment to above...\nUgh I can't wait till we can hide all of this away with lombok", "author": "suneet-s", "createdAt": "2020-01-15T18:17:57Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    DoubleAnyAggregatorFactory that = (DoubleAnyAggregatorFactory) o;\n+\n+    return name.equals(that.name) && fieldName.equals(that.fieldName);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(name, fieldName);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return \"DoubleAnyAggregatorFactory{\" +\n+           \"name='\" + name + '\\'' +\n+           \", fieldName='\" + fieldName + '\\'' +\n+           '}';\n+  }", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1ODk5Nw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367158997", "bodyText": "No idea. DoubleFirstAggregatorFactory does not look at storeDoubleAsFloat for hashCode.", "author": "maytasm", "createdAt": "2020-01-15T23:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NTEyOA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367165128", "bodyText": "Actually gonna remove storeDoubleAsFloat", "author": "maytasm", "createdAt": "2020-01-15T23:43:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMTI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMjY4Ng==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367032686", "bodyText": "not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true?\nI see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?", "author": "suneet-s", "createdAt": "2020-01-15T18:21:01Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NTE2MA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367165160", "bodyText": "Actually gonna remove storeDoubleAsFloat", "author": "maytasm", "createdAt": "2020-01-15T23:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMjY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMzMyNg==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367033326", "bodyText": "nit: Collections.singletonList(fieldName)", "author": "suneet-s", "createdAt": "2020-01-15T18:22:11Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1OTU3Nw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367159577", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-01-15T23:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMzMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNjg1Nw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367036857", "bodyText": "I don't understand why both the parameters here are fieldName and both the parameters in getCombiningFactory are name - I see this pattern used in all the aggregators", "author": "suneet-s", "createdAt": "2020-01-15T18:29:31Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MDUzOQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367160539", "bodyText": "There's javadoc on AggregatorFactory class. But i think it's like reusing input output fields", "author": "maytasm", "createdAt": "2020-01-15T23:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNjg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MDYwNA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367160604", "bodyText": "getCombiningFactory are combining between segments", "author": "maytasm", "createdAt": "2020-01-15T23:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNjg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MDIwNQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367040205", "bodyText": "Is this so that missing values show up first? Is that the behavior we want? I don't know the answer...", "author": "suneet-s", "createdAt": "2020-01-15T18:36:34Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MTA0NQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367161045", "bodyText": "Not sure I understand the question. This is for sorting the aggregated result. I think it does not really matters", "author": "maytasm", "createdAt": "2020-01-15T23:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MDIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MjQ0MQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367042441", "bodyText": "I know this is an existing pattern, but I prefer having a package private all args constructor to make unit testing easier and have the JsonCreator constructor call the all args constructor. Otherwise the tests need to rely on the static implementation of ColumnHolder#storeDoubleAsFloat which can be a huge pain to try and mock correctly.", "author": "suneet-s", "createdAt": "2020-01-15T18:41:43Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjA2NA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367162064", "bodyText": "Not sure if the storeDoubleAsFloat is even needed.", "author": "maytasm", "createdAt": "2020-01-15T23:32:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MjQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NjA3NA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367166074", "bodyText": "Actually gonna remove storeDoubleAsFloat", "author": "maytasm", "createdAt": "2020-01-15T23:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MjQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0Mjc1Ng==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367042756", "bodyText": "nit: Comment for empty function please", "author": "suneet-s", "createdAt": "2020-01-15T18:42:25Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.putDouble(position, NULL_VALUE);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    if (buf.getDouble(position) == NULL_VALUE && !valueSelector.isNull()) {\n+      buf.putDouble(position, valueSelector.getDouble());\n+    }\n+  }\n+\n+  @Override\n+  public Object get(ByteBuffer buf, int position)\n+  {\n+    return buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public float getFloat(ByteBuffer buf, int position)\n+  {\n+    return (float) buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public long getLong(ByteBuffer buf, int position)\n+  {\n+    return (long) buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public double getDouble(ByteBuffer buf, int position)\n+  {\n+    return buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public void close()\n+  {\n+", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MzUxMg==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367163512", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-01-15T23:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0Mjc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0Mzk3OQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367043979", "bodyText": "0 is a valid value for a double. I think Double.NaN is safer to indicate that the value is not found.\nSimilar comments to DoubleAnyAggregator - I think you need to store a byte to indicate whether or not the value has been found since 0, NaN, etc. are all valid values that can show up in a double column.", "author": "suneet-s", "createdAt": "2020-01-15T18:45:21Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final double NULL_VALUE = 0;", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NzQwOQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367167409", "bodyText": "Added byte to indicate whether or not the value has been found. We actually do not get null due to the NullableNumericAggregatorFactory/ NullableNumericAggregator stuff", "author": "maytasm", "createdAt": "2020-01-15T23:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0Mzk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0NzIxNg==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367047216", "bodyText": "Why was this change needed?", "author": "suneet-s", "createdAt": "2020-01-15T18:52:27Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/first/StringAggregatorUtils.java", "diffHunk": "@@ -87,7 +87,7 @@ public static void writePair(\n \n     if (pair.rhs != null) {\n       mutationBuffer.position(position + Long.BYTES + Integer.BYTES);\n-      mutationBuffer.limit(maxStringBytes);\n+      mutationBuffer.limit(position + Long.BYTES + Integer.BYTES + maxStringBytes);", "originalCommit": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4NTExMA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367085110", "bodyText": "This is to fix an existing bug i found. The limit method for buffer sets it at absolute position. The correct limit should be maxStringBytes after where we are writing the String to the buffer (which is position + Long.BYTES + Integer.BYTES). Hence, limit should be position + Long.BYTES + Integer.BYTES + maxStringBytes", "author": "maytasm", "createdAt": "2020-01-15T20:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0NzIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2NzU5OA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367167598", "bodyText": "Removed this. Will fix as part of separate PR", "author": "maytasm", "createdAt": "2020-01-15T23:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0NzIxNg=="}], "type": "inlineReview"}, {"oid": "a9b71131991216c9265af15e72407159825762b8", "url": "https://github.com/apache/druid/commit/a9b71131991216c9265af15e72407159825762b8", "message": "add check for buffer aggregator", "committedDate": "2020-01-15T21:15:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExNjA0OQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367116049", "bodyText": "valueSelector.isNull() will never be true since this the factory is NullableNumericAggregatorFactory", "author": "clintropolis", "createdAt": "2020-01-15T21:27:44Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {", "originalCommit": "a9b71131991216c9265af15e72407159825762b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2ODE4Mg==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367168182", "bodyText": "Removed.", "author": "maytasm", "createdAt": "2020-01-15T23:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExNjA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMDQ0OQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367120449", "bodyText": "I think this could be SimpleDoubleAggregatorFactory", "author": "clintropolis", "createdAt": "2020-01-15T21:38:09Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>", "originalCommit": "a9b71131991216c9265af15e72407159825762b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE4ODU3OA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367188578", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-01-16T01:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMDQ0OQ=="}], "type": "inlineReview"}, {"oid": "2fa5a515e3d0e2f7a428e76af3f5a0481ea74333", "url": "https://github.com/apache/druid/commit/2fa5a515e3d0e2f7a428e76af3f5a0481ea74333", "message": "Address comment", "committedDate": "2020-01-15T23:55:10Z", "type": "commit"}, {"oid": "e20a74392835b7a80078d3d22f3d86731f0a1958", "url": "https://github.com/apache/druid/commit/e20a74392835b7a80078d3d22f3d86731f0a1958", "message": "address comments", "committedDate": "2020-01-16T01:17:29Z", "type": "commit"}, {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372", "url": "https://github.com/apache/druid/commit/3436332501a9374b3bc657b19a7d754a06a4d372", "message": "add docs", "committedDate": "2020-01-16T01:30:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDU1MA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367204550", "bodyText": "This method and similar could use CacheKeyBuilder instead", "author": "jon-wei", "createdAt": "2020-01-16T02:31:44Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.DoubleMaxAggregator;\n+import org.apache.druid.query.aggregation.DoubleMaxBufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+{\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName,\n+      @JsonProperty(\"expression\") @Nullable String expression,\n+      @JacksonInject ExprMacroTable macroTable\n+  )\n+  {\n+    super(macroTable, name, fieldName, expression);\n+  }\n+\n+  public DoubleAnyAggregatorFactory(String name, String fieldName)\n+  {\n+    this(name, fieldName, null, ExprMacroTable.nil());\n+  }\n+\n+  @Override\n+  protected double nullValue()\n+  {\n+    return Double.NaN;\n+  }\n+\n+  @Override\n+  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name, null, macroTable);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName, expression, macroTable));\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8WithNullToEmpty(fieldName);", "originalCommit": "3436332501a9374b3bc657b19a7d754a06a4d372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1MzE0OA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367253148", "bodyText": "Done!", "author": "maytasm", "createdAt": "2020-01-16T06:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDczOA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367204738", "bodyText": "nit: suggest setting the IS_SET byte first before the double value, since that's the order they appear in the buffer", "author": "jon-wei", "createdAt": "2020-01-16T02:32:45Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n+ * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n+ * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n+ * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ */\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, BYTE_FLAG_IS_NOT_SET);\n+    buf.putDouble(position + Byte.BYTES, NULL_VALUE);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    if (buf.get(position) == BYTE_FLAG_IS_NOT_SET) {\n+      buf.putDouble(position + Byte.BYTES, valueSelector.getDouble());\n+      buf.put(position, BYTE_FLAG_IS_SET);", "originalCommit": "3436332501a9374b3bc657b19a7d754a06a4d372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMTAzMA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367231030", "bodyText": "I agree on put ordering", "author": "clintropolis", "createdAt": "2020-01-16T04:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1NTQzMQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367255431", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-01-16T06:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMDQ4Mw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367230483", "bodyText": "instead of NULL_VALUE maybe use NullHandling.ZERO_DOUBLE or like just 0 since this is the only place this is used", "author": "clintropolis", "createdAt": "2020-01-16T04:55:29Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n+ * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n+ * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n+ * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ */\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, BYTE_FLAG_IS_NOT_SET);\n+    buf.putDouble(position + Byte.BYTES, NULL_VALUE);", "originalCommit": "3436332501a9374b3bc657b19a7d754a06a4d372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2MDg1Nw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367260857", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-01-16T07:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMDQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMjI0Nw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367232247", "bodyText": "nit: It is probably worth pushing chop down into StringUtils rather than renaming and widening the usage of StringAggregatorUtils", "author": "clintropolis", "createdAt": "2020-01-16T05:05:27Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.first.StringAggregatorUtils;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+public class StringAnyAggregator implements Aggregator\n+{\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  private String foundValue;\n+\n+  public StringAnyAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+    this.foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {\n+        foundValue = DimensionHandlerUtils.convertObjectToString(object);\n+        if (foundValue != null && foundValue.length() > maxStringBytes) {\n+          foundValue = foundValue.substring(0, maxStringBytes);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return StringAggregatorUtils.chop(foundValue, maxStringBytes);", "originalCommit": "3436332501a9374b3bc657b19a7d754a06a4d372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2MzA4MA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367263080", "bodyText": "sounds good to me. Done", "author": "maytasm", "createdAt": "2020-01-16T07:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMjI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMjU1NA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367232554", "bodyText": "If you decide to end up moving chop to StringUtils, please revert this rename", "author": "clintropolis", "createdAt": "2020-01-16T05:06:47Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/first/StringAggregatorUtils.java", "diffHunk": "@@ -29,7 +29,7 @@\n import java.nio.ByteBuffer;\n import java.nio.charset.StandardCharsets;\n \n-public class StringFirstLastUtils\n+public class StringAggregatorUtils", "originalCommit": "3436332501a9374b3bc657b19a7d754a06a4d372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2MzEwOQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367263109", "bodyText": "done", "author": "maytasm", "createdAt": "2020-01-16T07:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMjU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMzI1MA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367233250", "bodyText": "nit: It would probably be worth adding an additional test that tests numeric columns agains druid.numfoo table since it contains numeric columns that have null values when run in sql compatible null mode, and also tests for ordering by each 'any' aggregator.", "author": "clintropolis", "createdAt": "2020-01-16T05:10:26Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -1297,6 +1301,46 @@ public void testLatestAggregators() throws Exception\n     );\n   }\n \n+  // This test the on-heap version of the AnyAggregator (Double/Float/Long/String)\n+  @Test\n+  public void testAnyAggregator() throws Exception", "originalCommit": "3436332501a9374b3bc657b19a7d754a06a4d372", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2MzM5Nw==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367263397", "bodyText": "done", "author": "maytasm", "createdAt": "2020-01-16T07:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMzI1MA=="}], "type": "inlineReview"}, {"oid": "a370ffc182da3019c5e070e13b9da4e66738c4f6", "url": "https://github.com/apache/druid/commit/a370ffc182da3019c5e070e13b9da4e66738c4f6", "message": "Address comments", "committedDate": "2020-01-16T07:21:25Z", "type": "commit"}, {"oid": "bcae86e41dbf0d5650fb24b09cc77b57ed77795d", "url": "https://github.com/apache/druid/commit/bcae86e41dbf0d5650fb24b09cc77b57ed77795d", "message": "add more tests for numeric columns that have null values when run in sql compatible null mode", "committedDate": "2020-01-16T08:00:35Z", "type": "commit"}, {"oid": "d6f954355ed3455f529507da578e903930bec1b9", "url": "https://github.com/apache/druid/commit/d6f954355ed3455f529507da578e903930bec1b9", "message": "fix checkstyle errors", "committedDate": "2020-01-16T08:12:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMTUwMg==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367301502", "bodyText": "sorry I missed this earlier, this check isn't necessary, DimensionHandlerUtils.convertObjectToString has it's own null check", "author": "clintropolis", "createdAt": "2020-01-16T09:05:43Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+public class StringAnyAggregator implements Aggregator\n+{\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  private String foundValue;\n+\n+  public StringAnyAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+    this.foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {", "originalCommit": "d6f954355ed3455f529507da578e903930bec1b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4NjQ5OQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367586499", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-01-16T18:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMTUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMjAwNg==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367302006", "bodyText": "same comment about unnecessary check", "author": "clintropolis", "createdAt": "2020-01-16T09:06:53Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+import java.nio.ByteBuffer;\n+\n+public class StringAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final int NULL_STRING_LENGTH = -1;\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  public StringAnyBufferAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.putInt(position, NULL_STRING_LENGTH);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    int stringSizeBytes = buf.getInt(position);\n+    if (stringSizeBytes < 0) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {", "originalCommit": "d6f954355ed3455f529507da578e903930bec1b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4NjUxMQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367586511", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-01-16T18:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMjAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMzk1MA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367303950", "bodyText": "Hmm, it seems like this change is causing some unrelated test failures", "author": "clintropolis", "createdAt": "2020-01-16T09:10:54Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/CalciteTests.java", "diffHunk": "@@ -377,6 +377,15 @@ public AuthenticationResult createEscalatedAuthenticationResult()\n   );\n \n   public static final List<InputRow> ROWS1_WITH_NUMERIC_DIMS = ImmutableList.of(\n+      createRow(", "originalCommit": "d6f954355ed3455f529507da578e903930bec1b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYwMzYwNA==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367603604", "bodyText": "Seems like the VarianceSqlAggregatorTest is using this data too and when the ordering of the rows changed, the variance also changed. I created a new datasource that have the numeric dim first for my test and changed the numfoo datasource back to how it was. The reason I wanted to have numeric null first is because the ANY will select the first row and skip everything after. So if the first row is not null, then there is not really any point in testing (if we want to test the numeric null stuff)", "author": "maytasm", "createdAt": "2020-01-16T19:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMzk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYyODI4NQ==", "url": "https://github.com/apache/druid/pull/9187#discussion_r367628285", "bodyText": "Actually, I think it's fine to just test with the same numfoo datasource (with first row being non-null)", "author": "maytasm", "createdAt": "2020-01-16T20:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMzk1MA=="}], "type": "inlineReview"}, {"oid": "9532752229330d5e4b0504f90479b473685faf58", "url": "https://github.com/apache/druid/commit/9532752229330d5e4b0504f90479b473685faf58", "message": "fix failing tests", "committedDate": "2020-01-16T19:21:40Z", "type": "commit"}, {"oid": "a3925dcfcc638100dfdd1df17d2a8653219cdf9c", "url": "https://github.com/apache/druid/commit/a3925dcfcc638100dfdd1df17d2a8653219cdf9c", "message": "fix failing tests", "committedDate": "2020-01-16T20:15:28Z", "type": "commit"}]}