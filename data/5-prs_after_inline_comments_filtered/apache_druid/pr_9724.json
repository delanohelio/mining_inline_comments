{"pr_number": 9724, "pr_title": "Add integration tests for kafka ingestion", "pr_createdAt": "2020-04-19T04:15:20Z", "pr_url": "https://github.com/apache/druid/pull/9724", "timeline": [{"oid": "fe95b67954aa9233a0108e48dc33d475a41f34dd", "url": "https://github.com/apache/druid/commit/fe95b67954aa9233a0108e48dc33d475a41f34dd", "message": "add kafka admin and kafka writer", "committedDate": "2020-04-17T06:51:42Z", "type": "commit"}, {"oid": "eee34658803c721228147af4138c068c5a4f139e", "url": "https://github.com/apache/druid/commit/eee34658803c721228147af4138c068c5a4f139e", "message": "refactor kinesis IT", "committedDate": "2020-04-17T08:52:44Z", "type": "commit"}, {"oid": "3cd2135246cc3946d3f363d4e34efe355b7a1711", "url": "https://github.com/apache/druid/commit/3cd2135246cc3946d3f363d4e34efe355b7a1711", "message": "fix typo refactor", "committedDate": "2020-04-17T09:20:16Z", "type": "commit"}, {"oid": "8714cff257fb57f976bca760a5c1eea18ab459a5", "url": "https://github.com/apache/druid/commit/8714cff257fb57f976bca760a5c1eea18ab459a5", "message": "parallel", "committedDate": "2020-04-18T07:56:20Z", "type": "commit"}, {"oid": "2c97efd81d55b181e69d64f7868fcea5bb046b5e", "url": "https://github.com/apache/druid/commit/2c97efd81d55b181e69d64f7868fcea5bb046b5e", "message": "parallel", "committedDate": "2020-04-18T11:21:28Z", "type": "commit"}, {"oid": "8a737c519f7763bb054ab8d3b9b4d6396c2e9eb4", "url": "https://github.com/apache/druid/commit/8a737c519f7763bb054ab8d3b9b4d6396c2e9eb4", "message": "parallel", "committedDate": "2020-04-18T12:18:28Z", "type": "commit"}, {"oid": "e12449d9ca951db4b51b0082bd6032abe394ac3f", "url": "https://github.com/apache/druid/commit/e12449d9ca951db4b51b0082bd6032abe394ac3f", "message": "parallel works now", "committedDate": "2020-04-18T22:36:07Z", "type": "commit"}, {"oid": "fae658f2b1eddfd92e3d802118942bcfafae653a", "url": "https://github.com/apache/druid/commit/fae658f2b1eddfd92e3d802118942bcfafae653a", "message": "add kafka it", "committedDate": "2020-04-19T03:47:40Z", "type": "commit"}, {"oid": "33837300dee1eb0fb23c70f03303434bdf927765", "url": "https://github.com/apache/druid/commit/33837300dee1eb0fb23c70f03303434bdf927765", "message": "add doc to readme", "committedDate": "2020-04-19T04:37:04Z", "type": "commit"}, {"oid": "29c39cf9f8d97fedd6280a4b3a3f6839aedf5439", "url": "https://github.com/apache/druid/commit/29c39cf9f8d97fedd6280a4b3a3f6839aedf5439", "message": "fix tests", "committedDate": "2020-04-20T00:25:35Z", "type": "commit"}, {"oid": "3f7e05e4ee781a32848df2e568d03c96047926ac", "url": "https://github.com/apache/druid/commit/3f7e05e4ee781a32848df2e568d03c96047926ac", "message": "fix failing test", "committedDate": "2020-04-20T04:10:22Z", "type": "commit"}, {"oid": "d0a8c1a30b8d88eb0176d00f84534a741018969f", "url": "https://github.com/apache/druid/commit/d0a8c1a30b8d88eb0176d00f84534a741018969f", "message": "test", "committedDate": "2020-04-20T05:40:28Z", "type": "commit"}, {"oid": "9febc083410b4967dc1e0b919a6690846281ed81", "url": "https://github.com/apache/druid/commit/9febc083410b4967dc1e0b919a6690846281ed81", "message": "test", "committedDate": "2020-04-20T09:27:53Z", "type": "commit"}, {"oid": "6db038ec35c92af13fe5ebb947091973bb50eb47", "url": "https://github.com/apache/druid/commit/6db038ec35c92af13fe5ebb947091973bb50eb47", "message": "test", "committedDate": "2020-04-20T10:18:43Z", "type": "commit"}, {"oid": "fcbfcc2403ab2c8bd90fbfef9a42bc5f4812e473", "url": "https://github.com/apache/druid/commit/fcbfcc2403ab2c8bd90fbfef9a42bc5f4812e473", "message": "test", "committedDate": "2020-04-20T17:39:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NTgwMA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r411855800", "bodyText": "Suggest adding a brief comment here noting that Kinesis doesn't immediately drop the old shards after the resharding which is why the counts are summed", "author": "jon-wei", "createdAt": "2020-04-21T04:16:14Z", "path": "integration-tests/src/main/java/org/apache/druid/testing/utils/KinesisAdminClient.java", "diffHunk": "@@ -129,18 +132,28 @@ public void updateShardCount(String streamName, int newShardCount, boolean block\n     }\n   }\n \n+  @Override\n   public boolean isStreamActive(String streamName)\n   {\n     StreamDescription streamDescription = getStreamDescription(streamName);\n     return verifyStreamStatus(streamDescription, StreamStatus.ACTIVE);\n   }\n \n+  @Override\n   public int getStreamShardCount(String streamName)\n   {\n     StreamDescription streamDescription = getStreamDescription(streamName);\n     return getStreamShardCount(streamDescription);\n   }\n \n+  @Override\n+  public boolean verfiyShardCountUpdated(String streamName, int oldShardCount, int newShardCount)\n+  {\n+    int actualShardCount = getStreamShardCount(streamName);\n+    return actualShardCount == oldShardCount + newShardCount;", "originalCommit": "fcbfcc2403ab2c8bd90fbfef9a42bc5f4812e473", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMDY5MQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r411910691", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-04-21T06:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NTgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NzU5NQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r411857595", "bodyText": "Hmm, it's a bit strange that the stream indexing test extends something called \"batch index test\", maybe the base \"batch index\" class is generic enough that it should be renamed to something else, or some other refactoring", "author": "jon-wei", "createdAt": "2020-04-21T04:22:22Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/indexer/AbstractStreamIndexingTest.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.tests.indexer;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.inject.Inject;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorStateManager;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.testing.utils.DruidClusterAdminClient;\n+import org.apache.druid.testing.utils.ITRetryUtil;\n+import org.apache.druid.testing.utils.StreamAdminClient;\n+import org.apache.druid.testing.utils.StreamEventWriter;\n+import org.apache.druid.testing.utils.WikipediaStreamEventStreamGenerator;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+public abstract class AbstractStreamIndexingTest extends AbstractITBatchIndexTest", "originalCommit": "fcbfcc2403ab2c8bd90fbfef9a42bc5f4812e473", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkxMTg2NQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r411911865", "bodyText": "My bad. Can extend from AbstractIndexerTest instead.", "author": "maytasm", "createdAt": "2020-04-21T06:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NzU5NQ=="}], "type": "inlineReview"}, {"oid": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "url": "https://github.com/apache/druid/commit/f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "message": "address comments", "committedDate": "2020-04-21T06:44:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY1NDg1Nw==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412654857", "bodyText": "Can you add javadoc for this class?", "author": "jihoonson", "createdAt": "2020-04-22T04:10:38Z", "path": "integration-tests/src/main/java/org/apache/druid/testing/utils/StreamEventWriter.java", "diffHunk": "@@ -25,5 +25,11 @@\n \n   void shutdown();\n \n-  void flush();\n+  void flush() throws Exception;", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMjg4NA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412702884", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-04-22T06:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY1NDg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY1NTYxNw==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412655617", "bodyText": "This method is not being called, but seems like it should be called in AbstractStreamIndexingTest.doMethodTeardown().", "author": "jihoonson", "createdAt": "2020-04-22T04:12:52Z", "path": "integration-tests/src/main/java/org/apache/druid/testing/utils/StreamEventWriter.java", "diffHunk": "@@ -25,5 +25,11 @@\n \n   void shutdown();", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMzI2Ng==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412703266", "bodyText": "Yep. Done.", "author": "maytasm", "createdAt": "2020-04-22T06:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY1NTYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY1NjM4NA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412656384", "bodyText": "nit: probably better to name createStreamAdminClient() since it creates an instance rather than returning an existing one.", "author": "jihoonson", "createdAt": "2020-04-22T04:15:20Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/indexer/AbstractStreamIndexingTest.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.tests.indexer;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.inject.Inject;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorStateManager;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.testing.utils.DruidClusterAdminClient;\n+import org.apache.druid.testing.utils.ITRetryUtil;\n+import org.apache.druid.testing.utils.StreamAdminClient;\n+import org.apache.druid.testing.utils.StreamEventWriter;\n+import org.apache.druid.testing.utils.WikipediaStreamEventStreamGenerator;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+public abstract class AbstractStreamIndexingTest extends AbstractIndexerTest\n+{\n+  static final DateTime FIRST_EVENT_TIME = DateTimes.of(1994, 4, 29, 1, 0);\n+  // format for the querying interval\n+  static final DateTimeFormatter INTERVAL_FMT = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:'00Z'\");\n+  // format for the expected timestamp in a query response\n+  static final DateTimeFormatter TIMESTAMP_FMT = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss'.000Z'\");\n+  static final int EVENTS_PER_SECOND = 6;\n+  static final int TOTAL_NUMBER_OF_SECOND = 10;\n+  static final Logger LOG = new Logger(AbstractStreamIndexingTest.class);\n+  // Since this integration test can terminates or be killed un-expectedly, this tag is added to all streams created\n+  // to help make stream clean up easier. (Normally, streams should be cleanup automattically by the teardown method)\n+  // The value to this tag is a timestamp that can be used by a lambda function to remove unused stream.\n+  private static final String STREAM_EXPIRE_TAG = \"druid-ci-expire-after\";\n+  private static final int STREAM_SHARD_COUNT = 2;\n+  private static final long WAIT_TIME_MILLIS = 3 * 60 * 1000L;\n+  private static final String INDEXER_FILE_LEGACY_PARSER = \"/indexer/stream_supervisor_spec_legacy_parser.json\";\n+  private static final String INDEXER_FILE_INPUT_FORMAT = \"/indexer/stream_supervisor_spec_input_format.json\";\n+  private static final String QUERIES_FILE = \"/indexer/stream_index_queries.json\";\n+  private static final long CYCLE_PADDING_MS = 100;\n+\n+  @Inject\n+  private DruidClusterAdminClient druidClusterAdminClient;\n+\n+  private StreamAdminClient streamAdminClient;\n+  private WikipediaStreamEventStreamGenerator wikipediaStreamEventGenerator;\n+\n+  abstract StreamAdminClient getStreamAdminClient() throws Exception;\n+  abstract StreamEventWriter getStreamEventWriter() throws Exception;", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwMzgwNA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412703804", "bodyText": "Done.", "author": "maytasm", "createdAt": "2020-04-22T06:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY1NjM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY1NjU3OA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412656578", "bodyText": "nit: can be private.", "author": "jihoonson", "createdAt": "2020-04-22T04:15:55Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/indexer/AbstractStreamIndexingTest.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.tests.indexer;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.inject.Inject;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorStateManager;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.testing.utils.DruidClusterAdminClient;\n+import org.apache.druid.testing.utils.ITRetryUtil;\n+import org.apache.druid.testing.utils.StreamAdminClient;\n+import org.apache.druid.testing.utils.StreamEventWriter;\n+import org.apache.druid.testing.utils.WikipediaStreamEventStreamGenerator;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+public abstract class AbstractStreamIndexingTest extends AbstractIndexerTest\n+{\n+  static final DateTime FIRST_EVENT_TIME = DateTimes.of(1994, 4, 29, 1, 0);\n+  // format for the querying interval\n+  static final DateTimeFormatter INTERVAL_FMT = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:'00Z'\");\n+  // format for the expected timestamp in a query response\n+  static final DateTimeFormatter TIMESTAMP_FMT = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss'.000Z'\");\n+  static final int EVENTS_PER_SECOND = 6;\n+  static final int TOTAL_NUMBER_OF_SECOND = 10;\n+  static final Logger LOG = new Logger(AbstractStreamIndexingTest.class);", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcwNDQ0Ng==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412704446", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-04-22T06:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY1NjU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2MDQ3Ng==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412660476", "bodyText": "Can you add javadoc? It would be nice to explain where this class is used, how it is used, what is the contracts for implementations and so on.", "author": "jihoonson", "createdAt": "2020-04-22T04:27:49Z", "path": "integration-tests/src/main/java/org/apache/druid/testing/utils/StreamAdminClient.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.testing.utils;\n+\n+import java.util.Map;\n+\n+public interface StreamAdminClient", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMTEzMg==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412711132", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-04-22T06:41:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2MDQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2MTE4NA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412661184", "bodyText": "SeekableStream series use the word \"partition\" instead of \"shard\". It would be nice to use a consistent name.", "author": "jihoonson", "createdAt": "2020-04-22T04:30:08Z", "path": "integration-tests/src/main/java/org/apache/druid/testing/utils/StreamAdminClient.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.testing.utils;\n+\n+import java.util.Map;\n+\n+public interface StreamAdminClient\n+{\n+  void createStream(String streamName, int partitionCount, Map<String, String> tags) throws Exception;\n+\n+  void deleteStream(String streamName) throws Exception;\n+\n+  void updateShardCount(String streamName, int newPartitionCount, boolean blocksUntilStarted) throws Exception;", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxMzAzNA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412713034", "bodyText": "I am really sad Kinesis and Kafka don't just call everything the same. Which then extends to our Kafka and Kinesis supervisor spec like useEarliestSequenceNumber vs useEarliestOffset. I spent an hour setting the wrong one and wondering why it wasn't working.", "author": "maytasm", "createdAt": "2020-04-22T06:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2MTE4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxNDA5OQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412714099", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-04-22T06:47:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2MTE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2MTczOA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412661738", "bodyText": "nit: can be private final.", "author": "jihoonson", "createdAt": "2020-04-22T04:31:43Z", "path": "integration-tests/src/main/java/org/apache/druid/testing/utils/KafkaAdminClient.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.testing.utils;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.admin.AdminClientConfig;\n+import org.apache.kafka.clients.admin.CreatePartitionsResult;\n+import org.apache.kafka.clients.admin.CreateTopicsResult;\n+import org.apache.kafka.clients.admin.DeleteTopicsResult;\n+import org.apache.kafka.clients.admin.DescribeTopicsResult;\n+import org.apache.kafka.clients.admin.NewPartitions;\n+import org.apache.kafka.clients.admin.NewTopic;\n+import org.apache.kafka.clients.admin.TopicDescription;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+public class KafkaAdminClient implements StreamAdminClient\n+{\n+  AdminClient adminClient;", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxNTA5OA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412715098", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-04-22T06:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2MTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2MjY0Ng==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412662646", "bodyText": "nit: Intellij recommends using setProperty() instead of put(). I guess it's because the parameter type is more strict.", "author": "jihoonson", "createdAt": "2020-04-22T04:34:42Z", "path": "integration-tests/src/main/java/org/apache/druid/testing/utils/KafkaAdminClient.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.testing.utils;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.admin.AdminClientConfig;\n+import org.apache.kafka.clients.admin.CreatePartitionsResult;\n+import org.apache.kafka.clients.admin.CreateTopicsResult;\n+import org.apache.kafka.clients.admin.DeleteTopicsResult;\n+import org.apache.kafka.clients.admin.DescribeTopicsResult;\n+import org.apache.kafka.clients.admin.NewPartitions;\n+import org.apache.kafka.clients.admin.NewTopic;\n+import org.apache.kafka.clients.admin.TopicDescription;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+public class KafkaAdminClient implements StreamAdminClient\n+{\n+  AdminClient adminClient;\n+\n+  public KafkaAdminClient(String kafkaInternalHost)\n+  {\n+    Properties config = new Properties();\n+    config.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaInternalHost);", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxNTU5Mg==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412715592", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-04-22T06:50:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2MjY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2NDI1MQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412664251", "bodyText": "What does \"active stream\" mean for Kafka?", "author": "jihoonson", "createdAt": "2020-04-22T04:39:41Z", "path": "integration-tests/src/main/java/org/apache/druid/testing/utils/KafkaAdminClient.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.testing.utils;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.admin.AdminClientConfig;\n+import org.apache.kafka.clients.admin.CreatePartitionsResult;\n+import org.apache.kafka.clients.admin.CreateTopicsResult;\n+import org.apache.kafka.clients.admin.DeleteTopicsResult;\n+import org.apache.kafka.clients.admin.DescribeTopicsResult;\n+import org.apache.kafka.clients.admin.NewPartitions;\n+import org.apache.kafka.clients.admin.NewTopic;\n+import org.apache.kafka.clients.admin.TopicDescription;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+public class KafkaAdminClient implements StreamAdminClient\n+{\n+  AdminClient adminClient;\n+\n+  public KafkaAdminClient(String kafkaInternalHost)\n+  {\n+    Properties config = new Properties();\n+    config.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, kafkaInternalHost);\n+    adminClient = AdminClient.create(config);\n+  }\n+\n+  @Override\n+  public void createStream(String streamName, int partitionCount, Map<String, String> tags) throws Exception\n+  {\n+    final short replicationFactor = 1;\n+    final NewTopic newTopic = new NewTopic(streamName, partitionCount, replicationFactor);\n+    final CreateTopicsResult createTopicsResult = adminClient.createTopics(Collections.singleton(newTopic));\n+    // Wait for create topic to compelte\n+    createTopicsResult.values().get(streamName).get();\n+  }\n+\n+  @Override\n+  public void deleteStream(String streamName) throws Exception\n+  {\n+    DeleteTopicsResult deleteTopicsResult = adminClient.deleteTopics(ImmutableList.of(streamName));\n+    deleteTopicsResult.values().get(streamName).get();\n+  }\n+\n+  /**\n+   * This method can only increase the partition count of {@param streamName} to have a final partition\n+   * count of {@param newPartitionCount}\n+   * If {@param blocksUntilStarted} is set to true, then this method will blocks until the partitioning\n+   * started (but not nessesary finished), otherwise, the method will returns right after issue the reshard command\n+   */\n+  @Override\n+  public void updateShardCount(String streamName, int newPartitionCount, boolean blocksUntilStarted) throws Exception\n+  {\n+    Map<String, NewPartitions> counts = new HashMap<>();\n+    counts.put(streamName, NewPartitions.increaseTo(newPartitionCount));\n+    CreatePartitionsResult createPartitionsResult = adminClient.createPartitions(counts);\n+    if (blocksUntilStarted) {\n+      createPartitionsResult.values().get(streamName).get();\n+\n+    }\n+  }\n+\n+  @Override\n+  public boolean isStreamActive(String streamName)\n+  {\n+    return true;", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxNjI2MQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412716261", "bodyText": "It doesn't means anything but since it implement the interface it needs the method. Added comment.", "author": "maytasm", "createdAt": "2020-04-22T06:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2NDI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2NDc4NQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412664785", "bodyText": "These 3 private variables can be final.", "author": "jihoonson", "createdAt": "2020-04-22T04:41:21Z", "path": "integration-tests/src/main/java/org/apache/druid/testing/utils/KafkaEventWriter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.testing.utils;\n+\n+import org.apache.druid.indexer.TaskIdUtils;\n+import org.apache.druid.testing.IntegrationTestingConfig;\n+import org.apache.kafka.clients.producer.KafkaProducer;\n+import org.apache.kafka.clients.producer.ProducerRecord;\n+import org.apache.kafka.clients.producer.RecordMetadata;\n+import org.apache.kafka.common.serialization.ByteArraySerializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.Future;\n+\n+public class KafkaEventWriter implements StreamEventWriter\n+{\n+  private static final String TEST_PROPERTY_PREFIX = \"kafka.test.property.\";\n+  private KafkaProducer<String, String> producer;\n+  private boolean txnEnabled;\n+  private List<Future<RecordMetadata>> pendingWriteRecords = new ArrayList<>();", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcxODk4OQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412718989", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-04-22T06:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2NDc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2OTEwMw==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412669103", "bodyText": "nit: it would be better to check the compaction config is set by calling the compaction config API.", "author": "jihoonson", "createdAt": "2020-04-22T04:55:11Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/coordinator/duty/ITAutoCompactionTest.java", "diffHunk": "@@ -251,6 +251,9 @@ private void submitCompactionConfig(Integer maxRowsPerSegment, Period skipOffset\n                                                                                  null);\n     compactionResource.submitCompactionConfig(compactionConfig);\n \n+    // Wait for compaction config to persist\n+    Thread.sleep(2000);", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyMDk5NA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412720994", "bodyText": "I actually do make calls to config/compaction and config/compaction/{datasource} to verify that the compaction is updated. But I did see that the old config was apply to the compaction when the test runs in the following sequence... post config 1 datasource A-> verify config 1 from the two get calls -> post config 2 datasource A-> verify config 2 from the two get calls -> force compaction datasource A\nWill look at this more closely in a separate PR. Lets keep this hear to reduce intermittent failure but I'll revisit later.", "author": "maytasm", "createdAt": "2020-04-22T06:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2OTEwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2NjkzNQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r413166935", "bodyText": "Sounds good.", "author": "jihoonson", "createdAt": "2020-04-22T17:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2OTEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2OTQ4Mw==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412669483", "bodyText": "Why not injecting it in Kafka/Kinesis tests?", "author": "jihoonson", "createdAt": "2020-04-22T04:56:20Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/indexer/AbstractIndexerTest.java", "diffHunk": "@@ -57,7 +57,7 @@\n   protected TestQueryHelper queryHelper;\n \n   @Inject\n-  private IntegrationTestingConfig config;\n+  public IntegrationTestingConfig config;", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyMTM0OA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412721348", "bodyText": "Got lazy. I can do that.", "author": "maytasm", "createdAt": "2020-04-22T07:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2OTQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNjYwNg==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412726606", "bodyText": "done", "author": "maytasm", "createdAt": "2020-04-22T07:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2OTQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2OTY4Mg==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412669682", "bodyText": "nit: can be protected.", "author": "jihoonson", "createdAt": "2020-04-22T04:56:59Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/indexer/AbstractKafkaIndexingServiceTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.tests.indexer;\n+\n+import org.apache.druid.indexing.kafka.KafkaConsumerConfigs;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.testing.utils.KafkaAdminClient;\n+import org.apache.druid.testing.utils.KafkaEventWriter;\n+import org.apache.druid.testing.utils.StreamAdminClient;\n+import org.apache.druid.testing.utils.StreamEventWriter;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.function.Function;\n+\n+public abstract class AbstractKafkaIndexingServiceTest extends AbstractStreamIndexingTest\n+{\n+  public abstract boolean isKafkaWriterTransactionalEnabled();", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNjUyNw==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412726527", "bodyText": "done", "author": "maytasm", "createdAt": "2020-04-22T07:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY2OTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3MjU1Mg==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412672552", "bodyText": "\"may have already gone\"?", "author": "jihoonson", "createdAt": "2020-04-22T05:05:59Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/indexer/AbstractStreamIndexingTest.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.tests.indexer;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.inject.Inject;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorStateManager;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.testing.utils.DruidClusterAdminClient;\n+import org.apache.druid.testing.utils.ITRetryUtil;\n+import org.apache.druid.testing.utils.StreamAdminClient;\n+import org.apache.druid.testing.utils.StreamEventWriter;\n+import org.apache.druid.testing.utils.WikipediaStreamEventStreamGenerator;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+public abstract class AbstractStreamIndexingTest extends AbstractIndexerTest\n+{\n+  static final DateTime FIRST_EVENT_TIME = DateTimes.of(1994, 4, 29, 1, 0);\n+  // format for the querying interval\n+  static final DateTimeFormatter INTERVAL_FMT = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:'00Z'\");\n+  // format for the expected timestamp in a query response\n+  static final DateTimeFormatter TIMESTAMP_FMT = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss'.000Z'\");\n+  static final int EVENTS_PER_SECOND = 6;\n+  static final int TOTAL_NUMBER_OF_SECOND = 10;\n+  static final Logger LOG = new Logger(AbstractStreamIndexingTest.class);\n+  // Since this integration test can terminates or be killed un-expectedly, this tag is added to all streams created\n+  // to help make stream clean up easier. (Normally, streams should be cleanup automattically by the teardown method)\n+  // The value to this tag is a timestamp that can be used by a lambda function to remove unused stream.\n+  private static final String STREAM_EXPIRE_TAG = \"druid-ci-expire-after\";\n+  private static final int STREAM_SHARD_COUNT = 2;\n+  private static final long WAIT_TIME_MILLIS = 3 * 60 * 1000L;\n+  private static final String INDEXER_FILE_LEGACY_PARSER = \"/indexer/stream_supervisor_spec_legacy_parser.json\";\n+  private static final String INDEXER_FILE_INPUT_FORMAT = \"/indexer/stream_supervisor_spec_input_format.json\";\n+  private static final String QUERIES_FILE = \"/indexer/stream_index_queries.json\";\n+  private static final long CYCLE_PADDING_MS = 100;\n+\n+  @Inject\n+  private DruidClusterAdminClient druidClusterAdminClient;\n+\n+  private StreamAdminClient streamAdminClient;\n+  private WikipediaStreamEventStreamGenerator wikipediaStreamEventGenerator;\n+\n+  abstract StreamAdminClient getStreamAdminClient() throws Exception;\n+  abstract StreamEventWriter getStreamEventWriter() throws Exception;\n+  abstract Function<String, String> generateStreamIngestionPropsTransform(String streamName, String fullDatasourceName);\n+  abstract Function<String, String> generateStreamQueryPropsTransform(String streamName, String fullDatasourceName);\n+  public abstract String getTestNamePrefix();\n+\n+  protected void doBeforeClass() throws Exception\n+  {\n+    streamAdminClient = getStreamAdminClient();\n+    wikipediaStreamEventGenerator = new WikipediaStreamEventStreamGenerator(EVENTS_PER_SECOND, CYCLE_PADDING_MS);\n+  }\n+\n+  protected void doClassTeardown()\n+  {\n+    wikipediaStreamEventGenerator.shutdown();\n+  }\n+\n+  protected void doTestIndexDataWithLegacyParserStableState() throws Exception\n+  {\n+    StreamEventWriter streamEventWriter = getStreamEventWriter();\n+    final GeneratedTestConfig generatedTestConfig = new GeneratedTestConfig();\n+    try (\n+        final Closeable ignored1 = unloader(generatedTestConfig.getFullDatasourceName())\n+    ) {\n+      final String taskSpec = generatedTestConfig.getStreamIngestionPropsTransform().apply(getResourceAsString(INDEXER_FILE_LEGACY_PARSER));\n+      LOG.info(\"supervisorSpec: [%s]\\n\", taskSpec);\n+      // Start supervisor\n+      generatedTestConfig.setSupervisorId(indexer.submitSupervisor(taskSpec));\n+      LOG.info(\"Submitted supervisor\");\n+      // Start data generator\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, TOTAL_NUMBER_OF_SECOND, FIRST_EVENT_TIME);\n+      verifyIngestedData(generatedTestConfig);\n+    }\n+    finally {\n+      doMethodTeardown(generatedTestConfig, streamEventWriter);\n+    }\n+  }\n+\n+  protected void doTestIndexDataWithInputFormatStableState() throws Exception\n+  {\n+    StreamEventWriter streamEventWriter = getStreamEventWriter();\n+    final GeneratedTestConfig generatedTestConfig = new GeneratedTestConfig();\n+    try (\n+        final Closeable ignored1 = unloader(generatedTestConfig.getFullDatasourceName())\n+    ) {\n+      final String taskSpec = generatedTestConfig.getStreamIngestionPropsTransform().apply(getResourceAsString(INDEXER_FILE_INPUT_FORMAT));\n+      LOG.info(\"supervisorSpec: [%s]\\n\", taskSpec);\n+      // Start supervisor\n+      generatedTestConfig.setSupervisorId(indexer.submitSupervisor(taskSpec));\n+      LOG.info(\"Submitted supervisor\");\n+      // Start data generator\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, TOTAL_NUMBER_OF_SECOND, FIRST_EVENT_TIME);\n+      verifyIngestedData(generatedTestConfig);\n+    }\n+    finally {\n+      doMethodTeardown(generatedTestConfig, streamEventWriter);\n+    }\n+  }\n+\n+  void doTestIndexDataWithLosingCoordinator() throws Exception\n+  {\n+    testIndexWithLosingNodeHelper(() -> druidClusterAdminClient.restartCoordinatorContainer(), () -> druidClusterAdminClient.waitUntilCoordinatorReady());\n+  }\n+\n+  void doTestIndexDataWithLosingOverlord() throws Exception\n+  {\n+    testIndexWithLosingNodeHelper(() -> druidClusterAdminClient.restartIndexerContainer(), () -> druidClusterAdminClient.waitUntilIndexerReady());\n+  }\n+\n+  void doTestIndexDataWithLosingHistorical() throws Exception\n+  {\n+    testIndexWithLosingNodeHelper(() -> druidClusterAdminClient.restartHistoricalContainer(), () -> druidClusterAdminClient.waitUntilHistoricalReady());\n+  }\n+\n+  protected void doTestIndexDataWithStartStopSupervisor() throws Exception\n+  {\n+    StreamEventWriter streamEventWriter = getStreamEventWriter();\n+    final GeneratedTestConfig generatedTestConfig = new GeneratedTestConfig();\n+    try (\n+        final Closeable ignored1 = unloader(generatedTestConfig.getFullDatasourceName())\n+    ) {\n+      final String taskSpec = generatedTestConfig.getStreamIngestionPropsTransform().apply(getResourceAsString(INDEXER_FILE_INPUT_FORMAT));\n+      LOG.info(\"supervisorSpec: [%s]\\n\", taskSpec);\n+      // Start supervisor\n+      generatedTestConfig.setSupervisorId(indexer.submitSupervisor(taskSpec));\n+      LOG.info(\"Submitted supervisor\");\n+      // Start generating half of the data\n+      int secondsToGenerateRemaining = TOTAL_NUMBER_OF_SECOND;\n+      int secondsToGenerateFirstRound = TOTAL_NUMBER_OF_SECOND / 2;\n+      secondsToGenerateRemaining = secondsToGenerateRemaining - secondsToGenerateFirstRound;\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateFirstRound, FIRST_EVENT_TIME);\n+      // Verify supervisor is healthy before suspension\n+      ITRetryUtil.retryUntil(\n+          () -> SupervisorStateManager.BasicState.RUNNING.equals(indexer.getSupervisorStatus(generatedTestConfig.getSupervisorId())),\n+          true,\n+          10000,\n+          30,\n+          \"Waiting for supervisor to be healthy\"\n+      );\n+      // Suspend the supervisor\n+      indexer.suspendSupervisor(generatedTestConfig.getSupervisorId());\n+      // Start generating remainning half of the data\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateRemaining, FIRST_EVENT_TIME.plusSeconds(secondsToGenerateFirstRound));\n+      // Resume the supervisor\n+      indexer.resumeSupervisor(generatedTestConfig.getSupervisorId());\n+      // Verify supervisor is healthy after suspension\n+      ITRetryUtil.retryUntil(\n+          () -> SupervisorStateManager.BasicState.RUNNING.equals(indexer.getSupervisorStatus(generatedTestConfig.getSupervisorId())),\n+          true,\n+          10000,\n+          30,\n+          \"Waiting for supervisor to be healthy\"\n+      );\n+      // Verify that supervisor can catch up with the stream\n+      verifyIngestedData(generatedTestConfig);\n+    }\n+    finally {\n+      doMethodTeardown(generatedTestConfig, streamEventWriter);\n+    }\n+  }\n+\n+  protected void doTestIndexDataWithStreamReshardSplit() throws Exception\n+  {\n+    // Reshard the stream from STREAM_SHARD_COUNT to STREAM_SHARD_COUNT * 2\n+    testIndexWithStreamReshardHelper(STREAM_SHARD_COUNT * 2);\n+  }\n+\n+  protected void doTestIndexDataWithStreamReshardMerge() throws Exception\n+  {\n+    // Reshard the stream from STREAM_SHARD_COUNT to STREAM_SHARD_COUNT / 2\n+    testIndexWithStreamReshardHelper(STREAM_SHARD_COUNT / 2);\n+  }\n+\n+  private void testIndexWithLosingNodeHelper(Runnable restartRunnable, Runnable waitForReadyRunnable) throws Exception\n+  {\n+    StreamEventWriter streamEventWriter = getStreamEventWriter();\n+    final GeneratedTestConfig generatedTestConfig = new GeneratedTestConfig();\n+    try (\n+        final Closeable ignored1 = unloader(generatedTestConfig.getFullDatasourceName())\n+    ) {\n+      final String taskSpec = generatedTestConfig.getStreamIngestionPropsTransform().apply(getResourceAsString(INDEXER_FILE_INPUT_FORMAT));\n+      LOG.info(\"supervisorSpec: [%s]\\n\", taskSpec);\n+      // Start supervisor\n+      generatedTestConfig.setSupervisorId(indexer.submitSupervisor(taskSpec));\n+      LOG.info(\"Submitted supervisor\");\n+      // Start generating one third of the data (before restarting)\n+      int secondsToGenerateRemaining = TOTAL_NUMBER_OF_SECOND;\n+      int secondsToGenerateFirstRound = TOTAL_NUMBER_OF_SECOND / 3;\n+      secondsToGenerateRemaining = secondsToGenerateRemaining - secondsToGenerateFirstRound;\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateFirstRound, FIRST_EVENT_TIME);\n+      // Verify supervisor is healthy before restart\n+      ITRetryUtil.retryUntil(\n+          () -> SupervisorStateManager.BasicState.RUNNING.equals(indexer.getSupervisorStatus(generatedTestConfig.getSupervisorId())),\n+          true,\n+          10000,\n+          30,\n+          \"Waiting for supervisor to be healthy\"\n+      );\n+      // Restart Druid process\n+      LOG.info(\"Restarting Druid process\");\n+      restartRunnable.run();\n+      LOG.info(\"Restarted Druid process\");\n+      // Start generating one third of the data (while restarting)\n+      int secondsToGenerateSecondRound = TOTAL_NUMBER_OF_SECOND / 3;\n+      secondsToGenerateRemaining = secondsToGenerateRemaining - secondsToGenerateSecondRound;\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateSecondRound, FIRST_EVENT_TIME.plusSeconds(secondsToGenerateFirstRound));\n+      // Wait for Druid process to be available\n+      LOG.info(\"Waiting for Druid process to be available\");\n+      waitForReadyRunnable.run();\n+      LOG.info(\"Druid process is now available\");\n+      // Start generating remainding data (after restarting)\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateRemaining, FIRST_EVENT_TIME.plusSeconds(secondsToGenerateFirstRound + secondsToGenerateSecondRound));\n+      // Verify supervisor is healthy\n+      ITRetryUtil.retryUntil(\n+          () -> SupervisorStateManager.BasicState.RUNNING.equals(indexer.getSupervisorStatus(generatedTestConfig.getSupervisorId())),\n+          true,\n+          10000,\n+          30,\n+          \"Waiting for supervisor to be healthy\"\n+      );\n+      // Verify that supervisor ingested all data\n+      verifyIngestedData(generatedTestConfig);\n+    }\n+    finally {\n+      doMethodTeardown(generatedTestConfig, streamEventWriter);\n+    }\n+  }\n+\n+  private void testIndexWithStreamReshardHelper(int newShardCount) throws Exception\n+  {\n+    StreamEventWriter streamEventWriter = getStreamEventWriter();\n+    final GeneratedTestConfig generatedTestConfig = new GeneratedTestConfig();\n+    try (\n+        final Closeable ignored1 = unloader(generatedTestConfig.getFullDatasourceName())\n+    ) {\n+      final String taskSpec = generatedTestConfig.getStreamIngestionPropsTransform().apply(getResourceAsString(INDEXER_FILE_INPUT_FORMAT));\n+      LOG.info(\"supervisorSpec: [%s]\\n\", taskSpec);\n+      // Start supervisor\n+      generatedTestConfig.setSupervisorId(indexer.submitSupervisor(taskSpec));\n+      LOG.info(\"Submitted supervisor\");\n+      // Start generating one third of the data (before resharding)\n+      int secondsToGenerateRemaining = TOTAL_NUMBER_OF_SECOND;\n+      int secondsToGenerateFirstRound = TOTAL_NUMBER_OF_SECOND / 3;\n+      secondsToGenerateRemaining = secondsToGenerateRemaining - secondsToGenerateFirstRound;\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateFirstRound, FIRST_EVENT_TIME);\n+      // Verify supervisor is healthy before resahrding\n+      ITRetryUtil.retryUntil(\n+          () -> SupervisorStateManager.BasicState.RUNNING.equals(indexer.getSupervisorStatus(generatedTestConfig.getSupervisorId())),\n+          true,\n+          10000,\n+          30,\n+          \"Waiting for supervisor to be healthy\"\n+      );\n+      // Reshard the supervisor by split from STREAM_SHARD_COUNT to newShardCount and waits until the resharding starts\n+      streamAdminClient.updateShardCount(generatedTestConfig.getStreamName(), newShardCount, true);\n+      // Start generating one third of the data (while resharding)\n+      int secondsToGenerateSecondRound = TOTAL_NUMBER_OF_SECOND / 3;\n+      secondsToGenerateRemaining = secondsToGenerateRemaining - secondsToGenerateSecondRound;\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateSecondRound, FIRST_EVENT_TIME.plusSeconds(secondsToGenerateFirstRound));\n+      // Wait for stream to finish resharding\n+      ITRetryUtil.retryUntil(\n+          () -> streamAdminClient.isStreamActive(generatedTestConfig.getStreamName()),\n+          true,\n+          10000,\n+          30,\n+          \"Waiting for stream to finish resharding\"\n+      );\n+      ITRetryUtil.retryUntil(\n+          () -> streamAdminClient.verfiyShardCountUpdated(generatedTestConfig.getStreamName(), STREAM_SHARD_COUNT, newShardCount),\n+          true,\n+          10000,\n+          30,\n+          \"Waiting for stream to finish resharding\"\n+      );\n+      // Start generating remainding data (after resharding)\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateRemaining, FIRST_EVENT_TIME.plusSeconds(secondsToGenerateFirstRound + secondsToGenerateSecondRound));\n+      // Verify supervisor is healthy after resahrding\n+      ITRetryUtil.retryUntil(\n+          () -> SupervisorStateManager.BasicState.RUNNING.equals(indexer.getSupervisorStatus(generatedTestConfig.getSupervisorId())),\n+          true,\n+          10000,\n+          30,\n+          \"Waiting for supervisor to be healthy\"\n+      );\n+      // Verify that supervisor can catch up with the stream\n+      verifyIngestedData(generatedTestConfig);\n+    }\n+    finally {\n+      doMethodTeardown(generatedTestConfig, streamEventWriter);\n+    }\n+  }\n+\n+  private void verifyIngestedData(GeneratedTestConfig generatedTestConfig) throws Exception\n+  {\n+    // Wait for supervisor to consume events\n+    LOG.info(\"Waiting for [%s] millis for stream indexing tasks to consume events\", WAIT_TIME_MILLIS);\n+    Thread.sleep(WAIT_TIME_MILLIS);\n+    // Query data\n+    final String querySpec = generatedTestConfig.getStreamQueryPropsTransform().apply(getResourceAsString(QUERIES_FILE));\n+    // this query will probably be answered from the indexing tasks but possibly from 2 historical segments / 2 indexing\n+    this.queryHelper.testQueriesFromString(querySpec, 2);\n+    LOG.info(\"Shutting down supervisor\");\n+    indexer.shutdownSupervisor(generatedTestConfig.getSupervisorId());\n+    // wait for all indexing tasks to finish\n+    LOG.info(\"Waiting for all indexing tasks to finish\");\n+    ITRetryUtil.retryUntilTrue(\n+        () -> (indexer.getUncompletedTasksForDataSource(generatedTestConfig.getFullDatasourceName()).size() == 0),\n+        \"Waiting for Tasks Completion\"\n+    );\n+    // wait for segments to be handed off\n+    ITRetryUtil.retryUntil(\n+        () -> coordinator.areSegmentsLoaded(generatedTestConfig.getFullDatasourceName()),\n+        true,\n+        10000,\n+        30,\n+        \"Real-time generated segments loaded\"\n+    );\n+\n+    // this query will be answered by at least 1 historical segment, most likely 2, and possibly up to all 4\n+    this.queryHelper.testQueriesFromString(querySpec, 2);\n+  }\n+\n+  long getSumOfEventSequence(int numEvents)\n+  {\n+    return (numEvents * (1 + numEvents)) / 2;\n+  }\n+\n+  private void doMethodTeardown(GeneratedTestConfig generatedTestConfig, StreamEventWriter streamEventWriter)\n+  {\n+    try {\n+      streamEventWriter.flush();\n+    }\n+    catch (Exception e) {\n+      // Best effort cleanup as the writer may have already went Bye-Bye", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3Mjg2OA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412672868", "bodyText": "BTW, I don't think ignoring exceptions is a good idea in any case. Probably it should log at least.", "author": "jihoonson", "createdAt": "2020-04-22T05:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3MjU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjcyNzI4Mw==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412727283", "bodyText": "hahaha\nDone", "author": "maytasm", "createdAt": "2020-04-22T07:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3MjU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY4NTQ5Mg==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412685492", "bodyText": "Probably better to call run() or generate() rather than start() since the generator is not something you can start/stop, but generates all events in start().", "author": "jihoonson", "createdAt": "2020-04-22T05:42:41Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/indexer/AbstractStreamIndexingTest.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.tests.indexer;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.inject.Inject;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorStateManager;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.testing.utils.DruidClusterAdminClient;\n+import org.apache.druid.testing.utils.ITRetryUtil;\n+import org.apache.druid.testing.utils.StreamAdminClient;\n+import org.apache.druid.testing.utils.StreamEventWriter;\n+import org.apache.druid.testing.utils.WikipediaStreamEventStreamGenerator;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+public abstract class AbstractStreamIndexingTest extends AbstractIndexerTest\n+{\n+  static final DateTime FIRST_EVENT_TIME = DateTimes.of(1994, 4, 29, 1, 0);\n+  // format for the querying interval\n+  static final DateTimeFormatter INTERVAL_FMT = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:'00Z'\");\n+  // format for the expected timestamp in a query response\n+  static final DateTimeFormatter TIMESTAMP_FMT = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss'.000Z'\");\n+  static final int EVENTS_PER_SECOND = 6;\n+  static final int TOTAL_NUMBER_OF_SECOND = 10;\n+  static final Logger LOG = new Logger(AbstractStreamIndexingTest.class);\n+  // Since this integration test can terminates or be killed un-expectedly, this tag is added to all streams created\n+  // to help make stream clean up easier. (Normally, streams should be cleanup automattically by the teardown method)\n+  // The value to this tag is a timestamp that can be used by a lambda function to remove unused stream.\n+  private static final String STREAM_EXPIRE_TAG = \"druid-ci-expire-after\";\n+  private static final int STREAM_SHARD_COUNT = 2;\n+  private static final long WAIT_TIME_MILLIS = 3 * 60 * 1000L;\n+  private static final String INDEXER_FILE_LEGACY_PARSER = \"/indexer/stream_supervisor_spec_legacy_parser.json\";\n+  private static final String INDEXER_FILE_INPUT_FORMAT = \"/indexer/stream_supervisor_spec_input_format.json\";\n+  private static final String QUERIES_FILE = \"/indexer/stream_index_queries.json\";\n+  private static final long CYCLE_PADDING_MS = 100;\n+\n+  @Inject\n+  private DruidClusterAdminClient druidClusterAdminClient;\n+\n+  private StreamAdminClient streamAdminClient;\n+  private WikipediaStreamEventStreamGenerator wikipediaStreamEventGenerator;\n+\n+  abstract StreamAdminClient getStreamAdminClient() throws Exception;\n+  abstract StreamEventWriter getStreamEventWriter() throws Exception;\n+  abstract Function<String, String> generateStreamIngestionPropsTransform(String streamName, String fullDatasourceName);\n+  abstract Function<String, String> generateStreamQueryPropsTransform(String streamName, String fullDatasourceName);\n+  public abstract String getTestNamePrefix();\n+\n+  protected void doBeforeClass() throws Exception\n+  {\n+    streamAdminClient = getStreamAdminClient();\n+    wikipediaStreamEventGenerator = new WikipediaStreamEventStreamGenerator(EVENTS_PER_SECOND, CYCLE_PADDING_MS);\n+  }\n+\n+  protected void doClassTeardown()\n+  {\n+    wikipediaStreamEventGenerator.shutdown();\n+  }\n+\n+  protected void doTestIndexDataWithLegacyParserStableState() throws Exception\n+  {\n+    StreamEventWriter streamEventWriter = getStreamEventWriter();\n+    final GeneratedTestConfig generatedTestConfig = new GeneratedTestConfig();\n+    try (\n+        final Closeable ignored1 = unloader(generatedTestConfig.getFullDatasourceName())\n+    ) {\n+      final String taskSpec = generatedTestConfig.getStreamIngestionPropsTransform().apply(getResourceAsString(INDEXER_FILE_LEGACY_PARSER));\n+      LOG.info(\"supervisorSpec: [%s]\\n\", taskSpec);\n+      // Start supervisor\n+      generatedTestConfig.setSupervisorId(indexer.submitSupervisor(taskSpec));\n+      LOG.info(\"Submitted supervisor\");\n+      // Start data generator\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, TOTAL_NUMBER_OF_SECOND, FIRST_EVENT_TIME);", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjczMjU2OQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412732569", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-04-22T07:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY4NTQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY4NjYxMw==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412686613", "bodyText": "remainding -> remaining?", "author": "jihoonson", "createdAt": "2020-04-22T05:45:42Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/indexer/AbstractStreamIndexingTest.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.tests.indexer;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.inject.Inject;\n+import org.apache.druid.indexing.overlord.supervisor.SupervisorStateManager;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.testing.utils.DruidClusterAdminClient;\n+import org.apache.druid.testing.utils.ITRetryUtil;\n+import org.apache.druid.testing.utils.StreamAdminClient;\n+import org.apache.druid.testing.utils.StreamEventWriter;\n+import org.apache.druid.testing.utils.WikipediaStreamEventStreamGenerator;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.joda.time.format.DateTimeFormatter;\n+\n+import java.io.Closeable;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+public abstract class AbstractStreamIndexingTest extends AbstractIndexerTest\n+{\n+  static final DateTime FIRST_EVENT_TIME = DateTimes.of(1994, 4, 29, 1, 0);\n+  // format for the querying interval\n+  static final DateTimeFormatter INTERVAL_FMT = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:'00Z'\");\n+  // format for the expected timestamp in a query response\n+  static final DateTimeFormatter TIMESTAMP_FMT = DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss'.000Z'\");\n+  static final int EVENTS_PER_SECOND = 6;\n+  static final int TOTAL_NUMBER_OF_SECOND = 10;\n+  static final Logger LOG = new Logger(AbstractStreamIndexingTest.class);\n+  // Since this integration test can terminates or be killed un-expectedly, this tag is added to all streams created\n+  // to help make stream clean up easier. (Normally, streams should be cleanup automattically by the teardown method)\n+  // The value to this tag is a timestamp that can be used by a lambda function to remove unused stream.\n+  private static final String STREAM_EXPIRE_TAG = \"druid-ci-expire-after\";\n+  private static final int STREAM_SHARD_COUNT = 2;\n+  private static final long WAIT_TIME_MILLIS = 3 * 60 * 1000L;\n+  private static final String INDEXER_FILE_LEGACY_PARSER = \"/indexer/stream_supervisor_spec_legacy_parser.json\";\n+  private static final String INDEXER_FILE_INPUT_FORMAT = \"/indexer/stream_supervisor_spec_input_format.json\";\n+  private static final String QUERIES_FILE = \"/indexer/stream_index_queries.json\";\n+  private static final long CYCLE_PADDING_MS = 100;\n+\n+  @Inject\n+  private DruidClusterAdminClient druidClusterAdminClient;\n+\n+  private StreamAdminClient streamAdminClient;\n+  private WikipediaStreamEventStreamGenerator wikipediaStreamEventGenerator;\n+\n+  abstract StreamAdminClient getStreamAdminClient() throws Exception;\n+  abstract StreamEventWriter getStreamEventWriter() throws Exception;\n+  abstract Function<String, String> generateStreamIngestionPropsTransform(String streamName, String fullDatasourceName);\n+  abstract Function<String, String> generateStreamQueryPropsTransform(String streamName, String fullDatasourceName);\n+  public abstract String getTestNamePrefix();\n+\n+  protected void doBeforeClass() throws Exception\n+  {\n+    streamAdminClient = getStreamAdminClient();\n+    wikipediaStreamEventGenerator = new WikipediaStreamEventStreamGenerator(EVENTS_PER_SECOND, CYCLE_PADDING_MS);\n+  }\n+\n+  protected void doClassTeardown()\n+  {\n+    wikipediaStreamEventGenerator.shutdown();\n+  }\n+\n+  protected void doTestIndexDataWithLegacyParserStableState() throws Exception\n+  {\n+    StreamEventWriter streamEventWriter = getStreamEventWriter();\n+    final GeneratedTestConfig generatedTestConfig = new GeneratedTestConfig();\n+    try (\n+        final Closeable ignored1 = unloader(generatedTestConfig.getFullDatasourceName())\n+    ) {\n+      final String taskSpec = generatedTestConfig.getStreamIngestionPropsTransform().apply(getResourceAsString(INDEXER_FILE_LEGACY_PARSER));\n+      LOG.info(\"supervisorSpec: [%s]\\n\", taskSpec);\n+      // Start supervisor\n+      generatedTestConfig.setSupervisorId(indexer.submitSupervisor(taskSpec));\n+      LOG.info(\"Submitted supervisor\");\n+      // Start data generator\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, TOTAL_NUMBER_OF_SECOND, FIRST_EVENT_TIME);\n+      verifyIngestedData(generatedTestConfig);\n+    }\n+    finally {\n+      doMethodTeardown(generatedTestConfig, streamEventWriter);\n+    }\n+  }\n+\n+  protected void doTestIndexDataWithInputFormatStableState() throws Exception\n+  {\n+    StreamEventWriter streamEventWriter = getStreamEventWriter();\n+    final GeneratedTestConfig generatedTestConfig = new GeneratedTestConfig();\n+    try (\n+        final Closeable ignored1 = unloader(generatedTestConfig.getFullDatasourceName())\n+    ) {\n+      final String taskSpec = generatedTestConfig.getStreamIngestionPropsTransform().apply(getResourceAsString(INDEXER_FILE_INPUT_FORMAT));\n+      LOG.info(\"supervisorSpec: [%s]\\n\", taskSpec);\n+      // Start supervisor\n+      generatedTestConfig.setSupervisorId(indexer.submitSupervisor(taskSpec));\n+      LOG.info(\"Submitted supervisor\");\n+      // Start data generator\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, TOTAL_NUMBER_OF_SECOND, FIRST_EVENT_TIME);\n+      verifyIngestedData(generatedTestConfig);\n+    }\n+    finally {\n+      doMethodTeardown(generatedTestConfig, streamEventWriter);\n+    }\n+  }\n+\n+  void doTestIndexDataWithLosingCoordinator() throws Exception\n+  {\n+    testIndexWithLosingNodeHelper(() -> druidClusterAdminClient.restartCoordinatorContainer(), () -> druidClusterAdminClient.waitUntilCoordinatorReady());\n+  }\n+\n+  void doTestIndexDataWithLosingOverlord() throws Exception\n+  {\n+    testIndexWithLosingNodeHelper(() -> druidClusterAdminClient.restartIndexerContainer(), () -> druidClusterAdminClient.waitUntilIndexerReady());\n+  }\n+\n+  void doTestIndexDataWithLosingHistorical() throws Exception\n+  {\n+    testIndexWithLosingNodeHelper(() -> druidClusterAdminClient.restartHistoricalContainer(), () -> druidClusterAdminClient.waitUntilHistoricalReady());\n+  }\n+\n+  protected void doTestIndexDataWithStartStopSupervisor() throws Exception\n+  {\n+    StreamEventWriter streamEventWriter = getStreamEventWriter();\n+    final GeneratedTestConfig generatedTestConfig = new GeneratedTestConfig();\n+    try (\n+        final Closeable ignored1 = unloader(generatedTestConfig.getFullDatasourceName())\n+    ) {\n+      final String taskSpec = generatedTestConfig.getStreamIngestionPropsTransform().apply(getResourceAsString(INDEXER_FILE_INPUT_FORMAT));\n+      LOG.info(\"supervisorSpec: [%s]\\n\", taskSpec);\n+      // Start supervisor\n+      generatedTestConfig.setSupervisorId(indexer.submitSupervisor(taskSpec));\n+      LOG.info(\"Submitted supervisor\");\n+      // Start generating half of the data\n+      int secondsToGenerateRemaining = TOTAL_NUMBER_OF_SECOND;\n+      int secondsToGenerateFirstRound = TOTAL_NUMBER_OF_SECOND / 2;\n+      secondsToGenerateRemaining = secondsToGenerateRemaining - secondsToGenerateFirstRound;\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateFirstRound, FIRST_EVENT_TIME);\n+      // Verify supervisor is healthy before suspension\n+      ITRetryUtil.retryUntil(\n+          () -> SupervisorStateManager.BasicState.RUNNING.equals(indexer.getSupervisorStatus(generatedTestConfig.getSupervisorId())),\n+          true,\n+          10000,\n+          30,\n+          \"Waiting for supervisor to be healthy\"\n+      );\n+      // Suspend the supervisor\n+      indexer.suspendSupervisor(generatedTestConfig.getSupervisorId());\n+      // Start generating remainning half of the data\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateRemaining, FIRST_EVENT_TIME.plusSeconds(secondsToGenerateFirstRound));\n+      // Resume the supervisor\n+      indexer.resumeSupervisor(generatedTestConfig.getSupervisorId());\n+      // Verify supervisor is healthy after suspension\n+      ITRetryUtil.retryUntil(\n+          () -> SupervisorStateManager.BasicState.RUNNING.equals(indexer.getSupervisorStatus(generatedTestConfig.getSupervisorId())),\n+          true,\n+          10000,\n+          30,\n+          \"Waiting for supervisor to be healthy\"\n+      );\n+      // Verify that supervisor can catch up with the stream\n+      verifyIngestedData(generatedTestConfig);\n+    }\n+    finally {\n+      doMethodTeardown(generatedTestConfig, streamEventWriter);\n+    }\n+  }\n+\n+  protected void doTestIndexDataWithStreamReshardSplit() throws Exception\n+  {\n+    // Reshard the stream from STREAM_SHARD_COUNT to STREAM_SHARD_COUNT * 2\n+    testIndexWithStreamReshardHelper(STREAM_SHARD_COUNT * 2);\n+  }\n+\n+  protected void doTestIndexDataWithStreamReshardMerge() throws Exception\n+  {\n+    // Reshard the stream from STREAM_SHARD_COUNT to STREAM_SHARD_COUNT / 2\n+    testIndexWithStreamReshardHelper(STREAM_SHARD_COUNT / 2);\n+  }\n+\n+  private void testIndexWithLosingNodeHelper(Runnable restartRunnable, Runnable waitForReadyRunnable) throws Exception\n+  {\n+    StreamEventWriter streamEventWriter = getStreamEventWriter();\n+    final GeneratedTestConfig generatedTestConfig = new GeneratedTestConfig();\n+    try (\n+        final Closeable ignored1 = unloader(generatedTestConfig.getFullDatasourceName())\n+    ) {\n+      final String taskSpec = generatedTestConfig.getStreamIngestionPropsTransform().apply(getResourceAsString(INDEXER_FILE_INPUT_FORMAT));\n+      LOG.info(\"supervisorSpec: [%s]\\n\", taskSpec);\n+      // Start supervisor\n+      generatedTestConfig.setSupervisorId(indexer.submitSupervisor(taskSpec));\n+      LOG.info(\"Submitted supervisor\");\n+      // Start generating one third of the data (before restarting)\n+      int secondsToGenerateRemaining = TOTAL_NUMBER_OF_SECOND;\n+      int secondsToGenerateFirstRound = TOTAL_NUMBER_OF_SECOND / 3;\n+      secondsToGenerateRemaining = secondsToGenerateRemaining - secondsToGenerateFirstRound;\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateFirstRound, FIRST_EVENT_TIME);\n+      // Verify supervisor is healthy before restart\n+      ITRetryUtil.retryUntil(\n+          () -> SupervisorStateManager.BasicState.RUNNING.equals(indexer.getSupervisorStatus(generatedTestConfig.getSupervisorId())),\n+          true,\n+          10000,\n+          30,\n+          \"Waiting for supervisor to be healthy\"\n+      );\n+      // Restart Druid process\n+      LOG.info(\"Restarting Druid process\");\n+      restartRunnable.run();\n+      LOG.info(\"Restarted Druid process\");\n+      // Start generating one third of the data (while restarting)\n+      int secondsToGenerateSecondRound = TOTAL_NUMBER_OF_SECOND / 3;\n+      secondsToGenerateRemaining = secondsToGenerateRemaining - secondsToGenerateSecondRound;\n+      wikipediaStreamEventGenerator.start(generatedTestConfig.getStreamName(), streamEventWriter, secondsToGenerateSecondRound, FIRST_EVENT_TIME.plusSeconds(secondsToGenerateFirstRound));\n+      // Wait for Druid process to be available\n+      LOG.info(\"Waiting for Druid process to be available\");\n+      waitForReadyRunnable.run();\n+      LOG.info(\"Druid process is now available\");\n+      // Start generating remainding data (after restarting)", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjczMjg4Mg==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412732882", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-04-22T07:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY4NjYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY4ODQ0MQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412688441", "bodyText": "Can you add javadoc that explains what kind of tests should be done in parallel?", "author": "jihoonson", "createdAt": "2020-04-22T05:50:38Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/parallelized/ITKafkaIndexingServiceNonTransactionalParallelizedTest.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.tests.parallelized;\n+\n+import org.apache.druid.testing.guice.DruidTestModuleFactory;\n+import org.apache.druid.tests.TestNGGroup;\n+import org.apache.druid.tests.indexer.AbstractKafkaIndexingServiceTest;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Guice;\n+import org.testng.annotations.Test;\n+\n+@Test(groups = TestNGGroup.KAFKA_INDEX)\n+@Guice(moduleFactory = DruidTestModuleFactory.class)\n+public class ITKafkaIndexingServiceNonTransactionalParallelizedTest extends AbstractKafkaIndexingServiceTest", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjczMzYyNA==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412733624", "bodyText": "The docs in integration-tests/README.md under \"Running test methods in parallel\" should cover that already. I will add explanation for this particular case why is it parallel vs sequential", "author": "maytasm", "createdAt": "2020-04-22T07:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY4ODQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY4ODU2OQ==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412688569", "bodyText": "Similarly, can you add javadoc that explains what kind of tests should be done in sequential?", "author": "jihoonson", "createdAt": "2020-04-22T05:50:59Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/indexer/ITKinesisIndexingServiceSerializedTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.tests.indexer;\n+\n+import org.apache.druid.testing.guice.DruidTestModuleFactory;\n+import org.apache.druid.tests.TestNGGroup;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Guice;\n+import org.testng.annotations.Test;\n+\n+@Test(groups = TestNGGroup.KINESIS_INDEX)\n+@Guice(moduleFactory = DruidTestModuleFactory.class)\n+public class ITKinesisIndexingServiceSerializedTest extends AbstractKinesisIndexingServiceTest", "originalCommit": "f31dc7ba95a1fc8a5d7df041c9a37368a4fb9b88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjczMzY3Mg==", "url": "https://github.com/apache/druid/pull/9724#discussion_r412733672", "bodyText": "The docs in integration-tests/README.md under \"Running test methods in parallel\" should cover that already. I will add explanation for this particular case why is it parallel vs sequential", "author": "maytasm", "createdAt": "2020-04-22T07:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY4ODU2OQ=="}], "type": "inlineReview"}, {"oid": "47d3f624cd0b171d343eb081df41db51a141250a", "url": "https://github.com/apache/druid/commit/47d3f624cd0b171d343eb081df41db51a141250a", "message": "addressed comments", "committedDate": "2020-04-22T07:26:49Z", "type": "commit"}]}