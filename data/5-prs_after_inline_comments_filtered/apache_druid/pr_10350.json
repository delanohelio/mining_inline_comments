{"pr_number": 10350, "pr_title": "Support SearchQueryDimFilter in sql via new methods", "pr_createdAt": "2020-09-03T20:07:11Z", "pr_url": "https://github.com/apache/druid/pull/10350", "timeline": [{"oid": "6648e67d8c9568d5936f82b495cc24dea5510762", "url": "https://github.com/apache/druid/commit/6648e67d8c9568d5936f82b495cc24dea5510762", "message": "Support SearchQueryDimFilter in sql via new methods", "committedDate": "2020-09-03T19:59:59Z", "type": "commit"}, {"oid": "6e86280ad4b9e006fb58bc54e818cd89f4fe1bae", "url": "https://github.com/apache/druid/commit/6e86280ad4b9e006fb58bc54e818cd89f4fe1bae", "message": "Contains is a reserved word", "committedDate": "2020-09-04T12:49:45Z", "type": "commit"}, {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "url": "https://github.com/apache/druid/commit/176d71272f6629fed5b0924b54c4f78ecef94e3f", "message": "revert unnecessary change", "committedDate": "2020-09-04T12:51:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2NzUzMA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486067530", "bodyText": "nit: javadocs please", "author": "suneet-s", "createdAt": "2020-09-10T05:08:18Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ContainsOperatorConversion.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.filter.DimFilter;\n+import org.apache.druid.query.filter.SearchQueryDimFilter;\n+import org.apache.druid.query.search.ContainsSearchQuerySpec;\n+import org.apache.druid.query.search.SearchQuerySpec;\n+import org.apache.druid.segment.VirtualColumn;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DirectOperatorConversion;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+import org.apache.druid.sql.calcite.rel.VirtualColumnRegistry;\n+\n+import javax.annotation.Nullable;\n+import java.util.List;\n+\n+public class ContainsOperatorConversion extends DirectOperatorConversion", "originalCommit": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMDcwMA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486510700", "bodyText": "Added.", "author": "abhishekagarwal87", "createdAt": "2020-09-10T17:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2NzUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3MDg4OA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486070888", "bodyText": "Can you also add some tests similar to the ones in FunctionTest to test that we can correctly parse the expression similar to testLpad", "author": "suneet-s", "createdAt": "2020-09-10T05:17:46Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/expression/ExpressionsTest.java", "diffHunk": "@@ -1072,6 +1075,108 @@ public void testPad()\n     );\n   }\n \n+  @Test\n+  public void testContains()\n+  {\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        Collections.emptyList(),\n+        new SearchQueryDimFilter(\"spacey\", new ContainsSearchQuerySpec(\"there\", true), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        Collections.emptyList(),\n+        new SearchQueryDimFilter(\"spacey\", new ContainsSearchQuerySpec(\"There\", true), null),\n+        false\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(false).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        Collections.emptyList(),\n+        new SearchQueryDimFilter(\"spacey\", new ContainsSearchQuerySpec(\"There\", false), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"what\")\n+        ),\n+        ImmutableList.of(\n+            new ExpressionVirtualColumn(\n+                \"v0\",\n+                \"concat('what is',\\\"spacey\\\")\",\n+                ValueType.STRING,\n+                TestExprMacroTable.INSTANCE\n+            )\n+        ),\n+        new SearchQueryDimFilter(\"v0\", new ContainsSearchQuerySpec(\"what\", true), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        ImmutableList.of(\n+            new ExpressionVirtualColumn(\n+                \"v0\",\n+                \"concat('what is',\\\"spacey\\\")\",\n+                ValueType.STRING,\n+                TestExprMacroTable.INSTANCE\n+            )\n+        ),\n+        new SearchQueryDimFilter(\"v0\", new ContainsSearchQuerySpec(\"there\", true), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(false).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"What\")\n+        ),\n+        ImmutableList.of(\n+            new ExpressionVirtualColumn(\n+                \"v0\",\n+                \"concat('what is',\\\"spacey\\\")\",\n+                ValueType.STRING,\n+                TestExprMacroTable.INSTANCE\n+            )\n+        ),\n+        new SearchQueryDimFilter(\"v0\", new ContainsSearchQuerySpec(\"What\", false), null),\n+        true\n+    );\n+  }", "originalCommit": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5Nzg5Nw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486197897", "bodyText": "I have not added native functions for these methods. Yet. similar discussion - https://github.com/apache/druid/pull/10350/files#r486068975", "author": "abhishekagarwal87", "createdAt": "2020-09-10T09:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3MDg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2ODk3NQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486068975", "bodyText": "I don't see native functions named \"contains_str\" and \"icontains_str\", do they exist? (DirectOperatorConversion assumes there is a native function with the functionName you pass in here.)", "author": "gianm", "createdAt": "2020-09-10T05:10:48Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ContainsOperatorConversion.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.filter.DimFilter;\n+import org.apache.druid.query.filter.SearchQueryDimFilter;\n+import org.apache.druid.query.search.ContainsSearchQuerySpec;\n+import org.apache.druid.query.search.SearchQuerySpec;\n+import org.apache.druid.segment.VirtualColumn;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DirectOperatorConversion;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+import org.apache.druid.sql.calcite.rel.VirtualColumnRegistry;\n+\n+import javax.annotation.Nullable;\n+import java.util.List;\n+\n+public class ContainsOperatorConversion extends DirectOperatorConversion\n+{\n+  private static final String CASE_SENSITIVE_FN_NAME = \"contains_str\";\n+  private static final String CASE_INSENSITIVE_FN_NAME = \"icontains_str\";\n+  private final boolean caseSensitive;\n+\n+  public ContainsOperatorConversion(\n+      final SqlFunction sqlFunction,\n+      final String functionName,\n+      final boolean caseSensitive\n+  )\n+  {\n+    super(sqlFunction, functionName);", "originalCommit": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExNzQ1Nw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486117457", "bodyText": "They don't exist. I am going to fix this by returning null in toDruidExpression method. do you think it will be useful to add corresponding native functions as well that can be used outside leaf filters?", "author": "abhishekagarwal87", "createdAt": "2020-09-10T07:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2ODk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE5MzE2NA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486193164", "bodyText": "Yes, because we should let people use this function in any context, not just as a leaf filter, and we'll need a native expression in order to do that. Imagine a query like:\nSELECT CASE WHEN CONTAINS_STR(domain, '.com') THEN 'dot-com' ELSE 'other' END\nFROM tbl\n\nThat would need to get translated using a virtual column + a native expression.", "author": "gianm", "createdAt": "2020-09-10T09:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2ODk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI1MTUzNw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486251537", "bodyText": "makes sense.", "author": "abhishekagarwal87", "createdAt": "2020-09-10T11:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2ODk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzODAzNw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486438037", "bodyText": "This would be a nice comment to add on DirectOperatorConversion. I always get confused about which one to add to.", "author": "suneet-s", "createdAt": "2020-09-10T15:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2ODk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2OTE3NQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486069175", "bodyText": "Might be more readable to give these methods nice names, like caseInsensitive() and caseSensitive(). Small nit though.", "author": "gianm", "createdAt": "2020-09-10T05:11:32Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/planner/DruidOperatorTable.java", "diffHunk": "@@ -181,6 +182,8 @@\n           .add(new AliasedOperatorConversion(new TruncateOperatorConversion(), \"TRUNC\"))\n           .add(new LPadOperatorConversion())\n           .add(new RPadOperatorConversion())\n+          .add(ContainsOperatorConversion.createOperatorConversion(true))\n+          .add(ContainsOperatorConversion.createOperatorConversion(false))", "originalCommit": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExNTU0MA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486115540", "bodyText": "Ack. Those indeed sound better.", "author": "abhishekagarwal87", "createdAt": "2020-09-10T07:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2OTE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2OTYwNw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486069607", "bodyText": "You should include tests here using testHelper.testExpression too. It'll test that toDruidExpression works properly, which will be used if someone uses this operator outside of a leaf filter.", "author": "gianm", "createdAt": "2020-09-10T05:13:10Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/expression/ExpressionsTest.java", "diffHunk": "@@ -1072,6 +1075,108 @@ public void testPad()\n     );\n   }\n \n+  @Test\n+  public void testContains()\n+  {", "originalCommit": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI1MTc3OQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486251779", "bodyText": "will add those as I add corresponding native functions.", "author": "abhishekagarwal87", "createdAt": "2020-09-10T11:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2OTYwNw=="}], "type": "inlineReview"}, {"oid": "d5a841a4a04a301daf8a839b15a03926e570d5da", "url": "https://github.com/apache/druid/commit/d5a841a4a04a301daf8a839b15a03926e570d5da", "message": "Fix toDruidExpression method", "committedDate": "2020-09-10T09:30:16Z", "type": "commit"}, {"oid": "b7d3cef69b128a5dde2b83cbfe502c671ddda06f", "url": "https://github.com/apache/druid/commit/b7d3cef69b128a5dde2b83cbfe502c671ddda06f", "message": "rename methods", "committedDate": "2020-09-10T11:04:32Z", "type": "commit"}, {"oid": "bbfe4cbfb39747c0c60960fae452c4cd6be354a6", "url": "https://github.com/apache/druid/commit/bbfe4cbfb39747c0c60960fae452c4cd6be354a6", "message": "java docs", "committedDate": "2020-09-10T11:20:33Z", "type": "commit"}, {"oid": "7e7125d36acde6c70ef1e7b4a86b805e5199d7e3", "url": "https://github.com/apache/druid/commit/7e7125d36acde6c70ef1e7b4a86b805e5199d7e3", "message": "Add native functions", "committedDate": "2020-09-10T17:08:38Z", "type": "commit"}, {"oid": "38306ecc759b2c35cb1aa515f787ac14ce738613", "url": "https://github.com/apache/druid/commit/38306ecc759b2c35cb1aa515f787ac14ce738613", "message": "revert change in dockerfile", "committedDate": "2020-09-10T17:16:36Z", "type": "commit"}, {"oid": "549971029d0f2659b9a4734711ea8147ede726c5", "url": "https://github.com/apache/druid/commit/549971029d0f2659b9a4734711ea8147ede726c5", "message": "remove changes from dockerfile", "committedDate": "2020-09-10T17:19:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTI2Mw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486709263", "bodyText": "Since ContainsExpr always expects this to be a literal value, should this class just accept a String instead?", "author": "suneet-s", "createdAt": "2020-09-11T00:45:05Z", "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExpr.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.math.expr.ExprType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.function.Function;\n+\n+/**\n+ * {@link Expr} class returned by {@link ContainsExprMacro} and {@link CaseInsensitiveContainsExprMacro} for\n+ * evaluating the expression.\n+ */\n+class ContainsExpr extends ExprMacroTable.BaseScalarUnivariateMacroFunctionExpr\n+{\n+  private final Function<String, Boolean> searchFunction;\n+  private final Expr searchStrExpr;", "originalCommit": "549971029d0f2659b9a4734711ea8147ede726c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkyOTg3Mw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486929873", "bodyText": "searchStrExpr is required in stringify method.", "author": "abhishekagarwal87", "createdAt": "2020-09-11T09:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxOTQ2Ng==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487319466", "bodyText": "I think that makes sense. I tried to walk through the possible values of expr.stringify() given the fact that it is guaranteed to be a string literal, but it was a little tricky for me to reason about, so keeping it an Expr is cool", "author": "suneet-s", "createdAt": "2020-09-11T22:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTc2OA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486709768", "bodyText": "Thanks for the awesome javadocs \ud83e\udd18", "author": "suneet-s", "createdAt": "2020-09-11T00:47:11Z", "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExprMacro.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+\n+import java.util.List;\n+\n+/**\n+ * This class implements a function that checks if one string contains another string. It is required that second\n+ * string be a literal. This expression is case-sensitive.\n+ * signature:\n+ * long contains_string(string, string)\n+ * <p>\n+ * Examples:\n+ * - {@code contains_string(\"foobar\", \"bar\") - 1 }\n+ * - {@code contains_string(\"foobar\", \"car\") - 0 }\n+ * - {@code contains_string(\"foobar\", \"Bar\") - 0 }\n+ * <p>\n+ * See {@link CaseInsensitiveContainsExprMacro} for the case-insensitive version.\n+ */", "originalCommit": "549971029d0f2659b9a4734711ea8147ede726c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMDMyNg==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486710326", "bodyText": "super nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public ContainsOperatorConversion(\n          \n          \n            \n              private ContainsOperatorConversion(", "author": "suneet-s", "createdAt": "2020-09-11T00:49:15Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ContainsOperatorConversion.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.expression.CaseInsensitiveContainsExprMacro;\n+import org.apache.druid.query.expression.ContainsExprMacro;\n+import org.apache.druid.query.filter.DimFilter;\n+import org.apache.druid.query.filter.SearchQueryDimFilter;\n+import org.apache.druid.query.search.ContainsSearchQuerySpec;\n+import org.apache.druid.query.search.SearchQuerySpec;\n+import org.apache.druid.segment.VirtualColumn;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+import org.apache.druid.sql.calcite.rel.VirtualColumnRegistry;\n+\n+import javax.annotation.Nullable;\n+import java.util.List;\n+\n+/**\n+ * Register {@code contains_string} and {@code icontains_string} functions with calcite that internally\n+ * translate these functions into {@link SearchQueryDimFilter} with {@link ContainsSearchQuerySpec} as\n+ * search query spec.\n+ */\n+public class ContainsOperatorConversion implements SqlOperatorConversion\n+{\n+  private final SqlOperator operator;\n+  private final boolean caseSensitive;\n+\n+  public ContainsOperatorConversion(", "originalCommit": "549971029d0f2659b9a4734711ea8147ede726c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMjYyMA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r486712620", "bodyText": "Can you add some tests for how the function deals with nulls and empty strings - these tend to surface some issues because we need to support 2 modes - default mode and sql compatible mode, and sometimes the behavior of these functions may be slightly different than we expect. I remember finding issues when I changed the behavior of lpad / rpad functions - https://github.com/apache/druid/pull/10006/files#diff-fd48c48432e4977332aa9806d2d308faR150-R151", "author": "suneet-s", "createdAt": "2020-09-11T00:57:40Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/expression/ExpressionsTest.java", "diffHunk": "@@ -1072,6 +1075,221 @@ public void testPad()\n     );\n   }\n \n+  @Test\n+  public void testContains()\n+  {\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(\\\"spacey\\\",'there')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(\\\"spacey\\\",'There')\"),\n+        0L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseInsensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        DruidExpression.fromExpression(\"icontains_string(\\\"spacey\\\",'There')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"what\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(concat('what is',\\\"spacey\\\"),'what')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(concat('what is',\\\"spacey\\\"),'there')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseInsensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        DruidExpression.fromExpression(\"icontains_string(concat('what is',\\\"spacey\\\"),'There')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        SqlStdOperatorTable.AND,\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+                testHelper.makeInputRef(\"spacey\"),\n+                testHelper.makeLiteral(\"there\")\n+            ),\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.EQUALS,\n+                testHelper.makeLiteral(\"yes\"),\n+                testHelper.makeLiteral(\"yes\")\n+            )\n+        ),\n+        DruidExpression.fromExpression(\"(contains_string(\\\"spacey\\\",'there') && ('yes' == 'yes'))\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        SqlStdOperatorTable.AND,\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                ContainsOperatorConversion.caseInsensitive().calciteOperator(),\n+                testHelper.makeInputRef(\"spacey\"),\n+                testHelper.makeLiteral(\"There\")\n+            ),\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.EQUALS,\n+                testHelper.makeLiteral(\"yes\"),\n+                testHelper.makeLiteral(\"yes\")\n+            )\n+        ),\n+        DruidExpression.fromExpression(\"(icontains_string(\\\"spacey\\\",'There') && ('yes' == 'yes'))\"),", "originalCommit": "549971029d0f2659b9a4734711ea8147ede726c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2NTIwMg==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487065202", "bodyText": "Added two tests for the same. Learnt a few things along the way. I was not at all expecting an empty string to be turned to null. Do you know why that is done?", "author": "abhishekagarwal87", "createdAt": "2020-09-11T14:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3MzQxMg==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487073412", "bodyText": "https://druid.apache.org/docs/latest/querying/sql.html#null-values\nThis is because initially there was no null and druid was not sql compatible so nulls were treated as empty strings or 0s. This was done at ingestion time as well, so once the data was ingested, we can't distinguish between a null and a 0.", "author": "suneet-s", "createdAt": "2020-09-11T14:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3Nzg5Ng==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487077896", "bodyText": "hmm. what do you think should be the output of following in the default mode assuming myColumn has empty value?\nCONTAINS(\"myColumn\", '')", "author": "abhishekagarwal87", "createdAt": "2020-09-11T14:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyOTg4Ng==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487129886", "bodyText": "I was not handling the null values similar to other expressions. It should work now. code coverage bot was complaining as tests were added in sql module and these Expr* classes are in the processing module. After I added the tests in the processing module, I realized what the problem was.  When an empty string is passed, the functions get a null value that they again convert to an empty value.", "author": "abhishekagarwal87", "createdAt": "2020-09-11T15:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMjYyMA=="}], "type": "inlineReview"}, {"oid": "1f408a72d73e5dd8fd60e03269eecae0e68f2c71", "url": "https://github.com/apache/druid/commit/1f408a72d73e5dd8fd60e03269eecae0e68f2c71", "message": "More tests", "committedDate": "2020-09-11T11:34:58Z", "type": "commit"}, {"oid": "cfd26bdaaf9e9768e734d1e460b38e57bd44921d", "url": "https://github.com/apache/druid/commit/cfd26bdaaf9e9768e734d1e460b38e57bd44921d", "message": "travis fix", "committedDate": "2020-09-11T13:50:35Z", "type": "commit"}, {"oid": "a8ae16920d494aaafc1d6f454a644fbd096fc044", "url": "https://github.com/apache/druid/commit/a8ae16920d494aaafc1d6f454a644fbd096fc044", "message": "Handle null values better", "committedDate": "2020-09-11T15:31:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyMjY4OA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487322688", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // same behavior as regexp_like.\n          \n          \n            \n                  // same behavior as ContainsSearchQuerySpec#accept\n          \n      \n    \n    \n  \n\nLuckily the behavior is the same as regexp_like\n    if (dimVal == null || value == null) {\n      return false;\n    }", "author": "suneet-s", "createdAt": "2020-09-11T22:48:10Z", "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExpr.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.math.expr.ExprType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.function.Function;\n+\n+/**\n+ * {@link Expr} class returned by {@link ContainsExprMacro} and {@link CaseInsensitiveContainsExprMacro} for\n+ * evaluating the expression.\n+ */\n+class ContainsExpr extends ExprMacroTable.BaseScalarUnivariateMacroFunctionExpr\n+{\n+  private final Function<String, Boolean> searchFunction;\n+  private final Expr searchStrExpr;\n+\n+  ContainsExpr(String functioName, Expr arg, Expr searchStrExpr, boolean caseSensitive)\n+  {\n+    super(functioName, arg);\n+    this.searchStrExpr = validateSearchExpr(searchStrExpr, functioName);\n+    // Creates the function eagerly to avoid branching in eval.\n+    this.searchFunction = createFunction(searchStrExpr, caseSensitive);\n+  }\n+\n+  private ContainsExpr(String functioName, Expr arg, Expr searchStrExpr, Function<String, Boolean> searchFunction)\n+  {\n+    super(functioName, arg);\n+    this.searchFunction = searchFunction;\n+    this.searchStrExpr = validateSearchExpr(searchStrExpr, functioName);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public ExprEval eval(final Expr.ObjectBinding bindings)\n+  {\n+    final String s = NullHandling.nullToEmptyIfNeeded(arg.eval(bindings).asString());\n+\n+    if (s == null) {\n+      // same behavior as regexp_like.", "originalCommit": "a8ae16920d494aaafc1d6f454a644fbd096fc044", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyMzYzMA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487323630", "bodyText": "nit: It would be good to link to the DimFilter whose behavior we are trying to mimic here ContainsSearchQuerySpec\nsince we want the logic between these 2 classes to stay the same. I wonder if we can future proof this so they stay in sync if someone makes an update to ContainsSearchQuerySpec", "author": "suneet-s", "createdAt": "2020-09-11T22:52:01Z", "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExpr.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.math.expr.ExprType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.function.Function;\n+\n+/**\n+ * {@link Expr} class returned by {@link ContainsExprMacro} and {@link CaseInsensitiveContainsExprMacro} for\n+ * evaluating the expression.\n+ */", "originalCommit": "a8ae16920d494aaafc1d6f454a644fbd096fc044", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyOTUzMQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487329531", "bodyText": "According to ContainsSearchQuerySpec#accept searching for anything on null should be false\n    if (dimVal == null || value == null) {\n      return false;\n    }", "author": "suneet-s", "createdAt": "2020-09-11T23:18:14Z", "path": "processing/src/test/java/org/apache/druid/query/expression/ContainsExprMacroTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprType;\n+import org.apache.druid.math.expr.Parser;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class ContainsExprMacroTest extends MacroTestBase\n+{\n+  public ContainsExprMacroTest()\n+  {\n+    super(new ContainsExprMacro());\n+  }\n+\n+  @Test\n+  public void testErrorZeroArguments()\n+  {\n+    expectException(IllegalArgumentException.class, \"Function[contains_string] must have 2 arguments\");\n+    eval(\"contains_string()\", Parser.withMap(ImmutableMap.of()));\n+  }\n+\n+  @Test\n+  public void testErrorThreeArguments()\n+  {\n+    expectException(IllegalArgumentException.class, \"Function[contains_string] must have 2 arguments\");\n+    eval(\"contains_string('a', 'b', 'c')\", Parser.withMap(ImmutableMap.of()));\n+  }\n+\n+  @Test\n+  public void testMatch()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, 'oba')\", Parser.withMap(ImmutableMap.of(\"a\", \"foobar\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNoMatch()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, 'bar')\", Parser.withMap(ImmutableMap.of(\"a\", \"foo\")));\n+    Assert.assertEquals(\n+        ExprEval.of(false, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNullSearch()\n+  {\n+    if (NullHandling.sqlCompatible()) {\n+      expectException(IllegalArgumentException.class, \"Function[contains_string] substring must be a string literal\");\n+    }\n+\n+    final ExprEval<?> result = eval(\"contains_string(a, null)\", Parser.withMap(ImmutableMap.of(\"a\", \"foo\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testEmptyStringSearch()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, '')\", Parser.withMap(ImmutableMap.of(\"a\", \"foo\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNullSearchOnEmptyString()\n+  {\n+    if (NullHandling.sqlCompatible()) {\n+      expectException(IllegalArgumentException.class, \"Function[contains_string] substring must be a string literal\");\n+    }\n+\n+    final ExprEval<?> result = eval(\"contains_string(a, null)\", Parser.withMap(ImmutableMap.of(\"a\", \"\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testEmptyStringSearchOnEmptyString()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, '')\", Parser.withMap(ImmutableMap.of(\"a\", \"\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNullSearchOnNull()\n+  {\n+    if (NullHandling.sqlCompatible()) {\n+      expectException(IllegalArgumentException.class, \"Function[contains_string] substring must be a string literal\");\n+    }\n+\n+    final ExprEval<?> result = eval(\"contains_string(a, null)\", Parser.withSuppliers(ImmutableMap.of(\"a\", () -> null)));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),", "originalCommit": "a8ae16920d494aaafc1d6f454a644fbd096fc044", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM3MTI3Mw==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487371273", "bodyText": "In non-sql compatible mode, both of these will be empty instead of null and hence the function would return true.\nIn SQL compatible mode, we would see an exception since null is not a valid literal.", "author": "abhishekagarwal87", "createdAt": "2020-09-12T05:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyOTUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM3MTY2OA==", "url": "https://github.com/apache/druid/pull/10350#discussion_r487371668", "bodyText": "though I am still evaluating if the SQL operator behaves differently in non-sql compatible mode. That is, If null is not translated into empty string in the SQL operator, we may see a behaviour mismatch.", "author": "abhishekagarwal87", "createdAt": "2020-09-12T05:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyOTUzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA4NTYyNQ==", "url": "https://github.com/apache/druid/pull/10350#discussion_r488085625", "bodyText": "In non-sql compatible mode, both of these will be empty instead of null and hence the function would return true.\nIn SQL compatible mode, we would see an exception since null is not a valid literal.\n\nThanks for the explanation", "author": "suneet-s", "createdAt": "2020-09-14T16:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyOTUzMQ=="}], "type": "inlineReview"}]}