{"pr_number": 9317, "pr_title": "ANY Aggregator should not skip null values implementation", "pr_createdAt": "2020-02-05T23:24:23Z", "pr_url": "https://github.com/apache/druid/pull/9317", "timeline": [{"oid": "59488e0ce6b38770673ea786d39e70d8ed9ce63b", "url": "https://github.com/apache/druid/commit/59488e0ce6b38770673ea786d39e70d8ed9ce63b", "message": "ANY Aggregator should not skip null values implementation", "committedDate": "2020-02-05T23:24:00Z", "type": "commit"}, {"oid": "4344b4a6020f7f0c9e5416a32e6cb31ee8d5feb4", "url": "https://github.com/apache/druid/commit/4344b4a6020f7f0c9e5416a32e6cb31ee8d5feb4", "message": "add tests", "committedDate": "2020-02-06T21:23:13Z", "type": "commit"}, {"oid": "68ac8de271d290f798b073e699a9d08aea1dee1b", "url": "https://github.com/apache/druid/commit/68ac8de271d290f798b073e699a9d08aea1dee1b", "message": "add more tests", "committedDate": "2020-02-07T00:35:30Z", "type": "commit"}, {"oid": "e68e9ee9b3ee94ba3ff746c0c2c8d994b49110c4", "url": "https://github.com/apache/druid/commit/e68e9ee9b3ee94ba3ff746c0c2c8d994b49110c4", "message": "Update documentation", "committedDate": "2020-02-07T00:51:19Z", "type": "commit"}, {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73", "url": "https://github.com/apache/druid/commit/e224eedf9ab1b385447d677b38d39c5f58eafe73", "message": "add more tests", "committedDate": "2020-02-07T01:38:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0OTEzNQ==", "url": "https://github.com/apache/druid/pull/9317#discussion_r376649135", "bodyText": "I think from like a .. user satisfaction perspective, it might still be nice to prefer non-null values since it is still legitimate.", "author": "clintropolis", "createdAt": "2020-02-07T23:06:56Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -19,103 +19,214 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import com.fasterxml.jackson.annotation.JacksonInject;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import org.apache.druid.math.expr.ExprMacroTable;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.UOE;\n+import org.apache.druid.query.aggregation.AggregateCombiner;\n import org.apache.druid.query.aggregation.Aggregator;\n import org.apache.druid.query.aggregation.AggregatorFactory;\n import org.apache.druid.query.aggregation.AggregatorUtil;\n import org.apache.druid.query.aggregation.BufferAggregator;\n-import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.query.aggregation.DoubleSumAggregator;\n import org.apache.druid.query.cache.CacheKeyBuilder;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.NilColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n \n import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n+import java.util.Objects;\n \n-public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+public class DoubleAnyAggregatorFactory extends AggregatorFactory\n {\n+  private static final Comparator<Double> VALUE_COMPARATOR = Comparator.nullsFirst(Double::compare);\n+\n+  private static final Aggregator NIL_AGGREGATOR = new DoubleAnyAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate()\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private static final BufferAggregator NIL_BUFFER_AGGREGATOR = new DoubleAnyBufferAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate(ByteBuffer buf, int position)\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n   @JsonCreator\n   public DoubleAnyAggregatorFactory(\n       @JsonProperty(\"name\") String name,\n-      @JsonProperty(\"fieldName\") final String fieldName,\n-      @JsonProperty(\"expression\") @Nullable String expression,\n-      @JacksonInject ExprMacroTable macroTable\n+      @JsonProperty(\"fieldName\") final String fieldName\n   )\n   {\n-    super(macroTable, name, fieldName, expression);\n-  }\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n \n-  public DoubleAnyAggregatorFactory(String name, String fieldName)\n-  {\n-    this(name, fieldName, null, ExprMacroTable.nil());\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n   }\n \n   @Override\n-  protected double nullValue()\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n   {\n-    return Double.NaN;\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n   {\n-    return new DoubleAnyAggregator(selector);\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_BUFFER_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyBufferAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  public Comparator getComparator()\n   {\n-    return new DoubleAnyBufferAggregator(selector);\n+    return VALUE_COMPARATOR;\n   }\n \n   @Override\n   @Nullable\n   public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n   {\n-    if (lhs != null) {\n-      return lhs;\n-    } else {\n-      return rhs;\n-    }\n+    return lhs;", "originalCommit": "e224eedf9ab1b385447d677b38d39c5f58eafe73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3NzYwNA==", "url": "https://github.com/apache/druid/pull/9317#discussion_r377977604", "bodyText": "to be consistent with the new policy of not discriminating null values #equality\nDecided not to make assumption in preferring non-null value.", "author": "maytasm", "createdAt": "2020-02-12T00:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0OTEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1MzI0MA==", "url": "https://github.com/apache/druid/pull/9317#discussion_r376653240", "bodyText": "this comment seems not applicable since it is a primitive", "author": "clintropolis", "createdAt": "2020-02-07T23:23:18Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -19,103 +19,214 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import com.fasterxml.jackson.annotation.JacksonInject;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import org.apache.druid.math.expr.ExprMacroTable;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.UOE;\n+import org.apache.druid.query.aggregation.AggregateCombiner;\n import org.apache.druid.query.aggregation.Aggregator;\n import org.apache.druid.query.aggregation.AggregatorFactory;\n import org.apache.druid.query.aggregation.AggregatorUtil;\n import org.apache.druid.query.aggregation.BufferAggregator;\n-import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.query.aggregation.DoubleSumAggregator;\n import org.apache.druid.query.cache.CacheKeyBuilder;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.NilColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n \n import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n+import java.util.Objects;\n \n-public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+public class DoubleAnyAggregatorFactory extends AggregatorFactory\n {\n+  private static final Comparator<Double> VALUE_COMPARATOR = Comparator.nullsFirst(Double::compare);\n+\n+  private static final Aggregator NIL_AGGREGATOR = new DoubleAnyAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate()\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private static final BufferAggregator NIL_BUFFER_AGGREGATOR = new DoubleAnyBufferAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate(ByteBuffer buf, int position)\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n   @JsonCreator\n   public DoubleAnyAggregatorFactory(\n       @JsonProperty(\"name\") String name,\n-      @JsonProperty(\"fieldName\") final String fieldName,\n-      @JsonProperty(\"expression\") @Nullable String expression,\n-      @JacksonInject ExprMacroTable macroTable\n+      @JsonProperty(\"fieldName\") final String fieldName\n   )\n   {\n-    super(macroTable, name, fieldName, expression);\n-  }\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n \n-  public DoubleAnyAggregatorFactory(String name, String fieldName)\n-  {\n-    this(name, fieldName, null, ExprMacroTable.nil());\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n   }\n \n   @Override\n-  protected double nullValue()\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n   {\n-    return Double.NaN;\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n   {\n-    return new DoubleAnyAggregator(selector);\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_BUFFER_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyBufferAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  public Comparator getComparator()\n   {\n-    return new DoubleAnyBufferAggregator(selector);\n+    return VALUE_COMPARATOR;\n   }\n \n   @Override\n   @Nullable\n   public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n   {\n-    if (lhs != null) {\n-      return lhs;\n-    } else {\n-      return rhs;\n-    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregateCombiner makeAggregateCombiner()\n+  {\n+    throw new UOE(\"DoubleAnyAggregatorFactory is not supported during ingestion for rollup\");\n   }\n \n   @Override\n   public AggregatorFactory getCombiningFactory()\n   {\n-    return new DoubleAnyAggregatorFactory(name, name, null, macroTable);\n+    return new DoubleAnyAggregatorFactory(name, name);\n   }\n \n   @Override\n   public List<AggregatorFactory> getRequiredColumns()\n   {\n-    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName, expression, macroTable));\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    // handle \"NaN\" / \"Infinity\" values serialized as strings in JSON\n+    if (object instanceof String) {\n+      return Double.parseDouble((String) object);\n+    }\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Collections.singletonList(fieldName);\n   }\n \n   @Override\n   public byte[] getCacheKey()\n   {\n     return new CacheKeyBuilder(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n         .appendString(fieldName)\n-        .appendString(expression)\n         .build();\n   }\n \n+  @Override\n+  public String getTypeName()\n+  {\n+    // if we don't pretend to be a primitive, group by v1 gets sad and doesn't work because no complex type serde", "originalCommit": "e224eedf9ab1b385447d677b38d39c5f58eafe73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5NjgyNg==", "url": "https://github.com/apache/druid/pull/9317#discussion_r377996826", "bodyText": "removed.", "author": "maytasm", "createdAt": "2020-02-12T01:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1MzI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMTQ5Mg==", "url": "https://github.com/apache/druid/pull/9317#discussion_r377931492", "bodyText": "I'm not sure this is really worth mentioning. This is the standard case for aggregator implementations, since it is less common for an agg implementation to have magic null handling wrapped around it than just handling the nulls itself.", "author": "clintropolis", "createdAt": "2020-02-11T22:13:55Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -19,44 +19,35 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import org.apache.druid.query.aggregation.Aggregator;\n-import org.apache.druid.query.aggregation.NullableNumericAggregator;\n-import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n- * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n- * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n- * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which has no special null handling logic.", "originalCommit": "e224eedf9ab1b385447d677b38d39c5f58eafe73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5NzI4Mg==", "url": "https://github.com/apache/druid/pull/9317#discussion_r377997282", "bodyText": "Removed", "author": "maytasm", "createdAt": "2020-02-12T01:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMTQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDA3NQ==", "url": "https://github.com/apache/druid/pull/9317#discussion_r377934075", "bodyText": "nit: I think this 0 offset variable makes the put and get operations more complicated than they need to be, suggest just dropping this and not adding or removing anything.", "author": "clintropolis", "createdAt": "2020-02-11T22:19:55Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;", "originalCommit": "e224eedf9ab1b385447d677b38d39c5f58eafe73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0NDAwNw==", "url": "https://github.com/apache/druid/pull/9317#discussion_r377944007", "bodyText": "Further, since is null is only going to be either 0 or 1, you save a byte per agg result and could use any of the high bits of this null byte to set whether or not you have found a value. Instead of an offset for null flag, you define a bit mask and your found check becomes something like buf.get(position) & FOUND_MASK == FOUND_MASK or whatever.", "author": "clintropolis", "createdAt": "2020-02-11T22:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwMjgyNg==", "url": "https://github.com/apache/druid/pull/9317#discussion_r378002826", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-02-12T01:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNTA0MA==", "url": "https://github.com/apache/druid/pull/9317#discussion_r377935040", "bodyText": "Please use NullHandling.IS_NULL_BYTE and NullHandling.IS_NOT_NULL_BYTE to be consistent with other aggregators, at least for the 'is null' byte.", "author": "clintropolis", "createdAt": "2020-02-11T22:22:00Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;", "originalCommit": "e224eedf9ab1b385447d677b38d39c5f58eafe73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwMjg2Mg==", "url": "https://github.com/apache/druid/pull/9317#discussion_r378002862", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-02-12T01:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNTA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODIyMA==", "url": "https://github.com/apache/druid/pull/9317#discussion_r377938220", "bodyText": "nit: suggest just making this package private and having subclasses use this directly in their putValue implementations instead of getFoundValueStoredPosition function call, and maybe just calling it VALUE_OFFSET or FOUND_VALUE_OFFSET since the position seems redundant.", "author": "clintropolis", "createdAt": "2020-02-11T22:29:20Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;\n+  private static final int IS_NULL_FLAG_OFFSET_POSITION = IS_FOUND_FLAG_OFFSET_POSITION + Byte.BYTES;\n+  private static final int FOUND_VALUE_OFFSET_POSITION = IS_NULL_FLAG_OFFSET_POSITION + Byte.BYTES;", "originalCommit": "e224eedf9ab1b385447d677b38d39c5f58eafe73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwMzAwNw==", "url": "https://github.com/apache/druid/pull/9317#discussion_r378003007", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-02-12T01:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MjExNQ==", "url": "https://github.com/apache/druid/pull/9317#discussion_r377942115", "bodyText": "Why this change? I don't think it is correct, since this stuff should only be set if it was a QueryInterruptedException", "author": "clintropolis", "createdAt": "2020-02-11T22:38:31Z", "path": "server/src/main/java/org/apache/druid/server/QueryLifecycle.java", "diffHunk": "@@ -318,14 +318,12 @@ public void emitLogsAndMetrics(\n \n       if (e != null) {\n         statsMap.put(\"exception\", e.toString());\n-\n-        if (e instanceof QueryInterruptedException) {\n-          // Mimic behavior from QueryResource, where this code was originally taken from.\n-          log.noStackTrace().warn(e, \"Exception while processing queryId [%s]\", baseQuery.getId());\n-          statsMap.put(\"interrupted\", true);\n-          statsMap.put(\"reason\", e.toString());\n-        }\n+        // Mimic behavior from QueryResource, where this code was originally taken from.", "originalCommit": "e224eedf9ab1b385447d677b38d39c5f58eafe73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwNDk5OQ==", "url": "https://github.com/apache/druid/pull/9317#discussion_r378004999", "bodyText": "Changed to just moving the logging out of the if check", "author": "maytasm", "createdAt": "2020-02-12T02:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MjExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwNTEwMg==", "url": "https://github.com/apache/druid/pull/9317#discussion_r378005102", "bodyText": "The change is so that we can see the exception (and possibly stacktrace) for exceptions other than QueryInterruptedException too", "author": "maytasm", "createdAt": "2020-02-12T02:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MjExNQ=="}], "type": "inlineReview"}, {"oid": "511d33da8e22482073ae49ca1d965548f110b391", "url": "https://github.com/apache/druid/commit/511d33da8e22482073ae49ca1d965548f110b391", "message": "Merge remote-tracking branch 'upstream/master' into IMPLY-1889", "committedDate": "2020-02-11T23:27:38Z", "type": "commit"}, {"oid": "094425a6605b2646c1ac87d03130009ddac05cec", "url": "https://github.com/apache/druid/commit/094425a6605b2646c1ac87d03130009ddac05cec", "message": "address review comments", "committedDate": "2020-02-12T02:08:32Z", "type": "commit"}, {"oid": "00eb20ed80c3041d688818468cd0c15d3ba91663", "url": "https://github.com/apache/druid/commit/00eb20ed80c3041d688818468cd0c15d3ba91663", "message": "optimize StringAnyBufferAggregator", "committedDate": "2020-02-12T02:21:16Z", "type": "commit"}, {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6", "url": "https://github.com/apache/druid/commit/b9ef751385492faca5d57fbf05d0c7a71a1ff7e6", "message": "fix failing tests", "committedDate": "2020-02-12T08:14:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MjkzOQ==", "url": "https://github.com/apache/druid/pull/9317#discussion_r378152939", "bodyText": "super super nit, but can you use hex? (0x02 and 0x01 for BYTE_FLAG_NULL_MASK)", "author": "clintropolis", "createdAt": "2020-02-12T10:09:57Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -32,11 +32,11 @@\n public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n     implements BufferAggregator\n {\n-  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n-  private static final byte BYTE_FLAG_IS_SET = 1;\n-  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;\n-  private static final int IS_NULL_FLAG_OFFSET_POSITION = IS_FOUND_FLAG_OFFSET_POSITION + Byte.BYTES;\n-  private static final int FOUND_VALUE_OFFSET_POSITION = IS_NULL_FLAG_OFFSET_POSITION + Byte.BYTES;\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  private static final byte BYTE_FLAG_FOUND_MASK = 0b0010;", "originalCommit": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyODM5OA==", "url": "https://github.com/apache/druid/pull/9317#discussion_r378428398", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-02-12T18:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MjkzOQ=="}], "type": "inlineReview"}, {"oid": "c3e645c75948c58a48767fd3e3904d784c1c7222", "url": "https://github.com/apache/druid/commit/c3e645c75948c58a48767fd3e3904d784c1c7222", "message": "address pr comments", "committedDate": "2020-02-12T18:20:10Z", "type": "commit"}]}