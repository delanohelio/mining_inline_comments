{"pr_number": 9287, "pr_title": "Add getRightEquiConditionKeys to JoinConditionAnalysis", "pr_createdAt": "2020-01-29T19:02:29Z", "pr_url": "https://github.com/apache/druid/pull/9287", "timeline": [{"oid": "7f98720bf182a34d05cbdc781bf184e4b5345270", "url": "https://github.com/apache/druid/commit/7f98720bf182a34d05cbdc781bf184e4b5345270", "message": "Add getRightColumns to JoinConditionAnalysis\n\nThis change other implementations of JoinableFactory to ask the analysis\nfor the right key columns instead of having to calculate it themselves.", "committedDate": "2020-01-29T18:59:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5Nzg3MA==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372597870", "bodyText": "I'm not sure if it's clear that this method only applies to the equi-conditions. The javadoc explains it but the method name might be misleading? What do you think?\nI don't know if I have a good solution, btw. getRightKeyColumnsForEquiConditions is clear but quite a mouthful. Maybe getRightEquiConditionKeys.", "author": "gianm", "createdAt": "2020-01-29T19:54:03Z", "path": "processing/src/main/java/org/apache/druid/segment/join/JoinConditionAnalysis.java", "diffHunk": "@@ -176,6 +179,14 @@ public boolean canHashJoin()\n     return canHashJoin;\n   }\n \n+  /**\n+   * Returns the distinct column keys from the RHS required to evaluate the equi conditions.\n+   */\n+  public List<String> getRightKeyColumns()\n+  {", "originalCommit": "7f98720bf182a34d05cbdc781bf184e4b5345270", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5OTM2MA==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372599360", "bodyText": "Btw, a Set may be more appropriate than a List here.", "author": "gianm", "createdAt": "2020-01-29T19:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5Nzg3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0MzQwMQ==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372643401", "bodyText": "I like the suggestion. Done.", "author": "suneet-s", "createdAt": "2020-01-29T21:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5Nzg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5Nzk4MQ==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372597981", "bodyText": "Is this better than Assert.assertEquals?", "author": "gianm", "createdAt": "2020-01-29T19:54:18Z", "path": "processing/src/test/java/org/apache/druid/segment/join/JoinConditionAnalysisTest.java", "diffHunk": "@@ -60,6 +61,7 @@ public void test_forExpression_simple()\n         ImmutableList.of(),\n         exprsToStrings(analysis.getNonEquiConditions())\n     );\n+    Assert.assertThat(analysis.getRightKeyColumns(), CoreMatchers.is(ImmutableList.of(\"y\")));", "originalCommit": "7f98720bf182a34d05cbdc781bf184e4b5345270", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYyNzU2Mw==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372627563", "bodyText": "assertEquals fails because getRightKeyColumns doesn't return an ImmutableList", "author": "suneet-s", "createdAt": "2020-01-29T21:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5Nzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5MjI4OQ==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372692289", "bodyText": "How can that be? CoreMatchers.is is calling actual.equals(expected), with extra steps.", "author": "gianm", "createdAt": "2020-01-29T23:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5Nzk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NDMxNA==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372694314", "bodyText": "I definitely saw the test fail which is why I had to google how to fix this - and I found CoreMatchers.\nhahaha I think I know why now -\nAssert.assertEquals checks expected.equals(actual)\nCoreMatchers.is checks actual.equals(expected)\nThat probably means the equals implementation for one (or both?) of those classes isn't correct according to the javadocs", "author": "suneet-s", "createdAt": "2020-01-29T23:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5Nzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5ODU0OA==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372598548", "bodyText": "The comment above is incorrect now. Actually, it was incorrect before too, since some of these fields are based on equiConditions as well.", "author": "gianm", "createdAt": "2020-01-29T19:55:30Z", "path": "processing/src/test/java/org/apache/druid/segment/join/JoinConditionAnalysisTest.java", "diffHunk": "@@ -271,7 +283,7 @@ public void test_equals()\n                           // These fields are tightly coupled with originalExpression\n                           \"equiConditions\", \"nonEquiConditions\",\n                           // These fields are calculated from nonEquiConditions\n-                          \"isAlwaysTrue\", \"isAlwaysFalse\", \"canHashJoin\")\n+                          \"isAlwaysTrue\", \"isAlwaysFalse\", \"canHashJoin\", \"rightKeyColumns\")", "originalCommit": "7f98720bf182a34d05cbdc781bf184e4b5345270", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5OTAzMA==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372599030", "bodyText": "You could probably do a similar simplification in LookupJoinMatcher (there's a part that checks that all the equikeys are the key column).", "author": "gianm", "createdAt": "2020-01-29T19:56:30Z", "path": "server/src/main/java/org/apache/druid/segment/join/InlineJoinableFactory.java", "diffHunk": "@@ -39,8 +38,7 @@\n   {\n     if (condition.canHashJoin() && dataSource instanceof InlineDataSource) {\n       final InlineDataSource inlineDataSource = (InlineDataSource) dataSource;\n-      final List<String> rightKeyColumns =\n-          condition.getEquiConditions().stream().map(Equality::getRightColumn).distinct().collect(Collectors.toList());\n+      final List<String> rightKeyColumns = condition.getRightKeyColumns();", "originalCommit": "7f98720bf182a34d05cbdc781bf184e4b5345270", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY1MzM2Mg==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372653362", "bodyText": "It's not immediately obvious to me how other implementations would use what LookupJoinMatcher is doing with the equiConditions. If it's ok with you, I'd like to do that refactoring at a later time", "author": "suneet-s", "createdAt": "2020-01-29T21:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5OTAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5MjkxMg==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372692912", "bodyText": "Ah, I just meant replacing this:\n    } else if (!condition.getEquiConditions()\n                         .stream()\n                         .allMatch(eq -> eq.getRightColumn().equals(LookupColumnSelectorFactory.KEY_COLUMN))) {\nWith this:\n    } else if (!condition.getRightEquiConditionKeys().equals(Collections.singletonSet(LookupColumnSelectorFactory.KEY_COLUMN)) {", "author": "gianm", "createdAt": "2020-01-29T23:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5OTAzMA=="}], "type": "inlineReview"}, {"oid": "5b54942b4ca2a61755f6872bd4f3111da755925d", "url": "https://github.com/apache/druid/commit/5b54942b4ca2a61755f6872bd4f3111da755925d", "message": "Address some review comments", "committedDate": "2020-01-29T22:01:59Z", "type": "commit"}, {"oid": "e70dca1b9796189273a21c4a8f357b1fb0ff751a", "url": "https://github.com/apache/druid/commit/e70dca1b9796189273a21c4a8f357b1fb0ff751a", "message": "more code review stuff", "committedDate": "2020-01-30T00:14:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3NzU2Mw==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372777563", "bodyText": "These are backwards. (I think putting actual before expected is more natural, but JUnit disagrees and who am I to judge?)", "author": "gianm", "createdAt": "2020-01-30T06:28:46Z", "path": "processing/src/test/java/org/apache/druid/segment/join/JoinConditionAnalysisTest.java", "diffHunk": "@@ -220,6 +229,7 @@ public void test_forExpression_onlyRight()\n         ImmutableList.of(),\n         exprsToStrings(analysis.getNonEquiConditions())\n     );\n+    Assert.assertEquals(analysis.getRightEquiConditionKeys(), ImmutableSet.of(\"x\"));", "originalCommit": "e70dca1b9796189273a21c4a8f357b1fb0ff751a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3NzYyMQ==", "url": "https://github.com/apache/druid/pull/9287#discussion_r372777621", "bodyText": "Typo (other other)", "author": "gianm", "createdAt": "2020-01-30T06:28:57Z", "path": "processing/src/test/java/org/apache/druid/segment/join/JoinConditionAnalysisTest.java", "diffHunk": "@@ -270,8 +282,8 @@ public void test_equals()\n                   .withIgnoredFields(\n                           // These fields are tightly coupled with originalExpression\n                           \"equiConditions\", \"nonEquiConditions\",\n-                          // These fields are calculated from nonEquiConditions\n-                          \"isAlwaysTrue\", \"isAlwaysFalse\", \"canHashJoin\")\n+                          // These fields are calculated from other other fields in the class", "originalCommit": "e70dca1b9796189273a21c4a8f357b1fb0ff751a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}