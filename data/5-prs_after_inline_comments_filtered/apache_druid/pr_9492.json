{"pr_number": 9492, "pr_title": "add manual laning strategy, integration test", "pr_createdAt": "2020-03-10T11:05:51Z", "pr_url": "https://github.com/apache/druid/pull/9492", "timeline": [{"oid": "6654a724bdbefeabb28c6d2f5ec5afaddfe8755f", "url": "https://github.com/apache/druid/commit/6654a724bdbefeabb28c6d2f5ec5afaddfe8755f", "message": "add manual laning strategy, integration test, json config test", "committedDate": "2020-03-10T10:13:55Z", "type": "commit"}, {"oid": "b187125ce937a053a33116769403cc02a001ab23", "url": "https://github.com/apache/druid/commit/b187125ce937a053a33116769403cc02a001ab23", "message": "share percent conversion method", "committedDate": "2020-03-10T11:10:13Z", "type": "commit"}, {"oid": "700e6abc1520bdaacb69f0a2d601ec73104d5b61", "url": "https://github.com/apache/druid/commit/700e6abc1520bdaacb69f0a2d601ec73104d5b61", "message": "wrong assert", "committedDate": "2020-03-10T20:17:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMDQ2MA==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391200460", "bodyText": "assert this against StringUtils.format(QueryCapacityExceededException.ERROR_MESSAGE_TEMPLATE, \"one\") instead?", "author": "maytasm", "createdAt": "2020-03-11T19:08:45Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test\n+  public void testQueryLaning() throws Exception\n+  {\n+    // the broker is configured with 2 manually defined query lanes, 'one' with limit 1, and 'two' with limit 'two'\n+    //  -Ddruid.query.scheduler.laning.type=manual\n+    //  -Ddruid.query.scheduler.laning.lanes.one=1\n+    //  -Ddruid.query.scheduler.laning.lanes.two=2\n+    // by issuing 50 queries, at least 1 of them will succeed on 'one', and at least 1 of them will overlap enough to\n+    // get limited\n+    final int numQueries = 50;\n+    List<Future<StatusResponseHolder>> futures = new ArrayList<>(numQueries);\n+    for (int i = 0; i < numQueries; i++) {\n+      futures.add(\n+          queryClient.queryAsync(\n+              queryHelper.getQueryURL(config.getBrokerUrl()),\n+              getQueryBuilder().build()\n+          )\n+      );\n+    }\n+\n+    int success = 0;\n+    int limited = 0;\n+\n+    for (Future<StatusResponseHolder> future : futures) {\n+      StatusResponseHolder status = future.get();\n+      if (status.getStatus().getCode() == QueryCapacityExceededException.STATUS_CODE) {\n+        limited++;\n+        Assert.assertTrue(status.getContent().contains(\"one\"));", "originalCommit": "700e6abc1520bdaacb69f0a2d601ec73104d5b61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEwNTIxNQ==", "url": "https://github.com/apache/druid/pull/9492#discussion_r392105215", "bodyText": "changed", "author": "clintropolis", "createdAt": "2020-03-13T09:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMDQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMTkyMA==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391201920", "bodyText": "This can be separate into another @test method. Will make understanding each test case easier.", "author": "maytasm", "createdAt": "2020-03-11T19:11:43Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test\n+  public void testQueryLaning() throws Exception\n+  {\n+    // the broker is configured with 2 manually defined query lanes, 'one' with limit 1, and 'two' with limit 'two'\n+    //  -Ddruid.query.scheduler.laning.type=manual\n+    //  -Ddruid.query.scheduler.laning.lanes.one=1\n+    //  -Ddruid.query.scheduler.laning.lanes.two=2\n+    // by issuing 50 queries, at least 1 of them will succeed on 'one', and at least 1 of them will overlap enough to\n+    // get limited\n+    final int numQueries = 50;\n+    List<Future<StatusResponseHolder>> futures = new ArrayList<>(numQueries);\n+    for (int i = 0; i < numQueries; i++) {\n+      futures.add(\n+          queryClient.queryAsync(\n+              queryHelper.getQueryURL(config.getBrokerUrl()),\n+              getQueryBuilder().build()\n+          )\n+      );\n+    }\n+\n+    int success = 0;\n+    int limited = 0;\n+\n+    for (Future<StatusResponseHolder> future : futures) {\n+      StatusResponseHolder status = future.get();\n+      if (status.getStatus().getCode() == QueryCapacityExceededException.STATUS_CODE) {\n+        limited++;\n+        Assert.assertTrue(status.getContent().contains(\"one\"));\n+      } else if (status.getStatus().getCode() == HttpResponseStatus.OK.getCode()) {\n+        success++;\n+      }\n+    }\n+\n+    Assert.assertTrue(success > 0);\n+    Assert.assertTrue(limited > 0);\n+\n+    // test another to make sure we can still issue one query at a time", "originalCommit": "700e6abc1520bdaacb69f0a2d601ec73104d5b61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzNzcxMA==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391237710", "bodyText": "Hmm, this is testing a sequence of events though, so it belongs in the same test", "author": "clintropolis", "createdAt": "2020-03-11T20:09:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMTkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MDY4OQ==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391240689", "bodyText": "I was thinking the top part is test where we exceed and expect rejection. The bottom part is test where we are always under the limit and never exceed hence expect all to be successful.", "author": "maytasm", "createdAt": "2020-03-11T20:12:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMTkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEwNDYzMw==", "url": "https://github.com/apache/druid/pull/9492#discussion_r392104633", "bodyText": "added a separate test which runs a bunch of queries the same manner that do not belong to a lane to make sure they are not limited", "author": "clintropolis", "createdAt": "2020-03-13T09:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwMTkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjkzMQ==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391206931", "bodyText": "maybe also test negative case (like lane name \"three\") and see we get NO_CAPACITY?", "author": "maytasm", "createdAt": "2020-03-11T19:21:31Z", "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -399,6 +399,49 @@ public void testMisConfigHiLo()\n   }\n \n \n+  @Test\n+  public void testConfigManual()\n+  {\n+    final Injector injector = createInjector();\n+    final String propertyPrefix = \"druid.query.scheduler\";\n+    final JsonConfigProvider<QuerySchedulerProvider> provider = JsonConfigProvider.of(\n+        propertyPrefix,\n+        QuerySchedulerProvider.class\n+    );\n+    final Properties properties = new Properties();\n+    properties.put(propertyPrefix + \".numThreads\", \"10\");\n+    properties.put(propertyPrefix + \".laning.strategy\", \"manual\");\n+    properties.put(propertyPrefix + \".laning.lanes.one\", \"1\");\n+    properties.put(propertyPrefix + \".laning.lanes.two\", \"2\");\n+    provider.inject(properties, injector.getInstance(JsonConfigurator.class));\n+    final QueryScheduler scheduler = provider.get().get().get();\n+    Assert.assertEquals(10, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(\"one\"));\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(\"two\"));", "originalCommit": "700e6abc1520bdaacb69f0a2d601ec73104d5b61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIzOTc2MQ==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391239761", "bodyText": "This isn't actually true currently, non-existent lanes are currently treated the same as not having a lane. I did this in  #9407 because it seemed friendlier, but an argument can probably made for making undefined lanes that are present be treated as having 0 capacity which would make what you are suggesting true. If we wanted to make this change, we could either do it across the board in QueryScheduler, or leave the decision to the QueryLaningStrategy which is a bit more flexible.", "author": "clintropolis", "createdAt": "2020-03-11T20:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0NzEzOQ==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391247139", "bodyText": "Oh, I maybe interpreted this as something deeper, suggesting that we should treat queries that specify non-existent lanes as a 0 capacity lane, because of my poorly named NO_CAPACITY variable which I am going to rename as UNAVAILABLE pending this discussion. If you're just suggesting that we check that non-existent lanes return -1 I can add that test.", "author": "clintropolis", "createdAt": "2020-03-11T20:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0Mzc0NA==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391343744", "bodyText": "Im just suggesting to add test that check that non-existent lanes return -1", "author": "maytasm", "createdAt": "2020-03-12T00:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEwNTUzMQ==", "url": "https://github.com/apache/druid/pull/9492#discussion_r392105531", "bodyText": "added some asserts to existing tests to show that non-existent lane is unavailable", "author": "clintropolis", "createdAt": "2020-03-13T09:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIwNjk3NQ==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391206975", "bodyText": "maybe also test negative case (like lane name \"three\") and see we get NO_CAPACITY?", "author": "maytasm", "createdAt": "2020-03-11T19:21:36Z", "path": "server/src/test/java/org/apache/druid/server/QuerySchedulerTest.java", "diffHunk": "@@ -399,6 +399,49 @@ public void testMisConfigHiLo()\n   }\n \n \n+  @Test\n+  public void testConfigManual()\n+  {\n+    final Injector injector = createInjector();\n+    final String propertyPrefix = \"druid.query.scheduler\";\n+    final JsonConfigProvider<QuerySchedulerProvider> provider = JsonConfigProvider.of(\n+        propertyPrefix,\n+        QuerySchedulerProvider.class\n+    );\n+    final Properties properties = new Properties();\n+    properties.put(propertyPrefix + \".numThreads\", \"10\");\n+    properties.put(propertyPrefix + \".laning.strategy\", \"manual\");\n+    properties.put(propertyPrefix + \".laning.lanes.one\", \"1\");\n+    properties.put(propertyPrefix + \".laning.lanes.two\", \"2\");\n+    provider.inject(properties, injector.getInstance(JsonConfigurator.class));\n+    final QueryScheduler scheduler = provider.get().get().get();\n+    Assert.assertEquals(10, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(\"one\"));\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(\"two\"));\n+  }\n+\n+  @Test\n+  public void testConfigManualPercent()\n+  {\n+    final Injector injector = createInjector();\n+    final String propertyPrefix = \"druid.query.scheduler\";\n+    final JsonConfigProvider<QuerySchedulerProvider> provider = JsonConfigProvider.of(\n+        propertyPrefix,\n+        QuerySchedulerProvider.class\n+    );\n+    final Properties properties = new Properties();\n+    properties.put(propertyPrefix + \".numThreads\", \"10\");\n+    properties.put(propertyPrefix + \".laning.strategy\", \"manual\");\n+    properties.put(propertyPrefix + \".laning.isLimitPercent\", \"true\");\n+    properties.put(propertyPrefix + \".laning.lanes.one\", \"1\");\n+    properties.put(propertyPrefix + \".laning.lanes.twenty\", \"20\");\n+    provider.inject(properties, injector.getInstance(JsonConfigurator.class));\n+    final QueryScheduler scheduler = provider.get().get().get();\n+    Assert.assertEquals(10, scheduler.getTotalAvailableCapacity());\n+    Assert.assertEquals(1, scheduler.getLaneAvailableCapacity(\"one\"));\n+    Assert.assertEquals(2, scheduler.getLaneAvailableCapacity(\"twenty\"));", "originalCommit": "700e6abc1520bdaacb69f0a2d601ec73104d5b61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMjczOA==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391212738", "bodyText": "Just wondering..why does computeLane needs SegmentServerSelector? Doesn't laning or not should just depend on the query context that was given with the query?", "author": "maytasm", "createdAt": "2020-03-11T19:33:03Z", "path": "server/src/main/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class ManualQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  @JsonProperty\n+  private Map<String, Integer> lanes;\n+\n+  @JsonProperty\n+  private boolean isLimitPercent;\n+\n+  @JsonCreator\n+  public ManualQueryLaningStrategy(\n+      @JsonProperty(\"lanes\") Map<String, Integer> lanes,\n+      @JsonProperty(\"isLimitPercent\") @Nullable Boolean isLimitPercent\n+  )\n+  {\n+    this.lanes = Preconditions.checkNotNull(lanes, \"lanes must be set\");\n+    this.isLimitPercent = isLimitPercent != null ? isLimitPercent : false;\n+    Preconditions.checkArgument(lanes.size() > 0, \"lanes must define at least one lane\");\n+    Preconditions.checkArgument(\n+        lanes.values().stream().allMatch(x -> this.isLimitPercent ? 0 < x && x <= 100 : x > 0),\n+        this.isLimitPercent ? \"All lane limits must be in the range 1 to 100\" : \"All lane limits must be greater than 0\"\n+    );\n+  }\n+\n+  @Override\n+  public Object2IntMap<String> getLaneLimits(int totalLimit)\n+  {\n+\n+    if (isLimitPercent) {\n+      Object2IntMap<String> laneLimits = new Object2IntArrayMap<>(lanes.size());\n+      lanes.forEach((key, value) -> laneLimits.put(key, computeLimitFromPercent(totalLimit, value)));\n+      return laneLimits;\n+    }\n+    return new Object2IntArrayMap<>(lanes);\n+  }\n+\n+  @Override\n+  public <T> Optional<String> computeLane(QueryPlus<T> query, Set<SegmentServerSelector> segments)", "originalCommit": "700e6abc1520bdaacb69f0a2d601ec73104d5b61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI0MzI3OQ==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391243279", "bodyText": "QueryLaningStrategy are intended to compute the lane on the query context, which the QueryScheduler can then use to enforce limits. This laning strategy is a bit of a special case because it only preserves what was already there, but other strategies could consider all sorts of information to allow them to make informed decisions about lane assignment based on details of the query.", "author": "clintropolis", "createdAt": "2020-03-11T20:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMjczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0Mzk4OA==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391343988", "bodyText": "I see. Thanks for the clarification", "author": "maytasm", "createdAt": "2020-03-12T00:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMjczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMzYzOA==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391213638", "bodyText": "testPercentLaneLimitsMustBeBelowOneHundred?", "author": "maytasm", "createdAt": "2020-03-11T19:34:47Z", "path": "server/src/test/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategyTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.query.Druids;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.query.aggregation.CountAggregatorFactory;\n+import org.apache.druid.query.timeseries.TimeseriesQuery;\n+import org.apache.druid.server.QueryLaningStrategy;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+@SuppressWarnings(\"ResultOfObjectAllocationIgnored\")\n+public class ManualQueryLaningStrategyTest\n+{\n+  private Druids.TimeseriesQueryBuilder queryBuilder;\n+  private QueryLaningStrategy exactStrategy;\n+  private QueryLaningStrategy percentStrategy;\n+\n+  @Rule\n+  public ExpectedException expectedException = ExpectedException.none();\n+\n+  @Before\n+  public void setup()\n+  {\n+    this.queryBuilder = Druids.newTimeseriesQueryBuilder()\n+                              .dataSource(\"test\")\n+                              .intervals(ImmutableList.of(Intervals.ETERNITY))\n+                              .granularity(Granularities.DAY)\n+                              .aggregators(new CountAggregatorFactory(\"count\"));\n+    this.exactStrategy =\n+        new ManualQueryLaningStrategy(ImmutableMap.of(\"one\", 1, \"ten\", 10), null);\n+    this.percentStrategy =\n+        new ManualQueryLaningStrategy(ImmutableMap.of(\"one\", 1, \"ten\", 10), true);\n+  }\n+\n+  @Test\n+  public void testLanesMustBeSet()\n+  {\n+    expectedException.expect(NullPointerException.class);\n+    expectedException.expectMessage(\"lanes must be set\");\n+    new ManualQueryLaningStrategy(null, null);\n+  }\n+\n+  @Test\n+  public void testMustDefineAtLeast1Lane()\n+  {\n+    expectedException.expect(IllegalArgumentException.class);\n+    expectedException.expectMessage(\"lanes must define at least one lane\");\n+    new ManualQueryLaningStrategy(ImmutableMap.of(), null);\n+  }\n+\n+  @Test\n+  public void testExactLaneLimitsMustBeAboveZero()\n+  {\n+    expectedException.expect(IllegalArgumentException.class);\n+    expectedException.expectMessage(\"All lane limits must be greater than 0\");\n+    new ManualQueryLaningStrategy(ImmutableMap.of(\"zero\", 0, \"one\", 1), null);\n+  }\n+\n+  @Test\n+  public void testPercentLaneLimitsMustBeAboveZero()", "originalCommit": "700e6abc1520bdaacb69f0a2d601ec73104d5b61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEwMjgwOQ==", "url": "https://github.com/apache/druid/pull/9492#discussion_r392102809", "bodyText": "added more tests", "author": "clintropolis", "createdAt": "2020-03-13T09:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMzYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxNzcyMA==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391217720", "bodyText": "Should we also have a test for when the Manual Lane From Context That Arent In Map is given? For example, if lane in query context is \"some-unknown-lane\"", "author": "maytasm", "createdAt": "2020-03-11T19:42:44Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test", "originalCommit": "700e6abc1520bdaacb69f0a2d601ec73104d5b61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIyMDI2Nw==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391220267", "bodyText": "I guess they will always be rejected since we give NO_CAPACITY right?", "author": "maytasm", "createdAt": "2020-03-11T19:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxNzcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NDU0Ng==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391344546", "bodyText": "^ update typo above. Meant to say \"also\" have a test for case when the Manual Lane From Context That Arent In Map is given", "author": "maytasm", "createdAt": "2020-03-12T00:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxNzcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxNzM4Ng==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391917386", "bodyText": "Seems the lane 'two' is not used. Perhaps better to remove it for now.", "author": "jihoonson", "createdAt": "2020-03-12T21:43:56Z", "path": "integration-tests/src/test/java/org/apache/druid/tests/query/ITWikipediaQueryTest.java", "diffHunk": "@@ -51,15 +69,78 @@ public void before() throws Exception\n     ITRetryUtil.retryUntilTrue(\n         () -> coordinatorClient.areSegmentsLoaded(WIKIPEDIA_DATA_SOURCE), \"wikipedia segment load\"\n     );\n-    coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n-    ITRetryUtil.retryUntilTrue(\n-        () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n-    );\n+    if (!coordinatorClient.areLookupsLoaded(WIKI_LOOKUP)) {\n+      coordinatorClient.initializeLookups(WIKIPEDIA_LOOKUP_RESOURCE);\n+      ITRetryUtil.retryUntilTrue(\n+          () -> coordinatorClient.areLookupsLoaded(WIKI_LOOKUP), \"wikipedia lookup load\"\n+      );\n+    }\n   }\n \n   @Test\n   public void testWikipediaQueriesFromFile() throws Exception\n   {\n     queryHelper.testQueriesFromFile(WIKIPEDIA_QUERIES_RESOURCE, 2);\n   }\n+\n+  @Test\n+  public void testQueryLaning() throws Exception\n+  {\n+    // the broker is configured with 2 manually defined query lanes, 'one' with limit 1, and 'two' with limit 'two'\n+    //  -Ddruid.query.scheduler.laning.type=manual\n+    //  -Ddruid.query.scheduler.laning.lanes.one=1\n+    //  -Ddruid.query.scheduler.laning.lanes.two=2", "originalCommit": "700e6abc1520bdaacb69f0a2d601ec73104d5b61", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxOTg3MQ==", "url": "https://github.com/apache/druid/pull/9492#discussion_r391919871", "bodyText": "Should it check the sum of percents of lanes is less than or equal to 100 when isLimitPercent = true?", "author": "jihoonson", "createdAt": "2020-03-12T21:47:24Z", "path": "server/src/main/java/org/apache/druid/server/scheduling/ManualQueryLaningStrategy.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.server.scheduling;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import org.apache.druid.client.SegmentServerSelector;\n+import org.apache.druid.query.QueryContexts;\n+import org.apache.druid.query.QueryPlus;\n+import org.apache.druid.server.QueryLaningStrategy;\n+\n+import javax.annotation.Nullable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+public class ManualQueryLaningStrategy implements QueryLaningStrategy\n+{\n+  @JsonProperty\n+  private Map<String, Integer> lanes;\n+\n+  @JsonProperty\n+  private boolean isLimitPercent;\n+\n+  @JsonCreator\n+  public ManualQueryLaningStrategy(\n+      @JsonProperty(\"lanes\") Map<String, Integer> lanes,\n+      @JsonProperty(\"isLimitPercent\") @Nullable Boolean isLimitPercent\n+  )\n+  {\n+    this.lanes = Preconditions.checkNotNull(lanes, \"lanes must be set\");\n+    this.isLimitPercent = isLimitPercent != null ? isLimitPercent : false;\n+    Preconditions.checkArgument(lanes.size() > 0, \"lanes must define at least one lane\");\n+    Preconditions.checkArgument(\n+        lanes.values().stream().allMatch(x -> this.isLimitPercent ? 0 < x && x <= 100 : x > 0),", "originalCommit": "700e6abc1520bdaacb69f0a2d601ec73104d5b61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjEwMTQ3NA==", "url": "https://github.com/apache/druid/pull/9492#discussion_r392101474", "bodyText": "I'm not sure it is necessary to enforce that since lane limits are currently an 'at most' guarantee instead of an 'at least'; so it seems possibly legitimate to say configure two lanes and allow either of them to use 75% of total capacity.", "author": "clintropolis", "createdAt": "2020-03-13T08:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxOTg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQwNDk0OQ==", "url": "https://github.com/apache/druid/pull/9492#discussion_r392404949", "bodyText": "Hmm I see. Then should this be documented?", "author": "jihoonson", "createdAt": "2020-03-13T18:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxOTg3MQ=="}], "type": "inlineReview"}, {"oid": "13491bb3f81268a357b27f2d3953e0af31ddcf38", "url": "https://github.com/apache/druid/commit/13491bb3f81268a357b27f2d3953e0af31ddcf38", "message": "Merge remote-tracking branch 'upstream/master' into manual-query-laning", "committedDate": "2020-03-13T08:42:43Z", "type": "commit"}, {"oid": "a05c9fa53c7c83362241092bcbd71d732be837a0", "url": "https://github.com/apache/druid/commit/a05c9fa53c7c83362241092bcbd71d732be837a0", "message": "review stuffs", "committedDate": "2020-03-13T08:58:43Z", "type": "commit"}, {"oid": "20c10cfedb3d0cc2b28b4a5c7afe0e5ca2e4b929", "url": "https://github.com/apache/druid/commit/20c10cfedb3d0cc2b28b4a5c7afe0e5ca2e4b929", "message": "doc adjustments", "committedDate": "2020-03-13T09:01:09Z", "type": "commit"}, {"oid": "0bf4232d3aa4f4f0d42bd1724aacbdc2a0a971c5", "url": "https://github.com/apache/druid/commit/0bf4232d3aa4f4f0d42bd1724aacbdc2a0a971c5", "message": "more tests", "committedDate": "2020-03-13T09:05:13Z", "type": "commit"}, {"oid": "ee435add58db2333e2539e904d0d3114f5b2f477", "url": "https://github.com/apache/druid/commit/ee435add58db2333e2539e904d0d3114f5b2f477", "message": "test adjustment", "committedDate": "2020-03-13T09:06:46Z", "type": "commit"}, {"oid": "cdb2d12c73e508c81659dffcc5e220839b43c1e1", "url": "https://github.com/apache/druid/commit/cdb2d12c73e508c81659dffcc5e220839b43c1e1", "message": "adjust docs", "committedDate": "2020-03-14T00:13:11Z", "type": "commit"}, {"oid": "d9762699717e50c1297539d25a38af749a289acb", "url": "https://github.com/apache/druid/commit/d9762699717e50c1297539d25a38af749a289acb", "message": "Update index.md", "committedDate": "2020-03-14T01:00:45Z", "type": "commit"}]}