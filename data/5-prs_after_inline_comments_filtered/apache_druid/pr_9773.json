{"pr_number": 9773, "pr_title": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "pr_createdAt": "2020-04-25T08:50:43Z", "pr_url": "https://github.com/apache/druid/pull/9773", "timeline": [{"oid": "523124ad2d45048aecb2d6c93b5f804720d9f4dd", "url": "https://github.com/apache/druid/commit/523124ad2d45048aecb2d6c93b5f804720d9f4dd", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-04-25T08:49:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3ODM0OQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r416778349", "bodyText": "What do you think about keeping this interface the same and instead changing the private members left and right to DruidRel<?>\nWhenever left and right is set - we can do something like this.left = getCheapestDruidRel(RelNode);\nAs it's written, I wonder if it's possible for us to estimate that a subquery is not required in the computeSelfCost function, but the DruidRel used to build the native query actually uses a subquery.", "author": "suneet-s", "createdAt": "2020-04-28T17:04:23Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -328,17 +327,27 @@ private static JoinType toDruidJoinType(JoinRelType calciteJoinType)\n     }\n   }\n \n-  private static boolean computeLeftRequiresSubquery(final DruidRel<?> left)\n+  private static boolean computeLeftRequiresSubquery(final List<DruidRel<?>> leftList)", "originalCommit": "523124ad2d45048aecb2d6c93b5f804720d9f4dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5a7795b7099fd7d9650a024961c9b03ffddff521", "url": "https://github.com/apache/druid/commit/5a7795b7099fd7d9650a024961c9b03ffddff521", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-05-01T01:37:23Z", "type": "commit"}, {"oid": "9475845bc4e2a19b02de6592adf6987ae126f61f", "url": "https://github.com/apache/druid/commit/9475845bc4e2a19b02de6592adf6987ae126f61f", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-05-01T01:39:06Z", "type": "commit"}, {"oid": "19bb16cf4d72264fec98b8f46cc9a030956dd874", "url": "https://github.com/apache/druid/commit/19bb16cf4d72264fec98b8f46cc9a030956dd874", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-05-01T02:41:24Z", "type": "commit"}, {"oid": "cafca0edc23339f0981b0ab3db5b2b4bd316d48a", "url": "https://github.com/apache/druid/commit/cafca0edc23339f0981b0ab3db5b2b4bd316d48a", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-05-01T03:47:40Z", "type": "commit"}, {"oid": "7911b2096677593195cb054a2a5a8497807c6ece", "url": "https://github.com/apache/druid/commit/7911b2096677593195cb054a2a5a8497807c6ece", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "committedDate": "2020-05-01T22:16:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTA5NQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421051095", "bodyText": "This \"due to the order of applying/popping rules\" sounds a bit sketchy. Does it mean that a good plan and bad plan will have equal cost, and we'll pick the good plan due to order-based tiebreaking? If so, I'm not sure it would be safe to rely on that. Ideally the good plans should be cheaper than the bad plans, which ensures we pick them.", "author": "gianm", "createdAt": "2020-05-06T19:51:05Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -293,23 +293,17 @@ protected RelDataType deriveRowType()\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    double cost;\n-\n-    if (computeLeftRequiresSubquery(getSomeDruidChild(left))) {\n-      cost = CostEstimates.COST_JOIN_SUBQUERY;\n-    } else {\n-      cost = partialQuery.estimateCost();\n-    }\n-\n-    if (computeRightRequiresSubquery(getSomeDruidChild(right))) {\n-      cost += CostEstimates.COST_JOIN_SUBQUERY;\n-    }\n-\n+    double cost = partialQuery.estimateCost();\n     if (joinRel.getCondition().isA(SqlKind.LITERAL) && !joinRel.getCondition().isAlwaysFalse()) {\n       cost += CostEstimates.COST_JOIN_CROSS;\n     }\n-\n-    return planner.getCostFactory().makeCost(cost, 0, 0);\n+    // This is to cancel out the MULTIPLIER_FILTER (value=0.1) from partialQuery.estimateCost() to discourage\n+    // filter push down if pushing down the filter makes this DruidJoinQueryRel not a scan or mapping.\n+    // This will leave the filter at the topmost DruidJoinQueryRel (due to the order of applying/popping rules).", "originalCommit": "7911b2096677593195cb054a2a5a8497807c6ece", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE3MzMyMQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421173321", "bodyText": "After thinking about this for a while, I'm thinking that a less-sketchy method would be to remove the rules that push filters past joins. It's similar to how #9648 (temporarily) addressed issues related to bad join orderings by just nuking the rules that reordered joins. It makes sense since we don't have a good way to guide the optimizer at this point.\nWe'll want to reintroduce these rules when we've made improvements to the cost estimators that allow all these rules to operate at their full power.\nIn this case, I think the relevant rules are FilterJoinRule.FILTER_ON_JOIN and FilterJoinRule.JOIN. I'm not sure if we can actually fully disable them, though. We might need parts of them. So we might need to copy them and dumb them down a bit? I'm not sure if this will be necessary, but it's an option if necessary.", "author": "gianm", "createdAt": "2020-05-07T00:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxNzkyOA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421917928", "bodyText": "Done. Updated PR description with details.", "author": "maytasm", "createdAt": "2020-05-08T03:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTY1OQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421051659", "bodyText": "Could you also add a super-long version of this (just in case)? Such as:\n        \"SELECT dim1\\n\"\n        + \"FROM foo\\n\"\n        + \"INNER JOIN lookup.lookyloo l ON foo.dim2 = l.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l2 ON foo.dim2 = l2.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l3 ON foo.dim2 = l3.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l4 ON foo.dim2 = l4.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l5 ON foo.dim2 = l5.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l6 ON foo.dim2 = l6.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l7 ON foo.dim2 = l7.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l8 ON foo.dim2 = l8.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l9 ON foo.dim2 = l9.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l10 ON foo.dim2 = l10.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l11 ON foo.dim2 = l11.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l12 ON foo.dim2 = l12.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l13 ON foo.dim2 = l13.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l14 ON foo.dim2 = l14.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l15 ON foo.dim2 = l15.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l16 ON foo.dim2 = l16.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l17 ON foo.dim2 = l17.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l18 ON foo.dim2 = l18.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l19 ON foo.dim2 = l19.k\\n\"\n        + \"WHERE l.v = 'xa'\\n\",\nThe reason I'm suggesting this is we want to make sure the approach we're using doesn't change behavior as the stack gets deeper.", "author": "gianm", "createdAt": "2020-05-06T19:52:07Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -8346,6 +8346,166 @@ public void testLeftJoinTwoLookupsUsingJoinOperator() throws Exception\n     );\n   }\n \n+  @Test\n+  public void testInnerJoinTableLookupLookupWithFilterWithOuterLimit() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT dim1\\n\"\n+        + \"FROM foo\\n\"\n+        + \"INNER JOIN lookup.lookyloo l ON foo.dim2 = l.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l2 ON foo.dim2 = l2.k\\n\"\n+        + \"WHERE l.v = 'xa'\\n\"\n+        + \"LIMIT 100\\n\",\n+        ImmutableList.of(\n+            newScanQueryBuilder()\n+                .dataSource(\n+                    join(\n+                        join(\n+                            new TableDataSource(CalciteTests.DATASOURCE1),\n+                            new LookupDataSource(\"lookyloo\"),\n+                            \"j0.\",\n+                            equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"j0.k\")),\n+                            JoinType.INNER\n+                        ),\n+                        new LookupDataSource(\"lookyloo\"),\n+                        \"_j0.\",\n+                        equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"_j0.k\")),\n+                        JoinType.INNER\n+                    )\n+                )\n+                .intervals(querySegmentSpec(Filtration.eternity()))\n+                .limit(100)\n+                .filters(selector(\"j0.v\", \"xa\", null))\n+                .columns(\"dim1\")\n+                .context(QUERY_CONTEXT_DEFAULT)\n+                .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\"},\n+            new Object[]{\"1\"}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testInnerJoinTableLookupLookupWithFilterWithoutLimit() throws Exception\n+  {\n+    testQuery(", "originalCommit": "7911b2096677593195cb054a2a5a8497807c6ece", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxNzk0Nw==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421917947", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-08T03:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NDIzOQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421054239", "bodyText": "Could you add a comment about why this is being done here?", "author": "gianm", "createdAt": "2020-05-06T19:56:31Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQueryRel.java", "diffHunk": "@@ -183,6 +183,10 @@ public RelWriter explainTerms(final RelWriter pw)\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    return planner.getCostFactory().makeCost(partialQuery.estimateCost(), 0, 0);\n+    double cost = partialQuery.estimateCost();\n+    double multiplier = DruidRels.isScanOrMapping(this, true)", "originalCommit": "7911b2096677593195cb054a2a5a8497807c6ece", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxNzk3OA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421917978", "bodyText": "No longer need this. Removed", "author": "maytasm", "createdAt": "2020-05-08T03:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NDIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NDk1NQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421054955", "bodyText": "It seems like this happens even if there is no filter. Is that right?", "author": "gianm", "createdAt": "2020-05-06T19:57:49Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -293,23 +293,17 @@ protected RelDataType deriveRowType()\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    double cost;\n-\n-    if (computeLeftRequiresSubquery(getSomeDruidChild(left))) {\n-      cost = CostEstimates.COST_JOIN_SUBQUERY;\n-    } else {\n-      cost = partialQuery.estimateCost();\n-    }\n-\n-    if (computeRightRequiresSubquery(getSomeDruidChild(right))) {\n-      cost += CostEstimates.COST_JOIN_SUBQUERY;\n-    }\n-\n+    double cost = partialQuery.estimateCost();\n     if (joinRel.getCondition().isA(SqlKind.LITERAL) && !joinRel.getCondition().isAlwaysFalse()) {\n       cost += CostEstimates.COST_JOIN_CROSS;\n     }\n-\n-    return planner.getCostFactory().makeCost(cost, 0, 0);\n+    // This is to cancel out the MULTIPLIER_FILTER (value=0.1) from partialQuery.estimateCost() to discourage\n+    // filter push down if pushing down the filter makes this DruidJoinQueryRel not a scan or mapping.\n+    // This will leave the filter at the topmost DruidJoinQueryRel (due to the order of applying/popping rules).\n+    double multiplier = DruidRels.isScanOrMapping(this, true)\n+                        ? 1\n+                        : 1 / CostEstimates.MULTIPLIER_FILTER;", "originalCommit": "7911b2096677593195cb054a2a5a8497807c6ece", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxODAyMg==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421918022", "bodyText": "No longer need this. Removed", "author": "maytasm", "createdAt": "2020-05-08T03:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NDk1NQ=="}], "type": "inlineReview"}, {"oid": "c5893ab1fc2ebe88099d3c42d172043b3c8c9fc2", "url": "https://github.com/apache/druid/commit/c5893ab1fc2ebe88099d3c42d172043b3c8c9fc2", "message": "address comments", "committedDate": "2020-05-08T03:34:22Z", "type": "commit"}, {"oid": "0aed7ea9f6ec4e2bd32fa3becaed8206ac74f15c", "url": "https://github.com/apache/druid/commit/0aed7ea9f6ec4e2bd32fa3becaed8206ac74f15c", "message": "address comments", "committedDate": "2020-05-08T03:37:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkyMDI5MA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r421920290", "bodyText": "These left right thing is not needed. But I copied this whole code from Calcite and made minimum change (which is just the classifyFilters method). Hence, keeping these variables here as I don't want to refactor Calcite stuff more than needed.", "author": "maytasm", "createdAt": "2020-05-08T03:45:05Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import org.apache.calcite.adapter.enumerable.EnumerableConvention;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.RelFactories;\n+import org.apache.calcite.rel.rules.FilterJoinRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.calcite.plan.RelOptUtil.conjunctions;\n+\n+public abstract class FilterJoinExcludePushToChildRule extends FilterJoinRule\n+{\n+  /** Copied from {@link FilterJoinRule#NOT_ENUMERABLE} */\n+  private static final Predicate NOT_ENUMERABLE = (join, joinType, exp) ->\n+      join.getConvention() != EnumerableConvention.INSTANCE;\n+\n+  /**\n+   * Rule that pushes predicates from a Filter into the Join below them.\n+   * Similar to {@link FilterJoinRule#FILTER_ON_JOIN} but does not push predicate to the child\n+   */\n+  public static final FilterJoinRule FILTER_ON_JOIN_EXCLUDE_PUSH_TO_CHILD =\n+      new FilterIntoJoinExcludePushToChildRule(RelFactories.LOGICAL_BUILDER, NOT_ENUMERABLE);\n+\n+  FilterJoinExcludePushToChildRule(RelOptRuleOperand operand,\n+                                             String id,\n+                                             boolean smart,\n+                                             RelBuilderFactory relBuilderFactory,\n+                                             Predicate predicate) {\n+    super(operand, id, smart, relBuilderFactory, predicate);\n+  }\n+\n+  /**\n+   * Rule that tries to push filter expressions into a join\n+   * condition. Exlucde pushing into the inputs (child) of the join.\n+   */\n+  public static class FilterIntoJoinExcludePushToChildRule extends FilterJoinExcludePushToChildRule\n+  {\n+    public FilterIntoJoinExcludePushToChildRule(RelBuilderFactory relBuilderFactory, Predicate predicate) {\n+      super(\n+          operand(Filter.class,\n+                  operand(Join.class, RelOptRule.any())),\n+          \"FilterJoinExcludePushToChildRule:filter\", true, relBuilderFactory,\n+          predicate);\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+      Filter filter = call.rel(0);\n+      Join join = call.rel(1);\n+      perform(call, filter, join);\n+    }\n+  }\n+\n+  /**\n+   * Copied from {@link FilterJoinRule#perform}\n+   * The difference is that this method will not not push filters to the children in classifyFilters\n+   */\n+  @Override\n+  protected void perform(RelOptRuleCall call, Filter filter,\n+                         Join join) {\n+    final List<RexNode> joinFilters =\n+        RelOptUtil.conjunctions(join.getCondition());\n+    final List<RexNode> origJoinFilters = ImmutableList.copyOf(joinFilters);\n+    // If there is only the joinRel,\n+    // make sure it does not match a cartesian product joinRel\n+    // (with \"true\" condition), otherwise this rule will be applied\n+    // again on the new cartesian product joinRel.\n+    if (filter == null && joinFilters.isEmpty()) {\n+      return;\n+    }\n+\n+    final List<RexNode> aboveFilters =\n+        filter != null\n+        ? getConjunctions(filter)\n+        : new ArrayList<>();\n+    final ImmutableList<RexNode> origAboveFilters =\n+        ImmutableList.copyOf(aboveFilters);\n+\n+    // Simplify Outer Joins\n+    JoinRelType joinType = join.getJoinType();\n+    if (!origAboveFilters.isEmpty() && join.getJoinType() != JoinRelType.INNER) {\n+      joinType = RelOptUtil.simplifyJoin(join, origAboveFilters, joinType);\n+    }\n+\n+    final List<RexNode> leftFilters = new ArrayList<>();", "originalCommit": "0aed7ea9f6ec4e2bd32fa3becaed8206ac74f15c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "url": "https://github.com/apache/druid/commit/f3dc681414f9b10bc9d37805d0965d6aceba58b1", "message": "fix checkstyle", "committedDate": "2020-05-08T19:42:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3Nzc4OA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425277788", "bodyText": "CAST, not CASE (spelling)\npassed the check (spelling)", "author": "gianm", "createdAt": "2020-05-14T16:37:48Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -193,9 +193,16 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n     final int numLeftFields = leftRowType.getFieldCount();\n \n     for (RexNode subCondition : subConditions) {\n-      if (subCondition.isA(SqlKind.LITERAL)) {\n-        // Literals are always OK.\n-        literalSubConditions.add((RexLiteral) subCondition);\n+      if (RexUtil.isLiteral(subCondition, true)) {\n+        if (subCondition instanceof RexCall) {\n+          // This is CAST(literal) which is always OK.\n+          // We know that this is CASE(literal) as it pass the check from RexUtil.isLiteral", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ0ODMzNg==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425448336", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T21:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3Nzc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3ODUwMg==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425278502", "bodyText": "A bit nicer to do if (subCondition.isA(SqlKind.CAST)), since it's more explicit as to what we're actually looking for.", "author": "gianm", "createdAt": "2020-05-14T16:39:01Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -193,9 +193,16 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n     final int numLeftFields = leftRowType.getFieldCount();\n \n     for (RexNode subCondition : subConditions) {\n-      if (subCondition.isA(SqlKind.LITERAL)) {\n-        // Literals are always OK.\n-        literalSubConditions.add((RexLiteral) subCondition);\n+      if (RexUtil.isLiteral(subCondition, true)) {\n+        if (subCondition instanceof RexCall) {", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ0ODUxOA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425448518", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T21:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3ODUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMDg5Nw==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425300897", "bodyText": "We have to verify the types of the cast here, because if the underlying literal and the cast output type are different, then skipping the cast might change the meaning of the subcondition. Try looking at the type of the RexCall and comparing it to the type of the underlying RexLiteral. I think some logic like this would work:\n\nIf the types are the same, unwrap the cast and use the underlying literal.\nIf the types are not the same, return Optional.empty() indicating the condition is not supported.\n\nAlternatively, actually apply the cast in step (2) instead of rejecting the condition. I'm not sure how exactly you would do this or whether it is necessary. If it turns out to be necessary, perhaps check out what ReduceExpressionsRule does.", "author": "gianm", "createdAt": "2020-05-14T17:13:00Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -193,9 +193,16 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n     final int numLeftFields = leftRowType.getFieldCount();\n \n     for (RexNode subCondition : subConditions) {\n-      if (subCondition.isA(SqlKind.LITERAL)) {\n-        // Literals are always OK.\n-        literalSubConditions.add((RexLiteral) subCondition);\n+      if (RexUtil.isLiteral(subCondition, true)) {\n+        if (subCondition instanceof RexCall) {\n+          // This is CAST(literal) which is always OK.\n+          // We know that this is CASE(literal) as it pass the check from RexUtil.isLiteral\n+          RexCall call = (RexCall) subCondition;\n+          literalSubConditions.add((RexLiteral) call.operands.get(0));", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ2NTExNQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425465115", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T22:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMDg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMTI2Ng==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425301266", "bodyText": "Please add a javadoc here explaining where the code came from, what modifications you made, and what might need to happen to make this no longer necessary (so we can use the builtin rule instead).", "author": "gianm", "createdAt": "2020-05-14T17:13:38Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import org.apache.calcite.adapter.enumerable.EnumerableConvention;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.RelFactories;\n+import org.apache.calcite.rel.rules.FilterJoinRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public abstract class FilterJoinExcludePushToChildRule extends FilterJoinRule", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1NDI1Mg==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425454252", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T21:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMjE0Ng==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425302146", "bodyText": "Unfortunately (spelling)", "author": "gianm", "createdAt": "2020-05-14T17:15:08Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -8749,6 +9097,9 @@ public void testCommaJoinLeftFunction() throws Exception\n     );\n   }\n \n+  // This SQL currently does not result in an optimum plan.\n+  // Unfortunetly, we have disabled pushing down predicates (conditions and filters) due to https://github.com/apache/druid/pull/9773", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1NTYzMQ==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425455631", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T22:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMjE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMjM1Ng==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425302356", "bodyText": "Please update the docs to point out that people should avoid comma joins for this reason.", "author": "gianm", "createdAt": "2020-05-14T17:15:30Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -8749,6 +9097,9 @@ public void testCommaJoinLeftFunction() throws Exception\n     );\n   }\n \n+  // This SQL currently does not result in an optimum plan.\n+  // Unfortunetly, we have disabled pushing down predicates (conditions and filters) due to https://github.com/apache/druid/pull/9773\n+  // Hence, comma join will result in a cross join with filter on outermost", "originalCommit": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1NTY4OA==", "url": "https://github.com/apache/druid/pull/9773#discussion_r425455688", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-05-14T22:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMjM1Ng=="}], "type": "inlineReview"}, {"oid": "9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "url": "https://github.com/apache/druid/commit/9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "message": "address comments", "committedDate": "2020-05-14T22:06:36Z", "type": "commit"}, {"oid": "177e0bbf4b6537231b1f1746b212fd7de6fd2eab", "url": "https://github.com/apache/druid/commit/177e0bbf4b6537231b1f1746b212fd7de6fd2eab", "message": "address comments", "committedDate": "2020-05-14T22:26:54Z", "type": "commit"}]}