{"pr_number": 9965, "pr_title": "API to verify a datasource has the latest ingested data", "pr_createdAt": "2020-06-02T04:13:00Z", "pr_url": "https://github.com/apache/druid/pull/9965", "timeline": [{"oid": "bd95578e6a4875aa106b1710b3c1b78f46bbc12f", "url": "https://github.com/apache/druid/commit/bd95578e6a4875aa106b1710b3c1b78f46bbc12f", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-02T03:57:56Z", "type": "commit"}, {"oid": "8d2749e34f0d74ccfc480da14c0b2826ef354116", "url": "https://github.com/apache/druid/commit/8d2749e34f0d74ccfc480da14c0b2826ef354116", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-02T09:13:38Z", "type": "commit"}, {"oid": "aca82f3eafa1c9ca9b4cb6dde48b55442b86c0bd", "url": "https://github.com/apache/druid/commit/aca82f3eafa1c9ca9b4cb6dde48b55442b86c0bd", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-02T10:13:01Z", "type": "commit"}, {"oid": "1a1a0cdb13bc473b81e4ecf7a9e76afb035a72e5", "url": "https://github.com/apache/druid/commit/1a1a0cdb13bc473b81e4ecf7a9e76afb035a72e5", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-02T10:21:08Z", "type": "commit"}, {"oid": "6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "url": "https://github.com/apache/druid/commit/6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-02T10:48:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NTM4OQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r434945389", "bodyText": "I think this parameter should be something like forceMetadataPoll or forceMetadataRefresh something", "author": "clintropolis", "createdAt": "2020-06-04T01:41:52Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +393,43 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"firstCheck\") @Nullable final Boolean firstCheck", "originalCommit": "6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxNzA5OQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r437817099", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-10T01:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NTM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjMxNA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r434946314", "bodyText": "It seems a little off that not having serverInventoryView or it not being initialized would return a {\"loaded\":false} but a datasource not existing would be an empty response. I think this response is fine, but maybe the serverInventoryView == null case should be an error response indicating that information in unavailable", "author": "clintropolis", "createdAt": "2020-06-04T01:45:10Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +393,43 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"firstCheck\") @Nullable final Boolean firstCheck\n+  )\n+  {\n+    if (serverInventoryView == null || serverInventoryView.getSegmentLoadInfos() == null) {\n+      return Response.ok(ImmutableMap.of(\"loaded\", false)).build();\n+    }\n+    // Force poll\n+    Interval theInterval = interval == null ? Intervals.ETERNITY : Intervals.of(interval);\n+    boolean requiresMetadataStorePoll = firstCheck == null ? true :firstCheck;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);", "originalCommit": "6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxNzUwNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r437817506", "bodyText": "serverInventoryView and segmentLoadInfos are never null", "author": "maytasm", "createdAt": "2020-06-10T01:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjY1NQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r434946655", "bodyText": "nit: i think the old name was better, and still works with the new method being named forceOrWaitOngoingDatabasePoll", "author": "clintropolis", "createdAt": "2020-06-04T01:46:43Z", "path": "server/src/main/java/org/apache/druid/metadata/SqlSegmentsMetadataManager.java", "diffHunk": "@@ -403,11 +425,16 @@ private void awaitOrPerformDatabasePoll()\n   }\n \n   /**\n-   * If the latest {@link DatabasePoll} is a {@link PeriodicDatabasePoll}, or an {@link OnDemandDatabasePoll} that is\n-   * made not longer than {@link #periodicPollDelay} from now, awaits for it and returns true; returns false otherwise,\n-   * meaning that a new on-demand database poll should be initiated.\n+   * This method returns true without waiting for database poll if the latest {@link DatabasePoll} is a\n+   * {@link PeriodicDatabasePoll} that has completed it's first poll, or an {@link OnDemandDatabasePoll} that is\n+   * made not longer than {@link #periodicPollDelay} from current time.\n+   * This method does wait untill completion for if the latest {@link DatabasePoll} is a\n+   * {@link PeriodicDatabasePoll} that has not completed it's first poll, or an {@link OnDemandDatabasePoll} that is\n+   * alrady in the process of polling the database.\n+   * This means that any method using this check can read from snapshot that is\n+   * up to {@link SqlSegmentsMetadataManager#periodicPollDelay} old.\n    */\n-  private boolean awaitLatestDatabasePoll()\n+  private boolean useLatestSnapshotIfWithinDelay()", "originalCommit": "6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxODUxOQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r437818519", "bodyText": "I really dont like the old name. This method most of the time does not wait (even though the method is called await). For example, if the latest poll is PeriodicDatabasePoll, it will never wait and just return the last poll. Even if there is a on-going PeriodicDatabasePoll, it does not wait and return the last poll. If the latest poll is OnDemandDatabasePoll, it will only wait if the latest is older than pollPeriod. This means that most of the time this method does not await and return last poll.", "author": "maytasm", "createdAt": "2020-06-10T02:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxODcxNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r437818716", "bodyText": "Just saying awaitLatestDatabasePoll is misleading as it does not always guarantee wait on latest database poll.", "author": "maytasm", "createdAt": "2020-06-10T02:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk0NjY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1MjA3Nw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r434952077", "bodyText": "nit: formatting seems strange here, i suggest:\n  Optional<Iterable<DataSegment>> iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n      String datasource,\n      Interval interval,\n      boolean requiresLatest\n  );", "author": "clintropolis", "createdAt": "2020-06-04T02:08:40Z", "path": "server/src/main/java/org/apache/druid/metadata/SegmentsMetadataManager.java", "diffHunk": "@@ -113,6 +114,18 @@ int markAsUsedNonOvershadowedSegments(String dataSource, Set<String> segmentIds)\n    */\n   Iterable<DataSegment> iterateAllUsedSegments();\n \n+  /**\n+   * Returns an iterable to go over all used and non-overshadowed segments of given data sources over given interval.\n+   * The order in which segments are iterated is unspecified.\n+   * If {@param requiresLatest} is true then a force metadatastore poll will be triggered. This can cause a longer\n+   * response time but will ensure that the latest segment information (at the time this method is called) is returned.\n+   * If {@param requiresLatest} is false then segment information from stale snapshot of up to the last periodic poll\n+   * period {@link SqlSegmentsMetadataManager#periodicPollDelay} will be used.\n+   */\n+  Optional<Iterable<DataSegment>> iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(String datasource,", "originalCommit": "6dc035cb2d5dcf5796c7ad516ab39700ef7204a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxODg0Nw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r437818847", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-10T02:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1MjA3Nw=="}], "type": "inlineReview"}, {"oid": "0a7dc4e2a357a9094e08fcd8f4684abe1ff0ceae", "url": "https://github.com/apache/druid/commit/0a7dc4e2a357a9094e08fcd8f4684abe1ff0ceae", "message": "fix checksyle", "committedDate": "2020-06-06T03:43:41Z", "type": "commit"}, {"oid": "0a019d1b2adbcfb7a92ffc496d3c21edb510ef86", "url": "https://github.com/apache/druid/commit/0a019d1b2adbcfb7a92ffc496d3c21edb510ef86", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-10T01:58:08Z", "type": "commit"}, {"oid": "49dc85b69325ccfe7515ad5a4870aa40567c292d", "url": "https://github.com/apache/druid/commit/49dc85b69325ccfe7515ad5a4870aa40567c292d", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-10T02:05:33Z", "type": "commit"}, {"oid": "46e5019df2fdf9dda0e5a3475fd6e877d5c23cf9", "url": "https://github.com/apache/druid/commit/46e5019df2fdf9dda0e5a3475fd6e877d5c23cf9", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-10T08:07:46Z", "type": "commit"}, {"oid": "2270a5bec6985111be1d464b96bf23f7962a0d58", "url": "https://github.com/apache/druid/commit/2270a5bec6985111be1d464b96bf23f7962a0d58", "message": "API to verify a datasource has the latest ingested data", "committedDate": "2020-06-10T08:43:15Z", "type": "commit"}, {"oid": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "url": "https://github.com/apache/druid/commit/172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "message": "fix spelling", "committedDate": "2020-06-10T12:19:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3OTExMA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439179110", "bodyText": "I really don't think this should default to true since it is a heavy operation, but also, since the docs recommend polling the API with the not default option to determine when your segments are all available and only calling with the default option once.", "author": "clintropolis", "createdAt": "2020-06-12T02:51:13Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMTU4Ng==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439701586", "bodyText": "The reason I have the default as true is to prevent operator mistake by forgetting to set to true on the first call. Basically, you will get the correct result if you make every call with true. However, you will not get the correct result (and can be making query when segments are not yet loaded!) if you make every call with false. Hence, having default to true to a safer option imo.", "author": "maytasm", "createdAt": "2020-06-13T02:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3OTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMTYyNQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439701625", "bodyText": "Setting to false is an optional optimization that can be done on the calls after the first call.", "author": "maytasm", "createdAt": "2020-06-13T02:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3OTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzE5Mw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707193", "bodyText": "Making this field mandatory instead. 400 bad request will be returned if forceMetadataRefresh is not given. This will make sure user read and understand the doc when using this API. To use this API properly, you will have to change the flag in the flow between first call and subsequent call. Hence, there is no \u201cdefault\u201d as the flag are for different cases. Basically both flags are as default as the other flag and are needed for different step in the flow.", "author": "maytasm", "createdAt": "2020-06-13T04:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE3OTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MDgyNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439180826", "bodyText": "It seems like there is quite a lot of logic in this API entry point method, it would be worth breaking each of these blocks out into methods dedicated for each response so it's a bit easier to follow", "author": "clintropolis", "createdAt": "2020-06-12T02:58:53Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzE5Ng==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707196", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T04:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MDgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MTI2Mg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439181262", "bodyText": "resposne -> response", "author": "clintropolis", "createdAt": "2020-06-12T03:00:42Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzIxMw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707213", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T04:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MjY0MA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439182640", "bodyText": "Hmm, is there a way to re-arrange this without iterating the entire set of segments twice? If not it would maybe be worth pushing this into DruidCoordinator, at least if force refresh is true, since it potentially has segmentReplicantLookup already built, or exposing it to this resource in some manner.", "author": "clintropolis", "createdAt": "2020-06-12T03:06:54Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUnloadedSegments = 0;\n+      for (DataSegment segment : segments.get()) {\n+        if (!segmentLoadInfos.containsKey(segment.getId())) {\n+          numUnloadedSegments++;\n+        }\n+      }\n+      return Response.ok(\n+          ImmutableMap.of(\n+              dataSourceName,\n+              numUnloadedSegments\n+          )\n+      ).build();\n+    } else if (full != null) {\n+      // Calculate resposne for full mode\n+      final Map<String, Object2LongMap<String>> underReplicationCountsPerDataSourcePerTier = new HashMap<>();\n+      final List<Rule> rules = metadataRuleManager.getRulesWithDefault(dataSourceName);\n+      final Table<SegmentId, String, Integer> segmentsInCluster = HashBasedTable.create();\n+      final DateTime now = DateTimes.nowUtc();\n+\n+      for (DataSegment segment : segments.get()) {\n+        for (DruidServer druidServer : serverInventoryView.getInventory()) {\n+          String tier = druidServer.getTier();\n+          SegmentId segmentId = segment.getId();\n+          DruidDataSource druidDataSource = druidServer.getDataSource(dataSourceName);\n+          if (druidDataSource != null && druidDataSource.getSegment(segmentId) != null) {\n+            Integer numReplicants = segmentsInCluster.get(segmentId, tier);\n+            if (numReplicants == null) {\n+              numReplicants = 0;\n+            }\n+            segmentsInCluster.put(segmentId, tier, numReplicants + 1);\n+          }\n+        }\n+      }\n+      for (DataSegment segment : segments.get()) {", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzM5MQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707391", "bodyText": "Removed this code in DataSourcesResource. Reuse the code for calculating the underReplicationCountsPerDataSourcePerTier in DruidCoordinator by making the call to DruidCoordinator. This basically reuse segmentReplicantLookup in DruidCoordinator. This can make sure that the behavior is consistent between the full format of the new API and the existing coordinator loadstatus API. For example, if there is a bug in the full format coordinator loadstatus API where it is ignoring broadcast rule, then we just have to remember to fix it in one place ;)", "author": "maytasm", "createdAt": "2020-06-13T04:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MjY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MzYwMQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439183601", "bodyText": "resposne -> response", "author": "clintropolis", "createdAt": "2020-06-12T03:11:19Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUnloadedSegments = 0;\n+      for (DataSegment segment : segments.get()) {\n+        if (!segmentLoadInfos.containsKey(segment.getId())) {\n+          numUnloadedSegments++;\n+        }\n+      }\n+      return Response.ok(\n+          ImmutableMap.of(\n+              dataSourceName,\n+              numUnloadedSegments\n+          )\n+      ).build();\n+    } else if (full != null) {\n+      // Calculate resposne for full mode\n+      final Map<String, Object2LongMap<String>> underReplicationCountsPerDataSourcePerTier = new HashMap<>();\n+      final List<Rule> rules = metadataRuleManager.getRulesWithDefault(dataSourceName);\n+      final Table<SegmentId, String, Integer> segmentsInCluster = HashBasedTable.create();\n+      final DateTime now = DateTimes.nowUtc();\n+\n+      for (DataSegment segment : segments.get()) {\n+        for (DruidServer druidServer : serverInventoryView.getInventory()) {\n+          String tier = druidServer.getTier();\n+          SegmentId segmentId = segment.getId();\n+          DruidDataSource druidDataSource = druidServer.getDataSource(dataSourceName);\n+          if (druidDataSource != null && druidDataSource.getSegment(segmentId) != null) {\n+            Integer numReplicants = segmentsInCluster.get(segmentId, tier);\n+            if (numReplicants == null) {\n+              numReplicants = 0;\n+            }\n+            segmentsInCluster.put(segmentId, tier, numReplicants + 1);\n+          }\n+        }\n+      }\n+      for (DataSegment segment : segments.get()) {\n+        for (final Rule rule : rules) {\n+          if (!(rule instanceof LoadRule && rule.appliesTo(segment, now))) {\n+            continue;\n+          }\n+          ((LoadRule) rule)\n+              .getTieredReplicants()\n+              .forEach((final String tier, final Integer ruleReplicants) -> {\n+                Integer currentReplicantsRetVal = segmentsInCluster.get(segment.getId(), tier);\n+                int currentReplicants = currentReplicantsRetVal == null ? 0 : currentReplicantsRetVal;\n+                Object2LongMap<String> underReplicationPerDataSource = underReplicationCountsPerDataSourcePerTier\n+                    .computeIfAbsent(tier, ignored -> new Object2LongOpenHashMap<>());\n+                ((Object2LongOpenHashMap<String>) underReplicationPerDataSource)\n+                    .addTo(dataSourceName, Math.max(ruleReplicants - currentReplicants, 0));\n+              });\n+          break; // only the first matching rule applies\n+        }\n+      }\n+      return Response.ok(underReplicationCountsPerDataSourcePerTier).build();\n+    } else {\n+      // Calculate resposne for default mode", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzQxMA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707410", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T04:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4MzYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NDExNg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439184116", "bodyText": "Yeah, I think you need to handle BroadcastDistributionRule here too if you want to be totally complete, however CoordinatorResource loadstatus api call has this problem too, so it would probably be ok to fix both in a follow-up PR.", "author": "clintropolis", "createdAt": "2020-06-12T03:13:50Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUnloadedSegments = 0;\n+      for (DataSegment segment : segments.get()) {\n+        if (!segmentLoadInfos.containsKey(segment.getId())) {\n+          numUnloadedSegments++;\n+        }\n+      }\n+      return Response.ok(\n+          ImmutableMap.of(\n+              dataSourceName,\n+              numUnloadedSegments\n+          )\n+      ).build();\n+    } else if (full != null) {\n+      // Calculate resposne for full mode\n+      final Map<String, Object2LongMap<String>> underReplicationCountsPerDataSourcePerTier = new HashMap<>();\n+      final List<Rule> rules = metadataRuleManager.getRulesWithDefault(dataSourceName);\n+      final Table<SegmentId, String, Integer> segmentsInCluster = HashBasedTable.create();\n+      final DateTime now = DateTimes.nowUtc();\n+\n+      for (DataSegment segment : segments.get()) {\n+        for (DruidServer druidServer : serverInventoryView.getInventory()) {\n+          String tier = druidServer.getTier();\n+          SegmentId segmentId = segment.getId();\n+          DruidDataSource druidDataSource = druidServer.getDataSource(dataSourceName);\n+          if (druidDataSource != null && druidDataSource.getSegment(segmentId) != null) {\n+            Integer numReplicants = segmentsInCluster.get(segmentId, tier);\n+            if (numReplicants == null) {\n+              numReplicants = 0;\n+            }\n+            segmentsInCluster.put(segmentId, tier, numReplicants + 1);\n+          }\n+        }\n+      }\n+      for (DataSegment segment : segments.get()) {\n+        for (final Rule rule : rules) {\n+          if (!(rule instanceof LoadRule && rule.appliesTo(segment, now))) {", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzQzMQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707431", "bodyText": "Since this is a bug in the original Coordinator loadstatus API. I'll fix this in a follow-up PR", "author": "maytasm", "createdAt": "2020-06-13T04:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NDExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NDc5MQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439184791", "bodyText": "super nit: it would probably be consistent to try to match the terminology that appears in the system segments table, which uses 'published' and 'available' for used and loaded\n\nnumUsedSegments -> numPublishedSegments\nnumUnloadedSegments -> numUnavailableSegments", "author": "clintropolis", "createdAt": "2020-06-12T03:16:50Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUnloadedSegments = 0;\n+      for (DataSegment segment : segments.get()) {\n+        if (!segmentLoadInfos.containsKey(segment.getId())) {\n+          numUnloadedSegments++;\n+        }\n+      }\n+      return Response.ok(\n+          ImmutableMap.of(\n+              dataSourceName,\n+              numUnloadedSegments\n+          )\n+      ).build();\n+    } else if (full != null) {\n+      // Calculate resposne for full mode\n+      final Map<String, Object2LongMap<String>> underReplicationCountsPerDataSourcePerTier = new HashMap<>();\n+      final List<Rule> rules = metadataRuleManager.getRulesWithDefault(dataSourceName);\n+      final Table<SegmentId, String, Integer> segmentsInCluster = HashBasedTable.create();\n+      final DateTime now = DateTimes.nowUtc();\n+\n+      for (DataSegment segment : segments.get()) {\n+        for (DruidServer druidServer : serverInventoryView.getInventory()) {\n+          String tier = druidServer.getTier();\n+          SegmentId segmentId = segment.getId();\n+          DruidDataSource druidDataSource = druidServer.getDataSource(dataSourceName);\n+          if (druidDataSource != null && druidDataSource.getSegment(segmentId) != null) {\n+            Integer numReplicants = segmentsInCluster.get(segmentId, tier);\n+            if (numReplicants == null) {\n+              numReplicants = 0;\n+            }\n+            segmentsInCluster.put(segmentId, tier, numReplicants + 1);\n+          }\n+        }\n+      }\n+      for (DataSegment segment : segments.get()) {\n+        for (final Rule rule : rules) {\n+          if (!(rule instanceof LoadRule && rule.appliesTo(segment, now))) {\n+            continue;\n+          }\n+          ((LoadRule) rule)\n+              .getTieredReplicants()\n+              .forEach((final String tier, final Integer ruleReplicants) -> {\n+                Integer currentReplicantsRetVal = segmentsInCluster.get(segment.getId(), tier);\n+                int currentReplicants = currentReplicantsRetVal == null ? 0 : currentReplicantsRetVal;\n+                Object2LongMap<String> underReplicationPerDataSource = underReplicationCountsPerDataSourcePerTier\n+                    .computeIfAbsent(tier, ignored -> new Object2LongOpenHashMap<>());\n+                ((Object2LongOpenHashMap<String>) underReplicationPerDataSource)\n+                    .addTo(dataSourceName, Math.max(ruleReplicants - currentReplicants, 0));\n+              });\n+          break; // only the first matching rule applies\n+        }\n+      }\n+      return Response.ok(underReplicationCountsPerDataSourcePerTier).build();\n+    } else {\n+      // Calculate resposne for default mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUsedSegments = 0;", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzUyMA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707520", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T04:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NDc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NTM3NA==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439185374", "bodyText": "resposne -> response", "author": "clintropolis", "createdAt": "2020-06-12T03:19:37Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +396,123 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"forceMetadataRefresh\") @Nullable final Boolean forceMetadataRefresh,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;\n+      long currentTimeInMs = System.currentTimeMillis();\n+      theInterval = Intervals.utc(currentTimeInMs - defaultIntervalOffset, currentTimeInMs);\n+    } else {\n+      theInterval = Intervals.of(interval.replace('_', '/'));\n+    }\n+\n+    boolean requiresMetadataStorePoll = forceMetadataRefresh == null ? true : forceMetadataRefresh;\n+\n+    Optional<Iterable<DataSegment>> segments = segmentsMetadataManager.iterateAllUsedNonOvershadowedSegmentsForDatasourceInterval(\n+        dataSourceName,\n+        theInterval,\n+        requiresMetadataStorePoll\n+    );\n+\n+    if (!segments.isPresent()) {\n+      return logAndCreateDataSourceNotFoundResponse(dataSourceName);\n+    }\n+\n+    if (simple != null) {\n+      // Calculate resposne for simple mode\n+      Map<SegmentId, SegmentLoadInfo> segmentLoadInfos = serverInventoryView.getSegmentLoadInfos();\n+      int numUnloadedSegments = 0;\n+      for (DataSegment segment : segments.get()) {\n+        if (!segmentLoadInfos.containsKey(segment.getId())) {\n+          numUnloadedSegments++;\n+        }\n+      }\n+      return Response.ok(\n+          ImmutableMap.of(\n+              dataSourceName,\n+              numUnloadedSegments\n+          )\n+      ).build();\n+    } else if (full != null) {\n+      // Calculate resposne for full mode", "originalCommit": "172ef6ac47e1566ad889d937bd8f12ad170bf4ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzUyNQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r439707525", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-13T04:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE4NTM3NA=="}], "type": "inlineReview"}, {"oid": "6d4db3164bbf3aa06f511426b6208f8273901e0f", "url": "https://github.com/apache/druid/commit/6d4db3164bbf3aa06f511426b6208f8273901e0f", "message": "address comments", "committedDate": "2020-06-13T04:21:49Z", "type": "commit"}, {"oid": "cb39dd2e4e5f3aa5589e67ff84edf10d0afda109", "url": "https://github.com/apache/druid/commit/cb39dd2e4e5f3aa5589e67ff84edf10d0afda109", "message": "fix checkstyle", "committedDate": "2020-06-13T04:28:53Z", "type": "commit"}, {"oid": "409a3926a21c8cbe8deb7a5c8b620d99d93cdfd1", "url": "https://github.com/apache/druid/commit/409a3926a21c8cbe8deb7a5c8b620d99d93cdfd1", "message": "update docs", "committedDate": "2020-06-13T05:01:16Z", "type": "commit"}, {"oid": "bb803cd946dc94d0a8a362c84bf42ce66f3ba9b9", "url": "https://github.com/apache/druid/commit/bb803cd946dc94d0a8a362c84bf42ce66f3ba9b9", "message": "fix tests", "committedDate": "2020-06-13T05:48:30Z", "type": "commit"}, {"oid": "2470e8fa81e483839e8903a6f982c6108c230c8a", "url": "https://github.com/apache/druid/commit/2470e8fa81e483839e8903a6f982c6108c230c8a", "message": "fix doc", "committedDate": "2020-06-15T20:22:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMzA2Mw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r440503063", "bodyText": "I think it's ok that segmentReplicantLookup could potentially be stale since it is only updated on coordinator runs, since the refreshed segment metadata would at least ensure that the stale data would be under counting replication levels, rather than potentially falsely reporting that everything is available (when forcing refresh).", "author": "clintropolis", "createdAt": "2020-06-15T23:35:02Z", "path": "server/src/main/java/org/apache/druid/server/coordinator/DruidCoordinator.java", "diffHunk": "@@ -256,15 +256,24 @@ public boolean isLeader()\n    * @return tier -> { dataSource -> underReplicationCount } map\n    */\n   public Map<String, Object2LongMap<String>> computeUnderReplicationCountsPerDataSourcePerTier()\n+  {\n+    final Iterable<DataSegment> dataSegments = segmentsMetadataManager.iterateAllUsedSegments();\n+    return computeUnderReplicationCountsPerDataSourcePerTierForSegments(dataSegments);\n+  }\n+\n+  /**\n+   * @return tier -> { dataSource -> underReplicationCount } map\n+   */\n+  public Map<String, Object2LongMap<String>> computeUnderReplicationCountsPerDataSourcePerTierForSegments(", "originalCommit": "2470e8fa81e483839e8903a6f982c6108c230c8a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU0MTk0OQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r440541949", "bodyText": "Keeping the segmentReplicantLookup as possibly stale for now. This still ensures that we will never return true (available) when it\u2019s false (not available) since we force refresh metadata. Although we can return false (not available) when it\u2019s true (available) for up to a period of coordinator run longer for the full format response. This problem will only affects the full format. We can loop back to this if we find that having the option to force refresh the  segmentReplicantLookup is useful. If that is the case then we can use the existing query param, forceMetadataRefresh, to force refresh segmentReplicantLookup too.", "author": "maytasm", "createdAt": "2020-06-16T01:55:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUwMzA2Mw=="}], "type": "inlineReview"}, {"oid": "cb9f160d0331574fe112ca2467a9518cff5302b5", "url": "https://github.com/apache/druid/commit/cb9f160d0331574fe112ca2467a9518cff5302b5", "message": "address comments", "committedDate": "2020-06-16T01:52:26Z", "type": "commit"}, {"oid": "79acb14fe87c15c3cb795b83476a8f497917ddb0", "url": "https://github.com/apache/druid/commit/79acb14fe87c15c3cb795b83476a8f497917ddb0", "message": "fix typo", "committedDate": "2020-06-16T02:04:02Z", "type": "commit"}, {"oid": "afac4fd572a0b1fa4fd0439c98d61c3f19524f7f", "url": "https://github.com/apache/druid/commit/afac4fd572a0b1fa4fd0439c98d61c3f19524f7f", "message": "fix spelling", "committedDate": "2020-06-16T03:46:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0NTI0MQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441145241", "bodyText": "typo: alrady -> already", "author": "jihoonson", "createdAt": "2020-06-16T21:12:43Z", "path": "server/src/main/java/org/apache/druid/metadata/SqlSegmentsMetadataManager.java", "diffHunk": "@@ -403,11 +427,17 @@ private void awaitOrPerformDatabasePoll()\n   }\n \n   /**\n-   * If the latest {@link DatabasePoll} is a {@link PeriodicDatabasePoll}, or an {@link OnDemandDatabasePoll} that is\n-   * made not longer than {@link #periodicPollDelay} from now, awaits for it and returns true; returns false otherwise,\n-   * meaning that a new on-demand database poll should be initiated.\n+   * This method returns true without waiting for database poll if the latest {@link DatabasePoll} is a\n+   * {@link PeriodicDatabasePoll} that has completed it's first poll, or an {@link OnDemandDatabasePoll} that is\n+   * made not longer than {@link #periodicPollDelay} from current time.\n+   * This method does wait untill completion for if the latest {@link DatabasePoll} is a\n+   * {@link PeriodicDatabasePoll} that has not completed it's first poll, or an {@link OnDemandDatabasePoll} that is\n+   * alrady in the process of polling the database.", "originalCommit": "afac4fd572a0b1fa4fd0439c98d61c3f19524f7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyNjgxMQ==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441226811", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-17T01:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE0NTI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1Nzk4Mw==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441157983", "bodyText": "Could be defined as a static final.", "author": "jihoonson", "createdAt": "2020-06-16T21:40:19Z", "path": "server/src/main/java/org/apache/druid/server/http/DataSourcesResource.java", "diffHunk": "@@ -391,6 +397,131 @@ public Response getServedSegmentsInInterval(\n     return getServedSegmentsInInterval(dataSourceName, full != null, theInterval::contains);\n   }\n \n+  @GET\n+  @Path(\"/{dataSourceName}/loadstatus\")\n+  @Produces(MediaType.APPLICATION_JSON)\n+  @ResourceFilters(DatasourceResourceFilter.class)\n+  public Response getDatasourceLoadstatus(\n+      @PathParam(\"dataSourceName\") String dataSourceName,\n+      @QueryParam(\"forceMetadataRefresh\") final Boolean forceMetadataRefresh,\n+      @QueryParam(\"interval\") @Nullable final String interval,\n+      @QueryParam(\"simple\") @Nullable final String simple,\n+      @QueryParam(\"full\") @Nullable final String full\n+  )\n+  {\n+    if (forceMetadataRefresh == null) {\n+      return Response\n+          .status(Response.Status.BAD_REQUEST)\n+          .entity(\"Invalid request. forceMetadataRefresh must be specified\")\n+          .build();\n+    }\n+    final Interval theInterval;\n+    if (interval == null) {\n+      long defaultIntervalOffset = 14 * 24 * 60 * 60 * 1000;", "originalCommit": "afac4fd572a0b1fa4fd0439c98d61c3f19524f7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIyNzA4Mg==", "url": "https://github.com/apache/druid/pull/9965#discussion_r441227082", "bodyText": "Done", "author": "maytasm", "createdAt": "2020-06-17T01:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE1Nzk4Mw=="}], "type": "inlineReview"}, {"oid": "fc77cc07dc22ec86e73961b582893750ca4bb8da", "url": "https://github.com/apache/druid/commit/fc77cc07dc22ec86e73961b582893750ca4bb8da", "message": "address comments", "committedDate": "2020-06-17T01:39:32Z", "type": "commit"}, {"oid": "7b64a1aeda61c183baa42bbd9961b51511e63064", "url": "https://github.com/apache/druid/commit/7b64a1aeda61c183baa42bbd9961b51511e63064", "message": "address comments", "committedDate": "2020-06-17T01:46:18Z", "type": "commit"}, {"oid": "65b60febe9e02f7ca44991aadf2fcf9fb2ab6094", "url": "https://github.com/apache/druid/commit/65b60febe9e02f7ca44991aadf2fcf9fb2ab6094", "message": "fix typo in docs", "committedDate": "2020-06-17T04:52:11Z", "type": "commit"}]}