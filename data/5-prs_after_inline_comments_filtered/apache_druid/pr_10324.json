{"pr_number": 10324, "pr_title": "SQL support for union datasources.", "pr_createdAt": "2020-08-26T22:16:38Z", "pr_url": "https://github.com/apache/druid/pull/10324", "timeline": [{"oid": "80502217e4eaf32ceaf360df2db1a51c3eb66c14", "url": "https://github.com/apache/druid/commit/80502217e4eaf32ceaf360df2db1a51c3eb66c14", "message": "SQL support for union datasources.\n\nExposed via the \"UNION ALL\" operator. This means that there are now two\ndifferent implementations of UNION ALL: one at the top level of a query\nthat works by concatenating subquery results, and one at the table level\nthat works by creating a UnionDataSource.\n\nThe SQL documentation is updated to discuss these two use cases and how\nthey behave.\n\nFuture work could unify these by building support for a native datasource\nthat represents the union of multiple subqueries. (Today, UnionDataSource\ncan only represent the union of tables, not subqueries.)", "committedDate": "2020-08-26T22:20:29Z", "type": "commit"}, {"oid": "80502217e4eaf32ceaf360df2db1a51c3eb66c14", "url": "https://github.com/apache/druid/commit/80502217e4eaf32ceaf360df2db1a51c3eb66c14", "message": "SQL support for union datasources.\n\nExposed via the \"UNION ALL\" operator. This means that there are now two\ndifferent implementations of UNION ALL: one at the top level of a query\nthat works by concatenating subquery results, and one at the table level\nthat works by creating a UnionDataSource.\n\nThe SQL documentation is updated to discuss these two use cases and how\nthey behave.\n\nFuture work could unify these by building support for a native datasource\nthat represents the union of multiple subqueries. (Today, UnionDataSource\ncan only represent the union of tables, not subqueries.)", "committedDate": "2020-08-26T22:20:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1MDgzMQ==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478250831", "bodyText": "nit: adding an error message will be helpful.", "author": "abhishekagarwal87", "createdAt": "2020-08-27T08:35:20Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel);", "originalCommit": "80502217e4eaf32ceaf360df2db1a51c3eb66c14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwNzU5Nw==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478507597", "bodyText": "I added a message.", "author": "gianm", "createdAt": "2020-08-27T15:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1MDgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2MTk3Mg==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478561972", "bodyText": "Thanks. There are a few more places which I have highlighted.", "author": "abhishekagarwal87", "createdAt": "2020-08-27T16:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1MDgzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNDk0NQ==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478724945", "bodyText": "Those all make sense; I added some messages.", "author": "gianm", "createdAt": "2020-08-27T22:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1MDgzMQ=="}], "type": "inlineReview"}, {"oid": "f57e18d6ca7b4e03affa41c1e62080cb600ea880", "url": "https://github.com/apache/druid/commit/f57e18d6ca7b4e03affa41c1e62080cb600ea880", "message": "Fixes.", "committedDate": "2020-08-27T15:28:44Z", "type": "commit"}, {"oid": "87a01867a002df369bacbb1f3cf27ddbb80072a8", "url": "https://github.com/apache/druid/commit/87a01867a002df369bacbb1f3cf27ddbb80072a8", "message": "Error message for sanity check.", "committedDate": "2020-08-27T15:29:33Z", "type": "commit"}, {"oid": "a6c8c9bc45ac239f8543203ee73984026509196a", "url": "https://github.com/apache/druid/commit/a6c8c9bc45ac239f8543203ee73984026509196a", "message": "Additional test fixes.", "committedDate": "2020-08-27T15:40:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1OTg3OA==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478559878", "bodyText": "if this ever happens, an exception containing the actual stage name will be useful in debugging.", "author": "abhishekagarwal87", "createdAt": "2020-08-27T16:51:25Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel, \"Expected first rel to be a DruidQueryRel\");\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              unionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    }\n+  }\n+\n+  private static boolean isUnionCompatible(final DruidRel<?> first, final DruidRel<?> second)\n+  {\n+    final Optional<List<String>> columnNames = getColumnNamesIfTableOrUnion(first);\n+    return columnNames.isPresent() && columnNames.equals(getColumnNamesIfTableOrUnion(second));\n+  }\n+\n+  static Optional<List<String>> getColumnNamesIfTableOrUnion(final DruidRel<?> druidRel)\n+  {\n+    final PartialDruidQuery partialQuery = druidRel.getPartialDruidQuery();\n+\n+    final Optional<DruidTable> druidTable =\n+        DruidRels.druidTableIfLeafRel(druidRel)\n+                 .filter(table -> table.getDataSource() instanceof TableDataSource);\n+\n+    if (druidTable.isPresent() && DruidRels.isScanOrMapping(druidRel, false)) {\n+      // This rel is a table scan or mapping.\n+\n+      if (partialQuery.stage() == PartialDruidQuery.Stage.SCAN) {\n+        return Optional.of(druidTable.get().getRowSignature().getColumnNames());\n+      } else {\n+        // Sanity check. Expected to be true due to the \"scan or mapping\" check.\n+        Preconditions.checkState(partialQuery.stage() == PartialDruidQuery.Stage.SELECT_PROJECT);", "originalCommit": "a6c8c9bc45ac239f8543203ee73984026509196a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1OTk3Mg==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478559972", "bodyText": "same comment here. will be useful to know both the table signature size as well as source count.", "author": "abhishekagarwal87", "createdAt": "2020-08-27T16:51:36Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel, \"Expected first rel to be a DruidQueryRel\");\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              unionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    }\n+  }\n+\n+  private static boolean isUnionCompatible(final DruidRel<?> first, final DruidRel<?> second)\n+  {\n+    final Optional<List<String>> columnNames = getColumnNamesIfTableOrUnion(first);\n+    return columnNames.isPresent() && columnNames.equals(getColumnNamesIfTableOrUnion(second));\n+  }\n+\n+  static Optional<List<String>> getColumnNamesIfTableOrUnion(final DruidRel<?> druidRel)\n+  {\n+    final PartialDruidQuery partialQuery = druidRel.getPartialDruidQuery();\n+\n+    final Optional<DruidTable> druidTable =\n+        DruidRels.druidTableIfLeafRel(druidRel)\n+                 .filter(table -> table.getDataSource() instanceof TableDataSource);\n+\n+    if (druidTable.isPresent() && DruidRels.isScanOrMapping(druidRel, false)) {\n+      // This rel is a table scan or mapping.\n+\n+      if (partialQuery.stage() == PartialDruidQuery.Stage.SCAN) {\n+        return Optional.of(druidTable.get().getRowSignature().getColumnNames());\n+      } else {\n+        // Sanity check. Expected to be true due to the \"scan or mapping\" check.\n+        Preconditions.checkState(partialQuery.stage() == PartialDruidQuery.Stage.SELECT_PROJECT);\n+\n+        // Apply the mapping (with additional sanity checks).\n+        final RowSignature tableSignature = druidTable.get().getRowSignature();\n+        final Mappings.TargetMapping mapping = partialQuery.getSelectProject().getMapping();\n+        Preconditions.checkState(mapping.getSourceCount() == tableSignature.size());", "originalCommit": "a6c8c9bc45ac239f8543203ee73984026509196a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2MDM2Mg==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478560362", "bodyText": "maybe add the class name of firstDruidRel in exception message?", "author": "abhishekagarwal87", "createdAt": "2020-08-27T16:52:17Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel, \"Expected first rel to be a DruidQueryRel\");", "originalCommit": "a6c8c9bc45ac239f8543203ee73984026509196a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6", "url": "https://github.com/apache/druid/commit/9226a449b9cdafadc583bab883f094bdbe182ed6", "message": "Add some error messages.", "committedDate": "2020-08-27T22:13:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczNzk1Ng==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478737956", "bodyText": "nit: this could be an else if of the previous if that assigns signature if it was previously null", "author": "clintropolis", "createdAt": "2020-08-27T22:51:06Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidUnionDataSourceRel.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.query.UnionDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.table.RowSignatures;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents a query on top of a {@link UnionDataSource}. This is used to represent a \"UNION ALL\" of regular table\n+ * datasources.\n+ *\n+ * See {@link DruidUnionRel} for a version that can union any set of queries together (not just regular tables),\n+ * but also must be the outermost rel of a query plan. In the future we expect that {@link UnionDataSource} will gain\n+ * the ability to union query datasources together, and then this class could replace {@link DruidUnionRel}.\n+ */\n+public class DruidUnionDataSourceRel extends DruidRel<DruidUnionDataSourceRel>\n+{\n+  private static final TableDataSource DUMMY_DATA_SOURCE = new TableDataSource(\"__union__\");\n+\n+  private final Union unionRel;\n+  private final List<String> unionColumnNames;\n+  private final PartialDruidQuery partialQuery;\n+\n+  private DruidUnionDataSourceRel(\n+      final RelOptCluster cluster,\n+      final RelTraitSet traitSet,\n+      final Union unionRel,\n+      final List<String> unionColumnNames,\n+      final PartialDruidQuery partialQuery,\n+      final QueryMaker queryMaker\n+  )\n+  {\n+    super(cluster, traitSet, queryMaker);\n+    this.unionRel = unionRel;\n+    this.unionColumnNames = unionColumnNames;\n+    this.partialQuery = partialQuery;\n+  }\n+\n+  public static DruidUnionDataSourceRel create(\n+      final Union unionRel,\n+      final List<String> unionColumnNames,\n+      final QueryMaker queryMaker\n+  )\n+  {\n+    return new DruidUnionDataSourceRel(\n+        unionRel.getCluster(),\n+        unionRel.getTraitSet(),\n+        unionRel,\n+        unionColumnNames,\n+        PartialDruidQuery.create(unionRel),\n+        queryMaker\n+    );\n+  }\n+\n+  public List<String> getUnionColumnNames()\n+  {\n+    return unionColumnNames;\n+  }\n+\n+  @Override\n+  public PartialDruidQuery getPartialDruidQuery()\n+  {\n+    return partialQuery;\n+  }\n+\n+  @Override\n+  public DruidUnionDataSourceRel withPartialQuery(final PartialDruidQuery newQueryBuilder)\n+  {\n+    return new DruidUnionDataSourceRel(\n+        getCluster(),\n+        getTraitSet().plusAll(newQueryBuilder.getRelTraits()),\n+        unionRel,\n+        unionColumnNames,\n+        newQueryBuilder,\n+        getQueryMaker()\n+    );\n+  }\n+\n+  @Override\n+  public Sequence<Object[]> runQuery()\n+  {\n+    // runQuery doesn't need to finalize aggregations, because the fact that runQuery is happening suggests this\n+    // is the outermost query and it will actually get run as a native query. Druid's native query layer will\n+    // finalize aggregations for the outermost query even if we don't explicitly ask it to.\n+\n+    return getQueryMaker().runQuery(toDruidQuery(false));\n+  }\n+\n+  @Override\n+  public DruidQuery toDruidQuery(final boolean finalizeAggregations)\n+  {\n+    final List<TableDataSource> dataSources = new ArrayList<>();\n+    RowSignature signature = null;\n+\n+    for (final RelNode relNode : unionRel.getInputs()) {\n+      final DruidRel<?> druidRel = (DruidRel<?>) relNode;\n+      if (!DruidRels.isScanOrMapping(druidRel, false)) {\n+        throw new CannotBuildQueryException(druidRel);\n+      }\n+\n+      final DruidQuery query = druidRel.toDruidQuery(false);\n+      final DataSource dataSource = query.getDataSource();\n+      if (!(dataSource instanceof TableDataSource)) {\n+        throw new CannotBuildQueryException(druidRel);\n+      }\n+\n+      if (signature == null) {\n+        signature = query.getOutputRowSignature();\n+      }\n+\n+      if (signature.getColumnNames().equals(query.getOutputRowSignature().getColumnNames())) {", "originalCommit": "9226a449b9cdafadc583bab883f094bdbe182ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDM1MA==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478740350", "bodyText": "nit: would the signatures themselves rather than the count be more useful?", "author": "clintropolis", "createdAt": "2020-08-27T22:58:09Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.java.util.common.ISE;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      if (!(firstDruidRel instanceof DruidQueryRel)) {\n+        throw new ISE(\"Expected first rel to be a DruidQueryRel, but it was %s\", firstDruidRel.getClass().getName());\n+      }\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              unionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    }\n+  }\n+\n+  private static boolean isUnionCompatible(final DruidRel<?> first, final DruidRel<?> second)\n+  {\n+    final Optional<List<String>> columnNames = getColumnNamesIfTableOrUnion(first);\n+    return columnNames.isPresent() && columnNames.equals(getColumnNamesIfTableOrUnion(second));\n+  }\n+\n+  static Optional<List<String>> getColumnNamesIfTableOrUnion(final DruidRel<?> druidRel)\n+  {\n+    final PartialDruidQuery partialQuery = druidRel.getPartialDruidQuery();\n+\n+    final Optional<DruidTable> druidTable =\n+        DruidRels.druidTableIfLeafRel(druidRel)\n+                 .filter(table -> table.getDataSource() instanceof TableDataSource);\n+\n+    if (druidTable.isPresent() && DruidRels.isScanOrMapping(druidRel, false)) {\n+      // This rel is a table scan or mapping.\n+\n+      if (partialQuery.stage() == PartialDruidQuery.Stage.SCAN) {\n+        return Optional.of(druidTable.get().getRowSignature().getColumnNames());\n+      } else {\n+        // Sanity check. Expected to be true due to the \"scan or mapping\" check.\n+        if (partialQuery.stage() != PartialDruidQuery.Stage.SELECT_PROJECT) {\n+          throw new ISE(\"Expected stage %s but got %s\", PartialDruidQuery.Stage.SELECT_PROJECT, partialQuery.stage());\n+        }\n+\n+        // Apply the mapping (with additional sanity checks).\n+        final RowSignature tableSignature = druidTable.get().getRowSignature();\n+        final Mappings.TargetMapping mapping = partialQuery.getSelectProject().getMapping();\n+\n+        if (mapping.getSourceCount() != tableSignature.size()) {\n+          throw new ISE(\n+              \"Expected mapping with %d columns but got %d columns\",", "originalCommit": "9226a449b9cdafadc583bab883f094bdbe182ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2MzEwMA==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478763100", "bodyText": "Perhaps, but so would the entire query, and you gotta stop somewhere.", "author": "gianm", "createdAt": "2020-08-28T00:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NTAzMA==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478745030", "bodyText": "nit: I wonder if the instanceof checks here are something that should be pushed into a couple of methods on DruidRel (one to check if is scan/projection one to check if is 'external' (or is there a better word?) scan/projection for join/union)", "author": "clintropolis", "createdAt": "2020-08-27T23:12:14Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRels.java", "diffHunk": "@@ -59,12 +59,14 @@ public static boolean isScanOrMapping(final DruidRel<?> druidRel, final boolean\n   /**\n    * Check if a druidRel is a simple table scan or a scan + projection.\n    *\n-   * @param druidRel  the rel to check\n-   * @param canBeJoin consider a 'join' that doesn't do anything fancy to be a scan-or-mapping too.\n+   * @param druidRel         the rel to check\n+   * @param canBeJoinOrUnion consider a {@link DruidJoinQueryRel} or {@link DruidUnionDataSourceRel} as possible\n+   *                         scans-and-mappings too.\n    */\n-  private static boolean isScanOrProject(final DruidRel<?> druidRel, final boolean canBeJoin)\n+  private static boolean isScanOrProject(final DruidRel<?> druidRel, final boolean canBeJoinOrUnion)\n   {\n-    if (druidRel instanceof DruidQueryRel || (canBeJoin && druidRel instanceof DruidJoinQueryRel)) {\n+    if (druidRel instanceof DruidQueryRel || (canBeJoinOrUnion && (druidRel instanceof DruidJoinQueryRel", "originalCommit": "9226a449b9cdafadc583bab883f094bdbe182ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2MzgxNg==", "url": "https://github.com/apache/druid/pull/10324#discussion_r478763816", "bodyText": "You might be right. I have a sneaking suspicion that we'll want to redesign the DruidRel interface at some point. I was thinking we could rethink it when we create a native datasource that represents a union of queries, which would allow us to merge the two UNION ALL implementations in SQL, which would allow a single-SQL-query-to-single-native-query mapping. That would simplify a lot of stuff and would be a good catalyst for rethinking the interface.", "author": "gianm", "createdAt": "2020-08-28T00:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NTAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzMTkwMw==", "url": "https://github.com/apache/druid/pull/10324#discussion_r562431903", "bodyText": "Hi, is there a particular reason firstDruidRel is of DruidRel<?> but secondDruidRel is DruidQueryRel?\nHaving it DruidQueryRel creates issues with top level UNION ALL when the second rel contains a subquery.\nOn the same PR, matches(RelOptRuleCall call) in DruidJoinRule.java has both parts typed as DruidRel<?>\nI don't know if it's appropriate to discuss findings in closed PR, but as my issue is completely confined with changes specified here, I took the liberty to discuss them.", "author": "laserscout", "createdAt": "2021-01-22T07:19:08Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.java.util.common.ISE;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }", "originalCommit": "9226a449b9cdafadc583bab883f094bdbe182ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzMjM5MQ==", "url": "https://github.com/apache/druid/pull/10324#discussion_r562432391", "bodyText": "@gianm @clintropolis I would very much value your input here.\nThanks a lot!", "author": "laserscout", "createdAt": "2021-01-22T07:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzMTkwMw=="}], "type": "inlineReview"}]}