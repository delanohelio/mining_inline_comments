{"pr_number": 10370, "pr_title": "add computed Expr output types", "pr_createdAt": "2020-09-09T01:45:37Z", "pr_url": "https://github.com/apache/druid/pull/10370", "timeline": [{"oid": "834cb13aeb531a60685ce9eb270894e74a5201c3", "url": "https://github.com/apache/druid/commit/834cb13aeb531a60685ce9eb270894e74a5201c3", "message": "push down ValueType to ExprType conversion, tidy up", "committedDate": "2020-09-08T07:46:52Z", "type": "commit"}, {"oid": "472918e282c5787dbaa801d85ea6c052e2e29c8a", "url": "https://github.com/apache/druid/commit/472918e282c5787dbaa801d85ea6c052e2e29c8a", "message": "determine expr output type for given input types", "committedDate": "2020-09-09T00:57:36Z", "type": "commit"}, {"oid": "28c058816d50d40c90222d93a937257fafc72f1b", "url": "https://github.com/apache/druid/commit/28c058816d50d40c90222d93a937257fafc72f1b", "message": "revert unintended name change", "committedDate": "2020-09-09T01:01:08Z", "type": "commit"}, {"oid": "57282df134152becec26e1ae964f28b6159bdedb", "url": "https://github.com/apache/druid/commit/57282df134152becec26e1ae964f28b6159bdedb", "message": "add nullable", "committedDate": "2020-09-09T01:26:21Z", "type": "commit"}, {"oid": "3b5a1fe7deb737304ad242605193c6ea3d884ae6", "url": "https://github.com/apache/druid/commit/3b5a1fe7deb737304ad242605193c6ea3d884ae6", "message": "tidy up", "committedDate": "2020-09-09T01:32:08Z", "type": "commit"}, {"oid": "8fc125358d0f894b9d124414b464c4e212cef92d", "url": "https://github.com/apache/druid/commit/8fc125358d0f894b9d124414b464c4e212cef92d", "message": "fixup", "committedDate": "2020-09-09T01:36:21Z", "type": "commit"}, {"oid": "2c6fc87c5a0361363914a8f1ea1ef46403fd4e6e", "url": "https://github.com/apache/druid/commit/2c6fc87c5a0361363914a8f1ea1ef46403fd4e6e", "message": "more better", "committedDate": "2020-09-09T02:27:50Z", "type": "commit"}, {"oid": "c36afdfea33cdffc6182ecf07f7317ad7c21b870", "url": "https://github.com/apache/druid/commit/c36afdfea33cdffc6182ecf07f7317ad7c21b870", "message": "fix signatures", "committedDate": "2020-09-09T02:32:41Z", "type": "commit"}, {"oid": "d2d7f9ad249d1189c121958726fa9b38d87ca886", "url": "https://github.com/apache/druid/commit/d2d7f9ad249d1189c121958726fa9b38d87ca886", "message": "naming things is hard", "committedDate": "2020-09-09T03:52:39Z", "type": "commit"}, {"oid": "8d64ecce0e8cc4a683c81cfbaf78b4aedcf2cbdb", "url": "https://github.com/apache/druid/commit/8d64ecce0e8cc4a683c81cfbaf78b4aedcf2cbdb", "message": "fix inspection", "committedDate": "2020-09-09T06:57:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyMzI0NQ==", "url": "https://github.com/apache/druid/pull/10370#discussion_r485423245", "bodyText": "shouldn't it instead throw an exception?", "author": "abhishekagarwal87", "createdAt": "2020-09-09T08:14:44Z", "path": "core/src/main/java/org/apache/druid/math/expr/ExprType.java", "diffHunk": "@@ -29,5 +35,116 @@\n   STRING,\n   DOUBLE_ARRAY,\n   LONG_ARRAY,\n-  STRING_ARRAY\n+  STRING_ARRAY;\n+\n+  public boolean isNumeric()\n+  {\n+    return isNumeric(this);\n+  }\n+\n+  /**\n+   * The expression system does not distinguish between {@link ValueType#FLOAT} and {@link ValueType#DOUBLE}, and\n+   * cannot currently handle {@link ValueType#COMPLEX} inputs. This method will convert {@link ValueType#FLOAT} to\n+   * {@link #DOUBLE}, or throw an exception if a {@link ValueType#COMPLEX} is encountered.\n+   *\n+   * @throws IllegalStateException\n+   */\n+  public static ExprType fromValueType(@Nullable ValueType valueType)\n+  {\n+    if (valueType == null) {\n+      throw new IllegalStateException(\"Unsupported unknown value type\");\n+    }\n+    switch (valueType) {\n+      case LONG:\n+        return LONG;\n+      case LONG_ARRAY:\n+        return LONG_ARRAY;\n+      case FLOAT:\n+      case DOUBLE:\n+        return DOUBLE;\n+      case DOUBLE_ARRAY:\n+        return DOUBLE_ARRAY;\n+      case STRING:\n+        return STRING;\n+      case STRING_ARRAY:\n+        return STRING_ARRAY;\n+      case COMPLEX:\n+      default:\n+        throw new ISE(\"Unsupported value type[%s]\", valueType);\n+    }\n+  }\n+\n+  public static boolean isNumeric(ExprType type)\n+  {\n+    return LONG.equals(type) || DOUBLE.equals(type);\n+  }\n+\n+  public static boolean isArray(@Nullable ExprType type)\n+  {\n+    return LONG_ARRAY.equals(type) || DOUBLE_ARRAY.equals(type) || STRING_ARRAY.equals(type);\n+  }\n+\n+  @Nullable\n+  public static ExprType elementType(@Nullable ExprType type)\n+  {\n+    if (type != null && isArray(type)) {\n+      switch (type) {\n+        case STRING_ARRAY:\n+          return STRING;\n+        case LONG_ARRAY:\n+          return LONG;\n+        case DOUBLE_ARRAY:\n+          return DOUBLE;\n+      }\n+    }\n+    return type;\n+  }\n+\n+  @Nullable\n+  public static ExprType asArrayType(@Nullable ExprType elementType)\n+  {\n+    if (elementType != null && !isArray(elementType)) {\n+      switch (elementType) {\n+        case STRING:\n+          return STRING_ARRAY;\n+        case LONG:\n+          return LONG_ARRAY;\n+        case DOUBLE:\n+          return DOUBLE_ARRAY;\n+      }\n+    }\n+    return elementType;\n+  }\n+\n+  @Nullable\n+  public static ExprType implicitCast(@Nullable ExprType type, @Nullable ExprType other)\n+  {\n+    if (type == null || other == null) {\n+      // cannot implicitly cast unknown types\n+      return null;\n+    }\n+    // arrays cannot be implicitly cast\n+    if (isArray(type)) {\n+      if (!type.equals(other)) {\n+        throw new IAE(\"Cannot implicitly cast %s to %s\", type, other);\n+      }\n+      return type;\n+    }\n+    // if either argument is a string, type becomes a string\n+    if (STRING.equals(type) || STRING.equals(other)) {\n+      return STRING;\n+    }\n+\n+    if (isNumeric(type) && isNumeric(other)) {\n+      // all numbers win over longs\n+      if (LONG.equals(type)) {\n+        return other;\n+      }\n+      // floats vs longs would be handled here, but we currently only support doubles...\n+      return type;\n+    }\n+\n+    // unhandled is unknown\n+    return null;", "originalCommit": "8d64ecce0e8cc4a683c81cfbaf78b4aedcf2cbdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4OTY4MQ==", "url": "https://github.com/apache/druid/pull/10370#discussion_r485989681", "bodyText": "Maybe? This case can't actually happen right now, all cases are actually covered in previous clauses so this line should currently never be hit. I was sort of starting to imagine ahead to a world where ExprType and ValueType are unified and things like complex types could appear in a type conversion logic block similar to this. I sort of expect this area of the code to be somewhat volatile in the near future as I work out some things about type handling.\nUsage wise, this method is basically only used to compute the output type given 2 input types, so it at least partially makes sense to return null if we can't determine the output type. I can see an argument for this being an exception as well (as well as either argument being null). implicitCast isn't a great name for this method either, I should probably call it something else, maybe something like implicitTypeConversion or .. something.", "author": "clintropolis", "createdAt": "2020-09-10T00:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyMzI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0MDA4MQ==", "url": "https://github.com/apache/druid/pull/10370#discussion_r487140081", "bodyText": "my thinking is that returning null here would surface as a bug someplace else. but if we throw an exception here itself, its easier to debug. As you said the code is volatile so chances of this path being hit are even higher.", "author": "abhishekagarwal87", "createdAt": "2020-09-11T15:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyMzI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDk5OA==", "url": "https://github.com/apache/druid/pull/10370#discussion_r487150998", "bodyText": "As you said the code is volatile so chances of this path being hit are even higher.\n\nI mean, it's totally not possible to hit this null because there isn't a ExprType combination of input arguments that ends up on this line. By volatile I meant that this enum and file is likely going to go away and maybe this function migrated into ValueType. This line is essentially a placeholder for ValueType.COMPLEX which doesn't exist in ExprType, so I was shaping this method to be straightforward to work off of that enum instead of this one someday.\nI can throw an exception with the messaging 'impossible' if you would prefer, but there isn't a way to actually check it with a test.", "author": "clintropolis", "createdAt": "2020-09-11T16:18:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQyMzI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA0ODQ5MA==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486048490", "bodyText": "javadocs please", "author": "suneet-s", "createdAt": "2020-09-10T03:59:43Z", "path": "core/src/main/java/org/apache/druid/math/expr/ApplyFunction.java", "diffHunk": "@@ -74,6 +75,9 @@ default boolean hasArrayOutput(LambdaExpr lambdaExpr)\n    */\n   void validateArguments(LambdaExpr lambdaExpr, List<Expr> args);\n \n+  @Nullable\n+  ExprType getOutputType(Expr.InputBindingTypes inputTypes, LambdaExpr expr, List<Expr> args);", "originalCommit": "8d64ecce0e8cc4a683c81cfbaf78b4aedcf2cbdb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MDUxOQ==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486050519", "bodyText": "javadocs please", "author": "suneet-s", "createdAt": "2020-09-10T04:08:04Z", "path": "core/src/main/java/org/apache/druid/math/expr/ApplyFunction.java", "diffHunk": "@@ -848,4 +882,32 @@ public CartesianFoldLambdaBinding accumulateWithIndex(int index, Object acc)\n       return this;\n     }\n   }\n+\n+  class LambdaInputBindingTypes implements Expr.InputBindingTypes", "originalCommit": "8d64ecce0e8cc4a683c81cfbaf78b4aedcf2cbdb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MjAwNA==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486052004", "bodyText": "nit: Willl getType be called in a loop anywhere? It might be better to use getOrDefault(..) instead to avoid 2 hashcode computations here (for containsKey and getInt)", "author": "suneet-s", "createdAt": "2020-09-10T04:14:09Z", "path": "core/src/main/java/org/apache/druid/math/expr/ApplyFunction.java", "diffHunk": "@@ -848,4 +882,32 @@ public CartesianFoldLambdaBinding accumulateWithIndex(int index, Object acc)\n       return this;\n     }\n   }\n+\n+  class LambdaInputBindingTypes implements Expr.InputBindingTypes\n+  {\n+    private final Object2IntMap<String> lambdaIdentifiers;\n+    private final Expr.InputBindingTypes inputTypes;\n+    private final List<Expr> args;\n+\n+    public LambdaInputBindingTypes(Expr.InputBindingTypes inputTypes, LambdaExpr expr, List<Expr> args)\n+    {\n+      this.inputTypes = inputTypes;\n+      this.args = args;\n+      List<String> identifiers = expr.getIdentifiers();\n+      this.lambdaIdentifiers = new Object2IntOpenHashMap<>(args.size());\n+      for (int i = 0; i < args.size(); i++) {\n+        lambdaIdentifiers.put(identifiers.get(i), i);\n+      }\n+    }\n+\n+    @Nullable\n+    @Override\n+    public ExprType getType(String name)\n+    {\n+      if (lambdaIdentifiers.containsKey(name)) {\n+        return ExprType.elementType(args.get(lambdaIdentifiers.getInt(name)).getOutputType(inputTypes));", "originalCommit": "8d64ecce0e8cc4a683c81cfbaf78b4aedcf2cbdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzNDc4Nw==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486634787", "bodyText": "It shouldn't be called in any sort of hot loop. The eventual usage of this information is so that this happens during a sort of planning phase that is checking to see if it we can make a strongly typed and optimized expression evaluator to use instead of the default.", "author": "clintropolis", "createdAt": "2020-09-10T21:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1MjAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1NTE3NQ==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486055175", "bodyText": "Looking at how this function works got me thinking about some stuff... Does this function need to be in sync with the behavior in BinaryEvalOpExprBase#eval (I think so \ud83e\udd14) Since the eval method isn't implemented here, would it be better to implement it in BinaryEvalOpExprBase?\nCan you explain how getOutputType would deal with default null handling mode.\nAlso, what does it mean to have an output type of null?", "author": "suneet-s", "createdAt": "2020-09-10T04:27:08Z", "path": "core/src/main/java/org/apache/druid/math/expr/BinaryLogicalOperatorExpr.java", "diffHunk": "@@ -57,6 +57,17 @@ protected final double evalDouble(double left, double right)\n     // Use Double.compare for more consistent NaN handling.\n     return Evals.asDouble(Double.compare(left, right) < 0);\n   }\n+\n+  @Nullable\n+  @Override\n+  public ExprType getOutputType(InputBindingTypes inputTypes)\n+  {\n+    ExprType implicitCast = super.getOutputType(inputTypes);\n+    if (ExprType.STRING.equals(implicitCast)) {\n+      return ExprType.LONG;\n+    }\n+    return implicitCast;", "originalCommit": "8d64ecce0e8cc4a683c81cfbaf78b4aedcf2cbdb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNzUxMg==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486627512", "bodyText": "Looking at how this function works got me thinking about some stuff... Does this function need to be in sync with the behavior in BinaryEvalOpExprBase#eval (I think so \ud83e\udd14) Since the eval method isn't implemented here, would it be better to implement it in BinaryEvalOpExprBase?\n\nYeah, the behavior of getOutputType should always match the behavior of eval. In this case, it can't really be pushed down because the math operators also implement BinaryEvalOpExprBase, but do not handle string inputs as numerical outputs. We could put another type in between these logical operators and BinaryEvalOpExprBase that provides it though, I will consider doing that.\n\nCan you explain how getOutputType would deal with default null handling mode.\n\ngetOutputType should be fully independent of how druid.generic.useDefaultValueForNull is set since it does not capture (currently) whether or not nulls can happen.\n\nAlso, what does it mean to have an output type of null?\n\nAn output type of null signifies that we couldn't compute what the output type is, most likely because input type information isn't available. When the input to the expressions are actual segments (QueryableIndexStorageAdapter) then type information should always be available, and a null signifies an input that doesn't exist, but other adapters (and other usages of Expr such as for transforms) might not always have complete type information.\nI will add all of this stuff to the javadocs.", "author": "clintropolis", "createdAt": "2020-09-10T20:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1NTE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU2NjMyOA==", "url": "https://github.com/apache/druid/pull/10370#discussion_r487566328", "bodyText": "what should be the expected output type here if the left output type is a string and the right output type is a double?\nAs per org.apache.druid.math.expr.BinaryEvalOpExprBase#eval it seems, the runtime output type will be double . As per ExprType.autoTypeConversion it seems to be string.", "author": "abhishekagarwal87", "createdAt": "2020-09-13T19:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1NTE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0MTc1Nw==", "url": "https://github.com/apache/druid/pull/10370#discussion_r487841757", "bodyText": "Good eye, you spotted a thing I was purposefully ignoring because I think it is not really great behavior, or consistent with other math functions. The default behavior for those 2 input math operators is to consider the arguments as doubles as you've noticed, regardless of whether or not they are both doubles. I suspect it is implemented like this to allow null values inputs to still work as zeros in 'default' mode (druid.generic.useDefaultValueForNull=true), because the current expressions are not strongly typed so these nulls all end up as string values. See this comment for a bit more explanation, and this comment for some of the problems that this causes.\nIt is also a bit unintuitive behavior. A string column which contains numeric values will work in one of these math operators, so something like 2.0 + '3.1' = 5.1 works magically. But it will also potentially treat the string value as 0 if the string is not a number in default mode, so 2.0 + 'foo' = 2.0 (or null in sql compatible mode). The math functions (min, max, etc) instead treat either input as string as a 0/null output without evaluating the function.\nI'm not actually sure what the best behavior here is, the math function behavior seems a bit more intuitive to me, where either input being a string produces a null output, so I chose to use that here. This PR is setting up for vectorized expressions, which are going to be strongly typed before processing, which I think makes this inconsistent/confusing/magical behavior not necessary. I was planning to raise a discussion about this part in a future PR since it isn't actually affecting anything yet, but I think it is good to start talking about it even though it isn't wired up to anything yet.\nAlso, I really think 'default' mode complicates the expression system quite a lot. It would be my preference for the expression system to always behave in an SQL compatible manner, and default mode only come into play on the boundaries for data coming in and going out, but I haven't fully thought through the implications of this and it requires some discussion I think, and might be a bit dramatic of a change.", "author": "clintropolis", "createdAt": "2020-09-14T11:30:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1NTE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg2ODE5MQ==", "url": "https://github.com/apache/druid/pull/10370#discussion_r487868191", "bodyText": "so something like 2.0 + '3.1' = 5.1\n\nThat might not have been a great example, this might normal behavior in some other databases \ud83d\ude05. I'm going to have a closer read over https://www.postgresql.org/docs/9.0/typeconv-oper.html and https://www.postgresql.org/docs/9.0/typeconv-func.html and maybe reference some other docs too and see if might make sense to different versions of this implicit conversion function for different contexts.", "author": "clintropolis", "createdAt": "2020-09-14T12:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1NTE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA3NTAyNg==", "url": "https://github.com/apache/druid/pull/10370#discussion_r488075026", "bodyText": "This PR is setting up for vectorized expressions, which are going to be strongly typed before processing, which I think makes this inconsistent/confusing/magical behavior not necessary.\n\ncan you elaborate more on this? How will that look like?\nWhile I understand the right behavior is debatable, it may still be best to keep the type in sync with eval even if it's not very intuitive. It may require that the logic of figuring out the type is not reusable as a function ExprType.autoTypeConversion and may have to be written differently for some operators.  We can, later on, change the different functions, fixing both the eval and getOutputType together. But till then, they will be in sync.", "author": "abhishekagarwal87", "createdAt": "2020-09-14T16:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1NTE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3MjIyMw==", "url": "https://github.com/apache/druid/pull/10370#discussion_r488172223", "bodyText": "can you elaborate more on this? How will that look like?\n\nAh, its going to be based on using these methods, just the processors will be specialized to deal with the correct type based on the set of input types. Since the output type information isn't used for non-vectorized expressions, I'm trying to model this as the change I want to see in the world and will ensure that this matches the behavior of the vectorized expressions, but I've gone ahead and split operator from function auto conversion and changed it to match existing behavior for now in case it is necessary, and can always consolidate them again in the future.", "author": "clintropolis", "createdAt": "2020-09-14T19:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1NTE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNDkxNQ==", "url": "https://github.com/apache/druid/pull/10370#discussion_r488324915", "bodyText": "I'm going to merge this PR, but we can continue this discussion in the next one, so this stuff can actually be tied into things in a concrete manner. Looking at postgres, its math functions do, at least somewhat, allow for implicit conversion of sting numbers to numbers. So 2.0 + '3.1' = 5.1 and cos('1') work, but '2.0' + '3.1' does not. In druid  currently the first would have the same behavior as postgres, but the 2nd would be null or 0 depending on the value of druid.generic.useDefaultValueForNull, while the 3rd expression would do string concatenation.", "author": "clintropolis", "createdAt": "2020-09-15T01:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1NTE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQzMTkzMA==", "url": "https://github.com/apache/druid/pull/10370#discussion_r488431930", "bodyText": "Thanks @clintropolis", "author": "abhishekagarwal87", "createdAt": "2020-09-15T07:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1NTE3NQ=="}], "type": "inlineReview"}, {"oid": "ee4306cfecf643fe2a7d3fce4d8386b41b1af785", "url": "https://github.com/apache/druid/commit/ee4306cfecf643fe2a7d3fce4d8386b41b1af785", "message": "javadoc", "committedDate": "2020-09-10T21:50:12Z", "type": "commit"}, {"oid": "b09b24d9ff6addcb0bb6dab22c83a72cd85c8969", "url": "https://github.com/apache/druid/commit/b09b24d9ff6addcb0bb6dab22c83a72cd85c8969", "message": "make default implementation of Expr.getOutputType that returns null", "committedDate": "2020-09-10T22:18:22Z", "type": "commit"}, {"oid": "9ff744b360de695535cd76010120d3091bb572ad", "url": "https://github.com/apache/druid/commit/9ff744b360de695535cd76010120d3091bb572ad", "message": "rename method", "committedDate": "2020-09-10T23:20:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczOTI4NA==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486739284", "bodyText": "nit: Add @NonNull since the super class says this is Nullable, I'm not actually sure which takes precedence in this case when the package is annotated with EverythingIsNonNullByDefault", "author": "suneet-s", "createdAt": "2020-09-11T02:38:07Z", "path": "core/src/main/java/org/apache/druid/math/expr/ConstantExpr.java", "diffHunk": "@@ -35,6 +35,19 @@\n  */\n abstract class ConstantExpr implements Expr\n {\n+  final ExprType outputType;\n+\n+  protected ConstantExpr(ExprType outputType)\n+  {\n+    this.outputType = outputType;\n+  }\n+\n+  @Override", "originalCommit": "9ff744b360de695535cd76010120d3091bb572ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NjAwOQ==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486756009", "bodyText": "Oops, I didn't actually mean to make this not be @Nullable, though I guess it is true, but will fix to just be consistent with the interface.", "author": "clintropolis", "createdAt": "2020-09-11T03:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczOTI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczOTczMw==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486739733", "bodyText": "note to self: Do we want null to mean 2 things?", "author": "suneet-s", "createdAt": "2020-09-11T02:39:33Z", "path": "core/src/main/java/org/apache/druid/math/expr/Expr.java", "diffHunk": "@@ -116,16 +116,39 @@ default String getBindingIfIdentifier()\n   void visit(Visitor visitor);\n \n   /**\n-   * Programatically rewrite the {@link Expr} tree with a {@link Shuttle}.Each {@link Expr} is responsible for\n+   * Programatically rewrite the {@link Expr} tree with a {@link Shuttle}. Each {@link Expr} is responsible for\n    * ensuring the {@link Shuttle} can visit all of its {@link Expr} children, as well as updating its children\n    * {@link Expr} with the results from the {@link Shuttle}, before finally visiting an updated form of itself.\n    */\n   Expr visit(Shuttle shuttle);\n \n   /**\n-   * Examine the usage of {@link IdentifierExpr} children of an {@link Expr}, constructing a {@link BindingDetails}\n+   * Examine the usage of {@link IdentifierExpr} children of an {@link Expr}, constructing a {@link BindingAnalysis}\n    */\n-  BindingDetails analyzeInputs();\n+  BindingAnalysis analyzeInputs();\n+\n+  /**\n+   * Given an {@link InputBindingTypes}, compute what the output {@link ExprType} will be for this expression. A return\n+   * value of null indicates that the given type information was not enough to resolve the output type, so the\n+   * expression must be evaluated using default {@link #eval} handling where types are only known after evaluation,\n+   * through {@link ExprEval#type}.\n+   */\n+  @Nullable\n+  default ExprType getOutputType(InputBindingTypes inputTypes)\n+  {\n+    return null;\n+  }\n+\n+  /**\n+   * Mechanism to supply input types for the bindings which will back {@link IdentifierExpr}, to use in the aid of\n+   * inferring the output type of an expression with {@link #getOutputType}. A null value means that either the binding", "originalCommit": "9ff744b360de695535cd76010120d3091bb572ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NjE0Mw==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486756143", "bodyText": "not long term probably, but currently this will be backed by ColumnCapabilities from a ColumnInspector, which does not currently distinguish between those 2 things for all implementations.", "author": "clintropolis", "createdAt": "2020-09-11T03:45:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczOTczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0MDcxMA==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486740710", "bodyText": "nit: I don't think the isArray check is needed\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (elementType != null && !isArray(elementType)) {\n          \n          \n            \n                if (elementType != null) {", "author": "suneet-s", "createdAt": "2020-09-11T02:43:04Z", "path": "core/src/main/java/org/apache/druid/math/expr/ExprType.java", "diffHunk": "@@ -29,5 +35,119 @@\n   STRING,\n   DOUBLE_ARRAY,\n   LONG_ARRAY,\n-  STRING_ARRAY\n+  STRING_ARRAY;\n+\n+  public boolean isNumeric()\n+  {\n+    return isNumeric(this);\n+  }\n+\n+  /**\n+   * The expression system does not distinguish between {@link ValueType#FLOAT} and {@link ValueType#DOUBLE}, and\n+   * cannot currently handle {@link ValueType#COMPLEX} inputs. This method will convert {@link ValueType#FLOAT} to\n+   * {@link #DOUBLE}, or throw an exception if a {@link ValueType#COMPLEX} is encountered.\n+   *\n+   * @throws IllegalStateException\n+   */\n+  public static ExprType fromValueType(@Nullable ValueType valueType)\n+  {\n+    if (valueType == null) {\n+      throw new IllegalStateException(\"Unsupported unknown value type\");\n+    }\n+    switch (valueType) {\n+      case LONG:\n+        return LONG;\n+      case LONG_ARRAY:\n+        return LONG_ARRAY;\n+      case FLOAT:\n+      case DOUBLE:\n+        return DOUBLE;\n+      case DOUBLE_ARRAY:\n+        return DOUBLE_ARRAY;\n+      case STRING:\n+        return STRING;\n+      case STRING_ARRAY:\n+        return STRING_ARRAY;\n+      case COMPLEX:\n+      default:\n+        throw new ISE(\"Unsupported value type[%s]\", valueType);\n+    }\n+  }\n+\n+  public static boolean isNumeric(ExprType type)\n+  {\n+    return LONG.equals(type) || DOUBLE.equals(type);\n+  }\n+\n+  public static boolean isArray(@Nullable ExprType type)\n+  {\n+    return LONG_ARRAY.equals(type) || DOUBLE_ARRAY.equals(type) || STRING_ARRAY.equals(type);\n+  }\n+\n+  @Nullable\n+  public static ExprType elementType(@Nullable ExprType type)\n+  {\n+    if (type != null && isArray(type)) {\n+      switch (type) {\n+        case STRING_ARRAY:\n+          return STRING;\n+        case LONG_ARRAY:\n+          return LONG;\n+        case DOUBLE_ARRAY:\n+          return DOUBLE;\n+      }\n+    }\n+    return type;\n+  }\n+\n+  @Nullable\n+  public static ExprType asArrayType(@Nullable ExprType elementType)\n+  {\n+    if (elementType != null && !isArray(elementType)) {", "originalCommit": "9ff744b360de695535cd76010120d3091bb572ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0MTAxOA==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486741018", "bodyText": "I think we should add a unit test to make sure we cover all the different branches for this. There looks like there's a lot of subtlety in the ordering of the if conditions and It sounds like an important function that many others will rely on working correctly. I think this function should have 100% branch coverage\nI think all the static functions in this class should be unit tested.", "author": "suneet-s", "createdAt": "2020-09-11T02:44:21Z", "path": "core/src/main/java/org/apache/druid/math/expr/ExprType.java", "diffHunk": "@@ -29,5 +35,119 @@\n   STRING,\n   DOUBLE_ARRAY,\n   LONG_ARRAY,\n-  STRING_ARRAY\n+  STRING_ARRAY;\n+\n+  public boolean isNumeric()\n+  {\n+    return isNumeric(this);\n+  }\n+\n+  /**\n+   * The expression system does not distinguish between {@link ValueType#FLOAT} and {@link ValueType#DOUBLE}, and\n+   * cannot currently handle {@link ValueType#COMPLEX} inputs. This method will convert {@link ValueType#FLOAT} to\n+   * {@link #DOUBLE}, or throw an exception if a {@link ValueType#COMPLEX} is encountered.\n+   *\n+   * @throws IllegalStateException\n+   */\n+  public static ExprType fromValueType(@Nullable ValueType valueType)\n+  {\n+    if (valueType == null) {\n+      throw new IllegalStateException(\"Unsupported unknown value type\");\n+    }\n+    switch (valueType) {\n+      case LONG:\n+        return LONG;\n+      case LONG_ARRAY:\n+        return LONG_ARRAY;\n+      case FLOAT:\n+      case DOUBLE:\n+        return DOUBLE;\n+      case DOUBLE_ARRAY:\n+        return DOUBLE_ARRAY;\n+      case STRING:\n+        return STRING;\n+      case STRING_ARRAY:\n+        return STRING_ARRAY;\n+      case COMPLEX:\n+      default:\n+        throw new ISE(\"Unsupported value type[%s]\", valueType);\n+    }\n+  }\n+\n+  public static boolean isNumeric(ExprType type)\n+  {\n+    return LONG.equals(type) || DOUBLE.equals(type);\n+  }\n+\n+  public static boolean isArray(@Nullable ExprType type)\n+  {\n+    return LONG_ARRAY.equals(type) || DOUBLE_ARRAY.equals(type) || STRING_ARRAY.equals(type);\n+  }\n+\n+  @Nullable\n+  public static ExprType elementType(@Nullable ExprType type)\n+  {\n+    if (type != null && isArray(type)) {\n+      switch (type) {\n+        case STRING_ARRAY:\n+          return STRING;\n+        case LONG_ARRAY:\n+          return LONG;\n+        case DOUBLE_ARRAY:\n+          return DOUBLE;\n+      }\n+    }\n+    return type;\n+  }\n+\n+  @Nullable\n+  public static ExprType asArrayType(@Nullable ExprType elementType)\n+  {\n+    if (elementType != null && !isArray(elementType)) {\n+      switch (elementType) {\n+        case STRING:\n+          return STRING_ARRAY;\n+        case LONG:\n+          return LONG_ARRAY;\n+        case DOUBLE:\n+          return DOUBLE_ARRAY;\n+      }\n+    }\n+    return elementType;\n+  }\n+\n+  /**\n+   * Given 2 'input' types, choose the most appropriate combined type, if possible\n+   */\n+  @Nullable\n+  public static ExprType autoTypeConversion(@Nullable ExprType type, @Nullable ExprType other)", "originalCommit": "9ff744b360de695535cd76010120d3091bb572ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NDkzOQ==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486744939", "bodyText": "Why does the not operator need to translate a string to a long?", "author": "suneet-s", "createdAt": "2020-09-11T02:59:32Z", "path": "core/src/main/java/org/apache/druid/math/expr/UnaryOperatorExpr.java", "diffHunk": "@@ -163,4 +171,15 @@ public String toString()\n   {\n     return StringUtils.format(\"!%s\", expr);\n   }\n+\n+  @Nullable\n+  @Override\n+  public ExprType getOutputType(InputBindingTypes inputTypes)\n+  {\n+    ExprType implicitCast = super.getOutputType(inputTypes);\n+    if (ExprType.STRING.equals(implicitCast)) {\n+      return ExprType.LONG;\n+    }", "originalCommit": "9ff744b360de695535cd76010120d3091bb572ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1NzYzNA==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486757634", "bodyText": "I don't know off the top of my head why it does that, I was just trying to model its output. The binary logic expressions do that too:\n  @Override\n  protected ExprEval evalString(@Nullable String left, @Nullable String right)\n  {\n    return ExprEval.ofLongBoolean(Comparators.<String>naturalNullsFirst().compare(left, right) < 0);\n  }\n\nso it is just being consistent with those operators I think.\nI'm moderately in the camp of wondering why these logical operators return anything other than long for any input type, but I haven't thought fully through on the implications of changing that yet, so maybe there is a reason that the type is preserved for doubles in these operators.", "author": "clintropolis", "createdAt": "2020-09-11T03:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0NDkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0ODU4Mg==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486748582", "bodyText": "The eval function returns ExprEval.of(null) if the value is a numeric null. It looks like in that case the output type should be ExprType.STRING", "author": "suneet-s", "createdAt": "2020-09-11T03:14:28Z", "path": "processing/src/main/java/org/apache/druid/query/expression/TimestampCeilExprMacro.java", "diffHunk": "@@ -93,6 +95,13 @@ public Expr visit(Shuttle shuttle)\n       return shuttle.visit(new TimestampCeilExpr(newArgs));\n     }\n \n+    @Nullable\n+    @Override\n+    public ExprType getOutputType(InputBindingTypes inputTypes)\n+    {\n+      return ExprType.LONG;", "originalCommit": "9ff744b360de695535cd76010120d3091bb572ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2MjUyMQ==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486762521", "bodyText": "Hmm, so numeric null handling should be done currently be done using ExprEval.isNumericNull, which will return true even if the type is a null string from a StringExprEval. So i think 'string' is technically correct, but I don't think spiritually or functionally quite true, nor that useful. We probably should modify these ExprEval.of(null) to make type correct ExprEval to make eval match exactly what getOutputType says, but I don't know if this PR is the correct place to do that.", "author": "clintropolis", "createdAt": "2020-09-11T04:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0ODU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNzYxMQ==", "url": "https://github.com/apache/druid/pull/10370#discussion_r487317611", "bodyText": "Thanks for the explanation. I agree that we shouldn't try to address that in this PR", "author": "suneet-s", "createdAt": "2020-09-11T22:28:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0ODU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0OTA5Ng==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486749096", "bodyText": "nit: You can delete this now that this is the default behavior.", "author": "suneet-s", "createdAt": "2020-09-11T03:16:22Z", "path": "processing/src/test/java/org/apache/druid/query/expression/IPv4AddressMatchExprMacroTest.java", "diffHunk": "@@ -203,5 +205,12 @@ public Expr visit(Shuttle shuttle)\n     {\n       return null;\n     }\n+\n+    @Nullable\n+    @Override\n+    public ExprType getOutputType(InputBindingTypes inputTypes)\n+    {\n+      return null;\n+    }", "originalCommit": "9ff744b360de695535cd76010120d3091bb572ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0OTMwNA==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486749304", "bodyText": "I think this is an accidental change", "author": "suneet-s", "createdAt": "2020-09-11T03:17:15Z", "path": "server/src/main/java/org/apache/druid/server/lookup/cache/LookupCoordinatorManager.java", "diffHunk": "@@ -518,7 +518,7 @@ private void initializeLookupsConfigWatcher()\n         configManager.set(\n             LOOKUP_CONFIG_KEY,\n             converted,\n-            new AuditInfo(\"autoConversion\", \"autoConversion\", \"127.0.0.1\")\n+            new AuditInfo(\"autoTypeConversion\", \"autoTypeConversion\", \"127.0.0.1\")", "originalCommit": "9ff744b360de695535cd76010120d3091bb572ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc2MjY3Mw==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486762673", "bodyText": "oops, intellij got a bit aggro", "author": "clintropolis", "createdAt": "2020-09-11T04:12:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0OTMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MDI1Ng==", "url": "https://github.com/apache/druid/pull/10370#discussion_r486750256", "bodyText": "Similar problem with ExprEval.of(null)", "author": "suneet-s", "createdAt": "2020-09-11T03:21:06Z", "path": "processing/src/main/java/org/apache/druid/query/expression/TimestampParseExprMacro.java", "diffHunk": "@@ -100,6 +102,13 @@ public Expr visit(Shuttle shuttle)\n         return shuttle.visit(new TimestampParseExpr(newArg));\n       }\n \n+      @Nullable\n+      @Override\n+      public ExprType getOutputType(InputBindingTypes inputTypes)\n+      {\n+        return ExprType.LONG;", "originalCommit": "9ff744b360de695535cd76010120d3091bb572ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "40d0913bc0c44b35bc2cd1dee8bf5bbd660aeecb", "url": "https://github.com/apache/druid/commit/40d0913bc0c44b35bc2cd1dee8bf5bbd660aeecb", "message": "more test", "committedDate": "2020-09-11T05:05:01Z", "type": "commit"}, {"oid": "5d99b3d50cb6f1d851495e3a0aaef1f1caa9bf80", "url": "https://github.com/apache/druid/commit/5d99b3d50cb6f1d851495e3a0aaef1f1caa9bf80", "message": "Merge remote-tracking branch 'upstream/master' into expr-output-type", "committedDate": "2020-09-14T17:04:46Z", "type": "commit"}, {"oid": "b0b76aacee80065622ed04dd857d406a9d45d655", "url": "https://github.com/apache/druid/commit/b0b76aacee80065622ed04dd857d406a9d45d655", "message": "add output for contains expr macro, split operation and function auto conversion", "committedDate": "2020-09-14T19:31:33Z", "type": "commit"}]}