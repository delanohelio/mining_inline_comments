{"pr_number": 9893, "pr_title": "Add REGEXP_LIKE, fix bugs in REGEXP_EXTRACT.", "pr_createdAt": "2020-05-19T03:33:24Z", "pr_url": "https://github.com/apache/druid/pull/9893", "timeline": [{"oid": "73d8fd11e6e39a09393c9b38717db2e5c36fae44", "url": "https://github.com/apache/druid/commit/73d8fd11e6e39a09393c9b38717db2e5c36fae44", "message": "Add REGEXP_LIKE, fix empty-pattern bug in REGEXP_EXTRACT.\n\n- Add REGEXP_LIKE function that returns a boolean, and is useful in\n  WHERE clauses.\n- Fix REGEXP_EXTRACT return type (should be nullable; causes incorrect\n  filter elision).\n- Fix REGEXP_EXTRACT behavior for empty patterns: should always match\n  (previously, they threw errors).\n- Improve error behavior when REGEXP_EXTRACT and REGEXP_LIKE are passed\n  non-literal patterns.\n- Improve documentation of REGEXP_EXTRACT.", "committedDate": "2020-05-19T03:33:53Z", "type": "commit"}, {"oid": "73d8fd11e6e39a09393c9b38717db2e5c36fae44", "url": "https://github.com/apache/druid/commit/73d8fd11e6e39a09393c9b38717db2e5c36fae44", "message": "Add REGEXP_LIKE, fix empty-pattern bug in REGEXP_EXTRACT.\n\n- Add REGEXP_LIKE function that returns a boolean, and is useful in\n  WHERE clauses.\n- Fix REGEXP_EXTRACT return type (should be nullable; causes incorrect\n  filter elision).\n- Fix REGEXP_EXTRACT behavior for empty patterns: should always match\n  (previously, they threw errors).\n- Improve error behavior when REGEXP_EXTRACT and REGEXP_LIKE are passed\n  non-literal patterns.\n- Improve documentation of REGEXP_EXTRACT.", "committedDate": "2020-05-19T03:33:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc1NTEyOA==", "url": "https://github.com/apache/druid/pull/9893#discussion_r427755128", "bodyText": "hmm, I forget why I added this function, but it appears at least now that nothing is calling it.. It was added with #6974, specifically to be able to set this as non-null. I guess with this change that block will always be null, so the if can probably be removed, though I wish I could remember why I added it. However, that PR was open for over a year so .. maybe over that lifetime of fixing it up for conflicts it's purpose was lost to time...", "author": "clintropolis", "createdAt": "2020-05-20T05:47:03Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/OperatorConversions.java", "diffHunk": "@@ -291,15 +294,15 @@ public OperatorBuilder operandTypes(final SqlTypeFamily... operandTypes)\n       return this;\n     }\n \n-    public OperatorBuilder operandTypeInference(final SqlOperandTypeInference operandTypeInference)", "originalCommit": "73d8fd11e6e39a09393c9b38717db2e5c36fae44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc1NzM4Mw==", "url": "https://github.com/apache/druid/pull/9893#discussion_r428757383", "bodyText": "Ah, yeah, I removed it because it wasn't being used; I suppose we could add it back if needed in the future.", "author": "gianm", "createdAt": "2020-05-21T16:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc1NTEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc1NjIzNA==", "url": "https://github.com/apache/druid/pull/9893#discussion_r427756234", "bodyText": "this seems handy to have \ud83e\udd18, but (nit) could you add javadoc indicating that these are the positions of the operands that are required to be literals? bonus points if you add javadocs to other methods, but also, since nothing else has them don't feel obligated to add them even for this unless there are other changes to make", "author": "clintropolis", "createdAt": "2020-05-20T05:50:49Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/OperatorConversions.java", "diffHunk": "@@ -291,15 +294,15 @@ public OperatorBuilder operandTypes(final SqlTypeFamily... operandTypes)\n       return this;\n     }\n \n-    public OperatorBuilder operandTypeInference(final SqlOperandTypeInference operandTypeInference)\n+    public OperatorBuilder requiredOperands(final int requiredOperands)\n     {\n-      this.operandTypeInference = operandTypeInference;\n+      this.requiredOperands = requiredOperands;\n       return this;\n     }\n \n-    public OperatorBuilder requiredOperands(final int requiredOperands)\n+    public OperatorBuilder literalOperands(final int... literalOperands)", "originalCommit": "73d8fd11e6e39a09393c9b38717db2e5c36fae44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc4MDQxMg==", "url": "https://github.com/apache/druid/pull/9893#discussion_r428780412", "bodyText": "I added javadocs to all these methods.", "author": "gianm", "createdAt": "2020-05-21T16:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc1NjIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc4MjM0Mw==", "url": "https://github.com/apache/druid/pull/9893#discussion_r428782343", "bodyText": "By the way, I also renamed returnType to returnTypeNonNull to make it clearer.", "author": "gianm", "createdAt": "2020-05-21T16:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc1NjIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1NzcxMg==", "url": "https://github.com/apache/druid/pull/9893#discussion_r430757712", "bodyText": "rad thanks!", "author": "clintropolis", "createdAt": "2020-05-26T23:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc1NjIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc2MDAzOQ==", "url": "https://github.com/apache/druid/pull/9893#discussion_r427760039", "bodyText": "Would it make sense for this null part of the check be consolidated with the else if (operandType.getSqlTypeName() == SqlTypeName.NULL) branch by putting the can be null check first in the if/else chain? I guess SqlUtil.isNullLiteral, is slightly more expensive of a check than just checking that the type name is null, but is also maybe more correct since casting a null is still probably null?", "author": "clintropolis", "createdAt": "2020-05-20T06:02:51Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/OperatorConversions.java", "diffHunk": "@@ -430,36 +434,64 @@ public void inferOperandTypes(\n \n   /**\n    * Operand type checker that is used in 'simple' situations: there are a particular number of operands, with\n-   * particular types, some of which may be optional or nullable.\n+   * particular types, some of which may be optional or nullable, and some of which may be required to be literals.\n    */\n   private static class DefaultOperandTypeChecker implements SqlOperandTypeChecker\n   {\n     private final List<SqlTypeFamily> operandTypes;\n     private final int requiredOperands;\n     private final IntSet nullableOperands;\n+    private final IntSet literalOperands;\n \n     DefaultOperandTypeChecker(\n         final List<SqlTypeFamily> operandTypes,\n         final int requiredOperands,\n-        final IntSet nullableOperands\n+        final IntSet nullableOperands,\n+        @Nullable final int[] literalOperands\n     )\n     {\n       Preconditions.checkArgument(requiredOperands <= operandTypes.size() && requiredOperands >= 0);\n       this.operandTypes = Preconditions.checkNotNull(operandTypes, \"operandTypes\");\n       this.requiredOperands = requiredOperands;\n       this.nullableOperands = Preconditions.checkNotNull(nullableOperands, \"nullableOperands\");\n+\n+      if (literalOperands == null) {\n+        this.literalOperands = IntSets.EMPTY_SET;\n+      } else {\n+        this.literalOperands = new IntArraySet();\n+        Arrays.stream(literalOperands).forEach(this.literalOperands::add);\n+      }\n     }\n \n     @Override\n     public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure)\n     {\n-      if (operandTypes.size() != callBinding.getOperandCount()) {\n-        // Just like FamilyOperandTypeChecker: assume this is an inapplicable sub-rule of a composite rule; don't throw\n-        return false;\n-      }\n-\n       for (int i = 0; i < callBinding.operands().size(); i++) {\n         final SqlNode operand = callBinding.operands().get(i);\n+\n+        if (literalOperands.contains(i)) {\n+          // Verify that 'operand' is a literal.\n+          if (!SqlUtil.isLiteral(operand)) {\n+            return throwOrReturn(\n+                throwOnFailure,\n+                callBinding,\n+                cb -> cb.getValidator()\n+                        .newValidationError(\n+                            operand,\n+                            Static.RESOURCE.argumentMustBeLiteral(callBinding.getOperator().getName())\n+                        )\n+            );\n+          }\n+\n+          if (!nullableOperands.contains(i) && SqlUtil.isNullLiteral(operand, true)) {", "originalCommit": "73d8fd11e6e39a09393c9b38717db2e5c36fae44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc4MjA4Nw==", "url": "https://github.com/apache/druid/pull/9893#discussion_r428782087", "bodyText": "Sure, I think this makes sense. I changed it.", "author": "gianm", "createdAt": "2020-05-21T16:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc2MDAzOQ=="}], "type": "inlineReview"}, {"oid": "215971a097bd6f8d80dde17a178f372cc8a6863b", "url": "https://github.com/apache/druid/commit/215971a097bd6f8d80dde17a178f372cc8a6863b", "message": "Changes based on PR review.", "committedDate": "2020-05-21T16:54:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc5MjcyNQ==", "url": "https://github.com/apache/druid/pull/9893#discussion_r428792725", "bodyText": "what is the 3rd argument for? I only see the first 2 being used in this expr\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (args.size() < 2 || args.size() > 3) {\n          \n          \n            \n                if (args.size() != 2) {", "author": "suneet-s", "createdAt": "2020-05-21T17:12:24Z", "path": "processing/src/main/java/org/apache/druid/query/expression/RegexpLikeExprMacro.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.math.expr.ExprType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RegexpLikeExprMacro implements ExprMacroTable.ExprMacro\n+{\n+  private static final String FN_NAME = \"regexp_like\";\n+\n+  @Override\n+  public String name()\n+  {\n+    return FN_NAME;\n+  }\n+\n+  @Override\n+  public Expr apply(final List<Expr> args)\n+  {\n+    if (args.size() < 2 || args.size() > 3) {", "originalCommit": "215971a097bd6f8d80dde17a178f372cc8a6863b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgzMTM0Nw==", "url": "https://github.com/apache/druid/pull/9893#discussion_r428831347", "bodyText": "Good catch. I'll fix it.", "author": "gianm", "createdAt": "2020-05-21T18:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc5MjcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwODAzMg==", "url": "https://github.com/apache/druid/pull/9893#discussion_r428808032", "bodyText": "Do we have tests that check how the function performs against\n\na multi-value column\na numeric column\nmatching against null", "author": "suneet-s", "createdAt": "2020-05-21T17:39:54Z", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -7300,6 +7301,74 @@ public void testRegexpExtract() throws Exception\n     );\n   }\n \n+  @Test\n+  public void testRegexpExtractFilterViaNotNullCheck() throws Exception\n+  {\n+    // Cannot vectorize due to extractionFn in dimension spec.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT COUNT(*)\\n\"\n+        + \"FROM foo\\n\"\n+        + \"WHERE REGEXP_EXTRACT(dim1, '^1') IS NOT NULL OR REGEXP_EXTRACT('Z' || dim1, '^Z2') IS NOT NULL\",\n+        ImmutableList.of(\n+            Druids.newTimeseriesQueryBuilder()\n+                  .dataSource(CalciteTests.DATASOURCE1)\n+                  .intervals(querySegmentSpec(Filtration.eternity()))\n+                  .granularity(Granularities.ALL)\n+                  .virtualColumns(\n+                      expressionVirtualColumn(\"v0\", \"regexp_extract(concat('Z',\\\"dim1\\\"),'^Z2')\", ValueType.STRING)\n+                  )\n+                  .filters(\n+                      or(\n+                          not(selector(\"dim1\", null, new RegexDimExtractionFn(\"^1\", 0, true, null))),\n+                          not(selector(\"v0\", null, null))\n+                      )\n+                  )\n+                  .aggregators(new CountAggregatorFactory(\"a0\"))\n+                  .context(TIMESERIES_CONTEXT_DEFAULT)\n+                  .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{3L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testRegexpLikeFilter() throws Exception\n+  {\n+    // Cannot vectorize due to usage of regex filter.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT COUNT(*)\\n\"\n+        + \"FROM foo\\n\"\n+        + \"WHERE REGEXP_LIKE(dim1, '^1') OR REGEXP_LIKE('Z' || dim1, '^Z2')\",", "originalCommit": "215971a097bd6f8d80dde17a178f372cc8a6863b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwOTQ4NQ==", "url": "https://github.com/apache/druid/pull/9893#discussion_r428809485", "bodyText": "The docs say that \"The pattern must match starting at the beginning of expr\" but it looks like the regex pattern you are passing in is asking that it start at the beginning of the string via ^ in the pattern string. Can I use a $ in my regex to ask that it matches the end of the expr?", "author": "suneet-s", "createdAt": "2020-05-21T17:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwODAzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyNzg3Mg==", "url": "https://github.com/apache/druid/pull/9893#discussion_r428827872", "bodyText": "a multi-value column\n\nThere aren't tests for multi-value columns for this specific expression, nor for other functions that aren't multi-value-aware. (There is a separate system that handles mapping over non-multi-value-aware functions.) I could see having a systematic way to test for this (a query generator, maybe) but I don't think adding one just for this function would make sense.\n\na numeric column\n\nThere aren't tests for a numeric column. It should be a validation error but we don't currently have very comprehensive tests for the validator. I could add one in an ad-hoc way right now, and that would make sense. But I was actually hoping to add more systematic tests in a future patch, so could do it then too.\n\nmatching against null\n\nI added a test for matching against null to ExpressionsTest.\n\nThe docs say that \"The pattern must match starting at the beginning of expr\" but it looks like the regex pattern you are passing in is asking that it start at the beginning of the string via ^ in the pattern string. Can I use a $ in my regex to ask that it matches the end of the expr?\n\nWow! After looking into your comment, I realized that I totally screwed up the docs here. I actually have a test in this patch for what happens when you skip the ^, and it does match substrings that are in the middle of the string, and the test expects that to happen, all in contradiction of what the docs say. I'll fix the docs. Thanks for calling this to my attention.\nAnd yes, you can use $ to ask that it match the end. There are tests for this too.", "author": "gianm", "createdAt": "2020-05-21T18:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwODAzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NjY2MA==", "url": "https://github.com/apache/druid/pull/9893#discussion_r428846660", "bodyText": "Sounds good to me!\n\nI could see having a systematic way to test for this (a query generator, maybe) but I don't think adding one just for this function would make sense.\n\nI've been working on the beginnings of a query generator to match all the different rows in druid.foo table - I was kinda sneakily hoping there was already a systematic way we add tests for all these different conditions and I just hadn't seen it yet :)", "author": "suneet-s", "createdAt": "2020-05-21T18:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgwODAzMg=="}], "type": "inlineReview"}, {"oid": "0f3170b2d5e5cd6111cc5efc873d7e2847ae8397", "url": "https://github.com/apache/druid/commit/0f3170b2d5e5cd6111cc5efc873d7e2847ae8397", "message": "Fix arg check.", "committedDate": "2020-05-21T18:03:46Z", "type": "commit"}, {"oid": "00698bfe82b1cbc9719d0e8e180ccfd9ddec7982", "url": "https://github.com/apache/druid/commit/00698bfe82b1cbc9719d0e8e180ccfd9ddec7982", "message": "Important fixes!", "committedDate": "2020-05-21T18:24:59Z", "type": "commit"}, {"oid": "dd0c16f1fecea3f6835e803477982219a26bcd8b", "url": "https://github.com/apache/druid/commit/dd0c16f1fecea3f6835e803477982219a26bcd8b", "message": "Add speller.", "committedDate": "2020-05-21T18:26:47Z", "type": "commit"}, {"oid": "89dcaa80ba46ec5f76122bb41d324179e8d001b7", "url": "https://github.com/apache/druid/commit/89dcaa80ba46ec5f76122bb41d324179e8d001b7", "message": "Merge branch 'master' into regexp-stuff", "committedDate": "2020-05-21T18:27:00Z", "type": "commit"}, {"oid": "8b95b9e5430469fee78e4bc18784d902087ec265", "url": "https://github.com/apache/druid/commit/8b95b9e5430469fee78e4bc18784d902087ec265", "message": "Merge branch 'master' into regexp-stuff", "committedDate": "2020-05-27T00:40:13Z", "type": "commit"}, {"oid": "c72cab02b0caecd2501b094c1fd685f37e773a24", "url": "https://github.com/apache/druid/commit/c72cab02b0caecd2501b094c1fd685f37e773a24", "message": "wip", "committedDate": "2020-05-27T01:03:46Z", "type": "commit"}, {"oid": "0f67d2c9a77a88c7f89bdcafa096734edcc68b51", "url": "https://github.com/apache/druid/commit/0f67d2c9a77a88c7f89bdcafa096734edcc68b51", "message": "Merge branch 'master' into regexp-stuff", "committedDate": "2020-06-01T17:37:42Z", "type": "commit"}, {"oid": "192ac338d967493679f287e550d9d4a8361159d1", "url": "https://github.com/apache/druid/commit/192ac338d967493679f287e550d9d4a8361159d1", "message": "Additional tests.", "committedDate": "2020-06-01T23:17:25Z", "type": "commit"}, {"oid": "cb89950a7c18e6ab92bd34f6571c398577d160fe", "url": "https://github.com/apache/druid/commit/cb89950a7c18e6ab92bd34f6571c398577d160fe", "message": "Merge branch 'master' into regexp-stuff", "committedDate": "2020-06-02T01:57:14Z", "type": "commit"}, {"oid": "ce4197c0dea05b854fee63c54eb1694f064f8fea", "url": "https://github.com/apache/druid/commit/ce4197c0dea05b854fee63c54eb1694f064f8fea", "message": "Fix up tests.", "committedDate": "2020-06-02T02:09:55Z", "type": "commit"}, {"oid": "71b9e298c4285dac6082f8484ee44aae73dfceb4", "url": "https://github.com/apache/druid/commit/71b9e298c4285dac6082f8484ee44aae73dfceb4", "message": "Add validation error tests.", "committedDate": "2020-06-02T15:14:21Z", "type": "commit"}, {"oid": "6641cab46b570ac537822e67371d9ce41f41b11d", "url": "https://github.com/apache/druid/commit/6641cab46b570ac537822e67371d9ce41f41b11d", "message": "Additional tests.", "committedDate": "2020-06-02T16:51:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5NjUxOA==", "url": "https://github.com/apache/druid/pull/9893#discussion_r434196518", "bodyText": "nit: Is this nullToEmptyIfNeeded still needed because of the if block on line 77 - same comment for RegexpExtractMacro\nUnclear to me if there's a performance loss from the extra function call (I'd think it's probably not measurable)", "author": "suneet-s", "createdAt": "2020-06-02T21:53:12Z", "path": "processing/src/main/java/org/apache/druid/query/expression/RegexpLikeExprMacro.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.math.expr.ExprType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class RegexpLikeExprMacro implements ExprMacroTable.ExprMacro\n+{\n+  private static final String FN_NAME = \"regexp_like\";\n+\n+  @Override\n+  public String name()\n+  {\n+    return FN_NAME;\n+  }\n+\n+  @Override\n+  public Expr apply(final List<Expr> args)\n+  {\n+    if (args.size() != 2) {\n+      throw new IAE(\"Function[%s] must have 2 arguments\", name());\n+    }\n+\n+    final Expr arg = args.get(0);\n+    final Expr patternExpr = args.get(1);\n+\n+    if (!ExprUtils.isStringLiteral(patternExpr)) {\n+      throw new IAE(\"Function[%s] pattern must be a string literal\", name());\n+    }\n+\n+    // Precompile the pattern.\n+    final Pattern pattern = Pattern.compile(\n+        StringUtils.nullToEmptyNonDruidDataString((String) patternExpr.getLiteralValue())\n+    );\n+\n+    class RegexpLikeExpr extends ExprMacroTable.BaseScalarUnivariateMacroFunctionExpr\n+    {\n+      private RegexpLikeExpr(Expr arg)\n+      {\n+        super(FN_NAME, arg);\n+      }\n+\n+      @Nonnull\n+      @Override\n+      public ExprEval eval(final ObjectBinding bindings)\n+      {\n+        final String s = NullHandling.nullToEmptyIfNeeded(arg.eval(bindings).asString());\n+\n+        if (s == null) {\n+          // True nulls do not match anything. Note: this branch only executes in SQL-compatible null handling mode.\n+          return ExprEval.of(false, ExprType.LONG);\n+        } else {\n+          final Matcher matcher = pattern.matcher(NullHandling.nullToEmptyIfNeeded(s));", "originalCommit": "6641cab46b570ac537822e67371d9ce41f41b11d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc0NTE5OQ==", "url": "https://github.com/apache/druid/pull/9893#discussion_r434745199", "bodyText": "Good catch, I removed it.", "author": "gianm", "createdAt": "2020-06-03T17:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5NjUxOA=="}], "type": "inlineReview"}, {"oid": "292836a4b21c33afa6acfa3f300157ffc8d7d6fe", "url": "https://github.com/apache/druid/commit/292836a4b21c33afa6acfa3f300157ffc8d7d6fe", "message": "Merge branch 'master' into regexp-stuff", "committedDate": "2020-06-03T17:43:12Z", "type": "commit"}, {"oid": "bb322273174716b58c04b72fd79c2ea53eb31c96", "url": "https://github.com/apache/druid/commit/bb322273174716b58c04b72fd79c2ea53eb31c96", "message": "Remove useless call.", "committedDate": "2020-06-03T17:45:39Z", "type": "commit"}]}