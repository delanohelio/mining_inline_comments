{"pr_number": 9994, "pr_title": "remove incorrect and unnecessary overrides from BooleanVectorValueMatcher", "pr_createdAt": "2020-06-05T21:09:50Z", "pr_url": "https://github.com/apache/druid/pull/9994", "timeline": [{"oid": "c6a098d828504c48484837ab7a0447c786991815", "url": "https://github.com/apache/druid/commit/c6a098d828504c48484837ab7a0447c786991815", "message": "remove incorrect and unnecessary overrides from BooleanVectorValueMatcher", "committedDate": "2020-06-05T21:08:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1MzIzNw==", "url": "https://github.com/apache/druid/pull/9994#discussion_r436853237", "bodyText": "nit: maybe good to have unit tests for future proof.", "author": "jihoonson", "createdAt": "2020-06-08T16:55:17Z", "path": "processing/src/main/java/org/apache/druid/query/filter/vector/BooleanVectorValueMatcher.java", "diffHunk": "@@ -38,18 +36,6 @@ public static BooleanVectorValueMatcher of(final VectorSizeInspector selector, f\n     return new BooleanVectorValueMatcher(selector, matches);\n   }\n \n-  @Override\n-  public int getCurrentVectorSize()\n-  {\n-    return selector.getCurrentVectorSize();", "originalCommit": "c6a098d828504c48484837ab7a0447c786991815", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b49744b8bf9940e0a01c1f81fee0b4ea2d302ad", "url": "https://github.com/apache/druid/commit/1b49744b8bf9940e0a01c1f81fee0b4ea2d302ad", "message": "Merge remote-tracking branch 'upstream/master' into remove-boolean-vector-value-matcher-overrides", "committedDate": "2020-06-09T09:20:28Z", "type": "commit"}, {"oid": "6998f91090693efd1d79f578169ac97952ee9338", "url": "https://github.com/apache/druid/commit/6998f91090693efd1d79f578169ac97952ee9338", "message": "add test case", "committedDate": "2020-06-09T10:05:15Z", "type": "commit"}, {"oid": "2761970008e6c10c819a6b71bc0b8d212c7a8fbc", "url": "https://github.com/apache/druid/commit/2761970008e6c10c819a6b71bc0b8d212c7a8fbc", "message": "add unit tests for ... part of VectorValueMatcherColumnProcessorFactory", "committedDate": "2020-06-09T11:14:07Z", "type": "commit"}, {"oid": "278d20c741cfd12b8efbb29fdfd993b8650bfb90", "url": "https://github.com/apache/druid/commit/278d20c741cfd12b8efbb29fdfd993b8650bfb90", "message": "Update VectorValueMatcherColumnProcessorFactoryTest.java", "committedDate": "2020-06-09T13:34:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyOTgyMg==", "url": "https://github.com/apache/druid/pull/9994#discussion_r437729822", "bodyText": "If value cardinality == 0, shouldn't it return this thing...\n      return new BaseVectorValueMatcher(selector)\n      {\n        final VectorMatch match = VectorMatch.wrap(new int[selector.getMaxVectorSize()]);\n\n        @Override\n        public ReadableVectorMatch match(final ReadableVectorMatch mask)\n        {\n          final int[] vector = selector.getRowVector();\n          final int[] selection = match.getSelection();\n\n          int numRows = 0;\n\n          for (int i = 0; i < mask.getSelectionSize(); i++) {\n            final int rowNum = mask.getSelection()[i];\n            if (predicate.apply(selector.lookupName(vector[rowNum]))) {\n              selection[numRows++] = rowNum;\n            }\n          }\n\n          match.setSelectionSize(numRows);\n          assert match.isValid(mask);\n          return match;\n        }\n      };", "author": "maytasm", "createdAt": "2020-06-09T21:21:19Z", "path": "processing/src/test/java/org/apache/druid/query/filter/vector/VectorValueMatcherColumnProcessorFactoryTest.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.filter.vector;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.segment.IdLookup;\n+import org.apache.druid.segment.vector.MultiValueDimensionVectorSelector;\n+import org.apache.druid.segment.vector.SingleValueDimensionVectorSelector;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.easymock.EasyMock;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class VectorValueMatcherColumnProcessorFactoryTest extends InitializedNullHandlingTest\n+{\n+  private static final int VECTOR_SIZE = 128;\n+  private static final int CURRENT_SIZE = 24;\n+  private VectorValueSelector vectorValueSelector;\n+\n+  @Before\n+  public void setup()\n+  {\n+    vectorValueSelector = EasyMock.createMock(VectorValueSelector.class);\n+    EasyMock.expect(vectorValueSelector.getCurrentVectorSize()).andReturn(CURRENT_SIZE).anyTimes();\n+    EasyMock.expect(vectorValueSelector.getMaxVectorSize()).andReturn(VECTOR_SIZE).anyTimes();\n+    EasyMock.replay(vectorValueSelector);\n+  }\n+\n+  @Test\n+  public void testFloat()\n+  {\n+    VectorValueMatcherFactory matcherFactory =\n+        VectorValueMatcherColumnProcessorFactory.instance().makeFloatProcessor(vectorValueSelector);\n+\n+    Assert.assertTrue(matcherFactory instanceof FloatVectorValueMatcher);\n+\n+    VectorValueMatcher matcher = matcherFactory.makeMatcher(\"2.0\");\n+    Assert.assertFalse(matcher instanceof BooleanVectorValueMatcher);\n+    Assert.assertEquals(VECTOR_SIZE, matcher.getMaxVectorSize());\n+    Assert.assertEquals(CURRENT_SIZE, matcher.getCurrentVectorSize());\n+\n+    // in default mode, matching null produces a boolean matcher\n+    VectorValueMatcher booleanMatcher = matcherFactory.makeMatcher((String) null);\n+    if (NullHandling.replaceWithDefault()) {\n+      Assert.assertTrue(booleanMatcher instanceof BooleanVectorValueMatcher);\n+    } else {\n+      Assert.assertFalse(booleanMatcher instanceof BooleanVectorValueMatcher);\n+    }\n+    Assert.assertEquals(VECTOR_SIZE, booleanMatcher.getMaxVectorSize());\n+    Assert.assertEquals(CURRENT_SIZE, booleanMatcher.getCurrentVectorSize());\n+    EasyMock.verify(vectorValueSelector);\n+  }\n+\n+  @Test\n+  public void testDouble()\n+  {\n+    VectorValueMatcherFactory matcherFactory =\n+        VectorValueMatcherColumnProcessorFactory.instance().makeDoubleProcessor(vectorValueSelector);\n+\n+    Assert.assertTrue(matcherFactory instanceof DoubleVectorValueMatcher);\n+\n+\n+    VectorValueMatcher matcher = matcherFactory.makeMatcher(\"1.0\");\n+    Assert.assertFalse(matcher instanceof BooleanVectorValueMatcher);\n+    Assert.assertEquals(VECTOR_SIZE, matcher.getMaxVectorSize());\n+    Assert.assertEquals(CURRENT_SIZE, matcher.getCurrentVectorSize());\n+\n+    // in default mode, matching null produces a boolean matcher\n+    VectorValueMatcher booleanMatcher = matcherFactory.makeMatcher((String) null);\n+    if (NullHandling.replaceWithDefault()) {\n+      Assert.assertTrue(booleanMatcher instanceof BooleanVectorValueMatcher);\n+    } else {\n+      Assert.assertFalse(booleanMatcher instanceof BooleanVectorValueMatcher);\n+    }\n+    Assert.assertEquals(VECTOR_SIZE, booleanMatcher.getMaxVectorSize());\n+    Assert.assertEquals(CURRENT_SIZE, booleanMatcher.getCurrentVectorSize());\n+    EasyMock.verify(vectorValueSelector);\n+  }\n+\n+  @Test\n+  public void testLong()\n+  {\n+    VectorValueMatcherFactory matcherFactory =\n+        VectorValueMatcherColumnProcessorFactory.instance().makeLongProcessor(vectorValueSelector);\n+\n+    Assert.assertTrue(matcherFactory instanceof LongVectorValueMatcher);\n+\n+    VectorValueMatcher matcher = matcherFactory.makeMatcher(\"1\");\n+    Assert.assertFalse(matcher instanceof BooleanVectorValueMatcher);\n+    Assert.assertEquals(VECTOR_SIZE, matcher.getMaxVectorSize());\n+    Assert.assertEquals(CURRENT_SIZE, matcher.getCurrentVectorSize());\n+\n+    // in default mode, matching null produces a boolean matcher\n+    VectorValueMatcher booleanMatcher = matcherFactory.makeMatcher((String) null);\n+    if (NullHandling.replaceWithDefault()) {\n+      Assert.assertTrue(booleanMatcher instanceof BooleanVectorValueMatcher);\n+    } else {\n+      Assert.assertFalse(booleanMatcher instanceof BooleanVectorValueMatcher);\n+    }\n+    Assert.assertEquals(VECTOR_SIZE, booleanMatcher.getMaxVectorSize());\n+    Assert.assertEquals(CURRENT_SIZE, booleanMatcher.getCurrentVectorSize());\n+    EasyMock.verify(vectorValueSelector);\n+  }\n+\n+  @Test\n+  public void testSingleValueString()\n+  {\n+    IdLookup lookup = EasyMock.createMock(IdLookup.class);\n+    SingleValueDimensionVectorSelector selector =\n+        EasyMock.createMock(SingleValueDimensionVectorSelector.class);\n+    EasyMock.expect(selector.getCurrentVectorSize()).andReturn(CURRENT_SIZE).anyTimes();\n+    EasyMock.expect(selector.getMaxVectorSize()).andReturn(VECTOR_SIZE).anyTimes();\n+    EasyMock.expect(selector.getValueCardinality()).andReturn(1024).anyTimes();\n+    EasyMock.expect(selector.nameLookupPossibleInAdvance()).andReturn(false).anyTimes();\n+    EasyMock.expect(selector.idLookup()).andReturn(lookup).anyTimes();\n+    EasyMock.expect(lookup.lookupId(\"any value\")).andReturn(1).anyTimes();\n+    EasyMock.expect(lookup.lookupId(\"another value\")).andReturn(-1).anyTimes();\n+    EasyMock.replay(selector, lookup);\n+\n+    VectorValueMatcherFactory matcherFactory =\n+        VectorValueMatcherColumnProcessorFactory.instance().makeSingleValueDimensionProcessor(selector);\n+\n+    Assert.assertTrue(matcherFactory instanceof SingleValueStringVectorValueMatcher);\n+\n+    // value exists in column nonboolean matcher\n+    VectorValueMatcher matcher = matcherFactory.makeMatcher(\"any value\");\n+    Assert.assertFalse(matcher instanceof BooleanVectorValueMatcher);\n+    Assert.assertEquals(VECTOR_SIZE, matcher.getMaxVectorSize());\n+    Assert.assertEquals(CURRENT_SIZE, matcher.getCurrentVectorSize());\n+\n+    // value not exist in dictionary uses boolean matcher\n+    VectorValueMatcher booleanMatcher = matcherFactory.makeMatcher(\"another value\");\n+    Assert.assertTrue(booleanMatcher instanceof BooleanVectorValueMatcher);\n+    Assert.assertEquals(VECTOR_SIZE, booleanMatcher.getMaxVectorSize());\n+    Assert.assertEquals(CURRENT_SIZE, booleanMatcher.getCurrentVectorSize());\n+    EasyMock.verify(selector, lookup);\n+  }\n+\n+  @Test\n+  public void testSingleValueStringZeroCardinalityAlwaysBooleanMatcher()\n+  {\n+    // cardinality 0 has special path to always use boolean matcher\n+    SingleValueDimensionVectorSelector selector =\n+        EasyMock.createMock(SingleValueDimensionVectorSelector.class);\n+    EasyMock.expect(selector.getCurrentVectorSize()).andReturn(CURRENT_SIZE).anyTimes();\n+    EasyMock.expect(selector.getMaxVectorSize()).andReturn(VECTOR_SIZE).anyTimes();\n+    EasyMock.expect(selector.getValueCardinality()).andReturn(0).anyTimes();\n+    EasyMock.replay(selector);\n+\n+    VectorValueMatcherFactory matcherFactory =\n+        VectorValueMatcherColumnProcessorFactory.instance().makeSingleValueDimensionProcessor(selector);\n+\n+    Assert.assertTrue(matcherFactory instanceof SingleValueStringVectorValueMatcher);\n+\n+    VectorValueMatcher matcher = matcherFactory.makeMatcher(\"any value\");\n+    Assert.assertTrue(matcher instanceof BooleanVectorValueMatcher);", "originalCommit": "278d20c741cfd12b8efbb29fdfd993b8650bfb90", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzczNTkwMw==", "url": "https://github.com/apache/druid/pull/9994#discussion_r437735903", "bodyText": "With cardinality of 0, ValueMatchers.toBooleanIfPossible will return 'false' from the path from \n  \n    \n      druid/processing/src/main/java/org/apache/druid/query/filter/vector/SingleValueStringVectorValueMatcher.java\n    \n    \n         Line 62\n      in\n      17cf8ea\n    \n    \n    \n    \n\n        \n          \n           final VectorValueMatcher booleanMatcher = toBooleanMatcherIfPossible(selector, s -> Objects.equals(s, etnValue)); \n        \n    \n  \n\n, which will make a false boolean matcher, so the current test is correct afaict.", "author": "clintropolis", "createdAt": "2020-06-09T21:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyOTgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2ODAwNQ==", "url": "https://github.com/apache/druid/pull/9994#discussion_r437768005", "bodyText": "Ahh I see. Got it.", "author": "maytasm", "createdAt": "2020-06-09T22:59:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyOTgyMg=="}], "type": "inlineReview"}]}