{"pr_number": 9488, "pr_title": "Match GREATEST/LEAST function behavior to other DBs", "pr_createdAt": "2020-03-09T22:27:27Z", "pr_url": "https://github.com/apache/druid/pull/9488", "timeline": [{"oid": "44c4b5e40ec1cabde5ba5f76707f4eb535222989", "url": "https://github.com/apache/druid/commit/44c4b5e40ec1cabde5ba5f76707f4eb535222989", "message": "Match GREATEST/LEAST function behavior\n\nChange the behavior of the GREATEST / LEAST functions to be similar to\nhow it is implemented in other databases (as functions instead of\naggregators). The GREATEST/LEAST functions are not in the SQL standard,\nbut users will expect behavior similar to what other databases provide.", "committedDate": "2020-03-09T22:20:08Z", "type": "commit"}, {"oid": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "url": "https://github.com/apache/druid/commit/ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "message": "Merge remote-tracking branch 'upstream/master' into fix-greatest-least", "committedDate": "2020-03-10T18:07:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5MjY3Mw==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391092673", "bodyText": "Given it's not standard and we can do what we want, I would suggest going with the Postgres behavior for these reasons:\n\nIMO the Postgres behavior is more likely to be useful: if I do GREATEST(x, y, z) and y is null, I probably want that to be equivalent to GREATEST(x, z).\nPostgres behavior is used as a base for a wide variety of other databases beyond the ones we're looking at here, so its behavior is influential.", "author": "gianm", "createdAt": "2020-03-11T16:17:13Z", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.", "originalCommit": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5NDg1Mg==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391094852", "bodyText": "Even though this method is private, javadocs would be nice, especially for explaining when null would be returned. The method is long enough that it is not obvious what it does without studying it.", "author": "gianm", "createdAt": "2020-03-11T16:20:20Z", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.\n+        return ExprEval.of(null);\n+      }\n+\n+      Stream<ExprEval<?>> exprEvalStream = exprAnalysis.exprEvals.stream();\n+      switch (exprAnalysis.comparisonType) {\n+        case DOUBLE:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToDouble(ExprEval::asDouble).reduce(doubleReducer).getAsDouble());\n+        case LONG:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToLong(ExprEval::asLong).reduce(longReducer).getAsLong());\n+        default:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.map(ExprEval::asString).reduce(stringReducer).get());\n+      }\n+    }\n+\n+    @Nullable\n+    private ExprAnalysis analyzeExprs(List<Expr> exprs, Expr.ObjectBinding bindings)", "originalCommit": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5NzU2NQ==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391097565", "bodyText": "I believe exprEval.value() == null is equivalent and may avoid computing the stringValue in some cases.", "author": "gianm", "createdAt": "2020-03-11T16:24:16Z", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.\n+        return ExprEval.of(null);\n+      }\n+\n+      Stream<ExprEval<?>> exprEvalStream = exprAnalysis.exprEvals.stream();\n+      switch (exprAnalysis.comparisonType) {\n+        case DOUBLE:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToDouble(ExprEval::asDouble).reduce(doubleReducer).getAsDouble());\n+        case LONG:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.mapToLong(ExprEval::asLong).reduce(longReducer).getAsLong());\n+        default:\n+          //noinspection OptionalGetWithoutIsPresent (empty list handled earlier)\n+          return ExprEval.of(exprEvalStream.map(ExprEval::asString).reduce(stringReducer).get());\n+      }\n+    }\n+\n+    @Nullable\n+    private ExprAnalysis analyzeExprs(List<Expr> exprs, Expr.ObjectBinding bindings)\n+    {\n+      Set<ExprType> presentTypes = EnumSet.noneOf(ExprType.class);\n+      List<ExprEval<?>> exprEvals = new ArrayList<>();\n+\n+      for (Expr expr : exprs) {\n+        ExprEval<?> exprEval = expr.eval(bindings);\n+        ExprType exprType = exprEval.type();\n+\n+        if (isValidType(exprType)) {\n+          presentTypes.add(exprType);\n+        }\n+\n+        if (exprEval.asString() == null) {", "originalCommit": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNjczMQ==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391106731", "bodyText": "There are more SQL types than Druid types so we need to account for all the 'extras' too. (They can show up from literals, etc.) For example a DECIMAL or FLOAT could show up and we want to treat those as doubles for purposes of this logic.\nMostly we do this mapping by using Calcites.getValueTypeForSqlTypeName \u2014\u00a0try checking that out.", "author": "gianm", "createdAt": "2020-03-11T16:37:44Z", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ReductionOperatorConversionHelper.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.sql.type.SqlReturnTypeInference;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+\n+class ReductionOperatorConversionHelper\n+{\n+  private ReductionOperatorConversionHelper()\n+  {\n+  }\n+\n+  /**\n+   * Implements rules similar to: https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_least\n+   *\n+   * @see org.apache.druid.math.expr.Function.ReduceFunc#apply\n+   * @see org.apache.druid.math.expr.Function.ReduceFunc#getComparisionType\n+   */\n+  static final SqlReturnTypeInference TYPE_INFERENCE =\n+      opBinding -> {\n+        final RelDataTypeFactory typeFactory = opBinding.getTypeFactory();\n+\n+        final int n = opBinding.getOperandCount();\n+        if (n == 0) {\n+          return typeFactory.createSqlType(SqlTypeName.NULL);\n+        }\n+\n+        boolean hasDouble = false;\n+        for (int i = 0; i < n; i++) {\n+          RelDataType type = opBinding.getOperandType(i);\n+          if (SqlTypeUtil.isString(type) || SqlTypeUtil.isCharacter(type)) {\n+            return type;\n+          } else if (SqlTypeUtil.isDouble(type)) {", "originalCommit": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwOTQ5MA==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391109490", "bodyText": "You could probably come up with some tests for these cases too.", "author": "gianm", "createdAt": "2020-03-11T16:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNjczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExMjY5Mw==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391112693", "bodyText": "Sorry if I'm mis-reading this.\nIt looks like this patch introduces expressions to calculate the greatest / least across multiple expressions. Native druid queries have a post aggregator that should do this. When I was thinking of implementing this I thought there would be a translation from sql to the native druid query with the correct post aggregator (maybe somewhere in here - OperatorConversions#toPostAggregator)\nOtherwise we'd want to make sure this behavior stays in sync with the Double/LongPostAggregators", "author": "suneet-s", "createdAt": "2020-03-11T16:46:21Z", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -976,6 +981,163 @@ protected ExprEval eval(double x, double y)\n     }\n   }\n \n+  class GreatestFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"greatest\";\n+\n+    public GreatestFunc()\n+    {\n+      super(\n+          Math::max,\n+          Math::max,\n+          BinaryOperator.maxBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  class LeastFunc extends ReduceFunc\n+  {\n+    public static final String NAME = \"least\";\n+\n+    public LeastFunc()\n+    {\n+      super(\n+          Math::min,\n+          Math::min,\n+          BinaryOperator.minBy(Comparator.naturalOrder())\n+      );\n+    }\n+\n+    @Override\n+    public String name()\n+    {\n+      return NAME;\n+    }\n+  }\n+\n+  abstract class ReduceFunc implements Function\n+  {\n+    private final DoubleBinaryOperator doubleReducer;\n+    private final LongBinaryOperator longReducer;\n+    private final BinaryOperator<String> stringReducer;\n+\n+    ReduceFunc(\n+        DoubleBinaryOperator doubleReducer,\n+        LongBinaryOperator longReducer,\n+        BinaryOperator<String> stringReducer\n+    )\n+    {\n+      this.doubleReducer = doubleReducer;\n+      this.longReducer = longReducer;\n+      this.stringReducer = stringReducer;\n+    }\n+\n+    @Override\n+    public void validateArguments(List<Expr> args)\n+    {\n+      // anything goes\n+    }\n+\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      if (args.isEmpty()) {\n+        return ExprEval.of(null);\n+      }\n+\n+      ExprAnalysis exprAnalysis = analyzeExprs(args, bindings);\n+      if (exprAnalysis == null) {\n+        // The GREATEST/LEAST functions are not in the SQL standard, but most (e.g., MySQL, Oracle) return NULL if any\n+        // are NULL. Others (e.g., Postgres) only return NULL if all are NULL, otherwise the NULLs are ignored.\n+        return ExprEval.of(null);", "originalCommit": "ff6d7fbd151f4ea543fcac1bafeaff1e22eadce8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE4NTQ5NQ==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391185495", "bodyText": "Some relevant facts:\n\nIn SQL, these functions can be used in contexts that are not post-aggregation, so that means a native Druid post-aggregator is insufficient to cover all SQL use cases\nIn native Druid queries, there is an ExpressionPostAggregator, so an expression can cover the post-aggregation use case as well as all others.\n\nTogether these mean the expression does everything we want, and the greatest/least-specific post-aggregators aren't that useful. To keep things simple, the Druid SQL layer shouldn't use the post-aggregators, it should just use the expressions via an ExpressionPostAggregator (@ccaominh's patch does achieve this).\nI agree it would be good for them to be consistent, though.", "author": "gianm", "createdAt": "2020-03-11T18:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExMjY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE4ODE3MA==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391188170", "bodyText": "Ah makes sense. Thanks for the explanation! :)", "author": "suneet-s", "createdAt": "2020-03-11T18:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExMjY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwOTgzOA==", "url": "https://github.com/apache/druid/pull/9488#discussion_r391809838", "bodyText": "Looks like the greatest/least post aggregator behavior is like postgres (ignore nulls, unless all are nulls), so another reason to switch the behavior of the expressions from mysql-like to postgres-like.", "author": "ccaominh", "createdAt": "2020-03-12T18:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExMjY5Mw=="}], "type": "inlineReview"}, {"oid": "1a5a9610e9c6e10910059bc383238b5b88c5cbd6", "url": "https://github.com/apache/druid/commit/1a5a9610e9c6e10910059bc383238b5b88c5cbd6", "message": "Match postgres behavior & handle more SQL types", "committedDate": "2020-03-12T19:06:03Z", "type": "commit"}, {"oid": "5f0fcc03ac04411af6f50607db22a67e2ca3ddf8", "url": "https://github.com/apache/druid/commit/5f0fcc03ac04411af6f50607db22a67e2ca3ddf8", "message": "Merge remote-tracking branch 'upstream/master' into fix-greatest-least", "committedDate": "2020-03-12T19:07:00Z", "type": "commit"}, {"oid": "643a3fc6fa82df975f72148971a64179958c25b7", "url": "https://github.com/apache/druid/commit/643a3fc6fa82df975f72148971a64179958c25b7", "message": "Fix imports", "committedDate": "2020-03-12T19:10:25Z", "type": "commit"}]}