{"pr_number": 9367, "pr_title": "string -> expression -> string -> expression", "pr_createdAt": "2020-02-15T11:02:17Z", "pr_url": "https://github.com/apache/druid/pull/9367", "timeline": [{"oid": "bbc5800ea8be5726e06ba29f3e6bc691289e953c", "url": "https://github.com/apache/druid/commit/bbc5800ea8be5726e06ba29f3e6bc691289e953c", "message": "add Expr.stringify which produces parseable expression strings, parser support for null values in arrays, and parser support for empty numeric arrays", "committedDate": "2020-02-15T10:48:45Z", "type": "commit"}, {"oid": "7f35b8f6025f2d3f583393f82d1a90d20bd23966", "url": "https://github.com/apache/druid/commit/7f35b8f6025f2d3f583393f82d1a90d20bd23966", "message": "oops, macros are expressions too", "committedDate": "2020-02-15T13:40:51Z", "type": "commit"}, {"oid": "6745c34f3b875e4c9be82e9d2ab2e6b9bcd9f6df", "url": "https://github.com/apache/druid/commit/6745c34f3b875e4c9be82e9d2ab2e6b9bcd9f6df", "message": "style", "committedDate": "2020-02-16T00:16:25Z", "type": "commit"}, {"oid": "9a8e23e0549112c2628feef6c3b409f53940df4d", "url": "https://github.com/apache/druid/commit/9a8e23e0549112c2628feef6c3b409f53940df4d", "message": "spotbugs", "committedDate": "2020-02-16T04:48:17Z", "type": "commit"}, {"oid": "7389deddf9e138f3ca502498eaf95cdda7af453f", "url": "https://github.com/apache/druid/commit/7389deddf9e138f3ca502498eaf95cdda7af453f", "message": "qualified type arrays", "committedDate": "2020-02-18T22:53:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2NzM3Mw==", "url": "https://github.com/apache/druid/pull/9367#discussion_r381567373", "bodyText": "Can you add a comment about why escapeJavaScript is used (or escapeJava for IdentifierExpr )?", "author": "jon-wei", "createdAt": "2020-02-19T21:53:54Z", "path": "core/src/main/java/org/apache/druid/math/expr/Expr.java", "diffHunk": "@@ -571,6 +596,12 @@ public ExprEval eval(ObjectBinding bindings)\n   {\n     return ExprEval.of(value);\n   }\n+\n+  @Override\n+  public String stringify()\n+  {\n+    return value == null ? NULL_LITERAL : StringUtils.format(\"'%s'\", StringEscapeUtils.escapeJavaScript(value));", "originalCommit": "7389deddf9e138f3ca502498eaf95cdda7af453f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU2ODkwOQ==", "url": "https://github.com/apache/druid/pull/9367#discussion_r381568909", "bodyText": "This and similar blocks could use the NULL_LITERAL constant", "author": "jon-wei", "createdAt": "2020-02-19T21:57:10Z", "path": "core/src/main/java/org/apache/druid/math/expr/ExprListenerImpl.java", "diffHunk": "@@ -109,9 +110,13 @@ public void exitDoubleExpr(ExprParser.DoubleExprContext ctx)\n   @Override\n   public void exitDoubleArray(ExprParser.DoubleArrayContext ctx)\n   {\n-    Double[] values = new Double[ctx.DOUBLE().size()];\n+    Double[] values = new Double[ctx.doubleElement().size()];\n     for (int i = 0; i < values.length; i++) {\n-      values[i] = Double.parseDouble(ctx.DOUBLE(i).getText());\n+      if (ctx.doubleElement(i).getText().equalsIgnoreCase(\"null\")) {", "originalCommit": "7389deddf9e138f3ca502498eaf95cdda7af453f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9a84920f59616b10b8b17482532ce7c181875e76", "url": "https://github.com/apache/druid/commit/9a84920f59616b10b8b17482532ce7c181875e76", "message": "Merge remote-tracking branch 'upstream/master' into reversible-expressions", "committedDate": "2020-02-19T23:17:41Z", "type": "commit"}, {"oid": "8aafe2ea0bccfe16f459069adf9e8aae8792d2f6", "url": "https://github.com/apache/druid/commit/8aafe2ea0bccfe16f459069adf9e8aae8792d2f6", "message": "review stuffs", "committedDate": "2020-02-19T23:24:29Z", "type": "commit"}, {"oid": "ad0b01fa430a16cbfcc55ded91f9224252ec783e", "url": "https://github.com/apache/druid/commit/ad0b01fa430a16cbfcc55ded91f9224252ec783e", "message": "simplify grammar", "committedDate": "2020-02-20T23:51:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNDYxNA==", "url": "https://github.com/apache/druid/pull/9367#discussion_r382324614", "bodyText": "nit: should it use Expr.ARG_JOINER?", "author": "jihoonson", "createdAt": "2020-02-20T23:50:57Z", "path": "core/src/main/java/org/apache/druid/math/expr/ExprMacroTable.java", "diffHunk": "@@ -132,17 +141,29 @@ private BindingDetails supplyAnalyzeInputs()\n    */\n   public abstract static class BaseScalarMacroFunctionExpr implements Expr\n   {\n+    protected final String name;\n     protected final List<Expr> args;\n \n     // Use Supplier to memoize values as ExpressionSelectors#makeExprEvalSelector() can make repeated calls for them\n     private final Supplier<BindingDetails> analyzeInputsSupplier;\n \n-    public BaseScalarMacroFunctionExpr(final List<Expr> args)\n+    public BaseScalarMacroFunctionExpr(String name, final List<Expr> args)\n     {\n+      this.name = name;\n       this.args = args;\n       analyzeInputsSupplier = Suppliers.memoize(this::supplyAnalyzeInputs);\n     }\n \n+    @Override\n+    public String stringify()\n+    {\n+      return StringUtils.format(\n+          \"%s(%s)\",\n+          name,\n+          Joiner.on(\", \").join(args.stream().map(Expr::stringify).iterator())", "originalCommit": "8aafe2ea0bccfe16f459069adf9e8aae8792d2f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjUxNDQ3Ng==", "url": "https://github.com/apache/druid/pull/9367#discussion_r382514476", "bodyText": "changed", "author": "clintropolis", "createdAt": "2020-02-21T10:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNDYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNDg5NQ==", "url": "https://github.com/apache/druid/pull/9367#discussion_r382324895", "bodyText": "\ud83d\udc4d", "author": "jihoonson", "createdAt": "2020-02-20T23:51:42Z", "path": "core/src/test/java/org/apache/druid/math/expr/ApplyFunctionTest.java", "diffHunk": "@@ -102,7 +102,7 @@ public void testFold()\n     assertExpr(\"fold((b, acc) -> b * acc, map((b) -> b * 2, filter(b -> b > 3, b)), 1)\", 80L);\n     assertExpr(\"fold((a, acc) -> concat(a, acc), a, '')\", \"foobarbazbarfoo\");\n     assertExpr(\"fold((a, acc) -> array_append(acc, a), a, [])\", new String[]{\"foo\", \"bar\", \"baz\", \"foobar\"});\n-    assertExpr(\"fold((a, acc) -> array_append(acc, a), b, cast([], 'LONG_ARRAY'))\", new Long[]{1L, 2L, 3L, 4L, 5L});\n+    assertExpr(\"fold((a, acc) -> array_append(acc, a), b, <LONG>[])\", new Long[]{1L, 2L, 3L, 4L, 5L});", "originalCommit": "8aafe2ea0bccfe16f459069adf9e8aae8792d2f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMDQzNw==", "url": "https://github.com/apache/druid/pull/9367#discussion_r382330437", "bodyText": "Wondering if the array elements should be casted if they are not longs.", "author": "jihoonson", "createdAt": "2020-02-21T00:10:20Z", "path": "core/src/main/java/org/apache/druid/math/expr/ExprListenerImpl.java", "diffHunk": "@@ -188,9 +195,15 @@ public void exitLogicalAndOrExpr(ExprParser.LogicalAndOrExprContext ctx)\n   @Override\n   public void exitLongArray(ExprParser.LongArrayContext ctx)\n   {\n-    Long[] values = new Long[ctx.LONG().size()];\n+    Long[] values = ctx.longArrayBody() == null\n+                    ? new Long[0]\n+                    : new Long[ctx.longArrayBody().longElement().size()];\n     for (int i = 0; i < values.length; i++) {\n-      values[i] = Long.parseLong(ctx.LONG(i).getText());\n+      if (ctx.longArrayBody().longElement(i).getText().equalsIgnoreCase(Expr.NULL_LITERAL)) {\n+        values[i] = null;\n+      } else {\n+        values[i] = Long.parseLong(ctx.longArrayBody().longElement(i).getText());", "originalCommit": "ad0b01fa430a16cbfcc55ded91f9224252ec783e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjUxNjU2MA==", "url": "https://github.com/apache/druid/pull/9367#discussion_r382516560", "bodyText": "Yeah, it seems more druidish to do that, I've modified explicitly typed numeric arrays to use a more permissive parsing with a couple of methods I've added to Numbers utility class, so <LONG>[1, 1.2, 3] and <DOUBLE>[1, 2, 3] will coerce the elements as new Long[]{1L, 1L, 3L}  and new Double[]{1.0, 2.0, 3.0} respectively, as one might hope. However, I am not converting string literals, so things like <LONG>[1, 2, '3'] are still not valid at this time.\nI also made explicit string arrays more permissive, and can accept any type of literal as an element and will convert them all to strings, <STRING>['hello', 1, 1.2] -> new String[]{\"hello\", \"1\", \"1.2\"}.\nString and long implicitly typed arrays are unchanged, but I did modify the parser to allow double implicitly typed arrays to also accept longs.", "author": "clintropolis", "createdAt": "2020-02-21T10:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMDQzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg0OTA2Ng==", "url": "https://github.com/apache/druid/pull/9367#discussion_r382849066", "bodyText": "Thanks, sounds good.", "author": "jihoonson", "createdAt": "2020-02-21T23:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMDQzNw=="}], "type": "inlineReview"}, {"oid": "276a4c56b4743ebb1d24230ba0416d388b662623", "url": "https://github.com/apache/druid/commit/276a4c56b4743ebb1d24230ba0416d388b662623", "message": "more permissive array parsing", "committedDate": "2020-02-21T10:39:46Z", "type": "commit"}, {"oid": "7efa7d616fb97e0c67e254ff2a174205acf85ad5", "url": "https://github.com/apache/druid/commit/7efa7d616fb97e0c67e254ff2a174205acf85ad5", "message": "reuse expr joiner", "committedDate": "2020-02-21T10:43:52Z", "type": "commit"}, {"oid": "56bf7c38762be0a26cbd7748d9d684ded93c1f38", "url": "https://github.com/apache/druid/commit/56bf7c38762be0a26cbd7748d9d684ded93c1f38", "message": "fix it", "committedDate": "2020-02-21T11:58:35Z", "type": "commit"}]}