{"pr_number": 10383, "pr_title": "Fix ingestion failure of pretty-formatted JSON message", "pr_createdAt": "2020-09-11T08:02:35Z", "pr_url": "https://github.com/apache/druid/pull/10383", "timeline": [{"oid": "ea0a561b0f8fd5723b88cfc9ea2e397870d75a10", "url": "https://github.com/apache/druid/commit/ea0a561b0f8fd5723b88cfc9ea2e397870d75a10", "message": "support multi-line text", "committedDate": "2020-10-16T10:30:15Z", "type": "commit"}, {"oid": "18b7b99b7fbf5cdc2ebbc5e415b750ae00129ed3", "url": "https://github.com/apache/druid/commit/18b7b99b7fbf5cdc2ebbc5e415b750ae00129ed3", "message": "add test cases", "committedDate": "2020-10-16T10:30:15Z", "type": "commit"}, {"oid": "3815eda2c0c64e904bc3e95faf0bc8d66e70963c", "url": "https://github.com/apache/druid/commit/3815eda2c0c64e904bc3e95faf0bc8d66e70963c", "message": "split json text into lines case by case", "committedDate": "2020-10-16T10:30:15Z", "type": "commit"}, {"oid": "2159cb85f4c78189159c50317c45741f2ee0ea34", "url": "https://github.com/apache/druid/commit/2159cb85f4c78189159c50317c45741f2ee0ea34", "message": "improve exception handle", "committedDate": "2020-10-16T10:30:15Z", "type": "commit"}, {"oid": "129db850e933a43b9a05cc5f6567eea2cde585d9", "url": "https://github.com/apache/druid/commit/129db850e933a43b9a05cc5f6567eea2cde585d9", "message": "fix CI", "committedDate": "2020-10-16T10:30:16Z", "type": "commit"}, {"oid": "93b06abb80b3f18a57905539a6675ecd73a16e49", "url": "https://github.com/apache/druid/commit/93b06abb80b3f18a57905539a6675ecd73a16e49", "message": "use IntermediateRowParsingReader as base of JsonReader", "committedDate": "2020-10-16T10:30:16Z", "type": "commit"}, {"oid": "9d3822450e205dcc1bccaa4763ef3e34d65ee6ff", "url": "https://github.com/apache/druid/commit/9d3822450e205dcc1bccaa4763ef3e34d65ee6ff", "message": "update doc", "committedDate": "2020-10-16T10:30:16Z", "type": "commit"}, {"oid": "7df940c5db2dbc594e00c29bcf0a3e743cd6d228", "url": "https://github.com/apache/druid/commit/7df940c5db2dbc594e00c29bcf0a3e743cd6d228", "message": "ignore the non-immutable field in test case", "committedDate": "2020-10-16T10:30:16Z", "type": "commit"}, {"oid": "330b16c4f8d023040b3556854a65272f3e152883", "url": "https://github.com/apache/druid/commit/330b16c4f8d023040b3556854a65272f3e152883", "message": "add more test cases", "committedDate": "2020-10-16T10:30:16Z", "type": "commit"}, {"oid": "3649e89afe8736218441cea6236757ab6737e58d", "url": "https://github.com/apache/druid/commit/3649e89afe8736218441cea6236757ab6737e58d", "message": "mark `lineSplittable` as final", "committedDate": "2020-10-16T10:30:16Z", "type": "commit"}, {"oid": "929f2a208cf2773b9c1d6fe52b79f337c7fd4a53", "url": "https://github.com/apache/druid/commit/929f2a208cf2773b9c1d6fe52b79f337c7fd4a53", "message": "fix testcases", "committedDate": "2020-10-16T10:30:16Z", "type": "commit"}, {"oid": "078410d4cb4a8ad8340b1f5f04da3d897698400b", "url": "https://github.com/apache/druid/commit/078410d4cb4a8ad8340b1f5f04da3d897698400b", "message": "fix doc", "committedDate": "2020-10-16T10:30:16Z", "type": "commit"}, {"oid": "d0f449ec2a3472755524ae4fccbbe9e852c55594", "url": "https://github.com/apache/druid/commit/d0f449ec2a3472755524ae4fccbbe9e852c55594", "message": "add a test case for SqlReader", "committedDate": "2020-10-16T10:30:16Z", "type": "commit"}, {"oid": "fd34e1d0f6b762ba6cab93b966ccbe3ef1a79374", "url": "https://github.com/apache/druid/commit/fd34e1d0f6b762ba6cab93b966ccbe3ef1a79374", "message": "return all raw columns when exception occurs", "committedDate": "2020-10-16T10:36:42Z", "type": "commit"}, {"oid": "fd34e1d0f6b762ba6cab93b966ccbe3ef1a79374", "url": "https://github.com/apache/druid/commit/fd34e1d0f6b762ba6cab93b966ccbe3ef1a79374", "message": "return all raw columns when exception occurs", "committedDate": "2020-10-16T10:36:42Z", "type": "forcePushed"}, {"oid": "8cba03019a59001efb391aa15240c1946cc1cfb1", "url": "https://github.com/apache/druid/commit/8cba03019a59001efb391aa15240c1946cc1cfb1", "message": "fix CI", "committedDate": "2020-10-19T09:36:42Z", "type": "commit"}, {"oid": "a9eb12a548e961ab700a43b064735d52f4495c40", "url": "https://github.com/apache/druid/commit/a9eb12a548e961ab700a43b064735d52f4495c40", "message": "fix test cases", "committedDate": "2020-10-20T05:18:26Z", "type": "commit"}, {"oid": "a9eb12a548e961ab700a43b064735d52f4495c40", "url": "https://github.com/apache/druid/commit/a9eb12a548e961ab700a43b064735d52f4495c40", "message": "fix test cases", "committedDate": "2020-10-20T05:18:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2OTgwMg==", "url": "https://github.com/apache/druid/pull/10383#discussion_r510469802", "bodyText": "nit: it would be better to use Iterables.getOnlyElement(rawValues) to make sure that you are getting the only element.", "author": "jihoonson", "createdAt": "2020-10-22T21:31:10Z", "path": "core/src/main/java/org/apache/druid/data/input/InputRowListPlusRawValues.java", "diffHunk": "@@ -82,8 +121,16 @@ private InputRowListPlusRawValues(\n     return inputRows;\n   }\n \n+  /**\n+   * This method is left here only for test cases\n+   */\n   @Nullable\n   public Map<String, Object> getRawValues()\n+  {\n+    return CollectionUtils.isNullOrEmpty(rawValues) ? null : rawValues.get(0);", "originalCommit": "a9eb12a548e961ab700a43b064735d52f4495c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUzMzk0NA==", "url": "https://github.com/apache/druid/pull/10383#discussion_r512533944", "bodyText": "But Iterables.getOnlyElement does not check whether the given input is null or not. If the given input is null, there will be a NPE.", "author": "FrankChen021", "createdAt": "2020-10-27T09:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2OTgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAyODA2OQ==", "url": "https://github.com/apache/druid/pull/10383#discussion_r513028069", "bodyText": "I meant, for rawValues.get(0) to make sure there is only one element in there if this method is called.", "author": "jihoonson", "createdAt": "2020-10-27T21:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2OTgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTY5Mw==", "url": "https://github.com/apache/druid/pull/10383#discussion_r512261693", "bodyText": "ParseException is Nullable.", "author": "jihoonson", "createdAt": "2020-10-26T20:54:23Z", "path": "core/src/main/java/org/apache/druid/data/input/InputRowListPlusRawValues.java", "diffHunk": "@@ -53,21 +54,59 @@ public static InputRowListPlusRawValues of(@Nullable InputRow inputRow, Map<Stri\n \n   public static InputRowListPlusRawValues of(@Nullable List<InputRow> inputRows, Map<String, Object> rawColumns)\n   {\n-    return new InputRowListPlusRawValues(inputRows, Preconditions.checkNotNull(rawColumns, \"rawColumns\"), null);\n+    return new InputRowListPlusRawValues(inputRows,\n+                                         Collections.singletonList(Preconditions.checkNotNull(rawColumns, \"rawColumns\")),\n+                                         null);\n   }\n \n   public static InputRowListPlusRawValues of(@Nullable Map<String, Object> rawColumns, ParseException parseException)\n   {\n     return new InputRowListPlusRawValues(\n         null,\n-        rawColumns,\n+        rawColumns == null ? null : Collections.singletonList(rawColumns),\n         Preconditions.checkNotNull(parseException, \"parseException\")\n     );\n   }\n \n+  public static InputRowListPlusRawValues ofList(@Nullable List<Map<String, Object>> rawColumnsList, ParseException parseException)\n+  {\n+    return ofList(rawColumnsList, null, parseException);\n+  }\n+\n+  /**\n+   * Create an instance of {@link InputRowListPlusRawValues}\n+   *\n+   * Make sure the size of given rawColumnsList and inputRows are the same if both of them are not null\n+   */\n+  public static InputRowListPlusRawValues ofList(@Nullable List<Map<String, Object>> rawColumnsList,\n+                                                 @Nullable List<InputRow> inputRows)\n+  {\n+    return ofList(rawColumnsList, inputRows, null);\n+  }\n+\n+  /**\n+   * Create an instance of {@link InputRowListPlusRawValues}\n+   *\n+   * Make sure the size of given rawColumnsList and inputRows are the same if both of them are not null\n+   */\n+  public static InputRowListPlusRawValues ofList(@Nullable List<Map<String, Object>> rawColumnsList,\n+                                                 @Nullable List<InputRow> inputRows,\n+                                                 ParseException parseException)", "originalCommit": "a9eb12a548e961ab700a43b064735d52f4495c40", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NTM3OQ==", "url": "https://github.com/apache/druid/pull/10383#discussion_r512265379", "bodyText": "Can this introduce duplicate rows in responseRows? Suppose you have 3 rawColumns in rawColumnsList including an unparseable row at the second position. The first row will be added to both index and thus a new SamplerResponseRow of the first rawColumns will be added to responseRows. But for the second row, index.add() will throw a ParseException which will execute these lines. In this case, 2 duplicate rawColumns of the first row will be added in responseRows.\nLooking at what JsonReader does, it seems throwing away the whole intermediateRow when there is any unparseable row. The sampler behavior should match to the actual ingestion.", "author": "jihoonson", "createdAt": "2020-10-26T21:01:10Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/sampler/InputSourceSampler.java", "diffHunk": "@@ -131,17 +130,27 @@ public SamplerResponse sample(\n             continue;\n           }\n \n-          for (InputRow row : inputRowListPlusRawValues.getInputRows()) {\n-            index.add(new SamplerInputRow(row, counter), true);\n+          for (int i = 0; i < rawColumnsList.size(); i++) {\n+            Map<String, Object> rawColumns = rawColumnsList.get(i);\n+            InputRow row = inputRowListPlusRawValues.getInputRows().get(i);\n+\n+            //keep the index of the row to be added to responseRows for further use\n+            final int rowIndex = responseRows.size();\n+            index.add(new SamplerInputRow(row, rowIndex), true);\n+\n             // store the raw value; will be merged with the data from the IncrementalIndex later\n-            responseRows[counter] = new SamplerResponseRow(rawColumns, null, null, null);\n-            counter++;\n+            responseRows.add(new SamplerResponseRow(rawColumns, null, null, null));\n             numRowsIndexed++;\n           }\n         }\n         catch (ParseException e) {\n-          responseRows[counter] = new SamplerResponseRow(rawColumns, null, true, e.getMessage());\n-          counter++;\n+          if (rawColumnsList != null) {\n+            responseRows.addAll(rawColumnsList.stream()\n+                                              .map(rawColumns -> new SamplerResponseRow(rawColumns, null, true, e.getMessage()))\n+                                              .collect(Collectors.toList()));", "originalCommit": "a9eb12a548e961ab700a43b064735d52f4495c40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU0NDMwMA==", "url": "https://github.com/apache/druid/pull/10383#discussion_r512544300", "bodyText": "I notice that index.add does not throw ParseException but returns the exception in its returning result. The previous version of InputSourceSampler checks the result to rethrow this exception, while the change introduced by #10336 deletes these exception related code, which means the code here won't throw ParseException.\nOf course, there's possibility that the code in for-loop throws ParseException in future. I've made little changes to avoid this potential situation to happen. Let's check it once the CI passes.\nBTW, my local branch has failed to build since last time it was rebased on master, I have to reply on the CI to check if there're any test case failures.", "author": "FrankChen021", "createdAt": "2020-10-27T09:43:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAyODAzNw==", "url": "https://github.com/apache/druid/pull/10383#discussion_r513028037", "bodyText": "I notice that index.add does not throw ParseException but returns the exception in its returning result. The previous version of InputSourceSampler checks the result to rethrow this exception, while the change introduced by #10336 deletes these exception related code, which means the code here won't throw ParseException.\nOf course, there's possibility that the code in for-loop throws ParseException in future. I've made little changes to avoid this potential situation to happen. Let's check it once the CI passes.\n\nOops, good point. I forgot what I have done in #10336.. I think index.add() should never throw parseException directly, but return them in IncrementalIndexAddResult. We can add this contract on the Javadoc of IncrementalIndex.add(). I suggest removing the catch clause here to avoid future confusion (there is no point in catching exceptions which cannot be thrown here).", "author": "jihoonson", "createdAt": "2020-10-27T21:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIzNDYxNQ==", "url": "https://github.com/apache/druid/pull/10383#discussion_r513234615", "bodyText": "Got it. BTW, should we handle the exception returned in IncrementalIndexAddResult by adding the corresponding row to responseRows ?", "author": "FrankChen021", "createdAt": "2020-10-28T07:43:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY0NjQwOQ==", "url": "https://github.com/apache/druid/pull/10383#discussion_r513646409", "bodyText": "Yes, I think so because the sampler result should match to what will actually be ingested to Druid.", "author": "jihoonson", "createdAt": "2020-10-28T17:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0MjIxOA==", "url": "https://github.com/apache/druid/pull/10383#discussion_r515442218", "bodyText": "A new case testIndexParseException in InputSouceSamplerTest has been added to check whether the exception returned by index.add has been processed properly. And also some little changes are applied in IncrementalIndex.getCombinedParseException and SampleInputRow to make exception message more accurate.", "author": "FrankChen021", "createdAt": "2020-10-31T01:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2NTM3OQ=="}], "type": "inlineReview"}, {"oid": "167a579aa28f1733509cec436e60d50a322fef26", "url": "https://github.com/apache/druid/commit/167a579aa28f1733509cec436e60d50a322fef26", "message": "resolve review comments", "committedDate": "2020-10-27T09:36:58Z", "type": "commit"}, {"oid": "4288c4a3087eb78079b365e26d5b3878c9cf2f67", "url": "https://github.com/apache/druid/commit/4288c4a3087eb78079b365e26d5b3878c9cf2f67", "message": "handle ParseException returned by index.add", "committedDate": "2020-10-30T08:20:33Z", "type": "commit"}, {"oid": "c1157d2f13f8cff3e3539fb64555c2eb1cba3c21", "url": "https://github.com/apache/druid/commit/c1157d2f13f8cff3e3539fb64555c2eb1cba3c21", "message": "apply Iterables.getOnlyElement", "committedDate": "2020-10-30T08:25:36Z", "type": "commit"}, {"oid": "150c57954f30c2b9f267556f1e4e47402c124bee", "url": "https://github.com/apache/druid/commit/150c57954f30c2b9f267556f1e4e47402c124bee", "message": "fix CI", "committedDate": "2020-10-30T10:42:41Z", "type": "commit"}, {"oid": "e89053e22659effbf6bad7f198ad002528fe1727", "url": "https://github.com/apache/druid/commit/e89053e22659effbf6bad7f198ad002528fe1727", "message": "fix test cases", "committedDate": "2020-10-31T01:24:19Z", "type": "commit"}, {"oid": "2e5c1306ba4df053c54419e726fed24e457387d3", "url": "https://github.com/apache/druid/commit/2e5c1306ba4df053c54419e726fed24e457387d3", "message": "improve code in more graceful way", "committedDate": "2020-10-31T01:46:00Z", "type": "commit"}, {"oid": "3a9076cfe7b8c767b02888f03b98133f9a480f26", "url": "https://github.com/apache/druid/commit/3a9076cfe7b8c767b02888f03b98133f9a480f26", "message": "fix test cases", "committedDate": "2020-11-01T12:03:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxMzc5OQ==", "url": "https://github.com/apache/druid/pull/10383#discussion_r520013799", "bodyText": "nit: with this change, when a parseException is thrown while parsing a list of rows in one message, those rows in the message will be added as separate rows in responseRows but with the same parseException. This can be confusing since the parseException error message seem irrelevant to the associated rawColumns in the same responseRow. IMO, the better fix in this case would be storing the whole rawColumnsList in one SamplerResponseRow. Then, the parseException can indicate that it was thrown while parsing one of the rows in rawColumnsList. However, this requires a change on the web console side as well. I'm OK with fixing this in a follow-up PR.", "author": "jihoonson", "createdAt": "2020-11-09T18:06:14Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/sampler/InputSourceSampler.java", "diffHunk": "@@ -111,38 +113,49 @@ public SamplerResponse sample(\n     try (final CloseableIterator<InputRowListPlusRawValues> iterator = reader.sample();\n          final IncrementalIndex<Aggregator> index = buildIncrementalIndex(nonNullSamplerConfig, nonNullDataSchema);\n          final Closer closer1 = closer) {\n-      SamplerResponseRow[] responseRows = new SamplerResponseRow[nonNullSamplerConfig.getNumRows()];\n-      int counter = 0, numRowsIndexed = 0;\n-\n-      while (counter < responseRows.length && iterator.hasNext()) {\n-        Map<String, Object> rawColumns = null;\n-        try {\n-          final InputRowListPlusRawValues inputRowListPlusRawValues = iterator.next();\n-\n-          if (inputRowListPlusRawValues.getRawValues() != null) {\n-            rawColumns = inputRowListPlusRawValues.getRawValues();\n-          }\n-\n-          if (inputRowListPlusRawValues.getParseException() != null) {\n-            throw inputRowListPlusRawValues.getParseException();\n+      List<SamplerResponseRow> responseRows = new ArrayList<>(nonNullSamplerConfig.getNumRows());\n+      int numRowsIndexed = 0;\n+\n+      while (responseRows.size() < nonNullSamplerConfig.getNumRows() && iterator.hasNext()) {\n+        final InputRowListPlusRawValues inputRowListPlusRawValues = iterator.next();\n+\n+        final List<Map<String, Object>> rawColumnsList = inputRowListPlusRawValues.getRawValuesList();\n+\n+        final ParseException parseException = inputRowListPlusRawValues.getParseException();\n+        if (parseException != null) {\n+          if (rawColumnsList != null) {\n+            // add all rows to response\n+            responseRows.addAll(rawColumnsList.stream()\n+                                              .map(rawColumns -> new SamplerResponseRow(rawColumns, null, true, parseException.getMessage()))\n+                                              .collect(Collectors.toList()));", "originalCommit": "3a9076cfe7b8c767b02888f03b98133f9a480f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI3NTgxOA==", "url": "https://github.com/apache/druid/pull/10383#discussion_r520275818", "bodyText": "Yes, returning the whole rawColumnsList involves some changes at the web-console side which is currently out of my ability. Thanks for understanding.", "author": "FrankChen021", "createdAt": "2020-11-10T04:16:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxMzc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxODgxMQ==", "url": "https://github.com/apache/druid/pull/10383#discussion_r520018811", "bodyText": "Did you intend StringUtils.toUtf8(illformed)? The variable illformed is not in use.", "author": "jihoonson", "createdAt": "2020-11-09T18:14:52Z", "path": "extensions-core/kafka-indexing-service/src/test/java/org/apache/druid/indexing/kafka/KafkaIndexTaskTest.java", "diffHunk": "@@ -2726,4 +2726,83 @@ public void close()\n         null\n     );\n   }\n+\n+  @Test(timeout = 60_000L)\n+  public void testMultipleLinesJSONText() throws Exception\n+  {\n+    reportParseExceptions = false;\n+    maxParseExceptions = 1000;\n+    maxSavedParseExceptions = 2;\n+\n+    // Insert data\n+    try (final KafkaProducer<byte[], byte[]> kafkaProducer = kafkaServer.newProducer()) {\n+      kafkaProducer.initTransactions();\n+      kafkaProducer.beginTransaction();\n+\n+      //multiple objects in one Kafka record will yield 2 rows in druid\n+      String wellformed = toJsonString(true, \"2049\", \"d2\", \"y\", \"10\", \"22.0\", \"2.0\") +\n+                     toJsonString(true, \"2049\", \"d3\", \"y\", \"10\", \"23.0\", \"3.0\");\n+\n+      //multiple objects in one Kafka record but some objects are in ill-formed format\n+      //the whole ProducerRecord will be discarded\n+      String illformed = \"{\\\"timestamp\\\":2049, \\\"dim1\\\": \\\"d4\\\", \\\"dim2\\\":\\\"x\\\", \\\"dimLong\\\": 10, \\\"dimFloat\\\":\\\"24.0\\\", \\\"met1\\\":\\\"2.0\\\" }\" +\n+                     \"{\\\"timestamp\\\":2049, \\\"dim1\\\": \\\"d5\\\", \\\"dim2\\\":\\\"y\\\", \\\"dimLong\\\": 10, \\\"dimFloat\\\":\\\"24.0\\\", \\\"met1\\\":invalidFormat }\" +\n+                     \"{\\\"timestamp\\\":2049, \\\"dim1\\\": \\\"d6\\\", \\\"dim2\\\":\\\"z\\\", \\\"dimLong\\\": 10, \\\"dimFloat\\\":\\\"24.0\\\", \\\"met1\\\":\\\"3.0\\\" }\";\n+\n+      ProducerRecord[] producerRecords = new ProducerRecord[]{\n+          // pretty formatted\n+          new ProducerRecord<>(topic, 0, null, jb(true, \"2049\", \"d1\", \"y\", \"10\", \"20.0\", \"1.0\")),\n+          //well-formed\n+          new ProducerRecord<>(topic, 0, null, StringUtils.toUtf8(wellformed)),\n+          //ill-formed\n+          new ProducerRecord<>(topic, 0, null, StringUtils.toUtf8(\"illformed\")),", "originalCommit": "3a9076cfe7b8c767b02888f03b98133f9a480f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI3NTQ3Mw==", "url": "https://github.com/apache/druid/pull/10383#discussion_r520275473", "bodyText": "Yes, illformed here should be a variable instead of a text string.", "author": "FrankChen021", "createdAt": "2020-11-10T04:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAxODgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyNDg4Nw==", "url": "https://github.com/apache/druid/pull/10383#discussion_r520024887", "bodyText": "Thanks for adding this test! Similar to https://github.com/apache/druid/pull/10383/files#diff-ef25ac1cc1f275b47b939b65e1d0c8b8b8512aeada52d06b8541b8f381df03eeR2731, could you please add a unit test for sampling a block of multiple JSON strings? The unit test can be run only when parserType is STR_JSON. We usually just return in the unit test when the parameter is not what we want to test with. It would be nice if the test verifies the followings:\n\nThe sampler response when there is no parseException with a list of multiple JSON strings.\nThe sampler response when there is a parseException thrown while parsing a list of multiple JSON strings. Maybe you can improve this unit test to do it as well.", "author": "jihoonson", "createdAt": "2020-11-09T18:25:13Z", "path": "indexing-service/src/test/java/org/apache/druid/indexing/overlord/sampler/InputSourceSamplerTest.java", "diffHunk": "@@ -1060,6 +1062,107 @@ public void testWithFilter() throws IOException\n     );\n   }\n \n+  @Test\n+  public void testIndexParseException() throws IOException", "originalCommit": "3a9076cfe7b8c767b02888f03b98133f9a480f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI3NTUwMw==", "url": "https://github.com/apache/druid/pull/10383#discussion_r520275503", "bodyText": "A block of multiple json strings is only supported in stream ingestion as we discussed above, that's also why the test cases are added in kafka-indexing-service module.It's implemented by setting the new property on JsonInputFormat in RecordSupplierInputSource.\nFor test cases for InputSourceSampler here, the input source is InlineInputSource which always uses InputEntityIteratingReader even when input format is JsonInputFormat, there's no chance to test that. So I think we don't need add test cases here.", "author": "FrankChen021", "createdAt": "2020-11-10T04:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyNDg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4NjAwNA==", "url": "https://github.com/apache/druid/pull/10383#discussion_r520286004", "bodyText": "I think we need such tests because KafkaIndexTaskTest only covers the actual indexing side, but not the sampling side. Without those tests, we could break the sampler without being noticed.\n\nFor test cases for InputSourceSampler here, the input source is InlineInputSource which always uses InputEntityIteratingReader even when input format is JsonInputFormat, there's no chance to test that. So I think we don't need add test cases here.\n\nMaybe this is not a good place for the new tests, but you don't have to use the InlineInputSource for them. Rather, you should use RecordSupplierInputSource as you mentioned. Since RecordSupplierInputSource accepts the RecordSupplier interface as a parameter which is the data supplier, I think you could implement a mock for testing (I don't think we should test Firehose as it's deprecated). Or do you see some reason you cannot? If it's hard, I'm also OK with adding them in a follow-up.", "author": "jihoonson", "createdAt": "2020-11-10T04:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyNDg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0NzgwNQ==", "url": "https://github.com/apache/druid/pull/10383#discussion_r520347805", "bodyText": "I think we need such tests because KafkaIndexTaskTest only covers the actual indexing side, but not the sampling side. Without those tests, we could break the sampler without being noticed.\n\nI forgot that test cases in KafkaIndexTaskTest only cover the indexing process. It's OK for me to add such tests.\nBTW, integration tests failed, I don't think it's related to changes in this PR, and the failure can also be seen in my other PR, is there any other problem ?", "author": "FrankChen021", "createdAt": "2020-11-10T07:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyNDg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1NDE1Ng==", "url": "https://github.com/apache/druid/pull/10383#discussion_r520354156", "bodyText": "Thanks for understanding. Do you want to add those tests in this PR? For the integration test failure, I don\u2019t think it\u2019s relevant to the changes in this PR. I just retriggered it.", "author": "jihoonson", "createdAt": "2020-11-10T07:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyNDg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNTYwMg==", "url": "https://github.com/apache/druid/pull/10383#discussion_r520435602", "bodyText": "I've added a test testMultipleJsonStringInOneBlock,  please check it.", "author": "FrankChen021", "createdAt": "2020-11-10T10:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyNDg4Nw=="}], "type": "inlineReview"}, {"oid": "50718ce5f8c6862edcdf094895afc277c3229d62", "url": "https://github.com/apache/druid/commit/50718ce5f8c6862edcdf094895afc277c3229d62", "message": "fix test cases", "committedDate": "2020-11-10T04:18:20Z", "type": "commit"}, {"oid": "19fae71afb3d6f750a468c5bca2e8cdddb55a71f", "url": "https://github.com/apache/druid/commit/19fae71afb3d6f750a468c5bca2e8cdddb55a71f", "message": "add a test case to check multiple json string in one text block", "committedDate": "2020-11-10T09:47:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1ODk2MQ==", "url": "https://github.com/apache/druid/pull/10383#discussion_r520758961", "bodyText": "[ERROR] indexing-service/src/test/java/org/apache/druid/indexing/overlord/sampler/InputSourceSamplerTest.java:1221 -- Can be replaced with 'Collectors.joining'\n\nSeems like the Intellij Inspection CI doesn't like this line.", "author": "jihoonson", "createdAt": "2020-11-10T17:55:37Z", "path": "indexing-service/src/test/java/org/apache/druid/indexing/overlord/sampler/InputSourceSamplerTest.java", "diffHunk": "@@ -1163,6 +1172,121 @@ public void testIndexParseException() throws IOException\n     );\n   }\n \n+  /**\n+   *\n+   * This case tests sampling for multiple json lines in one text block\n+   * Currently only RecordSupplierInputSource supports this kind of input, see https://github.com/apache/druid/pull/10383 for more information\n+   *\n+   * This test combines illegal json block and legal json block together to verify:\n+   * 1. all lines in the illegal json block should not be parsed\n+   * 2. the illegal json block should not affect the processing of the 2nd record\n+   * 3. all lines in legal json block should be parsed successfully\n+   *\n+   */\n+  @Test\n+  public void testMultipleJsonStringInOneBlock() throws IOException\n+  {\n+    if (!ParserType.STR_JSON.equals(parserType) || !useInputFormatApi) {\n+      return;\n+    }\n+\n+    final TimestampSpec timestampSpec = new TimestampSpec(\"t\", null, null);\n+    final DimensionsSpec dimensionsSpec = new DimensionsSpec(\n+        ImmutableList.of(StringDimensionSchema.create(\"dim1PlusBar\"))\n+    );\n+    final TransformSpec transformSpec = new TransformSpec(\n+        null,\n+        ImmutableList.of(new ExpressionTransform(\"dim1PlusBar\", \"concat(dim1 + 'bar')\", TestExprMacroTable.INSTANCE))\n+    );\n+    final AggregatorFactory[] aggregatorFactories = {new LongSumAggregatorFactory(\"met1\", \"met1\")};\n+    final GranularitySpec granularitySpec = new UniformGranularitySpec(\n+        Granularities.DAY,\n+        Granularities.HOUR,\n+        true,\n+        null\n+    );\n+    final DataSchema dataSchema = createDataSchema(\n+        timestampSpec,\n+        dimensionsSpec,\n+        aggregatorFactories,\n+        granularitySpec,\n+        transformSpec\n+    );\n+\n+    List<String> jsonBlockList = ImmutableList.of(\n+        // include the line which can't be parsed into JSON object to form a illegal json block\n+        String.join(\"\", STR_JSON_ROWS),\n+\n+        // exclude the last line to form a legal json block\n+        String.join(\"\", STR_JSON_ROWS.stream().limit(STR_JSON_ROWS.size() - 1).collect(Collectors.toList()))", "originalCommit": "19fae71afb3d6f750a468c5bca2e8cdddb55a71f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAwMTgzNw==", "url": "https://github.com/apache/druid/pull/10383#discussion_r521001837", "bodyText": "Every time I push a commit to a branch that is being merge, I run the test cases in the module which contains the changes in that commit. If it's OK, I'll push the commit. But I find that there's a high probability that CI fails. Sometime it's related to inspection check, sometimes it's caused by failures of test cases in other modules, sometime it's about dependency check, sometime it has something with license check.\nI wonder what steps do you follow to check before push a commit ? Do you run all the cases in all modules ? Or is there a simple way to run the checks mentioned above ?", "author": "FrankChen021", "createdAt": "2020-11-11T01:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1ODk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA3OTc0MQ==", "url": "https://github.com/apache/druid/pull/10383#discussion_r521079741", "bodyText": "could you re-trigger the CI ? The failure does not related to changes in the PR.\nFailed with bad exit code during 'Extraction'\n\n[ERROR] Failed to execute goal on project druid-sql: Could not resolve dependencies for project org.apache.druid:druid-sql:jar:0.21.0-SNAPSHOT: Failed to collect dependencies at org.apache.calcite:calcite-core:jar:1.21.0 -> org.codehaus.janino:janino:jar:3.0.11: Failed to read artifact descriptor for org.codehaus.janino:janino:jar:3.0.11: Could not transfer artifact org.codehaus.janino:janino-parent:pom:3.0.11 from/to central (https://repo.maven.apache.org/maven2): Failed to transfer file https://repo.maven.apache.org/maven2/org/codehaus/janino/janino-parent/3.0.11/janino-parent-3.0.11.pom with status code 503 -> [Help 1]", "author": "FrankChen021", "createdAt": "2020-11-11T03:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1ODk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA4MzYzOQ==", "url": "https://github.com/apache/druid/pull/10383#discussion_r521083639", "bodyText": "Re-triggered LGTM", "author": "suneet-s", "createdAt": "2020-11-11T03:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1ODk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI1OTY2MA==", "url": "https://github.com/apache/druid/pull/10383#discussion_r521259660", "bodyText": "Hi @suneet-s , do you have any comments ?", "author": "FrankChen021", "createdAt": "2020-11-11T10:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1ODk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1NzEwMA==", "url": "https://github.com/apache/druid/pull/10383#discussion_r521857100", "bodyText": "Every time I push a commit to a branch that is being merge, I run the test cases in the module which contains the changes in that commit. If it's OK, I'll push the commit. But I find that there's a high probability that CI fails. Sometime it's related to inspection check, sometimes it's caused by failures of test cases in other modules, sometime it's about dependency check, sometime it has something with license check.\nI wonder what steps do you follow to check before push a commit ? Do you run all the cases in all modules ? Or is there a simple way to run the checks mentioned above ?\n\n@FrankChen021 That's what I usually do as well. To be honest, unexpected CI failures make me annoyed too \ud83d\ude05 You can run those checks on your own by running the same command as what Travis runs. You may want to set up some pre-commit/post-commit hooks. The best would be some automatic correction for trivial issues, but I'm not sure if there is such a tool available which is matured and reliable enough.", "author": "jihoonson", "createdAt": "2020-11-12T05:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1ODk2MQ=="}], "type": "inlineReview"}, {"oid": "fbe683a24385d9c64a83f2f1e8ea6c81ad77a3f4", "url": "https://github.com/apache/druid/commit/fbe683a24385d9c64a83f2f1e8ea6c81ad77a3f4", "message": "fix inspection check", "committedDate": "2020-11-11T01:25:38Z", "type": "commit"}]}