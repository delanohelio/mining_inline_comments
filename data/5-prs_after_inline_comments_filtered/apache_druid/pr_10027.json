{"pr_number": 10027, "pr_title": "fix query memory leak", "pr_createdAt": "2020-06-12T07:24:58Z", "pr_url": "https://github.com/apache/druid/pull/10027", "timeline": [{"oid": "dcbf02b89a16ffcde941c3e16917d751038f277f", "url": "https://github.com/apache/druid/commit/dcbf02b89a16ffcde941c3e16917d751038f277f", "message": "fix query memory leak", "committedDate": "2020-06-12T06:11:57Z", "type": "commit"}, {"oid": "64698dd54627c1072651216468584d5648cd6ed4", "url": "https://github.com/apache/druid/commit/64698dd54627c1072651216468584d5648cd6ed4", "message": "rollup ./idea", "committedDate": "2020-06-12T08:04:05Z", "type": "commit"}, {"oid": "8d390def22edc9f0dcb561d729fc30797f4a6956", "url": "https://github.com/apache/druid/commit/8d390def22edc9f0dcb561d729fc30797f4a6956", "message": "roll up ./idea dir", "committedDate": "2020-06-12T08:07:03Z", "type": "commit"}, {"oid": "5df370bdadee598ba3e90036c9cf25c0e49d3ca7", "url": "https://github.com/apache/druid/commit/5df370bdadee598ba3e90036c9cf25c0e49d3ca7", "message": "roll up .idea", "committedDate": "2020-06-12T08:25:09Z", "type": "commit"}, {"oid": "341546694389b219bc887e425ad5ee89e7958e7d", "url": "https://github.com/apache/druid/commit/341546694389b219bc887e425ad5ee89e7958e7d", "message": "clean code", "committedDate": "2020-06-12T08:27:18Z", "type": "commit"}, {"oid": "c82bda7d6f5dc6465797c61b12dafd8775fbf06b", "url": "https://github.com/apache/druid/commit/c82bda7d6f5dc6465797c61b12dafd8775fbf06b", "message": "optimize style", "committedDate": "2020-06-12T13:02:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MjAwNA==", "url": "https://github.com/apache/druid/pull/10027#discussion_r440572004", "bodyText": "Can f.cancel(true) throw an exception? I'm not sure, but if so I guess we should catch it and keep canceling more futures.", "author": "gianm", "createdAt": "2020-06-16T03:56:56Z", "path": "processing/src/main/java/org/apache/druid/query/ChainedExecutionQueryRunner.java", "diffHunk": "@@ -141,34 +142,38 @@ public ChainedExecutionQueryRunner(\n                           );\n                         }\n                     )\n-                )\n-            );\n+                );\n \n-            queryWatcher.registerQueryFuture(query, futures);\n+            Function<Throwable, Void> cancelFunction = (t) -> {\n+              futures.forEach(f -> f.cancel(true));", "originalCommit": "c82bda7d6f5dc6465797c61b12dafd8775fbf06b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MjIwNQ==", "url": "https://github.com/apache/druid/pull/10027#discussion_r440572205", "bodyText": "This little block is used in a few places, and it would be good to include comments about why it's needed.\nCould you please move it to GuavaUtils and also make the following changes:\n\nAdd a comment about why it's needed: it's an alternative to Futures.allAsList(...).cancel, that is necessary because Futures.allAsList creates a Future that cannot be canceled if one of its constituent futures has already failed. (This comment is the real reason that it's good to have it be its own function.)\nThe function isn't doing anything with the Throwable, so it could just be void cancelAll(List<Future<T>>).\nAdd unit tests to GuavaUtilsTest.\n\nThen we can do stuff like GuavaUtils.cancelAll(futures).", "author": "gianm", "createdAt": "2020-06-16T03:57:57Z", "path": "processing/src/main/java/org/apache/druid/query/ChainedExecutionQueryRunner.java", "diffHunk": "@@ -141,34 +142,38 @@ public ChainedExecutionQueryRunner(\n                           );\n                         }\n                     )\n-                )\n-            );\n+                );\n \n-            queryWatcher.registerQueryFuture(query, futures);\n+            Function<Throwable, Void> cancelFunction = (t) -> {", "originalCommit": "c82bda7d6f5dc6465797c61b12dafd8775fbf06b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MTI3Nw==", "url": "https://github.com/apache/druid/pull/10027#discussion_r441191277", "bodyText": "I've been thinking about this, and it seems good to use CompletableFuture rather than having another home-grown util method for ListenableFuture. But it needs more work like how to support the query priority with CompletableFuture, it would be fine to add a util method for now.", "author": "jihoonson", "createdAt": "2020-06-16T23:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MjIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzOTU1MA==", "url": "https://github.com/apache/druid/pull/10027#discussion_r441639550", "bodyText": "This little block is used in a few places, and it would be good to include comments about why it's needed.\nCould you please move it to GuavaUtils and also make the following changes:\n\nAdd a comment about why it's needed: it's an alternative to Futures.allAsList(...).cancel, that is necessary because Futures.allAsList creates a Future that cannot be canceled if one of its constituent futures has already failed. (This comment is the real reason that it's good to have it be its own function.)\nThe function isn't doing anything with the Throwable, so it could just be void cancelAll(List<Future<T>>).\nAdd unit tests to GuavaUtilsTest.\n\nThen we can do stuff like GuavaUtils.cancelAll(futures).\n\nThanks for your advice, I've revised it.", "author": "chenyuzhi459", "createdAt": "2020-06-17T15:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MjIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MzEzMg==", "url": "https://github.com/apache/druid/pull/10027#discussion_r440573132", "bodyText": "Similar comments as in ChainedExecutionQueryRunner about GuavaUtils.", "author": "gianm", "createdAt": "2020-06-16T04:02:15Z", "path": "processing/src/main/java/org/apache/druid/query/GroupByMergedQueryRunner.java", "diffHunk": "@@ -173,11 +173,16 @@ public T apply(Row input)\n \n   private void waitForFutureCompletion(\n       GroupByQuery query,\n-      ListenableFuture<?> future,\n+      List<ListenableFuture<Void>> futures,\n       IncrementalIndex<?> closeOnFailure\n   )\n   {\n+    Function<Throwable, Void> cancelFunction = (t) -> {", "originalCommit": "c82bda7d6f5dc6465797c61b12dafd8775fbf06b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "894e975399b4e9ce3552242790c40b68b4193fca", "url": "https://github.com/apache/druid/commit/894e975399b4e9ce3552242790c40b68b4193fca", "message": "optimize cancel function", "committedDate": "2020-06-17T15:24:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3OTUzNA==", "url": "https://github.com/apache/druid/pull/10027#discussion_r441779534", "bodyText": "We shouldn't chomp Throwables, because they're generally bad things that should interrupt execution. It'd be better to either assume no exceptions, i.e.:\nfutures.forEach(f -> f.cancel(true));\nOr surface Errors, but suppress and log exceptions:\nfutures.forEach(f -> {\n  try {\n    f.cancel(true);\n  } catch (Exception e) {\n    log.warn(e, \"Error while canceling future.\");\n  }\n});\nIMO, the first one is best if we can assure ourselves that ListenableFuture.cancel isn't going to throw exceptions. Looking at AbstractFuture, it seems like it won't, so the first option looks safe to me.", "author": "gianm", "createdAt": "2020-06-17T19:21:36Z", "path": "core/src/main/java/org/apache/druid/common/guava/GuavaUtils.java", "diffHunk": "@@ -77,4 +79,24 @@ public static Long tryParseLong(@Nullable String string)\n     }\n     return arg1;\n   }\n+\n+  /**\n+   * Cancel futures manually, because sometime we can't cancel all futures in {@link com.google.common.util.concurrent.Futures.CombinedFuture}\n+   * automatically. Especially when we call {@link  com.google.common.util.concurrent.Futures#allAsList(Iterable)} to create a batch of\n+   * future.\n+   * @param futures The futures that we want to cancel\n+   * @param <T>   The result type returned by this Future's {@code get} method\n+   */\n+  public static <T, F  extends Future<T>> void cancelAll(List<F> futures){\n+    if(futures == null || futures.isEmpty()){\n+      return;\n+    }\n+    futures.forEach(f -> {\n+      try {\n+        f.cancel(true);\n+      } catch (Throwable t){\n+        //do nothing and continue the loop.", "originalCommit": "894e975399b4e9ce3552242790c40b68b4193fca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyNzM0OQ==", "url": "https://github.com/apache/druid/pull/10027#discussion_r441927349", "bodyText": "Well, I think it's great that we shouldn't chomp throwables. But the method that AbstractFuture.cancel probably throws exceptions because it will execute future's listeners which is called by ExecutionList.executeListener. And ExecutionList.executeListener only catch RuntimeException, thus i think we should log exceptions.", "author": "chenyuzhi459", "createdAt": "2020-06-18T02:04:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3OTUzNA=="}], "type": "inlineReview"}, {"oid": "4c52185e1aa34763eab4dd9902e609b8a7fd474f", "url": "https://github.com/apache/druid/commit/4c52185e1aa34763eab4dd9902e609b8a7fd474f", "message": "optimize style", "committedDate": "2020-06-18T02:28:54Z", "type": "commit"}, {"oid": "166fc326d71109719a1750c3d1c88fc217ae3b8b", "url": "https://github.com/apache/druid/commit/166fc326d71109719a1750c3d1c88fc217ae3b8b", "message": "add concurrentGroupTest test case", "committedDate": "2020-06-18T14:42:24Z", "type": "commit"}, {"oid": "af9508b3435627162f99db79e3984a5312a54690", "url": "https://github.com/apache/druid/commit/af9508b3435627162f99db79e3984a5312a54690", "message": "add test case", "committedDate": "2020-06-18T16:38:58Z", "type": "commit"}, {"oid": "f2c07e3b815d17e2d5839cf5a624bad56e70cece", "url": "https://github.com/apache/druid/commit/f2c07e3b815d17e2d5839cf5a624bad56e70cece", "message": "add unit test", "committedDate": "2020-06-19T16:29:09Z", "type": "commit"}, {"oid": "9114052a29755adc61681eba2e6538f75011f5a0", "url": "https://github.com/apache/druid/commit/9114052a29755adc61681eba2e6538f75011f5a0", "message": "fix code style", "committedDate": "2020-06-20T03:39:01Z", "type": "commit"}, {"oid": "7734da50f0385ff92d8ace7bbeb56e25e83f1772", "url": "https://github.com/apache/druid/commit/7734da50f0385ff92d8ace7bbeb56e25e83f1772", "message": "optimize cancell method use", "committedDate": "2020-06-23T09:35:07Z", "type": "commit"}, {"oid": "c0941b7816db0a606fe12eea8e0a1066268054ab", "url": "https://github.com/apache/druid/commit/c0941b7816db0a606fe12eea8e0a1066268054ab", "message": "format code", "committedDate": "2020-06-23T13:49:21Z", "type": "commit"}, {"oid": "7fc9d5036af8003f1a576ccab128b57571ad03fd", "url": "https://github.com/apache/druid/commit/7fc9d5036af8003f1a576ccab128b57571ad03fd", "message": "reback code", "committedDate": "2020-06-24T02:24:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMDA4MQ==", "url": "https://github.com/apache/druid/pull/10027#discussion_r445720081", "bodyText": "It seems easy to forget canceling future and so error-prone. How about modifying GuavaUtils.cancelAll() to take future as well? So it would be like\n  public static <F extends Future<?>> void cancelAll(\n      boolean mayInterruptIfRunning,\n      @Nullable ListenableFuture<?> combinedFuture,\n      List<F> futures\n  )\n  {\n    final List<Future> allFuturesToCancel = new ArrayList<>(futures);\n    allFuturesToCancel.add(combinedFuture);\n    if (allFuturesToCancel.isEmpty()) {\n      return;\n    }\n    allFuturesToCancel.forEach(f -> {\n      try {\n        f.cancel(mayInterruptIfRunning);\n      }\n      catch (Throwable t) {\n        log.warn(t, \"Error while cancelling future.\");\n      }\n    });\n  }", "author": "jihoonson", "createdAt": "2020-06-25T17:26:26Z", "path": "processing/src/main/java/org/apache/druid/query/ChainedExecutionQueryRunner.java", "diffHunk": "@@ -141,33 +144,34 @@ public ChainedExecutionQueryRunner(\n                           );\n                         }\n                     )\n-                )\n-            );\n+                );\n \n-            queryWatcher.registerQueryFuture(query, futures);\n+            ListenableFuture<List<Iterable<T>>> future = Futures.allAsList(futures);\n+            queryWatcher.registerQueryFuture(query, future);\n \n             try {\n               return new MergeIterable<>(\n                   ordering.nullsFirst(),\n                   QueryContexts.hasTimeout(query) ?\n-                      futures.get(QueryContexts.getTimeout(query), TimeUnit.MILLISECONDS) :\n-                      futures.get()\n+                      future.get(QueryContexts.getTimeout(query), TimeUnit.MILLISECONDS) :\n+                      future.get()\n               ).iterator();\n             }\n             catch (InterruptedException e) {\n               log.noStackTrace().warn(e, \"Query interrupted, cancelling pending results, query id [%s]\", query.getId());\n-              futures.cancel(true);\n+              GuavaUtils.cancelAll(true, ImmutableList.<Future>builder().add(future).addAll(futures).build());", "originalCommit": "7fc9d5036af8003f1a576ccab128b57571ad03fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMDQ3NA==", "url": "https://github.com/apache/druid/pull/10027#discussion_r445720474", "bodyText": "Or, more structured way to do could be adding a new CombinedFuture like this\n  public static class CombinedFuture<V> implements Future<List<V>>\n  {\n    private final List<ListenableFuture<V>> underlyingFutures;\n    private final ListenableFuture<List<V>> combined;\n    \n    public CombinedFuture(List<ListenableFuture<V>> futures)\n    {\n      this.underlyingFutures = futures;\n      this.combined = Futures.allAsList(futures);\n    }\n\n    @Override\n    public boolean cancel(boolean mayInterruptIfRunning)\n    {\n      if (combined.isDone() || combined.isCancelled()) {\n        return false;\n      } else {\n        cancelAll(mayInterruptIfRunning, combined, underlyingFutures);\n        return true;\n      }\n    }\n\n    @Override\n    public boolean isCancelled()\n    {\n      return combined.isCancelled();\n    }\n\n    @Override\n    public boolean isDone()\n    {\n      return combined.isDone();\n    }\n\n    @Override\n    public List<V> get() throws InterruptedException, ExecutionException\n    {\n      return combined.get();\n    }\n\n    @Override\n    public List<V> get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException\n    {\n      return combined.get(timeout, unit);\n    }\n  }\nI'm fine with either way.", "author": "jihoonson", "createdAt": "2020-06-25T17:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMDA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzE1MA==", "url": "https://github.com/apache/druid/pull/10027#discussion_r446193150", "bodyText": "It seems easy to forget canceling future and so error-prone. How about modifying GuavaUtils.cancelAll() to take future as well? So it would be like\n  public static <F extends Future<?>> void cancelAll(\n      boolean mayInterruptIfRunning,\n      @Nullable ListenableFuture<?> combinedFuture,\n      List<F> futures\n  )\n  {\n    final List<Future> allFuturesToCancel = new ArrayList<>(futures);\n    allFuturesToCancel.add(combinedFuture);\n    if (allFuturesToCancel.isEmpty()) {\n      return;\n    }\n    allFuturesToCancel.forEach(f -> {\n      try {\n        f.cancel(mayInterruptIfRunning);\n      }\n      catch (Throwable t) {\n        log.warn(t, \"Error while cancelling future.\");\n      }\n    });\n  }\n\nWell, thanks for your tips, i'll follow it except one point. It's better to cancel the combinedFuture first, because if we cancel the first future in  underlyingFutures  , it will trigger the listener of com.google.common.util.concurrent.Futures.CombinedFuture which is added for every future in underlyingFutures  by init method. This listener is actually a method called setOneValue  which will set combinedFuture's status as CANCELLED rather than INTERRUTED as we expect when we cancel the first future of underlyingFutures cause of the CancellationException.\nIn addition , the listener of combinedFuture will set the status of other future in underlyingFutures   as the same with itself(CANCELLED rather than INTERRUTED as we expect). I have test it in the test of testQueryTimeout in ChainedExecutionQueryRunnerTest use the sequences of [underlyingFutures, combinedFuture], it failed cause  the second future was not INTERRUTED but CANCELLED", "author": "chenyuzhi459", "createdAt": "2020-06-26T13:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMDA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyMzUyNw==", "url": "https://github.com/apache/druid/pull/10027#discussion_r446323527", "bodyText": "Ah makes sense \ud83d\udc4d. Would you please add a comment on this line about why we cancel it first? It would help other people to understand your intention. Maybe the comment can say \"Canceling combinedFuture first so that it can complete with INTERRUPTED as its final state. See ChainedExecutionQueryRunnerTest.testQueryTimeout()\".", "author": "jihoonson", "createdAt": "2020-06-26T17:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMDA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMTQ1OQ==", "url": "https://github.com/apache/druid/pull/10027#discussion_r445721459", "bodyText": "nit: future should be canceled on exceptions too. This is nit since this class is used only by groupBy v1 which is deprecated.", "author": "jihoonson", "createdAt": "2020-06-25T17:28:46Z", "path": "processing/src/main/java/org/apache/druid/query/GroupByMergedQueryRunner.java", "diffHunk": "@@ -187,7 +189,7 @@ private void waitForFutureCompletion(\n     }\n     catch (InterruptedException e) {\n       log.warn(e, \"Query interrupted, cancelling pending results, query id [%s]\", query.getId());\n-      future.cancel(true);\n+      GuavaUtils.cancelAll(true, futures);", "originalCommit": "7fc9d5036af8003f1a576ccab128b57571ad03fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIxMDgxOQ==", "url": "https://github.com/apache/druid/pull/10027#discussion_r446210819", "bodyText": "Thanks for your tip, i forgot it and now it have been fixed.", "author": "chenyuzhi459", "createdAt": "2020-06-26T14:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyMTQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyNTAyMw==", "url": "https://github.com/apache/druid/pull/10027#discussion_r445725023", "bodyText": "nit: the variable name starting with an underscore is not Java convention. How about mergedRunner?", "author": "jihoonson", "createdAt": "2020-06-25T17:34:57Z", "path": "processing/src/test/java/org/apache/druid/query/groupby/GroupByQueryRunnerFailureTest.java", "diffHunk": "@@ -281,4 +281,41 @@ public void testInsufficientResourcesOnBroker()\n       }\n     }\n   }\n+\n+  @Test(timeout = 60_000L)\n+  public void testTimeoutExceptionOnQueryable()\n+  {\n+    expectedException.expect(QueryInterruptedException.class);\n+    expectedException.expectCause(CoreMatchers.instanceOf(TimeoutException.class));\n+\n+    final GroupByQuery query = GroupByQuery\n+        .builder()\n+        .setDataSource(QueryRunnerTestHelper.DATA_SOURCE)\n+        .setQuerySegmentSpec(QueryRunnerTestHelper.FIRST_TO_THIRD)\n+        .setDimensions(new DefaultDimensionSpec(\"quality\", \"alias\"))\n+        .setAggregatorSpecs(new LongSumAggregatorFactory(\"rows\", \"rows\"))\n+        .setGranularity(QueryRunnerTestHelper.DAY_GRAN)\n+        .overrideContext(ImmutableMap.of(QueryContexts.TIMEOUT_KEY, 1))\n+        .build();\n+\n+    GroupByQueryRunnerFactory factory = makeQueryRunnerFactory(\n+        GroupByQueryRunnerTest.DEFAULT_MAPPER,\n+        new GroupByQueryConfig()\n+        {\n+          @Override\n+          public String getDefaultStrategy()\n+          {\n+            return \"v2\";\n+          }\n+\n+          @Override\n+          public boolean isSingleThreaded()\n+          {\n+            return true;\n+          }\n+        }\n+    );\n+    QueryRunner<ResultRow> _runnnner = factory.mergeRunners(Execs.directExecutor(), ImmutableList.of(runner));", "originalCommit": "7fc9d5036af8003f1a576ccab128b57571ad03fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIxMTIyNQ==", "url": "https://github.com/apache/druid/pull/10027#discussion_r446211225", "bodyText": "It have been fixed", "author": "chenyuzhi459", "createdAt": "2020-06-26T14:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyNTAyMw=="}], "type": "inlineReview"}, {"oid": "2ff5917185ea805d14b136a2aeb82aebf8f36dff", "url": "https://github.com/apache/druid/commit/2ff5917185ea805d14b136a2aeb82aebf8f36dff", "message": "optimize cancelAll", "committedDate": "2020-06-26T14:10:11Z", "type": "commit"}, {"oid": "a51d7e16f5f15af33fa239419aaa82bffb99f8f5", "url": "https://github.com/apache/druid/commit/a51d7e16f5f15af33fa239419aaa82bffb99f8f5", "message": "clean code", "committedDate": "2020-06-26T15:38:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMwMzkzMQ==", "url": "https://github.com/apache/druid/pull/10027#discussion_r446303931", "bodyText": "[ERROR] /home/travis/build/apache/druid/core/src/main/java/org/apache/druid/common/guava/GuavaUtils.java:26: 'javax.annotation.Nullable' should be separated from previous imports. [ImportOrder]\nThe checkstyle wants an empty line between the Lines 26 and 27.", "author": "jihoonson", "createdAt": "2020-06-26T17:02:21Z", "path": "core/src/main/java/org/apache/druid/common/guava/GuavaUtils.java", "diffHunk": "@@ -23,8 +23,8 @@\n import com.google.common.base.Strings;\n import com.google.common.primitives.Longs;\n import org.apache.druid.java.util.common.logger.Logger;\n-\n import javax.annotation.Nullable;\n+import java.util.ArrayList;", "originalCommit": "a51d7e16f5f15af33fa239419aaa82bffb99f8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MTA3Mg==", "url": "https://github.com/apache/druid/pull/10027#discussion_r446471072", "bodyText": "ok, it's done.", "author": "chenyuzhi459", "createdAt": "2020-06-27T02:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMwMzkzMQ=="}], "type": "inlineReview"}, {"oid": "2b0bc1acc77496ae3efbfb77bcb1e63fbee9adf2", "url": "https://github.com/apache/druid/commit/2b0bc1acc77496ae3efbfb77bcb1e63fbee9adf2", "message": "add comment", "committedDate": "2020-06-27T00:24:19Z", "type": "commit"}]}