{"pr_number": 9610, "pr_title": "Fix NPE in RemoteTaskRunner event handler causes JVM shutdown", "pr_createdAt": "2020-04-03T05:17:15Z", "pr_url": "https://github.com/apache/druid/pull/9610", "timeline": [{"oid": "576bf2ae86253050d39b29f1ffd3cf55d7309385", "url": "https://github.com/apache/druid/commit/576bf2ae86253050d39b29f1ffd3cf55d7309385", "message": "Fix NPE in RemoteTaskRunner event handler causes JVM shutdown", "committedDate": "2020-04-03T05:10:41Z", "type": "commit"}, {"oid": "82c979e994e74bf2add2b0de537c101f9fc7f844", "url": "https://github.com/apache/druid/commit/82c979e994e74bf2add2b0de537c101f9fc7f844", "message": "address comments", "committedDate": "2020-04-03T20:32:44Z", "type": "commit"}, {"oid": "51106421b12a43b7f27bc2db0c033997378c85cc", "url": "https://github.com/apache/druid/commit/51106421b12a43b7f27bc2db0c033997378c85cc", "message": "fix compile", "committedDate": "2020-04-03T20:46:11Z", "type": "commit"}, {"oid": "376b9b243b37dc9dd65d6350cb8ee7493b11ec47", "url": "https://github.com/apache/druid/commit/376b9b243b37dc9dd65d6350cb8ee7493b11ec47", "message": "fix checkstyle", "committedDate": "2020-04-03T23:31:52Z", "type": "commit"}, {"oid": "88c5286e29ddff853e08a65c370a29ad0d8f3d12", "url": "https://github.com/apache/druid/commit/88c5286e29ddff853e08a65c370a29ad0d8f3d12", "message": "fix lgtm", "committedDate": "2020-04-03T23:54:34Z", "type": "commit"}, {"oid": "70cc2fc2351e93d59e7dde8a561217bf37e6ca3e", "url": "https://github.com/apache/druid/commit/70cc2fc2351e93d59e7dde8a561217bf37e6ca3e", "message": "Merge remote-tracking branch 'upstream/master' into IMPLY-2589", "committedDate": "2020-04-04T01:17:57Z", "type": "commit"}, {"oid": "17da2c587ed1a1c61926c05740b81068d7d8cbae", "url": "https://github.com/apache/druid/commit/17da2c587ed1a1c61926c05740b81068d7d8cbae", "message": "fix merge", "committedDate": "2020-04-04T01:38:55Z", "type": "commit"}, {"oid": "868176850bab929a43a7e1f3a8de4c48047afda4", "url": "https://github.com/apache/druid/commit/868176850bab929a43a7e1f3a8de4c48047afda4", "message": "fix test", "committedDate": "2020-04-04T01:54:25Z", "type": "commit"}, {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99", "url": "https://github.com/apache/druid/commit/258bfe476f5377789faec9bbf6ab9e1869110f99", "message": "fix tests", "committedDate": "2020-04-04T04:00:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA==", "url": "https://github.com/apache/druid/pull/9610#discussion_r403433584", "bodyText": "Per the PR description/linked javadocs, can this and other usages of event.getData() in this switch statement be null? I guess we are relying on an NPE happening and then the catch checking and handling there? It might be nicer to explicitly check and throw a more useful error about the ChildData for the event unexpectedly being null so that the alerted exception is more useful", "author": "clintropolis", "createdAt": "2020-04-04T06:38:42Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "diffHunk": "@@ -1081,6 +979,117 @@ private boolean cancelWorkerCleanup(String workerHost)\n     }\n   }\n \n+  @VisibleForTesting\n+  PathChildrenCacheListener getStatusListener(final Worker worker, final ZkWorker zkWorker, final SettableFuture<ZkWorker> retVal)\n+  {\n+    return (client, event) -> {\n+      final String taskId;\n+      final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n+      synchronized (statusLock) {\n+        try {\n+          switch (event.getType()) { // lgtm [java/dereferenced-value-may-be-null]\n+            case CHILD_ADDED:\n+            case CHILD_UPDATED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]", "originalCommit": "258bfe476f5377789faec9bbf6ab9e1869110f99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjQyMA==", "url": "https://github.com/apache/druid/pull/9610#discussion_r403436420", "bodyText": "Yes. event.getData() can be null here and everywhere else in this function. I dont think we need to do anything differently in handling the null from event.getData() so I just let NPE happens and the catch will take care of logging and making sure the JVM doesnt shutdown. You can deduce that the NPE from event.getData() happens from the data map of the alert and the Exception that was produced", "author": "maytasm", "createdAt": "2020-04-04T07:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzODU5NA==", "url": "https://github.com/apache/druid/pull/9610#discussion_r403438594", "bodyText": "The childData itself is null. The only other data that we have is the eventType which we can always add to the alert? or only add to alert if childData is null", "author": "maytasm", "createdAt": "2020-04-04T07:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NTE5MA==", "url": "https://github.com/apache/druid/pull/9610#discussion_r404395190", "bodyText": "Yes. event.getData() can be null here and everywhere else in this function. I dont think we need to do anything differently in handling the null from event.getData() so I just let NPE happens and the catch will take care of logging and making sure the JVM doesnt shutdown.\n\neven.getData() can be null depending on the event type; it must not be null for CHILD_ADDED, CHILD_UPDATED, and CHILD_REMOVED events. It should be null otherwise. I think it's worth checking null depending on the event type.", "author": "jihoonson", "createdAt": "2020-04-06T21:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5OTUxOQ==", "url": "https://github.com/apache/druid/pull/9610#discussion_r404399519", "bodyText": "You can deduce that the NPE from event.getData() happens from the data map of the alert and the Exception that was produced\n\nAh yeah, I know I can deduce this, my point was more to be useful for operators who see an error or alert and don't want to dig through the code, which is probably most of them, that we could indicate friendlier messaging that an unexpected situation where the child data was null occurred on a zk event.", "author": "clintropolis", "createdAt": "2020-04-06T21:28:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5MzMwNQ==", "url": "https://github.com/apache/druid/pull/9610#discussion_r404593305", "bodyText": "Confirmed that event cannot be null. Removed null check for the event.\nAdded a null check blocks for event.getData() with different alert message than the existing message for catching any Exception. This should be more helpful to operators. Let me know if you have suggestion on different wording or other KV data to add to alert. This check is for the CHILD_ADDED, CHILD_UPDATED, and CHILD_REMOVED events which even.getData() must not be null.", "author": "maytasm", "createdAt": "2020-04-07T07:28:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA=="}], "type": "inlineReview"}, {"oid": "d6b76ba077c058107b655699004f435a9f8ba554", "url": "https://github.com/apache/druid/commit/d6b76ba077c058107b655699004f435a9f8ba554", "message": "change scope", "committedDate": "2020-04-04T07:29:12Z", "type": "commit"}, {"oid": "0e62d3da2abb5d05a7bf89f304c8031a2c1a5163", "url": "https://github.com/apache/druid/commit/0e62d3da2abb5d05a7bf89f304c8031a2c1a5163", "message": "address comments", "committedDate": "2020-04-04T07:42:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MTMxMw==", "url": "https://github.com/apache/druid/pull/9610#discussion_r404391313", "bodyText": "I don't think event can ever be null. Check out callers of PathChildrenCache.callListeners().", "author": "jihoonson", "createdAt": "2020-04-06T21:12:44Z", "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "diffHunk": "@@ -969,116 +970,129 @@ private boolean cancelWorkerCleanup(String workerHost)\n       );\n \n       // Add status listener to the watcher for status changes\n-      zkWorker.addListener(\n-          (client, event) -> {\n-            final String taskId;\n-            final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n-            synchronized (statusLock) {\n-              try {\n-                switch (event.getType()) {\n-                  case CHILD_ADDED:\n-                  case CHILD_UPDATED:\n-                    taskId = ZKPaths.getNodeFromPath(event.getData().getPath());\n-                    final TaskAnnouncement announcement = jsonMapper.readValue(\n-                        event.getData().getData(), TaskAnnouncement.class\n-                    );\n-\n-                    log.info(\n-                        \"Worker[%s] wrote %s status for task [%s] on [%s]\",\n-                        zkWorker.getWorker().getHost(),\n-                        announcement.getTaskStatus().getStatusCode(),\n-                        taskId,\n-                        announcement.getTaskLocation()\n-                    );\n-\n-                    // Synchronizing state with ZK\n-                    statusLock.notifyAll();\n-\n-                    final RemoteTaskRunnerWorkItem tmp;\n-                    if ((tmp = runningTasks.get(taskId)) != null) {\n-                      taskRunnerWorkItem = tmp;\n-                    } else {\n-                      final RemoteTaskRunnerWorkItem newTaskRunnerWorkItem = new RemoteTaskRunnerWorkItem(\n-                          taskId,\n-                          announcement.getTaskType(),\n-                          zkWorker.getWorker(),\n-                          TaskLocation.unknown(),\n-                          announcement.getTaskDataSource()\n-                      );\n-                      final RemoteTaskRunnerWorkItem existingItem = runningTasks.putIfAbsent(\n-                          taskId,\n-                          newTaskRunnerWorkItem\n-                      );\n-                      if (existingItem == null) {\n-                        log.warn(\n-                            \"Worker[%s] announced a status for a task I didn't know about, adding to runningTasks: %s\",\n-                            zkWorker.getWorker().getHost(),\n-                            taskId\n-                        );\n-                        taskRunnerWorkItem = newTaskRunnerWorkItem;\n-                      } else {\n-                        taskRunnerWorkItem = existingItem;\n-                      }\n-                    }\n-\n-                    if (!announcement.getTaskLocation().equals(taskRunnerWorkItem.getLocation())) {\n-                      taskRunnerWorkItem.setLocation(announcement.getTaskLocation());\n-                      TaskRunnerUtils.notifyLocationChanged(listeners, taskId, announcement.getTaskLocation());\n-                    }\n+      zkWorker.addListener(getStatusListener(worker, zkWorker, retVal));\n+      zkWorker.start();\n+      return retVal;\n+    }\n+    catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n \n-                    if (announcement.getTaskStatus().isComplete()) {\n-                      taskComplete(taskRunnerWorkItem, zkWorker, announcement.getTaskStatus());\n-                      runPendingTasks();\n-                    }\n-                    break;\n-                  case CHILD_REMOVED:\n-                    taskId = ZKPaths.getNodeFromPath(event.getData().getPath());\n-                    taskRunnerWorkItem = runningTasks.remove(taskId);\n-                    if (taskRunnerWorkItem != null) {\n-                      log.info(\"Task[%s] just disappeared!\", taskId);\n-                      taskRunnerWorkItem.setResult(TaskStatus.failure(taskId));\n-                      TaskRunnerUtils.notifyStatusChanged(listeners, taskId, TaskStatus.failure(taskId));\n-                    } else {\n-                      log.info(\"Task[%s] went bye bye.\", taskId);\n-                    }\n-                    break;\n-                  case INITIALIZED:\n-                    if (zkWorkers.putIfAbsent(worker.getHost(), zkWorker) == null) {\n-                      retVal.set(zkWorker);\n-                    } else {\n-                      final String message = StringUtils.format(\n-                          \"WTF?! Tried to add already-existing worker[%s]\",\n-                          worker.getHost()\n-                      );\n-                      log.makeAlert(message)\n-                         .addData(\"workerHost\", worker.getHost())\n-                         .addData(\"workerIp\", worker.getIp())\n-                         .emit();\n-                      retVal.setException(new IllegalStateException(message));\n-                    }\n-                    runPendingTasks();\n-                    break;\n-                  case CONNECTION_SUSPENDED:\n-                  case CONNECTION_RECONNECTED:\n-                  case CONNECTION_LOST:\n-                    // do nothing\n+  @VisibleForTesting\n+  PathChildrenCacheListener getStatusListener(final Worker worker, final ZkWorker zkWorker, final SettableFuture<ZkWorker> retVal)\n+  {\n+    return (client, event) -> {\n+      final String taskId;\n+      final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n+      synchronized (statusLock) {\n+        try {\n+          switch (event.getType()) { // lgtm [java/dereferenced-value-may-be-null]\n+            case CHILD_ADDED:\n+            case CHILD_UPDATED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]\n+              final TaskAnnouncement announcement = jsonMapper.readValue(\n+                  event.getData().getData(), TaskAnnouncement.class // lgtm [java/dereferenced-value-may-be-null]\n+              );\n+\n+              log.info(\n+                  \"Worker[%s] wrote %s status for task [%s] on [%s]\",\n+                  zkWorker.getWorker().getHost(),\n+                  announcement.getTaskStatus().getStatusCode(),\n+                  taskId,\n+                  announcement.getTaskLocation()\n+              );\n+\n+              // Synchronizing state with ZK\n+              statusLock.notifyAll();\n+\n+              final RemoteTaskRunnerWorkItem tmp;\n+              if ((tmp = runningTasks.get(taskId)) != null) {\n+                taskRunnerWorkItem = tmp;\n+              } else {\n+                final RemoteTaskRunnerWorkItem newTaskRunnerWorkItem = new RemoteTaskRunnerWorkItem(\n+                    taskId,\n+                    announcement.getTaskType(),\n+                    zkWorker.getWorker(),\n+                    TaskLocation.unknown(),\n+                    announcement.getTaskDataSource()\n+                );\n+                final RemoteTaskRunnerWorkItem existingItem = runningTasks.putIfAbsent(\n+                    taskId,\n+                    newTaskRunnerWorkItem\n+                );\n+                if (existingItem == null) {\n+                  log.warn(\n+                      \"Worker[%s] announced a status for a task I didn't know about, adding to runningTasks: %s\",\n+                      zkWorker.getWorker().getHost(),\n+                      taskId\n+                  );\n+                  taskRunnerWorkItem = newTaskRunnerWorkItem;\n+                } else {\n+                  taskRunnerWorkItem = existingItem;\n                 }\n               }\n-              catch (Exception e) {\n-                log.makeAlert(e, \"Failed to handle new worker status\")\n-                   .addData(\"worker\", zkWorker.getWorker().getHost())\n-                   .addData(\"znode\", event.getData().getPath())\n+\n+              if (!announcement.getTaskLocation().equals(taskRunnerWorkItem.getLocation())) {\n+                taskRunnerWorkItem.setLocation(announcement.getTaskLocation());\n+                TaskRunnerUtils.notifyLocationChanged(listeners, taskId, announcement.getTaskLocation());\n+              }\n+\n+              if (announcement.getTaskStatus().isComplete()) {\n+                taskComplete(taskRunnerWorkItem, zkWorker, announcement.getTaskStatus());\n+                runPendingTasks();\n+              }\n+              break;\n+            case CHILD_REMOVED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]\n+              taskRunnerWorkItem = runningTasks.remove(taskId);\n+              if (taskRunnerWorkItem != null) {\n+                log.info(\"Task[%s] just disappeared!\", taskId);\n+                taskRunnerWorkItem.setResult(TaskStatus.failure(taskId));\n+                TaskRunnerUtils.notifyStatusChanged(listeners, taskId, TaskStatus.failure(taskId));\n+              } else {\n+                log.info(\"Task[%s] went bye bye.\", taskId);\n+              }\n+              break;\n+            case INITIALIZED:\n+              if (zkWorkers.putIfAbsent(worker.getHost(), zkWorker) == null) {\n+                retVal.set(zkWorker);\n+              } else {\n+                final String message = StringUtils.format(\n+                    \"This should not happen...tried to add already-existing worker[%s]\",\n+                    worker.getHost()\n+                );\n+                log.makeAlert(message)\n+                   .addData(\"workerHost\", worker.getHost())\n+                   .addData(\"workerIp\", worker.getIp())\n                    .emit();\n+                retVal.setException(new IllegalStateException(message));\n               }\n+              runPendingTasks();\n+              break;\n+            case CONNECTION_SUSPENDED:\n+            case CONNECTION_RECONNECTED:\n+            case CONNECTION_LOST:\n+              // do nothing\n+          }\n+        }\n+        catch (Exception e) {\n+          String znode = null;\n+          String eventType = null;\n+          if (event != null) {", "originalCommit": "0e62d3da2abb5d05a7bf89f304c8031a2c1a5163", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTUyNw==", "url": "https://github.com/apache/druid/pull/9610#discussion_r404595527", "bodyText": "event cannot be null. I added the check just in case upstream and/or dependency library changes. This is to prevent the JVM from shutting down. I removed it for now.", "author": "maytasm", "createdAt": "2020-04-07T07:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MTMxMw=="}], "type": "inlineReview"}, {"oid": "fb9ced297bdf033e5e235b26dbcc874501d13f75", "url": "https://github.com/apache/druid/commit/fb9ced297bdf033e5e235b26dbcc874501d13f75", "message": "address comments", "committedDate": "2020-04-07T07:41:35Z", "type": "commit"}]}