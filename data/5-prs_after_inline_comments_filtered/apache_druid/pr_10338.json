{"pr_number": 10338, "pr_title": "Vectorized ANY aggregators", "pr_createdAt": "2020-09-01T17:23:38Z", "pr_url": "https://github.com/apache/druid/pull/10338", "timeline": [{"oid": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f", "url": "https://github.com/apache/druid/commit/49e4f0ced8e81a243afeaca6d79048a7c36bf30f", "message": "WIP vectorized ANY aggregators", "committedDate": "2020-09-01T17:17:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxMDY4NA==", "url": "https://github.com/apache/druid/pull/10338#discussion_r481310684", "bodyText": "Should this check the columnType before offering a vectorized implementation? Similar question for other factories", "author": "suneet-s", "createdAt": "2020-09-01T17:24:21Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -112,6 +115,18 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     }\n   }\n \n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new DoubleAnyVectorAggregator(selectorFactory.makeValueSelector(fieldName));\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;", "originalCommit": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxMTM3Mw==", "url": "https://github.com/apache/druid/pull/10338#discussion_r481311373", "bodyText": "should any column type be allowed?", "author": "suneet-s", "createdAt": "2020-09-01T17:25:36Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregatorFactory.java", "diffHunk": "@@ -77,6 +82,37 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     return new StringAnyBufferAggregator(metricFactory.makeColumnValueSelector(fieldName), maxStringBytes);\n   }\n \n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+\n+    ColumnCapabilities capabilities = selectorFactory.getColumnCapabilities(fieldName);\n+    if (capabilities == null || capabilities.hasMultipleValues().isFalse()) {\n+      return new StringAnyVectorAggregator(\n+          selectorFactory.makeSingleValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          null,\n+          maxStringBytes\n+      );\n+    } else {\n+      return new StringAnyVectorAggregator(\n+          null,\n+          selectorFactory.makeMultiValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          maxStringBytes\n+      );\n+\n+    }\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    if (fieldName != null) {\n+      ColumnCapabilities capabilities = columnInspector.getColumnCapabilities(fieldName);\n+      return capabilities == null || capabilities.getType() == ValueType.STRING;", "originalCommit": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7f990915a2eef8f165e3437a5f979fe894ac6924", "url": "https://github.com/apache/druid/commit/7f990915a2eef8f165e3437a5f979fe894ac6924", "message": "Merge remote-tracking branch 'upstream/master' into vectorization", "committedDate": "2020-09-02T22:02:18Z", "type": "commit"}, {"oid": "a0c7aabf1d0e676ba74681865572d724be04693e", "url": "https://github.com/apache/druid/commit/a0c7aabf1d0e676ba74681865572d724be04693e", "message": "tests", "committedDate": "2020-09-03T03:35:00Z", "type": "commit"}, {"oid": "8ba5de97b5c4c8862ff9e36a6d801e5c482cd6be", "url": "https://github.com/apache/druid/commit/8ba5de97b5c4c8862ff9e36a6d801e5c482cd6be", "message": "fix aggs", "committedDate": "2020-09-04T00:18:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxOTU2Ng==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483319566", "bodyText": "This approach doesn't work, and one of the CalciteQueryTests caught it \ud83c\udf89", "author": "suneet-s", "createdAt": "2020-09-04T00:21:20Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  private static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   * @return true if a value was put on the buffer, false otherwise.\n+   */\n+  abstract boolean putValue(ByteBuffer buf, int position, int startRow, int endRow);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putValue(buf, position, null);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      if (putValue(buf, position, startRow, endRow)) {\n+        buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    int prevPosition = -1;\n+    @Nullable Object theValue = null;\n+    boolean found = false;\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      // If the aggregate is not found at the position\n+      if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+        // If there's a value at the previous position, use it in this position.\n+        if (prevPosition >= 0 && (found || (buf.get(prevPosition) & BYTE_FLAG_FOUND_MASK) == BYTE_FLAG_FOUND_MASK)) {", "originalCommit": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0a3bc03de282d0eca49a8bf0690a0e8222ac9356", "url": "https://github.com/apache/druid/commit/0a3bc03de282d0eca49a8bf0690a0e8222ac9356", "message": "cleanup", "committedDate": "2020-09-04T05:31:25Z", "type": "commit"}, {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8", "url": "https://github.com/apache/druid/commit/bf291df4c1122257c4a47f1e992b417800f101c8", "message": "Merge remote-tracking branch 'upstream/master' into vectorization", "committedDate": "2020-09-04T05:31:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1MzM2MQ==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483453361", "bodyText": "startRow <= nulls.length is this check required? if so, it should check startRow < nulls.length", "author": "abhishekagarwal87", "createdAt": "2020-09-04T07:58:34Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {", "originalCommit": "bf291df4c1122257c4a47f1e992b417800f101c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1MzkzNw==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483453937", "bodyText": "or endRow <= nulls.length", "author": "abhishekagarwal87", "createdAt": "2020-09-04T07:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1MzM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NDc2NA==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483674764", "bodyText": "Fixed.", "author": "suneet-s", "createdAt": "2020-09-04T15:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1MzM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1ODcxOQ==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483458719", "bodyText": "should it not be aggregate(buf, position, row, row + 1) ?", "author": "abhishekagarwal87", "createdAt": "2020-09-04T08:09:08Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      aggregate(buf, position, row, row);", "originalCommit": "bf291df4c1122257c4a47f1e992b417800f101c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NTExMw==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483675113", "bodyText": "yes \ud83d\ude2c", "author": "suneet-s", "createdAt": "2020-09-04T15:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1ODcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDQxNQ==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483460415", "bodyText": "are there unit tests for this method?", "author": "abhishekagarwal87", "createdAt": "2020-09-04T08:12:18Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(", "originalCommit": "bf291df4c1122257c4a47f1e992b417800f101c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NDk4Mw==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483674983", "bodyText": "added now. Was in progress when I pushed the last patch up.", "author": "suneet-s", "createdAt": "2020-09-04T15:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MjQ2Mw==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483462463", "bodyText": "I think it may be more efficient to not call aggregate. E.g. if a value is already found, we still iterate through the loop which could have been avoided. what do you think?", "author": "abhishekagarwal87", "createdAt": "2020-09-04T08:16:14Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      aggregate(buf, position, row, row);", "originalCommit": "bf291df4c1122257c4a47f1e992b417800f101c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NjUyOA==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483676528", "bodyText": "I tried that earlier and it failed a test with subqueries - #10338 (comment)", "author": "suneet-s", "createdAt": "2020-09-04T15:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MjQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDk1OQ==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483474959", "bodyText": "non null", "author": "abhishekagarwal87", "createdAt": "2020-09-04T08:39:33Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer", "originalCommit": "bf291df4c1122257c4a47f1e992b417800f101c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4MTUwMg==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483681502", "bodyText": "Removed this function. Realized that it was just putting 0, which is what initValue does", "author": "suneet-s", "createdAt": "2020-09-04T15:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NTQzMA==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483475430", "bodyText": "nit: how about putNonNullRow?", "author": "abhishekagarwal87", "createdAt": "2020-09-04T08:40:24Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);", "originalCommit": "bf291df4c1122257c4a47f1e992b417800f101c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNTQxNQ==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483705415", "bodyText": "Refactored to boolean putAnyValueFromRow(ByteBuffer buf, int position, int startRow, int endRow)", "author": "suneet-s", "createdAt": "2020-09-04T15:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NTQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NjcwNA==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483476704", "bodyText": "again nitpicking: but this can be made private. In inherited classes, instead of passing position, you can pass position + FOUND_VALUE_OFFSET so that those methods are free of any logic related to offset.", "author": "abhishekagarwal87", "createdAt": "2020-09-04T08:42:37Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;", "originalCommit": "bf291df4c1122257c4a47f1e992b417800f101c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NzIyMw==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483477223", "bodyText": "they would also be free of any null handling", "author": "abhishekagarwal87", "createdAt": "2020-09-04T08:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NjcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNTYxNA==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483705614", "bodyText": "good suggestion! Done.", "author": "suneet-s", "createdAt": "2020-09-04T15:45:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NjcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3ODcyMA==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483478720", "bodyText": "out of curiosity, when can capabilities be null?", "author": "abhishekagarwal87", "createdAt": "2020-09-04T08:46:10Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregatorFactory.java", "diffHunk": "@@ -77,6 +81,33 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     return new StringAnyBufferAggregator(metricFactory.makeColumnValueSelector(fieldName), maxStringBytes);\n   }\n \n+  @Override\n+  public StringAnyVectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+\n+    ColumnCapabilities capabilities = selectorFactory.getColumnCapabilities(fieldName);\n+    if (capabilities == null || capabilities.hasMultipleValues().isMaybeTrue()) {\n+      return new StringAnyVectorAggregator(\n+          null,\n+          selectorFactory.makeMultiValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          maxStringBytes\n+      );\n+    } else {\n+      return new StringAnyVectorAggregator(\n+          selectorFactory.makeSingleValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          null,\n+          maxStringBytes\n+      );\n+    }\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    ColumnCapabilities capabilities = columnInspector.getColumnCapabilities(fieldName);\n+    return capabilities == null || capabilities.getType() == ValueType.STRING;", "originalCommit": "bf291df4c1122257c4a47f1e992b417800f101c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNjYzMg==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483706632", "bodyText": "/**\n   * Returns capabilities of a particular column, if known. May be null if the column doesn't exist, or if\n   * the column does exist but the capabilities are unknown. The latter is possible with dynamically discovered\n   * columns.\n   *\n   * Note that StorageAdapters are representations of \"real\" segments, so they are not aware of any virtual columns\n   * that may be involved in a query. In general, query engines should instead use the method\n   * {@link ColumnSelectorFactory#getColumnCapabilities(String)}, which returns capabilities for virtual columns as\n   * well.\n   *\n   * @param column column name\n   *\n   * @return capabilities, or null\n   */\n  @Override\n  @Nullable\n  ColumnCapabilities getColumnCapabilities(String column);\n\nI found this explanation in StorageAdapter#getColumnCapabilities", "author": "suneet-s", "createdAt": "2020-09-04T15:47:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3ODcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxOTM1Nw==", "url": "https://github.com/apache/druid/pull/10338#discussion_r483719357", "bodyText": "Thanks \ud83d\udc4d", "author": "abhishekagarwal87", "createdAt": "2020-09-04T16:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3ODcyMA=="}], "type": "inlineReview"}, {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23", "url": "https://github.com/apache/druid/commit/d9e56f04ce7db06e0fa38b3e761072fb95289a23", "message": "code review + tests", "committedDate": "2020-09-04T17:38:00Z", "type": "commit"}, {"oid": "605568eb662275cbef15ba37d6832bfac7c691f4", "url": "https://github.com/apache/druid/commit/605568eb662275cbef15ba37d6832bfac7c691f4", "message": "docs", "committedDate": "2020-09-04T18:04:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI1MTQ0MA==", "url": "https://github.com/apache/druid/pull/10338#discussion_r484251440", "bodyText": "by the way, are these checks necessary? The framework calling aggregators should be taking care of passing valid ranges. If not, its a bug and exception will be raised. I didn't notice these checks in other vector aggregation implementations.", "author": "abhishekagarwal87", "createdAt": "2020-09-07T07:53:51Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/FloatAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Vectorized implementation of the {@link FloatAnyBufferAggregator}\n+ */\n+public class FloatAnyVectorAggregator extends NumericAnyVectorAggregator\n+{\n+  public FloatAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    super(vectorValueSelector);\n+  }\n+\n+  @Override\n+  void initValue(ByteBuffer buf, int position)\n+  {\n+    buf.putFloat(position, 0F);\n+  }\n+\n+  @Override\n+  boolean putAnyValueFromRow(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    float[] values = vectorValueSelector.getFloatVector();\n+    boolean isRowsWithinIndex = startRow < endRow && startRow < values.length;", "originalCommit": "d9e56f04ce7db06e0fa38b3e761072fb95289a23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyMDI0NQ==", "url": "https://github.com/apache/druid/pull/10338#discussion_r485020245", "bodyText": "I wasn't sure if it's needed or not. The other aggregators have these checks implicitly within the for loops I think", "author": "suneet-s", "createdAt": "2020-09-08T15:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI1MTQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNTEyMQ==", "url": "https://github.com/apache/druid/pull/10338#discussion_r484315121", "bodyText": "this got me thinking about how did this test pass. There was no flag set in the buffer and the target still returned the value. I realized that in NumericAnyVectorAggregator, non-null is the default than null\nboolean isValueNull(ByteBuffer buf, int position)\n  {\n    return (buf.get(position) & BYTE_FLAG_NULL_MASK) == NullHandling.IS_NULL_BYTE;\n  }\n\nIt should be fine since init is always called. maybe the tests should do the same as well.", "author": "abhishekagarwal87", "createdAt": "2020-09-07T09:37:22Z", "path": "processing/src/test/java/org/apache/druid/query/aggregation/any/DoubleAnyVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import static org.mockito.Mockito.spy;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DoubleAnyVectorAggregatorTest extends InitializedNullHandlingTest\n+{\n+  private static final int NULL_POSITION = 32;\n+  private static final int POSITION = 2;\n+  private static final double EPSILON = 1e-15;\n+  private static final double[] VALUES = new double[]{7.8d, 11, 23.67, 60, 123};\n+\n+  private ByteBuffer buf;\n+  @Mock\n+  private VectorValueSelector selector;\n+\n+  private DoubleAnyVectorAggregator target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    byte[] randomBytes = new byte[128];\n+    ThreadLocalRandom.current().nextBytes(randomBytes);\n+    buf = ByteBuffer.wrap(randomBytes);\n+    Mockito.doReturn(VALUES).when(selector).getDoubleVector();\n+\n+    target = spy(new DoubleAnyVectorAggregator(selector));\n+    Mockito.when(target.isValueNull(buf, NULL_POSITION)).thenReturn(true);\n+    Mockito.when(target.isValueNull(buf, POSITION)).thenReturn(false);\n+  }\n+\n+  @Test\n+  public void initValueShouldInitZero()\n+  {\n+    target.initValue(buf, POSITION);\n+    Assert.assertEquals(0, buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void getAtPositionIsNullShouldReturnNull()\n+  {\n+    Assert.assertNull(target.get(buf, NULL_POSITION));\n+  }\n+\n+  @Test\n+  public void getAtPositionShouldReturnValue()\n+  {\n+    buf.putDouble(POSITION + 1, VALUES[3]);", "originalCommit": "d9e56f04ce7db06e0fa38b3e761072fb95289a23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxODI1Ng==", "url": "https://github.com/apache/druid/pull/10338#discussion_r484318256", "bodyText": "Mockito.when(target.isValueNull(buf, POSITION)).thenReturn(false); should be taking care of it.", "author": "abhishekagarwal87", "createdAt": "2020-09-07T09:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNTEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNjA4OA==", "url": "https://github.com/apache/druid/pull/10338#discussion_r484316088", "bodyText": "we should be passing the delta in assertNotEquals methods too.", "author": "abhishekagarwal87", "createdAt": "2020-09-07T09:38:58Z", "path": "processing/src/test/java/org/apache/druid/query/aggregation/any/DoubleAnyVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import static org.mockito.Mockito.spy;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DoubleAnyVectorAggregatorTest extends InitializedNullHandlingTest\n+{\n+  private static final int NULL_POSITION = 32;\n+  private static final int POSITION = 2;\n+  private static final double EPSILON = 1e-15;\n+  private static final double[] VALUES = new double[]{7.8d, 11, 23.67, 60, 123};\n+\n+  private ByteBuffer buf;\n+  @Mock\n+  private VectorValueSelector selector;\n+\n+  private DoubleAnyVectorAggregator target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    byte[] randomBytes = new byte[128];\n+    ThreadLocalRandom.current().nextBytes(randomBytes);\n+    buf = ByteBuffer.wrap(randomBytes);\n+    Mockito.doReturn(VALUES).when(selector).getDoubleVector();\n+\n+    target = spy(new DoubleAnyVectorAggregator(selector));\n+    Mockito.when(target.isValueNull(buf, NULL_POSITION)).thenReturn(true);\n+    Mockito.when(target.isValueNull(buf, POSITION)).thenReturn(false);\n+  }\n+\n+  @Test\n+  public void initValueShouldInitZero()\n+  {\n+    target.initValue(buf, POSITION);\n+    Assert.assertEquals(0, buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void getAtPositionIsNullShouldReturnNull()\n+  {\n+    Assert.assertNull(target.get(buf, NULL_POSITION));\n+  }\n+\n+  @Test\n+  public void getAtPositionShouldReturnValue()\n+  {\n+    buf.putDouble(POSITION + 1, VALUES[3]);\n+    Assert.assertEquals(VALUES[3], (double) target.get(buf, POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void putValueShouldAddToBuffer()\n+  {\n+    Assert.assertTrue(target.putAnyValueFromRow(buf, POSITION, 2, 3));\n+    Assert.assertEquals(VALUES[2], buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void putValueStartAfterEndShouldNotAddToBuffer()\n+  {\n+    Assert.assertFalse(target.putAnyValueFromRow(buf, POSITION, 2, 2));\n+    Assert.assertNotEquals(VALUES[2], buf.getDouble(POSITION));", "originalCommit": "d9e56f04ce7db06e0fa38b3e761072fb95289a23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyMzc2MA==", "url": "https://github.com/apache/druid/pull/10338#discussion_r485023760", "bodyText": "will add in the next patch. waiting to see if any other changes are needed", "author": "suneet-s", "createdAt": "2020-09-08T15:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNjA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0MDU0Mg==", "url": "https://github.com/apache/druid/pull/10338#discussion_r485040542", "bodyText": "Looks good to me otherwise.", "author": "abhishekagarwal87", "createdAt": "2020-09-08T16:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNjA4OA=="}], "type": "inlineReview"}, {"oid": "d5b70786c184e356d2a08d02fc3b1fbb6bd8c98a", "url": "https://github.com/apache/druid/commit/d5b70786c184e356d2a08d02fc3b1fbb6bd8c98a", "message": "Merge remote-tracking branch 'upstream/master' into vectorization", "committedDate": "2020-09-09T17:51:07Z", "type": "commit"}, {"oid": "6d08da9c52d05472a916365cae38c2d496e816d1", "url": "https://github.com/apache/druid/commit/6d08da9c52d05472a916365cae38c2d496e816d1", "message": "Merge remote-tracking branch 'upstream/master' into vectorization", "committedDate": "2020-09-12T00:50:26Z", "type": "commit"}, {"oid": "0855b4a1c877b5280528c6e3ffcff28901110418", "url": "https://github.com/apache/druid/commit/0855b4a1c877b5280528c6e3ffcff28901110418", "message": "use NilVectorSelector when needed", "committedDate": "2020-09-12T02:13:49Z", "type": "commit"}, {"oid": "18b09faff4151969a86045770e5c1ee455f05e95", "url": "https://github.com/apache/druid/commit/18b09faff4151969a86045770e5c1ee455f05e95", "message": "fix spellcheck", "committedDate": "2020-09-13T03:17:11Z", "type": "commit"}, {"oid": "8832808a07015619ef5369adc82a20062643105b", "url": "https://github.com/apache/druid/commit/8832808a07015619ef5369adc82a20062643105b", "message": "dont instantiate vectors", "committedDate": "2020-09-13T03:47:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2MjAzMA==", "url": "https://github.com/apache/druid/pull/10338#discussion_r488262030", "bodyText": "nit: can extend NoopVectorAggregator to reduce boilerplate. I also don't think you need separate classes for each type, since the number is an object anyway, can just instantiate each singleton using NullHandling.defaultLongValue() etc.", "author": "clintropolis", "createdAt": "2020-09-14T22:22:07Z", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericNilVectorAggregator.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * A vector aggregator that returns the default numeric value.\n+ */\n+public abstract class NumericNilVectorAggregator implements VectorAggregator", "originalCommit": "8832808a07015619ef5369adc82a20062643105b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4MDY5OQ==", "url": "https://github.com/apache/druid/pull/10338#discussion_r488280699", "bodyText": "I decided not to extend NoopVectorAggregator since it's constructor was private, and I didn't want to think through what the right inheritance model should be. I did take your suggestion on just instantiating 1 singleton for each numeric type to reduce the boiler plate code. New patch incoming...", "author": "suneet-s", "createdAt": "2020-09-14T22:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2MjAzMA=="}], "type": "inlineReview"}, {"oid": "a781ec7c82de61f5f66f7c24b505ce189d61dc13", "url": "https://github.com/apache/druid/commit/a781ec7c82de61f5f66f7c24b505ce189d61dc13", "message": "Merge remote-tracking branch 'upstream/master' into vectorization", "committedDate": "2020-09-14T22:31:56Z", "type": "commit"}, {"oid": "a0458395212d148303eaadf9f7d0ede3ec3314d3", "url": "https://github.com/apache/druid/commit/a0458395212d148303eaadf9f7d0ede3ec3314d3", "message": "cleanup", "committedDate": "2020-09-14T22:55:08Z", "type": "commit"}]}