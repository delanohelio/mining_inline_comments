{"pr_number": 8206, "pr_title": "IGNITE-13204 Add Java thin client Kubernetes auto discovery", "pr_createdAt": "2020-09-01T16:08:03Z", "pr_url": "https://github.com/apache/ignite/pull/8206", "timeline": [{"oid": "da60f72c9b250bd1e2a15391c0a967d17bdfeac5", "url": "https://github.com/apache/ignite/commit/da60f72c9b250bd1e2a15391c0a967d17bdfeac5", "message": "IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-01T16:00:54Z", "type": "commit"}, {"oid": "4f6d1b1293b76af3bdfc7a38254e1a3a0c4cb98d", "url": "https://github.com/apache/ignite/commit/4f6d1b1293b76af3bdfc7a38254e1a3a0c4cb98d", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-01T16:22:56Z", "type": "commit"}, {"oid": "003b164bb40369ca95eb76cc149719df5d263663", "url": "https://github.com/apache/ignite/commit/003b164bb40369ca95eb76cc149719df5d263663", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-02T13:34:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMDM3OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482730378", "bodyText": "Is -> Whether", "author": "ptupitsyn", "createdAt": "2020-09-03T06:22:36Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -62,16 +65,16 @@\n     private final Function<ClientChannelConfiguration, ClientChannel> chFactory;\n \n     /** Client channel holders for each configured address. */\n-    private final ClientChannelHolder[] channels;\n+    private final AtomicReference<List<ClientChannelHolder>> channels = new AtomicReference<>();\n \n     /** Index of the current channel. */\n-    private int curChIdx;\n+    private volatile int curChIdx = -1;\n \n-    /** Partition awareness enabled. */\n-    private final boolean partitionAwarenessEnabled;\n+    /** Is all channels should be initialized at one moment. */", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODI3Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148276", "bodyText": "Outdated.", "author": "timoninmaxim", "createdAt": "2020-09-03T17:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMDM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMDQ1MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482730451", "bodyText": "private", "author": "ptupitsyn", "createdAt": "2020-09-03T06:22:46Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientChannelHolder.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import org.apache.ignite.client.ClientAuthenticationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+\n+/**\n+ * Channels holder.\n+ */\n+class ClientChannelHolder {\n+    /** Channel configuration. */\n+    final ClientChannelConfiguration chCfg;", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODE3MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148170", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-03T17:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMDQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMDkxMA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482730910", "bodyText": "Please move this explanation to public setter/getter", "author": "ptupitsyn", "createdAt": "2020-09-03T06:23:52Z", "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +116,33 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /**\n+     * Try use other limited number of channels to send a request if default channel is not responding.", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODA1Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148056", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-03T17:39:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMDkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMTMzNw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482731337", "bodyText": "shouldApplyReconnectionThrottling", "author": "ptupitsyn", "createdAt": "2020-09-03T06:24:56Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientChannelHolder.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import org.apache.ignite.client.ClientAuthenticationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+\n+/**\n+ * Channels holder.\n+ */\n+class ClientChannelHolder {\n+    /** Channel configuration. */\n+    final ClientChannelConfiguration chCfg;\n+\n+    /** Channel. */\n+    private volatile ClientChannel ch;\n+\n+    /** Address that holder is bind to (chCfg.addr) is not in use now. So close the holder */\n+    private volatile boolean close;\n+\n+    /** Timestamps of reconnect retries. */\n+    private final long[] reconnectRetries;\n+\n+    /** Channel factory. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory;\n+\n+    /** Callback invokes when new channel create */\n+    private final BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate;\n+\n+    /** Callback invokes when channel close */\n+    private final Consumer<ClientChannel> onChannelClose;\n+\n+    /**\n+     * @param chCfg Channel config.\n+     */\n+    ClientChannelHolder(ClientChannelConfiguration chCfg,\n+                        Function<ClientChannelConfiguration, ClientChannel> chFactory,\n+                        BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate,\n+                        Consumer<ClientChannel> onChannelClose) {\n+        this.chCfg = chCfg;\n+        this.chFactory = chFactory;\n+        this.onChannelCreate = onChannelCreate;\n+        this.onChannelClose = onChannelClose;\n+\n+        reconnectRetries = chCfg.getReconnectThrottlingRetries() > 0 && chCfg.getReconnectThrottlingPeriod() > 0L ?\n+            new long[chCfg.getReconnectThrottlingRetries()] : null;\n+    }\n+\n+    /**\n+     * @return Whether reconnect throttling should be applied.\n+     */\n+    boolean applyReconnectionThrottling() {", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzNjAyNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482836024", "bodyText": "private here and for other methods where apply.", "author": "isapego", "createdAt": "2020-09-03T09:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMTMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODIxNw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148217", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-03T17:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczMTMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNjc5MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482736791", "bodyText": "I think we should remove this interface. There is hardly any value in sharing an interface across thin and thick configurations, but it can cause difficulties when APIs evolve in the future.", "author": "ptupitsyn", "createdAt": "2020-09-03T06:38:10Z", "path": "modules/kubernetes/src/main/java/org/apache/ignite/kubernetes/KubernetesConnectorConfigurator.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.kubernetes;\n+\n+/**\n+ * Interface provide methods to configure Kubernetes connection.\n+ */\n+public interface KubernetesConnectorConfigurator {", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc3ODU4NQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482778585", "bodyText": "@ptupitsyn Connection to k8s API is independent on Ignite node type. IpFinder and AddressFinder both have the same setters to configure the connection (namespace, service, etc). IMHO the right implementation would be to create a class like KubernetesConnectionConfiguration and use it as field in the finders. But it will break existing API for IpFinder. So I introduced the interface to track common configuration params.", "author": "timoninmaxim", "createdAt": "2020-09-03T07:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNjc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc5MjU4OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482792589", "bodyText": "This interface extends our public API. Every new public API is a future liability and should be considered carefully. In this case there is no value for the users, so let's remove it.", "author": "ptupitsyn", "createdAt": "2020-09-03T08:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNjc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzMjc0NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482832744", "bodyText": "I can move this interface to package with finders and make it package-private, isn't it enough? Public API for IpFinder isn't changed, it still have the same setters. I'm agree that this interface doesn't look good but it's a limitation of exisiting IpFinder. Alternatives are:\n\nRemove this interface and track k8s configuration params only with constructor of KubernetesServiceAddressResolver;\nProvide a new object like KubernetesConnectionKonfiguration instead of interface, provide new IpFinder constructor that accept the configuration, deprecate setters in the IpFinder in favor of the constructor.\n\nI like the second option. But it lead change of the IpFinder API (add new, deprecate old), is it ok?", "author": "timoninmaxim", "createdAt": "2020-09-03T09:18:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNjc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA1MDAxOA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r484050018", "bodyText": "I've implemented the second option. I think, it got prettier.", "author": "timoninmaxim", "createdAt": "2020-09-06T10:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNjc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MTkwNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482741904", "bodyText": "Can you please explain the purpose of this class?", "author": "ptupitsyn", "createdAt": "2020-09-03T06:48:18Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannelFacade.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import org.apache.ignite.IgniteBinary;\n+import org.apache.ignite.client.ClientAuthenticationException;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+\n+/**\n+ * Communication channel with failover and partition awareness.\n+ */\n+final class ReliableChannelFacade implements AutoCloseable {", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1NTk2MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482855961", "bodyText": "I think that ReliableChannel was overloaded, it was responsible for 2 things the same time: communication and affinity awareness. Due to that there were some non-intuitive conditions for me while I debug the code. So I split the original class on 2 parts:\n\nReliableChannel now is responsible for sending any request to Ignite nodes. If some channel is failure it tries to use another one, roll channels, etc. It just provides infrastructure for communication between client and servers.\nReliableChannelFacade provides logic with affinity awareness: send affinity or user requests, choose affinity node for a request.", "author": "timoninmaxim", "createdAt": "2020-09-03T09:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MTkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1ODE1NQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482858155", "bodyText": "I'd like to ask you to limit the scope of changes in this PR, it is hard to grasp as it is. Can we revert all unrelated refactoring and do it separately later?", "author": "ptupitsyn", "createdAt": "2020-09-03T09:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MTkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4NDA2MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482984061", "bodyText": "sure, I will remove this change from the PR", "author": "timoninmaxim", "createdAt": "2020-09-03T13:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MTkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODQ5Mw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148493", "bodyText": "Updated.", "author": "timoninmaxim", "createdAt": "2020-09-03T17:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MTkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0Mjc5NQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482742795", "bodyText": "I don't think this should be in the public package, users won't use this class directly.", "author": "ptupitsyn", "createdAt": "2020-09-03T06:50:14Z", "path": "modules/kubernetes/src/main/java/org/apache/ignite/kubernetes/KubernetesServiceAddressResolver.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.kubernetes;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.SecureRandom;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.internal.IgniteInterruptedCheckedException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+\n+/**\n+ * The class is responsible to fetch list of IP address for all pods that runs the specified kubernetes service.\n+ */\n+public class KubernetesServiceAddressResolver {", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODY1NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148654", "bodyText": "This class used both by IpFinder and AddressFinder that are in different packages.", "author": "timoninmaxim", "createdAt": "2020-09-03T17:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0Mjc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2OTk5NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483469994", "bodyText": "The fact that it is being used by other classes does not require us to put it in a \"public\" package. Can we move this to org.apache.ignite.internal.kubernetes package?", "author": "ptupitsyn", "createdAt": "2020-09-04T08:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0Mjc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA1MDAzNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r484050034", "bodyText": "Moved.", "author": "timoninmaxim", "createdAt": "2020-09-06T10:08:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0Mjc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NjI1Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482746252", "bodyText": "have to be deployed", "author": "ptupitsyn", "createdAt": "2020-09-03T06:57:14Z", "path": "modules/kubernetes/src/main/java/org/apache/ignite/spi/discovery/tcp/ipfinder/kubernetes/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.kubernetes.KubernetesConnectorConfigurator;\n+import org.apache.ignite.kubernetes.KubernetesConnectorDefaults;\n+import org.apache.ignite.kubernetes.KubernetesServiceAddressResolver;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite nodes running in Kubernetes environment. All Ignite nodes have to", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODc4Mw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148783", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-03T17:41:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NjI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NzM3OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482747378", "bodyText": "I know this was copied from existing TcpDiscoveryKubernetesIpFinder, but the text is confusing:\n\nprior Ignite nodes startup - not true, k8s service can be created before or after the pods - does not matter\nservice will maintain a list of all endpoints - misleading, service is an abstraction over a set of pods, it does not maintain endpoints, and this is k8s implementation details https://kubernetes.io/docs/concepts/services-networking/service/", "author": "ptupitsyn", "createdAt": "2020-09-03T06:59:38Z", "path": "modules/kubernetes/src/main/java/org/apache/ignite/spi/discovery/tcp/ipfinder/kubernetes/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.kubernetes.KubernetesConnectorConfigurator;\n+import org.apache.ignite.kubernetes.KubernetesConnectorDefaults;\n+import org.apache.ignite.kubernetes.KubernetesServiceAddressResolver;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite nodes running in Kubernetes environment. All Ignite nodes have to\n+ * deployed as Kubernetes pods in order to be found. Applications and Ignite nodes running outside of Kubernetes\n+ * will not be able to reach the containerized counterparts.\n+ * <p>\n+ * The implementation is based on a distinct Kubernetes service that has to be created and should be deployed prior\n+ * Ignite nodes startup. The service will maintain a list of all endpoints (internal IP addresses) of all containerized", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODc5Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148796", "bodyText": "Agree with first comment, fixed;\nDisagree, as Service do maintain Endpoints, from the link you provide:\n\n\nThe controller for the Service selector continuously scans for Pods that match its selector, and then POSTs any updates to an Endpoint object", "author": "timoninmaxim", "createdAt": "2020-09-03T17:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NzM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NzgwMg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482747802", "bodyText": "This paragraph is also confusing. We don't care how users define their services and use their selectors, why mention that?", "author": "ptupitsyn", "createdAt": "2020-09-03T07:00:38Z", "path": "modules/kubernetes/src/main/java/org/apache/ignite/spi/discovery/tcp/ipfinder/kubernetes/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.kubernetes.KubernetesConnectorConfigurator;\n+import org.apache.ignite.kubernetes.KubernetesConnectorDefaults;\n+import org.apache.ignite.kubernetes.KubernetesServiceAddressResolver;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite nodes running in Kubernetes environment. All Ignite nodes have to\n+ * deployed as Kubernetes pods in order to be found. Applications and Ignite nodes running outside of Kubernetes\n+ * will not be able to reach the containerized counterparts.\n+ * <p>\n+ * The implementation is based on a distinct Kubernetes service that has to be created and should be deployed prior\n+ * Ignite nodes startup. The service will maintain a list of all endpoints (internal IP addresses) of all containerized\n+ * Ignite pods running so far. The name of the service must be equal to {@link #setServiceName(String)} which is\n+ * `ignite` by default.\n+ * <p>\n+ * As for Ignite pods, it's recommended to label them in such a way that the service will use the label in its selector", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4MzA4OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482983089", "bodyText": "Actually, we should care. K8S services are bounded with k8s deployments by selector. IpFinder / AddressFinder return addresses to all pods that are matches service. So, for IpFinder service should contain all server and thick clients nodes. For AddressFinder service should contain only server nodes. Otherwise there could be issues with failed connections to other pods.", "author": "timoninmaxim", "createdAt": "2020-09-03T13:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NzgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NTkwNQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483465905", "bodyText": "What you describe is correct, but also obvious - you have to use labels to define a service with a subset of pods in k8s. This is common knowledge and this is the first thing k8s docs tell you. So:\n\nThis part is redundant\nThis part is worded in such a way that (in my opinion) can bring unnecessary confusion.\n\nAnyway, this is a minor thing - keep it if you insist.", "author": "ptupitsyn", "createdAt": "2020-09-04T08:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NzgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA1MDIzMQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r484050231", "bodyText": "I think you're correct. I reword it, just add mention about nodes types that are target by service. I think this mention is important as invalid configuration would lead to performance issues.", "author": "timoninmaxim", "createdAt": "2020-09-06T10:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NzgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1MjAxMg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482752012", "bodyText": "I think this belongs to org.apache.ignite.client package", "author": "ptupitsyn", "createdAt": "2020-09-03T07:04:17Z", "path": "modules/kubernetes/src/main/java/org/apache/ignite/spi/discovery/tcp/ipfinder/kubernetes/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes;", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODc0OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148749", "bodyText": "moved.", "author": "timoninmaxim", "createdAt": "2020-09-03T17:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1MjAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1MjcyMQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482752721", "bodyText": "ReliableChannel is an implementation detail in the internal package, let's not mention it in the javadoc of the public class.", "author": "ptupitsyn", "createdAt": "2020-09-03T07:05:01Z", "path": "modules/kubernetes/src/main/java/org/apache/ignite/spi/discovery/tcp/ipfinder/kubernetes/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.kubernetes.KubernetesConnectorConfigurator;\n+import org.apache.ignite.kubernetes.KubernetesConnectorDefaults;\n+import org.apache.ignite.kubernetes.KubernetesServiceAddressResolver;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite nodes running in Kubernetes environment. All Ignite nodes have to\n+ * deployed as Kubernetes pods in order to be found. Applications and Ignite nodes running outside of Kubernetes\n+ * will not be able to reach the containerized counterparts.\n+ * <p>\n+ * The implementation is based on a distinct Kubernetes service that has to be created and should be deployed prior\n+ * Ignite nodes startup. The service will maintain a list of all endpoints (internal IP addresses) of all containerized\n+ * Ignite pods running so far. The name of the service must be equal to {@link #setServiceName(String)} which is\n+ * `ignite` by default.\n+ * <p>\n+ * As for Ignite pods, it's recommended to label them in such a way that the service will use the label in its selector\n+ * configuration excluding endpoints of irrelevant Kubernetes pods running in parallel.\n+ * <p>\n+ * The address finder, in its turn, will call this service to retrieve Ignite pods IP addresses. The port will be\n+ * set with {@link ReliableChannel#parseAddresses(String[])}. Make sure that all Ignite pods occupy a similar", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODg4MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148880", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-03T17:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1MjcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1NTY2Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482755662", "bodyText": "Copypasted javadoc", "author": "ptupitsyn", "createdAt": "2020-09-03T07:11:01Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -98,265 +101,291 @@\n     /** Channels reinit was scheduled. */\n     private final AtomicBoolean scheduledChannelsReinit = new AtomicBoolean();\n \n-    /** Affinity map update is in progress. */\n-    private final AtomicBoolean affinityUpdateInProgress = new AtomicBoolean();\n-\n     /** Channel is closed. */\n     private volatile boolean closed;\n \n     /** Fail (disconnect) listeners. */\n-    private ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n+    private final ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n \n-    /**\n-     * Constructor.\n-     */\n-    ReliableChannel(\n-        Function<ClientChannelConfiguration, ClientChannel> chFactory,\n-        ClientConfiguration clientCfg,\n-        IgniteBinary binary\n-    ) throws ClientException {\n+    /** Fail (disconnect) listeners. */", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODMyMw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148323", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-03T17:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1NTY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1Nzg5OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482757899", "bodyText": "resolvedAddrs is a List, this can be inefficient with large number of channels and addresses", "author": "ptupitsyn", "createdAt": "2020-09-03T07:15:34Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -98,265 +101,291 @@\n     /** Channels reinit was scheduled. */\n     private final AtomicBoolean scheduledChannelsReinit = new AtomicBoolean();\n \n-    /** Affinity map update is in progress. */\n-    private final AtomicBoolean affinityUpdateInProgress = new AtomicBoolean();\n-\n     /** Channel is closed. */\n     private volatile boolean closed;\n \n     /** Fail (disconnect) listeners. */\n-    private ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n+    private final ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n \n-    /**\n-     * Constructor.\n-     */\n-    ReliableChannel(\n-        Function<ClientChannelConfiguration, ClientChannel> chFactory,\n-        ClientConfiguration clientCfg,\n-        IgniteBinary binary\n-    ) throws ClientException {\n+    /** Fail (disconnect) listeners. */\n+    private final ArrayList<Predicate<ClientChannel>> topChangeFilters = new ArrayList<>();\n+\n+    /** Guard channels and curChIdx together. */\n+    private final ReadWriteLock curChannelsGuard = new ReentrantReadWriteLock();\n+\n+    /** Constructor. */\n+    ReliableChannel(ClientConfiguration clientCfg,\n+                    Function<ClientChannelConfiguration, ClientChannel> chFactory,\n+                    boolean initAllChannels) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n+        this.initAllChannels = initAllChannels;\n+    }\n+\n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n+    /** Callback is invoked after new ClientChannel has created. */\n+    private final BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate = (holder, ch) -> {\n+        ch.addTopologyChangeListener(channel -> {\n+            if (topChangeFilters.stream().allMatch(s -> s.test(channel)))\n+                channelsInit(true);\n+        });\n \n-        channels = new ClientChannelHolder[addrs.size()];\n+        ch.addNotificationListener(this);\n \n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n+        nodeChannels.values().remove(holder);\n+        nodeChannels.put(ch.serverNodeId(), holder);\n+    };\n \n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n+    /** Callback is invoked after a ClientChannel has closed. */\n+    private final Consumer<ClientChannel> onChannelClose = ch -> {\n+        for (Consumer<ClientChannel> lsnr : channelCloseLsnrs)\n+            lsnr.accept(ch);\n+    };\n \n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        List<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4OTYyMg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486089622", "bodyText": "replaced  with Set", "author": "timoninmaxim", "createdAt": "2020-09-10T06:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1Nzg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzMzc5Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487033792", "bodyText": "I'm not sure that replacing List to Set it's a good idea here (perhaps you should just copy list to set here locally). Using List you can solve some user problems which can't be solved with Set. For example, using list you can make some server nodes to be used more often than another. Also, by having a single duplicated address you can workaround some known issues.", "author": "alex-plekhanov", "createdAt": "2020-09-11T13:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1Nzg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4NTY0Nw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497485647", "bodyText": "Fixed, add tests for that.", "author": "timoninmaxim", "createdAt": "2020-09-30T12:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1Nzg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2MDA0OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482760049", "bodyText": "Do we need a lock around AtomicReference usage?", "author": "ptupitsyn", "createdAt": "2020-09-03T07:19:37Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -98,265 +101,291 @@\n     /** Channels reinit was scheduled. */\n     private final AtomicBoolean scheduledChannelsReinit = new AtomicBoolean();\n \n-    /** Affinity map update is in progress. */\n-    private final AtomicBoolean affinityUpdateInProgress = new AtomicBoolean();\n-\n     /** Channel is closed. */\n     private volatile boolean closed;\n \n     /** Fail (disconnect) listeners. */\n-    private ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n+    private final ArrayList<Runnable> chFailLsnrs = new ArrayList<>();\n \n-    /**\n-     * Constructor.\n-     */\n-    ReliableChannel(\n-        Function<ClientChannelConfiguration, ClientChannel> chFactory,\n-        ClientConfiguration clientCfg,\n-        IgniteBinary binary\n-    ) throws ClientException {\n+    /** Fail (disconnect) listeners. */\n+    private final ArrayList<Predicate<ClientChannel>> topChangeFilters = new ArrayList<>();\n+\n+    /** Guard channels and curChIdx together. */\n+    private final ReadWriteLock curChannelsGuard = new ReentrantReadWriteLock();\n+\n+    /** Constructor. */\n+    ReliableChannel(ClientConfiguration clientCfg,\n+                    Function<ClientChannelConfiguration, ClientChannel> chFactory,\n+                    boolean initAllChannels) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n+        this.initAllChannels = initAllChannels;\n+    }\n+\n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n+    /** Callback is invoked after new ClientChannel has created. */\n+    private final BiConsumer<ClientChannelHolder, ClientChannel> onChannelCreate = (holder, ch) -> {\n+        ch.addTopologyChangeListener(channel -> {\n+            if (topChangeFilters.stream().allMatch(s -> s.test(channel)))\n+                channelsInit(true);\n+        });\n \n-        channels = new ClientChannelHolder[addrs.size()];\n+        ch.addNotificationListener(this);\n \n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n+        nodeChannels.values().remove(holder);\n+        nodeChannels.put(ch.serverNodeId(), holder);\n+    };\n \n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n+    /** Callback is invoked after a ClientChannel has closed. */\n+    private final Consumer<ClientChannel> onChannelClose = ch -> {\n+        for (Consumer<ClientChannel> lsnr : channelCloseLsnrs)\n+            lsnr.accept(ch);\n+    };\n \n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        List<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))\n+            .forEach(addr -> addrs.get(addr).setValue(true));\n+\n+        // create new holders for new addrs\n+        resolvedAddrs.stream()\n+            .filter(addr -> !addrs.containsKey(addr))\n+            .forEach(addr -> {\n+                ClientChannelHolder hld = new ClientChannelHolder(\n+                    new ClientChannelConfiguration(clientCfg, addr), chFactory, onChannelCreate, onChannelClose);\n+\n+                addrs.put(addr, new T2<>(hld, false));\n+            });\n+\n+        if (!stopInitCondition()) {\n+            List<ClientChannelHolder> list = new ArrayList<>();\n+            // The variable holds a new index of default channel after topology change.\n+            // Suppose that reuse of the channel is better than open new connection.\n+            int dfltChannelIdx = -1;\n+\n+            ClientChannelHolder currHolder = null;\n+            if (curChIdx != -1)\n+                currHolder = channels.get().get(curChIdx);\n+\n+            for (T2<ClientChannelHolder, Boolean> t : addrs.values()) {\n+                ClientChannelHolder hld = t.get1();\n+                Boolean markForDelete = t.get2();\n+\n+                if (markForDelete == null) {\n+                    // this channel is still in use\n+                    list.add(hld);\n+                    if (hld == currHolder)\n+                        dfltChannelIdx = list.size() - 1;\n \n-        affinityCtx = new ClientCacheAffinityContext(binary);\n+                }\n+                else if (markForDelete) {\n+                    // this holder should be deleted now\n+                    nodeChannels.values().remove(hld);\n+                    hld.close();\n+                }\n+                else {\n+                    // this channel is new\n+                    list.add(hld);\n+                }\n+            }\n \n-        ClientConnectionException lastEx = null;\n+            if (dfltChannelIdx == -1)\n+                dfltChannelIdx = new Random().nextInt(list.size());\n \n-        for (int i = 0; i < channels.length; i++) {\n+            curChannelsGuard.writeLock().lock();", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgxNDY2OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482814669", "bodyText": "This lock is around two variables that must be in sync: channels (AtomicReference) and curChIdx.", "author": "timoninmaxim", "createdAt": "2020-09-03T08:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2MDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgyODk2MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482828960", "bodyText": "Then maybe AtomicReference is not required? Furthermore, this method is synchronized - overall rather hard to understand.", "author": "ptupitsyn", "createdAt": "2020-09-03T09:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2MDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg0NzM3MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482847371", "bodyText": "There are different goals for those sync operations:\n\nSynchronized method guarantees that only one thread is initializing holders. This is required to limit requests to the AddressFinder, and avoid do the same work for prepare addresses multiple times;\nAtomicReference is required as list of addresses are changed due to the preparation - merging new addresses, removing obsolete addresses. This performed in the \"thin-client-channel#\" thread.\nThe same time channels and CurChIdx are used in non-synchronized methods in user threads. There should be a guarantee for consistency between those variables. So this a reason to use the guard.", "author": "timoninmaxim", "createdAt": "2020-09-03T09:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2MDA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0OTkxOA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487049918", "bodyText": "Agree with Pavel, we don't need AtomicReference, it's too verbose and we don't use any atomic features (no CAS operations, only get and set). Can be replaced with volatile variable (List or array).", "author": "alex-plekhanov", "createdAt": "2020-09-11T13:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2MDA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2OTc5Mw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482769793", "bodyText": "Do we really need this property? What is the use case when this is not 0?\nI think retryLimit is a better name", "author": "ptupitsyn", "createdAt": "2020-09-03T07:37:01Z", "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +116,33 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /**\n+     * Try use other limited number of channels to send a request if default channel is not responding.\n+     * 0 means try use all configured channels before fail.\n+     */\n+    private int channelsAttemptsLimit = 0;", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc5NTI3NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482795274", "bodyText": "+1 for retryLimit", "author": "isapego", "createdAt": "2020-09-03T08:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgxODkyOA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482818928", "bodyText": "I introduced this variable because number of configured nodes dynamically changes. Earlier user could just configure addresses with limited number of nodes. With k8s configuration number of nodes changes. And in case of large number of non-responding nodes (cluster is down, for example) without this limit client will wait for a long time for an exception.", "author": "timoninmaxim", "createdAt": "2020-09-03T08:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2OTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE1MTEzMw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483151133", "bodyText": "Rename to retryLimit", "author": "timoninmaxim", "createdAt": "2020-09-03T17:45:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2OTc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzODQ3OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r482838479", "bodyText": "Please, add a description of what is this class for and how should it be used.", "author": "isapego", "createdAt": "2020-09-03T09:26:59Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientChannelHolder.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import org.apache.ignite.client.ClientAuthenticationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+\n+/**\n+ * Channels holder.", "originalCommit": "003b164bb40369ca95eb76cc149719df5d263663", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0ODEyMQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r483148121", "bodyText": "Outdated.", "author": "timoninmaxim", "createdAt": "2020-09-03T17:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzODQ3OQ=="}], "type": "inlineReview"}, {"oid": "96655a1f35edbd8d86913f2b8322f40a26505638", "url": "https://github.com/apache/ignite/commit/96655a1f35edbd8d86913f2b8322f40a26505638", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-03T17:12:23Z", "type": "commit"}, {"oid": "f29d2806197b7cce268b7fc8867d932605b8095e", "url": "https://github.com/apache/ignite/commit/f29d2806197b7cce268b7fc8867d932605b8095e", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-03T17:39:16Z", "type": "commit"}, {"oid": "36df449dd67705ef8c99aefe92531be1eeb61cda", "url": "https://github.com/apache/ignite/commit/36df449dd67705ef8c99aefe92531be1eeb61cda", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-06T10:06:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MDE0NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r485490144", "bodyText": "addrFinder can be null", "author": "ptupitsyn", "createdAt": "2020-09-09T09:57:58Z", "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +116,30 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /** Retry limit. */\n+    private int retryLimit = 0;\n+\n     /**\n      * @return Host addresses.\n      */\n     public String[] getAddresses() {\n-        return addrs;\n+        return addrFinder.get();", "originalCommit": "36df449dd67705ef8c99aefe92531be1eeb61cda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4OTY4MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486089680", "bodyText": "fixed", "author": "timoninmaxim", "createdAt": "2020-09-10T06:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MDE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MjI4Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r485492286", "bodyText": "Performance: do not create KubernetesServiceAddressResolver on every call, create it once in constructor.", "author": "ptupitsyn", "createdAt": "2020-09-09T10:01:37Z", "path": "modules/kubernetes/src/main/java/org/apache/ignite/client/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.internal.kubernetes.connection.KubernetesServiceAddressResolver;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite server nodes running in Kubernetes environment. All Ignite nodes have\n+ * to be deployed as Kubernetes pods in order to be found. Applications and Ignite nodes running outside of Kubernetes\n+ * will not be able to reach the containerized counterparts.\n+ * <p>\n+ * The implementation is based on a distinct Kubernetes service. The name of the service must be set with\n+ * {@code KubernetesConnectionConfiguration}. As for Ignite pods, it's recommended to label them in such a way that\n+ * the service will target only server nodes.\n+ * <p>\n+ * The address finder, in its turn, will call this service to retrieve Ignite pods IP addresses. The port will be\n+ * set later within {@link IgniteClient}. Make sure that all Ignite pods occupy a similar ClientConnector port,\n+ * otherwise they will not be able to connect each other using this address finder.\n+ * <p>\n+ */\n+public class ThinClientKubernetesAddressFinder implements Supplier<String[]> {\n+    /** Kubernetes connection configuration */\n+    private final KubernetesConnectionConfiguration cfg;\n+\n+    /** Constructor */\n+    public ThinClientKubernetesAddressFinder(KubernetesConnectionConfiguration cfg) {\n+        this.cfg = cfg;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String[] get() {\n+        return new KubernetesServiceAddressResolver(cfg)", "originalCommit": "36df449dd67705ef8c99aefe92531be1eeb61cda", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4OTcxOA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486089718", "bodyText": "fixed", "author": "timoninmaxim", "createdAt": "2020-09-10T06:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MjI4Ng=="}], "type": "inlineReview"}, {"oid": "6175a9561fc4875e19b3cae99767d45649ba0fcf", "url": "https://github.com/apache/ignite/commit/6175a9561fc4875e19b3cae99767d45649ba0fcf", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-10T05:53:47Z", "type": "commit"}, {"oid": "318bd1208f7ab401f7623967d83e7e01c789f665", "url": "https://github.com/apache/ignite/commit/318bd1208f7ab401f7623967d83e7e01c789f665", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-11T04:49:14Z", "type": "commit"}, {"oid": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "url": "https://github.com/apache/ignite/commit/431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-11T10:51:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MDkxNg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486970916", "bodyText": "Let's revert - no need to be clever here. ClientConfiguration should be a simple POJO, the logic for address handling should not be here.", "author": "ptupitsyn", "createdAt": "2020-09-11T10:59:50Z", "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +125,35 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /** Retry limit. */\n+    private int retryLimit = 0;\n+\n     /**\n      * @return Host addresses.\n      */\n     public String[] getAddresses() {\n-        return addrs;\n+        return Optional.ofNullable(addrFinder)", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY2NTcwNQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488665705", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MDkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MTI0MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486971241", "bodyText": "Same here - let's revert and move the logic to ReliableChannel.", "author": "ptupitsyn", "createdAt": "2020-09-11T11:00:36Z", "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +125,35 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /** Retry limit. */\n+    private int retryLimit = 0;\n+\n     /**\n      * @return Host addresses.\n      */\n     public String[] getAddresses() {\n-        return addrs;\n+        return Optional.ofNullable(addrFinder)\n+            .map(Supplier::get)\n+            .orElse(addrs);\n     }\n \n     /**\n      * @param addrs Host addresses.\n      */\n     public ClientConfiguration setAddresses(String... addrs) {\n-        this.addrs = addrs;\n+        if (addrs != null) {", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY2NTc2OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488665769", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MTI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MTI2Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486971266", "bodyText": "Corresponding getter is missing.", "author": "ptupitsyn", "createdAt": "2020-09-11T11:00:39Z", "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -115,18 +125,35 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /** Retry limit. */\n+    private int retryLimit = 0;\n+\n     /**\n      * @return Host addresses.\n      */\n     public String[] getAddresses() {\n-        return addrs;\n+        return Optional.ofNullable(addrFinder)\n+            .map(Supplier::get)\n+            .orElse(addrs);\n     }\n \n     /**\n      * @param addrs Host addresses.\n      */\n     public ClientConfiguration setAddresses(String... addrs) {\n-        this.addrs = addrs;\n+        if (addrs != null) {\n+            this.addrs = Arrays.copyOf(addrs, addrs.length);\n+            addrFinder = () -> this.addrs;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * @param finder function that finds node addresses\n+     */\n+    public ClientConfiguration setAddressesFinder(Supplier<String[]> finder) {", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY2NTg1OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488665858", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MjMzMA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486972330", "bodyText": "Sets the retry limit. When a request fails due to a connection error, and multiple server connections are available, Ignite will retry the request on every connection. When this property is greater than zero, Ignite will limit the number of retries.", "author": "ptupitsyn", "createdAt": "2020-09-11T11:03:23Z", "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -493,6 +520,25 @@ public ClientConfiguration setReconnectThrottlingRetries(int reconnectThrottling\n         return this;\n     }\n \n+    /**\n+     * Get retry limit.\n+     */\n+    public int getRetryLimit() {\n+        return retryLimit;\n+    }\n+\n+    /**\n+     * Try use limited number of channels to send a request if default channel is not responding.", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY2NTkyMA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488665920", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MjMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3Mzg3Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486973872", "bodyText": "Is there a reason to bring this outside of the constructor?", "author": "ptupitsyn", "createdAt": "2020-09-11T11:07:01Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/TcpIgniteClient.java", "diffHunk": "@@ -114,6 +114,7 @@ private TcpIgniteClient(ClientConfiguration cfg) throws ClientException {\n         binary = new ClientBinary(marsh);\n \n         ch = new ReliableChannel(chFactory, cfg, binary);\n+        ch.initConnection();", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxNjUwMA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487016500", "bodyText": "initCollection perform async operations, so it will lead to escaping incomplete ReliableChannel. I'm not confident is there too much troubles in our particular case, but best practice is to avoid such situations. IMHO, lazy initialization is preferable but there are too much test cases that rely that connection is initialized from beginning. So let's do not break the API, but preserve this object safe.", "author": "timoninmaxim", "createdAt": "2020-09-11T12:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3Mzg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3Njc4NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486976784", "bodyText": "AtomicReference is not needed, we can just use volatile since only get() and set() methods are used below.", "author": "ptupitsyn", "createdAt": "2020-09-11T11:13:43Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -62,16 +68,19 @@\n     private final Function<ClientChannelConfiguration, ClientChannel> chFactory;\n \n     /** Client channel holders for each configured address. */\n-    private final ClientChannelHolder[] channels;\n+    private final AtomicReference<List<ClientChannelHolder>> channels = new AtomicReference<>();", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4MTk1Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489181956", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-16T05:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3Njc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3NzU2Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486977562", "bodyText": "Please revert unnecessary renames to reduce the scope of changes.", "author": "ptupitsyn", "createdAt": "2020-09-11T11:15:22Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -62,16 +68,19 @@\n     private final Function<ClientChannelConfiguration, ClientChannel> chFactory;\n \n     /** Client channel holders for each configured address. */\n-    private final ClientChannelHolder[] channels;\n+    private final AtomicReference<List<ClientChannelHolder>> channels = new AtomicReference<>();\n \n     /** Index of the current channel. */\n-    private int curChIdx;\n+    private volatile int curChIdx = -1;\n \n     /** Partition awareness enabled. */\n     private final boolean partitionAwarenessEnabled;\n \n     /** Cache partition awareness context. */\n-    private final ClientCacheAffinityContext affinityCtx;\n+    private final ClientCacheAffinityContext affCtx;", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4MjAxMg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489182012", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-16T06:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3NzU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3ODEwNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486978104", "bodyText": "Here and below: race condition - channels may become null after the null check. Copy to a variable, then check for null / iterate / etc.", "author": "ptupitsyn", "createdAt": "2020-09-11T11:16:39Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -169,8 +167,10 @@\n             // No-op.\n         }\n \n-        for (ClientChannelHolder hld : channels)\n-            hld.closeChannel();\n+        if (channels.get() != null) {\n+            for (ClientChannelHolder hld: channels.get())", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3MzI4OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488673289", "bodyText": "There is no race conditions. As channels are set within synchronized method initChannelHolders. The discussed code is placed within close that is synchronized too. Also channels is never reference to null after it initialized, so this check is enough.\nFor other accessors to the channels field:\n\nrollCurrentChannel invokes after channels is initialized. Also it guards with curChannelsGuard.writeLock, so it is safe the reference directly;\napplyOnDefaultChannel can lead to NPE in case initConnection is not invoked. So I've just lazy initialization in the method, so there is a guarantee that channels are initialized. In our case this method call just returns fast;\ninitAllChannelsAsync are invoked after channels are initialized. Also it uses ArrayList.iterator() to iterate through channels. Under the hood it just creates Iterator object that. We change channels by reference switch so, this iterator is safe to use.\nchannelsInit is checks channels for null and then initialize them is it needed. So it's safe too.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3ODEwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2MDQyNQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488760425", "bodyText": "Sure, with current usages it may work, but the approach is fragile and hard to trace. See how you had to check every usage to make sure this logic is safe?\nFor volatiles and atomics it is a common practice to copy the value into a variable when you do multiple access and/or conditional logic:\n\nEasy to see that it is safe - less cognitive load\nFaster", "author": "ptupitsyn", "createdAt": "2020-09-15T15:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3ODEwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI3NjAyMQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489276021", "bodyText": "Fixed. The only place channels used directly is a single getter in applyOnDefaultChannel within guard read lock.", "author": "timoninmaxim", "createdAt": "2020-09-16T08:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3ODEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MTY3Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486981676", "bodyText": "private", "author": "ptupitsyn", "createdAt": "2020-09-11T11:24:58Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -381,78 +343,59 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n                 .rangeClosed(r.portFrom(), r.portTo()).boxed()\n                 .map(p -> new InetSocketAddress(r.host(), p))\n             )\n-            .collect(Collectors.toList());\n-    }\n-\n-    /** */\n-    private synchronized ClientChannel channel() {\n-        if (closed)\n-            throw new ClientException(\"Channel is closed\");\n-\n-        try {\n-            return channels[curChIdx].getOrCreateChannel();\n-        }\n-        catch (ClientConnectionException e) {\n-            rollCurrentChannel();\n-\n-            throw e;\n-        }\n-    }\n-\n-    /** */\n-    private synchronized void rollCurrentChannel() {\n-        if (++curChIdx >= channels.length)\n-            curChIdx = 0;\n+            .collect(Collectors.toSet());\n     }\n \n     /**\n-     * On current channel failure.\n+     * Roll current default channel if specified holder equals to it.\n      */\n-    private synchronized void onChannelFailure(ClientChannel ch) {\n-        // There is nothing wrong if curChIdx was concurrently changed, since channel was closed by another thread\n-        // when current index was changed and no other wrong channel will be closed by current thread because\n-        // onChannelFailure checks channel binded to the holder before closing it.\n-        onChannelFailure(channels[curChIdx], ch);\n-\n-        chFailLsnrs.forEach(Runnable::run);\n+    private void rollCurrentChannel(ClientChannelHolder hld) {\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            ClientChannelHolder dfltHld = channels.get().get(curChIdx);\n+            if (dfltHld == hld) {\n+                int idx = curChIdx + 1;\n+                if (idx >= channels.get().size())\n+                    curChIdx = 0;\n+                else\n+                    curChIdx = idx;\n+            }\n+        } finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n     }\n \n     /**\n      * On channel of the specified holder failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n-        if (ch == hld.ch && ch != null) {\n+    private void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n+        if (hld != null && ch != null && ch == hld.ch)\n             hld.closeChannel();\n \n-            if (hld == channels[curChIdx])\n-                rollCurrentChannel();\n-        }\n+        rollCurrentChannel(hld);\n+\n+        chFailLsnrs.forEach(Runnable::run);\n     }\n \n     /**\n      * Asynchronously try to establish a connection to all configured servers.\n      */\n-    private void initAllChannelsAsync() {\n-        // Skip if there is already channels reinit scheduled.\n-        if (scheduledChannelsReinit.compareAndSet(false, true)) {\n-            asyncRunner.submit(\n-                () -> {\n-                    scheduledChannelsReinit.set(false);\n-\n-                    for (ClientChannelHolder hld : channels) {\n-                        if (scheduledChannelsReinit.get() || closed)\n-                            return; // New reinit task scheduled or channel is closed.\n-\n-                        try {\n-                            hld.getOrCreateChannel(true);\n-                        }\n-                        catch (Exception ignore) {\n-                            // No-op.\n-                        }\n+    void initAllChannelsAsync() {", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3MzY0MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488673640", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MTY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MjM5Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486982392", "bodyText": "shouldStopChannelsReinit()", "author": "ptupitsyn", "createdAt": "2020-09-11T11:26:31Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3MzcxNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488673714", "bodyText": "FIxed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4MjM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NDExOQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486984119", "bodyText": "Too clever, verbose, and memory-hungry. Just make it channel = hld == null ? null : hld.getOrCreateChannel();.", "author": "ptupitsyn", "createdAt": "2020-09-11T11:30:15Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))\n+            .forEach(addr -> addrs.get(addr).setValue(true));\n+\n+        // create new holders for new addrs\n+        resolvedAddrs.stream()\n+            .filter(addr -> !addrs.containsKey(addr))\n+            .forEach(addr -> {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+                addrs.put(addr, new T2<>(hld, false));\n+            });\n+\n+        if (!stopInitCondition()) {\n+            List<ClientChannelHolder> list = new ArrayList<>();\n+            // The variable holds a new index of default channel after topology change.\n+            // Suppose that reuse of the channel is better than open new connection.\n+            int dfltChannelIdx = -1;\n+\n+            ClientChannelHolder currHolder = null;\n+            if (curChIdx != -1)\n+                currHolder = channels.get().get(curChIdx);\n+\n+            for (T2<ClientChannelHolder, Boolean> t : addrs.values()) {\n+                ClientChannelHolder hld = t.get1();\n+                Boolean markForDelete = t.get2();\n+\n+                if (markForDelete == null) {\n+                    // this channel is still in use\n+                    list.add(hld);\n+                    if (hld == currHolder)\n+                        dfltChannelIdx = list.size() - 1;\n+\n+                }\n+                else if (markForDelete) {\n+                    // this holder should be deleted now\n+                    nodeChannels.values().remove(hld);\n+                    hld.close();\n+                }\n+                else {\n+                    // this channel is new\n+                    list.add(hld);\n+                }\n+            }\n+\n+            if (dfltChannelIdx == -1)\n+                dfltChannelIdx = new Random().nextInt(list.size());\n+\n+            curChannelsGuard.writeLock().lock();\n+            try {\n+                channels.set(list);\n+                curChIdx = dfltChannelIdx;\n+            } finally {\n+                curChannelsGuard.writeLock().unlock();\n+            }\n+        }\n+    }\n+\n+    /** Initialization of channels. */\n+    private void channelsInit(boolean force) {\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        // Skip if there is already channels reinit scheduled.\n+        // Flag is set back when a thread comes in synchronized initChannelHolders\n+        if (scheduledChannelsReinit.compareAndSet(false, true)) {\n+            initChannelHolders(force);\n+\n+            if (partitionAwarenessEnabled)\n+                initAllChannelsAsync();\n+        }\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on a channel corresponding to specified {@code nodeId}.\n+     */\n+    private <T> T applyOnNodeChannel(UUID nodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = null;\n+        ClientChannel channel = null;\n+\n+        try {\n+            hld = nodeChannels.get(nodeId);\n+\n+            channel = Optional", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3Mzc5MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488673791", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NDExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4OTg2Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r486989862", "bodyText": "This requires iteration over entire map. Instead, use addrs.entrySet() for looping and remove by key.", "author": "ptupitsyn", "createdAt": "2020-09-11T11:43:02Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))\n+            .forEach(addr -> addrs.get(addr).setValue(true));\n+\n+        // create new holders for new addrs\n+        resolvedAddrs.stream()\n+            .filter(addr -> !addrs.containsKey(addr))\n+            .forEach(addr -> {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+                addrs.put(addr, new T2<>(hld, false));\n+            });\n+\n+        if (!stopInitCondition()) {\n+            List<ClientChannelHolder> list = new ArrayList<>();\n+            // The variable holds a new index of default channel after topology change.\n+            // Suppose that reuse of the channel is better than open new connection.\n+            int dfltChannelIdx = -1;\n+\n+            ClientChannelHolder currHolder = null;\n+            if (curChIdx != -1)\n+                currHolder = channels.get().get(curChIdx);\n+\n+            for (T2<ClientChannelHolder, Boolean> t : addrs.values()) {\n+                ClientChannelHolder hld = t.get1();\n+                Boolean markForDelete = t.get2();\n+\n+                if (markForDelete == null) {\n+                    // this channel is still in use\n+                    list.add(hld);\n+                    if (hld == currHolder)\n+                        dfltChannelIdx = list.size() - 1;\n+\n+                }\n+                else if (markForDelete) {\n+                    // this holder should be deleted now\n+                    nodeChannels.values().remove(hld);", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3Mzg2OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488673868", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4OTg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxNzI4Mw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487017283", "bodyText": "Here and below, please use Ignite code style for comments (start with uppercase later, end with a point).", "author": "alex-plekhanov", "createdAt": "2020-09-11T12:40:34Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -114,46 +126,32 @@\n         Function<ClientChannelConfiguration, ClientChannel> chFactory,\n         ClientConfiguration clientCfg,\n         IgniteBinary binary\n-    ) throws ClientException {\n+    ) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n-\n-        channels = new ClientChannelHolder[addrs.size()];\n-\n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n+        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled();\n \n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n-\n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n-\n-        affinityCtx = new ClientCacheAffinityContext(binary);\n-\n-        ClientConnectionException lastEx = null;\n-\n-        for (int i = 0; i < channels.length; i++) {\n-            try {\n-                channels[curChIdx].getOrCreateChannel();\n-\n-                if (partitionAwarenessEnabled)\n-                    initAllChannelsAsync();\n-\n-                return;\n-            } catch (ClientConnectionException e) {\n-                lastEx = e;\n-\n-                rollCurrentChannel();\n-            }\n-        }\n+        affCtx = new ClientCacheAffinityContext(binary);\n+    }\n \n-        throw lastEx;\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void initConnection() {\n+        channelsInit(false);\n+        if (!partitionAwarenessEnabled)\n+            applyOnDefaultChannel(channel -> {\n+                // do nothing, just trigger channel connection.", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3NDE5OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488674198", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxNzI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxOTQ0MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487019440", "bodyText": "Let's keep it static", "author": "alex-plekhanov", "createdAt": "2020-09-11T12:44:37Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -356,7 +318,7 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n     /**\n      * @return host:port_range address lines parsed as {@link InetSocketAddress}.\n      */\n-    private static List<InetSocketAddress> parseAddresses(String[] addrs) throws ClientException {\n+    private Set<InetSocketAddress> parseAddresses(String[] addrs) throws ClientException {", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3NDI4Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488674282", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxOTQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNDQ0NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487024444", "bodyText": "Can we skip further steps if clientCfg.getAddresses() is not changed? (for example, in case of static addresses configuration you will always reinit holders, but it's redundant)", "author": "alex-plekhanov", "createdAt": "2020-09-11T12:53:32Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4NjU4NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487686584", "bodyText": "Somebody can configure addresses with DNS names, in k8s env it is possible with StatefulSet configuration. But node can change IP. So after topology change we should check resolve all addresses. Nevertheless, It's possible to cache result of resolution.\nIn case of static configuration holders are persisted. But it's true that cache help to win some by skip iteration steps.", "author": "timoninmaxim", "createdAt": "2020-09-14T06:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNDQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcxNjYwMA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487716600", "bodyText": "At least you can skip these steps if references to addresses are equals (in case of k8s you will get the new array each time, in case of static configuration - the same array each time)", "author": "alex-plekhanov", "createdAt": "2020-09-14T07:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNDQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc0MzY2Nw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487743667", "bodyText": "With StatefulSet it will be a static configuration, i.e. list of DNS names like \"ignite-1, ignite-2, ignite-3\". Also it's not prohibited to configure with DNS names in any other env (non-k8s).\nTcpClientChannel creates socket with cfg.getAddress().getHostName() and it invokes reverse lookup even in case we specify address with hostnames.\nKubernetes have troubles with reverse lookup, as pods aren't aimed to be reverse resolved at all. There are some work in that direction, but the issue isn't resolved yet: coredns/coredns#3888\nSo, I think we can't rely on this reverse lookup. So it could be case when DNS name isn't changed but the channel is broken and don't have changes to be fixed. So re-resolution is required.\nI will check that resolved address isn't changed. And so skip next steps.", "author": "timoninmaxim", "createdAt": "2020-09-14T08:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNDQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MzA0NQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487853045", "bodyText": "To solve this problem we can store address as unresolved (InetSocketAddress#createUnresolved).\nIn your implementation initChannelHolders will be invoked in response reading thread on each topology change. I think address resolving in this thread can take some time and should be avoided.", "author": "alex-plekhanov", "createdAt": "2020-09-14T11:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNDQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3NDM2Mw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488674363", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNDQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNDc3MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487024771", "bodyText": "new ArrayList<>() -> Collections.emptyList()", "author": "alex-plekhanov", "createdAt": "2020-09-11T12:54:07Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3NDQ1OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488674459", "bodyText": "FIxed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyNDc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NTE4Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487055186", "bodyText": "force flag is only set when partition awareness is used, but I think sometimes we should reinit holders even without partition awareness. For example, if we use Kubernetes discovery and new servers were started, the client will use only addresses of server nodes that were available at the time of client start.", "author": "alex-plekhanov", "createdAt": "2020-09-11T13:45:19Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()\n+            .collect(Collectors.toMap(\n+                c -> c.chCfg.getAddress(),\n+                c -> new T2<>(c, null)\n+        ));\n+\n+        // mark for delete addrs that aren't provided by clientConfig now\n+        addrs.keySet()\n+            .stream()\n+            .filter(addr -> !resolvedAddrs.contains(addr))\n+            .forEach(addr -> addrs.get(addr).setValue(true));\n+\n+        // create new holders for new addrs\n+        resolvedAddrs.stream()\n+            .filter(addr -> !addrs.containsKey(addr))\n+            .forEach(addr -> {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+                addrs.put(addr, new T2<>(hld, false));\n+            });\n+\n+        if (!stopInitCondition()) {\n+            List<ClientChannelHolder> list = new ArrayList<>();\n+            // The variable holds a new index of default channel after topology change.\n+            // Suppose that reuse of the channel is better than open new connection.\n+            int dfltChannelIdx = -1;\n+\n+            ClientChannelHolder currHolder = null;\n+            if (curChIdx != -1)\n+                currHolder = channels.get().get(curChIdx);\n+\n+            for (T2<ClientChannelHolder, Boolean> t : addrs.values()) {\n+                ClientChannelHolder hld = t.get1();\n+                Boolean markForDelete = t.get2();\n+\n+                if (markForDelete == null) {\n+                    // this channel is still in use\n+                    list.add(hld);\n+                    if (hld == currHolder)\n+                        dfltChannelIdx = list.size() - 1;\n+\n+                }\n+                else if (markForDelete) {\n+                    // this holder should be deleted now\n+                    nodeChannels.values().remove(hld);\n+                    hld.close();\n+                }\n+                else {\n+                    // this channel is new\n+                    list.add(hld);\n+                }\n+            }\n+\n+            if (dfltChannelIdx == -1)\n+                dfltChannelIdx = new Random().nextInt(list.size());\n+\n+            curChannelsGuard.writeLock().lock();\n+            try {\n+                channels.set(list);\n+                curChIdx = dfltChannelIdx;\n+            } finally {\n+                curChannelsGuard.writeLock().unlock();\n+            }\n+        }\n+    }\n+\n+    /** Initialization of channels. */\n+    private void channelsInit(boolean force) {", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3NDk2Nw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488674967", "bodyText": "FIxed. Skip check flag partitionAwareness and just checks topology version.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NTE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3Mjg2NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487072864", "bodyText": "I would prefer a dedicated interface - ThinClientAddressFinder or something like this.", "author": "ptupitsyn", "createdAt": "2020-09-11T14:12:48Z", "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -33,9 +36,16 @@\n     /** Serial version uid. */\n     private static final long serialVersionUID = 0L;\n \n-    /** @serial Server addresses. */\n+    /**\n+     * @serial Server addresses.\n+     * @deprecated deprecated in favor of {@link #addrFinder}. Keep it due to Serializable compatibility.\n+     */\n+    @Deprecated\n     private String[] addrs = null;\n \n+    /** Server addresses finder. */\n+    private transient Supplier<String[]> addrFinder;", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3NTMxMQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488675311", "bodyText": "Used ClientAddressFinder as all classes in this package use Client prefix.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3Mjg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3MzA2OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487073068", "bodyText": "Perhaps code will be much more simple with regular loop over holders without streams and intermediate structures.", "author": "alex-plekhanov", "createdAt": "2020-09-11T14:13:09Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,6 +415,196 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean stopInitCondition() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    private synchronized void initChannelHolders(boolean force) {\n+        // enable parallel threads to schedule new init of channel holders\n+        scheduledChannelsReinit.set(false);\n+\n+        if (!force && channels.get() != null)\n+            return;\n+\n+        Set<InetSocketAddress> resolvedAddrs = parseAddresses(clientCfg.getAddresses());\n+\n+        List<ClientChannelHolder> holders = Optional.ofNullable(channels.get()).orElse(new ArrayList<>());\n+\n+        // addr -> (holder, delete)\n+        Map<InetSocketAddress, T2<ClientChannelHolder, Boolean>> addrs = holders.stream()", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3NTQ5MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488675490", "bodyText": "Fixed. Looks simplier.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3MzA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMDcxMw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r487720713", "bodyText": "There will be 100 holders created for each host (and there will be 100 retries to connect for each host) if port is not set explicitly (see ReliableChannel#parseAddresses). Can we also add ports to this array?", "author": "alex-plekhanov", "createdAt": "2020-09-14T07:57:01Z", "path": "modules/kubernetes/src/main/java/org/apache/ignite/client/ThinClientKubernetesAddressFinder.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+import java.net.InetAddress;\n+import java.util.function.Supplier;\n+import org.apache.ignite.internal.kubernetes.connection.KubernetesServiceAddressResolver;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+\n+/**\n+ * Address finder for automatic lookup of Ignite server nodes running in Kubernetes environment. All Ignite nodes have\n+ * to be deployed as Kubernetes pods in order to be found. Applications and Ignite nodes running outside of Kubernetes\n+ * will not be able to reach the containerized counterparts.\n+ * <p>\n+ * The implementation is based on a distinct Kubernetes service. The name of the service must be set with\n+ * {@code KubernetesConnectionConfiguration}. As for Ignite pods, it's recommended to label them in such a way that\n+ * the service will target only server nodes.\n+ * <p>\n+ * The address finder, in its turn, will call this service to retrieve Ignite pods IP addresses. The port will be\n+ * set later within {@link IgniteClient}. Make sure that all Ignite pods occupy a similar ClientConnector port,\n+ * otherwise they will not be able to connect each other using this address finder.\n+ * <p>\n+ */\n+public class ThinClientKubernetesAddressFinder implements Supplier<String[]> {\n+    /** Kubernetes service address resolver. */\n+    private final KubernetesServiceAddressResolver resolver;\n+\n+    /** Constructor */\n+    public ThinClientKubernetesAddressFinder(KubernetesConnectionConfiguration cfg) {\n+        resolver = new KubernetesServiceAddressResolver(cfg);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public String[] get() {\n+        return resolver\n+            .getServiceAddresses()\n+            .stream().map(InetAddress::getHostAddress)\n+            .toArray(String[]::new);", "originalCommit": "431769fb3f3bed84257a88ecb0ac1edeb5f3f893", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3NTU5NQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r488675595", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-15T13:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMDcxMw=="}], "type": "inlineReview"}, {"oid": "6c8629b391096817d069351c30332dde63f70859", "url": "https://github.com/apache/ignite/commit/6c8629b391096817d069351c30332dde63f70859", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-15T13:25:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2NDIyNg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489364226", "bodyText": "If partition awareness is enabled we still need to init default channel on startup", "author": "alex-plekhanov", "createdAt": "2020-09-16T11:28:56Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -114,46 +135,32 @@\n         Function<ClientChannelConfiguration, ClientChannel> chFactory,\n         ClientConfiguration clientCfg,\n         IgniteBinary binary\n-    ) throws ClientException {\n+    ) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n-\n-        channels = new ClientChannelHolder[addrs.size()];\n-\n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n-\n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n-\n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n+        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled();\n \n         affinityCtx = new ClientCacheAffinityContext(binary);\n+    }\n \n-        ClientConnectionException lastEx = null;\n-\n-        for (int i = 0; i < channels.length; i++) {\n-            try {\n-                channels[curChIdx].getOrCreateChannel();\n-\n-                if (partitionAwarenessEnabled)\n-                    initAllChannelsAsync();\n-\n-                return;\n-            } catch (ClientConnectionException e) {\n-                lastEx = e;\n-\n-                rollCurrentChannel();\n-            }\n-        }\n-\n-        throw lastEx;\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void initConnection() {\n+        channelsInit(false);\n+        if (!partitionAwarenessEnabled)", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ1NTM4MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489455381", "bodyText": "It will inside channelsInit", "author": "timoninmaxim", "createdAt": "2020-09-16T13:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2NDIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ1OTIyMA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489459220", "bodyText": "But it will be async. We should throw an exception if none of addresses are valid.", "author": "alex-plekhanov", "createdAt": "2020-09-16T13:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2NDIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2Nzk1Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r494267952", "bodyText": "FIxed, add test for that", "author": "timoninmaxim", "createdAt": "2020-09-24T12:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2NDIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2NjMwMg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489366302", "bodyText": "Here and bellow, please use Ignite codestyle (see https://cwiki.apache.org/confluence/display/IGNITE/Coding+Guidelines Semantic Units section)", "author": "alex-plekhanov", "createdAt": "2020-09-16T11:32:52Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -114,46 +135,32 @@\n         Function<ClientChannelConfiguration, ClientChannel> chFactory,\n         ClientConfiguration clientCfg,\n         IgniteBinary binary\n-    ) throws ClientException {\n+    ) {\n         if (chFactory == null)\n             throw new NullPointerException(\"chFactory\");\n \n         if (clientCfg == null)\n             throw new NullPointerException(\"clientCfg\");\n \n+        this.clientCfg = clientCfg;\n         this.chFactory = chFactory;\n \n-        List<InetSocketAddress> addrs = parseAddresses(clientCfg.getAddresses());\n-\n-        channels = new ClientChannelHolder[addrs.size()];\n-\n-        for (int i = 0; i < channels.length; i++)\n-            channels[i] = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addrs.get(i)));\n-\n-        curChIdx = new Random().nextInt(channels.length); // We already verified there is at least one address.\n-\n-        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled() && channels.length > 1;\n+        partitionAwarenessEnabled = clientCfg.isPartitionAwarenessEnabled();\n \n         affinityCtx = new ClientCacheAffinityContext(binary);\n+    }\n \n-        ClientConnectionException lastEx = null;\n-\n-        for (int i = 0; i < channels.length; i++) {\n-            try {\n-                channels[curChIdx].getOrCreateChannel();\n-\n-                if (partitionAwarenessEnabled)\n-                    initAllChannelsAsync();\n-\n-                return;\n-            } catch (ClientConnectionException e) {\n-                lastEx = e;\n-\n-                rollCurrentChannel();\n-            }\n-        }\n-\n-        throw lastEx;\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void initConnection() {\n+        channelsInit(false);", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3NDEyOA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489374128", "bodyText": "hld can't be null here", "author": "alex-plekhanov", "createdAt": "2020-09-16T11:47:20Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -379,80 +351,65 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n         return ranges.stream()\n             .flatMap(r -> IntStream\n                 .rangeClosed(r.portFrom(), r.portTo()).boxed()\n-                .map(p -> new InetSocketAddress(r.host(), p))\n+                .map(p -> InetSocketAddress.createUnresolved(r.host(), p))\n             )\n-            .collect(Collectors.toList());\n-    }\n-\n-    /** */\n-    private synchronized ClientChannel channel() {\n-        if (closed)\n-            throw new ClientException(\"Channel is closed\");\n-\n-        try {\n-            return channels[curChIdx].getOrCreateChannel();\n-        }\n-        catch (ClientConnectionException e) {\n-            rollCurrentChannel();\n-\n-            throw e;\n-        }\n-    }\n-\n-    /** */\n-    private synchronized void rollCurrentChannel() {\n-        if (++curChIdx >= channels.length)\n-            curChIdx = 0;\n+            .collect(Collectors.toSet());\n     }\n \n     /**\n-     * On current channel failure.\n+     * Roll current default channel if specified holder equals to it.\n      */\n-    private synchronized void onChannelFailure(ClientChannel ch) {\n-        // There is nothing wrong if curChIdx was concurrently changed, since channel was closed by another thread\n-        // when current index was changed and no other wrong channel will be closed by current thread because\n-        // onChannelFailure checks channel binded to the holder before closing it.\n-        onChannelFailure(channels[curChIdx], ch);\n-\n-        chFailLsnrs.forEach(Runnable::run);\n+    private void rollCurrentChannel(ClientChannelHolder hld) {\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            int idx = curChIdx;\n+            List<ClientChannelHolder> holders = channels;\n+\n+            ClientChannelHolder dfltHld = holders.get(idx);\n+            if (dfltHld == hld) {\n+                idx += 1;\n+                if (idx >= holders.size())\n+                    curChIdx = 0;\n+                else\n+                    curChIdx = idx;\n+            }\n+        } finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n     }\n \n     /**\n      * On channel of the specified holder failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n-        if (ch == hld.ch && ch != null) {\n+    private void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n+        if (hld != null && ch != null && ch == hld.ch)", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3OTI4OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489379288", "bodyText": "This method is invoked inside request processing thread, I don't like the idea of sync channel holders reinit (which can do additional sync http requests) on each topology change in this thread.\nI think we should do it async if partition awareness is enabled. Additionally, we can do it sync in sending thread on channel failure and if we detect topology change before.", "author": "alex-plekhanov", "createdAt": "2020-09-16T11:56:22Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -461,9 +418,8 @@ private void initAllChannelsAsync() {\n      * @param ch Channel.\n      */\n     private void onTopologyChanged(ClientChannel ch) {\n-        if (partitionAwarenessEnabled && affinityCtx.updateLastTopologyVersion(ch.serverTopologyVersion(),\n-            ch.serverNodeId()))\n-            initAllChannelsAsync();\n+        if (affinityCtx.updateLastTopologyVersion(ch.serverTopologyVersion(), ch.serverNodeId()))\n+            channelsInit(true);", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzQ5NTUyMg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r493495522", "bodyText": "we can do it sync in sending thread on channel failure and if we detect topology change before\n\nIt can be wrong. Topology change can be triggered by joining node, so channel failure may never occur. I'll make async initialization in any case.", "author": "timoninmaxim", "createdAt": "2020-09-23T11:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3OTI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2ODk5Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r494268992", "bodyText": "If partition awareness is disabled and a new node is joined it's fine to work with the current node until failure (we don't need to find new nodes unless we disconnected from the current).", "author": "alex-plekhanov", "createdAt": "2020-09-24T12:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3OTI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk2OTE5Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r494969192", "bodyText": "Fair. Fixed it. Change signature of initChannelHolders, now it's not void but returns boolean (flag of interruption). Otherwise for disabled awareness and continuous topology events there would be a chances for StackOverflow, as channel failure trigger recursively applyOnDefaultChannel to enable default channel.", "author": "timoninmaxim", "createdAt": "2020-09-25T12:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM3OTI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4MTA4NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489381084", "bodyText": "Let's rename it to something more meaningful (like another two apply... methods). For, example, applyOnNodeChannelWithRetry or something like that.", "author": "alex-plekhanov", "createdAt": "2020-09-16T11:59:49Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -473,16 +429,230 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /** Should the channel initialization be stopped. */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     */\n+    synchronized void initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Set<InetSocketAddress> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getServerAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = Collections.emptyMap();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs);\n+\n+        if (holders != null) {\n+            curAddrs = holders.stream()\n+                .collect(Collectors.toMap(h -> h.chCfg.getAddress(), h -> h));\n+\n+            allAddrs.addAll(curAddrs.keySet());\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+        int idx = curChIdx;\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.contains(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+                reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+            reinitHolders.add(hld);\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();\n+    }\n+\n+    /** Initialization of channels. */\n+    private void channelsInit(boolean force) {\n+        if (!force && channels != null)\n+            return;\n+\n+        // Skip if there is already channels reinit scheduled.\n+        // Flag is set back when a thread comes in synchronized initChannelHolders.\n+        if (scheduledChannelsReinit.compareAndSet(false, true)) {\n+            initChannelHolders(force);\n+\n+            if (partitionAwarenessEnabled)\n+                initAllChannelsAsync();\n+        }\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on a channel corresponding to specified {@code nodeId}.\n+     */\n+    private <T> T applyOnNodeChannel(UUID nodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = null;\n+        ClientChannel channel = null;\n+\n+        try {\n+            hld = nodeChannels.get(nodeId);\n+\n+            channel = hld != null ? hld.getOrCreateChannel() : null;\n+\n+            if (channel != null)\n+                return function.apply(channel);\n+\n+        } catch (ClientConnectionException e) {\n+            onChannelFailure(hld, channel);\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on any of available channel.\n+     */\n+    private <T> T applyOnDefaultChannel(Function<ClientChannel, T> function) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (holders == null)\n+            throw new ClientException(\"Connections to nodes aren't initialized.\");\n+\n+        int size = holders.size();\n+\n+        int attemptsLimit = clientCfg.getRetryLimit() > 0 ?\n+            Math.min(clientCfg.getRetryLimit(), size) : size;\n+\n+        ClientConnectionException failure = null;\n+\n+        for (int attempt = 0; attempt < attemptsLimit; attempt++) {\n+            ClientChannelHolder hld = null;\n+            ClientChannel c = null;\n+            try {\n+                if (closed)\n+                    throw new ClientException(\"Channel is closed\");\n+\n+                curChannelsGuard.readLock().lock();\n+                try {\n+                    hld = channels.get(curChIdx);\n+                } finally {\n+                    curChannelsGuard.readLock().unlock();\n+                }\n+\n+                c = hld.getOrCreateChannel();\n+                if (c != null)\n+                    return function.apply(c);\n+            }\n+            catch (ClientConnectionException e) {\n+                if (failure == null)\n+                    failure = e;\n+                else\n+                    failure.addSuppressed(e);\n+\n+                onChannelFailure(hld, c);\n+            }\n+        }\n+\n+        throw failure;\n+    }\n+\n+    /**\n+     * Try apply specified {@code function} on a channel corresponding to {@code tryNodeId}.\n+     * If failed then apply the function on any available channel.\n+     */\n+    private <T> T apply(UUID tryNodeId, Function<ClientChannel, T> function) {", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4OTgyOA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497489828", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T13:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4MTA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4MjYwNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489382604", "bodyText": "This if is redundant, since you set serverNodeId later and the next if condition can't be true with this condition at the same time.", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:02:43Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -519,29 +689,44 @@ private boolean applyReconnectionThrottling() {\n         /**\n          * Get or create channel.\n          */\n-        private synchronized ClientChannel getOrCreateChannel()\n+        private ClientChannel getOrCreateChannel()\n             throws ClientConnectionException, ClientAuthenticationException, ClientProtocolError {\n             return getOrCreateChannel(false);\n         }\n \n         /**\n          * Get or create channel.\n          */\n-        private synchronized ClientChannel getOrCreateChannel(boolean ignoreThrottling)\n+        private ClientChannel getOrCreateChannel(boolean ignoreThrottling)\n             throws ClientConnectionException, ClientAuthenticationException, ClientProtocolError {\n-            if (ch == null) {\n-                if (!ignoreThrottling && applyReconnectionThrottling())\n-                    throw new ClientConnectionException(\"Reconnect is not allowed due to applied throttling\");\n+            if (ch == null && !close) {\n+                synchronized (this) {\n+                    if (close)\n+                        return null;\n+\n+                    if (ch != null)\n+                        return ch;\n \n-                ch = chFactory.apply(chCfg);\n+                    if (!ignoreThrottling && applyReconnectionThrottling())\n+                        throw new ClientConnectionException(\"Reconnect is not allowed due to applied throttling\");\n \n-                if (ch.serverNodeId() != null) {\n-                    ch.addTopologyChangeListener(ReliableChannel.this::onTopologyChanged);\n-                    ch.addNotificationListener(ReliableChannel.this);\n+                    ClientChannel channel = chFactory.apply(chCfg);\n \n-                    nodeChannels.values().remove(this);\n+                    if (channel.serverNodeId() != null) {\n+                        channel.addTopologyChangeListener(ReliableChannel.this::onTopologyChanged);\n+                        channel.addNotificationListener(ReliableChannel.this);\n \n-                    nodeChannels.putIfAbsent(ch.serverNodeId(), this);\n+                        if (serverNodeId == null)", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4OTkxNQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497489915", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T13:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4MjYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4Mjk4Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489382986", "bodyText": "nodeChannels.remove(serverNodeId, this)", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:03:29Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -519,29 +689,44 @@ private boolean applyReconnectionThrottling() {\n         /**\n          * Get or create channel.\n          */\n-        private synchronized ClientChannel getOrCreateChannel()\n+        private ClientChannel getOrCreateChannel()\n             throws ClientConnectionException, ClientAuthenticationException, ClientProtocolError {\n             return getOrCreateChannel(false);\n         }\n \n         /**\n          * Get or create channel.\n          */\n-        private synchronized ClientChannel getOrCreateChannel(boolean ignoreThrottling)\n+        private ClientChannel getOrCreateChannel(boolean ignoreThrottling)\n             throws ClientConnectionException, ClientAuthenticationException, ClientProtocolError {\n-            if (ch == null) {\n-                if (!ignoreThrottling && applyReconnectionThrottling())\n-                    throw new ClientConnectionException(\"Reconnect is not allowed due to applied throttling\");\n+            if (ch == null && !close) {\n+                synchronized (this) {\n+                    if (close)\n+                        return null;\n+\n+                    if (ch != null)\n+                        return ch;\n \n-                ch = chFactory.apply(chCfg);\n+                    if (!ignoreThrottling && applyReconnectionThrottling())\n+                        throw new ClientConnectionException(\"Reconnect is not allowed due to applied throttling\");\n \n-                if (ch.serverNodeId() != null) {\n-                    ch.addTopologyChangeListener(ReliableChannel.this::onTopologyChanged);\n-                    ch.addNotificationListener(ReliableChannel.this);\n+                    ClientChannel channel = chFactory.apply(chCfg);\n \n-                    nodeChannels.values().remove(this);\n+                    if (channel.serverNodeId() != null) {\n+                        channel.addTopologyChangeListener(ReliableChannel.this::onTopologyChanged);\n+                        channel.addNotificationListener(ReliableChannel.this);\n \n-                    nodeChannels.putIfAbsent(ch.serverNodeId(), this);\n+                        if (serverNodeId == null)\n+                            serverNodeId = channel.serverNodeId();\n+\n+                        if (serverNodeId != null && serverNodeId != channel.serverNodeId())\n+                            nodeChannels.remove(serverNodeId);", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5MDAwMA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497490000", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T13:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4Mjk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4MzU0Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489383542", "bodyText": "nodeChannels.remove(serverNodeId, this)", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:04:35Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -561,5 +746,24 @@ private synchronized void closeChannel() {\n                 ch = null;\n             }\n         }\n+\n+        /** Close holder. */\n+        void close() {\n+            close = true;\n+            if (serverNodeId != null)\n+                nodeChannels.remove(serverNodeId);", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5MDA3OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497490078", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T13:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4MzU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5MTcwNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504491704", "bodyText": "Still not fixed", "author": "alex-plekhanov", "createdAt": "2020-10-14T08:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4MzU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4ODY4MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489388680", "bodyText": "Let's make channel package private and use it in tests directly (or make nodeChannels private and create the same getter for it)", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:13:56Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -561,5 +746,24 @@ private synchronized void closeChannel() {\n                 ch = null;\n             }\n         }\n+\n+        /** Close holder. */\n+        void close() {\n+            close = true;\n+            if (serverNodeId != null)\n+                nodeChannels.remove(serverNodeId);\n+\n+            closeChannel();\n+        }\n+\n+        /** Wheteher the holder is closed. For test purposes. */\n+        boolean isClosed() {\n+            return close;\n+        }\n+    }\n+\n+    /** Get holders reference. For test purposes. */\n+    List<ClientChannelHolder> getChannelHolders() {", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5MDE3NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497490174", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T13:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM4ODY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5MTY0OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489391649", "bodyText": "Didn't get this check. We already checked that references are the same. Isn't it?", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:19:02Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** Checks that channel holders are not reinited if address finder return the same list of addresses. */\n+    @Test\n+    public void testChannelsNotReinitForStableDynamicAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\"));\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** */\n+    private void checkDoesNotReinit(ClientConfiguration ccfg) {\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        List<ReliableChannel.ClientChannelHolder> originalChannels = rc.getChannelHolders();\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+        List<ReliableChannel.ClientChannelHolder> newChannels = rc.getChannelHolders();\n+\n+        assertSame(originalChannels, newChannels);\n+        IntStream.range(0, 3).forEach(i -> {\n+            assertSame(originalChannels.get(i), newChannels.get(i));", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUwNDk4Nw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r493504987", "bodyText": "At first we check that reference of List doesn't change, then check that reference for every holder within the List doesn't change.", "author": "timoninmaxim", "createdAt": "2020-09-23T12:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5MTY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4OTE4Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497289186", "bodyText": "But you compare current reference with current reference. If you want to check that reference for every holder doesn't change you should copy originalChannels before topology change and then check this copy against newChannels", "author": "alex-plekhanov", "createdAt": "2020-09-30T07:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5MTY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4Nzc5MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497487790", "bodyText": "Fair, miss it. Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T12:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5MTY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5NDM3NQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489394375", "bodyText": "Let's use standard ports for thin client (10800). Yes, I know it's just a dummy address, but someone can understand it wrong during a brief test lookup.", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:23:44Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5MDI0NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497490244", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T13:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5NDM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5OTIzOQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489399239", "bodyText": "It's counterintuitive without looking at TestAddressFinder implementation that we use the same set of addresses. Let's make TestAddressFinder more generic, use some Queue inside, and use it something like this:\nnew TestAddressFinder().add(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\").add(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\")", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:31:43Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** Checks that channel holders are not reinited if address finder return the same list of addresses. */\n+    @Test\n+    public void testChannelsNotReinitForStableDynamicAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\"));", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5MDMyNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497490324", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T13:01:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5OTIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwMjY0MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489402641", "bodyText": "assertEquals(2, F.size(originChannels, r -> r.isClosed()));", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:37:29Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** Checks that channel holders are not reinited if address finder return the same list of addresses. */\n+    @Test\n+    public void testChannelsNotReinitForStableDynamicAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\"));\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** */\n+    private void checkDoesNotReinit(ClientConfiguration ccfg) {\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        List<ReliableChannel.ClientChannelHolder> originalChannels = rc.getChannelHolders();\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+        List<ReliableChannel.ClientChannelHolder> newChannels = rc.getChannelHolders();\n+\n+        assertSame(originalChannels, newChannels);\n+        IntStream.range(0, 3).forEach(i -> {\n+            assertSame(originalChannels.get(i), newChannels.get(i));\n+            assertFalse(originalChannels.get(i).isClosed());\n+        });\n+        assertEquals(3, newChannels.size());\n+    }\n+\n+    /** Checks that node channels are persisted if channels are reinit with static address configuration. */\n+    @Test\n+    public void testNodeChannelsAreNotCleaned() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        // Trigger TestClientChannel creation.\n+        rc.service(null, null, null);\n+\n+        assertEquals(1, rc.nodeChannels.size());\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+\n+        assertEquals(1, rc.nodeChannels.size());\n+    }\n+\n+    /** Checks that channels are changed (add new, remove old) and close channels if reinitialization performed. */\n+    @Test\n+    public void testDynamicAddressReinitializedCorrectly() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8003\"));\n+\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+\n+        List<ReliableChannel.ClientChannelHolder> originChannels = Collections.unmodifiableList(rc.getChannelHolders());\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+\n+        List<ReliableChannel.ClientChannelHolder> closedChannels = originChannels.stream()\n+            .filter(r -> r.isClosed())\n+            .collect(Collectors.toList());\n+\n+        assertEquals(2, closedChannels.size());", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5MDQwNw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497490407", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T13:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwMjY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwMzA5NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489403094", "bodyText": "IMO it's more readable to use for loop here", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:38:16Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** Checks that channel holders are not reinited if address finder return the same list of addresses. */\n+    @Test\n+    public void testChannelsNotReinitForStableDynamicAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\"));\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** */\n+    private void checkDoesNotReinit(ClientConfiguration ccfg) {\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        List<ReliableChannel.ClientChannelHolder> originalChannels = rc.getChannelHolders();\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+        List<ReliableChannel.ClientChannelHolder> newChannels = rc.getChannelHolders();\n+\n+        assertSame(originalChannels, newChannels);\n+        IntStream.range(0, 3).forEach(i -> {", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5MDQ4Mw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497490483", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T13:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwMzA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwNjI2NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489406264", "bodyText": "newChannels.contains?", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:43:29Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** Checks that channel holders are not reinited for static address configuration. */\n+    @Test\n+    public void testChannelsNotReinitForStaticAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** Checks that channel holders are not reinited if address finder return the same list of addresses. */\n+    @Test\n+    public void testChannelsNotReinitForStableDynamicAddressConfiguration() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\"));\n+\n+        checkDoesNotReinit(ccfg);\n+    }\n+\n+    /** */\n+    private void checkDoesNotReinit(ClientConfiguration ccfg) {\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        List<ReliableChannel.ClientChannelHolder> originalChannels = rc.getChannelHolders();\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+        List<ReliableChannel.ClientChannelHolder> newChannels = rc.getChannelHolders();\n+\n+        assertSame(originalChannels, newChannels);\n+        IntStream.range(0, 3).forEach(i -> {\n+            assertSame(originalChannels.get(i), newChannels.get(i));\n+            assertFalse(originalChannels.get(i).isClosed());\n+        });\n+        assertEquals(3, newChannels.size());\n+    }\n+\n+    /** Checks that node channels are persisted if channels are reinit with static address configuration. */\n+    @Test\n+    public void testNodeChannelsAreNotCleaned() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddresses(\"127.0.0.1:8000\", \"127.0.0.1:8001\", \"127.0.0.1:8002\");\n+\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+        // Trigger TestClientChannel creation.\n+        rc.service(null, null, null);\n+\n+        assertEquals(1, rc.nodeChannels.size());\n+\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+\n+        assertEquals(1, rc.nodeChannels.size());\n+    }\n+\n+    /** Checks that channels are changed (add new, remove old) and close channels if reinitialization performed. */\n+    @Test\n+    public void testDynamicAddressReinitializedCorrectly() {\n+        ClientConfiguration ccfg = new ClientConfiguration()\n+            .setAddressesFinder(new TestAddressFinder(\"127.0.0.1:8000\", \"127.0.0.1:8003\"));\n+\n+        ReliableChannel rc = new ReliableChannel(chFactory, ccfg, null);\n+        rc.initConnection();\n+\n+        List<ReliableChannel.ClientChannelHolder> originChannels = Collections.unmodifiableList(rc.getChannelHolders());\n+        // Imitate topology change.\n+        rc.initChannelHolders(true);\n+\n+        List<ReliableChannel.ClientChannelHolder> closedChannels = originChannels.stream()\n+            .filter(r -> r.isClosed())\n+            .collect(Collectors.toList());\n+\n+        assertEquals(2, closedChannels.size());\n+\n+        List<ReliableChannel.ClientChannelHolder> reuseChannel = originChannels.stream()\n+            .filter(c -> !c.isClosed())\n+            .collect(Collectors.toList());\n+\n+        assertEquals(1, reuseChannel.size());\n+\n+        List<ReliableChannel.ClientChannelHolder> newChannels = rc.getChannelHolders();\n+        assertEquals(2, newChannels.size());\n+        assertTrue(newChannels.get(0) == reuseChannel.get(0) || newChannels.get(1) == reuseChannel.get(0));", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzMzcwMg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r493533702", "bodyText": "contains invoke equals but I check references.", "author": "timoninmaxim", "createdAt": "2020-09-23T12:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwNjI2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI5MDc5Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497290792", "bodyText": "equals for ClientChannelHolder only compare references :)", "author": "alex-plekhanov", "createdAt": "2020-09-30T07:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwNjI2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQwNzA4Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497407082", "bodyText": "Currently it is, but the behavior may change in future and test will start check different case (we'll be lucky enough it will fail). Also I believe that explicit check is better.", "author": "timoninmaxim", "createdAt": "2020-09-30T10:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwNjI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwODg1Mw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489408853", "bodyText": "point at the end", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:47:32Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ThinClientPartitionAwarenessDiscoveryTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.processors.cache.IgniteInternalCache;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.odbc.ClientListenerProcessor.CLIENT_LISTENER_PORT;\n+\n+/**\n+ * Test partition awareness of thin client on changed topology.\n+ */\n+public class ThinClientPartitionAwarenessDiscoveryTest extends ThinClientAbstractPartitionAwarenessTest {\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while new nodes start", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4OTY4NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497489684", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T13:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwODg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwODg5NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489408894", "bodyText": "point at the end", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:47:36Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ThinClientPartitionAwarenessDiscoveryTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.processors.cache.IgniteInternalCache;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.odbc.ClientListenerProcessor.CLIENT_LISTENER_PORT;\n+\n+/**\n+ * Test partition awareness of thin client on changed topology.\n+ */\n+public class ThinClientPartitionAwarenessDiscoveryTest extends ThinClientAbstractPartitionAwarenessTest {\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while new nodes start\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesJoin() throws Exception {\n+        for (int i = 0; i < MAX_CLUSTER_SIZE; ++i) {\n+            startGrid(i);\n+            awaitPartitionMapExchange();\n+\n+            int[] workChannels = IntStream.rangeClosed(0, i).toArray();\n+\n+            if (i == 0)\n+                initClient(getClientConfigurationWithDiscovery(), workChannels);\n+            else {\n+                detectTopologyChange();\n+                awaitChannelsInit(workChannels);\n+            }\n+\n+            testPartitionAwareness(workChannels);\n+        }\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while nodes stop", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4OTYxNg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r497489616", "bodyText": "fixed.", "author": "timoninmaxim", "createdAt": "2020-09-30T13:00:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQwODg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNjg1Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489416852", "bodyText": "Why do we need a second request? Topology change already should be detected after initDefaultChannel call", "author": "alex-plekhanov", "createdAt": "2020-09-16T12:59:43Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ThinClientPartitionAwarenessDiscoveryTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.processors.cache.IgniteInternalCache;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.odbc.ClientListenerProcessor.CLIENT_LISTENER_PORT;\n+\n+/**\n+ * Test partition awareness of thin client on changed topology.\n+ */\n+public class ThinClientPartitionAwarenessDiscoveryTest extends ThinClientAbstractPartitionAwarenessTest {\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while new nodes start\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesJoin() throws Exception {\n+        for (int i = 0; i < MAX_CLUSTER_SIZE; ++i) {\n+            startGrid(i);\n+            awaitPartitionMapExchange();\n+\n+            int[] workChannels = IntStream.rangeClosed(0, i).toArray();\n+\n+            if (i == 0)\n+                initClient(getClientConfigurationWithDiscovery(), workChannels);\n+            else {\n+                detectTopologyChange();\n+                awaitChannelsInit(workChannels);\n+            }\n+\n+            testPartitionAwareness(workChannels);\n+        }\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while nodes stop\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesLeave() throws Exception {\n+        startGrids(MAX_CLUSTER_SIZE);\n+        awaitPartitionMapExchange();\n+\n+        initClient(getClientConfigurationWithDiscovery(), 0, 1, 2, 3);\n+        detectTopologyChange();\n+\n+        for (int i = MAX_CLUSTER_SIZE - 1; i != 0; i--) {\n+            int[] workChannels = IntStream.range(0, i).toArray();\n+\n+            channels[i] = null;\n+            stopGrid(i);\n+            awaitPartitionMapExchange();\n+            detectTopologyChange();\n+\n+            awaitChannelsInit(workChannels);\n+            testPartitionAwareness(workChannels);\n+        }\n+    }\n+\n+    /**\n+     * Checks that each request goes to right node.\n+     */\n+    private void testPartitionAwareness(int... chIdxs) {\n+        ClientCache<Object, Object> clientCache = client.cache(PART_CACHE_NAME);\n+        IgniteInternalCache<Object, Object> igniteCache = grid(0).context().cache().cache(PART_CACHE_NAME);\n+\n+        Map<TestTcpClientChannel, Boolean> channelHits = Arrays.stream(chIdxs).boxed()\n+            .collect(Collectors.toMap(idx -> channels[idx], idx -> false));\n+\n+        for (int i = 0; i < KEY_CNT; i++) {\n+            TestTcpClientChannel opCh = affinityChannel(i, igniteCache);\n+\n+            clientCache.put(i, i);\n+\n+            if (i == 0)\n+                assertOpOnChannel(dfltCh, ClientOperation.CACHE_PARTITIONS);\n+\n+            assertOpOnChannel(opCh, ClientOperation.CACHE_PUT);\n+            assertTrue(channelHits.containsKey(opCh));\n+\n+            channelHits.compute(opCh, (c, old) -> true);\n+        }\n+\n+        assertFalse(channelHits.containsValue(false));\n+    }\n+\n+    /**\n+     * Provide ClientConfiguration with addrResolver that find all alive nodes\n+     */\n+    private ClientConfiguration getClientConfigurationWithDiscovery() {\n+        ClientAddressFinder addrFinder = () ->\n+            IgnitionEx.allGrids().stream().map(node -> {\n+                int port = (Integer) node.cluster().localNode().attributes().get(CLIENT_LISTENER_PORT);\n+                return \"127.0.0.1:\" + port;\n+            }).toArray(String[]::new);\n+\n+        return new ClientConfiguration()\n+            .setAddressesFinder(addrFinder)\n+            .setPartitionAwarenessEnabled(true);\n+    }\n+\n+    /**\n+     * Trigger client to detect topology change\n+     */\n+    private void detectTopologyChange() {\n+        // Send non-affinity request to detect topology change.\n+        initDefaultChannel();\n+        client.getOrCreateCache(PART_CACHE_NAME);", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzNjU4OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r493536588", "bodyText": "It's not. I'm not sure why, but without additional request I don't detect topology change.", "author": "timoninmaxim", "createdAt": "2020-09-23T12:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNjg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2NjIyMg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r494266222", "bodyText": "Sorry, you're correct. Fixed.", "author": "timoninmaxim", "createdAt": "2020-09-24T12:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNjg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQyMTA3OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489421079", "bodyText": "All channels already inited after initClient, what else do we wait here?", "author": "alex-plekhanov", "createdAt": "2020-09-16T13:06:11Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ThinClientPartitionAwarenessDiscoveryTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.processors.cache.IgniteInternalCache;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.odbc.ClientListenerProcessor.CLIENT_LISTENER_PORT;\n+\n+/**\n+ * Test partition awareness of thin client on changed topology.\n+ */\n+public class ThinClientPartitionAwarenessDiscoveryTest extends ThinClientAbstractPartitionAwarenessTest {\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while new nodes start\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesJoin() throws Exception {\n+        for (int i = 0; i < MAX_CLUSTER_SIZE; ++i) {\n+            startGrid(i);\n+            awaitPartitionMapExchange();\n+\n+            int[] workChannels = IntStream.rangeClosed(0, i).toArray();\n+\n+            if (i == 0)\n+                initClient(getClientConfigurationWithDiscovery(), workChannels);\n+            else {\n+                detectTopologyChange();\n+                awaitChannelsInit(workChannels);\n+            }\n+\n+            testPartitionAwareness(workChannels);\n+        }\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while nodes stop\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesLeave() throws Exception {\n+        startGrids(MAX_CLUSTER_SIZE);\n+        awaitPartitionMapExchange();\n+\n+        initClient(getClientConfigurationWithDiscovery(), 0, 1, 2, 3);\n+        detectTopologyChange();\n+\n+        for (int i = MAX_CLUSTER_SIZE - 1; i != 0; i--) {\n+            int[] workChannels = IntStream.range(0, i).toArray();\n+\n+            channels[i] = null;\n+            stopGrid(i);\n+            awaitPartitionMapExchange();\n+            detectTopologyChange();\n+\n+            awaitChannelsInit(workChannels);", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1MDE1MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r494250150", "bodyText": "fixied", "author": "timoninmaxim", "createdAt": "2020-09-24T11:47:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQyMTA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQzNTI3MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r489435270", "bodyText": "We don't check discovery by this test at all. If we replace getClientConfigurationWithDiscovery() with getClientConfiguration(0, 1, 2, 3) result will be the same, test will pass. To check discovery I think we should exclude additional nodes by discovery (but not stop it) on topology change and check that this node is excluded from requests too.", "author": "alex-plekhanov", "createdAt": "2020-09-16T13:26:26Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ThinClientPartitionAwarenessDiscoveryTest.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientCache;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.IgnitionEx;\n+import org.apache.ignite.internal.processors.cache.IgniteInternalCache;\n+import org.junit.Test;\n+\n+import static org.apache.ignite.internal.processors.odbc.ClientListenerProcessor.CLIENT_LISTENER_PORT;\n+\n+/**\n+ * Test partition awareness of thin client on changed topology.\n+ */\n+public class ThinClientPartitionAwarenessDiscoveryTest extends ThinClientAbstractPartitionAwarenessTest {\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while new nodes start\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesJoin() throws Exception {\n+        for (int i = 0; i < MAX_CLUSTER_SIZE; ++i) {\n+            startGrid(i);\n+            awaitPartitionMapExchange();\n+\n+            int[] workChannels = IntStream.rangeClosed(0, i).toArray();\n+\n+            if (i == 0)\n+                initClient(getClientConfigurationWithDiscovery(), workChannels);\n+            else {\n+                detectTopologyChange();\n+                awaitChannelsInit(workChannels);\n+            }\n+\n+            testPartitionAwareness(workChannels);\n+        }\n+    }\n+\n+    /**\n+     * Test that client use channels to all running nodes while nodes stop\n+     */\n+    @Test\n+    public void testClientDiscoveryNodesLeave() throws Exception {", "originalCommit": "aea28f1ecc4d215a3cb73abd618deaa2f5ba462c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1MTcwNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r494251704", "bodyText": "Yes, it's ok that test will pass with default configuration too. It's like regression test, that discovery work expectedly. The case you describe will work the same way, it will pass both for default and discovery configurations, as both of them will configure the same set of channels. But it is a good test case and I've added it too.", "author": "timoninmaxim", "createdAt": "2020-09-24T11:50:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQzNTI3MA=="}], "type": "inlineReview"}, {"oid": "cbd0dde6d960b7bf83cddc7e0d49c50060c58088", "url": "https://github.com/apache/ignite/commit/cbd0dde6d960b7bf83cddc7e0d49c50060c58088", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-24T11:49:10Z", "type": "commit"}, {"oid": "cbd0dde6d960b7bf83cddc7e0d49c50060c58088", "url": "https://github.com/apache/ignite/commit/cbd0dde6d960b7bf83cddc7e0d49c50060c58088", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-24T11:49:10Z", "type": "forcePushed"}, {"oid": "99a519dd2334866f6e6a8ff66b6374b1fd1a98bf", "url": "https://github.com/apache/ignite/commit/99a519dd2334866f6e6a8ff66b6374b1fd1a98bf", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-24T12:16:48Z", "type": "commit"}, {"oid": "f0387c935faa3773db2b8ea5ee170365fdad7034", "url": "https://github.com/apache/ignite/commit/f0387c935faa3773db2b8ea5ee170365fdad7034", "message": "fixup! IGNITE-13204 Thin client kubernetes auto discovery", "committedDate": "2020-09-25T12:54:37Z", "type": "commit"}, {"oid": "beebf80c37118bf90630375abb566aa540d53033", "url": "https://github.com/apache/ignite/commit/beebf80c37118bf90630375abb566aa540d53033", "message": "Merge branch 'master' into IGNITE-13204_kubernetes_thin_client", "committedDate": "2020-09-30T10:08:06Z", "type": "forcePushed"}, {"oid": "55f56c10c3210168db7f6d1cf4e6ec567954f74e", "url": "https://github.com/apache/ignite/commit/55f56c10c3210168db7f6d1cf4e6ec567954f74e", "message": "Merge branch 'master' into IGNITE-13204_kubernetes_thin_client", "committedDate": "2020-09-30T12:59:03Z", "type": "commit"}, {"oid": "55f56c10c3210168db7f6d1cf4e6ec567954f74e", "url": "https://github.com/apache/ignite/commit/55f56c10c3210168db7f6d1cf4e6ec567954f74e", "message": "Merge branch 'master' into IGNITE-13204_kubernetes_thin_client", "committedDate": "2020-09-30T12:59:03Z", "type": "forcePushed"}, {"oid": "7a32fe73a33412dfe3f9bbd06aff3486a2961293", "url": "https://github.com/apache/ignite/commit/7a32fe73a33412dfe3f9bbd06aff3486a2961293", "message": "Fix codestyle", "committedDate": "2020-09-30T14:05:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE3MzM2OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r500173369", "bodyText": "Here and below please use multiline javadoc for methods as we do everywhere else.", "author": "ptupitsyn", "createdAt": "2020-10-06T10:36:29Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/client/thin/ReliableChannelTest.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.client.thin;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.ignite.client.ClientAddressFinder;\n+import org.apache.ignite.client.ClientAuthorizationException;\n+import org.apache.ignite.client.ClientConnectionException;\n+import org.apache.ignite.client.ClientException;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.apache.ignite.internal.util.typedef.F;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Class test ReliableChannel channels re-initialization.\n+ */\n+public class ReliableChannelTest {\n+    /** Mock factory for creating new channels. */\n+    private final Function<ClientChannelConfiguration, ClientChannel> chFactory = cfg -> new TestClientChannel();\n+\n+    /** */\n+    private final String[] dfltAddrs = new String[]{\"127.0.0.1:10800\", \"127.0.0.1:10801\", \"127.0.0.1:10802\"};\n+\n+    /** Checks that it is possible configure addresses with duplication (for load balancing). */", "originalCommit": "7a32fe73a33412dfe3f9bbd06aff3486a2961293", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNjE4OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r501126189", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-10-07T15:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE3MzM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE3ODUwNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r500178504", "bodyText": "Please provide details:\n\nWhen and how often Ignite will call the implementation\nWhat are the requirements:\n\nDuplicates allowed or not\nAllowed formats (with port, without port, ipv4/ipv6?)", "author": "ptupitsyn", "createdAt": "2020-10-06T10:46:41Z", "path": "modules/core/src/main/java/org/apache/ignite/client/ClientAddressFinder.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+/**\n+ * This interface provides a list of addresses of Ignite server nodes within a cluster. Thin client uses the list to", "originalCommit": "7a32fe73a33412dfe3f9bbd06aff3486a2961293", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNjA5MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r501126090", "bodyText": "Fixed. Also change javadoc for ClientConfiguration.setAddresses.", "author": "timoninmaxim", "createdAt": "2020-10-07T15:55:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE3ODUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5MTQ3NQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r500191475", "bodyText": "Let's rename to getAddresses for consistency with ClientConfiguration.", "author": "ptupitsyn", "createdAt": "2020-10-06T11:10:50Z", "path": "modules/core/src/main/java/org/apache/ignite/client/ClientAddressFinder.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+/**\n+ * This interface provides a list of addresses of Ignite server nodes within a cluster. Thin client uses the list to\n+ * route user requests. There are cases when the list is not static, for example in cloud environment. In such cases\n+ * addresses of nodes and/or number of server nodes can change. Implementation of this interface should handle these.\n+ *\n+ * {@link org.apache.ignite.configuration.ClientConfiguration#setAddressesFinder(ClientAddressFinder)}\n+ */\n+public interface ClientAddressFinder {\n+    /** @return Addresses of Ignite server nodes within a cluster. */\n+    public String[] getServerAddresses();", "originalCommit": "7a32fe73a33412dfe3f9bbd06aff3486a2961293", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEyNTQ5MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r501125491", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-10-07T15:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE5MTQ3NQ=="}], "type": "inlineReview"}, {"oid": "73adfc562bc2aa050b11228a7c1c10365edc1732", "url": "https://github.com/apache/ignite/commit/73adfc562bc2aa050b11228a7c1c10365edc1732", "message": "Provide more javadocs.", "committedDate": "2020-10-07T15:54:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwODE1Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r501208152", "bodyText": "waites -> waits", "author": "ptupitsyn", "createdAt": "2020-10-07T18:03:19Z", "path": "modules/core/src/main/java/org/apache/ignite/client/ClientAddressFinder.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+/**\n+ * This interface provides a list of addresses of Ignite server nodes within a cluster. Thin client uses the list to\n+ * route user requests. There are cases when the list is not static, for example in cloud environment. In such cases\n+ * addresses of nodes and/or number of server nodes can change. Implementation of this interface should handle these.\n+ *\n+ * Ignite waites for a topology change to trigger {@link #getAddresses()}. There are two modes of how soon Ignite calls", "originalCommit": "73adfc562bc2aa050b11228a7c1c10365edc1732", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1MDEzNQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r501250135", "bodyText": "Fixed.", "author": "timoninmaxim", "createdAt": "2020-10-07T19:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIwODE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxNzExOA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r501217118", "bodyText": "I thought we support IPv6? Is there any reason not to?", "author": "ptupitsyn", "createdAt": "2020-10-07T18:18:01Z", "path": "modules/core/src/main/java/org/apache/ignite/client/ClientAddressFinder.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+/**\n+ * This interface provides a list of addresses of Ignite server nodes within a cluster. Thin client uses the list to\n+ * route user requests. There are cases when the list is not static, for example in cloud environment. In such cases\n+ * addresses of nodes and/or number of server nodes can change. Implementation of this interface should handle these.\n+ *\n+ * Ignite waites for a topology change to trigger {@link #getAddresses()}. There are two modes of how soon Ignite calls\n+ * it, lazy and eager, depending on whether the partition awareness feature is enabled. If the feature is enabled then\n+ * Ignite calls the method for every topology change. Otherwise Ignite uses previous addresses until a first failure.\n+ *\n+ * {@link org.apache.ignite.configuration.ClientConfiguration#setPartitionAwarenessEnabled(boolean)}\n+ * {@link org.apache.ignite.configuration.ClientConfiguration#setAddressesFinder(ClientAddressFinder)}\n+ */\n+public interface ClientAddressFinder {\n+    /**\n+     * Get addresses of Ignite server nodes within a cluster. An address can be IPv4 address or hostname, with or", "originalCommit": "73adfc562bc2aa050b11228a7c1c10365edc1732", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI0NDE4MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r501244181", "bodyText": "ReliableChannel#parsedAddresses -> HostAndPortRange#parse split address by colon and consider left part as hostname and right part as port.\nI don't know is there other reasons do not use IPv6, need test for that. I suppose it should be a separate activity.", "author": "timoninmaxim", "createdAt": "2020-10-07T19:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxNzExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI0NjI0OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r501246249", "bodyText": "Agree, I've created a ticket https://issues.apache.org/jira/browse/IGNITE-13555", "author": "ptupitsyn", "createdAt": "2020-10-07T19:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxNzExOA=="}], "type": "inlineReview"}, {"oid": "4b060384d7d73247f005cab769c3579ad0a14dc2", "url": "https://github.com/apache/ignite/commit/4b060384d7d73247f005cab769c3579ad0a14dc2", "message": "Fix misprint", "committedDate": "2020-10-07T19:13:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MjgyOQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504452829", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T07:16:10Z", "path": "modules/core/src/main/java/org/apache/ignite/configuration/ClientConfiguration.java", "diffHunk": "@@ -118,21 +123,47 @@\n     /** Reconnect throttling retries. See {@code reconnectThrottlingPeriod}. */\n     private int reconnectThrottlingRetries = 3;\n \n+    /** Retry limit. */\n+    private int retryLimit = 0;\n+\n     /** Executor for async operations continuations. */\n     private Executor asyncContinuationExecutor;\n \n     /**\n      * @return Host addresses.\n      */\n     public String[] getAddresses() {\n-        return addrs;\n+        if (addrs != null)\n+            return Arrays.copyOf(addrs, addrs.length);", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzIwOQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504453209", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T07:16:58Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY3MDUxOA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504670518", "bodyText": "What if failure already not null here? We will lose this information?", "author": "alex-plekhanov", "createdAt": "2020-10-14T13:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTI1NTA4OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r505255089", "bodyText": "fixed", "author": "timoninmaxim", "createdAt": "2020-10-15T07:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzI2Nw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504453267", "bodyText": "Redundant NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T07:17:06Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzU4Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504453582", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T07:17:42Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);\n+            return;\n         }\n \n-        if (err instanceof ClientConnectionException) {\n-            onChannelFailure(ch);\n+        ClientChannel ch = chAndAttempts.getKey();\n \n-            if (failure == null)\n-                failure = (ClientConnectionException) err;\n-            else\n-                failure.addSuppressed(err);\n+        ch\n+            .serviceAsync(op, payloadWriter, payloadReader)\n+            .handle((res, err) -> {\n+                if (err == null) {\n+                    fut.complete(res);", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc1OTc2Mg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504759762", "bodyText": "Maybe you mean \"Redundant NL\"? Will fIx it this way", "author": "timoninmaxim", "createdAt": "2020-10-14T15:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc2MDY2Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504760666", "bodyText": "Ah, I see in next comments. There is already NL, will not change it.", "author": "timoninmaxim", "createdAt": "2020-10-14T15:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc2OTcyNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504769724", "bodyText": "No, I mean missing empty line between fut.complete(res); and onChannelFailure(ch);", "author": "alex-plekhanov", "createdAt": "2020-10-14T15:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkxMjg5NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504912894", "bodyText": "Sorry, I don't see this case.", "author": "timoninmaxim", "createdAt": "2020-10-14T19:15:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1MzY3OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504453679", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T07:17:51Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);\n+            return;\n         }\n \n-        if (err instanceof ClientConnectionException) {\n-            onChannelFailure(ch);\n+        ClientChannel ch = chAndAttempts.getKey();\n \n-            if (failure == null)\n-                failure = (ClientConnectionException) err;\n-            else\n-                failure.addSuppressed(err);\n+        ch\n+            .serviceAsync(op, payloadWriter, payloadReader)\n+            .handle((res, err) -> {\n+                if (err == null) {\n+                    fut.complete(res);\n \n-            if (chIdx == null)\n-                chIdx = new AtomicInteger();\n+                    return null;\n+                }\n \n-            while (chIdx.incrementAndGet() < channels.length) {\n-                try {\n-                    ch = channel();\n+                ClientConnectionException failure0 = failure;\n+\n+                if (err instanceof ClientConnectionException) {\n+                    try {\n+                        // Will try to reinit channels if topology changed.\n+                        onChannelFailure(ch);\n+                    }\n+                    catch (Throwable ex) {\n+                        fut.completeExceptionally(ex);", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1Mzk1Nw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504453957", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T07:18:21Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);\n+            return;\n         }\n \n-        if (err instanceof ClientConnectionException) {\n-            onChannelFailure(ch);\n+        ClientChannel ch = chAndAttempts.getKey();\n \n-            if (failure == null)\n-                failure = (ClientConnectionException) err;\n-            else\n-                failure.addSuppressed(err);\n+        ch\n+            .serviceAsync(op, payloadWriter, payloadReader)\n+            .handle((res, err) -> {\n+                if (err == null) {\n+                    fut.complete(res);\n \n-            if (chIdx == null)\n-                chIdx = new AtomicInteger();\n+                    return null;\n+                }\n \n-            while (chIdx.incrementAndGet() < channels.length) {\n-                try {\n-                    ch = channel();\n+                ClientConnectionException failure0 = failure;\n+\n+                if (err instanceof ClientConnectionException) {\n+                    try {\n+                        // Will try to reinit channels if topology changed.\n+                        onChannelFailure(ch);\n+                    }\n+                    catch (Throwable ex) {\n+                        fut.completeExceptionally(ex);\n+                        return null;\n+                    }\n \n-                    ClientConnectionException failure0 = failure;\n-                    AtomicInteger chIdx0 = chIdx;\n-                    ClientChannel ch0 = ch;\n+                    if (failure0 == null)\n+                        failure0 = (ClientConnectionException)err;\n+                    else\n+                        failure0.addSuppressed(err);\n \n-                    ch.serviceAsync(op, payloadWriter, payloadReader).handle((res2, err2) ->\n-                            handleServiceAsync(op, payloadWriter, payloadReader, fut, failure0, chIdx0, ch0, res2, err2));\n+                    int leftAttempts = attemptsLimit - chAndAttempts.getValue();\n \n+                    // If it is a first retry then reset attempts (as for initialization we use only 1 attempt).\n+                    if (failure == null)\n+                        leftAttempts = getRetryLimit() - 1;\n+\n+                    if (leftAttempts > 0) {\n+                        handleServiceAsync(fut, op, payloadWriter, payloadReader, leftAttempts, failure0);", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1NDAyMQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504454021", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T07:18:30Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);\n+            return;\n         }\n \n-        if (err instanceof ClientConnectionException) {\n-            onChannelFailure(ch);\n+        ClientChannel ch = chAndAttempts.getKey();\n \n-            if (failure == null)\n-                failure = (ClientConnectionException) err;\n-            else\n-                failure.addSuppressed(err);\n+        ch\n+            .serviceAsync(op, payloadWriter, payloadReader)\n+            .handle((res, err) -> {\n+                if (err == null) {\n+                    fut.complete(res);\n \n-            if (chIdx == null)\n-                chIdx = new AtomicInteger();\n+                    return null;\n+                }\n \n-            while (chIdx.incrementAndGet() < channels.length) {\n-                try {\n-                    ch = channel();\n+                ClientConnectionException failure0 = failure;\n+\n+                if (err instanceof ClientConnectionException) {\n+                    try {\n+                        // Will try to reinit channels if topology changed.\n+                        onChannelFailure(ch);\n+                    }\n+                    catch (Throwable ex) {\n+                        fut.completeExceptionally(ex);\n+                        return null;\n+                    }\n \n-                    ClientConnectionException failure0 = failure;\n-                    AtomicInteger chIdx0 = chIdx;\n-                    ClientChannel ch0 = ch;\n+                    if (failure0 == null)\n+                        failure0 = (ClientConnectionException)err;\n+                    else\n+                        failure0.addSuppressed(err);\n \n-                    ch.serviceAsync(op, payloadWriter, payloadReader).handle((res2, err2) ->\n-                            handleServiceAsync(op, payloadWriter, payloadReader, fut, failure0, chIdx0, ch0, res2, err2));\n+                    int leftAttempts = attemptsLimit - chAndAttempts.getValue();\n \n+                    // If it is a first retry then reset attempts (as for initialization we use only 1 attempt).\n+                    if (failure == null)\n+                        leftAttempts = getRetryLimit() - 1;\n+\n+                    if (leftAttempts > 0) {\n+                        handleServiceAsync(fut, op, payloadWriter, payloadReader, leftAttempts, failure0);\n+                        return null;\n+                    }\n+                }\n+                else {\n+                    fut.completeExceptionally(err instanceof ClientException ? err : new ClientException(err));", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ1NDA5NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504454094", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T07:18:39Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n+\n+        } catch (Throwable ex) {\n+            fut.completeExceptionally(ex);\n+            return;\n         }\n \n-        if (err instanceof ClientConnectionException) {\n-            onChannelFailure(ch);\n+        ClientChannel ch = chAndAttempts.getKey();\n \n-            if (failure == null)\n-                failure = (ClientConnectionException) err;\n-            else\n-                failure.addSuppressed(err);\n+        ch\n+            .serviceAsync(op, payloadWriter, payloadReader)\n+            .handle((res, err) -> {\n+                if (err == null) {\n+                    fut.complete(res);\n \n-            if (chIdx == null)\n-                chIdx = new AtomicInteger();\n+                    return null;\n+                }\n \n-            while (chIdx.incrementAndGet() < channels.length) {\n-                try {\n-                    ch = channel();\n+                ClientConnectionException failure0 = failure;\n+\n+                if (err instanceof ClientConnectionException) {\n+                    try {\n+                        // Will try to reinit channels if topology changed.\n+                        onChannelFailure(ch);\n+                    }\n+                    catch (Throwable ex) {\n+                        fut.completeExceptionally(ex);\n+                        return null;\n+                    }\n \n-                    ClientConnectionException failure0 = failure;\n-                    AtomicInteger chIdx0 = chIdx;\n-                    ClientChannel ch0 = ch;\n+                    if (failure0 == null)\n+                        failure0 = (ClientConnectionException)err;\n+                    else\n+                        failure0.addSuppressed(err);\n \n-                    ch.serviceAsync(op, payloadWriter, payloadReader).handle((res2, err2) ->\n-                            handleServiceAsync(op, payloadWriter, payloadReader, fut, failure0, chIdx0, ch0, res2, err2));\n+                    int leftAttempts = attemptsLimit - chAndAttempts.getValue();\n \n+                    // If it is a first retry then reset attempts (as for initialization we use only 1 attempt).\n+                    if (failure == null)\n+                        leftAttempts = getRetryLimit() - 1;\n+\n+                    if (leftAttempts > 0) {\n+                        handleServiceAsync(fut, op, payloadWriter, payloadReader, leftAttempts, failure0);\n+                        return null;\n+                    }\n+                }\n+                else {\n+                    fut.completeExceptionally(err instanceof ClientException ? err : new ClientException(err));\n                     return null;\n-                } catch (ClientConnectionException e) {\n-                    onChannelFailure(ch);\n-                    failure.addSuppressed(e);\n                 }\n-            }\n-        }\n \n-        if (failure != null)\n-            fut.completeExceptionally(failure);\n-        else\n-            fut.completeExceptionally(err instanceof ClientException ? err : new ClientException(err));\n-\n-        return null;\n+                fut.completeExceptionally(failure0);", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5MDE4NQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504490185", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T08:20:21Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5MDI2Ng==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504490266", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T08:20:29Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5MDQ4NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504490484", "bodyText": "Redundant NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T08:20:52Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();\n+        return true;\n+    }\n+\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void channelsInit(boolean force) {\n+        if (!force && channels != null)\n+            return;\n+\n+        // Do not establish connections if interrupted.\n+        if (!initChannelHolders(force))\n+            return;\n+\n+        // Apply no-op function. Establish default channel connection.\n+        applyOnDefaultChannel(channel -> null);\n+\n+        if (partitionAwarenessEnabled)\n+            initAllChannelsAsync();\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on a channel corresponding to specified {@code nodeId}.\n+     */\n+    private <T> T applyOnNodeChannel(UUID nodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = null;\n+        ClientChannel channel = null;\n+\n+        try {\n+            hld = nodeChannels.get(nodeId);\n+\n+            channel = hld != null ? hld.getOrCreateChannel() : null;\n+\n+            if (channel != null)\n+                return function.apply(channel);\n+", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDQ5MDkxMw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504490913", "bodyText": "point at the end", "author": "alex-plekhanov", "createdAt": "2020-10-14T08:21:35Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();\n+        return true;\n+    }\n+\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void channelsInit(boolean force) {\n+        if (!force && channels != null)\n+            return;\n+\n+        // Do not establish connections if interrupted.\n+        if (!initChannelHolders(force))\n+            return;\n+\n+        // Apply no-op function. Establish default channel connection.\n+        applyOnDefaultChannel(channel -> null);\n+\n+        if (partitionAwarenessEnabled)\n+            initAllChannelsAsync();\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on a channel corresponding to specified {@code nodeId}.\n+     */\n+    private <T> T applyOnNodeChannel(UUID nodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = null;\n+        ClientChannel channel = null;\n+\n+        try {\n+            hld = nodeChannels.get(nodeId);\n+\n+            channel = hld != null ? hld.getOrCreateChannel() : null;\n+\n+            if (channel != null)\n+                return function.apply(channel);\n+\n+        } catch (ClientConnectionException e) {\n+            onChannelFailure(hld, channel);\n+        }\n+\n+        return null;\n+    }\n+\n+    /** */\n+    private <T> T applyOnDefaultChannel(Function<ClientChannel, T> function) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (holders == null)\n+            throw new ClientException(\"Connections to nodes aren't initialized.\");\n+\n+        int size = holders.size();\n+\n+        int attemptsLimit = clientCfg.getRetryLimit() > 0 ?\n+            Math.min(clientCfg.getRetryLimit(), size) : size;\n+\n+        return applyOnDefaultChannel(function, attemptsLimit).getKey();\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on any of available channel.\n+     */\n+    private <T> T2<T, Integer> applyOnDefaultChannel(Function<ClientChannel, T> function, int attemptsLimit) {\n+        ClientConnectionException failure = null;\n+\n+        for (int attempt = 0; attempt < attemptsLimit; attempt++) {\n+            ClientChannelHolder hld = null;\n+            ClientChannel c = null;\n+\n+            try {\n+                if (closed)\n+                    throw new ClientException(\"Channel is closed\");\n+\n+                curChannelsGuard.readLock().lock();\n+\n+                try {\n+                    hld = channels.get(curChIdx);\n+                } finally {\n+                    curChannelsGuard.readLock().unlock();\n+                }\n+\n+                c = hld.getOrCreateChannel();\n+\n+                if (c != null)\n+                    return new T2<>(function.apply(c), attempt + 1);\n+            }\n+            catch (ClientConnectionException e) {\n+                if (failure == null)\n+                    failure = e;\n+                else\n+                    failure.addSuppressed(e);\n+\n+                onChannelFailure(hld, c);\n+            }\n+        }\n+\n+        throw failure;\n+    }\n+\n+    /**\n+     * Try apply specified {@code function} on a channel corresponding to {@code tryNodeId}.\n+     * If failed then apply the function on any available channel.\n+     */\n+    private <T> T applyOnNodeChannelWithFallback(UUID tryNodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = nodeChannels.get(tryNodeId);\n+\n+        int retryLimit = getRetryLimit();\n+\n+        if (hld != null) {\n+            ClientChannel channel = null;\n+\n+            try {\n+                channel = hld.getOrCreateChannel();\n+\n+                if (channel != null)\n+                    return function.apply(channel);\n+\n+            } catch (ClientConnectionException e) {\n+                onChannelFailure(hld, channel);\n+\n+                retryLimit -= 1;\n+\n+                if (retryLimit == 0)\n+                    throw e;\n+            }\n+        }\n+\n+        return applyOnDefaultChannel(function, retryLimit).getKey();\n+    }\n+\n+    /** Get retry limit. */\n+    private int getRetryLimit() {\n+        int size = channels.size();\n+\n+        return clientCfg.getRetryLimit() > 0 ? Math.min(clientCfg.getRetryLimit(), size) : size;\n+    }\n+\n     /**\n      * Channels holder.\n      */\n-    private class ClientChannelHolder {\n+    class ClientChannelHolder {\n         /** Channel configuration. */\n         private final ClientChannelConfiguration chCfg;\n \n         /** Channel. */\n         private volatile ClientChannel ch;\n \n+        /** ID of the last server node that {@link ch} is or was connected to. */\n+        private volatile UUID serverNodeId;\n+\n+        /** Address that holder is bind to (chCfg.addr) is not in use now. So close the holder */", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDUzNzg2MQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504537861", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T09:33:41Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -512,80 +504,81 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n         return ranges.stream()\n             .flatMap(r -> IntStream\n                 .rangeClosed(r.portFrom(), r.portTo()).boxed()\n-                .map(p -> new InetSocketAddress(r.host(), p))\n+                .map(p -> InetSocketAddress.createUnresolved(r.host(), p))\n             )\n-            .collect(Collectors.toList());\n+            .collect(Collectors.toMap(a -> a, a -> 1, Integer::sum));\n     }\n \n-    /** */\n-    private synchronized ClientChannel channel() {\n-        if (closed)\n-            throw new ClientException(\"Channel is closed\");\n-\n+    /**\n+     * Roll current default channel if specified holder equals to it.\n+     */\n+    private void rollCurrentChannel(ClientChannelHolder hld) {\n+        curChannelsGuard.writeLock().lock();", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY3MTk3Nw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504671977", "bodyText": "I think it's better to control attempts count in one method. I propose to rewrite this method without using applyOnDefaultChannel and rewrite applyOnDefaultChannel to return only result but not T2 with attempts counter (help GC a little bit).\nWDYT?", "author": "alex-plekhanov", "createdAt": "2020-10-14T13:22:09Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -223,67 +203,78 @@\n     ) throws ClientException, ClientError {\n         CompletableFuture<T> fut = new CompletableFuture<>();\n \n-        ClientChannel ch = channel();\n-\n-        ch.serviceAsync(op, payloadWriter, payloadReader).handle((res, err) ->\n-                handleServiceAsync(op, payloadWriter, payloadReader, fut, null, null, ch, res, err));\n+        // Use the only one attempt to avoid blocking async method.\n+        handleServiceAsync(fut, op, payloadWriter, payloadReader, 1, null);\n \n         return new IgniteClientFutureImpl<>(fut);\n     }\n \n     /**\n      * Handles serviceAsync results and retries as needed.\n      */\n-    private <T> Object handleServiceAsync(ClientOperation op,\n-                                          Consumer<PayloadOutputChannel> payloadWriter,\n-                                          Function<PayloadInputChannel, T> payloadReader,\n-                                          CompletableFuture<T> fut,\n-                                          ClientConnectionException failure,\n-                                          AtomicInteger chIdx,\n-                                          ClientChannel ch,\n-                                          T res,\n-                                          Throwable err) {\n-        if (err == null) {\n-            fut.complete(res);\n-            return null;\n+    private <T> void handleServiceAsync(final CompletableFuture<T> fut,\n+                                        ClientOperation op,\n+                                        Consumer<PayloadOutputChannel> payloadWriter,\n+                                        Function<PayloadInputChannel, T> payloadReader,\n+                                        int attemptsLimit,\n+                                        ClientConnectionException failure) {\n+        T2<ClientChannel, Integer> chAndAttempts;\n+\n+        try {\n+            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc3NDU2OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504774568", "bodyText": "Currently master branch do work approach you describe, and it leads to:\n\nintroducing additional AtomicInteger variable for attempts counter. Counter is required as it used in separate threads execute handleServiceAsync method;\ncode duplication for iterating through channels (for sync and async methods).\n\nThis is reasons to use T2. It's not pretty, but the alternative doesn't looks better, I think.", "author": "timoninmaxim", "createdAt": "2020-10-14T15:32:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY3MTk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzMzM5NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504833394", "bodyText": "You already get rid of AtomicInteger, and it's not required here anymore. Yes, there will be a little code duplication for iterating through channels, I think it's ok since it will make code more readable.", "author": "alex-plekhanov", "createdAt": "2020-10-14T16:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY3MTk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk2NjIzMw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504966233", "bodyText": "I tried rewrite this code, but it only becomes more complicated (lambdas starts to complain about non-final scope, etc.). So, I suggest another approach with introducing a callback to store attempts counter in an external value (push commit). WDYT?", "author": "timoninmaxim", "createdAt": "2020-10-14T20:54:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY3MTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDY3NDE4OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504674188", "bodyText": "Can be replaced with getRetryLimit()", "author": "alex-plekhanov", "createdAt": "2020-10-14T13:25:15Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();\n+        return true;\n+    }\n+\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void channelsInit(boolean force) {\n+        if (!force && channels != null)\n+            return;\n+\n+        // Do not establish connections if interrupted.\n+        if (!initChannelHolders(force))\n+            return;\n+\n+        // Apply no-op function. Establish default channel connection.\n+        applyOnDefaultChannel(channel -> null);\n+\n+        if (partitionAwarenessEnabled)\n+            initAllChannelsAsync();\n+    }\n+\n+    /**\n+     * Apply specified {@code function} on a channel corresponding to specified {@code nodeId}.\n+     */\n+    private <T> T applyOnNodeChannel(UUID nodeId, Function<ClientChannel, T> function) {\n+        ClientChannelHolder hld = null;\n+        ClientChannel channel = null;\n+\n+        try {\n+            hld = nodeChannels.get(nodeId);\n+\n+            channel = hld != null ? hld.getOrCreateChannel() : null;\n+\n+            if (channel != null)\n+                return function.apply(channel);\n+\n+        } catch (ClientConnectionException e) {\n+            onChannelFailure(hld, channel);\n+        }\n+\n+        return null;\n+    }\n+\n+    /** */\n+    private <T> T applyOnDefaultChannel(Function<ClientChannel, T> function) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (holders == null)\n+            throw new ClientException(\"Connections to nodes aren't initialized.\");\n+\n+        int size = holders.size();\n+\n+        int attemptsLimit = clientCfg.getRetryLimit() > 0 ?\n+            Math.min(clientCfg.getRetryLimit(), size) : size;", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyMzUyNQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504723525", "bodyText": "Why do we skip rollCurrentChannel if scheduledChannelsReinit? I think we should roll channel in any case.", "author": "alex-plekhanov", "createdAt": "2020-10-14T14:28:10Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -512,80 +504,81 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n         return ranges.stream()\n             .flatMap(r -> IntStream\n                 .rangeClosed(r.portFrom(), r.portTo()).boxed()\n-                .map(p -> new InetSocketAddress(r.host(), p))\n+                .map(p -> InetSocketAddress.createUnresolved(r.host(), p))\n             )\n-            .collect(Collectors.toList());\n+            .collect(Collectors.toMap(a -> a, a -> 1, Integer::sum));\n     }\n \n-    /** */\n-    private synchronized ClientChannel channel() {\n-        if (closed)\n-            throw new ClientException(\"Channel is closed\");\n-\n+    /**\n+     * Roll current default channel if specified holder equals to it.\n+     */\n+    private void rollCurrentChannel(ClientChannelHolder hld) {\n+        curChannelsGuard.writeLock().lock();\n         try {\n-            return channels[curChIdx].getOrCreateChannel();\n-        }\n-        catch (ClientConnectionException e) {\n-            rollCurrentChannel();\n+            int idx = curChIdx;\n+            List<ClientChannelHolder> holders = channels;\n \n-            throw e;\n-        }\n-    }\n+            ClientChannelHolder dfltHld = holders.get(idx);\n \n-    /** */\n-    private synchronized void rollCurrentChannel() {\n-        if (++curChIdx >= channels.length)\n-            curChIdx = 0;\n+            if (dfltHld == hld) {\n+                idx += 1;\n+\n+                if (idx >= holders.size())\n+                    curChIdx = 0;\n+                else\n+                    curChIdx = idx;\n+            }\n+        } finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n     }\n \n     /**\n      * On current channel failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannel ch) {\n+    private void onChannelFailure(ClientChannel ch) {\n         // There is nothing wrong if curChIdx was concurrently changed, since channel was closed by another thread\n         // when current index was changed and no other wrong channel will be closed by current thread because\n         // onChannelFailure checks channel binded to the holder before closing it.\n-        onChannelFailure(channels[curChIdx], ch);\n-\n-        chFailLsnrs.forEach(Runnable::run);\n+        onChannelFailure(channels.get(curChIdx), ch);\n     }\n \n     /**\n      * On channel of the specified holder failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n-        if (ch == hld.ch && ch != null) {\n+    private void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n+        if (ch != null && ch == hld.ch)\n             hld.closeChannel();\n \n-            if (hld == channels[curChIdx])\n-                rollCurrentChannel();\n-        }\n+        chFailLsnrs.forEach(Runnable::run);\n+\n+        if (scheduledChannelsReinit.get())\n+            channelsInit(true);\n+        else\n+            rollCurrentChannel(hld);", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc3OTkxMw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504779913", "bodyText": "if channel fails and there is scheduled reinit, there are chances that reinitialization will fix the issue (reinitialization may assign new default channel).", "author": "timoninmaxim", "createdAt": "2020-10-14T15:39:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyMzUyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyNjI3OA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504826278", "bodyText": "There are chances if some dynamic address finder is used, but by default, you just check current address twice and skip one channel. In both cases (dynamic and static address finder) there is nothing bad happens if we roll current channel", "author": "alex-plekhanov", "createdAt": "2020-10-14T16:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyMzUyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgyODcxNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504828714", "bodyText": "Also, if new default channel is assigned by channelsInit(), than rollCurrentChannel(hld) will do no-op, since hld already not a default channel.", "author": "alex-plekhanov", "createdAt": "2020-10-14T16:52:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyMzUyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNDk1NA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504924954", "bodyText": "Actually there is an invokation sequence for default case: channelsInit -> applyOnDefaultChannel to establish connection with default channel (that checks that connection is OK). So rolling is not required too. Also rolling at least acquires lock so it is not free.\nSo, there is a matrix of cases for channel failure:\n\nFixed addreses, topology changes -> Channel is rolled with channelsInit -> applyOnDefaultChannel;\nFixed addresses, topology does not change -> rollCurrentChannel;\nDynamic address, topology changes -> channels are reinited twice, rolls with applyOnDefaultChannel;\nDynamic address, topology does not change -> rollCurrentChannel.\n\nSo, there is an issue with double initialization for dynamic addresses only. I will fix it by skipping second initialization as describe in other comment.", "author": "timoninmaxim", "createdAt": "2020-10-14T19:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyMzUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyNjU2Nw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504726567", "bodyText": "Currently, flag force is useless (at least for production code, but perhaps for test code too). There are 3 calls of this method from production code, first - right after constructor (when channels == null), two other calls with force == true.", "author": "alex-plekhanov", "createdAt": "2020-10-14T14:31:50Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();\n+            return true;\n+        }\n+\n+        Map<InetSocketAddress, ClientChannelHolder> curAddrs = new HashMap<>();\n+        Set<InetSocketAddress> allAddrs = new HashSet<>(newAddrs.keySet());\n+\n+        if (holders != null) {\n+            for (int i = 0; i < holders.size(); i++) {\n+                ClientChannelHolder h = holders.get(i);\n+\n+                curAddrs.put(h.chCfg.getAddress(), h);\n+                allAddrs.add(h.chCfg.getAddress());\n+            }\n+        }\n+\n+        List<ClientChannelHolder> reinitHolders = new ArrayList<>();\n+\n+        // The variable holds a new index of default channel after topology change.\n+        // Suppose that reuse of the channel is better than open new connection.\n+        int dfltChannelIdx = -1;\n+\n+        ClientChannelHolder currDfltHolder = null;\n+\n+        int idx = curChIdx;\n+\n+        if (idx != -1)\n+            currDfltHolder = holders.get(idx);\n+\n+        for (InetSocketAddress addr : allAddrs) {\n+            if (shouldStopChannelsReinit())\n+                return false;\n+\n+            // Obsolete addr, to be removed.\n+            if (!newAddrs.containsKey(addr)) {\n+                curAddrs.get(addr).close();\n+\n+                continue;\n+            }\n+\n+            // Create new holders for new addrs.\n+            if (!curAddrs.containsKey(addr)) {\n+                ClientChannelHolder hld = new ClientChannelHolder(new ClientChannelConfiguration(clientCfg, addr));\n+\n+                for (int i = 0; i < newAddrs.get(addr); i++)\n+                    reinitHolders.add(hld);\n+\n+                continue;\n+            }\n+\n+            // This holder is up to date.\n+            ClientChannelHolder hld = curAddrs.get(addr);\n+\n+            for (int i = 0; i < newAddrs.get(addr); i++)\n+                reinitHolders.add(hld);\n+\n+            if (hld == currDfltHolder)\n+                dfltChannelIdx = reinitHolders.size() - 1;\n+        }\n+\n+        if (dfltChannelIdx == -1)\n+            dfltChannelIdx = new Random().nextInt(reinitHolders.size());\n+\n+        curChannelsGuard.writeLock().lock();\n+        try {\n+            channels = reinitHolders;\n+            curChIdx = dfltChannelIdx;\n+        }\n+        finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n+\n+        finishChannelsReInit = System.currentTimeMillis();\n+        return true;\n+    }\n+\n+    /**\n+     * Establishing connections to servers. If partition awareness feature is enabled connections are created\n+     * for every configured server. Otherwise only default channel is connected.\n+     */\n+    void channelsInit(boolean force) {\n+        if (!force && channels != null)", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTI1NTUwOA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r505255508", "bodyText": "fixed", "author": "timoninmaxim", "createdAt": "2020-10-15T07:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyNjU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDcyODEyNg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504728126", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-14T14:33:48Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -606,16 +603,271 @@ public void addChannelFailListener(Runnable chFailLsnr) {\n         chFailLsnrs.add(chFailLsnr);\n     }\n \n+    /**\n+     * Should the channel initialization be stopped.\n+     */\n+    private boolean shouldStopChannelsReinit() {\n+        return scheduledChannelsReinit.get() || closed;\n+    }\n+\n+    /**\n+     * Init channel holders to all nodes.\n+     * @param force enable to replace existing channels with new holders.\n+     * @return {@code true} if holders are reinited and {@code false} if the initialization was interrupted.\n+     */\n+    synchronized boolean initChannelHolders(boolean force) {\n+        List<ClientChannelHolder> holders = channels;\n+\n+        if (!force && holders != null)\n+            return true;\n+\n+        startChannelsReInit = System.currentTimeMillis();\n+\n+        // Enable parallel threads to schedule new init of channel holders.\n+        scheduledChannelsReinit.set(false);\n+\n+        Map<InetSocketAddress, Integer> newAddrs = null;\n+\n+        if (clientCfg.getAddressesFinder() != null) {\n+            String[] hostAddrs = clientCfg.getAddressesFinder().getAddresses();\n+\n+            if (hostAddrs.length == 0)\n+                throw new ClientException(\"Empty addresses\");\n+\n+            if (!Arrays.equals(hostAddrs, prevHostAddrs)) {\n+                newAddrs = parsedAddresses(hostAddrs);\n+                prevHostAddrs = hostAddrs;\n+            }\n+        } else if (holders == null)\n+            newAddrs = parsedAddresses(clientCfg.getAddresses());\n+\n+        if (newAddrs == null) {\n+            finishChannelsReInit = System.currentTimeMillis();", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczMDMzNw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504730337", "bodyText": "Perhaps && !partitionAwarenessEnabled should be added here (to avoid double reinit for partition awareness, first time here and second time in async thread). WDYT?", "author": "alex-plekhanov", "createdAt": "2020-10-14T14:36:18Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -512,80 +504,81 @@ private boolean affinityInfoIsUpToDate(int cacheId) {\n         return ranges.stream()\n             .flatMap(r -> IntStream\n                 .rangeClosed(r.portFrom(), r.portTo()).boxed()\n-                .map(p -> new InetSocketAddress(r.host(), p))\n+                .map(p -> InetSocketAddress.createUnresolved(r.host(), p))\n             )\n-            .collect(Collectors.toList());\n+            .collect(Collectors.toMap(a -> a, a -> 1, Integer::sum));\n     }\n \n-    /** */\n-    private synchronized ClientChannel channel() {\n-        if (closed)\n-            throw new ClientException(\"Channel is closed\");\n-\n+    /**\n+     * Roll current default channel if specified holder equals to it.\n+     */\n+    private void rollCurrentChannel(ClientChannelHolder hld) {\n+        curChannelsGuard.writeLock().lock();\n         try {\n-            return channels[curChIdx].getOrCreateChannel();\n-        }\n-        catch (ClientConnectionException e) {\n-            rollCurrentChannel();\n+            int idx = curChIdx;\n+            List<ClientChannelHolder> holders = channels;\n \n-            throw e;\n-        }\n-    }\n+            ClientChannelHolder dfltHld = holders.get(idx);\n \n-    /** */\n-    private synchronized void rollCurrentChannel() {\n-        if (++curChIdx >= channels.length)\n-            curChIdx = 0;\n+            if (dfltHld == hld) {\n+                idx += 1;\n+\n+                if (idx >= holders.size())\n+                    curChIdx = 0;\n+                else\n+                    curChIdx = idx;\n+            }\n+        } finally {\n+            curChannelsGuard.writeLock().unlock();\n+        }\n     }\n \n     /**\n      * On current channel failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannel ch) {\n+    private void onChannelFailure(ClientChannel ch) {\n         // There is nothing wrong if curChIdx was concurrently changed, since channel was closed by another thread\n         // when current index was changed and no other wrong channel will be closed by current thread because\n         // onChannelFailure checks channel binded to the holder before closing it.\n-        onChannelFailure(channels[curChIdx], ch);\n-\n-        chFailLsnrs.forEach(Runnable::run);\n+        onChannelFailure(channels.get(curChIdx), ch);\n     }\n \n     /**\n      * On channel of the specified holder failure.\n      */\n-    private synchronized void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n-        if (ch == hld.ch && ch != null) {\n+    private void onChannelFailure(ClientChannelHolder hld, ClientChannel ch) {\n+        if (ch != null && ch == hld.ch)\n             hld.closeChannel();\n \n-            if (hld == channels[curChIdx])\n-                rollCurrentChannel();\n-        }\n+        chFailLsnrs.forEach(Runnable::run);\n+\n+        if (scheduledChannelsReinit.get())", "originalCommit": "4b060384d7d73247f005cab769c3579ad0a14dc2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDc5OTYyNA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r504799624", "bodyText": "Yeah, it is a correct optimization. But I will add this condition inside if block to avoid additional rolling of current channel.", "author": "timoninmaxim", "createdAt": "2020-10-14T16:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczMDMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTI1NTY1OQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r505255659", "bodyText": "fixed", "author": "timoninmaxim", "createdAt": "2020-10-15T07:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDczMDMzNw=="}], "type": "inlineReview"}, {"oid": "c03c88ca9e19467263ba20648335fe84e8b804b8", "url": "https://github.com/apache/ignite/commit/c03c88ca9e19467263ba20648335fe84e8b804b8", "message": "Add more new lines. Refactor getting attemps value", "committedDate": "2020-10-14T20:54:02Z", "type": "commit"}, {"oid": "8203de15c22b5d14fd696292970953d130ae5e47", "url": "https://github.com/apache/ignite/commit/8203de15c22b5d14fd696292970953d130ae5e47", "message": "WIP", "committedDate": "2020-10-14T21:33:36Z", "type": "commit"}, {"oid": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab", "url": "https://github.com/apache/ignite/commit/2698804d09f7e668ac4ad6ac23e6005fc628b2ab", "message": "Add kubernetes tests", "committedDate": "2020-10-15T15:28:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEyOTA2Nw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506129067", "bodyText": "Clean it up, please", "author": "alex-plekhanov", "createdAt": "2020-10-16T07:38:57Z", "path": "modules/kubernetes/src/test/java/org/apache/ignite/internal/kubernetes/connection/KubernetesServiceAddressResolverTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.kubernetes.connection;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockserver.integration.ClientAndServer;\n+import org.mockserver.matchers.Times;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockserver.integration.ClientAndServer.startClientAndServer;\n+import static org.mockserver.model.HttpRequest.request;\n+import static org.mockserver.model.HttpResponse.response;\n+\n+/** Checks that correctly parse kubernetes json response. */\n+public class KubernetesServiceAddressResolverTest {\n+    /** Mock of kubernetes API. */\n+    private static ClientAndServer mockServer;\n+\n+    /** */\n+    private static final String namespace = \"ns01\";\n+\n+    /** */\n+    private static final String service = \"ignite\";\n+\n+    /** */\n+    @BeforeClass\n+    public static void startServer() {\n+        mockServer = startClientAndServer();\n+    }\n+\n+    /** */\n+    @AfterClass\n+    public static void stopServer() {\n+        mockServer.stop();\n+    }\n+\n+    /** */\n+    @Test\n+    public void testCorrectParseKubernetesResponse() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(false);\n+\n+        mockSuccessServerResponse();\n+\n+        // when\n+        Collection<InetAddress> result = rslvr.getServiceAddresses();\n+\n+        // then\n+        List<String> ips = result.stream()\n+            .map(InetAddress::getHostAddress)\n+            .collect(Collectors.toList());\n+\n+        assertEquals(\n+            Arrays.asList(\"10.1.1.1\", \"10.1.1.2\", \"10.1.1.4\", \"10.1.1.5\", \"10.1.1.7\"),\n+            ips\n+        );\n+    }\n+\n+    /** */\n+    @Test\n+    public void testCorrectParseKubernetesResponseWithIncludingNotReadyAddresses() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(true);\n+\n+        mockSuccessServerResponse();\n+\n+        // when\n+        Collection<InetAddress> result = rslvr.getServiceAddresses();\n+\n+        // then\n+        List<String> ips = result.stream()\n+            .map(InetAddress::getHostAddress)\n+            .collect(Collectors.toList());\n+\n+        assertEquals(\n+            Arrays.asList(\"10.1.1.1\", \"10.1.1.2\", \"10.1.1.3\", \"10.1.1.4\", \"10.1.1.5\", \"10.1.1.6\", \"10.1.1.7\"),\n+            ips\n+        );\n+    }\n+\n+    /** */\n+    @Test(expected = IgniteException.class)\n+    public void testConnectionFailure() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(true);\n+\n+        mockFailureServerResponse();\n+\n+        rslvr.getServiceAddresses();\n+    }\n+\n+    /** */\n+    private KubernetesServiceAddressResolver prepareResolver(boolean includeNotReadyAddresses)\n+        throws IOException\n+    {\n+        File account = File.createTempFile(\"kubernetes-test-account\", \"\");\n+        new FileWriter(account).write(\"account-token\");\n+        String accountFile = account.getAbsolutePath();\n+\n+        KubernetesConnectionConfiguration cfg = new KubernetesConnectionConfiguration();\n+        cfg.setNamespace(namespace);\n+        cfg.setServiceName(service);\n+        cfg.setMasterUrl(\"https://localhost:\" + mockServer.getLocalPort());\n+        cfg.setAccountToken(accountFile);\n+        cfg.setIncludeNotReadyAddresses(includeNotReadyAddresses);\n+\n+        return new KubernetesServiceAddressResolver(cfg);\n+    }\n+\n+    /** */\n+    private void mockFailureServerResponse() {\n+        mockServer\n+            .when(\n+                request()\n+                    .withMethod(\"GET\")\n+                    .withPath(String.format(\"/api/v1/namespaces/%s/endpoints/%s\", namespace, service)),\n+                Times.exactly(1)\n+            )\n+            .respond(\n+                response()\n+                    .withStatusCode(401));\n+    }\n+\n+    /** */\n+    private void mockSuccessServerResponse() {\n+        mockServer\n+            .when(\n+                request()\n+                    .withMethod(\"GET\")\n+                    .withPath(String.format(\"/api/v1/namespaces/%s/endpoints/%s\", namespace, service)),\n+                Times.exactly(1)\n+            )\n+            .respond(\n+                response()\n+                    .withStatusCode(200)\n+                    .withBody(\"{\" +\n+                              \"  \\\"subsets\\\": [\" +\n+                              \"     {\" +\n+                              \"        \\\"addresses\\\": [\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.1\\\"\" +\n+                              \"           },\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.2\\\"\" +\n+                              \"           }\" +\n+                              \"        ],\" +\n+                              \"        \\\"notReadyAddresses\\\": [\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.3\\\"\" +\n+                              \"           }\" +\n+                              \"        ]\" +\n+                              \"     },\" +\n+                              \"     {\" +\n+                              \"        \\\"addresses\\\": [\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.4\\\"\" +\n+                              \"           },\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.5\\\"\" +\n+                              \"           }\" +\n+                              \"        ],\" +\n+                              \"        \\\"notReadyAddresses\\\": [\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.6\\\"\" +\n+                              \"           }\" +\n+                              \"        ]\" +\n+                              \"     },\" +\n+                              \"     {\" +\n+                              \"        \\\"addresses\\\": [\" +\n+                              \"           {\" +\n+                              \"              \\\"ip\\\": \\\"10.1.1.7\\\"\" +\n+                              \"           }\" +\n+                              \"        ]\" +\n+                              \"     }\" +\n+                              \"  ]\" +\n+                              \"}\"\n+                    ));\n+    }\n+\n+//", "originalCommit": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEzMTgyNw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506131827", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-16T07:42:38Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -218,18 +220,24 @@\n                                         Function<PayloadInputChannel, T> payloadReader,\n                                         int attemptsLimit,\n                                         ClientConnectionException failure) {\n-        T2<ClientChannel, Integer> chAndAttempts;\n+        ClientChannel ch;\n+        // Workaround to store used attempts value within lambda body.\n+        int attemptsCnt[] = new int[1];\n \n         try {\n-            chAndAttempts = applyOnDefaultChannel(channel -> channel, attemptsLimit);\n-\n+            ch = applyOnDefaultChannel(channel -> channel, attemptsLimit, v -> attemptsCnt[0] = v );\n         } catch (Throwable ex) {\n+            if (failure != null) {\n+                failure.addSuppressed(ex);\n+                fut.completeExceptionally(failure);", "originalCommit": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjEzMjk0NQ==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506132945", "bodyText": "NL", "author": "alex-plekhanov", "createdAt": "2020-10-16T07:43:57Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/client/thin/ReliableChannel.java", "diffHunk": "@@ -798,8 +801,10 @@ void channelsInit(boolean force) {\n \n                 c = hld.getOrCreateChannel();\n \n-                if (c != null)\n-                    return new T2<>(function.apply(c), attempt + 1);\n+                if (c != null) {\n+                    attemptsCallback.accept(attempt + 1);", "originalCommit": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2Mjg3MA==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506162870", "bodyText": "Close FileWriter?", "author": "alex-plekhanov", "createdAt": "2020-10-16T08:23:16Z", "path": "modules/kubernetes/src/test/java/org/apache/ignite/client/TestClusterClientConnection.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.client;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.configuration.ClientConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+import org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi;\n+import org.apache.ignite.spi.discovery.tcp.ipfinder.kubernetes.TcpDiscoveryKubernetesIpFinder;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockserver.integration.ClientAndServer;\n+import org.mockserver.matchers.Times;\n+\n+import static org.mockserver.integration.ClientAndServer.startClientAndServer;\n+import static org.mockserver.model.HttpRequest.request;\n+import static org.mockserver.model.HttpResponse.response;\n+\n+/** Test that thin client connects to cluster with {@link ThinClientKubernetesAddressFinder}. */\n+public class TestClusterClientConnection extends GridCommonAbstractTest {\n+    /** Mock of kubernetes API. */\n+    private static ClientAndServer mockServer;\n+\n+    /** */\n+    private static final String namespace = \"ns01\";\n+\n+    /** */\n+    private static final String service = \"ignite\";\n+\n+    /** */\n+    @BeforeClass\n+    public static void startServer() {\n+        mockServer = startClientAndServer();\n+    }\n+\n+    /** */\n+    @AfterClass\n+    public static void stopServer() {\n+        mockServer.stop();\n+    }\n+\n+    /** */\n+    @After\n+    public void tearDown() {\n+        stopAllGrids();\n+    }\n+\n+    /** */\n+    @Test\n+    public void testClientConnectsToCluster() throws Exception {\n+        mockServerResponse();\n+\n+        IgniteEx crd = startGrid(getConfiguration());\n+        String crdAddr = crd.localNode().addresses().iterator().next();\n+\n+        mockServerResponse(crdAddr);\n+\n+        ClientConfiguration ccfg = new ClientConfiguration();\n+        ccfg.setAddressesFinder(new ThinClientKubernetesAddressFinder(prepareConfiguration()));\n+\n+        IgniteClient client = Ignition.startClient(ccfg);\n+\n+        ClientCache cache = client.createCache(\"cache\");\n+        cache.put(1, 2);\n+        assertEquals(2, cache.get(1));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration() throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration();\n+\n+        KubernetesConnectionConfiguration kccfg = prepareConfiguration();\n+        TcpDiscoveryKubernetesIpFinder ipFinder = new TcpDiscoveryKubernetesIpFinder(kccfg);\n+\n+        TcpDiscoverySpi discoverySpi = new TcpDiscoverySpi();\n+        discoverySpi.setIpFinder(ipFinder);\n+\n+        cfg.setDiscoverySpi(discoverySpi);\n+\n+        cfg.setIgniteInstanceName(getTestIgniteInstanceName());\n+\n+        return cfg;\n+    }\n+\n+    /** */\n+    private void mockServerResponse(String... addrs) {\n+        String ipAddrs = Arrays.stream(addrs)\n+            .map(addr -> String.format(\"{\\\"ip\\\":\\\"%s\\\"}\", addr))\n+            .collect(Collectors.joining(\",\"));\n+\n+        mockServer\n+            .when(\n+                request()\n+                    .withMethod(\"GET\")\n+                    .withPath(String.format(\"/api/v1/namespaces/%s/endpoints/%s\", namespace, service)),\n+                Times.exactly(1)\n+            )\n+            .respond(\n+                response()\n+                    .withStatusCode(200)\n+                    .withBody(\"{\" +\n+                        \"  \\\"subsets\\\": [\" +\n+                        \"     {\" +\n+                        \"        \\\"addresses\\\": [\" +\n+                        \"        \" + ipAddrs +\n+                        \"        ]\" +\n+                        \"     }\" +\n+                        \"  ]\" +\n+                        \"}\"\n+                    ));\n+    }\n+\n+    /** */\n+    private KubernetesConnectionConfiguration prepareConfiguration()\n+        throws IOException\n+    {\n+        File account = File.createTempFile(\"kubernetes-test-account\", \"\");\n+        new FileWriter(account).write(\"account-token\");", "originalCommit": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2MzQwMg==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506163402", "bodyText": "Close FileWriter?", "author": "alex-plekhanov", "createdAt": "2020-10-16T08:23:44Z", "path": "modules/kubernetes/src/test/java/org/apache/ignite/internal/kubernetes/connection/KubernetesServiceAddressResolverTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.kubernetes.connection;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockserver.integration.ClientAndServer;\n+import org.mockserver.matchers.Times;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockserver.integration.ClientAndServer.startClientAndServer;\n+import static org.mockserver.model.HttpRequest.request;\n+import static org.mockserver.model.HttpResponse.response;\n+\n+/** Checks that correctly parse kubernetes json response. */\n+public class KubernetesServiceAddressResolverTest {\n+    /** Mock of kubernetes API. */\n+    private static ClientAndServer mockServer;\n+\n+    /** */\n+    private static final String namespace = \"ns01\";\n+\n+    /** */\n+    private static final String service = \"ignite\";\n+\n+    /** */\n+    @BeforeClass\n+    public static void startServer() {\n+        mockServer = startClientAndServer();\n+    }\n+\n+    /** */\n+    @AfterClass\n+    public static void stopServer() {\n+        mockServer.stop();\n+    }\n+\n+    /** */\n+    @Test\n+    public void testCorrectParseKubernetesResponse() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(false);\n+\n+        mockSuccessServerResponse();\n+\n+        // when\n+        Collection<InetAddress> result = rslvr.getServiceAddresses();\n+\n+        // then\n+        List<String> ips = result.stream()\n+            .map(InetAddress::getHostAddress)\n+            .collect(Collectors.toList());\n+\n+        assertEquals(\n+            Arrays.asList(\"10.1.1.1\", \"10.1.1.2\", \"10.1.1.4\", \"10.1.1.5\", \"10.1.1.7\"),\n+            ips\n+        );\n+    }\n+\n+    /** */\n+    @Test\n+    public void testCorrectParseKubernetesResponseWithIncludingNotReadyAddresses() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(true);\n+\n+        mockSuccessServerResponse();\n+\n+        // when\n+        Collection<InetAddress> result = rslvr.getServiceAddresses();\n+\n+        // then\n+        List<String> ips = result.stream()\n+            .map(InetAddress::getHostAddress)\n+            .collect(Collectors.toList());\n+\n+        assertEquals(\n+            Arrays.asList(\"10.1.1.1\", \"10.1.1.2\", \"10.1.1.3\", \"10.1.1.4\", \"10.1.1.5\", \"10.1.1.6\", \"10.1.1.7\"),\n+            ips\n+        );\n+    }\n+\n+    /** */\n+    @Test(expected = IgniteException.class)\n+    public void testConnectionFailure() throws IOException {\n+        // given\n+        KubernetesServiceAddressResolver rslvr = prepareResolver(true);\n+\n+        mockFailureServerResponse();\n+\n+        rslvr.getServiceAddresses();\n+    }\n+\n+    /** */\n+    private KubernetesServiceAddressResolver prepareResolver(boolean includeNotReadyAddresses)\n+        throws IOException\n+    {\n+        File account = File.createTempFile(\"kubernetes-test-account\", \"\");\n+        new FileWriter(account).write(\"account-token\");", "originalCommit": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2NTg1Nw==", "url": "https://github.com/apache/ignite/pull/8206#discussion_r506165857", "bodyText": "Why it is not included to the suite?", "author": "alex-plekhanov", "createdAt": "2020-10-16T08:26:30Z", "path": "modules/kubernetes/src/test/java/org/apache/ignite/internal/kubernetes/connection/KubernetesServiceAddressResolverTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.kubernetes.connection;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.kubernetes.configuration.KubernetesConnectionConfiguration;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.mockserver.integration.ClientAndServer;\n+import org.mockserver.matchers.Times;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockserver.integration.ClientAndServer.startClientAndServer;\n+import static org.mockserver.model.HttpRequest.request;\n+import static org.mockserver.model.HttpResponse.response;\n+\n+/** Checks that correctly parse kubernetes json response. */\n+public class KubernetesServiceAddressResolverTest {", "originalCommit": "2698804d09f7e668ac4ad6ac23e6005fc628b2ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "86e58499b0aeb70ab5c7de92d362fa5478d97c87", "url": "https://github.com/apache/ignite/commit/86e58499b0aeb70ab5c7de92d362fa5478d97c87", "message": "Fix review comments.", "committedDate": "2020-10-16T08:54:30Z", "type": "commit"}, {"oid": "1c429a61bf7fc8e12edee592357c125a85ea3c83", "url": "https://github.com/apache/ignite/commit/1c429a61bf7fc8e12edee592357c125a85ea3c83", "message": "Merge remote-tracking branch 'upstream/master' into IGNITE-13204_kubernetes_thin_client", "committedDate": "2020-10-16T09:02:14Z", "type": "commit"}]}