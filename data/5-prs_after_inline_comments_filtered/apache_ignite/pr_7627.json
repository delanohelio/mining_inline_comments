{"pr_number": 7627, "pr_title": "IGNITE-12808 Allow register started caches in indexing to enable SQL query on them.", "pr_createdAt": "2020-04-06T13:11:42Z", "pr_url": "https://github.com/apache/ignite/pull/7627", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2MzIyMw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442863223", "bodyText": "Typo: dot in the end.", "author": "nizhikov", "createdAt": "2020-06-19T14:10:43Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheUtils.java", "diffHunk": "@@ -2121,6 +2122,43 @@ public static boolean isCacheTemplateName(String cacheName) {\n         return cacheName.endsWith(\"*\");\n     }\n \n+    /**\n+     * Patch cache configuration with {@link SchemaAddQueryEntityOperation}.\n+     *\n+     * @param oldCfg Old cache config.\n+     * @param op Schema add query entity operation.\n+     */\n+    public static <K, V> CacheConfiguration<K, V> patchCacheConfiguration(\n+        CacheConfiguration<K, V> oldCfg,\n+        SchemaAddQueryEntityOperation op\n+    ) {\n+        return patchCacheConfiguration(oldCfg, op.entities(), op.schemaName(), op.isSqlEscape(),\n+                op.queryParallelism());\n+    }\n+\n+    /**\n+     * Patch cache configuration with {@link SchemaAddQueryEntityOperation}.\n+     *\n+     * @param oldCfg Old cache config.\n+     * @param entities New query entities.\n+     * @param sqlSchema Sql schema name,", "originalCommit": "ba0e3662389047cbfa1cfa061213c790fd9f06d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2MzQwNQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442863405", "bodyText": "Typo: dot in the end.", "author": "nizhikov", "createdAt": "2020-06-19T14:11:01Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/ValidationOnNodeJoinUtils.java", "diffHunk": "@@ -92,6 +92,11 @@\n  * Util class for joining node validation.\n  */\n public class ValidationOnNodeJoinUtils {\n+    /** Template of message of conflicts of sql schema name */", "originalCommit": "ba0e3662389047cbfa1cfa061213c790fd9f06d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2NDAyNg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442864026", "bodyText": "Please, add the javadoc.", "author": "nizhikov", "createdAt": "2020-06-19T14:12:13Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridQueryProcessor.java", "diffHunk": "@@ -1152,6 +1176,75 @@ private void registerBinaryMetadata(CacheConfiguration ccfg, QuerySchema schema)\n         }\n     }\n \n+    /**\n+     *", "originalCommit": "ba0e3662389047cbfa1cfa061213c790fd9f06d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "280d6873320e4d13db7325ab1ef0635c6a7b5857", "url": "https://github.com/apache/ignite/commit/280d6873320e4d13db7325ab1ef0635c6a7b5857", "message": "IGNITE-12808 Final fixes.", "committedDate": "2020-06-19T14:36:19Z", "type": "commit"}, {"oid": "35ed98063b9ae5f344c1e76bfd1610e723acf0eb", "url": "https://github.com/apache/ignite/commit/35ed98063b9ae5f344c1e76bfd1610e723acf0eb", "message": "IGNITE-12808 Fix test.", "committedDate": "2020-06-20T12:46:30Z", "type": "commit"}, {"oid": "9ca04be23460f9da992612c351809b91022b13ae", "url": "https://github.com/apache/ignite/commit/9ca04be23460f9da992612c351809b91022b13ae", "message": "IGNITE-12808 Initial.", "committedDate": "2020-04-06T13:07:25Z", "type": "commit"}, {"oid": "5bb733a3c8e79abbd39b0e0ec2d4c30cca0dde5d", "url": "https://github.com/apache/ignite/commit/5bb733a3c8e79abbd39b0e0ec2d4c30cca0dde5d", "message": "Merge remote-tracking branch 'origin/master' into ignite-12808", "committedDate": "2020-04-06T13:08:51Z", "type": "commit"}, {"oid": "3d32fc4677d592dee4cf6ab2eb1e2f95a96e6cd3", "url": "https://github.com/apache/ignite/commit/3d32fc4677d592dee4cf6ab2eb1e2f95a96e6cd3", "message": "IGNITE-12808 Wip.", "committedDate": "2020-04-06T14:12:58Z", "type": "commit"}, {"oid": "d169c2ed025386b49ff9732ef2a06f33d2ed7f9a", "url": "https://github.com/apache/ignite/commit/d169c2ed025386b49ff9732ef2a06f33d2ed7f9a", "message": "IGNITE-12808 Problems with one scenarion -- when query entities with custom\nindex added, B+ tree corruption occurs.", "committedDate": "2020-04-09T17:12:49Z", "type": "commit"}, {"oid": "5705a9c6dae93439836d5c14f6b5de0b0985dca8", "url": "https://github.com/apache/ignite/commit/5705a9c6dae93439836d5c14f6b5de0b0985dca8", "message": "IGNITE-12808 Reproducer for scenario added. Surprisingly, after restarting partition recovers and everything works ok.", "committedDate": "2020-04-10T07:05:13Z", "type": "commit"}, {"oid": "00aed6d1af8337d2ef948c9d6185400b7065238d", "url": "https://github.com/apache/ignite/commit/00aed6d1af8337d2ef948c9d6185400b7065238d", "message": "IGNITE-12808 Fix corrupted tree.", "committedDate": "2020-04-10T10:34:48Z", "type": "commit"}, {"oid": "d9e4c6b6a6db19eeeb03e25794922b71291ed261", "url": "https://github.com/apache/ignite/commit/d9e4c6b6a6db19eeeb03e25794922b71291ed261", "message": "IGNITE-12808 Move index build futures to GridQueryProcessor", "committedDate": "2020-04-14T12:31:51Z", "type": "commit"}, {"oid": "18c4e9d156e585f08d942f336153533f6c795cf3", "url": "https://github.com/apache/ignite/commit/18c4e9d156e585f08d942f336153533f6c795cf3", "message": "Merge remote-tracking branch 'remotes/origin/master' into ignite-12808", "committedDate": "2020-04-14T12:32:40Z", "type": "commit"}, {"oid": "62566e41f48e8ddea3d28b1ca63c85379bdadba3", "url": "https://github.com/apache/ignite/commit/62566e41f48e8ddea3d28b1ca63c85379bdadba3", "message": "IGNITE-12808 Checkstyle fixes.", "committedDate": "2020-04-14T13:20:23Z", "type": "commit"}, {"oid": "c8775769848e513b0af5b226e0456007a4dad63e", "url": "https://github.com/apache/ignite/commit/c8775769848e513b0af5b226e0456007a4dad63e", "message": "IGNITE-12808 Fix failed test.", "committedDate": "2020-04-14T15:33:45Z", "type": "commit"}, {"oid": "0e9c03f305febcdcfc8940065b13bd61f8fcf90b", "url": "https://github.com/apache/ignite/commit/0e9c03f305febcdcfc8940065b13bd61f8fcf90b", "message": "IGNITE-12808 Fix another failed test.", "committedDate": "2020-04-14T17:49:55Z", "type": "commit"}, {"oid": "81d6370e6cb7467892c29f01905e44ddb7c61fe1", "url": "https://github.com/apache/ignite/commit/81d6370e6cb7467892c29f01905e44ddb7c61fe1", "message": "IGNITE-12808 Wip.", "committedDate": "2020-04-15T15:01:16Z", "type": "commit"}, {"oid": "6187304f0db096e4092f02f524d094b55c3777e0", "url": "https://github.com/apache/ignite/commit/6187304f0db096e4092f02f524d094b55c3777e0", "message": "Merge remote-tracking branch 'remotes/origin/master' into ignite-12808", "committedDate": "2020-05-18T06:44:07Z", "type": "commit"}, {"oid": "8eb135832598b6847db3bae066689d1ab4937a1b", "url": "https://github.com/apache/ignite/commit/8eb135832598b6847db3bae066689d1ab4937a1b", "message": "Merge remote-tracking branch 'origin/master' into ignite-12808", "committedDate": "2020-05-26T11:40:50Z", "type": "commit"}, {"oid": "d4aeebe4efed07aa153c62ac205403b0d6b5d46c", "url": "https://github.com/apache/ignite/commit/d4aeebe4efed07aa153c62ac205403b0d6b5d46c", "message": "IGNITE-12808: Wip.", "committedDate": "2020-05-29T16:21:48Z", "type": "commit"}, {"oid": "d4aeebe4efed07aa153c62ac205403b0d6b5d46c", "url": "https://github.com/apache/ignite/commit/d4aeebe4efed07aa153c62ac205403b0d6b5d46c", "message": "IGNITE-12808: Wip.", "committedDate": "2020-05-29T16:21:48Z", "type": "forcePushed"}, {"oid": "2e61bf25eed5d37492b10217e83d7148988ce354", "url": "https://github.com/apache/ignite/commit/2e61bf25eed5d37492b10217e83d7148988ce354", "message": "Merge remote-tracking branch 'origin/master' into ignite-12808", "committedDate": "2020-05-29T16:22:45Z", "type": "commit"}, {"oid": "f656a5352d71f9c37aabd52ace33ae93ac4f5b04", "url": "https://github.com/apache/ignite/commit/f656a5352d71f9c37aabd52ace33ae93ac4f5b04", "message": "wip.", "committedDate": "2020-05-31T17:42:27Z", "type": "commit"}, {"oid": "4c6d63df1d38059517d275227815eab701ed7c7c", "url": "https://github.com/apache/ignite/commit/4c6d63df1d38059517d275227815eab701ed7c7c", "message": "IGNITE-12808: Wip.", "committedDate": "2020-06-01T07:49:47Z", "type": "forcePushed"}, {"oid": "e90377c46f5f8674fd59ccc2d0e35a142d31145b", "url": "https://github.com/apache/ignite/commit/e90377c46f5f8674fd59ccc2d0e35a142d31145b", "message": "IGNITE-12808: Wip.", "committedDate": "2020-06-01T07:51:24Z", "type": "forcePushed"}, {"oid": "6ec8e038bfbb44c42a6ac3a1317aa1343e282e0b", "url": "https://github.com/apache/ignite/commit/6ec8e038bfbb44c42a6ac3a1317aa1343e282e0b", "message": "IGNITE-12808: Wip.", "committedDate": "2020-06-01T07:54:36Z", "type": "commit"}, {"oid": "6ec8e038bfbb44c42a6ac3a1317aa1343e282e0b", "url": "https://github.com/apache/ignite/commit/6ec8e038bfbb44c42a6ac3a1317aa1343e282e0b", "message": "IGNITE-12808: Wip.", "committedDate": "2020-06-01T07:54:36Z", "type": "forcePushed"}, {"oid": "86cbe4e6e7d0addc9d685d5e3e274024851aab30", "url": "https://github.com/apache/ignite/commit/86cbe4e6e7d0addc9d685d5e3e274024851aab30", "message": "IGNITE-12808: Fix client reconnect and joining node cases.", "committedDate": "2020-06-02T15:14:22Z", "type": "commit"}, {"oid": "91362d6f459ef21c0ddb54af3c285522526278b4", "url": "https://github.com/apache/ignite/commit/91362d6f459ef21c0ddb54af3c285522526278b4", "message": "IGNITE-12808: Implement test suites.", "committedDate": "2020-06-03T14:08:13Z", "type": "commit"}, {"oid": "466698de87f6e6afca30b00f59413a553f7d6031", "url": "https://github.com/apache/ignite/commit/466698de87f6e6afca30b00f59413a553f7d6031", "message": "Merge remote-tracking branch 'origin/master' into ignite-12808", "committedDate": "2020-06-04T10:21:59Z", "type": "commit"}, {"oid": "e747888b2da62b8e4a4931c98ad2198b2f23ae2a", "url": "https://github.com/apache/ignite/commit/e747888b2da62b8e4a4931c98ad2198b2f23ae2a", "message": "IGNITE-12808 Patch context + fix and extend test.", "committedDate": "2020-06-05T12:27:57Z", "type": "commit"}, {"oid": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "url": "https://github.com/apache/ignite/commit/1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "message": "IGNITE-12808 Some refactoring + concurrency fixes.", "committedDate": "2020-06-05T14:20:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEwNDU1OQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438104559", "bodyText": "Javadoc", "author": "AMashenkov", "createdAt": "2020-06-10T13:03:55Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/GridCacheQueryManager.java", "diffHunk": "@@ -296,6 +296,14 @@ public boolean enabled() {\n         return enabled;\n     }\n \n+    /**\n+     *", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEwNTkxOA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438105918", "bodyText": "Does second condition matter? QueryUtils.isEnabled(cctx.config())", "author": "AMashenkov", "createdAt": "2020-06-10T13:05:55Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/query/GridCacheQueryManager.java", "diffHunk": "@@ -425,7 +433,7 @@ public void store(CacheDataRow newRow, @Nullable CacheDataRow prevRow,\n      */\n     public void remove(KeyCacheObject key, @Nullable CacheDataRow prevRow)\n         throws IgniteCheckedException {\n-        if (!QueryUtils.isEnabled(cctx.config()))\n+        if (!qryProcEnabled && !QueryUtils.isEnabled(cctx.config()))", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODExMjg0OQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438112849", "bodyText": "There is no tests added with non-default 'queryParallelism' .", "author": "AMashenkov", "createdAt": "2020-06-10T13:16:32Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheContext.java", "diffHunk": "@@ -2350,6 +2352,29 @@ public boolean hasContinuousQueryListeners(@Nullable IgniteInternalTx tx) {\n             contQryMgr.notifyContinuousQueries(tx) && !F.isEmpty(contQryMgr.updateListeners(false, false));\n     }\n \n+    /**\n+     * Apply changes from {@link SchemaAddQueryEntityOperation}\n+     *\n+     * @param op Add query entity schema operation.\n+     */\n+    public void onSchemaAddQueryEntity(SchemaAddQueryEntityOperation op) {\n+        CacheConfiguration oldCfg = cacheCfg;\n+\n+        if (oldCfg != null) {\n+            CacheConfiguration newCfg = new CacheConfiguration(oldCfg);\n+\n+            newCfg.setQueryEntities(Collections.singletonList(op.entity()));\n+            newCfg.setSqlSchema(op.schemaName());\n+            newCfg.setSqlEscapeAll(op.isSqlEscape());\n+            newCfg.setQueryParallelism(op.queryParallelism());", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEzMDg5NA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438130894", "bodyText": "Let's add clients nodes and check schema changes propagated correctly to clients.", "author": "AMashenkov", "createdAt": "2020-06-10T13:41:38Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/IgniteDynamicEnableIndexingRestoreTest.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache;\n+\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.WALMode;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.PA;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+/**\n+ *  Tests different scenarious to ensure that enabling indexing on persistence CACHE\n+ *  correctly persisted and validated on topology change.\n+ */\n+public class IgniteDynamicEnableIndexingRestoreTest extends GridCommonAbstractTest {", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE3MTc5NQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438171795", "bodyText": "This looks like a bug.\n'beforeTestsStarted' is called before tests is started.\n'beforeTest()' - is called before each test.", "author": "AMashenkov", "createdAt": "2020-06-10T14:34:37Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingBasicSelfTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.Arrays;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.NearCacheConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Tests basic functionality of enabling indexing.\n+ */\n+@RunWith(Parameterized.class)\n+public class DynamicEnableIndexingBasicSelfTest extends DynamicEnableIndexingAbstractTest {\n+    /** Test parameters. */\n+    @Parameters(name = \"isNear={0},opNode={1}\")\n+    public static Iterable<Object[]> params() {\n+        return Arrays.asList(\n+                new Object[] {true, IDX_CLI},\n+                new Object[] {true, IDX_SRV_CRD},\n+                new Object[] {true, IDX_SRV_NON_CRD},\n+                new Object[] {true, IDX_SRV_FILTERED},\n+                new Object[] {false, IDX_CLI},\n+                new Object[] {false, IDX_SRV_CRD},\n+                new Object[] {false, IDX_SRV_NON_CRD},\n+                new Object[] {false, IDX_SRV_FILTERED}\n+        );\n+    }\n+\n+    /** */\n+    @Parameter(0)\n+    public boolean hasNear;\n+\n+    /** */\n+    @Parameter(1)\n+    public int nodeIdx;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        super.beforeTest();\n+", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE3NTI2OQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438175269", "bodyText": "Yes, I fixed this typo and will commit a corrected one with other fixes soon.", "author": "ivandasch", "createdAt": "2020-06-10T14:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE3MTc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NjEzMQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438066131", "bodyText": "Let's add here all parameters for this test:\n    public static Iterable<Object[]> params() {\n        boolean [] hasNear = new boolean[]{true, false};\n\n        int[] opNodes = new int[] {IDX_CLI, IDX_SRV_CRD, IDX_SRV_NON_CRD, IDX_SRV_FILTERED};\n\n        CacheMode[] cacheModes = new CacheMode[] {PARTITIONED, REPLICATED};\n\n        CacheAtomicityMode[] txModes = new CacheAtomicityMode[] {ATOMIC, TRANSACTIONAL};\n\n        List<Object[]> res = new ArrayList<>(hasNear.length * opNodes.length * cacheModes.length * txModes.length);\n        for (boolean near : hasNear) {\n            for (int node : opNodes) {\n                for (CacheMode mode : cacheModes) {\n                    for (CacheAtomicityMode txMode : txModes)\n                        res.add(new Object[] { near, node, mode, txMode});\n                }\n            }\n        }\n\n        return res;\n    }", "author": "nizhikov", "createdAt": "2020-06-10T11:57:39Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingBasicSelfTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.Arrays;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.NearCacheConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Tests basic functionality of enabling indexing.\n+ */\n+@RunWith(Parameterized.class)\n+public class DynamicEnableIndexingBasicSelfTest extends DynamicEnableIndexingAbstractTest {\n+    /** Test parameters. */\n+    @Parameters(name = \"isNear={0},opNode={1}\")\n+    public static Iterable<Object[]> params() {", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NzAyOA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438067028", "bodyText": "Do we support TRANSACTIONAL_SNAPSHOT for this feature? Let's add mode to tests", "author": "nizhikov", "createdAt": "2020-06-10T11:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEwOTIzMg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438109232", "bodyText": "Do we support LOCAL caches?\nIf yes - let's just add a test to check it.\nIf no -  we should add an exception when the user tries to create a table over LOCAL cache and test to check it.", "author": "nizhikov", "createdAt": "2020-06-10T13:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NDg5MA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438854890", "bodyText": "Actually, we don't support LOCAL caches and I added test for it (expected failure).\nI also add TRANSACTIONAL_SNAPSHOT to this test and rewrited as you suggests.\nAlso I add to this test check for queryParallelism and check it for PARTITIONED caches and expected failure for REPLICATED (As Andrey Mashenkov suggests)", "author": "ivandasch", "createdAt": "2020-06-11T15:06:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NjEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NTA1NQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438855055", "bodyText": "I will commit changes ASAP.", "author": "ivandasch", "createdAt": "2020-06-11T15:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NjEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NzUzOA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438067538", "bodyText": "Typo: brackets required for multiline if.", "author": "nizhikov", "createdAt": "2020-06-10T12:00:30Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/CommandProcessor.java", "diffHunk": "@@ -787,21 +787,31 @@ else if (cmdH2 instanceof GridSqlCreateTable) {\n                     if (err != null)\n                         throw err;\n \n-                    ctx.query().dynamicTableCreate(\n-                        cmd.schemaName(),\n-                        e,\n-                        cmd.templateName(),\n-                        cmd.cacheName(),\n-                        cmd.cacheGroup(),\n-                        cmd.dataRegionName(),\n-                        cmd.affinityKey(),\n-                        cmd.atomicityMode(),\n-                        cmd.writeSynchronizationMode(),\n-                        cmd.backups(),\n-                        cmd.ifNotExists(),\n-                        cmd.encrypted(),\n-                        cmd.parallelism()\n-                    );\n+                    if (!F.isEmpty(cmd.cacheName()) && ctx.cache().cacheDescriptor(cmd.cacheName()) != null)", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2OTQ0Nw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438069447", "bodyText": "What if we try to create table over the cache that already has QueryEntity defined?\n\nIgnite.createCache(\"my-cache\")\nCREATE TABLE t1(ID LONG, NAME VARCHAR) WITH \"CACHE_NAME=my-cache\"\nCREATE TABLE t2(ID LONG, NAME VARCHAR) WITH \"CACHE_NAME=my-cache\"\n\nI expect exception on the third operation.\nLet's add test for it.", "author": "nizhikov", "createdAt": "2020-06-10T12:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NjY5OA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438856698", "bodyText": "Actually, there is tests for this case in H2DynamicTableSelfTest#testDuplicateCustomCacheName", "author": "ivandasch", "createdAt": "2020-06-11T15:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NzUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NzA2Mw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438857063", "bodyText": "And I realized that this is not obvious name and refactor it a little bit, I'll commit soon", "author": "ivandasch", "createdAt": "2020-06-11T15:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NzUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3MTkwMg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438071902", "bodyText": "Please, avoid nested code blocks.\nThis reduces code readability.\nLet's just split this test.\nNote, that afterTest perform stopAllGrids already.", "author": "nizhikov", "createdAt": "2020-06-10T12:09:17Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/IgniteDynamicEnableIndexingRestoreTest.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache;\n+\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.WALMode;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.PA;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+/**\n+ *  Tests different scenarious to ensure that enabling indexing on persistence CACHE\n+ *  correctly persisted and validated on topology change.\n+ */\n+public class IgniteDynamicEnableIndexingRestoreTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    public static final String POI_SCHEMA_NAME = \"DOMAIN\";\n+\n+    /** */\n+    public static final String WRONG_SCHEMA_NAME = \"DOMAIN_1\";\n+\n+    /** */\n+    public static final String POI_TABLE_NAME = \"POI\";\n+\n+    /** */\n+    public static final String POI_CLASS_NAME = \"PointOfInterest\";\n+\n+    /** */\n+    public static final String ID_FIELD_NAME = \"id\";\n+\n+    /** */\n+    public static final String NAME_FIELD_NAME = \"name\";\n+\n+    /** */\n+    public static final String PK_INDEX_NAME = \"_key_pk\";\n+\n+    /** */\n+    public static final String LATITUDE_FIELD_NAME = \"latitude\";\n+\n+    /** */\n+    public static final String LONGITUDE_FIELD_NAME = \"longitude\";\n+\n+    /** */\n+    public static final int NUM_ENTRIES = 500;\n+\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(gridName);\n+\n+        cfg.setClusterStateOnStart(ClusterState.INACTIVE);\n+\n+        DataStorageConfiguration memCfg = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(\n+                new DataRegionConfiguration().setMaxSize(200 * 1024 * 1024).setPersistenceEnabled(true))\n+            .setWalMode(WALMode.LOG_ONLY);\n+\n+        cfg.setDataStorageConfiguration(memCfg);\n+\n+        cfg.setConsistentId(gridName);\n+\n+        cfg.setSqlSchemas(POI_SCHEMA_NAME, WRONG_SCHEMA_NAME);\n+\n+        return cfg;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        stopAllGrids();\n+\n+        cleanPersistenceDir();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        stopAllGrids();\n+\n+        cleanPersistenceDir();\n+    }\n+\n+    /**\n+     * @throws Exception if failed.\n+     */\n+    @Test\n+    public void testMergeCacheConfig_StartWithInitialCoordinator() throws Exception {\n+        testMergeCacheConfig(0, 1);\n+    }\n+\n+    /**\n+     * @throws Exception if failed.\n+     */\n+    @Test\n+    public void testMergeCacheConfig_StartWithInitialSecondNode() throws Exception {\n+        testMergeCacheConfig(1, 0);\n+    }\n+\n+    /**\n+     * @param firstIdx Index of first starting node after cluster stopping.\n+     * @param secondIdx Index of second starting node after cluster stopping.\n+     */\n+    private void testMergeCacheConfig(int firstIdx, int secondIdx) throws Exception {\n+        prepareTestGrid();\n+\n+        {", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4ODAzNg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438888036", "bodyText": "We cannot split this test. This is scenario. But I +1 for nested blocks. Here they are unnecessary.", "author": "ivandasch", "createdAt": "2020-06-11T15:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3MTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA4NjQ2NQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438086465", "bodyText": "Typo: please, remove empty line.", "author": "nizhikov", "createdAt": "2020-06-10T12:35:29Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/IgniteDynamicEnableIndexingRestoreTest.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache;\n+\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.WALMode;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.PA;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+/**\n+ *  Tests different scenarious to ensure that enabling indexing on persistence CACHE\n+ *  correctly persisted and validated on topology change.\n+ */\n+public class IgniteDynamicEnableIndexingRestoreTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    public static final String POI_SCHEMA_NAME = \"DOMAIN\";\n+\n+    /** */\n+    public static final String WRONG_SCHEMA_NAME = \"DOMAIN_1\";\n+\n+    /** */\n+    public static final String POI_TABLE_NAME = \"POI\";\n+\n+    /** */\n+    public static final String POI_CLASS_NAME = \"PointOfInterest\";\n+\n+    /** */\n+    public static final String ID_FIELD_NAME = \"id\";\n+\n+    /** */\n+    public static final String NAME_FIELD_NAME = \"name\";\n+\n+    /** */\n+    public static final String PK_INDEX_NAME = \"_key_pk\";\n+\n+    /** */\n+    public static final String LATITUDE_FIELD_NAME = \"latitude\";\n+\n+    /** */\n+    public static final String LONGITUDE_FIELD_NAME = \"longitude\";\n+\n+    /** */\n+    public static final int NUM_ENTRIES = 500;\n+\n+", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0OTM2NA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438649364", "bodyText": "This method invoked only once.\nLet's inline it.", "author": "nizhikov", "createdAt": "2020-06-11T09:10:51Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/H2RowCacheRegistry.java", "diffHunk": "@@ -49,12 +49,25 @@\n      *\n      * @param cacheInfo Cache info context.\n      */\n-    public void onCacheRegistered(GridCacheContextInfo cacheInfo) {\n+    public void onCacheRegistered(GridCacheContextInfo<?, ?> cacheInfo) {\n         if (!cacheInfo.config().isSqlOnheapCacheEnabled())\n             return;\n \n+        GridCacheContext<?, ?> cacheCtx = cacheInfo.cacheContext();\n+\n+        assert cacheCtx != null;\n+\n+        onCacheRegistered(cacheCtx);\n+    }\n+\n+    /**\n+     * Callback invoked on cache registration within indexing.\n+     *\n+     * @param cctx Cache context.\n+     */\n+    void onCacheRegistered(GridCacheContext<?, ?> cctx) {", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MTQ2Ng==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438651466", "bodyText": "It seems, the only change here - we move assert cacheCtx != null to the method start.\nCan you, please, describe, why do we need it?", "author": "nizhikov", "createdAt": "2020-06-11T09:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0OTM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjYzMA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438872630", "bodyText": "It's seems like an artifact of first experiment -- I'll revert it.", "author": "ivandasch", "createdAt": "2020-06-11T15:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0OTM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY4MDczNw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438680737", "bodyText": "Can you, please, explain, why do we need this new check?", "author": "nizhikov", "createdAt": "2020-06-11T10:08:35Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/IgniteH2Indexing.java", "diffHunk": "@@ -1954,22 +1954,23 @@ public UpdateResult executeUpdateOnDataNode(\n     }\n \n     /** {@inheritDoc} */\n-    @Override public IgniteInternalFuture<?> rebuildIndexesFromHash(GridCacheContext cctx) {\n+    @Override public IgniteInternalFuture<?> rebuildIndexesFromHash(GridCacheContext cctx, boolean rebuildInMemory) {\n         assert nonNull(cctx);\n \n-        // No data in fresh in-memory cache.\n-        if (!cctx.group().persistenceEnabled())\n+        // No data in fresh in-memory cache. If force, this meant that indexing is enabling dynamically.\n+        if (!cctx.group().persistenceEnabled() && !rebuildInMemory)\n             return null;\n \n-        IgnitePageStoreManager pageStore = cctx.shared().pageStore();\n+        if (!CU.affinityNode(cctx.localNode(), cctx.config().getNodeFilter()))", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NjczMQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438866731", "bodyText": "Because we don't need to rebuild indices on non-affinity nodes.", "author": "ivandasch", "createdAt": "2020-06-11T15:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY4MDczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwOTg0OA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438709848", "bodyText": "Can we add the test for this case?", "author": "nizhikov", "createdAt": "2020-06-11T11:10:35Z", "path": "modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/SchemaManager.java", "diffHunk": "@@ -355,6 +355,10 @@ public void onCacheDestroyed(String cacheName, boolean rmvIdx) {\n         // Remove this mapping only after callback to DML proc - it needs that mapping internally\n         cacheName2schema.remove(cacheName);\n \n+        // Possible situation, when node join after indexing enabled dynamically to cache.", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEwMjc2NQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r440102765", "bodyText": "org.apache.ignite.internal.processors.cache.index.DynamicEnableIndexingConcurrentSelfTest#testClientReconnect", "author": "ivandasch", "createdAt": "2020-06-15T11:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwOTg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNzU3NA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438827574", "bodyText": "Typo: Brackets for multiline if required.", "author": "nizhikov", "createdAt": "2020-06-11T14:27:26Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/ValidationOnNodeJoinUtils.java", "diffHunk": "@@ -209,6 +203,44 @@\n         return null;\n     }\n \n+    /**\n+     * @param locDesc Local cache descriptor.\n+     * @param joinedData Joined node cache data.\n+     * @param isGridActive Is grid active.\n+     * @param errorMsg Error message builder.\n+     */\n+    static void validateSqlSchema(\n+        DynamicCacheDescriptor locDesc,\n+        StoredCacheData joinedData,\n+        boolean isGridActive,\n+        StringBuilder errorMsg\n+    ) {\n+        String joinedSchema = joinedData.config().getSqlSchema();\n+        String locSchema = locDesc.cacheConfiguration().getSqlSchema();\n+\n+        // Peform checks of SQL schema. If schemas' names not equal, only valid case is if local or joined\n+        // QuerySchema is empty and schema name is null (when indexing enabled dynamically).\n+        if (!F.eq(joinedSchema, locSchema)\n+            && (locSchema != null || !locDesc.schema().isEmpty())\n+            && (joinedSchema != null || !F.isEmpty(joinedData.queryEntities()))\n+        )\n+            errorMsg.append(String.format(SQL_SCHEMA_CONFLICTS_MESSAGE, locDesc.cacheName(), joinedSchema,", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMDc0Mw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438830743", "bodyText": "Do we have a test to check this?", "author": "nizhikov", "createdAt": "2020-06-11T14:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNzU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MTY0Mw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438861643", "bodyText": "Yes, please see IgniteDynamicEnableIndexingRestoreTest", "author": "ivandasch", "createdAt": "2020-06-11T15:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNzU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNzcyOQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438827729", "bodyText": "Typo: Brackets for multiline if required.", "author": "nizhikov", "createdAt": "2020-06-11T14:27:39Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/ValidationOnNodeJoinUtils.java", "diffHunk": "@@ -209,6 +203,44 @@\n         return null;\n     }\n \n+    /**\n+     * @param locDesc Local cache descriptor.\n+     * @param joinedData Joined node cache data.\n+     * @param isGridActive Is grid active.\n+     * @param errorMsg Error message builder.\n+     */\n+    static void validateSqlSchema(\n+        DynamicCacheDescriptor locDesc,\n+        StoredCacheData joinedData,\n+        boolean isGridActive,\n+        StringBuilder errorMsg\n+    ) {\n+        String joinedSchema = joinedData.config().getSqlSchema();\n+        String locSchema = locDesc.cacheConfiguration().getSqlSchema();\n+\n+        // Peform checks of SQL schema. If schemas' names not equal, only valid case is if local or joined\n+        // QuerySchema is empty and schema name is null (when indexing enabled dynamically).\n+        if (!F.eq(joinedSchema, locSchema)\n+            && (locSchema != null || !locDesc.schema().isEmpty())\n+            && (joinedSchema != null || !F.isEmpty(joinedData.queryEntities()))\n+        )\n+            errorMsg.append(String.format(SQL_SCHEMA_CONFLICTS_MESSAGE, locDesc.cacheName(), joinedSchema,\n+                locSchema));\n+\n+        QuerySchemaPatch schemaPatch = locDesc.makeSchemaPatch(joinedData.queryEntities());\n+\n+        if (schemaPatch.hasConflicts() || (isGridActive && !schemaPatch.isEmpty())) {\n+            if (errorMsg.length() > 0)\n+                errorMsg.append(\"\\n\");\n+\n+            if (schemaPatch.hasConflicts())\n+                errorMsg.append(String.format(MERGE_OF_CONFIG_CONFLICTS_MESSAGE,", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMjA4Mg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438832082", "bodyText": "Let's inline this method as it has only one usage.", "author": "nizhikov", "createdAt": "2020-06-11T14:33:40Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/ValidationOnNodeJoinUtils.java", "diffHunk": "@@ -209,6 +203,44 @@\n         return null;\n     }\n \n+    /**\n+     * @param locDesc Local cache descriptor.\n+     * @param joinedData Joined node cache data.\n+     * @param isGridActive Is grid active.\n+     * @param errorMsg Error message builder.\n+     */\n+    static void validateSqlSchema(", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4MTc2Ng==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438881766", "bodyText": "I think that it is not really good idea here. validateNode is too complex and verbose.", "author": "ivandasch", "createdAt": "2020-06-11T15:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMjA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzNzYyMw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r441637623", "bodyText": "We can refactor validateNode in the next patches.\nFor now, we should try to keep PR as simple as we can.", "author": "nizhikov", "createdAt": "2020-06-17T15:32:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzMjA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNDUwNQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438834505", "bodyText": "Let's use new CacheConfiguration<> to remove compiler warning.", "author": "nizhikov", "createdAt": "2020-06-11T14:37:12Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheContextInfo.java", "diffHunk": "@@ -53,7 +55,25 @@\n      * @param clientCache Client cache or not.\n      */\n     public GridCacheContextInfo(GridCacheContext<K, V> cctx, boolean clientCache) {\n-        config = cctx.config();\n+        config = new CacheConfiguration(cctx.config());", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4NTQ1Nw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438885457", "bodyText": "This doesn't help, cctx.config() returns not parameterized CacheConfiguration.\nI suppose that we should either to do a massive refactoring, or leave it as is.", "author": "ivandasch", "createdAt": "2020-06-11T15:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNDUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNDU2MQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438834561", "bodyText": "Let's use new CacheConfiguration<> to remove compiler warning", "author": "nizhikov", "createdAt": "2020-06-11T14:37:17Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheContextInfo.java", "diffHunk": "@@ -53,7 +55,25 @@\n      * @param clientCache Client cache or not.\n      */\n     public GridCacheContextInfo(GridCacheContext<K, V> cctx, boolean clientCache) {\n-        config = cctx.config();\n+        config = new CacheConfiguration(cctx.config());\n+        dynamicDeploymentId = null;\n+        groupId = cctx.groupId();\n+        cacheId = cctx.cacheId();\n+\n+        this.clientCache = clientCache;\n+\n+        this.cctx = cctx;\n+    }\n+\n+    /**\n+     * Constructor of full cache context.\n+     *\n+     * @param cctx Cache context.\n+     * @param config Cache configuration, that may be different from cache context.\n+     * @param clientCache Client cache or not.\n+     */\n+    public GridCacheContextInfo(GridCacheContext<K, V> cctx, CacheConfiguration<K, V> config, boolean clientCache) {\n+        this.config = new CacheConfiguration(config);", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg4NTYxOA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438885618", "bodyText": "See comment above.", "author": "ivandasch", "createdAt": "2020-06-11T15:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNDU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNDY2Nw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438834667", "bodyText": "Let's use new CacheConfiguration<> to remove compiler warning", "author": "nizhikov", "createdAt": "2020-06-11T14:37:26Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheContextInfo.java", "diffHunk": "@@ -69,7 +89,7 @@ public GridCacheContextInfo(GridCacheContext<K, V> cctx, boolean clientCache) {\n      * @param cacheDesc Cache descriptor.\n      */\n     public GridCacheContextInfo(DynamicCacheDescriptor cacheDesc) {\n-        config = cacheDesc.cacheConfiguration();\n+        config = new CacheConfiguration(cacheDesc.cacheConfiguration());", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NDQ1Mg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438954452", "bodyText": "This doesn't help, cacheDesc.config() returns not parameterized CacheConfiguration.", "author": "ivandasch", "createdAt": "2020-06-11T17:35:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNDY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNzQyNw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438837427", "bodyText": "Let's use\n        CacheConfiguration<?, ?> oldCfg = cacheCfg;\n\n        if (oldCfg != null) {\n            CacheConfiguration<?, ?> newCfg = new CacheConfiguration<>(oldCfg);\n\nto remove compiler warnings.", "author": "nizhikov", "createdAt": "2020-06-11T14:41:26Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheContext.java", "diffHunk": "@@ -2350,6 +2352,29 @@ public boolean hasContinuousQueryListeners(@Nullable IgniteInternalTx tx) {\n             contQryMgr.notifyContinuousQueries(tx) && !F.isEmpty(contQryMgr.updateListeners(false, false));\n     }\n \n+    /**\n+     * Apply changes from {@link SchemaAddQueryEntityOperation}\n+     *\n+     * @param op Add query entity schema operation.\n+     */\n+    public void onSchemaAddQueryEntity(SchemaAddQueryEntityOperation op) {\n+        CacheConfiguration oldCfg = cacheCfg;", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzODc2NQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438838765", "bodyText": "Can this method be invoked concurrently?", "author": "nizhikov", "createdAt": "2020-06-11T14:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNzQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MDA2Mg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438860062", "bodyText": "Yes, i copy reference on stack for thread safety. We should ensure that we write to cacheCfg reference to fully constructed object.", "author": "ivandasch", "createdAt": "2020-06-11T15:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgzNzQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0MDIwOQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438840209", "bodyText": "We have the same code inside DynamicCacheDescriptor#schemaChangeFinish and GridCacheContextInfo#onSchemaAddQueryEntity - let's deduplicate it and write in one place.", "author": "nizhikov", "createdAt": "2020-06-11T14:45:20Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheContext.java", "diffHunk": "@@ -2350,6 +2352,29 @@ public boolean hasContinuousQueryListeners(@Nullable IgniteInternalTx tx) {\n             contQryMgr.notifyContinuousQueries(tx) && !F.isEmpty(contQryMgr.updateListeners(false, false));\n     }\n \n+    /**\n+     * Apply changes from {@link SchemaAddQueryEntityOperation}\n+     *\n+     * @param op Add query entity schema operation.\n+     */\n+    public void onSchemaAddQueryEntity(SchemaAddQueryEntityOperation op) {\n+        CacheConfiguration oldCfg = cacheCfg;\n+\n+        if (oldCfg != null) {\n+            CacheConfiguration newCfg = new CacheConfiguration(oldCfg);\n+\n+            newCfg.setQueryEntities(Collections.singletonList(op.entity()));", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNDQwNw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438934407", "bodyText": "I suggest to move this code to GridCacheUtils", "author": "ivandasch", "createdAt": "2020-06-11T16:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0MDIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0NTQyOQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438845429", "bodyText": "Why this change? Let's revert it.", "author": "nizhikov", "createdAt": "2020-06-11T14:52:55Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/QuerySchemaPatch.java", "diffHunk": "@@ -33,24 +32,35 @@\n  */\n public class QuerySchemaPatch {\n     /** Message which described conflicts during creating this patch. */\n-    private String conflictsMessage;\n+    private final String conflictsMessage;", "originalCommit": "1458f3b1dd500e3bcb4daf11bf5ca41c9c5dc39f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg5MDY5NA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r438890694", "bodyText": "No, I disagree. Here obviously final modificator is forgotten. This field is semantically final, and QuerySchemaPatch is immutable object.", "author": "ivandasch", "createdAt": "2020-06-11T15:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0NTQyOQ=="}], "type": "inlineReview"}, {"oid": "d58e234804df866550099bd105fff3649c12e647", "url": "https://github.com/apache/ignite/commit/d58e234804df866550099bd105fff3649c12e647", "message": "IGNITE-12876 Extend test coverage to test deadlock absence between checkpoint, entry update and TTL worker - Fixes #7643.\n\nSigned-off-by: Alexey Goncharuk <alexey.goncharuk@gmail.com>", "committedDate": "2020-06-15T09:04:55Z", "type": "commit"}, {"oid": "522fab06c470a5081e051a87fabde5e990e13201", "url": "https://github.com/apache/ignite/commit/522fab06c470a5081e051a87fabde5e990e13201", "message": "IGNITE-13104 Fixed incorrect logic in spring-data repositories for findAllById() and deleteAllById() methods. Code cleanup. #7886 - Fixes #7886.\n\nSigned-off-by: Alexey Kuznetsov <akuznetsov@apache.org>", "committedDate": "2020-06-15T09:04:55Z", "type": "commit"}, {"oid": "71fa55189607d45bf1da73ccaa62e19a09750aaf", "url": "https://github.com/apache/ignite/commit/71fa55189607d45bf1da73ccaa62e19a09750aaf", "message": "IGNITE-13122: Fix NullPointerException on snapshot deletion (#7904)", "committedDate": "2020-06-15T09:04:55Z", "type": "commit"}, {"oid": "1609a2dd1d855fd5476c75a7f19e9687f743f584", "url": "https://github.com/apache/ignite/commit/1609a2dd1d855fd5476c75a7f19e9687f743f584", "message": "IGNITE-13105 Fixed cursors leak in RunningQueryManager. Code cleanup. #7888 - Fixes #7888.\n\nSigned-off-by: Alexey Kuznetsov <akuznetsov@apache.org>", "committedDate": "2020-06-15T09:04:55Z", "type": "commit"}, {"oid": "312778a94a42e9d89d593f83343fda5a61264fb9", "url": "https://github.com/apache/ignite/commit/312778a94a42e9d89d593f83343fda5a61264fb9", "message": "IGNITE-13071 Improve test coverage for read-only cluster state - Fixes #7853.\n\nSigned-off-by: Ivan Rakov <ivan.glukos@gmail.com>", "committedDate": "2020-06-15T09:04:56Z", "type": "commit"}, {"oid": "178d394e8f45519d222d979efece5000e69f6abf", "url": "https://github.com/apache/ignite/commit/178d394e8f45519d222d979efece5000e69f6abf", "message": "IGNITE-13103 Fix SerializedLambda deployment by not registering capturingClass with marshaller - Fixes #7880.\n\nSigned-off-by: Ilya Kasnacheev <ilya.kasnacheev@gmail.com>", "committedDate": "2020-06-15T09:04:56Z", "type": "commit"}, {"oid": "aa8ef19cd2606d14bfc2a6e8af6db08865a97d39", "url": "https://github.com/apache/ignite/commit/aa8ef19cd2606d14bfc2a6e8af6db08865a97d39", "message": "IGNITE-13096 Java thin client: Fix binary type schema registration for nested objects - Fixes #7878.\n\nSigned-off-by: Aleksey Plekhanov <plehanov.alex@gmail.com>", "committedDate": "2020-06-15T09:04:56Z", "type": "commit"}, {"oid": "ad87d42be52b44fac36b1ba13b0f31545e9d48de", "url": "https://github.com/apache/ignite/commit/ad87d42be52b44fac36b1ba13b0f31545e9d48de", "message": "IGNITE-13088 Avoid NPE being thrown from checkProxyIsValid on client restart - Fixes #7873.\n\nSigned-off-by: Ilya Kasnacheev <ilya.kasnacheev@gmail.com>", "committedDate": "2020-06-15T09:04:56Z", "type": "commit"}, {"oid": "7ce9f26f5aed3475251f824e2f0f18644d870774", "url": "https://github.com/apache/ignite/commit/7ce9f26f5aed3475251f824e2f0f18644d870774", "message": "IGNITE-13119 fix data race when getting index rebuild status (#7901)", "committedDate": "2020-06-15T09:15:42Z", "type": "commit"}, {"oid": "412914c63a8ad7e6c955939d38d24f55180ead01", "url": "https://github.com/apache/ignite/commit/412914c63a8ad7e6c955939d38d24f55180ead01", "message": "IGNITE-12808 Review fixes.", "committedDate": "2020-06-15T09:15:43Z", "type": "commit"}, {"oid": "4d9d24a8effd26cfdfd3125cf833a31b5e566b51", "url": "https://github.com/apache/ignite/commit/4d9d24a8effd26cfdfd3125cf833a31b5e566b51", "message": "Merge remote-tracking branch 'origin/master' into ignite-12808", "committedDate": "2020-06-15T09:29:06Z", "type": "commit"}, {"oid": "4027bcbc2e883b0c0f4f7012aa3068f49fe99998", "url": "https://github.com/apache/ignite/commit/4027bcbc2e883b0c0f4f7012aa3068f49fe99998", "message": "IGNITE-12808 Remove duplicate commited by mistake.", "committedDate": "2020-06-15T09:55:26Z", "type": "commit"}, {"oid": "529925f6546d6224c90637b2e4e75af4e8dd1e38", "url": "https://github.com/apache/ignite/commit/529925f6546d6224c90637b2e4e75af4e8dd1e38", "message": "IGNITE-12808 Remove double query parallelism", "committedDate": "2020-06-17T07:40:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM3MjE4OQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r441372189", "bodyText": "This the only place where rebuildInMemory=false.\nIt seems we can eliminate this new flag in the bellow methods if just add if here\n            if (cctx.group().persistenceEnabled())\n                return rebuildIndexesFromHash0(cctx);\n\nAlso we can just remove persistence check in the\n        // No data in fresh in-memory cache. If force, this meant that indexing is enabling dynamically.\n        if (!cctx.group().persistenceEnabled() && !rebuildInMemory)\n            return null;", "author": "nizhikov", "createdAt": "2020-06-17T08:27:09Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridQueryProcessor.java", "diffHunk": "@@ -2164,13 +2256,66 @@ private boolean rebuildIsMeaningless(GridCacheContext cctx) {\n         }\n \n         try {\n-            return idx.rebuildIndexesFromHash(cctx);\n+            return rebuildIndexesFromHash0(cctx, false);", "originalCommit": "529925f6546d6224c90637b2e4e75af4e8dd1e38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM5NzMzNg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r441397336", "bodyText": "It seems that this check is also redundant, fixed.", "author": "ivandasch", "createdAt": "2020-06-17T09:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM3MjE4OQ=="}], "type": "inlineReview"}, {"oid": "b1c4086d86b8433915acef77850fb9fd79d0517a", "url": "https://github.com/apache/ignite/commit/b1c4086d86b8433915acef77850fb9fd79d0517a", "message": "IGNITE-12808 Remove redundant param and condition from rebuild hash procedure.", "committedDate": "2020-06-17T08:57:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzOTI1Mw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r441439253", "bodyText": "Let's use a utility method here:\n                    if (!QueryUtils.isEnabled(cache.context().config()) &&\n                        QueryUtils.isEnabled(desc.cacheConfiguration())) {", "author": "nizhikov", "createdAt": "2020-06-17T10:15:53Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheProcessor.java", "diffHunk": "@@ -924,15 +924,23 @@ private void stopCacheOnReconnect(GridCacheContext cctx, List<GridCacheAdapter>\n                 reconnected.add(cache);\n \n                 if (cache.context().userCache()) {\n-                    // Re-create cache structures inside indexing in order to apply recent schema changes.\n-                    GridCacheContextInfo cacheInfo = new GridCacheContextInfo(cache.context(), false);\n+                    DynamicCacheDescriptor desc = cacheDescriptor(cache.name());\n \n-                    DynamicCacheDescriptor desc = cacheDescriptor(cacheInfo.name());\n+                    assert desc != null : cache.name();\n \n-                    assert desc != null : cacheInfo.name();\n+                    if (cache.context().config().getQueryEntities().isEmpty()", "originalCommit": "b1c4086d86b8433915acef77850fb9fd79d0517a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MTYyMg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r441451622", "bodyText": "Typo: dot in the end.", "author": "nizhikov", "createdAt": "2020-06-17T10:39:26Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheUtils.java", "diffHunk": "@@ -2121,6 +2122,43 @@ public static boolean isCacheTemplateName(String cacheName) {\n         return cacheName.endsWith(\"*\");\n     }\n \n+    /**\n+     * Patch cache configuration with {@link SchemaAddQueryEntityOperation}", "originalCommit": "b1c4086d86b8433915acef77850fb9fd79d0517a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MTY1NQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r441451655", "bodyText": "Typo: dot in the end.", "author": "nizhikov", "createdAt": "2020-06-17T10:39:32Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheUtils.java", "diffHunk": "@@ -2121,6 +2122,43 @@ public static boolean isCacheTemplateName(String cacheName) {\n         return cacheName.endsWith(\"*\");\n     }\n \n+    /**\n+     * Patch cache configuration with {@link SchemaAddQueryEntityOperation}\n+     *\n+     * @param oldCfg Old cache config.\n+     * @param op Schema add query entity operation.\n+     */\n+    public static <K, V> CacheConfiguration<K, V> patchCacheConfiguration(\n+            CacheConfiguration<K, V> oldCfg,\n+            SchemaAddQueryEntityOperation op\n+    ) {\n+        return patchCacheConfiguration(oldCfg, Collections.singletonList(op.entity()), op.schemaName(), op.isSqlEscape(),\n+                op.queryParallelism());\n+    }\n+\n+    /**\n+     * Patch cache configuration with {@link SchemaAddQueryEntityOperation}", "originalCommit": "b1c4086d86b8433915acef77850fb9fd79d0517a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "551097a9934e9dd3db02a9201b67fef2263b7275", "url": "https://github.com/apache/ignite/commit/551097a9934e9dd3db02a9201b67fef2263b7275", "message": "IGNITE-12808 Fix minor issues.", "committedDate": "2020-06-17T11:41:10Z", "type": "commit"}, {"oid": "71e71bf445d81f69cf60985d3c6551713239d7dc", "url": "https://github.com/apache/ignite/commit/71e71bf445d81f69cf60985d3c6551713239d7dc", "message": "IGNITE-12808 Rewrite schema patch without CacheConfiguration.", "committedDate": "2020-06-17T14:19:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU4ODk2MA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r441588960", "bodyText": "Let's use Collections.singletonList here and Collections.emptyList() to omit declaration of patchOperations, entityToAdd and localEntities.", "author": "nizhikov", "createdAt": "2020-06-17T14:28:23Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/QuerySchema.java", "diffHunk": "@@ -94,17 +97,41 @@ public QuerySchema copy() {\n      * @see QuerySchemaPatch\n      */\n     public QuerySchemaPatch makePatch(Collection<QueryEntity> target) {\n+        return makePatch(null, target);\n+    }\n+\n+    /**\n+     * Make query schema patch.\n+     *\n+     * @param targetCfg Cache configuration when it should be changed (enabling indexing dynamically).\n+     * @param target Query entity list to which current schema should be expanded.\n+     * @return Patch to achieve entity which is a result of merging current one and target.\n+     * @see QuerySchemaPatch\n+     */\n+    public QuerySchemaPatch makePatch(CacheConfiguration<?, ?> targetCfg, Collection<QueryEntity> target) {\n         synchronized (mux) {\n             Map<String, QueryEntity> localEntities = new HashMap<>();\n+            Collection<SchemaAbstractOperation> patchOperations = new ArrayList<>();\n+            Collection<QueryEntity> entityToAdd = new ArrayList<>();\n+\n+            if (entities.isEmpty() && targetCfg != null) {\n+                patchOperations.add(new SchemaAddQueryEntityOperation(\n+                    UUID.randomUUID(),\n+                    targetCfg.getName(),\n+                    targetCfg.getSqlSchema(),\n+                    target,\n+                    targetCfg.getQueryParallelism(),\n+                    targetCfg.isSqlEscapeAll()\n+                ));\n+\n+                return new QuerySchemaPatch(patchOperations, entityToAdd, \"\");", "originalCommit": "71e71bf445d81f69cf60985d3c6551713239d7dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU4OTk2OQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r441589969", "bodyText": "Let's use filter+forEach here instead of findFirst and isPresent.\n\n            if (res) {\n                patch.getPatchOperations().stream()\n                    .filter(op -> op instanceof SchemaAddQueryEntityOperation)\n                    .forEach(op -> cacheCfg = patchCacheConfiguration(cacheCfg, (SchemaAddQueryEntityOperation)op));\n            }", "author": "nizhikov", "createdAt": "2020-06-17T14:29:46Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/DynamicCacheDescriptor.java", "diffHunk": "@@ -387,7 +409,15 @@ public QuerySchemaPatch makeSchemaPatch(Collection<QueryEntity> target) {\n      */\n     public boolean applySchemaPatch(QuerySchemaPatch patch) {\n         synchronized (schemaMux) {\n-            return schema.applyPatch(patch);\n+            boolean res = schema.applyPatch(patch);\n+\n+            Optional<SchemaAbstractOperation> op = patch.getPatchOperations().stream()", "originalCommit": "71e71bf445d81f69cf60985d3c6551713239d7dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a003474970284bd565d339adb8a79099efd7357b", "url": "https://github.com/apache/ignite/commit/a003474970284bd565d339adb8a79099efd7357b", "message": "IGNITE-12808 Minor fixes.", "committedDate": "2020-06-17T14:51:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzNjg0MQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r441636841", "bodyText": "Let's return this assert in the last else branch.", "author": "nizhikov", "createdAt": "2020-06-17T15:30:54Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridQueryProcessor.java", "diffHunk": "@@ -952,8 +925,26 @@ else if (op0 instanceof SchemaAlterTableDropColumnOperation) {\n \n                                         processDynamicDropColumn(typeDesc, opDropCol.columns());\n                                     }\n-                                    else\n-                                        assert false;", "originalCommit": "a003474970284bd565d339adb8a79099efd7357b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0NTE2MA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r441645160", "bodyText": "Do we need this changes?\nSeems we can revert it.", "author": "nizhikov", "createdAt": "2020-06-17T15:43:30Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/QueryUtils.java", "diffHunk": "@@ -416,19 +415,21 @@ private static String aliasForFieldName(String fieldName) {\n      *\n      * @param cacheName Cache name.\n      * @param schemaName Schema name.\n-     * @param cacheInfo Cache context info.\n+     * @param ccfg Cache configuration.\n      * @param qryEntity Query entity.\n      * @param mustDeserializeClss Classes which must be deserialized.\n      * @param escape Escape flag.\n      * @return Type candidate.\n      * @throws IgniteCheckedException If failed.\n      */\n-    public static QueryTypeCandidate typeForQueryEntity(GridKernalContext ctx, String cacheName, String schemaName,\n-        GridCacheContextInfo cacheInfo,\n-        QueryEntity qryEntity, List<Class<?>> mustDeserializeClss, boolean escape)\n-        throws IgniteCheckedException {\n-        CacheConfiguration<?, ?> ccfg = cacheInfo.config();\n-\n+    public static QueryTypeCandidate typeForQueryEntity(", "originalCommit": "a003474970284bd565d339adb8a79099efd7357b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b9248f81a63dd03446e4e5755015d6df92a2ffdc", "url": "https://github.com/apache/ignite/commit/b9248f81a63dd03446e4e5755015d6df92a2ffdc", "message": "IGNITE-12808 Minor fixes.", "committedDate": "2020-06-17T15:47:48Z", "type": "commit"}, {"oid": "585ae01b43e73cebb1da486e12d4728d189e9b5e", "url": "https://github.com/apache/ignite/commit/585ae01b43e73cebb1da486e12d4728d189e9b5e", "message": "IGNITE-12808 Minor fixes.", "committedDate": "2020-06-17T15:57:06Z", "type": "commit"}, {"oid": "b0eb5aa7572b4ff236c24247af913d726c698f72", "url": "https://github.com/apache/ignite/commit/b0eb5aa7572b4ff236c24247af913d726c698f72", "message": "IGNITE-12808 Defactor validateNode", "committedDate": "2020-06-17T17:03:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NDUwMg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442044502", "bodyText": "Typo: only one space required.", "author": "nizhikov", "createdAt": "2020-06-18T08:07:49Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/operation/SchemaAddQueryEntityOperation.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.query.schema.operation;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+import org.apache.ignite.cache.QueryEntity;\n+\n+/**\n+ * Enabling indexing on cache operation.\n+ */\n+public class SchemaAddQueryEntityOperation extends SchemaAbstractOperation {\n+    /** */\n+    private static final long serialVersionUID = 0L;\n+\n+    /** */\n+    private final Collection<QueryEntity> entities;\n+\n+    /** */\n+    private final int qryParallelism;\n+\n+    /** */\n+    private final boolean sqlEscape;\n+\n+    /**\n+     * @param opId    Operation ID.", "originalCommit": "585ae01b43e73cebb1da486e12d4728d189e9b5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEwNDM4MA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442104380", "bodyText": "Can we rewrite this statement to make it more readable:\n(nop || (!cacheRegistered && !(op instanceof SchemaAddQueryEntityOperation)))\n\nWe want to say here: Complete the future if\n1. There is no operation OR\n2. Cache not registered AND operation is not SchemaAddQueryEntityOperation", "author": "nizhikov", "createdAt": "2020-06-18T09:46:23Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/SchemaOperationWorker.java", "diffHunk": "@@ -95,7 +96,7 @@ public SchemaOperationWorker(GridKernalContext ctx, GridQueryProcessor qryProc,\n \n         if (err != null)\n             fut.onDone(err);\n-        else if (nop || !cacheRegistered)\n+        else if (nop || !(cacheRegistered || op instanceof SchemaAddQueryEntityOperation))", "originalCommit": "b0eb5aa7572b4ff236c24247af913d726c698f72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExNzI1Mw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442117253", "bodyText": "Typo: An empty line should be omitted.", "author": "nizhikov", "createdAt": "2020-06-18T10:09:02Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/H2DynamicTableSelfTest.java", "diffHunk": "@@ -326,26 +326,51 @@ public void testCustomCacheAndKeyAndValueTypeName() {\n     }\n \n     /**\n-     * Test that attempting to create a cache with a pre-existing name yields an error.\n+     * Test creating table over existing cache (enabling query.)\n      * @throws Exception if failed.\n      */\n     @Test\n-    public void testDuplicateCustomCacheName() throws Exception {\n+    public void testCreateTableOnExistingCache() throws Exception {\n         client().getOrCreateCache(\"new\");\n \n         try {\n+            doTestCustomNames(\"new\", null, null);\n+\n             GridTestUtils.assertThrows(null, new Callable<Object>() {\n                 @Override public Object call() throws Exception {\n                     doTestCustomNames(\"new\", null, null);\n                     return null;\n                 }\n             }, IgniteSQLException.class, \"Table already exists: NameTest\");\n+\n         }\n         finally {\n             client().destroyCache(\"new\");\n         }\n     }\n \n+    /**\n+     * Test creating table over existing LOCAL cache fails (enabling query.)\n+     * @throws Exception if failed.\n+     */\n+    @Test\n+    public void testCreateTableOnExistingLocalCache() throws Exception {\n+        client().getOrCreateCache(new CacheConfiguration<>(\"local\").setCacheMode(CacheMode.LOCAL));\n+\n+        try {\n+            GridTestUtils.assertThrows(null, new Callable<Object>() {\n+                @Override public Object call() throws Exception {\n+                    doTestCustomNames(\"local\", null, null);\n+                    return null;\n+                }\n+            }, IgniteSQLException.class, \"Schema changes are not supported for LOCAL cache\");\n+", "originalCommit": "b0eb5aa7572b4ff236c24247af913d726c698f72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExNzMyNw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442117327", "bodyText": "Typo: An empty line should be omitted.", "author": "nizhikov", "createdAt": "2020-06-18T10:09:11Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/H2DynamicTableSelfTest.java", "diffHunk": "@@ -326,26 +326,51 @@ public void testCustomCacheAndKeyAndValueTypeName() {\n     }\n \n     /**\n-     * Test that attempting to create a cache with a pre-existing name yields an error.\n+     * Test creating table over existing cache (enabling query.)\n      * @throws Exception if failed.\n      */\n     @Test\n-    public void testDuplicateCustomCacheName() throws Exception {\n+    public void testCreateTableOnExistingCache() throws Exception {\n         client().getOrCreateCache(\"new\");\n \n         try {\n+            doTestCustomNames(\"new\", null, null);\n+\n             GridTestUtils.assertThrows(null, new Callable<Object>() {\n                 @Override public Object call() throws Exception {\n                     doTestCustomNames(\"new\", null, null);\n                     return null;\n                 }\n             }, IgniteSQLException.class, \"Table already exists: NameTest\");\n+", "originalCommit": "b0eb5aa7572b4ff236c24247af913d726c698f72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b6715390246bf46c3dda3ae2cad6279b26bd1977", "url": "https://github.com/apache/ignite/commit/b6715390246bf46c3dda3ae2cad6279b26bd1977", "message": "IGNITE-12808 Add more tests.", "committedDate": "2020-06-18T10:09:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyMzgzNg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442123836", "bodyText": "Typo: Extra layer of indentation should be omitted.", "author": "nizhikov", "createdAt": "2020-06-18T10:20:48Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingAbstractTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.query.h2.H2TableDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.database.H2TreeIndex;\n+import org.apache.ignite.internal.util.typedef.PA;\n+import org.apache.ignite.lang.IgnitePredicate;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+/**\n+ * Base class for enable indexing tests.\n+ */\n+public class DynamicEnableIndexingAbstractTest extends GridCommonAbstractTest {\n+    /** Node index for regular server (coordinator). */\n+    protected static final int IDX_SRV_CRD = 0;\n+\n+    /** Node index for regular server (not coordinator). */\n+    protected static final int IDX_SRV_NON_CRD = 1;\n+\n+    /** Node index for regular client. */\n+    protected static final int IDX_CLI = 2;\n+\n+    /** Node index for server which doesn't pass node filter. */\n+    protected static final int IDX_SRV_FILTERED = 3;\n+\n+    /** Node index for client with near-only cache. */\n+    protected static final int IDX_CLI_NEAR_ONLY = 4;\n+\n+    /** Attribute to filter node out of cache data nodes. */\n+    protected static final String ATTR_FILTERED = \"FILTERED\";\n+\n+    /** */\n+    protected static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    protected static final int NUM_ENTRIES = 1000;\n+\n+    /** */\n+    static final String POI_SCHEMA_NAME = \"DOMAIN\";\n+\n+    /** */\n+    protected static final String POI_TABLE_NAME = \"POI\";\n+\n+    /** */\n+    protected static final String POI_CLASS_NAME = \"PointOfInterest\";\n+\n+    /** */\n+    protected static final String ID_FIELD_NAME = \"id\";\n+\n+    /** */\n+    protected static final String NAME_FIELD_NAME = \"name\";\n+\n+    /** */\n+    protected static final String KEY_PK_IDX_NAME = \"_key_PK\";\n+\n+    /** */\n+    protected static final String LATITUDE_FIELD_NAME = \"latitude\";\n+\n+    /** */\n+    protected static final String LONGITUDE_FIELD_NAME = \"longitude\";\n+\n+    /** */\n+    protected static final String SELECT_ALL_QUERY = String.format(\"SELECT * FROM %s\", POI_TABLE_NAME);\n+\n+    /** */\n+    protected static final int QUERY_PARALLELISM = 4;\n+\n+    /** */\n+    protected void createTable(IgniteCache<?, ?> cache, int qryParallelism) {\n+        cache.query(new SqlFieldsQuery(\n+                String.format(\"CREATE TABLE %s.%s \" +\n+                                \"(%s INT, %s VARCHAR,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" PRIMARY KEY (%s)\" +\n+                                \") WITH \" +\n+                                \" \\\"CACHE_NAME=%s,VALUE_TYPE=%s,PARALLELISM=%d\\\"\",\n+                        POI_SCHEMA_NAME, POI_TABLE_NAME, ID_FIELD_NAME, NAME_FIELD_NAME,\n+                        LATITUDE_FIELD_NAME, LONGITUDE_FIELD_NAME, ID_FIELD_NAME,\n+                        POI_CACHE_NAME, POI_CLASS_NAME, qryParallelism)\n+        ));\n+    }\n+\n+    /** */\n+    protected List<IgniteConfiguration> configurations() throws Exception {\n+        return Arrays.asList(\n+                serverConfiguration(IDX_SRV_CRD),", "originalCommit": "b6715390246bf46c3dda3ae2cad6279b26bd1977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3590fad1a5ede8d6609170525cedc7c4742d3feb", "url": "https://github.com/apache/ignite/commit/3590fad1a5ede8d6609170525cedc7c4742d3feb", "message": "IGNITE-12808 Minors.", "committedDate": "2020-06-18T10:21:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNjQxMA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442126410", "bodyText": "Typo: Extra layer of indentation should be omitted.", "author": "nizhikov", "createdAt": "2020-06-18T10:25:45Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingAbstractTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.query.h2.H2TableDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.database.H2TreeIndex;\n+import org.apache.ignite.internal.util.typedef.PA;\n+import org.apache.ignite.lang.IgnitePredicate;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+/**\n+ * Base class for enable indexing tests.\n+ */\n+public class DynamicEnableIndexingAbstractTest extends GridCommonAbstractTest {\n+    /** Node index for regular server (coordinator). */\n+    protected static final int IDX_SRV_CRD = 0;\n+\n+    /** Node index for regular server (not coordinator). */\n+    protected static final int IDX_SRV_NON_CRD = 1;\n+\n+    /** Node index for regular client. */\n+    protected static final int IDX_CLI = 2;\n+\n+    /** Node index for server which doesn't pass node filter. */\n+    protected static final int IDX_SRV_FILTERED = 3;\n+\n+    /** Node index for client with near-only cache. */\n+    protected static final int IDX_CLI_NEAR_ONLY = 4;\n+\n+    /** Attribute to filter node out of cache data nodes. */\n+    protected static final String ATTR_FILTERED = \"FILTERED\";\n+\n+    /** */\n+    protected static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    protected static final int NUM_ENTRIES = 1000;\n+\n+    /** */\n+    static final String POI_SCHEMA_NAME = \"DOMAIN\";\n+\n+    /** */\n+    protected static final String POI_TABLE_NAME = \"POI\";\n+\n+    /** */\n+    protected static final String POI_CLASS_NAME = \"PointOfInterest\";\n+\n+    /** */\n+    protected static final String ID_FIELD_NAME = \"id\";\n+\n+    /** */\n+    protected static final String NAME_FIELD_NAME = \"name\";\n+\n+    /** */\n+    protected static final String KEY_PK_IDX_NAME = \"_key_PK\";\n+\n+    /** */\n+    protected static final String LATITUDE_FIELD_NAME = \"latitude\";\n+\n+    /** */\n+    protected static final String LONGITUDE_FIELD_NAME = \"longitude\";\n+\n+    /** */\n+    protected static final String SELECT_ALL_QUERY = String.format(\"SELECT * FROM %s\", POI_TABLE_NAME);\n+\n+    /** */\n+    protected static final int QUERY_PARALLELISM = 4;\n+\n+    /** */\n+    protected void createTable(IgniteCache<?, ?> cache, int qryParallelism) {\n+        cache.query(new SqlFieldsQuery(\n+                String.format(\"CREATE TABLE %s.%s \" +\n+                                \"(%s INT, %s VARCHAR,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" PRIMARY KEY (%s)\" +\n+                                \") WITH \" +\n+                                \" \\\"CACHE_NAME=%s,VALUE_TYPE=%s,PARALLELISM=%d\\\"\",\n+                        POI_SCHEMA_NAME, POI_TABLE_NAME, ID_FIELD_NAME, NAME_FIELD_NAME,\n+                        LATITUDE_FIELD_NAME, LONGITUDE_FIELD_NAME, ID_FIELD_NAME,\n+                        POI_CACHE_NAME, POI_CLASS_NAME, qryParallelism)\n+        ));\n+    }\n+\n+    /** */\n+    protected List<IgniteConfiguration> configurations() throws Exception {\n+        return Arrays.asList(\n+                serverConfiguration(IDX_SRV_CRD),\n+                serverConfiguration(IDX_SRV_NON_CRD),\n+                clientConfiguration(IDX_CLI),\n+                serverConfiguration(IDX_SRV_FILTERED, true),\n+                clientConfiguration(IDX_CLI_NEAR_ONLY)\n+        );\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration clientConfiguration(int idx) throws Exception {\n+        return commonConfiguration(idx).setClientMode(true);\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration serverConfiguration(int idx) throws Exception {\n+        return serverConfiguration(idx, false);\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration serverConfiguration(int idx, boolean filter) throws Exception {\n+        IgniteConfiguration cfg = commonConfiguration(idx);\n+\n+        if (filter)\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_FILTERED, true));\n+\n+        return cfg;\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration commonConfiguration(int idx) throws Exception {\n+        String gridName = getTestIgniteInstanceName(idx);\n+\n+        IgniteConfiguration cfg = getConfiguration(gridName);\n+\n+        cfg.setClusterStateOnStart(ClusterState.INACTIVE);\n+\n+        DataStorageConfiguration memCfg = new DataStorageConfiguration()\n+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(128 * 1024 * 1024));\n+\n+        cfg.setDataStorageConfiguration(memCfg);\n+\n+        cfg.setConsistentId(gridName);\n+\n+        cfg.setSqlSchemas(POI_SCHEMA_NAME);\n+\n+        return optimize(cfg);\n+    }\n+\n+    /** */\n+    protected CacheConfiguration<?, ?> testCacheConfiguration(\n+            String name,", "originalCommit": "b6715390246bf46c3dda3ae2cad6279b26bd1977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNjg1Mw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442126853", "bodyText": "Typo: empty line here and below should be removed", "author": "nizhikov", "createdAt": "2020-06-18T10:26:41Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingAbstractTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.query.h2.H2TableDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.database.H2TreeIndex;\n+import org.apache.ignite.internal.util.typedef.PA;\n+import org.apache.ignite.lang.IgnitePredicate;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+/**\n+ * Base class for enable indexing tests.\n+ */\n+public class DynamicEnableIndexingAbstractTest extends GridCommonAbstractTest {\n+    /** Node index for regular server (coordinator). */\n+    protected static final int IDX_SRV_CRD = 0;\n+\n+    /** Node index for regular server (not coordinator). */\n+    protected static final int IDX_SRV_NON_CRD = 1;\n+\n+    /** Node index for regular client. */\n+    protected static final int IDX_CLI = 2;\n+\n+    /** Node index for server which doesn't pass node filter. */\n+    protected static final int IDX_SRV_FILTERED = 3;\n+\n+    /** Node index for client with near-only cache. */\n+    protected static final int IDX_CLI_NEAR_ONLY = 4;\n+\n+    /** Attribute to filter node out of cache data nodes. */\n+    protected static final String ATTR_FILTERED = \"FILTERED\";\n+\n+    /** */\n+    protected static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    protected static final int NUM_ENTRIES = 1000;\n+\n+    /** */\n+    static final String POI_SCHEMA_NAME = \"DOMAIN\";\n+\n+    /** */\n+    protected static final String POI_TABLE_NAME = \"POI\";\n+\n+    /** */\n+    protected static final String POI_CLASS_NAME = \"PointOfInterest\";\n+\n+    /** */\n+    protected static final String ID_FIELD_NAME = \"id\";\n+\n+    /** */\n+    protected static final String NAME_FIELD_NAME = \"name\";\n+\n+    /** */\n+    protected static final String KEY_PK_IDX_NAME = \"_key_PK\";\n+\n+    /** */\n+    protected static final String LATITUDE_FIELD_NAME = \"latitude\";\n+\n+    /** */\n+    protected static final String LONGITUDE_FIELD_NAME = \"longitude\";\n+\n+    /** */\n+    protected static final String SELECT_ALL_QUERY = String.format(\"SELECT * FROM %s\", POI_TABLE_NAME);\n+\n+    /** */\n+    protected static final int QUERY_PARALLELISM = 4;\n+\n+    /** */\n+    protected void createTable(IgniteCache<?, ?> cache, int qryParallelism) {\n+        cache.query(new SqlFieldsQuery(\n+                String.format(\"CREATE TABLE %s.%s \" +\n+                                \"(%s INT, %s VARCHAR,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" PRIMARY KEY (%s)\" +\n+                                \") WITH \" +\n+                                \" \\\"CACHE_NAME=%s,VALUE_TYPE=%s,PARALLELISM=%d\\\"\",\n+                        POI_SCHEMA_NAME, POI_TABLE_NAME, ID_FIELD_NAME, NAME_FIELD_NAME,\n+                        LATITUDE_FIELD_NAME, LONGITUDE_FIELD_NAME, ID_FIELD_NAME,\n+                        POI_CACHE_NAME, POI_CLASS_NAME, qryParallelism)\n+        ));\n+    }\n+\n+    /** */\n+    protected List<IgniteConfiguration> configurations() throws Exception {\n+        return Arrays.asList(\n+                serverConfiguration(IDX_SRV_CRD),\n+                serverConfiguration(IDX_SRV_NON_CRD),\n+                clientConfiguration(IDX_CLI),\n+                serverConfiguration(IDX_SRV_FILTERED, true),\n+                clientConfiguration(IDX_CLI_NEAR_ONLY)\n+        );\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration clientConfiguration(int idx) throws Exception {\n+        return commonConfiguration(idx).setClientMode(true);\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration serverConfiguration(int idx) throws Exception {\n+        return serverConfiguration(idx, false);\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration serverConfiguration(int idx, boolean filter) throws Exception {\n+        IgniteConfiguration cfg = commonConfiguration(idx);\n+\n+        if (filter)\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_FILTERED, true));\n+\n+        return cfg;\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration commonConfiguration(int idx) throws Exception {\n+        String gridName = getTestIgniteInstanceName(idx);\n+\n+        IgniteConfiguration cfg = getConfiguration(gridName);\n+\n+        cfg.setClusterStateOnStart(ClusterState.INACTIVE);\n+\n+        DataStorageConfiguration memCfg = new DataStorageConfiguration()\n+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(128 * 1024 * 1024));\n+\n+        cfg.setDataStorageConfiguration(memCfg);\n+", "originalCommit": "b6715390246bf46c3dda3ae2cad6279b26bd1977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE0MTIzMA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442141230", "bodyText": "Let's use java8 lambda here.", "author": "nizhikov", "createdAt": "2020-06-18T10:55:03Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingAbstractTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.query.h2.H2TableDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.database.H2TreeIndex;\n+import org.apache.ignite.internal.util.typedef.PA;\n+import org.apache.ignite.lang.IgnitePredicate;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+/**\n+ * Base class for enable indexing tests.\n+ */\n+public class DynamicEnableIndexingAbstractTest extends GridCommonAbstractTest {\n+    /** Node index for regular server (coordinator). */\n+    protected static final int IDX_SRV_CRD = 0;\n+\n+    /** Node index for regular server (not coordinator). */\n+    protected static final int IDX_SRV_NON_CRD = 1;\n+\n+    /** Node index for regular client. */\n+    protected static final int IDX_CLI = 2;\n+\n+    /** Node index for server which doesn't pass node filter. */\n+    protected static final int IDX_SRV_FILTERED = 3;\n+\n+    /** Node index for client with near-only cache. */\n+    protected static final int IDX_CLI_NEAR_ONLY = 4;\n+\n+    /** Attribute to filter node out of cache data nodes. */\n+    protected static final String ATTR_FILTERED = \"FILTERED\";\n+\n+    /** */\n+    protected static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    protected static final int NUM_ENTRIES = 1000;\n+\n+    /** */\n+    static final String POI_SCHEMA_NAME = \"DOMAIN\";\n+\n+    /** */\n+    protected static final String POI_TABLE_NAME = \"POI\";\n+\n+    /** */\n+    protected static final String POI_CLASS_NAME = \"PointOfInterest\";\n+\n+    /** */\n+    protected static final String ID_FIELD_NAME = \"id\";\n+\n+    /** */\n+    protected static final String NAME_FIELD_NAME = \"name\";\n+\n+    /** */\n+    protected static final String KEY_PK_IDX_NAME = \"_key_PK\";\n+\n+    /** */\n+    protected static final String LATITUDE_FIELD_NAME = \"latitude\";\n+\n+    /** */\n+    protected static final String LONGITUDE_FIELD_NAME = \"longitude\";\n+\n+    /** */\n+    protected static final String SELECT_ALL_QUERY = String.format(\"SELECT * FROM %s\", POI_TABLE_NAME);\n+\n+    /** */\n+    protected static final int QUERY_PARALLELISM = 4;\n+\n+    /** */\n+    protected void createTable(IgniteCache<?, ?> cache, int qryParallelism) {\n+        cache.query(new SqlFieldsQuery(\n+                String.format(\"CREATE TABLE %s.%s \" +\n+                                \"(%s INT, %s VARCHAR,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" PRIMARY KEY (%s)\" +\n+                                \") WITH \" +\n+                                \" \\\"CACHE_NAME=%s,VALUE_TYPE=%s,PARALLELISM=%d\\\"\",\n+                        POI_SCHEMA_NAME, POI_TABLE_NAME, ID_FIELD_NAME, NAME_FIELD_NAME,\n+                        LATITUDE_FIELD_NAME, LONGITUDE_FIELD_NAME, ID_FIELD_NAME,\n+                        POI_CACHE_NAME, POI_CLASS_NAME, qryParallelism)\n+        ));\n+    }\n+\n+    /** */\n+    protected List<IgniteConfiguration> configurations() throws Exception {\n+        return Arrays.asList(\n+                serverConfiguration(IDX_SRV_CRD),\n+                serverConfiguration(IDX_SRV_NON_CRD),\n+                clientConfiguration(IDX_CLI),\n+                serverConfiguration(IDX_SRV_FILTERED, true),\n+                clientConfiguration(IDX_CLI_NEAR_ONLY)\n+        );\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration clientConfiguration(int idx) throws Exception {\n+        return commonConfiguration(idx).setClientMode(true);\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration serverConfiguration(int idx) throws Exception {\n+        return serverConfiguration(idx, false);\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration serverConfiguration(int idx, boolean filter) throws Exception {\n+        IgniteConfiguration cfg = commonConfiguration(idx);\n+\n+        if (filter)\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_FILTERED, true));\n+\n+        return cfg;\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration commonConfiguration(int idx) throws Exception {\n+        String gridName = getTestIgniteInstanceName(idx);\n+\n+        IgniteConfiguration cfg = getConfiguration(gridName);\n+\n+        cfg.setClusterStateOnStart(ClusterState.INACTIVE);\n+\n+        DataStorageConfiguration memCfg = new DataStorageConfiguration()\n+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(128 * 1024 * 1024));\n+\n+        cfg.setDataStorageConfiguration(memCfg);\n+\n+        cfg.setConsistentId(gridName);\n+\n+        cfg.setSqlSchemas(POI_SCHEMA_NAME);\n+\n+        return optimize(cfg);\n+    }\n+\n+    /** */\n+    protected CacheConfiguration<?, ?> testCacheConfiguration(\n+            String name,\n+            CacheMode mode,\n+            CacheAtomicityMode atomicityMode\n+    ) {\n+        return new CacheConfiguration<>(name)\n+                .setNodeFilter(new DynamicEnableIndexingBasicSelfTest.NodeFilter())\n+                .setAtomicityMode(atomicityMode)\n+                .setWriteSynchronizationMode(CacheWriteSynchronizationMode.FULL_SYNC)\n+                .setCacheMode(mode);\n+    }\n+\n+    /** */\n+    protected void loadData(IgniteEx node, int start, int end) {\n+        try (IgniteDataStreamer<Object, Object> streamer = node.dataStreamer(POI_CACHE_NAME)) {\n+            Random rnd = ThreadLocalRandom.current();\n+\n+            for (int i = start; i < end; i++) {\n+                BinaryObject bo = node.binary().builder(POI_CLASS_NAME)\n+                        .setField(NAME_FIELD_NAME, \"POI_\" + i, String.class)\n+                        .setField(LATITUDE_FIELD_NAME, rnd.nextDouble(), Double.class)\n+                        .setField(LONGITUDE_FIELD_NAME, rnd.nextDouble(), Double.class)\n+                        .build();\n+\n+                streamer.addData(i, bo);\n+            }\n+        }\n+    }\n+\n+    /** */\n+    protected void performQueryingIntegrityCheck(Ignite ig) throws Exception {\n+        performQueryingIntegrityCheck(ig, 100);\n+    }\n+\n+    /** */\n+    protected List<List<?>> query(Ignite ig, String sql) throws Exception {\n+        IgniteCache<Object, Object> cache = ig.cache(POI_CACHE_NAME).withKeepBinary();\n+\n+        return cache.query(new SqlFieldsQuery(sql).setSchema(POI_SCHEMA_NAME)).getAll();\n+    }\n+\n+    /** */\n+    protected void performQueryingIntegrityCheck(Ignite ig, int key) throws Exception {\n+        IgniteCache<Object, Object> cache = ig.cache(POI_CACHE_NAME).withKeepBinary();\n+\n+        List<List<?>> res = cache.query(new SqlFieldsQuery(\n+                    String.format(\"DELETE FROM %s WHERE %s = %d\", POI_TABLE_NAME, ID_FIELD_NAME, key))\n+                .setSchema(POI_SCHEMA_NAME)).getAll();\n+\n+        assertEquals(1, res.size());\n+        assertNull(cache.get(key));\n+\n+        res = cache.query(new SqlFieldsQuery(\n+                String.format(\n+                        \"INSERT INTO %s(%s) VALUES (%s)\",\n+                        POI_TABLE_NAME,\n+                        String.join(\",\", ID_FIELD_NAME, NAME_FIELD_NAME),\n+                        String.join(\",\", String.valueOf(key),\"'test'\"))\n+        ).setSchema(POI_SCHEMA_NAME)).getAll();\n+\n+        assertEquals(1, res.size());\n+        assertNotNull(cache.get(key));\n+\n+        res = cache.query(new SqlFieldsQuery(String.format(\"UPDATE %s SET %s = '%s' WHERE ID = %d\",\n+                POI_TABLE_NAME, NAME_FIELD_NAME, \"POI_\" + key, key)).setSchema(POI_SCHEMA_NAME)).getAll();\n+\n+        assertEquals(1, res.size());\n+        assertEquals(\"POI_\" + key, ((BinaryObject)cache.get(key)).field(NAME_FIELD_NAME));\n+\n+        assertIndexUsed(cache, \"SELECT * FROM \" + POI_TABLE_NAME + \" WHERE ID = \" + key, KEY_PK_IDX_NAME);\n+    }\n+\n+    /** */\n+    protected String explainPlan(IgniteCache<?, ?> cache, String sql) {\n+        return cache.query(new SqlFieldsQuery(\"EXPLAIN \" + sql).setSchema(POI_SCHEMA_NAME))\n+                .getAll().get(0).get(0).toString().toLowerCase();\n+    }\n+\n+    /** */\n+    protected void assertIndexUsed(IgniteCache<?, ?> cache, String sql, String idx) throws IgniteCheckedException {\n+        AtomicReference<String> currPlan = new AtomicReference<>();\n+\n+        boolean res = GridTestUtils.waitForCondition(new PA() {", "originalCommit": "3590fad1a5ede8d6609170525cedc7c4742d3feb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE0MTg0Nw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442141847", "bodyText": "Typo: Extra layer of indentation should be omitted.", "author": "nizhikov", "createdAt": "2020-06-18T10:56:13Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingAbstractTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.query.h2.H2TableDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.database.H2TreeIndex;\n+import org.apache.ignite.internal.util.typedef.PA;\n+import org.apache.ignite.lang.IgnitePredicate;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+/**\n+ * Base class for enable indexing tests.\n+ */\n+public class DynamicEnableIndexingAbstractTest extends GridCommonAbstractTest {\n+    /** Node index for regular server (coordinator). */\n+    protected static final int IDX_SRV_CRD = 0;\n+\n+    /** Node index for regular server (not coordinator). */\n+    protected static final int IDX_SRV_NON_CRD = 1;\n+\n+    /** Node index for regular client. */\n+    protected static final int IDX_CLI = 2;\n+\n+    /** Node index for server which doesn't pass node filter. */\n+    protected static final int IDX_SRV_FILTERED = 3;\n+\n+    /** Node index for client with near-only cache. */\n+    protected static final int IDX_CLI_NEAR_ONLY = 4;\n+\n+    /** Attribute to filter node out of cache data nodes. */\n+    protected static final String ATTR_FILTERED = \"FILTERED\";\n+\n+    /** */\n+    protected static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    protected static final int NUM_ENTRIES = 1000;\n+\n+    /** */\n+    static final String POI_SCHEMA_NAME = \"DOMAIN\";\n+\n+    /** */\n+    protected static final String POI_TABLE_NAME = \"POI\";\n+\n+    /** */\n+    protected static final String POI_CLASS_NAME = \"PointOfInterest\";\n+\n+    /** */\n+    protected static final String ID_FIELD_NAME = \"id\";\n+\n+    /** */\n+    protected static final String NAME_FIELD_NAME = \"name\";\n+\n+    /** */\n+    protected static final String KEY_PK_IDX_NAME = \"_key_PK\";\n+\n+    /** */\n+    protected static final String LATITUDE_FIELD_NAME = \"latitude\";\n+\n+    /** */\n+    protected static final String LONGITUDE_FIELD_NAME = \"longitude\";\n+\n+    /** */\n+    protected static final String SELECT_ALL_QUERY = String.format(\"SELECT * FROM %s\", POI_TABLE_NAME);\n+\n+    /** */\n+    protected static final int QUERY_PARALLELISM = 4;\n+\n+    /** */\n+    protected void createTable(IgniteCache<?, ?> cache, int qryParallelism) {\n+        cache.query(new SqlFieldsQuery(\n+                String.format(\"CREATE TABLE %s.%s \" +\n+                                \"(%s INT, %s VARCHAR,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" PRIMARY KEY (%s)\" +\n+                                \") WITH \" +\n+                                \" \\\"CACHE_NAME=%s,VALUE_TYPE=%s,PARALLELISM=%d\\\"\",\n+                        POI_SCHEMA_NAME, POI_TABLE_NAME, ID_FIELD_NAME, NAME_FIELD_NAME,\n+                        LATITUDE_FIELD_NAME, LONGITUDE_FIELD_NAME, ID_FIELD_NAME,\n+                        POI_CACHE_NAME, POI_CLASS_NAME, qryParallelism)\n+        ));\n+    }\n+\n+    /** */\n+    protected List<IgniteConfiguration> configurations() throws Exception {\n+        return Arrays.asList(\n+                serverConfiguration(IDX_SRV_CRD),\n+                serverConfiguration(IDX_SRV_NON_CRD),\n+                clientConfiguration(IDX_CLI),\n+                serverConfiguration(IDX_SRV_FILTERED, true),\n+                clientConfiguration(IDX_CLI_NEAR_ONLY)\n+        );\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration clientConfiguration(int idx) throws Exception {\n+        return commonConfiguration(idx).setClientMode(true);\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration serverConfiguration(int idx) throws Exception {\n+        return serverConfiguration(idx, false);\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration serverConfiguration(int idx, boolean filter) throws Exception {\n+        IgniteConfiguration cfg = commonConfiguration(idx);\n+\n+        if (filter)\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_FILTERED, true));\n+\n+        return cfg;\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration commonConfiguration(int idx) throws Exception {\n+        String gridName = getTestIgniteInstanceName(idx);\n+\n+        IgniteConfiguration cfg = getConfiguration(gridName);\n+\n+        cfg.setClusterStateOnStart(ClusterState.INACTIVE);\n+\n+        DataStorageConfiguration memCfg = new DataStorageConfiguration()\n+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(128 * 1024 * 1024));\n+\n+        cfg.setDataStorageConfiguration(memCfg);\n+\n+        cfg.setConsistentId(gridName);\n+\n+        cfg.setSqlSchemas(POI_SCHEMA_NAME);\n+\n+        return optimize(cfg);\n+    }\n+\n+    /** */\n+    protected CacheConfiguration<?, ?> testCacheConfiguration(\n+            String name,\n+            CacheMode mode,\n+            CacheAtomicityMode atomicityMode\n+    ) {\n+        return new CacheConfiguration<>(name)\n+                .setNodeFilter(new DynamicEnableIndexingBasicSelfTest.NodeFilter())\n+                .setAtomicityMode(atomicityMode)\n+                .setWriteSynchronizationMode(CacheWriteSynchronizationMode.FULL_SYNC)\n+                .setCacheMode(mode);\n+    }\n+\n+    /** */\n+    protected void loadData(IgniteEx node, int start, int end) {\n+        try (IgniteDataStreamer<Object, Object> streamer = node.dataStreamer(POI_CACHE_NAME)) {\n+            Random rnd = ThreadLocalRandom.current();\n+\n+            for (int i = start; i < end; i++) {\n+                BinaryObject bo = node.binary().builder(POI_CLASS_NAME)\n+                        .setField(NAME_FIELD_NAME, \"POI_\" + i, String.class)", "originalCommit": "3590fad1a5ede8d6609170525cedc7c4742d3feb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjE0MjE4Nw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442142187", "bodyText": "Typo: Extra layer of indentation should be omitted.", "author": "nizhikov", "createdAt": "2020-06-18T10:56:57Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingAbstractTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.query.h2.H2TableDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.database.H2TreeIndex;\n+import org.apache.ignite.internal.util.typedef.PA;\n+import org.apache.ignite.lang.IgnitePredicate;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+/**\n+ * Base class for enable indexing tests.\n+ */\n+public class DynamicEnableIndexingAbstractTest extends GridCommonAbstractTest {\n+    /** Node index for regular server (coordinator). */\n+    protected static final int IDX_SRV_CRD = 0;\n+\n+    /** Node index for regular server (not coordinator). */\n+    protected static final int IDX_SRV_NON_CRD = 1;\n+\n+    /** Node index for regular client. */\n+    protected static final int IDX_CLI = 2;\n+\n+    /** Node index for server which doesn't pass node filter. */\n+    protected static final int IDX_SRV_FILTERED = 3;\n+\n+    /** Node index for client with near-only cache. */\n+    protected static final int IDX_CLI_NEAR_ONLY = 4;\n+\n+    /** Attribute to filter node out of cache data nodes. */\n+    protected static final String ATTR_FILTERED = \"FILTERED\";\n+\n+    /** */\n+    protected static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    protected static final int NUM_ENTRIES = 1000;\n+\n+    /** */\n+    static final String POI_SCHEMA_NAME = \"DOMAIN\";\n+\n+    /** */\n+    protected static final String POI_TABLE_NAME = \"POI\";\n+\n+    /** */\n+    protected static final String POI_CLASS_NAME = \"PointOfInterest\";\n+\n+    /** */\n+    protected static final String ID_FIELD_NAME = \"id\";\n+\n+    /** */\n+    protected static final String NAME_FIELD_NAME = \"name\";\n+\n+    /** */\n+    protected static final String KEY_PK_IDX_NAME = \"_key_PK\";\n+\n+    /** */\n+    protected static final String LATITUDE_FIELD_NAME = \"latitude\";\n+\n+    /** */\n+    protected static final String LONGITUDE_FIELD_NAME = \"longitude\";\n+\n+    /** */\n+    protected static final String SELECT_ALL_QUERY = String.format(\"SELECT * FROM %s\", POI_TABLE_NAME);\n+\n+    /** */\n+    protected static final int QUERY_PARALLELISM = 4;\n+\n+    /** */\n+    protected void createTable(IgniteCache<?, ?> cache, int qryParallelism) {\n+        cache.query(new SqlFieldsQuery(\n+                String.format(\"CREATE TABLE %s.%s \" +\n+                                \"(%s INT, %s VARCHAR,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" %s DOUBLE PRECISION,\" +\n+                                \" PRIMARY KEY (%s)\" +\n+                                \") WITH \" +\n+                                \" \\\"CACHE_NAME=%s,VALUE_TYPE=%s,PARALLELISM=%d\\\"\",\n+                        POI_SCHEMA_NAME, POI_TABLE_NAME, ID_FIELD_NAME, NAME_FIELD_NAME,\n+                        LATITUDE_FIELD_NAME, LONGITUDE_FIELD_NAME, ID_FIELD_NAME,\n+                        POI_CACHE_NAME, POI_CLASS_NAME, qryParallelism)\n+        ));\n+    }\n+\n+    /** */\n+    protected List<IgniteConfiguration> configurations() throws Exception {\n+        return Arrays.asList(\n+                serverConfiguration(IDX_SRV_CRD),\n+                serverConfiguration(IDX_SRV_NON_CRD),\n+                clientConfiguration(IDX_CLI),\n+                serverConfiguration(IDX_SRV_FILTERED, true),\n+                clientConfiguration(IDX_CLI_NEAR_ONLY)\n+        );\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration clientConfiguration(int idx) throws Exception {\n+        return commonConfiguration(idx).setClientMode(true);\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration serverConfiguration(int idx) throws Exception {\n+        return serverConfiguration(idx, false);\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration serverConfiguration(int idx, boolean filter) throws Exception {\n+        IgniteConfiguration cfg = commonConfiguration(idx);\n+\n+        if (filter)\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_FILTERED, true));\n+\n+        return cfg;\n+    }\n+\n+    /** */\n+    protected IgniteConfiguration commonConfiguration(int idx) throws Exception {\n+        String gridName = getTestIgniteInstanceName(idx);\n+\n+        IgniteConfiguration cfg = getConfiguration(gridName);\n+\n+        cfg.setClusterStateOnStart(ClusterState.INACTIVE);\n+\n+        DataStorageConfiguration memCfg = new DataStorageConfiguration()\n+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration().setMaxSize(128 * 1024 * 1024));\n+\n+        cfg.setDataStorageConfiguration(memCfg);\n+\n+        cfg.setConsistentId(gridName);\n+\n+        cfg.setSqlSchemas(POI_SCHEMA_NAME);\n+\n+        return optimize(cfg);\n+    }\n+\n+    /** */\n+    protected CacheConfiguration<?, ?> testCacheConfiguration(\n+            String name,\n+            CacheMode mode,\n+            CacheAtomicityMode atomicityMode\n+    ) {\n+        return new CacheConfiguration<>(name)\n+                .setNodeFilter(new DynamicEnableIndexingBasicSelfTest.NodeFilter())\n+                .setAtomicityMode(atomicityMode)\n+                .setWriteSynchronizationMode(CacheWriteSynchronizationMode.FULL_SYNC)\n+                .setCacheMode(mode);\n+    }\n+\n+    /** */\n+    protected void loadData(IgniteEx node, int start, int end) {\n+        try (IgniteDataStreamer<Object, Object> streamer = node.dataStreamer(POI_CACHE_NAME)) {\n+            Random rnd = ThreadLocalRandom.current();\n+\n+            for (int i = start; i < end; i++) {\n+                BinaryObject bo = node.binary().builder(POI_CLASS_NAME)\n+                        .setField(NAME_FIELD_NAME, \"POI_\" + i, String.class)\n+                        .setField(LATITUDE_FIELD_NAME, rnd.nextDouble(), Double.class)\n+                        .setField(LONGITUDE_FIELD_NAME, rnd.nextDouble(), Double.class)\n+                        .build();\n+\n+                streamer.addData(i, bo);\n+            }\n+        }\n+    }\n+\n+    /** */\n+    protected void performQueryingIntegrityCheck(Ignite ig) throws Exception {\n+        performQueryingIntegrityCheck(ig, 100);\n+    }\n+\n+    /** */\n+    protected List<List<?>> query(Ignite ig, String sql) throws Exception {\n+        IgniteCache<Object, Object> cache = ig.cache(POI_CACHE_NAME).withKeepBinary();\n+\n+        return cache.query(new SqlFieldsQuery(sql).setSchema(POI_SCHEMA_NAME)).getAll();\n+    }\n+\n+    /** */\n+    protected void performQueryingIntegrityCheck(Ignite ig, int key) throws Exception {\n+        IgniteCache<Object, Object> cache = ig.cache(POI_CACHE_NAME).withKeepBinary();\n+\n+        List<List<?>> res = cache.query(new SqlFieldsQuery(\n+                    String.format(\"DELETE FROM %s WHERE %s = %d\", POI_TABLE_NAME, ID_FIELD_NAME, key))", "originalCommit": "3590fad1a5ede8d6609170525cedc7c4742d3feb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "72028b2c1c4d87047634f963e212d82e3ae90d31", "url": "https://github.com/apache/ignite/commit/72028b2c1c4d87047634f963e212d82e3ae90d31", "message": "IGNITE-12808 Minor codestyle.", "committedDate": "2020-06-18T14:51:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMzOTE4OA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442339188", "bodyText": "Typo: Extra layer of indentation can be omitted.", "author": "nizhikov", "createdAt": "2020-06-18T16:06:18Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheUtils.java", "diffHunk": "@@ -2121,6 +2122,43 @@ public static boolean isCacheTemplateName(String cacheName) {\n         return cacheName.endsWith(\"*\");\n     }\n \n+    /**\n+     * Patch cache configuration with {@link SchemaAddQueryEntityOperation}.\n+     *\n+     * @param oldCfg Old cache config.\n+     * @param op Schema add query entity operation.\n+     */\n+    public static <K, V> CacheConfiguration<K, V> patchCacheConfiguration(\n+            CacheConfiguration<K, V> oldCfg,", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMzOTI0NQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442339245", "bodyText": "Typo: Extra layer of indentation can be omitted.", "author": "nizhikov", "createdAt": "2020-06-18T16:06:23Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheUtils.java", "diffHunk": "@@ -2121,6 +2122,43 @@ public static boolean isCacheTemplateName(String cacheName) {\n         return cacheName.endsWith(\"*\");\n     }\n \n+    /**\n+     * Patch cache configuration with {@link SchemaAddQueryEntityOperation}.\n+     *\n+     * @param oldCfg Old cache config.\n+     * @param op Schema add query entity operation.\n+     */\n+    public static <K, V> CacheConfiguration<K, V> patchCacheConfiguration(\n+            CacheConfiguration<K, V> oldCfg,\n+            SchemaAddQueryEntityOperation op\n+    ) {\n+        return patchCacheConfiguration(oldCfg, op.entities(), op.schemaName(), op.isSqlEscape(),\n+                op.queryParallelism());\n+    }\n+\n+    /**\n+     * Patch cache configuration with {@link SchemaAddQueryEntityOperation}.\n+     *\n+     * @param oldCfg Old cache config.\n+     * @param entities New query entities.\n+     * @param sqlSchema Sql schema name,\n+     * @param isSqlEscape Sql escape flag.\n+     * @param qryParallelism Query parallelism parameter.\n+     */\n+    public static <K, V> CacheConfiguration<K, V> patchCacheConfiguration(\n+            CacheConfiguration<K, V> oldCfg,", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM0MDA0Mw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442340043", "bodyText": "Typo: Extra layer of indentation can be omitted.", "author": "nizhikov", "createdAt": "2020-06-18T16:07:37Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheContext.java", "diffHunk": "@@ -2350,6 +2352,39 @@ public boolean hasContinuousQueryListeners(@Nullable IgniteInternalTx tx) {\n             contQryMgr.notifyContinuousQueries(tx) && !F.isEmpty(contQryMgr.updateListeners(false, false));\n     }\n \n+    /**\n+     * Apply changes from {@link SchemaAddQueryEntityOperation}\n+     *\n+     * @param op Add query entity schema operation.\n+     */\n+    public void onSchemaAddQueryEntity(SchemaAddQueryEntityOperation op) {\n+        onSchemaAddQueryEntity(op.entities(), op.schemaName(), op.isSqlEscape(),\n+                op.queryParallelism());\n+    }\n+\n+    /**\n+     * Apply changes on enable indexing.\n+     *\n+     * @param entities New query entities.\n+     * @param sqlSchema Sql schema name,\n+     * @param isSqlEscape Sql escape flag.\n+     * @param qryParallelism Query parallelism parameter.\n+     */\n+    public void onSchemaAddQueryEntity(\n+            Collection<QueryEntity> entities,", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM0MzY4NQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442343685", "bodyText": "Le'ts reduce NUM_ENTRIES to 3.", "author": "nizhikov", "createdAt": "2020-06-18T16:13:23Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingAbstractTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.processors.query.h2.H2TableDescriptor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.h2.SchemaManager;\n+import org.apache.ignite.internal.processors.query.h2.database.H2TreeIndex;\n+import org.apache.ignite.lang.IgnitePredicate;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+\n+/**\n+ * Base class for enable indexing tests.\n+ */\n+public class DynamicEnableIndexingAbstractTest extends GridCommonAbstractTest {\n+    /** Node index for regular server (coordinator). */\n+    protected static final int IDX_SRV_CRD = 0;\n+\n+    /** Node index for regular server (not coordinator). */\n+    protected static final int IDX_SRV_NON_CRD = 1;\n+\n+    /** Node index for regular client. */\n+    protected static final int IDX_CLI = 2;\n+\n+    /** Node index for server which doesn't pass node filter. */\n+    protected static final int IDX_SRV_FILTERED = 3;\n+\n+    /** Node index for client with near-only cache. */\n+    protected static final int IDX_CLI_NEAR_ONLY = 4;\n+\n+    /** Attribute to filter node out of cache data nodes. */\n+    protected static final String ATTR_FILTERED = \"FILTERED\";\n+\n+    /** */\n+    protected static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    protected static final int NUM_ENTRIES = 1000;", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MjE0OQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442352149", "bodyText": "But why 3? Why not 10, 50, 8, 7? 1000 is not so big, but it is not ridiculously small.", "author": "ivandasch", "createdAt": "2020-06-18T16:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM0MzY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MzA3Mw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442353073", "bodyText": "Let's go with 1, if we can.", "author": "nizhikov", "createdAt": "2020-06-18T16:28:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM0MzY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM0MzgxMw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442343813", "bodyText": "Le'ts reduce NUM_ENTRIES to 3.", "author": "nizhikov", "createdAt": "2020-06-18T16:13:36Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/IgniteDynamicEnableIndexingRestoreTest.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache;\n+\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.CachePeekMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.WALMode;\n+import org.apache.ignite.internal.IgniteClientReconnectAbstractTest;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+/**\n+ *  Tests different scenarious to ensure that enabling indexing on persistence CACHE\n+ *  correctly persisted and validated on topology change.\n+ */\n+public class IgniteDynamicEnableIndexingRestoreTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    public static final String POI_SCHEMA_NAME = \"DOMAIN\";\n+\n+    /** */\n+    public static final String WRONG_SCHEMA_NAME = \"DOMAIN_1\";\n+\n+    /** */\n+    public static final String POI_TABLE_NAME = \"POI\";\n+\n+    /** */\n+    public static final String POI_CLASS_NAME = \"PointOfInterest\";\n+\n+    /** */\n+    public static final String ID_FIELD_NAME = \"id\";\n+\n+    /** */\n+    public static final String NAME_FIELD_NAME = \"name\";\n+\n+    /** */\n+    public static final String PK_INDEX_NAME = \"_key_pk\";\n+\n+    /** */\n+    public static final String LATITUDE_FIELD_NAME = \"latitude\";\n+\n+    /** */\n+    public static final String LONGITUDE_FIELD_NAME = \"longitude\";\n+\n+    /** */\n+    public static final int NUM_ENTRIES = 500;", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1Njc3Mg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442356772", "bodyText": "Typo: line too long.\nLet's assert here that error message contains correct error description schema 'DOMAIN' from joining node differs to 'DOMAIN_1'", "author": "nizhikov", "createdAt": "2020-06-18T16:34:09Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/IgniteDynamicEnableIndexingRestoreTest.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache;\n+\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.CachePeekMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.WALMode;\n+import org.apache.ignite.internal.IgniteClientReconnectAbstractTest;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+/**\n+ *  Tests different scenarious to ensure that enabling indexing on persistence CACHE\n+ *  correctly persisted and validated on topology change.\n+ */\n+public class IgniteDynamicEnableIndexingRestoreTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    public static final String POI_SCHEMA_NAME = \"DOMAIN\";\n+\n+    /** */\n+    public static final String WRONG_SCHEMA_NAME = \"DOMAIN_1\";\n+\n+    /** */\n+    public static final String POI_TABLE_NAME = \"POI\";\n+\n+    /** */\n+    public static final String POI_CLASS_NAME = \"PointOfInterest\";\n+\n+    /** */\n+    public static final String ID_FIELD_NAME = \"id\";\n+\n+    /** */\n+    public static final String NAME_FIELD_NAME = \"name\";\n+\n+    /** */\n+    public static final String PK_INDEX_NAME = \"_key_pk\";\n+\n+    /** */\n+    public static final String LATITUDE_FIELD_NAME = \"latitude\";\n+\n+    /** */\n+    public static final String LONGITUDE_FIELD_NAME = \"longitude\";\n+\n+    /** */\n+    public static final int NUM_ENTRIES = 500;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(gridName);\n+\n+        cfg.setClusterStateOnStart(ClusterState.INACTIVE);\n+\n+        DataStorageConfiguration memCfg = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(\n+                new DataRegionConfiguration().setMaxSize(200 * 1024 * 1024).setPersistenceEnabled(true))\n+            .setWalMode(WALMode.LOG_ONLY);\n+\n+        cfg.setDataStorageConfiguration(memCfg);\n+        cfg.setConsistentId(gridName);\n+        cfg.setSqlSchemas(POI_SCHEMA_NAME, WRONG_SCHEMA_NAME);\n+\n+        return cfg;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        stopAllGrids();\n+\n+        cleanPersistenceDir();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        stopAllGrids();\n+\n+        cleanPersistenceDir();\n+    }\n+\n+    /**\n+     * @throws Exception if failed.\n+     */\n+    @Test\n+    public void testMergeCacheConfig_StartWithInitialCoordinator() throws Exception {\n+        testMergeCacheConfig(0, 1);\n+    }\n+\n+    /**\n+     * @throws Exception if failed.\n+     */\n+    @Test\n+    public void testMergeCacheConfig_StartWithInitialSecondNode() throws Exception {\n+        testMergeCacheConfig(1, 0);\n+    }\n+\n+    /**\n+     * @param firstIdx Index of first starting node after cluster stopping.\n+     * @param secondIdx Index of second starting node after cluster stopping.\n+     */\n+    private void testMergeCacheConfig(int firstIdx, int secondIdx) throws Exception {\n+        prepareTestGrid();\n+\n+        // Check when start from firstIdx node.\n+        IgniteEx ig = startGrid(firstIdx);\n+\n+        startGrid(secondIdx);\n+\n+        ig.cluster().state(ClusterState.ACTIVE);\n+\n+        awaitPartitionMapExchange();\n+\n+        performQueryingIntegrityCheck(ig);\n+\n+        // Restart and start from the beginning.\n+        stopAllGrids();\n+\n+        ig = startGrids(2);\n+\n+        ig.cluster().state(ClusterState.ACTIVE);\n+\n+        awaitPartitionMapExchange();\n+\n+        performQueryingIntegrityCheck(ig);\n+    }\n+\n+    /**\n+     * @throws Exception if failed.\n+     */\n+    @Test\n+    public void testFailJoiningNodeBecauseNeedConfigUpdateOnActiveGrid() throws Exception {\n+        prepareTestGrid();\n+\n+        IgniteEx ig = startGrid(1);\n+        ig.cluster().state(ClusterState.ACTIVE);\n+\n+        try {\n+            startGrid(0);\n+\n+            fail(\"Node should start with fail\");\n+        }\n+        catch (Exception e) {\n+            assertThat(X.cause(e, IgniteSpiException.class).getMessage(), containsString(\"Failed to join node to the active cluster\"));\n+        }\n+    }\n+\n+    /**\n+     * @throws Exception if failed.\n+     */\n+    @Test\n+    public void testFailJoiningNodeDifferentSchemasOnDynamicIndexes() throws Exception {\n+        prepareTestGrid();\n+\n+        IgniteEx ig = startGrid(1);\n+        ig.cluster().state(ClusterState.ACTIVE);\n+\n+        // Enable indexing with different schema name.\n+        createTable(ig.cache(POI_CACHE_NAME), WRONG_SCHEMA_NAME);\n+\n+        try {\n+            startGrid(0);\n+\n+            fail(\"Node should start with fail\");\n+        }\n+        catch (Exception e) {\n+            assertThat(X.cause(e, IgniteSpiException.class).getMessage(), containsString(\"Failed to join node to the active cluster\"));", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM2MDkwMw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442360903", "bodyText": "Typo: line too long.\nLet's assert here that error message contains correct error description the config of the cache 'poi' has to be merged which is impossible on active grid", "author": "nizhikov", "createdAt": "2020-06-18T16:41:06Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/IgniteDynamicEnableIndexingRestoreTest.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache;\n+\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.CachePeekMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.WALMode;\n+import org.apache.ignite.internal.IgniteClientReconnectAbstractTest;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+/**\n+ *  Tests different scenarious to ensure that enabling indexing on persistence CACHE\n+ *  correctly persisted and validated on topology change.\n+ */\n+public class IgniteDynamicEnableIndexingRestoreTest extends GridCommonAbstractTest {\n+    /** */\n+    public static final String POI_CACHE_NAME = \"poi\";\n+\n+    /** */\n+    public static final String POI_SCHEMA_NAME = \"DOMAIN\";\n+\n+    /** */\n+    public static final String WRONG_SCHEMA_NAME = \"DOMAIN_1\";\n+\n+    /** */\n+    public static final String POI_TABLE_NAME = \"POI\";\n+\n+    /** */\n+    public static final String POI_CLASS_NAME = \"PointOfInterest\";\n+\n+    /** */\n+    public static final String ID_FIELD_NAME = \"id\";\n+\n+    /** */\n+    public static final String NAME_FIELD_NAME = \"name\";\n+\n+    /** */\n+    public static final String PK_INDEX_NAME = \"_key_pk\";\n+\n+    /** */\n+    public static final String LATITUDE_FIELD_NAME = \"latitude\";\n+\n+    /** */\n+    public static final String LONGITUDE_FIELD_NAME = \"longitude\";\n+\n+    /** */\n+    public static final int NUM_ENTRIES = 500;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(gridName);\n+\n+        cfg.setClusterStateOnStart(ClusterState.INACTIVE);\n+\n+        DataStorageConfiguration memCfg = new DataStorageConfiguration()\n+            .setDefaultDataRegionConfiguration(\n+                new DataRegionConfiguration().setMaxSize(200 * 1024 * 1024).setPersistenceEnabled(true))\n+            .setWalMode(WALMode.LOG_ONLY);\n+\n+        cfg.setDataStorageConfiguration(memCfg);\n+        cfg.setConsistentId(gridName);\n+        cfg.setSqlSchemas(POI_SCHEMA_NAME, WRONG_SCHEMA_NAME);\n+\n+        return cfg;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        stopAllGrids();\n+\n+        cleanPersistenceDir();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        stopAllGrids();\n+\n+        cleanPersistenceDir();\n+    }\n+\n+    /**\n+     * @throws Exception if failed.\n+     */\n+    @Test\n+    public void testMergeCacheConfig_StartWithInitialCoordinator() throws Exception {\n+        testMergeCacheConfig(0, 1);\n+    }\n+\n+    /**\n+     * @throws Exception if failed.\n+     */\n+    @Test\n+    public void testMergeCacheConfig_StartWithInitialSecondNode() throws Exception {\n+        testMergeCacheConfig(1, 0);\n+    }\n+\n+    /**\n+     * @param firstIdx Index of first starting node after cluster stopping.\n+     * @param secondIdx Index of second starting node after cluster stopping.\n+     */\n+    private void testMergeCacheConfig(int firstIdx, int secondIdx) throws Exception {\n+        prepareTestGrid();\n+\n+        // Check when start from firstIdx node.\n+        IgniteEx ig = startGrid(firstIdx);\n+\n+        startGrid(secondIdx);\n+\n+        ig.cluster().state(ClusterState.ACTIVE);\n+\n+        awaitPartitionMapExchange();\n+\n+        performQueryingIntegrityCheck(ig);\n+\n+        // Restart and start from the beginning.\n+        stopAllGrids();\n+\n+        ig = startGrids(2);\n+\n+        ig.cluster().state(ClusterState.ACTIVE);\n+\n+        awaitPartitionMapExchange();\n+\n+        performQueryingIntegrityCheck(ig);\n+    }\n+\n+    /**\n+     * @throws Exception if failed.\n+     */\n+    @Test\n+    public void testFailJoiningNodeBecauseNeedConfigUpdateOnActiveGrid() throws Exception {\n+        prepareTestGrid();\n+\n+        IgniteEx ig = startGrid(1);\n+        ig.cluster().state(ClusterState.ACTIVE);\n+\n+        try {\n+            startGrid(0);\n+\n+            fail(\"Node should start with fail\");\n+        }\n+        catch (Exception e) {\n+            assertThat(X.cause(e, IgniteSpiException.class).getMessage(), containsString(\"Failed to join node to the active cluster\"));", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM2NzE5Nw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442367197", "bodyText": "Can we make IgniteDynamicEnableIndexingRestoreTest extendsDynamicEnableIndexingAbstractTest to reduce code duplication?", "author": "nizhikov", "createdAt": "2020-06-18T16:50:46Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/IgniteDynamicEnableIndexingRestoreTest.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache;\n+\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteDataStreamer;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.CachePeekMode;\n+import org.apache.ignite.cache.CacheWriteSynchronizationMode;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.DataRegionConfiguration;\n+import org.apache.ignite.configuration.DataStorageConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.WALMode;\n+import org.apache.ignite.internal.IgniteClientReconnectAbstractTest;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.spi.IgniteSpiException;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+/**\n+ *  Tests different scenarious to ensure that enabling indexing on persistence CACHE\n+ *  correctly persisted and validated on topology change.\n+ */\n+public class IgniteDynamicEnableIndexingRestoreTest extends GridCommonAbstractTest {", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM2ODY0Mw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442368643", "bodyText": "Typo: Extra layer of indentation can be omitted.", "author": "nizhikov", "createdAt": "2020-06-18T16:53:16Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingBasicSelfTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.NearCacheConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Tests basic functionality of enabling indexing.\n+ */\n+@RunWith(Parameterized.class)\n+public class DynamicEnableIndexingBasicSelfTest extends DynamicEnableIndexingAbstractTest {\n+    /** Test parameters. */\n+    @Parameters(name = \"hasNear={0},nodeIdx={1},cacheMode={2},atomicityMode={3}\")\n+    public static Iterable<Object[]> params() {\n+        int[] opNodes = new int[] {IDX_CLI, IDX_SRV_CRD, IDX_SRV_NON_CRD, IDX_SRV_FILTERED};\n+\n+        CacheMode[] cacheModes = new CacheMode[] {CacheMode.PARTITIONED, CacheMode.REPLICATED};\n+\n+        CacheAtomicityMode[] atomicityModes = new CacheAtomicityMode[] {\n+                CacheAtomicityMode.ATOMIC,", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM2OTk5OQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442369999", "bodyText": "Do we have a reason not to use startGrid(cfg) here?", "author": "nizhikov", "createdAt": "2020-06-18T16:55:37Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingBasicSelfTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.NearCacheConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Tests basic functionality of enabling indexing.\n+ */\n+@RunWith(Parameterized.class)\n+public class DynamicEnableIndexingBasicSelfTest extends DynamicEnableIndexingAbstractTest {\n+    /** Test parameters. */\n+    @Parameters(name = \"hasNear={0},nodeIdx={1},cacheMode={2},atomicityMode={3}\")\n+    public static Iterable<Object[]> params() {\n+        int[] opNodes = new int[] {IDX_CLI, IDX_SRV_CRD, IDX_SRV_NON_CRD, IDX_SRV_FILTERED};\n+\n+        CacheMode[] cacheModes = new CacheMode[] {CacheMode.PARTITIONED, CacheMode.REPLICATED};\n+\n+        CacheAtomicityMode[] atomicityModes = new CacheAtomicityMode[] {\n+                CacheAtomicityMode.ATOMIC,\n+                CacheAtomicityMode.TRANSACTIONAL,\n+                CacheAtomicityMode.TRANSACTIONAL_SNAPSHOT\n+        };\n+\n+        List<Object[]> res = new ArrayList<>();\n+\n+        for (int node : opNodes) {\n+            for (CacheMode cacheMode : cacheModes) {\n+                for (CacheAtomicityMode atomicityMode : atomicityModes) {\n+                    res.add(new Object[] {true, node, cacheMode, atomicityMode});\n+\n+                    // For TRANSACTIONAL_SNAPSHOT near caches is forbidden.\n+                    if (atomicityMode != CacheAtomicityMode.TRANSACTIONAL_SNAPSHOT)\n+                        res.add(new Object[] {false, node, cacheMode, atomicityMode});\n+\n+                }\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    /** */\n+    @Parameter(0)\n+    public Boolean hasNear;\n+\n+    /** */\n+    @Parameter(1)\n+    public int nodeIdx;\n+\n+    /** */\n+    @Parameter(2)\n+    public CacheMode cacheMode;\n+\n+    /** */\n+    @Parameter(3)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        super.beforeTestsStarted();\n+\n+        for (IgniteConfiguration cfg : configurations())\n+            Ignition.start(cfg);", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM3MTI2OA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442371268", "bodyText": "AFAIK stopAllGrids automatically executed after any test.\nWhy do we have to perform it explicitly?", "author": "nizhikov", "createdAt": "2020-06-18T16:57:46Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingBasicSelfTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.configuration.NearCacheConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.testframework.GridTestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Tests basic functionality of enabling indexing.\n+ */\n+@RunWith(Parameterized.class)\n+public class DynamicEnableIndexingBasicSelfTest extends DynamicEnableIndexingAbstractTest {\n+    /** Test parameters. */\n+    @Parameters(name = \"hasNear={0},nodeIdx={1},cacheMode={2},atomicityMode={3}\")\n+    public static Iterable<Object[]> params() {\n+        int[] opNodes = new int[] {IDX_CLI, IDX_SRV_CRD, IDX_SRV_NON_CRD, IDX_SRV_FILTERED};\n+\n+        CacheMode[] cacheModes = new CacheMode[] {CacheMode.PARTITIONED, CacheMode.REPLICATED};\n+\n+        CacheAtomicityMode[] atomicityModes = new CacheAtomicityMode[] {\n+                CacheAtomicityMode.ATOMIC,\n+                CacheAtomicityMode.TRANSACTIONAL,\n+                CacheAtomicityMode.TRANSACTIONAL_SNAPSHOT\n+        };\n+\n+        List<Object[]> res = new ArrayList<>();\n+\n+        for (int node : opNodes) {\n+            for (CacheMode cacheMode : cacheModes) {\n+                for (CacheAtomicityMode atomicityMode : atomicityModes) {\n+                    res.add(new Object[] {true, node, cacheMode, atomicityMode});\n+\n+                    // For TRANSACTIONAL_SNAPSHOT near caches is forbidden.\n+                    if (atomicityMode != CacheAtomicityMode.TRANSACTIONAL_SNAPSHOT)\n+                        res.add(new Object[] {false, node, cacheMode, atomicityMode});\n+\n+                }\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    /** */\n+    @Parameter(0)\n+    public Boolean hasNear;\n+\n+    /** */\n+    @Parameter(1)\n+    public int nodeIdx;\n+\n+    /** */\n+    @Parameter(2)\n+    public CacheMode cacheMode;\n+\n+    /** */\n+    @Parameter(3)\n+    public CacheAtomicityMode atomicityMode;\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTestsStarted() throws Exception {\n+        super.beforeTestsStarted();\n+\n+        for (IgniteConfiguration cfg : configurations())\n+            Ignition.start(cfg);\n+\n+        node().cluster().state(ClusterState.ACTIVE);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTestsStopped() throws Exception {\n+        stopAllGrids();", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0aca464607a49bd164fc7e9d8c23a062b1390754", "url": "https://github.com/apache/ignite/commit/0aca464607a49bd164fc7e9d8c23a062b1390754", "message": "IGNITE-12808 Refactor test + codestyle.", "committedDate": "2020-06-18T17:41:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MDY5MQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442670691", "bodyText": "Typo: extra indentation level can be omitted.", "author": "nizhikov", "createdAt": "2020-06-19T07:11:59Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/schema/operation/SchemaAddQueryEntityOperation.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.query.schema.operation;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+import org.apache.ignite.cache.QueryEntity;\n+\n+/**\n+ * Enabling indexing on cache operation.\n+ */\n+public class SchemaAddQueryEntityOperation extends SchemaAbstractOperation {\n+    /** */\n+    private static final long serialVersionUID = 0L;\n+\n+    /** */\n+    private final Collection<QueryEntity> entities;\n+\n+    /** */\n+    private final int qryParallelism;\n+\n+    /** */\n+    private final boolean sqlEscape;\n+\n+    /**\n+     * @param opId Operation ID.\n+     * @param cacheName Cache name.\n+     * @param schemaName Schema name.\n+     * @param entities Collection of QueryEntity.\n+     * @param qryParallelism Query parallelism.\n+     * @param sqlEscape Sql escape flag.\n+     */\n+    public SchemaAddQueryEntityOperation(\n+            UUID opId,", "originalCommit": "72028b2c1c4d87047634f963e212d82e3ae90d31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY4MDYzMw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442680633", "bodyText": "Typo: extra layer of indentation can be omitted.", "author": "nizhikov", "createdAt": "2020-06-19T07:34:29Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingConcurrentSelfTest.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.cache.CacheException;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.QueryEntity;\n+import org.apache.ignite.cache.QueryIndex;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteClientReconnectAbstractTest;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.CustomEventListener;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.query.GridQueryProcessor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.schema.SchemaOperationException;\n+import org.apache.ignite.internal.processors.query.schema.message.SchemaFinishDiscoveryMessage;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.internal.util.typedef.T2;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.transactions.TransactionSerializationException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test different scnerarions on concurrent enabling indexing.\n+ */\n+@RunWith(Parameterized.class)\n+public class DynamicEnableIndexingConcurrentSelfTest extends DynamicEnableIndexingAbstractTest {\n+    /** Test parameters. */\n+    @Parameters(name = \"cacheMode={0},atomicityMode={1}\")\n+    public static Iterable<Object[]> params() {\n+        CacheMode[] cacheModes = new CacheMode[] {CacheMode.PARTITIONED, CacheMode.REPLICATED};\n+\n+        CacheAtomicityMode[] atomicityModes = new CacheAtomicityMode[] {\n+                CacheAtomicityMode.ATOMIC,", "originalCommit": "0aca464607a49bd164fc7e9d8c23a062b1390754", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5MDY2OA==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442690668", "bodyText": "Typo: empty line should be removed.", "author": "nizhikov", "createdAt": "2020-06-19T07:55:29Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingConcurrentSelfTest.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.cache.CacheException;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.QueryEntity;\n+import org.apache.ignite.cache.QueryIndex;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteClientReconnectAbstractTest;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.CustomEventListener;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.query.GridQueryProcessor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.schema.SchemaOperationException;\n+import org.apache.ignite.internal.processors.query.schema.message.SchemaFinishDiscoveryMessage;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.internal.util.typedef.T2;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.transactions.TransactionSerializationException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test different scnerarions on concurrent enabling indexing.\n+ */\n+@RunWith(Parameterized.class)\n+public class DynamicEnableIndexingConcurrentSelfTest extends DynamicEnableIndexingAbstractTest {\n+    /** Test parameters. */\n+    @Parameters(name = \"cacheMode={0},atomicityMode={1}\")\n+    public static Iterable<Object[]> params() {\n+        CacheMode[] cacheModes = new CacheMode[] {CacheMode.PARTITIONED, CacheMode.REPLICATED};\n+\n+        CacheAtomicityMode[] atomicityModes = new CacheAtomicityMode[] {\n+                CacheAtomicityMode.ATOMIC,\n+                CacheAtomicityMode.TRANSACTIONAL,\n+                CacheAtomicityMode.TRANSACTIONAL_SNAPSHOT\n+        };\n+\n+        List<Object[]> res = new ArrayList<>();\n+        for (CacheMode cacheMode : cacheModes) {\n+            for (CacheAtomicityMode atomicityMode : atomicityModes)\n+                res.add(new Object[] {cacheMode, atomicityMode});\n+        }\n+\n+        return res;\n+    }\n+\n+    /** Latches to block certain index operations. */\n+    private static final ConcurrentHashMap<UUID, T2<CountDownLatch, CountDownLatch>> BLOCKS =\n+            new ConcurrentHashMap<>();\n+\n+    /** Name field index name. */\n+    private static final String NAME_FIELD_IDX_NAME = \"name_idx\";\n+\n+    /** Large number of entries. */\n+    private static final int LARGE_NUM_ENTRIES = 100_000;\n+\n+    /** */\n+    @Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** */\n+    @Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+", "originalCommit": "0aca464607a49bd164fc7e9d8c23a062b1390754", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5NjEyMw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442696123", "bodyText": "Why do we need this? It seems the test will pass even we removed these lines.", "author": "nizhikov", "createdAt": "2020-06-19T08:06:25Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingConcurrentSelfTest.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.cache.CacheException;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.QueryEntity;\n+import org.apache.ignite.cache.QueryIndex;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteClientReconnectAbstractTest;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.CustomEventListener;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.query.GridQueryProcessor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.schema.SchemaOperationException;\n+import org.apache.ignite.internal.processors.query.schema.message.SchemaFinishDiscoveryMessage;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.internal.util.typedef.T2;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.transactions.TransactionSerializationException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test different scnerarions on concurrent enabling indexing.\n+ */\n+@RunWith(Parameterized.class)\n+public class DynamicEnableIndexingConcurrentSelfTest extends DynamicEnableIndexingAbstractTest {\n+    /** Test parameters. */\n+    @Parameters(name = \"cacheMode={0},atomicityMode={1}\")\n+    public static Iterable<Object[]> params() {\n+        CacheMode[] cacheModes = new CacheMode[] {CacheMode.PARTITIONED, CacheMode.REPLICATED};\n+\n+        CacheAtomicityMode[] atomicityModes = new CacheAtomicityMode[] {\n+                CacheAtomicityMode.ATOMIC,\n+                CacheAtomicityMode.TRANSACTIONAL,\n+                CacheAtomicityMode.TRANSACTIONAL_SNAPSHOT\n+        };\n+\n+        List<Object[]> res = new ArrayList<>();\n+        for (CacheMode cacheMode : cacheModes) {\n+            for (CacheAtomicityMode atomicityMode : atomicityModes)\n+                res.add(new Object[] {cacheMode, atomicityMode});\n+        }\n+\n+        return res;\n+    }\n+\n+    /** Latches to block certain index operations. */\n+    private static final ConcurrentHashMap<UUID, T2<CountDownLatch, CountDownLatch>> BLOCKS =\n+            new ConcurrentHashMap<>();\n+\n+    /** Name field index name. */\n+    private static final String NAME_FIELD_IDX_NAME = \"name_idx\";\n+\n+    /** Large number of entries. */\n+    private static final int LARGE_NUM_ENTRIES = 100_000;\n+\n+    /** */\n+    @Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** */\n+    @Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        GridQueryProcessor.idxCls = null;\n+\n+        for (T2<CountDownLatch, CountDownLatch> block : BLOCKS.values())", "originalCommit": "0aca464607a49bd164fc7e9d8c23a062b1390754", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5OTQ4MQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442699481", "bodyText": "Of course it will pass. This is extra measure if something goes wrong not to hang test. It is nothing common with passing or not test.", "author": "ivandasch", "createdAt": "2020-06-19T08:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5NjEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5OTc0NQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442699745", "bodyText": "Why we use private API here?", "author": "nizhikov", "createdAt": "2020-06-19T08:14:01Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingConcurrentSelfTest.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.cache.CacheException;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.QueryEntity;\n+import org.apache.ignite.cache.QueryIndex;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteClientReconnectAbstractTest;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.CustomEventListener;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.query.GridQueryProcessor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.schema.SchemaOperationException;\n+import org.apache.ignite.internal.processors.query.schema.message.SchemaFinishDiscoveryMessage;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.internal.util.typedef.T2;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.transactions.TransactionSerializationException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test different scnerarions on concurrent enabling indexing.\n+ */\n+@RunWith(Parameterized.class)\n+public class DynamicEnableIndexingConcurrentSelfTest extends DynamicEnableIndexingAbstractTest {\n+    /** Test parameters. */\n+    @Parameters(name = \"cacheMode={0},atomicityMode={1}\")\n+    public static Iterable<Object[]> params() {\n+        CacheMode[] cacheModes = new CacheMode[] {CacheMode.PARTITIONED, CacheMode.REPLICATED};\n+\n+        CacheAtomicityMode[] atomicityModes = new CacheAtomicityMode[] {\n+                CacheAtomicityMode.ATOMIC,\n+                CacheAtomicityMode.TRANSACTIONAL,\n+                CacheAtomicityMode.TRANSACTIONAL_SNAPSHOT\n+        };\n+\n+        List<Object[]> res = new ArrayList<>();\n+        for (CacheMode cacheMode : cacheModes) {\n+            for (CacheAtomicityMode atomicityMode : atomicityModes)\n+                res.add(new Object[] {cacheMode, atomicityMode});\n+        }\n+\n+        return res;\n+    }\n+\n+    /** Latches to block certain index operations. */\n+    private static final ConcurrentHashMap<UUID, T2<CountDownLatch, CountDownLatch>> BLOCKS =\n+            new ConcurrentHashMap<>();\n+\n+    /** Name field index name. */\n+    private static final String NAME_FIELD_IDX_NAME = \"name_idx\";\n+\n+    /** Large number of entries. */\n+    private static final int LARGE_NUM_ENTRIES = 100_000;\n+\n+    /** */\n+    @Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** */\n+    @Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        GridQueryProcessor.idxCls = null;\n+\n+        for (T2<CountDownLatch, CountDownLatch> block : BLOCKS.values())\n+            block.get1().countDown();\n+\n+        BLOCKS.clear();\n+\n+        stopAllGrids();\n+\n+        super.afterTest();\n+    }\n+\n+    /**\n+     * Test pending operation when coordinator change.\n+     */\n+    @Test\n+    public void testCoordinatorChange() throws Exception {\n+        // Start servers.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+        ignitionStart(serverConfiguration(2));\n+        ignitionStart(serverConfiguration(3));\n+        ignitionStart(serverConfiguration(4));\n+\n+        // Start client.\n+        IgniteEx cli = ignitionStart(clientConfiguration(5));\n+        cli.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(cli);\n+        loadData(cli, 0, NUM_ENTRIES);\n+\n+        // Test migration between normal servers.\n+        UUID id1 = srv1.cluster().localNode().id();\n+\n+        CountDownLatch idxLatch = blockIndexing(id1);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(cli);\n+\n+        idxLatch.await();\n+\n+        Ignition.stop(srv1.name(), true);\n+\n+        unblockIndexing(id1);\n+\n+        tblFut.get();\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertTrue(query(g, SELECT_ALL_QUERY).size() >= 3 * NUM_ENTRIES / 4 );\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** */\n+    @Test\n+    public void testClientReconnect() throws Exception {\n+        // Start servers.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+        ignitionStart(serverConfiguration(2));\n+        ignitionStart(serverConfiguration(3));\n+        ignitionStart(serverConfiguration(4));\n+\n+        // Start client.\n+        IgniteEx cli = ignitionStart(clientConfiguration(5));\n+        cli.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(cli);\n+        loadData(cli, 0, NUM_ENTRIES);\n+\n+        // Reconnect client and enable indexing before client connects.\n+        IgniteClientReconnectAbstractTest.reconnectClientNode(log, cli, srv1, () -> {\n+            try {\n+                enableIndexing(srv1).get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to enable indexing\", e);\n+            }\n+        });\n+\n+        assertEquals(NUM_ENTRIES, query(cli, SELECT_ALL_QUERY).size());\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** */\n+    @Test\n+    public void testNodeJoinOnPendingOperation() throws Exception {\n+        CountDownLatch finishLatch = new CountDownLatch(3);\n+\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1), finishLatch);\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, NUM_ENTRIES);\n+\n+        CountDownLatch idxLatch = blockIndexing(srv1);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(srv1);\n+\n+        U.await(idxLatch);\n+\n+        ignitionStart(serverConfiguration(2), finishLatch);\n+        ignitionStart(serverConfiguration(3), finishLatch);\n+\n+        awaitPartitionMapExchange();\n+\n+        assertFalse(tblFut.isDone());\n+\n+        unblockIndexing(srv1);\n+\n+        tblFut.get();\n+\n+        U.await(finishLatch);\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** Test chaining schema operation with enable indexing. */\n+    @Test\n+    public void testOperationChaining() throws Exception {\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+\n+        ignitionStart(serverConfiguration(2));\n+        ignitionStart(serverConfiguration(3, true));\n+        ignitionStart(clientConfiguration(4));\n+\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, NUM_ENTRIES);\n+\n+        CountDownLatch idxLatch = blockIndexing(srv1);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(srv1);\n+\n+        QueryIndex idx = new QueryIndex();\n+        idx.setName(NAME_FIELD_IDX_NAME.toUpperCase());\n+        idx.setFieldNames(Collections.singletonList(NAME_FIELD_NAME.toUpperCase()), true);\n+\n+        IgniteInternalFuture<?> idxFut1 = srv1.context().query().dynamicIndexCreate(POI_CACHE_NAME, POI_SCHEMA_NAME,\n+                POI_TABLE_NAME, idx, false, 0);\n+\n+        idxLatch.await();\n+\n+        // Add more nodes.\n+        ignitionStart(serverConfiguration(5));\n+        ignitionStart(serverConfiguration(6, true));\n+        ignitionStart(clientConfiguration(7));\n+\n+        assertFalse(tblFut.isDone());\n+        assertFalse(idxFut1.isDone());\n+\n+        unblockIndexing(srv1);\n+\n+        idxFut1.get();\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+\n+            IgniteCache<Object, Object> cache = g.cache(POI_CACHE_NAME);\n+\n+            assertIndexUsed(cache, \"SELECT * FROM \" + POI_TABLE_NAME + \" WHERE name = 'POI_100'\", NAME_FIELD_IDX_NAME);\n+\n+            List<List<?>> res = cache.query(new SqlFieldsQuery(\"SELECT \" + ID_FIELD_NAME + \" FROM \" + POI_TABLE_NAME +\n+                    \" WHERE name = 'POI_100'\").setSchema(POI_SCHEMA_NAME)).getAll();\n+\n+            assertEquals(1, res.size());\n+            assertEquals(100, res.get(0).get(0));\n+        }\n+    }\n+\n+    /** Enable indexing on ongoing rebalance. */\n+    @Test\n+    public void testConcurrentRebalance() throws Exception {\n+        // Start cache and populate it with data.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+        Ignite srv2 = ignitionStart(serverConfiguration(2));\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, LARGE_NUM_ENTRIES);\n+\n+        // Start index operation in blocked state.\n+        CountDownLatch idxLatch1 = blockIndexing(srv1);\n+        CountDownLatch idxLatch2 = blockIndexing(srv2);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(srv1);\n+\n+        U.await(idxLatch1);\n+        U.await(idxLatch2);\n+\n+        // Start two more nodes and unblock index operation in the middle.\n+        ignitionStart(serverConfiguration(3));\n+\n+        unblockIndexing(srv1);\n+        unblockIndexing(srv2);\n+\n+        ignitionStart(serverConfiguration(4));\n+\n+        awaitPartitionMapExchange();\n+\n+        tblFut.get();\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(LARGE_NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** Test concurrent put remove when enabling indexing. */\n+    @Test\n+    public void testConcurrentPutRemove() throws Exception {\n+        CountDownLatch finishLatch = new CountDownLatch(4);\n+\n+        // Start several nodes.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1), finishLatch);\n+        ignitionStart(serverConfiguration(2), finishLatch);\n+        ignitionStart(serverConfiguration(3), finishLatch);\n+        ignitionStart(serverConfiguration(4), finishLatch);\n+\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, LARGE_NUM_ENTRIES);\n+\n+        // Start data change operations from several threads.\n+        final AtomicBoolean stopped = new AtomicBoolean();\n+\n+        IgniteInternalFuture<?> task = multithreadedAsync(() -> {\n+            while (!stopped.get()) {\n+                Ignite node = grid(ThreadLocalRandom.current().nextInt(1, 5));\n+\n+                ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+                int i = rnd.nextInt(0, LARGE_NUM_ENTRIES);\n+\n+                BinaryObject val = node.binary().builder(POI_CLASS_NAME)\n+                    .setField(NAME_FIELD_NAME, \"POI_\" + i, String.class)\n+                    .setField(LATITUDE_FIELD_NAME, rnd.nextDouble(), Double.class)\n+                    .setField(LONGITUDE_FIELD_NAME, rnd.nextDouble(), Double.class)\n+                    .build();\n+\n+                IgniteCache<Object, BinaryObject> cache = node.cache(POI_CACHE_NAME).withKeepBinary();\n+\n+                try {\n+                    if (ThreadLocalRandom.current().nextBoolean())\n+                        cache.put(i, val);\n+                    else\n+                        cache.remove(i);\n+                }\n+                catch (CacheException e) {\n+                    if (!X.hasCause(e, TransactionSerializationException.class))\n+                        throw e;\n+                }\n+            }\n+\n+            return null;\n+        }, 4);\n+\n+        // Do some work.\n+        Thread.sleep(2_000L);\n+\n+        enableIndexing(srv1).get();\n+\n+        // Stop updates once index is ready.\n+        stopped.set(true);\n+        task.get();\n+\n+        finishLatch.await();\n+\n+        // Perform integrity check.\n+        IgniteCache<Object, Object> cache = srv1.cache(POI_CACHE_NAME).withKeepBinary();\n+\n+        query(srv1, SELECT_ALL_QUERY).forEach(res -> {\n+            BinaryObject val = (BinaryObject)cache.get(res.get(0));\n+\n+            assertNotNull(val);\n+\n+            assertEquals(val.field(NAME_FIELD_NAME), res.get(1));\n+            assertEquals(val.field(LATITUDE_FIELD_NAME), res.get(2));\n+            assertEquals(val.field(LONGITUDE_FIELD_NAME), res.get(3));\n+        });\n+    }\n+\n+    /** Test concurrent enabling indexing. Only one attempt should succeed. */\n+    @Test\n+    public void testConcurrentEnableIndexing() throws Exception {\n+        // Start several nodes.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+        ignitionStart(serverConfiguration(2));\n+        ignitionStart(clientConfiguration(3));\n+        ignitionStart(clientConfiguration(4));\n+\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, LARGE_NUM_ENTRIES);\n+\n+        // Start enable indexing from several threads.\n+        final AtomicBoolean stopped = new AtomicBoolean();\n+        final AtomicInteger success = new AtomicInteger();\n+\n+        IgniteInternalFuture<?> task = multithreadedAsync(() -> {\n+            while (!stopped.get()) {\n+                IgniteEx node = grid(ThreadLocalRandom.current().nextInt(1, 4));\n+\n+                try {\n+                    Thread.sleep(100);\n+                }\n+                catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n+\n+                enableIndexing(node).chain((fut) -> {\n+                    try {\n+                        fut.get();\n+\n+                        success.incrementAndGet();\n+                    }\n+                    catch (IgniteCheckedException e) {\n+                        assertTrue(e.hasCause(SchemaOperationException.class));\n+\n+                        SchemaOperationException opEx = e.getCause(SchemaOperationException.class);\n+\n+                        assertEquals(SchemaOperationException.CODE_CACHE_ALREADY_INDEXED, opEx.code());\n+                        assertEquals(\"Cache is already indexed: \" + POI_CACHE_NAME, opEx.getMessage());\n+                    }\n+\n+                    return null;\n+                });\n+            }\n+\n+            return null;\n+        }, 4);\n+\n+        // Do attempts.\n+        Thread.sleep(1_000L);\n+\n+        // Start more server nodes..\n+        ignitionStart(serverConfiguration(5));\n+        ignitionStart(serverConfiguration(6));\n+\n+        // Do some more attempts.\n+        Thread.sleep(1_000L);\n+\n+        // Stop task.\n+        stopped.set(true);\n+        task.get();\n+\n+        // Check that only one successful attempt.\n+        assertEquals(1, success.get());\n+\n+        awaitPartitionMapExchange();\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(LARGE_NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** */\n+    private IgniteInternalFuture<?> enableIndexing(IgniteEx node) {\n+        Integer parallelism = cacheMode == CacheMode.PARTITIONED ? QUERY_PARALLELISM : null;\n+\n+        return node.context().query().dynamicAddQueryEntity(POI_CACHE_NAME, POI_SCHEMA_NAME, queryEntity(), parallelism,\n+                false);\n+    }\n+\n+    /** */\n+    private QueryEntity queryEntity() {\n+        LinkedHashMap<String, String> fields = new LinkedHashMap<>();\n+        fields.put(ID_FIELD_NAME, Integer.class.getName());\n+        fields.put(NAME_FIELD_NAME, String.class.getName());\n+        fields.put(LATITUDE_FIELD_NAME, Double.class.getName());\n+        fields.put(LONGITUDE_FIELD_NAME, Double.class.getName());\n+\n+        return new QueryEntity()\n+            .setKeyType(Integer.class.getName())\n+            .setKeyFieldName(ID_FIELD_NAME)\n+            .setValueType(POI_CLASS_NAME)\n+            .setTableName(POI_TABLE_NAME)\n+            .setFields(fields);\n+    }\n+\n+    /** */\n+    private void createCache(IgniteEx node) throws Exception {\n+        CacheConfiguration<?, ?> ccfg = testCacheConfiguration(POI_CACHE_NAME, cacheMode, atomicityMode);\n+\n+        node.context().cache().dynamicStartCache(ccfg, POI_CACHE_NAME, null, true, true, true).get();", "originalCommit": "0aca464607a49bd164fc7e9d8c23a062b1390754", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMzI3MQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442703271", "bodyText": "We need future for tests.", "author": "ivandasch", "createdAt": "2020-06-19T08:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5OTc0NQ=="}], "type": "inlineReview"}, {"oid": "b47d000a8786d1edb2e66e30fe7657d53142a625", "url": "https://github.com/apache/ignite/commit/b47d000a8786d1edb2e66e30fe7657d53142a625", "message": "IGNITE-12808 Added tests + codestyle.", "committedDate": "2020-06-19T08:20:02Z", "type": "commit"}, {"oid": "957c361356c94acde960a8736b8605b0ddfb184b", "url": "https://github.com/apache/ignite/commit/957c361356c94acde960a8736b8605b0ddfb184b", "message": "IGNITE-12808 Fixes test.", "committedDate": "2020-06-19T08:35:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNDkwMw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442714903", "bodyText": "Let's eliminate Thread.sleep with the latch here:\n        CountDownLatch doSomeWorkLatch = new CountDownLatch(10);\n\n        IgniteInternalFuture<?> task = multithreadedAsync(() -> {\n            while (!stopped.get()) {\n                // ....\n                try {\n                    if (ThreadLocalRandom.current().nextBoolean())\n                        cache.put(i, val);\n                    else\n                        cache.remove(i);\n\n                    if (doSomeWorkLatch.getCount() > 0)\n                        doSomeWorkLatch.countDown();\n                }\n                catch (CacheException e) {\n                    if (!X.hasCause(e, TransactionSerializationException.class))\n                        throw e;\n                }\n            }\n\n            return null;\n        }, 4);\n\n        // Do some work.\n        doSomeWorkLatch.await(2, TimeUnit.SECONDS);", "author": "nizhikov", "createdAt": "2020-06-19T08:47:47Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingConcurrentSelfTest.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.cache.CacheException;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.QueryEntity;\n+import org.apache.ignite.cache.QueryIndex;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteClientReconnectAbstractTest;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.CustomEventListener;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.query.GridQueryProcessor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.schema.SchemaOperationException;\n+import org.apache.ignite.internal.processors.query.schema.message.SchemaFinishDiscoveryMessage;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.internal.util.typedef.T2;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.transactions.TransactionSerializationException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test different scnerarions on concurrent enabling indexing.\n+ */\n+@RunWith(Parameterized.class)\n+public class DynamicEnableIndexingConcurrentSelfTest extends DynamicEnableIndexingAbstractTest {\n+    /** Test parameters. */\n+    @Parameters(name = \"cacheMode={0},atomicityMode={1}\")\n+    public static Iterable<Object[]> params() {\n+        CacheMode[] cacheModes = new CacheMode[] {CacheMode.PARTITIONED, CacheMode.REPLICATED};\n+\n+        CacheAtomicityMode[] atomicityModes = new CacheAtomicityMode[] {\n+                CacheAtomicityMode.ATOMIC,\n+                CacheAtomicityMode.TRANSACTIONAL,\n+                CacheAtomicityMode.TRANSACTIONAL_SNAPSHOT\n+        };\n+\n+        List<Object[]> res = new ArrayList<>();\n+        for (CacheMode cacheMode : cacheModes) {\n+            for (CacheAtomicityMode atomicityMode : atomicityModes)\n+                res.add(new Object[] {cacheMode, atomicityMode});\n+        }\n+\n+        return res;\n+    }\n+\n+    /** Latches to block certain index operations. */\n+    private static final ConcurrentHashMap<UUID, T2<CountDownLatch, CountDownLatch>> BLOCKS =\n+            new ConcurrentHashMap<>();\n+\n+    /** Name field index name. */\n+    private static final String NAME_FIELD_IDX_NAME = \"name_idx\";\n+\n+    /** Large number of entries. */\n+    private static final int LARGE_NUM_ENTRIES = 100_000;\n+\n+    /** */\n+    @Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** */\n+    @Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        GridQueryProcessor.idxCls = null;\n+\n+        for (T2<CountDownLatch, CountDownLatch> block : BLOCKS.values())\n+            block.get1().countDown();\n+\n+        BLOCKS.clear();\n+\n+        stopAllGrids();\n+\n+        super.afterTest();\n+    }\n+\n+    /**\n+     * Test pending operation when coordinator change.\n+     */\n+    @Test\n+    public void testCoordinatorChange() throws Exception {\n+        // Start servers.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+        ignitionStart(serverConfiguration(2));\n+        ignitionStart(serverConfiguration(3));\n+        ignitionStart(serverConfiguration(4));\n+\n+        // Start client.\n+        IgniteEx cli = ignitionStart(clientConfiguration(5));\n+        cli.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(cli);\n+        loadData(cli, 0, NUM_ENTRIES);\n+\n+        // Test migration between normal servers.\n+        UUID id1 = srv1.cluster().localNode().id();\n+\n+        CountDownLatch idxLatch = blockIndexing(id1);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(cli);\n+\n+        idxLatch.await();\n+\n+        Ignition.stop(srv1.name(), true);\n+\n+        unblockIndexing(id1);\n+\n+        tblFut.get();\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertTrue(query(g, SELECT_ALL_QUERY).size() >= 3 * NUM_ENTRIES / 4 );\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** */\n+    @Test\n+    public void testClientReconnect() throws Exception {\n+        // Start servers.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+        ignitionStart(serverConfiguration(2));\n+        ignitionStart(serverConfiguration(3));\n+        ignitionStart(serverConfiguration(4));\n+\n+        // Start client.\n+        IgniteEx cli = ignitionStart(clientConfiguration(5));\n+        cli.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(cli);\n+        loadData(cli, 0, NUM_ENTRIES);\n+\n+        // Reconnect client and enable indexing before client connects.\n+        IgniteClientReconnectAbstractTest.reconnectClientNode(log, cli, srv1, () -> {\n+            try {\n+                enableIndexing(srv1).get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to enable indexing\", e);\n+            }\n+        });\n+\n+        assertEquals(NUM_ENTRIES, query(cli, SELECT_ALL_QUERY).size());\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** */\n+    @Test\n+    public void testNodeJoinOnPendingOperation() throws Exception {\n+        CountDownLatch finishLatch = new CountDownLatch(3);\n+\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1), finishLatch);\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, NUM_ENTRIES);\n+\n+        CountDownLatch idxLatch = blockIndexing(srv1);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(srv1);\n+\n+        U.await(idxLatch);\n+\n+        ignitionStart(serverConfiguration(2), finishLatch);\n+        ignitionStart(serverConfiguration(3), finishLatch);\n+\n+        awaitPartitionMapExchange();\n+\n+        assertFalse(tblFut.isDone());\n+\n+        unblockIndexing(srv1);\n+\n+        tblFut.get();\n+\n+        U.await(finishLatch);\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** Test chaining schema operation with enable indexing. */\n+    @Test\n+    public void testOperationChaining() throws Exception {\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+\n+        ignitionStart(serverConfiguration(2));\n+        ignitionStart(serverConfiguration(3, true));\n+        ignitionStart(clientConfiguration(4));\n+\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, NUM_ENTRIES);\n+\n+        CountDownLatch idxLatch = blockIndexing(srv1);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(srv1);\n+\n+        QueryIndex idx = new QueryIndex();\n+        idx.setName(NAME_FIELD_IDX_NAME.toUpperCase());\n+        idx.setFieldNames(Collections.singletonList(NAME_FIELD_NAME.toUpperCase()), true);\n+\n+        IgniteInternalFuture<?> idxFut1 = srv1.context().query().dynamicIndexCreate(POI_CACHE_NAME, POI_SCHEMA_NAME,\n+                POI_TABLE_NAME, idx, false, 0);\n+\n+        idxLatch.await();\n+\n+        // Add more nodes.\n+        ignitionStart(serverConfiguration(5));\n+        ignitionStart(serverConfiguration(6, true));\n+        ignitionStart(clientConfiguration(7));\n+\n+        assertFalse(tblFut.isDone());\n+        assertFalse(idxFut1.isDone());\n+\n+        unblockIndexing(srv1);\n+\n+        idxFut1.get();\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+\n+            IgniteCache<Object, Object> cache = g.cache(POI_CACHE_NAME);\n+\n+            assertIndexUsed(cache, \"SELECT * FROM \" + POI_TABLE_NAME + \" WHERE name = 'POI_100'\", NAME_FIELD_IDX_NAME);\n+\n+            List<List<?>> res = cache.query(new SqlFieldsQuery(\"SELECT \" + ID_FIELD_NAME + \" FROM \" + POI_TABLE_NAME +\n+                    \" WHERE name = 'POI_100'\").setSchema(POI_SCHEMA_NAME)).getAll();\n+\n+            assertEquals(1, res.size());\n+            assertEquals(100, res.get(0).get(0));\n+        }\n+    }\n+\n+    /** Enable indexing on ongoing rebalance. */\n+    @Test\n+    public void testConcurrentRebalance() throws Exception {\n+        // Start cache and populate it with data.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+        Ignite srv2 = ignitionStart(serverConfiguration(2));\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, LARGE_NUM_ENTRIES);\n+\n+        // Start index operation in blocked state.\n+        CountDownLatch idxLatch1 = blockIndexing(srv1);\n+        CountDownLatch idxLatch2 = blockIndexing(srv2);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(srv1);\n+\n+        U.await(idxLatch1);\n+        U.await(idxLatch2);\n+\n+        // Start two more nodes and unblock index operation in the middle.\n+        ignitionStart(serverConfiguration(3));\n+\n+        unblockIndexing(srv1);\n+        unblockIndexing(srv2);\n+\n+        ignitionStart(serverConfiguration(4));\n+\n+        awaitPartitionMapExchange();\n+\n+        tblFut.get();\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(LARGE_NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** Test concurrent put remove when enabling indexing. */\n+    @Test\n+    public void testConcurrentPutRemove() throws Exception {\n+        CountDownLatch finishLatch = new CountDownLatch(4);\n+\n+        // Start several nodes.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1), finishLatch);\n+        ignitionStart(serverConfiguration(2), finishLatch);\n+        ignitionStart(serverConfiguration(3), finishLatch);\n+        ignitionStart(serverConfiguration(4), finishLatch);\n+\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, LARGE_NUM_ENTRIES);\n+\n+        // Start data change operations from several threads.\n+        final AtomicBoolean stopped = new AtomicBoolean();\n+\n+        IgniteInternalFuture<?> task = multithreadedAsync(() -> {\n+            while (!stopped.get()) {\n+                Ignite node = grid(ThreadLocalRandom.current().nextInt(1, 5));\n+\n+                ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+                int i = rnd.nextInt(0, LARGE_NUM_ENTRIES);\n+\n+                BinaryObject val = node.binary().builder(POI_CLASS_NAME)\n+                    .setField(NAME_FIELD_NAME, \"POI_\" + i, String.class)\n+                    .setField(LATITUDE_FIELD_NAME, rnd.nextDouble(), Double.class)\n+                    .setField(LONGITUDE_FIELD_NAME, rnd.nextDouble(), Double.class)\n+                    .build();\n+\n+                IgniteCache<Object, BinaryObject> cache = node.cache(POI_CACHE_NAME).withKeepBinary();\n+\n+                try {\n+                    if (ThreadLocalRandom.current().nextBoolean())\n+                        cache.put(i, val);\n+                    else\n+                        cache.remove(i);\n+                }\n+                catch (CacheException e) {\n+                    if (!X.hasCause(e, TransactionSerializationException.class))\n+                        throw e;\n+                }\n+            }\n+\n+            return null;\n+        }, 4);\n+\n+        // Do some work.\n+        Thread.sleep(2_000L);", "originalCommit": "0aca464607a49bd164fc7e9d8c23a062b1390754", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDQxMw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442724413", "bodyText": "Why we ignore TransactionSerializationException?", "author": "nizhikov", "createdAt": "2020-06-19T09:11:22Z", "path": "modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/index/DynamicEnableIndexingConcurrentSelfTest.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.cache.index;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.cache.CacheException;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteCache;\n+import org.apache.ignite.IgniteCheckedException;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.Ignition;\n+import org.apache.ignite.binary.BinaryObject;\n+import org.apache.ignite.cache.CacheAtomicityMode;\n+import org.apache.ignite.cache.CacheMode;\n+import org.apache.ignite.cache.QueryEntity;\n+import org.apache.ignite.cache.QueryIndex;\n+import org.apache.ignite.cache.query.SqlFieldsQuery;\n+import org.apache.ignite.cluster.ClusterNode;\n+import org.apache.ignite.cluster.ClusterState;\n+import org.apache.ignite.configuration.CacheConfiguration;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteClientReconnectAbstractTest;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.CustomEventListener;\n+import org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\n+import org.apache.ignite.internal.processors.cache.GridCacheContext;\n+import org.apache.ignite.internal.processors.query.GridQueryProcessor;\n+import org.apache.ignite.internal.processors.query.h2.IgniteH2Indexing;\n+import org.apache.ignite.internal.processors.query.schema.SchemaOperationException;\n+import org.apache.ignite.internal.processors.query.schema.message.SchemaFinishDiscoveryMessage;\n+import org.apache.ignite.internal.util.typedef.G;\n+import org.apache.ignite.internal.util.typedef.T2;\n+import org.apache.ignite.internal.util.typedef.X;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.transactions.TransactionSerializationException;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test different scnerarions on concurrent enabling indexing.\n+ */\n+@RunWith(Parameterized.class)\n+public class DynamicEnableIndexingConcurrentSelfTest extends DynamicEnableIndexingAbstractTest {\n+    /** Test parameters. */\n+    @Parameters(name = \"cacheMode={0},atomicityMode={1}\")\n+    public static Iterable<Object[]> params() {\n+        CacheMode[] cacheModes = new CacheMode[] {CacheMode.PARTITIONED, CacheMode.REPLICATED};\n+\n+        CacheAtomicityMode[] atomicityModes = new CacheAtomicityMode[] {\n+                CacheAtomicityMode.ATOMIC,\n+                CacheAtomicityMode.TRANSACTIONAL,\n+                CacheAtomicityMode.TRANSACTIONAL_SNAPSHOT\n+        };\n+\n+        List<Object[]> res = new ArrayList<>();\n+        for (CacheMode cacheMode : cacheModes) {\n+            for (CacheAtomicityMode atomicityMode : atomicityModes)\n+                res.add(new Object[] {cacheMode, atomicityMode});\n+        }\n+\n+        return res;\n+    }\n+\n+    /** Latches to block certain index operations. */\n+    private static final ConcurrentHashMap<UUID, T2<CountDownLatch, CountDownLatch>> BLOCKS =\n+            new ConcurrentHashMap<>();\n+\n+    /** Name field index name. */\n+    private static final String NAME_FIELD_IDX_NAME = \"name_idx\";\n+\n+    /** Large number of entries. */\n+    private static final int LARGE_NUM_ENTRIES = 100_000;\n+\n+    /** */\n+    @Parameter(0)\n+    public CacheMode cacheMode;\n+\n+    /** */\n+    @Parameter(1)\n+    public CacheAtomicityMode atomicityMode;\n+\n+\n+    /** {@inheritDoc} */\n+    @Override protected void beforeTest() throws Exception {\n+        super.beforeTest();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        GridQueryProcessor.idxCls = null;\n+\n+        for (T2<CountDownLatch, CountDownLatch> block : BLOCKS.values())\n+            block.get1().countDown();\n+\n+        BLOCKS.clear();\n+\n+        stopAllGrids();\n+\n+        super.afterTest();\n+    }\n+\n+    /**\n+     * Test pending operation when coordinator change.\n+     */\n+    @Test\n+    public void testCoordinatorChange() throws Exception {\n+        // Start servers.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+        ignitionStart(serverConfiguration(2));\n+        ignitionStart(serverConfiguration(3));\n+        ignitionStart(serverConfiguration(4));\n+\n+        // Start client.\n+        IgniteEx cli = ignitionStart(clientConfiguration(5));\n+        cli.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(cli);\n+        loadData(cli, 0, NUM_ENTRIES);\n+\n+        // Test migration between normal servers.\n+        UUID id1 = srv1.cluster().localNode().id();\n+\n+        CountDownLatch idxLatch = blockIndexing(id1);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(cli);\n+\n+        idxLatch.await();\n+\n+        Ignition.stop(srv1.name(), true);\n+\n+        unblockIndexing(id1);\n+\n+        tblFut.get();\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertTrue(query(g, SELECT_ALL_QUERY).size() >= 3 * NUM_ENTRIES / 4 );\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** */\n+    @Test\n+    public void testClientReconnect() throws Exception {\n+        // Start servers.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+        ignitionStart(serverConfiguration(2));\n+        ignitionStart(serverConfiguration(3));\n+        ignitionStart(serverConfiguration(4));\n+\n+        // Start client.\n+        IgniteEx cli = ignitionStart(clientConfiguration(5));\n+        cli.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(cli);\n+        loadData(cli, 0, NUM_ENTRIES);\n+\n+        // Reconnect client and enable indexing before client connects.\n+        IgniteClientReconnectAbstractTest.reconnectClientNode(log, cli, srv1, () -> {\n+            try {\n+                enableIndexing(srv1).get();\n+            }\n+            catch (IgniteCheckedException e) {\n+                throw new IgniteException(\"Failed to enable indexing\", e);\n+            }\n+        });\n+\n+        assertEquals(NUM_ENTRIES, query(cli, SELECT_ALL_QUERY).size());\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** */\n+    @Test\n+    public void testNodeJoinOnPendingOperation() throws Exception {\n+        CountDownLatch finishLatch = new CountDownLatch(3);\n+\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1), finishLatch);\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, NUM_ENTRIES);\n+\n+        CountDownLatch idxLatch = blockIndexing(srv1);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(srv1);\n+\n+        U.await(idxLatch);\n+\n+        ignitionStart(serverConfiguration(2), finishLatch);\n+        ignitionStart(serverConfiguration(3), finishLatch);\n+\n+        awaitPartitionMapExchange();\n+\n+        assertFalse(tblFut.isDone());\n+\n+        unblockIndexing(srv1);\n+\n+        tblFut.get();\n+\n+        U.await(finishLatch);\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** Test chaining schema operation with enable indexing. */\n+    @Test\n+    public void testOperationChaining() throws Exception {\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+\n+        ignitionStart(serverConfiguration(2));\n+        ignitionStart(serverConfiguration(3, true));\n+        ignitionStart(clientConfiguration(4));\n+\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, NUM_ENTRIES);\n+\n+        CountDownLatch idxLatch = blockIndexing(srv1);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(srv1);\n+\n+        QueryIndex idx = new QueryIndex();\n+        idx.setName(NAME_FIELD_IDX_NAME.toUpperCase());\n+        idx.setFieldNames(Collections.singletonList(NAME_FIELD_NAME.toUpperCase()), true);\n+\n+        IgniteInternalFuture<?> idxFut1 = srv1.context().query().dynamicIndexCreate(POI_CACHE_NAME, POI_SCHEMA_NAME,\n+                POI_TABLE_NAME, idx, false, 0);\n+\n+        idxLatch.await();\n+\n+        // Add more nodes.\n+        ignitionStart(serverConfiguration(5));\n+        ignitionStart(serverConfiguration(6, true));\n+        ignitionStart(clientConfiguration(7));\n+\n+        assertFalse(tblFut.isDone());\n+        assertFalse(idxFut1.isDone());\n+\n+        unblockIndexing(srv1);\n+\n+        idxFut1.get();\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+\n+            IgniteCache<Object, Object> cache = g.cache(POI_CACHE_NAME);\n+\n+            assertIndexUsed(cache, \"SELECT * FROM \" + POI_TABLE_NAME + \" WHERE name = 'POI_100'\", NAME_FIELD_IDX_NAME);\n+\n+            List<List<?>> res = cache.query(new SqlFieldsQuery(\"SELECT \" + ID_FIELD_NAME + \" FROM \" + POI_TABLE_NAME +\n+                    \" WHERE name = 'POI_100'\").setSchema(POI_SCHEMA_NAME)).getAll();\n+\n+            assertEquals(1, res.size());\n+            assertEquals(100, res.get(0).get(0));\n+        }\n+    }\n+\n+    /** Enable indexing on ongoing rebalance. */\n+    @Test\n+    public void testConcurrentRebalance() throws Exception {\n+        // Start cache and populate it with data.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1));\n+        Ignite srv2 = ignitionStart(serverConfiguration(2));\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, LARGE_NUM_ENTRIES);\n+\n+        // Start index operation in blocked state.\n+        CountDownLatch idxLatch1 = blockIndexing(srv1);\n+        CountDownLatch idxLatch2 = blockIndexing(srv2);\n+\n+        IgniteInternalFuture<?> tblFut = enableIndexing(srv1);\n+\n+        U.await(idxLatch1);\n+        U.await(idxLatch2);\n+\n+        // Start two more nodes and unblock index operation in the middle.\n+        ignitionStart(serverConfiguration(3));\n+\n+        unblockIndexing(srv1);\n+        unblockIndexing(srv2);\n+\n+        ignitionStart(serverConfiguration(4));\n+\n+        awaitPartitionMapExchange();\n+\n+        tblFut.get();\n+\n+        for (Ignite g: G.allGrids()) {\n+            assertEquals(LARGE_NUM_ENTRIES, query(g, SELECT_ALL_QUERY).size());\n+\n+            performQueryingIntegrityCheck(g);\n+\n+            checkQueryParallelism((IgniteEx)g, cacheMode);\n+        }\n+    }\n+\n+    /** Test concurrent put remove when enabling indexing. */\n+    @Test\n+    public void testConcurrentPutRemove() throws Exception {\n+        CountDownLatch finishLatch = new CountDownLatch(4);\n+\n+        // Start several nodes.\n+        IgniteEx srv1 = ignitionStart(serverConfiguration(1), finishLatch);\n+        ignitionStart(serverConfiguration(2), finishLatch);\n+        ignitionStart(serverConfiguration(3), finishLatch);\n+        ignitionStart(serverConfiguration(4), finishLatch);\n+\n+        srv1.cluster().state(ClusterState.ACTIVE);\n+\n+        createCache(srv1);\n+        loadData(srv1, 0, LARGE_NUM_ENTRIES);\n+\n+        // Start data change operations from several threads.\n+        final AtomicBoolean stopped = new AtomicBoolean();\n+\n+        IgniteInternalFuture<?> task = multithreadedAsync(() -> {\n+            while (!stopped.get()) {\n+                Ignite node = grid(ThreadLocalRandom.current().nextInt(1, 5));\n+\n+                ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n+                int i = rnd.nextInt(0, LARGE_NUM_ENTRIES);\n+\n+                BinaryObject val = node.binary().builder(POI_CLASS_NAME)\n+                    .setField(NAME_FIELD_NAME, \"POI_\" + i, String.class)\n+                    .setField(LATITUDE_FIELD_NAME, rnd.nextDouble(), Double.class)\n+                    .setField(LONGITUDE_FIELD_NAME, rnd.nextDouble(), Double.class)\n+                    .build();\n+\n+                IgniteCache<Object, BinaryObject> cache = node.cache(POI_CACHE_NAME).withKeepBinary();\n+\n+                try {\n+                    if (ThreadLocalRandom.current().nextBoolean())\n+                        cache.put(i, val);\n+                    else\n+                        cache.remove(i);\n+                }\n+                catch (CacheException e) {\n+                    if (!X.hasCause(e, TransactionSerializationException.class))", "originalCommit": "0aca464607a49bd164fc7e9d8c23a062b1390754", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDg0MQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442724841", "bodyText": "Because it is normal situation, see documentation to TRANSACTIONAL_SHAPSHOT", "author": "ivandasch", "createdAt": "2020-06-19T09:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDQxMw=="}], "type": "inlineReview"}, {"oid": "c69f3a57fd37c5f01505913b43784aaebcc33284", "url": "https://github.com/apache/ignite/commit/c69f3a57fd37c5f01505913b43784aaebcc33284", "message": "IGNITE-12808 Latch vs sleep", "committedDate": "2020-06-19T09:30:20Z", "type": "commit"}, {"oid": "ba0e3662389047cbfa1cfa061213c790fd9f06d0", "url": "https://github.com/apache/ignite/commit/ba0e3662389047cbfa1cfa061213c790fd9f06d0", "message": "IGNITE-12808 Some revert.", "committedDate": "2020-06-19T12:39:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgzNzc1Mw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442837753", "bodyText": "Typo: extra layer of indentation can be omitted.", "author": "nizhikov", "createdAt": "2020-06-19T13:23:18Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/query/GridQueryProcessor.java", "diffHunk": "@@ -2834,6 +3013,42 @@ public void cancelQueries(Collection<Long> queries) {\n         return startIndexOperationDistributed(op);\n     }\n \n+    /**\n+     * Enable dynamically indexing of existing cache.\n+     *\n+     * @param cacheName Cache name\n+     * @param schemaName Target schema name.\n+     * @param entity Instance of {@code QueryEntity}.\n+     * @param qryParallelism Query parallelism.\n+     * @param sqlEscape Escape flag, see{@link QueryUtils#normalizeQueryEntity}.\n+     */\n+    public IgniteInternalFuture<?> dynamicAddQueryEntity(\n+            String cacheName,", "originalCommit": "ba0e3662389047cbfa1cfa061213c790fd9f06d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2MjgwMw==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442862803", "bodyText": "Typo: dot in the end.", "author": "nizhikov", "createdAt": "2020-06-19T14:09:59Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheContext.java", "diffHunk": "@@ -2350,6 +2352,39 @@ public boolean hasContinuousQueryListeners(@Nullable IgniteInternalTx tx) {\n             contQryMgr.notifyContinuousQueries(tx) && !F.isEmpty(contQryMgr.updateListeners(false, false));\n     }\n \n+    /**\n+     * Apply changes from {@link SchemaAddQueryEntityOperation}", "originalCommit": "ba0e3662389047cbfa1cfa061213c790fd9f06d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2MjkzMg==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442862932", "bodyText": "Typo: dot instead of , in the end.", "author": "nizhikov", "createdAt": "2020-06-19T14:10:14Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheContext.java", "diffHunk": "@@ -2350,6 +2352,39 @@ public boolean hasContinuousQueryListeners(@Nullable IgniteInternalTx tx) {\n             contQryMgr.notifyContinuousQueries(tx) && !F.isEmpty(contQryMgr.updateListeners(false, false));\n     }\n \n+    /**\n+     * Apply changes from {@link SchemaAddQueryEntityOperation}\n+     *\n+     * @param op Add query entity schema operation.\n+     */\n+    public void onSchemaAddQueryEntity(SchemaAddQueryEntityOperation op) {\n+        onSchemaAddQueryEntity(op.entities(), op.schemaName(), op.isSqlEscape(),\n+                op.queryParallelism());\n+    }\n+\n+    /**\n+     * Apply changes on enable indexing.\n+     *\n+     * @param entities New query entities.\n+     * @param sqlSchema Sql schema name,", "originalCommit": "ba0e3662389047cbfa1cfa061213c790fd9f06d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2MzExMQ==", "url": "https://github.com/apache/ignite/pull/7627#discussion_r442863111", "bodyText": "Typo: dot in the end.", "author": "nizhikov", "createdAt": "2020-06-19T14:10:32Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/GridCacheContextInfo.java", "diffHunk": "@@ -167,6 +168,24 @@ public boolean isCacheContextInited() {\n         return cctx != null;\n     }\n \n+    /**\n+     * Apply changes from {@link SchemaAddQueryEntityOperation}", "originalCommit": "ba0e3662389047cbfa1cfa061213c790fd9f06d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}