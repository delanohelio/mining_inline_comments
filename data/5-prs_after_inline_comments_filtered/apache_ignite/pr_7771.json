{"pr_number": 7771, "pr_title": "IGNITE-12894 Adds ability to wait for the service topology initialization.", "pr_createdAt": "2020-05-04T21:29:42Z", "pr_url": "https://github.com/apache/ignite/pull/7771", "timeline": [{"oid": "9f0116ca009b512124c4be38ef011989e17050b5", "url": "https://github.com/apache/ignite/commit/9f0116ca009b512124c4be38ef011989e17050b5", "message": "IGNITE-12894 Adds ability to wait for the service topology.", "committedDate": "2020-05-04T17:26:50Z", "type": "commit"}, {"oid": "644068df61bb82306f1345135c7a155cc31bd3d9", "url": "https://github.com/apache/ignite/commit/644068df61bb82306f1345135c7a155cc31bd3d9", "message": "IGNITE-12894 Adds service topology timeout tests.", "committedDate": "2020-05-05T00:35:42Z", "type": "forcePushed"}, {"oid": "f2b00afb3ca9e9d79a18ef383a440f2ddf819bfa", "url": "https://github.com/apache/ignite/commit/f2b00afb3ca9e9d79a18ef383a440f2ddf819bfa", "message": "IGNITE-12894 Adds service topology timeout tests.", "committedDate": "2020-05-05T07:59:11Z", "type": "forcePushed"}, {"oid": "dd1041db0b79a864bd5664c04923be83da1d21be", "url": "https://github.com/apache/ignite/commit/dd1041db0b79a864bd5664c04923be83da1d21be", "message": "IGNITE-12894 Adds service topology timeout tests.", "committedDate": "2020-05-05T08:03:12Z", "type": "forcePushed"}, {"oid": "1bcd1e3de25d9c9020ff18e1d07673f3a1e7524a", "url": "https://github.com/apache/ignite/commit/1bcd1e3de25d9c9020ff18e1d07673f3a1e7524a", "message": "IGNITE-12894 Adds service topology timeout tests.", "committedDate": "2020-05-05T13:19:19Z", "type": "forcePushed"}, {"oid": "6feb3131a2ebd88a6e762bc6d89916752db36b54", "url": "https://github.com/apache/ignite/commit/6feb3131a2ebd88a6e762bc6d89916752db36b54", "message": "IGNITE-12894 Adds test for waiting of the service topology.", "committedDate": "2020-05-05T19:34:14Z", "type": "forcePushed"}, {"oid": "e90b3e1fe1352c0d9f370bdaf635be69629f5029", "url": "https://github.com/apache/ignite/commit/e90b3e1fe1352c0d9f370bdaf635be69629f5029", "message": "IGNITE-12894 Adds test for waiting of the service topology.", "committedDate": "2020-05-05T19:42:19Z", "type": "forcePushed"}, {"oid": "252e43b81435b5cdbaa964fa0ba171b24849c0da", "url": "https://github.com/apache/ignite/commit/252e43b81435b5cdbaa964fa0ba171b24849c0da", "message": "IGNITE-12894 Adds test for waiting of the service topology.", "committedDate": "2020-05-05T19:51:24Z", "type": "forcePushed"}, {"oid": "deeac4d57b8205adffd5b04710aa5e037c962a04", "url": "https://github.com/apache/ignite/commit/deeac4d57b8205adffd5b04710aa5e037c962a04", "message": "IGNITE-12894 Adds test for waiting of the service topology.", "committedDate": "2020-05-05T19:54:37Z", "type": "forcePushed"}, {"oid": "cd12af2b9e3c40c5db052b10a1121b53a683c27f", "url": "https://github.com/apache/ignite/commit/cd12af2b9e3c40c5db052b10a1121b53a683c27f", "message": "IGNITE-12894 Adds test for waiting of the service topology.", "committedDate": "2020-05-06T07:20:36Z", "type": "forcePushed"}, {"oid": "9a9f14bdfeed36968ef362aaacdd0b5317a9c3a9", "url": "https://github.com/apache/ignite/commit/9a9f14bdfeed36968ef362aaacdd0b5317a9c3a9", "message": "IGNITE-12894 Adds test for waiting of the service topology.", "committedDate": "2020-05-11T08:03:41Z", "type": "forcePushed"}, {"oid": "09a7ec9efa33c735ac6666e7a87197c3028a56de", "url": "https://github.com/apache/ignite/commit/09a7ec9efa33c735ac6666e7a87197c3028a56de", "message": "IGNITE-12894 Adds test for waiting of the service topology.", "committedDate": "2020-05-12T07:39:27Z", "type": "commit"}, {"oid": "09a7ec9efa33c735ac6666e7a87197c3028a56de", "url": "https://github.com/apache/ignite/commit/09a7ec9efa33c735ac6666e7a87197c3028a56de", "message": "IGNITE-12894 Adds test for waiting of the service topology.", "committedDate": "2020-05-12T07:39:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MDYxOA==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r423880618", "bodyText": "This condition can be moved outside the synchronized block.", "author": "daradurvs", "createdAt": "2020-05-12T16:44:06Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/service/IgniteServiceProcessor.java", "diffHunk": "@@ -823,19 +823,26 @@ else if (prj.predicate() == F.<ClusterNode>alwaysTrue())\n \n         long startTime = U.currentTimeMillis();\n \n-        Map<UUID, Integer> top;\n+        ServiceInfo desc;\n \n         while (true) {\n-            top = serviceTopology(name);\n+             desc = lookupInRegisteredServices(name);\n \n-            if (timeout == 0 || (top != null && !top.isEmpty()))\n-                return top;\n+            if (timeout == 0 && desc == null)\n+                return null;\n \n             synchronized (servicesTopsUpdateMux) {\n-                long wait = timeout - (U.currentTimeMillis() - startTime);\n+                if (desc != null && desc.topologyInitialized())", "originalCommit": "09a7ec9efa33c735ac6666e7a87197c3028a56de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMDQ5OA==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r423900498", "bodyText": "I think it cannot be done that way.\nIf topology is updated before acquiring of servicesTopsUpdateMux but after this condiiton, we will be blocked until the next full msg.", "author": "ololo3000", "createdAt": "2020-05-12T17:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MDYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MzcxOQ==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r423883719", "bodyText": "Use ServiceDeploymentProcessAbstractTest and BlockingTcpDiscoverySpi instead of latches.", "author": "daradurvs", "createdAt": "2020-05-12T16:48:55Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {", "originalCommit": "09a7ec9efa33c735ac6666e7a87197c3028a56de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1MjcxOA==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r423952718", "bodyText": "BlockingTcpDiscoverySpi gives an ability to only make the full msg disappear. In my cases it's needed to block/unblock the full msg and awaits for the completion of its processing.", "author": "ololo3000", "createdAt": "2020-05-12T18:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg4MzcxOQ=="}], "type": "inlineReview"}, {"oid": "c6b41aa260f558f52c6592e0ac730e85fcd1a080", "url": "https://github.com/apache/ignite/commit/c6b41aa260f558f52c6592e0ac730e85fcd1a080", "message": "IGNITE-12894 Fixes minor issues.", "committedDate": "2020-05-12T18:12:26Z", "type": "forcePushed"}, {"oid": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "url": "https://github.com/apache/ignite/commit/237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "message": "IGNITE-12894 Fixes minor issues.", "committedDate": "2020-05-13T01:01:43Z", "type": "commit"}, {"oid": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "url": "https://github.com/apache/ignite/commit/237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "message": "IGNITE-12894 Fixes minor issues.", "committedDate": "2020-05-13T01:01:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIxOTQ0NA==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424219444", "bodyText": "Constant should be over instance fields.", "author": "daradurvs", "createdAt": "2020-05-13T07:12:56Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;", "originalCommit": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzMDA1NQ==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424230055", "bodyText": "assertEquals(1, fullMsgReceivedLatch.getCount());", "author": "daradurvs", "createdAt": "2020-05-13T07:33:08Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        fullMsgUnblockedLatch.countDown();\n+\n+        deployServices(loc);\n+\n+        fullMsgHandledLatch.await(getTestTimeout(), MILLISECONDS);\n+\n+        assertThrowsWithCause(\n+            () -> rmt.services().serviceProxy(BROKEN_SRVC, Invoker.class, false).invoke(),\n+            IgniteException.class);\n+\n+        assertTrue(rmt.services().serviceProxy(DECENT_SRVC, Invoker.class, false).invoke());\n+    }\n+\n+    /**\n+     * Tests service invocation before its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    @SuppressWarnings(\"Convert2MethodRef\")\n+    public void testServiceTopologyInitializationDelayed() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+", "originalCommit": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzMTg2NQ==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424231865", "bodyText": "assertTrue(fullMsgReceivedLatch.await(getTestTimeout(), MILLISECONDS));", "author": "daradurvs", "createdAt": "2020-05-13T07:36:33Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        fullMsgUnblockedLatch.countDown();\n+\n+        deployServices(loc);\n+\n+        fullMsgHandledLatch.await(getTestTimeout(), MILLISECONDS);\n+\n+        assertThrowsWithCause(\n+            () -> rmt.services().serviceProxy(BROKEN_SRVC, Invoker.class, false).invoke(),\n+            IgniteException.class);\n+\n+        assertTrue(rmt.services().serviceProxy(DECENT_SRVC, Invoker.class, false).invoke());\n+    }\n+\n+    /**\n+     * Tests service invocation before its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    @SuppressWarnings(\"Convert2MethodRef\")\n+    public void testServiceTopologyInitializationDelayed() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        deployServices(loc);\n+\n+        fullMsgReceivedLatch.await(getTestTimeout(), MILLISECONDS);", "originalCommit": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzMjU0Mw==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424232543", "bodyText": "assertEquals(1, fullMsgUnblockedLatch.getCount());", "author": "daradurvs", "createdAt": "2020-05-13T07:37:44Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        fullMsgUnblockedLatch.countDown();\n+\n+        deployServices(loc);\n+\n+        fullMsgHandledLatch.await(getTestTimeout(), MILLISECONDS);\n+\n+        assertThrowsWithCause(\n+            () -> rmt.services().serviceProxy(BROKEN_SRVC, Invoker.class, false).invoke(),\n+            IgniteException.class);\n+\n+        assertTrue(rmt.services().serviceProxy(DECENT_SRVC, Invoker.class, false).invoke());\n+    }\n+\n+    /**\n+     * Tests service invocation before its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    @SuppressWarnings(\"Convert2MethodRef\")\n+    public void testServiceTopologyInitializationDelayed() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        deployServices(loc);\n+\n+        fullMsgReceivedLatch.await(getTestTimeout(), MILLISECONDS);\n+\n+        IgniteInternalFuture<Boolean> decentSvcFut = runAsync(() ->\n+            rmt.services().serviceProxy(DECENT_SRVC, Invoker.class, false).invoke());\n+\n+        IgniteInternalFuture<Boolean> brokenSvcFut = runAsync(() ->\n+            rmt.services().serviceProxy(BROKEN_SRVC, Invoker.class, false).invoke());\n+\n+        U.sleep(500);\n+", "originalCommit": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNDE3MQ==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424234171", "bodyText": "assertEquals(1, fullMsgUnblockedLatch.getCount());", "author": "daradurvs", "createdAt": "2020-05-13T07:40:35Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+", "originalCommit": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNDkzNA==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424234934", "bodyText": "@BeforeClass because all these tests are valid only for new service processor implementaion.", "author": "daradurvs", "createdAt": "2020-05-13T07:41:56Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before", "originalCommit": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNTY4Nw==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424235687", "bodyText": "assertTrue(fullMsgHandledLatch.await(getTestTimeout(), MILLISECONDS));", "author": "daradurvs", "createdAt": "2020-05-13T07:43:13Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        fullMsgUnblockedLatch.countDown();\n+\n+        deployServices(loc);\n+\n+        fullMsgHandledLatch.await(getTestTimeout(), MILLISECONDS);", "originalCommit": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIzNTk1OA==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424235958", "bodyText": "assertEquals(1, fullMsgHandledLatch.getCount());", "author": "daradurvs", "createdAt": "2020-05-13T07:43:41Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/service/GridServiceProxyTopologyInitializationTest.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.service;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+import org.apache.ignite.Ignite;\n+import org.apache.ignite.IgniteException;\n+import org.apache.ignite.configuration.IgniteConfiguration;\n+import org.apache.ignite.internal.IgniteEx;\n+import org.apache.ignite.internal.IgniteInternalFuture;\n+import org.apache.ignite.internal.managers.discovery.DiscoveryCustomMessage;\n+import org.apache.ignite.internal.util.typedef.internal.U;\n+import org.apache.ignite.services.Service;\n+import org.apache.ignite.services.ServiceConfiguration;\n+import org.apache.ignite.services.ServiceContext;\n+import org.apache.ignite.services.ServiceDeploymentException;\n+import org.apache.ignite.spi.discovery.tcp.TestTcpDiscoverySpi;\n+import org.apache.ignite.testframework.GridTestUtils.DiscoveryHook;\n+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.apache.ignite.testframework.GridTestUtils.assertThrowsWithCause;\n+import static org.apache.ignite.testframework.GridTestUtils.runAsync;\n+\n+/**\n+ * Tests service invocation if requested service is not deployed on the local node and the service topology is required.\n+ */\n+public class GridServiceProxyTopologyInitializationTest extends GridCommonAbstractTest {\n+    /** Name of the service that throws exception during initialization. */\n+    private static final String BROKEN_SRVC = \"broken-service\";\n+\n+    /** Name of the decent service. */\n+    private static final String DECENT_SRVC = \"decent-service\";\n+\n+    /** Name of the attribute that shows whether test servise deployment will be skipped on the node. */\n+    private static final String ATTR_SKIP_DEPLOYMENT = \"skip-deployment\";\n+\n+    /** Latch that indicates whether {@link ServiceSingleNodeDeploymentResultBatch} execution should be proceeded. */\n+    private final CountDownLatch fullMsgUnblockedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was received on the remote node. */\n+    private final CountDownLatch fullMsgReceivedLatch = new CountDownLatch(1);\n+\n+    /** Latch that indicated whether {@link ServiceSingleNodeDeploymentResultBatch} was handled on the remote node. */\n+    private final CountDownLatch fullMsgHandledLatch = new CountDownLatch(1);\n+\n+    /** Number of the test nodes. */\n+    private static final int NODES_CNT = 2;\n+\n+    /** {@inheritDoc} */\n+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {\n+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);\n+\n+        if (getTestIgniteInstanceName(NODES_CNT - 1).equals(igniteInstanceName)) {\n+            ((TestTcpDiscoverySpi) cfg.getDiscoverySpi()).discoveryHook(new DiscoveryHook() {\n+                @Override public void beforeDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch) {\n+                        fullMsgReceivedLatch.countDown();\n+\n+                        try {\n+                            fullMsgUnblockedLatch.await(getTestTimeout(), MILLISECONDS);\n+                        }\n+                        catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                }\n+\n+                @Override public void afterDiscovery(DiscoveryCustomMessage customMsg) {\n+                    if (customMsg instanceof ServiceClusterDeploymentResultBatch)\n+                        fullMsgHandledLatch.countDown();\n+                }\n+            });\n+\n+            cfg.setUserAttributes(Collections.singletonMap(ATTR_SKIP_DEPLOYMENT, true));\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Ignores the test in case the legacy service processor is used.\n+     */\n+    @Before\n+    public void check() {\n+        Assume.assumeTrue(isEventDrivenServiceProcessorEnabled());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected void afterTest() throws Exception {\n+        super.afterTest();\n+\n+        stopAllGrids();\n+    }\n+\n+    /**\n+     * Tests service invocation after its topology is initialized on the local node.\n+     *\n+     * @throws Exception If fails.\n+     */\n+    @Test\n+    public void testServiceTopologyInitialized() throws Exception {\n+        IgniteEx loc = startGrids(NODES_CNT);\n+\n+        IgniteEx rmt = grid(NODES_CNT - 1);\n+\n+        fullMsgUnblockedLatch.countDown();\n+", "originalCommit": "237ea81b1f5c4ac2d2c9dfe168f8318a8705b9b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "afdcc73714c6cee411668f0e79c204fa0a3db3c4", "url": "https://github.com/apache/ignite/commit/afdcc73714c6cee411668f0e79c204fa0a3db3c4", "message": "IGNITE-12894 Fixes minor issues.", "committedDate": "2020-05-13T09:13:08Z", "type": "commit"}, {"oid": "b8abcc20413a66ea6c07a1d9a8e7acd8ec8df82c", "url": "https://github.com/apache/ignite/commit/b8abcc20413a66ea6c07a1d9a8e7acd8ec8df82c", "message": "Merge branch 'master' of https://github.com/apache/ignite into IGNITE-12894", "committedDate": "2020-05-13T09:28:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk4ODEyMQ==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r424988121", "bodyText": "It looks like this block should be moved outside the loop\ndesc = lookupInRegisteredServices(name);\n\nif (timeout == 0 && desc == null)\n    return null;\n\nand variable desc shoud be refreshed under mutex\nsynchronized (servicesTopsUpdateMux) {\n    desc = lookupInRegisteredServices(name);\n    ...\n\nBecause there is might be a race, when during the checks service can be unregistered and ServiceClusterDeploymentResultBatch processed.\nThat means it's possible hanging because in your case wait might be equal to 0 - that means \"wait forever\".\nRefreshing desc under mutex - not to provide us happens-before guarantees but provide processing order guarantees: when undeployment may be processed before we start waiting for topology initialization.\nAlternative solution - do not wait for 0 and use 100 for example to retry the cycle.\nBut it's would be better to provide processing order guarantees.\nWhat do you think?", "author": "daradurvs", "createdAt": "2020-05-14T09:12:08Z", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/service/IgniteServiceProcessor.java", "diffHunk": "@@ -823,19 +823,26 @@ else if (prj.predicate() == F.<ClusterNode>alwaysTrue())\n \n         long startTime = U.currentTimeMillis();\n \n-        Map<UUID, Integer> top;\n+        ServiceInfo desc;\n \n         while (true) {\n-            top = serviceTopology(name);\n+             desc = lookupInRegisteredServices(name);", "originalCommit": "b8abcc20413a66ea6c07a1d9a8e7acd8ec8df82c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA0NDIwMg==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r425044202", "bodyText": "I got it. If after [1] but before [2] service is deleted and full message with requested service topology is received, topology of the local ServiceDescriptor reference will never be updated. Is that what you meant?\nwhile (true) {\n    desc = lookupInRegisteredServices(name);\n\n    if (timeout == 0 && desc == null) // [1]\n        return null;\n\n    synchronized (servicesTopsUpdateMux) { // [2]\n        if (desc != null && desc.topologyInitialized())\n            return desc.topologySnapshot();\n\n        long wait = 0;\n\n        if (timeout != 0) {\n            wait = timeout - (U.currentTimeMillis() - startTime);\n\n            if (wait <= 0)\n                return desc == null ? null : desc.topologySnapshot();\n        }\n\n        try {\n            servicesTopsUpdateMux.wait(wait);\n        }\n        catch (InterruptedException e) {\n            throw new IgniteInterruptedCheckedException(e);\n        }\n    }\n}\n\nIt seems that it will be enough to only move\ndesc = lookupInRegisteredServices(name);\n\nif (timeout == 0 && desc == null) // [1]\n    return null;\n\ninside the synchronization block.\nIn that case if service is removed before synchronization block acquired or full message is received no matter the order, we will return on\n if (timeout == 0 && desc == null) \n    return null;\n\nif service is removed during synchronization block execution, we anyway will receive the full message and stop waiting.", "author": "ololo3000", "createdAt": "2020-05-14T10:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk4ODEyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExODM3NQ==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r425118375", "bodyText": "I updated PR according to my proposal. Could you please take a look?\nUnfortunately I find it difficult to test this race condition.", "author": "ololo3000", "createdAt": "2020-05-14T13:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk4ODEyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYxOTE5Ng==", "url": "https://github.com/apache/ignite/pull/7771#discussion_r425619196", "bodyText": "Yes, you understood correctly.\nChanges look good to me.\nPlease rerun tests and update TC bot visa in Jira, just to be sure.", "author": "daradurvs", "createdAt": "2020-05-15T07:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk4ODEyMQ=="}], "type": "inlineReview"}, {"oid": "fe0f131086f45e62afd1bb5c773be800aa57c8d4", "url": "https://github.com/apache/ignite/commit/fe0f131086f45e62afd1bb5c773be800aa57c8d4", "message": "IGNITE-12894 Fixes the hang of topology awaiting in case requested service was removed.", "committedDate": "2020-05-14T10:55:40Z", "type": "commit"}]}