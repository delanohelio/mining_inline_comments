{"pr_number": 1003, "pr_title": "Add `ambWith` and `amb` methods for `Single` and `Completable`", "pr_createdAt": "2020-04-05T18:10:06Z", "pr_url": "https://github.com/apple/servicetalk/pull/1003", "timeline": [{"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "url": "https://github.com/apple/servicetalk/commit/d6ec0dad93d1f73f79d79c225a565f315b7c4384", "message": "Add `ambWith` and `amb` methods for `Single` and `Completable`\n\n__Motivation__\n\n[`amb`](http://reactivex.io/documentation/operators/amb.html) is a useful operator for trying multiple sources and using the first result. Few cases that are common;\n- Use as a windowing scheme (number of items or time as window boundarirs)\n- Backup/hedge requests for clients.\n\n__Modification__\n\nUse two flavors of these operators:\n\n- Static factory where an arbitrary number of sources can be ambiguated.\n- Operator to ambiguate a source with other.\n\n__Result__\n\nMore operators, more fun!", "committedDate": "2020-04-05T18:06:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMTAwMw==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404311003", "bodyText": "ambiguates -> this isn't a word. I think the amp operator name is meant to imply it \"ambiguously selects the source of data based upon the first one to produce data\" [1]. consider clarifying this language accordingly.\n[1] http://rxwiki.wikidot.com/enumerableex-amb", "author": "Scottmitch", "createdAt": "2020-04-06T18:45:56Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -1213,6 +1216,29 @@ public final Completable subscribeShareContext() {\n         return new CompletableSubscribeShareContext(this);\n     }\n \n+    /**\n+     * Creates a new {@link Completable} that ambiguates the result of this {@link Completable} with the passed", "originalCommit": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2OTAxOA==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404469018", "bodyText": "ambiguates -> this isn't a word\n\nBUSTED \ud83d\ude22\n\n\"ambiguously selects the source of data based upon the first one to produce data\"\n\nCorrect, thats what I explain in the next line but yeah lemme remove the invalid word \ud83d\ude04", "author": "NiteshKant", "createdAt": "2020-04-07T00:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMTAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMjMyNQ==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404312325", "bodyText": "not sure we need to get complex here but this would be like spawning n threads that each wait on the future, and complete a single future the main thread is waiting on.", "author": "Scottmitch", "createdAt": "2020-04-06T18:48:12Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -1213,6 +1216,29 @@ public final Completable subscribeShareContext() {\n         return new CompletableSubscribeShareContext(this);\n     }\n \n+    /**\n+     * Creates a new {@link Completable} that ambiguates the result of this {@link Completable} with the passed\n+     * {@code other} {@link Completable} such that whichever of them terminates first (successfully or with an error),\n+     * the returned {@link Completable} will return that result.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *      for (Future<T> ft: futures) { // Provided Futures (analogous to the Completables here)", "originalCommit": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzNzgyNg==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404437826", "bodyText": "This operator looks like the equivalent to CompletableFuture.anyOf(...).get(): https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#anyOf-java.util.concurrent.CompletableFuture...-", "author": "idelpivnitskiy", "createdAt": "2020-04-06T22:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMjMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NzU2OQ==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404447569", "bodyText": "@Scottmitch rite we generally do not do that in the documentation to avoid making the pseudo-code more complex to understand.\n@idelpivnitskiy\nThat is correct, interestingly @colestanfield also told me the same offline. Although, I would like to avoid using specific CompletableFuture methods which is async to explain the imperative control-flow here. However, I can add an alias method here for anyOf which delegates to amb", "author": "NiteshKant", "createdAt": "2020-04-06T23:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMjMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ5MjM5Nw==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404492397", "bodyText": "Generally, I don't like the amb name. I prefer more intuitive method names for discoverability, especially in an IDE where I'm looking for a method to do something specific to my problem. Completable  anyOf(Iterable<Completable>) to me also doesn't imply an order.\nI'd suggest a better name would be Completable firstOf(Iterable<Completable>), Completable firstSuccessOf(Iterable), Completable firstFailedOf(Iterable) or more generally Completable findFirst(Iterable<Completable>, Predicate<Completable>) . Implementing the last makes the others trivial helper operators.", "author": "colestanfield", "createdAt": "2020-04-07T01:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMjMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUwMDgzNQ==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404500835", "bodyText": "I agree the amb name isn't ideal. We try to balance \"using names that are pre-established and recognizable in the reactive space\" vs \"using names that are more descriptive of the control flow\". it can be difficult for folks to understand \"which operator do I need\" if all implementations have different names for the same operations. @NiteshKant - what is the precedent for this operator name vs choosing an alternative name?", "author": "Scottmitch", "createdAt": "2020-04-07T02:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMjMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUwNDU5Ng==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404504596", "bodyText": "Thanks all for the input here. I already added anyOf as an alias as there isn\u2019t a clear preference for a name across communities here (as is the case with most operators). Other anyOf variants are useful but not required for my related work ATM and we can add them incrementally later. So I will defer them for now.", "author": "NiteshKant", "createdAt": "2020-04-07T02:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMjMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxODQ5Mg==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404318492", "bodyText": "DelayedCancellable semantics are to provide a Cancellable now when the real Cancellable isn't yet available and not necessarily to protect against concurrent access on cancel (which is an implementation detail). Do these two things necessarily go together, and if so do we want to clarify the javadocs on DelayedCancellable to more clearly state the \"will only cancel upstream once\" semantics?", "author": "Scottmitch", "createdAt": "2020-04-06T18:58:35Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AmbSingles.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class AmbSingles<T> extends Single<T> {\n+    private final Single<? extends T>[] singles;\n+\n+    @SafeVarargs\n+    AmbSingles(final Single<? extends T>... singles) {\n+        for (Single<? extends T> single : singles) {\n+            requireNonNull(single);\n+        }\n+        this.singles = singles;\n+    }\n+\n+    AmbSingles(final Iterable<Single<? extends T>> singles) {\n+        List<Single<? extends T>> allSingles = new ArrayList<>();\n+        for (Single<? extends T> single : singles) {\n+            allSingles.add(requireNonNull(single));\n+        }\n+        @SuppressWarnings({\"unchecked\", \"SuspiciousToArrayCall\"})\n+        Single<? extends T>[] singlesArr = (Single<? extends T>[]) allSingles.toArray(new Single[0]);\n+        this.singles = singlesArr;\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final Cancellable[] cancellables = new Cancellable[singles.length];\n+        final State<T> state = new State<>(subscriber);\n+        subscriber.onSubscribe(state);\n+        try {\n+            for (int i = 0; i < singles.length; i++) {\n+                AmbSubscriber<T> sub = new AmbSubscriber<>(state);\n+                cancellables[i] = sub;\n+                singles[i].subscribeInternal(sub);\n+            }\n+        } catch (Throwable t) {\n+            state.delayedCancellable(CompositeCancellable.create(cancellables));\n+            state.tryError(t);\n+            return;\n+        }\n+        state.delayedCancellable(CompositeCancellable.create(cancellables));\n+    }\n+\n+    static final class AmbSubscriber<T> extends DelayedCancellable implements Subscriber<T> {", "originalCommit": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2NjczMg==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404466732", "bodyText": "In this case we are using DelayedCancellable due to the delay nature (other Subscriber can terminate before this gets onSubscribe()) and not for concurrent access protection. Did you think otherwise?", "author": "NiteshKant", "createdAt": "2020-04-07T00:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxODQ5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUwMTY2OA==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404501668", "bodyText": "The Cancellable maybe invoked concurrently from multiple threads (e.g. singles[i].subscribeInternal(sub); and state.delayedCancellable(CompositeCancellable.create(cancellables));). So in addition to \"delaying\" semantics the assumption is it will also provide \"invoke at most once in a thread safe manner\" semantics. Based upon our usage they are closely related , I'm just suggesting clarifying this in the API contract to make this more explicit.", "author": "Scottmitch", "createdAt": "2020-04-07T02:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxODQ5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzOTMxNw==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404539317", "bodyText": "Ok ya I understand your suggestion.\nThe delay nature essentially introduces potential concurrent invocation as the reason why it is delayed is because we want to use it before the actual Cancellable arrives. It isn't unique about this usage. Let me improve the documentation in a follow up.", "author": "NiteshKant", "createdAt": "2020-04-07T05:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxODQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyMTI5MQ==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404321291", "bodyText": "(pre-existing) since there is a static factory method for generation here, consider breaking apart into two separate classes to avoid unused state and duplicate conditionals.", "author": "Scottmitch", "createdAt": "2020-04-06T19:03:44Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompositeCancellable.java", "diffHunk": "@@ -59,13 +60,30 @@ private CompositeCancellable(Cancellable... others) {\n     public void cancel() {\n         if (cancelledUpdater.compareAndSet(this, 0, 1)) {\n             if (others == null) {\n-                //noinspection ConstantConditions\n-                first.cancel();\n-                //noinspection ConstantConditions\n-                second.cancel();\n+                try {\n+                    //noinspection ConstantConditions\n+                    first.cancel();\n+                } finally {\n+                    //noinspection ConstantConditions\n+                    second.cancel();\n+                }\n             } else {", "originalCommit": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyMjA2Nw==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404322067", "bodyText": "put this in a finally block in case one of the cancel operations throw.", "author": "Scottmitch", "createdAt": "2020-04-06T19:05:06Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AmbSingles.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class AmbSingles<T> extends Single<T> {\n+    private final Single<? extends T>[] singles;\n+\n+    @SafeVarargs\n+    AmbSingles(final Single<? extends T>... singles) {\n+        for (Single<? extends T> single : singles) {\n+            requireNonNull(single);\n+        }\n+        this.singles = singles;\n+    }\n+\n+    AmbSingles(final Iterable<Single<? extends T>> singles) {\n+        List<Single<? extends T>> allSingles = new ArrayList<>();\n+        for (Single<? extends T> single : singles) {\n+            allSingles.add(requireNonNull(single));\n+        }\n+        @SuppressWarnings({\"unchecked\", \"SuspiciousToArrayCall\"})\n+        Single<? extends T>[] singlesArr = (Single<? extends T>[]) allSingles.toArray(new Single[0]);\n+        this.singles = singlesArr;\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final Cancellable[] cancellables = new Cancellable[singles.length];\n+        final State<T> state = new State<>(subscriber);\n+        subscriber.onSubscribe(state);\n+        try {\n+            for (int i = 0; i < singles.length; i++) {\n+                AmbSubscriber<T> sub = new AmbSubscriber<>(state);\n+                cancellables[i] = sub;\n+                singles[i].subscribeInternal(sub);\n+            }\n+        } catch (Throwable t) {\n+            state.delayedCancellable(CompositeCancellable.create(cancellables));\n+            state.tryError(t);", "originalCommit": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyMzM1Mw==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404323353", "bodyText": "nit: put on previous line", "author": "Scottmitch", "createdAt": "2020-04-06T19:07:19Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AmbSingles.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class AmbSingles<T> extends Single<T> {\n+    private final Single<? extends T>[] singles;\n+\n+    @SafeVarargs\n+    AmbSingles(final Single<? extends T>... singles) {\n+        for (Single<? extends T> single : singles) {\n+            requireNonNull(single);\n+        }\n+        this.singles = singles;\n+    }\n+\n+    AmbSingles(final Iterable<Single<? extends T>> singles) {\n+        List<Single<? extends T>> allSingles = new ArrayList<>();\n+        for (Single<? extends T> single : singles) {\n+            allSingles.add(requireNonNull(single));\n+        }\n+        @SuppressWarnings({\"unchecked\", \"SuspiciousToArrayCall\"})\n+        Single<? extends T>[] singlesArr = (Single<? extends T>[]) allSingles.toArray(new Single[0]);\n+        this.singles = singlesArr;\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final Cancellable[] cancellables = new Cancellable[singles.length];\n+        final State<T> state = new State<>(subscriber);\n+        subscriber.onSubscribe(state);\n+        try {\n+            for (int i = 0; i < singles.length; i++) {\n+                AmbSubscriber<T> sub = new AmbSubscriber<>(state);\n+                cancellables[i] = sub;\n+                singles[i].subscribeInternal(sub);\n+            }\n+        } catch (Throwable t) {\n+            state.delayedCancellable(CompositeCancellable.create(cancellables));\n+            state.tryError(t);\n+            return;\n+        }\n+        state.delayedCancellable(CompositeCancellable.create(cancellables));\n+    }\n+\n+    static final class AmbSubscriber<T> extends DelayedCancellable implements Subscriber<T> {\n+        private final State<T> state;\n+\n+        AmbSubscriber(final State<T> state) {\n+            this.state = state;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Cancellable cancellable) {\n+            delayedCancellable(cancellable);\n+        }\n+\n+        @Override\n+        public void onSuccess(@Nullable final T result) {\n+            state.trySuccess(result);\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.tryError(t);\n+        }\n+    }\n+\n+    static final class State<T> extends DelayedCancellable {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<State> doneUpdater =\n+                newUpdater(State.class, \"done\");", "originalCommit": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyNzM2Ng==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404327366", "bodyText": "consider including this inside the try catch to avoid letting the exception escape.", "author": "Scottmitch", "createdAt": "2020-04-06T19:14:22Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SingleAmbWith.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.api.AmbSingles.AmbSubscriber;\n+import io.servicetalk.concurrent.api.AmbSingles.State;\n+import io.servicetalk.concurrent.internal.SignalOffloader;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+final class SingleAmbWith<T> extends AbstractNoHandleSubscribeSingle<T> {\n+    private final Single<T> original;\n+    private final Single<T> ambWith;\n+\n+    SingleAmbWith(final Executor executor, final Single<T> original, final Single<T> ambWith) {\n+        super(executor);\n+        this.original = requireNonNull(original);\n+        this.ambWith = requireNonNull(ambWith);\n+    }\n+\n+    @Override\n+    void handleSubscribe(final Subscriber<? super T> subscriber, final SignalOffloader signalOffloader,\n+                         final AsyncContextMap contextMap, final AsyncContextProvider contextProvider) {\n+        State<T> state = new State<>(subscriber);\n+        subscriber.onSubscribe(state);\n+        AmbSubscriber<T> originalSubscriber = new AmbSubscriber<>(state);", "originalCommit": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyNzU2MQ==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404327561", "bodyText": "consider most/all of the allocation/invocations in try/catch to avoid letting exceptions escape. we also have more context here as to when onSubscribe is invoked to avoid letting the exception bubble up and invoking it multiple times.", "author": "Scottmitch", "createdAt": "2020-04-06T19:14:43Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AmbSingles.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class AmbSingles<T> extends Single<T> {\n+    private final Single<? extends T>[] singles;\n+\n+    @SafeVarargs\n+    AmbSingles(final Single<? extends T>... singles) {\n+        for (Single<? extends T> single : singles) {\n+            requireNonNull(single);\n+        }\n+        this.singles = singles;\n+    }\n+\n+    AmbSingles(final Iterable<Single<? extends T>> singles) {\n+        List<Single<? extends T>> allSingles = new ArrayList<>();\n+        for (Single<? extends T> single : singles) {\n+            allSingles.add(requireNonNull(single));\n+        }\n+        @SuppressWarnings({\"unchecked\", \"SuspiciousToArrayCall\"})\n+        Single<? extends T>[] singlesArr = (Single<? extends T>[]) allSingles.toArray(new Single[0]);\n+        this.singles = singlesArr;\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final Cancellable[] cancellables = new Cancellable[singles.length];", "originalCommit": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2NDk2MQ==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404464961", "bodyText": "Good point about onSubscribe(). I will handle exceptions thrown from onSubscribe() but will leave the allocations outside try as it will further complicate control-flow and we expect Single#subscribe() to catch and invoke error on Subscriber anyways.", "author": "NiteshKant", "createdAt": "2020-04-07T00:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyNzU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMzMDIxOQ==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404330219", "bodyText": "what about tests for the Completable variants?", "author": "Scottmitch", "createdAt": "2020-04-06T19:19:36Z", "path": "servicetalk-concurrent-reactivestreams/src/test/java/io/servicetalk/concurrent/reactivestreams/tck/SingleAmbWithTckTest.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.reactivestreams.tck;\n+\n+import io.servicetalk.concurrent.api.Single;\n+\n+import org.testng.annotations.Test;\n+\n+import static io.servicetalk.concurrent.api.Single.never;\n+\n+@Test\n+public class SingleAmbWithTckTest extends AbstractSingleOperatorTckTest<Integer> {", "originalCommit": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2MzYyNA==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404463624", "bodyText": "Ya I did not add it as it was simply delegating to Single#amb() but lemme add the basic tests for it.", "author": "NiteshKant", "createdAt": "2020-04-07T00:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMzMDIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMzU3Mg==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404433572", "bodyText": "Consider suppressing the original t: tt.addSuppressed(t);, like we do in BeforeFinally*.", "author": "idelpivnitskiy", "createdAt": "2020-04-06T22:46:38Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AmbSingles.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class AmbSingles<T> extends Single<T> {\n+    private final Single<? extends T>[] singles;\n+\n+    @SafeVarargs\n+    AmbSingles(final Single<? extends T>... singles) {\n+        for (Single<? extends T> single : singles) {\n+            requireNonNull(single);\n+        }\n+        this.singles = singles;\n+    }\n+\n+    AmbSingles(final Iterable<Single<? extends T>> singles) {\n+        List<Single<? extends T>> allSingles = new ArrayList<>();\n+        for (Single<? extends T> single : singles) {\n+            allSingles.add(requireNonNull(single));\n+        }\n+        @SuppressWarnings({\"unchecked\", \"SuspiciousToArrayCall\"})\n+        Single<? extends T>[] singlesArr = (Single<? extends T>[]) allSingles.toArray(new Single[0]);\n+        this.singles = singlesArr;\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final Cancellable[] cancellables = new Cancellable[singles.length];\n+        final State<T> state = new State<>(subscriber);\n+        subscriber.onSubscribe(state);\n+        try {\n+            for (int i = 0; i < singles.length; i++) {\n+                AmbSubscriber<T> sub = new AmbSubscriber<>(state);\n+                cancellables[i] = sub;\n+                singles[i].subscribeInternal(sub);\n+            }\n+        } catch (Throwable t) {\n+            state.delayedCancellable(CompositeCancellable.create(cancellables));\n+            state.tryError(t);\n+            return;\n+        }\n+        state.delayedCancellable(CompositeCancellable.create(cancellables));\n+    }\n+\n+    static final class AmbSubscriber<T> extends DelayedCancellable implements Subscriber<T> {\n+        private final State<T> state;\n+\n+        AmbSubscriber(final State<T> state) {\n+            this.state = state;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Cancellable cancellable) {\n+            delayedCancellable(cancellable);\n+        }\n+\n+        @Override\n+        public void onSuccess(@Nullable final T result) {\n+            state.trySuccess(result);\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.tryError(t);\n+        }\n+    }\n+\n+    static final class State<T> extends DelayedCancellable {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<State> doneUpdater =\n+                newUpdater(State.class, \"done\");\n+        private final Subscriber<? super T> target;\n+\n+        private volatile int done;\n+\n+        State(final Subscriber<? super T> target) {\n+            this.target = target;\n+        }\n+\n+        void trySuccess(@Nullable final T result) {\n+            if (doneUpdater.compareAndSet(this, 0, 1)) {\n+                // Cancel other as we got a result.\n+                try {\n+                    cancel();\n+                } catch (Throwable t) {\n+                    target.onError(t);\n+                    return;\n+                }\n+                target.onSuccess(result);\n+            }\n+        }\n+\n+        void tryError(final Throwable t) {\n+            if (doneUpdater.compareAndSet(this, 0, 1)) {\n+                // Cancel other as we got a result.\n+                try {\n+                    cancel();\n+                } catch (Throwable tt) {\n+                    target.onError(tt);", "originalCommit": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2ODgwMQ==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404468801", "bodyText": "We are a bit inconsistent here but off late we have been avoiding adding suppressed causes for such unlikely situations generally due to the negatives of adding suppressed causes for static exceptions.", "author": "NiteshKant", "createdAt": "2020-04-07T00:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMzU3Mg=="}], "type": "inlineReview"}, {"oid": "310a350ef0af1b48acd669be4a00860821c2559a", "url": "https://github.com/apple/servicetalk/commit/310a350ef0af1b48acd669be4a00860821c2559a", "message": "Review comments", "committedDate": "2020-04-07T00:46:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MDY5NQ==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404540695", "bodyText": "Should we mention that this is an alias of amb operator and provide cross-links between amb and anyOf in @see tags?", "author": "idelpivnitskiy", "createdAt": "2020-04-07T05:18:21Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -1643,6 +1667,94 @@ public static Completable mergeAllDelayError(int maxConcurrency, Completable...\n         return from(completables).flatMapCompletableDelayError(identity(), maxConcurrency);\n     }\n \n+    /**\n+     * Creates a new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *      for (Future<T> ft: futures) { // Provided Futures (analogous to the Completables here)\n+     *          // This is an approximation, this operator will pick the first result from any of the futures.\n+     *          return ft.get();\n+     *      }\n+     * }</pre>\n+     *\n+     * @param completables {@link Completable}s the result of which are to be ambiguated.\n+     * @return A new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * @see <a href=\"http://reactivex.io/documentation/operators/amb.html\">ReactiveX amb operator.</a>\n+     */\n+    public static Completable amb(final Completable... completables) {\n+        return Single.amb(stream(spliterator(completables), false)\n+                .map(Completable::toSingle).collect(toList())).ignoreElement();\n+    }\n+\n+    /**\n+     * Creates a new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *      for (Future<T> ft: futures) { // Provided Futures (analogous to the Completables here)\n+     *          // This is an approximation, this operator will pick the first result from any of the futures.\n+     *          return ft.get();\n+     *      }\n+     * }</pre>\n+     *\n+     * @param completables {@link Completable}s the result of which are to be ambiguated.\n+     * @return A new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * that result.\n+     * @see <a href=\"http://reactivex.io/documentation/operators/amb.html\">ReactiveX amb operator.</a>\n+     */\n+    public static Completable amb(final Iterable<Completable> completables) {\n+        return Single.amb(stream(completables.spliterator(), false)\n+                .map(Completable::toSingle).collect(toList())).ignoreElement();\n+    }\n+\n+    /**\n+     * Creates a new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *      for (Future<T> ft: futures) { // Provided Futures (analogous to the Completables here)\n+     *          // This is an approximation, this operator will pick the first result from any of the futures.\n+     *          return ft.get();\n+     *      }\n+     * }</pre>\n+     *\n+     * @param completables {@link Completable}s the result of which are to be ambiguated.\n+     * @return A new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * @see <a href=\"http://reactivex.io/documentation/operators/amb.html\">ReactiveX amb operator.</a>\n+     */\n+    public static Completable anyOf(final Completable... completables) {", "originalCommit": "310a350ef0af1b48acd669be4a00860821c2559a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0OTI5OA==", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404549298", "bodyText": "I thought of doing it but decided against as it is an implementation detail that they are the same things, users do not get any value by knowing the relationship.", "author": "NiteshKant", "createdAt": "2020-04-07T05:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MDY5NQ=="}], "type": "inlineReview"}]}