{"pr_number": 1090, "pr_title": "Do not shutdown output channel until client receives the full response", "pr_createdAt": "2020-06-26T20:40:56Z", "pr_url": "https://github.com/apple/servicetalk/pull/1090", "timeline": [{"oid": "4f0c781dd8774343279d80bde128dea5ec7132a1", "url": "https://github.com/apple/servicetalk/commit/4f0c781dd8774343279d80bde128dea5ec7132a1", "message": "Do not shutdown output channel until client receives the full response\n\nMotivation:\n\nWhen client observes \"Connection: close\" header it shutdowns the output\nchannel as soon as request is written. Some servers interpret FIN from\nthe client as an indicator that it lost interest in their data and\ntherefore, server just closes the second half of the connection asap.\nAs the result, connection may be closed before client receives the full\nresponse from the server.\n\nModifications:\n\n- Reproduce this scenario using a simple proxy tunnel that is not aware\nof HTTP protocol semantics;\n- Defer connection closure on the client side until it completes the\nfull request-response iteration;\n- Fail all subsequent or pipelined requests on the connection that moves\nto the \"closing\" state;\n- Adjust `RequestResponseCloseHandlerTest` to not expecting outbound\nhalf-closure on the client side;\n- Add more tests to verify that client handles \"Connection: close\" header\ncorrectly;\n\nResult:\n\nResponse is not aborted when client observes \"Connection: close\" header.", "committedDate": "2020-06-26T20:38:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzNzQ2OQ==", "url": "https://github.com/apple/servicetalk/pull/1090#discussion_r447137469", "bodyText": "If pending > 0 then we are not writing the current request.\nPlz add an explanation about the subtle meaning of this condition:\n\"Protocol inbound closing for a client is when a response is read, which decrements the pending count before reading the inbound closure signal. This means if pending > 0 there are more requests pending responses but the peer has signalled close. We need to abort write for pending requests\"", "author": "NiteshKant", "createdAt": "2020-06-29T17:32:28Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -255,15 +253,14 @@ private void maybeCloseChannelHalfOrFullyOnClosing(final Channel channel, final\n             closeChannel(channel, evt);\n         } else if (isClient) {\n             if (evt == PROTOCOL_CLOSING_INBOUND) {\n-                if (pending != 0 || !has(state, WRITE)) {\n-                    // eagerly close the outbound channel unless we are still writing the current request\n+                if (pending != 0) {\n+                    // Abort the current and all following pipelined requests", "originalCommit": "4f0c781dd8774343279d80bde128dea5ec7132a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE1MzA3Mg==", "url": "https://github.com/apple/servicetalk/pull/1090#discussion_r447153072", "bodyText": "This name and comment isn't indicating the intent of this event.\nAbortWritesEvent is a better name that correctly indicates what we are doing at the moment.", "author": "NiteshKant", "createdAt": "2020-06-29T17:59:57Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java", "diffHunk": "@@ -355,4 +355,15 @@ private ProtocolPayloadEndEvent() {\n             // No instances.\n         }\n     }\n+\n+    /**\n+     * Netty UserEvent to indicate the output channel is closing.", "originalCommit": "4f0c781dd8774343279d80bde128dea5ec7132a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE2MjkyOA==", "url": "https://github.com/apple/servicetalk/pull/1090#discussion_r447162928", "bodyText": "Till now these events represented things that happened on the socket or what is exposed on the Close handler APIs. ChannelOutputClosingEvent is an event generated by the CloseHandler itself. Can we avoid expanding scope of events here? Instead validate/simulate things that will happen on the socket, like aborting writes.", "author": "NiteshKant", "createdAt": "2020-06-29T18:17:58Z", "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandlerTest.java", "diffHunk": "@@ -175,6 +178,7 @@ public Scenarios(final Mode mode, final List<Events> events, final ExpectEvent e\n             SR,         // validate Socket TCP RST -> SO_LINGER=0\n             UC,         // emit User Closing\n             IH, OH, FC, // validate Input/Output Half-close, Full-Close\n+            CE,         // emit ChannelOutputClosingEvent", "originalCommit": "4f0c781dd8774343279d80bde128dea5ec7132a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE3MTQ0Mw==", "url": "https://github.com/apple/servicetalk/pull/1090#discussion_r447171443", "bodyText": "closeReason isn't volatile so this may never see the closeReason.\nInstead of using closeReason here use the new pipeline event to replace writableListener with a \"poison value\" that indicates abort writes and also aborts the current write if present.", "author": "NiteshKant", "createdAt": "2020-06-29T18:32:37Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -408,7 +409,8 @@ private boolean failIfWriteActive(ChannelOutboundListener newChannelOutboundList\n             // It is possible that we have set the writeSubscriber, then the channel becomes inactive, and we will\n             // never notify the write writeSubscriber of the inactive event. So if the channel is inactive we notify\n             // the writeSubscriber.\n-            if (!channel().isActive()) {\n+            // It is also possible that Channel is in closing state, so we need to prevent sending more requests.\n+            if (!channel().isActive() || closeReason != null) {", "originalCommit": "4f0c781dd8774343279d80bde128dea5ec7132a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NzgxNQ==", "url": "https://github.com/apple/servicetalk/pull/1090#discussion_r447847815", "bodyText": "Good catch!\nI have to introduce another volatile boolean to prevent new writes because:\n\nCan not reuse AbortWritesEvent because it's emitted only when there are additional requests in the pipeline. If there is no pipelining and all requests are sequential, it's not emitted => does not abort new writes.\nTried to reuse ProtocolPayloadEndEvent.OUTBOUND but it has a much broader scope (also used for h2) and fails a lot of tests.\nHandling of \"poison value\" for channelOutboundListener complicates internal state management. It adds at least 2 volatile reads (1st in cleanupOnWriteTerminated, 2nd in failIfWriteActive) and complicates isWriteActive` implementation.", "author": "idelpivnitskiy", "createdAt": "2020-06-30T17:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE3MTQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NDc1MQ==", "url": "https://github.com/apple/servicetalk/pull/1090#discussion_r448044751", "bodyText": "Discussed offline. Because closeReason is not on the hot path it's better just to make closeReason volatile instead of expanding internal state with another boolean.", "author": "idelpivnitskiy", "createdAt": "2020-07-01T00:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE3MTQ0Mw=="}], "type": "inlineReview"}, {"oid": "aa70b2ebed49b8807d0c8e840c46224938b3c878", "url": "https://github.com/apple/servicetalk/commit/aa70b2ebed49b8807d0c8e840c46224938b3c878", "message": "Address comments", "committedDate": "2020-06-30T17:02:55Z", "type": "commit"}, {"oid": "a74c80704b9d2296f80377a852a221d4331412ef", "url": "https://github.com/apple/servicetalk/commit/a74c80704b9d2296f80377a852a221d4331412ef", "message": "Remove volatile boolean and make closeReason volatile", "committedDate": "2020-07-01T00:04:13Z", "type": "commit"}]}