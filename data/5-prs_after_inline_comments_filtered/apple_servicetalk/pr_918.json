{"pr_number": 918, "pr_title": "Remove LegacyBlockingSubscriber", "pr_createdAt": "2020-01-13T16:43:17Z", "pr_url": "https://github.com/apple/servicetalk/pull/918", "timeline": [{"oid": "560fd4dc8899f6781a6c4d58d59bab82a9f47863", "url": "https://github.com/apple/servicetalk/commit/560fd4dc8899f6781a6c4d58d59bab82a9f47863", "message": "Remove LegacyBlockingSubscriber\n\nMotivation:\nLegacyBlockingSubscriber was intended for removal but still had some remaining\nutility methods used to orchestrate sequential blocking test execution. This\nfunctionality can be replaced by a TestCollectingPublisherSubscriber.\n\nModifications:\n- Remove LegacyBlockingSubscriber\n- Add TestCollectingPublisherSubscriber which can be used in combination with\nTestPublisherSubscriber or independently.\n\nResult:\nLegacy code removed, more integrated sequential blocking test utilities.", "committedDate": "2020-01-13T17:16:13Z", "type": "commit"}, {"oid": "560fd4dc8899f6781a6c4d58d59bab82a9f47863", "url": "https://github.com/apple/servicetalk/commit/560fd4dc8899f6781a6c4d58d59bab82a9f47863", "message": "Remove LegacyBlockingSubscriber\n\nMotivation:\nLegacyBlockingSubscriber was intended for removal but still had some remaining\nutility methods used to orchestrate sequential blocking test execution. This\nfunctionality can be replaced by a TestCollectingPublisherSubscriber.\n\nModifications:\n- Remove LegacyBlockingSubscriber\n- Add TestCollectingPublisherSubscriber which can be used in combination with\nTestPublisherSubscriber or independently.\n\nResult:\nLegacy code removed, more integrated sequential blocking test utilities.", "committedDate": "2020-01-13T17:16:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAyNDQ2Mw==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r366024463", "bodyText": "Use TerminalNotification here to avoid the awkwardness of representing an onComplete with a Throwable?", "author": "NiteshKant", "createdAt": "2020-01-13T20:58:22Z", "path": "servicetalk-concurrent-api/src/testFixtures/java/io/servicetalk/concurrent/api/TestCollectingPublisherSubscriber.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.unknownStackTrace;\n+\n+/**\n+ * A {@link Subscriber} that enqueues {@link #onNext(Object)} and terminal signals while providing blocking methods\n+ * to consume these events. There are two approaches to using this class:\n+ * <pre>\n+ *     TestCollectingPublisherSubscriber&lt;String&gt; sub = new TestCollectingPublisherSubscriber&lt;&gt;();\n+ *\n+ *     // Approach 1 - verify individual items sequentially.\n+ *     String s = sub.takeOnNext();\n+ *     // verify s\n+ *     sub.awaitOnComplete(); // this will verify that all onNext signals have been consumed\n+ *\n+ *     // Approach 2 - wait for terminal, verify items in bulk.\n+ *     sub.awaitOnComplete(false); // wait for the terminal signal, ignore if there are unconsumed onNext signals.\n+ *     List&lt;String&gt; onNextSignals = sub.pollAllOnNext();\n+ *     // verify all onNextSignals occurred in the expected order\n+ * </pre>\n+ * @param <T> The type of data in {@link #onNext(Object)}.\n+ */\n+public final class TestCollectingPublisherSubscriber<T> implements Subscriber<T> {\n+    private static final Object NULL_ON_NEXT = new Object();\n+    private static final Throwable ON_COMPLETE = unknownStackTrace(new RuntimeException(\"onComplete\"),\n+            TestCollectingPublisherSubscriber.class, \"onComplete\");\n+    private final BlockingQueue<Object> items = new LinkedBlockingQueue<>();\n+    private final CountDownLatch onTerminalLatch = new CountDownLatch(1);\n+    private final CountDownLatch onSubscribeLatch = new CountDownLatch(1);\n+    @Nullable\n+    private Throwable onTerminal;", "originalCommit": "560fd4dc8899f6781a6c4d58d59bab82a9f47863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwMjQyNA==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r367502424", "bodyText": "TerminalNotification gets rid of the ON_COMPLETE but also adds complexity to the usage due to extra null checks (onTerminal maybe null then onTerminal.cause() maybe null) ... I'll change it though bcz I don't have a strong preference.", "author": "Scottmitch", "createdAt": "2020-01-16T16:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAyNDQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAyODA5MA==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r366028090", "bodyText": "Consider adding\nassert onTerminal == null;\nto make sure there is no onNext after a terminal since we verify consumed items post terminal with\nawaitOn[Error/Complete](boolean verifyOnNextConsumed)", "author": "NiteshKant", "createdAt": "2020-01-13T21:07:24Z", "path": "servicetalk-concurrent-api/src/testFixtures/java/io/servicetalk/concurrent/api/TestCollectingPublisherSubscriber.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.unknownStackTrace;\n+\n+/**\n+ * A {@link Subscriber} that enqueues {@link #onNext(Object)} and terminal signals while providing blocking methods\n+ * to consume these events. There are two approaches to using this class:\n+ * <pre>\n+ *     TestCollectingPublisherSubscriber&lt;String&gt; sub = new TestCollectingPublisherSubscriber&lt;&gt;();\n+ *\n+ *     // Approach 1 - verify individual items sequentially.\n+ *     String s = sub.takeOnNext();\n+ *     // verify s\n+ *     sub.awaitOnComplete(); // this will verify that all onNext signals have been consumed\n+ *\n+ *     // Approach 2 - wait for terminal, verify items in bulk.\n+ *     sub.awaitOnComplete(false); // wait for the terminal signal, ignore if there are unconsumed onNext signals.\n+ *     List&lt;String&gt; onNextSignals = sub.pollAllOnNext();\n+ *     // verify all onNextSignals occurred in the expected order\n+ * </pre>\n+ * @param <T> The type of data in {@link #onNext(Object)}.\n+ */\n+public final class TestCollectingPublisherSubscriber<T> implements Subscriber<T> {\n+    private static final Object NULL_ON_NEXT = new Object();\n+    private static final Throwable ON_COMPLETE = unknownStackTrace(new RuntimeException(\"onComplete\"),\n+            TestCollectingPublisherSubscriber.class, \"onComplete\");\n+    private final BlockingQueue<Object> items = new LinkedBlockingQueue<>();\n+    private final CountDownLatch onTerminalLatch = new CountDownLatch(1);\n+    private final CountDownLatch onSubscribeLatch = new CountDownLatch(1);\n+    @Nullable\n+    private Throwable onTerminal;\n+    @Nullable\n+    private Subscription subscription;\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        this.subscription = subscription;\n+        onSubscribeLatch.countDown();\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        items.add(t == null ? NULL_ON_NEXT : t);", "originalCommit": "560fd4dc8899f6781a6c4d58d59bab82a9f47863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAyOTMzMg==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r366029332", "bodyText": "Should we store subscription in a local var so that we are null-checking and returning the same value?\nAlternatively, add an assert subscription == null; in onSubscribe().", "author": "NiteshKant", "createdAt": "2020-01-13T21:10:19Z", "path": "servicetalk-concurrent-api/src/testFixtures/java/io/servicetalk/concurrent/api/TestCollectingPublisherSubscriber.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.unknownStackTrace;\n+\n+/**\n+ * A {@link Subscriber} that enqueues {@link #onNext(Object)} and terminal signals while providing blocking methods\n+ * to consume these events. There are two approaches to using this class:\n+ * <pre>\n+ *     TestCollectingPublisherSubscriber&lt;String&gt; sub = new TestCollectingPublisherSubscriber&lt;&gt;();\n+ *\n+ *     // Approach 1 - verify individual items sequentially.\n+ *     String s = sub.takeOnNext();\n+ *     // verify s\n+ *     sub.awaitOnComplete(); // this will verify that all onNext signals have been consumed\n+ *\n+ *     // Approach 2 - wait for terminal, verify items in bulk.\n+ *     sub.awaitOnComplete(false); // wait for the terminal signal, ignore if there are unconsumed onNext signals.\n+ *     List&lt;String&gt; onNextSignals = sub.pollAllOnNext();\n+ *     // verify all onNextSignals occurred in the expected order\n+ * </pre>\n+ * @param <T> The type of data in {@link #onNext(Object)}.\n+ */\n+public final class TestCollectingPublisherSubscriber<T> implements Subscriber<T> {\n+    private static final Object NULL_ON_NEXT = new Object();\n+    private static final Throwable ON_COMPLETE = unknownStackTrace(new RuntimeException(\"onComplete\"),\n+            TestCollectingPublisherSubscriber.class, \"onComplete\");\n+    private final BlockingQueue<Object> items = new LinkedBlockingQueue<>();\n+    private final CountDownLatch onTerminalLatch = new CountDownLatch(1);\n+    private final CountDownLatch onSubscribeLatch = new CountDownLatch(1);\n+    @Nullable\n+    private Throwable onTerminal;\n+    @Nullable\n+    private Subscription subscription;\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        this.subscription = subscription;\n+        onSubscribeLatch.countDown();\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        items.add(t == null ? NULL_ON_NEXT : t);\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        onTerminal = t;\n+        onTerminalLatch.countDown();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        onTerminal = ON_COMPLETE;\n+        onTerminalLatch.countDown();\n+    }\n+\n+    /**\n+     * Block until {@link #onSubscribe(Subscription)}.\n+     *\n+     * @return The {@link Subscription} from {@link #onSubscribe(Subscription)}.\n+     * @throws InterruptedException if an interrupt occurs while blocking for waiting for\n+     * {@link #onSubscribe(Subscription)}.\n+     */\n+    public Subscription awaitSubscription() throws InterruptedException {\n+        onSubscribeLatch.await();\n+        if (subscription == null) {", "originalCommit": "560fd4dc8899f6781a6c4d58d59bab82a9f47863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwNjg5NA==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r367506894", "bodyText": "I shifted the null check to the onSubscribe, made sure the value wasn't set twice, and changed this to an assert. PTAL", "author": "Scottmitch", "createdAt": "2020-01-16T16:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAyOTMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzMDE2NA==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r366030164", "bodyText": "Consider using drainTo() and stream() for a more succinct representation as we can absorb higher allocations in test code:\nList<Object> consumedItems = new ArrayList<>();\nitems.drainTo(consumedItems);\nreturn consumedItems.stream().map(item -> item == NULL_ON_NEXT ? null : (T) item).collect(toList());", "author": "NiteshKant", "createdAt": "2020-01-13T21:12:03Z", "path": "servicetalk-concurrent-api/src/testFixtures/java/io/servicetalk/concurrent/api/TestCollectingPublisherSubscriber.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.unknownStackTrace;\n+\n+/**\n+ * A {@link Subscriber} that enqueues {@link #onNext(Object)} and terminal signals while providing blocking methods\n+ * to consume these events. There are two approaches to using this class:\n+ * <pre>\n+ *     TestCollectingPublisherSubscriber&lt;String&gt; sub = new TestCollectingPublisherSubscriber&lt;&gt;();\n+ *\n+ *     // Approach 1 - verify individual items sequentially.\n+ *     String s = sub.takeOnNext();\n+ *     // verify s\n+ *     sub.awaitOnComplete(); // this will verify that all onNext signals have been consumed\n+ *\n+ *     // Approach 2 - wait for terminal, verify items in bulk.\n+ *     sub.awaitOnComplete(false); // wait for the terminal signal, ignore if there are unconsumed onNext signals.\n+ *     List&lt;String&gt; onNextSignals = sub.pollAllOnNext();\n+ *     // verify all onNextSignals occurred in the expected order\n+ * </pre>\n+ * @param <T> The type of data in {@link #onNext(Object)}.\n+ */\n+public final class TestCollectingPublisherSubscriber<T> implements Subscriber<T> {\n+    private static final Object NULL_ON_NEXT = new Object();\n+    private static final Throwable ON_COMPLETE = unknownStackTrace(new RuntimeException(\"onComplete\"),\n+            TestCollectingPublisherSubscriber.class, \"onComplete\");\n+    private final BlockingQueue<Object> items = new LinkedBlockingQueue<>();\n+    private final CountDownLatch onTerminalLatch = new CountDownLatch(1);\n+    private final CountDownLatch onSubscribeLatch = new CountDownLatch(1);\n+    @Nullable\n+    private Throwable onTerminal;\n+    @Nullable\n+    private Subscription subscription;\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        this.subscription = subscription;\n+        onSubscribeLatch.countDown();\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        items.add(t == null ? NULL_ON_NEXT : t);\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        onTerminal = t;\n+        onTerminalLatch.countDown();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        onTerminal = ON_COMPLETE;\n+        onTerminalLatch.countDown();\n+    }\n+\n+    /**\n+     * Block until {@link #onSubscribe(Subscription)}.\n+     *\n+     * @return The {@link Subscription} from {@link #onSubscribe(Subscription)}.\n+     * @throws InterruptedException if an interrupt occurs while blocking for waiting for\n+     * {@link #onSubscribe(Subscription)}.\n+     */\n+    public Subscription awaitSubscription() throws InterruptedException {\n+        onSubscribeLatch.await();\n+        if (subscription == null) {\n+            throw new IllegalStateException(\"subscription is null\");\n+        }\n+        return subscription;\n+    }\n+\n+    /**\n+     * Blocks until the next {@link #onNext(Object)} method invocation.\n+     *\n+     * @return item delivered to {@link #onNext(Object)}.\n+     * @throws InterruptedException if an interrupt occurs while blocking for the next item.\n+     */\n+    @Nullable\n+    @SuppressWarnings(\"unchecked\")\n+    public T takeOnNext() throws InterruptedException {\n+        Object item = items.take();\n+        return item == NULL_ON_NEXT ? null : (T) item;\n+    }\n+\n+    /**\n+     * Consume all currently available {@link #onNext(Object)} signals.\n+     *\n+     * @return {@link List} containing all currently available {@link #onNext(Object)} signals.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public List<T> pollAllOnNext() {\n+        List<T> consumedItems = new ArrayList<>();\n+        Object item;\n+        while ((item = items.poll()) != null) {", "originalCommit": "560fd4dc8899f6781a6c4d58d59bab82a9f47863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYyODcyOQ==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r367628729", "bodyText": "done", "author": "Scottmitch", "createdAt": "2020-01-16T20:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzMDE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzMTg3Nw==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r366031877", "bodyText": "Do we need this check?\nI am questioning usefullness more since we are adding pollTerminal() on TestCollectingPublisherSubscriber for this reason. Generally since we have test timeouts, we do not add APIs for time based polls, it will be better to avoid.", "author": "NiteshKant", "createdAt": "2020-01-13T21:15:44Z", "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/PublisherFlatMapSingleTest.java", "diffHunk": "@@ -515,31 +517,37 @@ public void onComplete() {\n \n     @Test\n     public void testEmitFromQueue() throws Exception {\n-        List<LegacyTestSingle<Integer>> emittedSingles = new ArrayList<>();\n-        LegacyBlockingSubscriber<Integer> subscriber = new LegacyBlockingSubscriber<>();\n+        List<TestSingle<Integer>> emittedSingles = new ArrayList<>();\n+        TestCollectingPublisherSubscriber<Integer> blockingSubscriber = new TestCollectingPublisherSubscriber<>();\n+        TestPublisherSubscriber<Integer> subscriber = new TestPublisherSubscriber.Builder<Integer>()\n+                .lastSubscriber(blockingSubscriber).build();\n         toSource(source.flatMapMergeSingle(integer -> {\n-            LegacyTestSingle<Integer> s = new LegacyTestSingle<>();\n+            TestSingle<Integer> s = new TestSingle<>();\n             emittedSingles.add(s);\n             return s;\n         }, 2)).subscribe(subscriber);\n         subscriber.request(Long.MAX_VALUE);\n         source.onNext(1, 1);\n         assertThat(\"Unexpected number of Singles emitted.\", emittedSingles, hasSize(2));\n \n-        LegacyTestSingle<Integer> single1 = emittedSingles.remove(0);\n-        LegacyTestSingle<Integer> single2 = emittedSingles.remove(0);\n+        TestSingle<Integer> single1 = emittedSingles.remove(0);\n+        TestSingle<Integer> single2 = emittedSingles.remove(0);\n+\n         executorService.execute(() -> {\n             single1.onSuccess(2);\n             single2.onSuccess(3);\n         });\n \n-        subscriber.awaitAndVerifyAwaitingItem(2); // Second item would only be sent once the first thread is free.\n-        subscriber.unblock(2);\n-        subscriber.verifyReceived(2);\n+        Integer nextItem = blockingSubscriber.takeOnNext();\n+        assertNotNull(nextItem);\n+        assertEquals(2, nextItem.intValue());\n+        nextItem = blockingSubscriber.takeOnNext();\n+        assertNotNull(nextItem);\n+        assertEquals(3, nextItem.intValue());\n+        assertFalse(blockingSubscriber.pollTerminal(200, MILLISECONDS));", "originalCommit": "560fd4dc8899f6781a6c4d58d59bab82a9f47863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYyOTU4Ng==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r367629586", "bodyText": "This is to test the affirmative that a terminal event isn't delivered until we expect it to be. Just checking blockingSubscriber.awaitOnComplete(); would be \"sufficient\" but the event may have been delivered for some reason other than the source completing (e.g. operator bug).", "author": "Scottmitch", "createdAt": "2020-01-16T20:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzMTg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzMjc1NQ==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r366032755", "bodyText": "Should we add some tests for this class?", "author": "NiteshKant", "createdAt": "2020-01-13T21:17:35Z", "path": "servicetalk-concurrent-api/src/testFixtures/java/io/servicetalk/concurrent/api/TestCollectingPublisherSubscriber.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.unknownStackTrace;\n+\n+/**\n+ * A {@link Subscriber} that enqueues {@link #onNext(Object)} and terminal signals while providing blocking methods\n+ * to consume these events. There are two approaches to using this class:\n+ * <pre>\n+ *     TestCollectingPublisherSubscriber&lt;String&gt; sub = new TestCollectingPublisherSubscriber&lt;&gt;();\n+ *\n+ *     // Approach 1 - verify individual items sequentially.\n+ *     String s = sub.takeOnNext();\n+ *     // verify s\n+ *     sub.awaitOnComplete(); // this will verify that all onNext signals have been consumed\n+ *\n+ *     // Approach 2 - wait for terminal, verify items in bulk.\n+ *     sub.awaitOnComplete(false); // wait for the terminal signal, ignore if there are unconsumed onNext signals.\n+ *     List&lt;String&gt; onNextSignals = sub.pollAllOnNext();\n+ *     // verify all onNextSignals occurred in the expected order\n+ * </pre>\n+ * @param <T> The type of data in {@link #onNext(Object)}.\n+ */\n+public final class TestCollectingPublisherSubscriber<T> implements Subscriber<T> {", "originalCommit": "560fd4dc8899f6781a6c4d58d59bab82a9f47863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY0NzcyNA==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r367647724", "bodyText": "will do", "author": "Scottmitch", "createdAt": "2020-01-16T21:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzMjc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzNDA3Nw==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r366034077", "bodyText": "You can use pollAllOnNext() to simplify:\nList<T> items = pollAllOnNext();\nif (!items.isEmpty()) {\n    throw new IllegalStateException(items.size() + \" onNext items were not processed: \" + items);\n}", "author": "NiteshKant", "createdAt": "2020-01-13T21:20:27Z", "path": "servicetalk-concurrent-api/src/testFixtures/java/io/servicetalk/concurrent/api/TestCollectingPublisherSubscriber.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.unknownStackTrace;\n+\n+/**\n+ * A {@link Subscriber} that enqueues {@link #onNext(Object)} and terminal signals while providing blocking methods\n+ * to consume these events. There are two approaches to using this class:\n+ * <pre>\n+ *     TestCollectingPublisherSubscriber&lt;String&gt; sub = new TestCollectingPublisherSubscriber&lt;&gt;();\n+ *\n+ *     // Approach 1 - verify individual items sequentially.\n+ *     String s = sub.takeOnNext();\n+ *     // verify s\n+ *     sub.awaitOnComplete(); // this will verify that all onNext signals have been consumed\n+ *\n+ *     // Approach 2 - wait for terminal, verify items in bulk.\n+ *     sub.awaitOnComplete(false); // wait for the terminal signal, ignore if there are unconsumed onNext signals.\n+ *     List&lt;String&gt; onNextSignals = sub.pollAllOnNext();\n+ *     // verify all onNextSignals occurred in the expected order\n+ * </pre>\n+ * @param <T> The type of data in {@link #onNext(Object)}.\n+ */\n+public final class TestCollectingPublisherSubscriber<T> implements Subscriber<T> {\n+    private static final Object NULL_ON_NEXT = new Object();\n+    private static final Throwable ON_COMPLETE = unknownStackTrace(new RuntimeException(\"onComplete\"),\n+            TestCollectingPublisherSubscriber.class, \"onComplete\");\n+    private final BlockingQueue<Object> items = new LinkedBlockingQueue<>();\n+    private final CountDownLatch onTerminalLatch = new CountDownLatch(1);\n+    private final CountDownLatch onSubscribeLatch = new CountDownLatch(1);\n+    @Nullable\n+    private Throwable onTerminal;\n+    @Nullable\n+    private Subscription subscription;\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        this.subscription = subscription;\n+        onSubscribeLatch.countDown();\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        items.add(t == null ? NULL_ON_NEXT : t);\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        onTerminal = t;\n+        onTerminalLatch.countDown();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        onTerminal = ON_COMPLETE;\n+        onTerminalLatch.countDown();\n+    }\n+\n+    /**\n+     * Block until {@link #onSubscribe(Subscription)}.\n+     *\n+     * @return The {@link Subscription} from {@link #onSubscribe(Subscription)}.\n+     * @throws InterruptedException if an interrupt occurs while blocking for waiting for\n+     * {@link #onSubscribe(Subscription)}.\n+     */\n+    public Subscription awaitSubscription() throws InterruptedException {\n+        onSubscribeLatch.await();\n+        if (subscription == null) {\n+            throw new IllegalStateException(\"subscription is null\");\n+        }\n+        return subscription;\n+    }\n+\n+    /**\n+     * Blocks until the next {@link #onNext(Object)} method invocation.\n+     *\n+     * @return item delivered to {@link #onNext(Object)}.\n+     * @throws InterruptedException if an interrupt occurs while blocking for the next item.\n+     */\n+    @Nullable\n+    @SuppressWarnings(\"unchecked\")\n+    public T takeOnNext() throws InterruptedException {\n+        Object item = items.take();\n+        return item == NULL_ON_NEXT ? null : (T) item;\n+    }\n+\n+    /**\n+     * Consume all currently available {@link #onNext(Object)} signals.\n+     *\n+     * @return {@link List} containing all currently available {@link #onNext(Object)} signals.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public List<T> pollAllOnNext() {\n+        List<T> consumedItems = new ArrayList<>();\n+        Object item;\n+        while ((item = items.poll()) != null) {\n+            consumedItems.add(item == NULL_ON_NEXT ? null : (T) item);\n+        }\n+        return consumedItems;\n+    }\n+\n+    /**\n+     * Block until a terminal signal is received, throws if {@link #onComplete()} and returns normally if\n+     * {@link #onError(Throwable)}. This method will verify that all {@link #onNext(Object)} signals have been\n+     * consumed.\n+     *\n+     * @return the exception received by {@link #onError(Throwable)}.\n+     * @throws InterruptedException If an interrupt occurs while blocking for the terminal event.\n+     */\n+    public Throwable awaitOnError() throws InterruptedException {\n+        return awaitOnError(true);\n+    }\n+\n+    /**\n+     * Block until a terminal signal is received, throws if {@link #onComplete()} and returns normally if\n+     * {@link #onError(Throwable)}.\n+     *\n+     * @param verifyOnNextConsumed {@code true} to verify that all {@link #onNext(Object)} signals have been consumed\n+     * and throw if not. {@code false} to ignore if {@link #onNext(Object)} signals have been consumed or not.\n+     * @return the exception received by {@link #onError(Throwable)}.\n+     * @throws InterruptedException If an interrupt occurs while blocking for the terminal event.\n+     */\n+    public Throwable awaitOnError(boolean verifyOnNextConsumed) throws InterruptedException {\n+        onTerminalLatch.await();\n+        assert onTerminal != null;\n+        if (onTerminal == ON_COMPLETE) {\n+            throw new IllegalStateException(\"wanted onError but Subscriber terminated with onComplete\");\n+        }\n+        if (verifyOnNextConsumed) {\n+            verifyAllOnNextProcessed();\n+        }\n+        return onTerminal;\n+    }\n+\n+    /**\n+     * Block until a terminal signal is received, throws if {@link #onError(Throwable)} and returns normally if\n+     * {@link #onComplete()}. This method will verify that all {@link #onNext(Object)} signals have been consumed.\n+     *\n+     * @throws InterruptedException If an interrupt occurs while blocking for the terminal event.\n+     */\n+    public void awaitOnComplete() throws InterruptedException {\n+        awaitOnComplete(true);\n+    }\n+\n+    /**\n+     * Block until a terminal signal is received, throws if {@link #onError(Throwable)} and returns normally if\n+     * {@link #onComplete()}.\n+     *\n+     * @param verifyOnNextConsumed {@code true} to verify that all {@link #onNext(Object)} signals have been consumed\n+     * and throw if not. {@code false} to ignore if {@link #onNext(Object)} signals have been consumed or not.\n+     * @throws InterruptedException If an interrupt occurs while blocking for the terminal event.\n+     */\n+    public void awaitOnComplete(boolean verifyOnNextConsumed) throws InterruptedException {\n+        onTerminalLatch.await();\n+        assert onTerminal != null;\n+        if (onTerminal != ON_COMPLETE) {\n+            throw new IllegalStateException(\"wanted onComplete but Subscriber terminated with onError\", onTerminal);\n+        }\n+        if (verifyOnNextConsumed) {\n+            verifyAllOnNextProcessed();\n+        }\n+    }\n+\n+    /**\n+     * Block for a terminal event.\n+     *\n+     * @param timeout The duration of time to wait.\n+     * @param unit The unit of time to apply to the duration.\n+     * @return {@code true} if a terminal event has been received before the timeout duration.\n+     * @throws InterruptedException If an interrupt occurs while blocking for the terminal event.\n+     */\n+    public boolean pollTerminal(long timeout, TimeUnit unit) throws InterruptedException {\n+        return onTerminalLatch.await(timeout, unit);\n+    }\n+\n+    private void verifyAllOnNextProcessed() {\n+        if (!items.isEmpty()) {", "originalCommit": "560fd4dc8899f6781a6c4d58d59bab82a9f47863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY0ODIxOA==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r367648218", "bodyText": "I still have to iterate to build the string, so I'll just keep this for now.", "author": "Scottmitch", "createdAt": "2020-01-16T21:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzNDA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc4NzAwMg==", "url": "https://github.com/apple/servicetalk/pull/918#discussion_r367787002", "bodyText": "I think the above code I provided would output the string pretty close to what is built by the iteration but it is not a big deal, I was just intending to reduce code.", "author": "NiteshKant", "createdAt": "2020-01-17T06:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAzNDA3Nw=="}], "type": "inlineReview"}, {"oid": "c21bc9d42063a3136a8e40ac514a40fdf876f24d", "url": "https://github.com/apple/servicetalk/commit/c21bc9d42063a3136a8e40ac514a40fdf876f24d", "message": "address comments", "committedDate": "2020-01-16T21:10:29Z", "type": "commit"}, {"oid": "7ab634b3b0a233107f6ab81a36b752a8e5bd305a", "url": "https://github.com/apple/servicetalk/commit/7ab634b3b0a233107f6ab81a36b752a8e5bd305a", "message": "simplify verification methods", "committedDate": "2020-01-16T21:14:46Z", "type": "commit"}]}