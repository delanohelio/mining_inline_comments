{"pr_number": 1060, "pr_title": "Allow chunked responses without payload body", "pr_createdAt": "2020-05-19T21:15:02Z", "pr_url": "https://github.com/apple/servicetalk/pull/1060", "timeline": [{"oid": "d14665dd66e31d3b319ff6bdceef009add2942a2", "url": "https://github.com/apple/servicetalk/commit/d14665dd66e31d3b319ff6bdceef009add2942a2", "message": "Allow chunked responses without payload body\n\nMotivation:\n\nSome older server implementations may use connection closure as an indicator\nof message completion even if `Transfer-Encoding: chunked` header is present.\n\nModifications:\n\n- Introduce `H1ProtocolConfig.allowChunkedResponseWithoutBody()` that controls\nthe ability to relax `HttpResponseDecoder`;\n- Add a `H1ProtocolConfigBuilder` option for `allowChunkedResponseWithoutBody()`;\n- Add tests to verify new behavior;\n\nResult:\n\n`HttpResponseDecoder` marks the chunked response as complete if server closes\nthe connection right after the headers.", "committedDate": "2020-05-19T16:05:26Z", "type": "commit"}, {"oid": "a1d7d676c02f3ef4185e20b46b449c7c9c527a52", "url": "https://github.com/apple/servicetalk/commit/a1d7d676c02f3ef4185e20b46b449c7c9c527a52", "message": "Add tests that verify ST still fails the response if the decoder starts reading some chunked-encoded data", "committedDate": "2020-05-19T18:04:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2MTY5Ng==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427661696", "bodyText": "Since we have decoded this buffer, this should always be true?", "author": "NiteshKant", "createdAt": "2020-05-19T23:44:42Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectDecoder.java", "diffHunk": "@@ -448,12 +452,16 @@ protected final void decodeLast(final ChannelHandlerContext ctx, final ByteBuf i\n         // Handle the last unfinished message.\n         if (message != null) {\n             boolean chunked = isTransferEncodingChunked(message.headers());\n-            if (currentState == State.READ_VARIABLE_LENGTH_CONTENT && !in.isReadable() && !chunked) {\n-                // End of connection.\n-                ctx.fireChannelRead(EmptyHttpHeaders.INSTANCE);\n-                closeHandler.protocolPayloadEndInbound(ctx);\n-                resetNow();\n-                return;\n+            if (!in.isReadable()) {", "originalCommit": "a1d7d676c02f3ef4185e20b46b449c7c9c527a52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODA2Mg==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427698062", "bodyText": "There is a case when ByteToMessageDecoder may cumulate some bytes before emitting or transitioning into another state. For example, it may receive some bytes that contribute to the chunk-length, but still not seeing \\r\\n that changes the state. We should verify that there was nothing cumulated.", "author": "idelpivnitskiy", "createdAt": "2020-05-20T01:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2MTY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MDg1Mg==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427670852", "bodyText": "Why is isDecodingRequest() a special case here?", "author": "NiteshKant", "createdAt": "2020-05-20T00:13:27Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectDecoder.java", "diffHunk": "@@ -448,12 +452,16 @@ protected final void decodeLast(final ChannelHandlerContext ctx, final ByteBuf i\n         // Handle the last unfinished message.\n         if (message != null) {\n             boolean chunked = isTransferEncodingChunked(message.headers());\n-            if (currentState == State.READ_VARIABLE_LENGTH_CONTENT && !in.isReadable() && !chunked) {\n-                // End of connection.\n-                ctx.fireChannelRead(EmptyHttpHeaders.INSTANCE);\n-                closeHandler.protocolPayloadEndInbound(ctx);\n-                resetNow();\n-                return;\n+            if (!in.isReadable()) {\n+                if ((currentState == State.READ_VARIABLE_LENGTH_CONTENT && !chunked) ||\n+                        (currentState == State.READ_CHUNK_SIZE && chunked && !isDecodingRequest() &&", "originalCommit": "a1d7d676c02f3ef4185e20b46b449c7c9c527a52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyNDY4NA==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427724684", "bodyText": "To highlight that this is a legit use-case only for the client-side that reads the response message. On the server-side, this is not expected because if a client closes the connection server can not write the response:\n\nClosing the connection cannot be used to indicate the end of a\nrequest body, since it leaves no possibility for the server to send\nback a response.\n\nhttps://tools.ietf.org/html/rfc1945#section-7.2.2", "author": "idelpivnitskiy", "createdAt": "2020-05-20T03:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MDg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5MTcyOA==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428191728", "bodyText": "On the server-side, this is not expected because if a client closes the connection server can not write the response:\n\nResponse may have already been sent.\nIf we follow spec for spec exceptions then isn't that ironic?", "author": "NiteshKant", "createdAt": "2020-05-20T17:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MDg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0NDY4OQ==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428244689", "bodyText": "A client that sends a \"close\" connection option\nMUST close the connection after reading the final response message\ncorresponding to this request.\n\n\nA server that sends a \"close\" connection option MUST initiate a close\nof the connection (see below) after it sends the response containing\n\"close\".\n\nServer-side is a bit more involved. Because closure initiated by the server may be concurrent with closure initiated by the client, decoder can not correctly understand which side closes the connection. It requires more work and additional testing for this PR to make sure we do not behave incorrectly.\nLet's limit the scope of this PR and defer server-side changes until we know the use-case.", "author": "idelpivnitskiy", "createdAt": "2020-05-20T19:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MDg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM2MzU3MA==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428363570", "bodyText": "Discussed offline, we will make it work for client and server decoders. Tests for the server side will be added later.\nDone in 64fb4cc", "author": "idelpivnitskiy", "createdAt": "2020-05-20T23:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MDg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MjE2OA==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427672168", "bodyText": "Is it necessary to special case this only when Connection: close header is present?", "author": "NiteshKant", "createdAt": "2020-05-20T00:18:01Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H1ProtocolConfigBuilder.java", "diffHunk": "@@ -130,14 +131,39 @@ public H1ProtocolConfigBuilder trailersEncodedSizeEstimate(final int trailersEnc\n         return this;\n     }\n \n+    /**\n+     * Defines if an HTTP/1.1 response with <a href=\"https://tools.ietf.org/html/rfc7230#section-6.1\">\n+     * Connection: close</a> and <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.1\">", "originalCommit": "a1d7d676c02f3ef4185e20b46b449c7c9c527a52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyMDQ2Mw==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427720463", "bodyText": "If I understand RFC 7230 correctly - yes. Every time a server wants to close the connection without any errors, it should express this intend using Connection: close header. Otherwise, the closure is unexpected.\nhttps://tools.ietf.org/html/rfc7230#section-6.6", "author": "idelpivnitskiy", "createdAt": "2020-05-20T03:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5MjgxMg==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428192812", "bodyText": "We are adding an exception to spec rules, it seems we can make this more generic than to follow the spec.", "author": "NiteshKant", "createdAt": "2020-05-20T17:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0ODM3Nw==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428248377", "bodyText": "The question: is it worth making it more generic before we know the use-case? I would prefer to keep the scope of each exception minimal as broader scope of not following RFC may introduce undesired behavior.", "author": "idelpivnitskiy", "createdAt": "2020-05-20T19:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM2Mzk1OA==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428363958", "bodyText": "Discussed offline and decided to remove requirement for the presence of Connection: close header.\nFixed in 64fb4cc", "author": "idelpivnitskiy", "createdAt": "2020-05-20T23:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MjE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MzkxMg==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427673912", "bodyText": "I am thinking if we need to make a special mention of Transfer-Encoding: chunked here?\nCan we have this option generally as allowPrematureClosureWithNoPayload()?\nWe can then generally say that if we see connection closure and no payload was received we assume there was no payload sent, unless contentLength > 0.", "author": "NiteshKant", "createdAt": "2020-05-20T00:24:24Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H1ProtocolConfigBuilder.java", "diffHunk": "@@ -130,14 +131,39 @@ public H1ProtocolConfigBuilder trailersEncodedSizeEstimate(final int trailersEnc\n         return this;\n     }\n \n+    /**\n+     * Defines if an HTTP/1.1 response with <a href=\"https://tools.ietf.org/html/rfc7230#section-6.1\">\n+     * Connection: close</a> and <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.1\">\n+     * Transfer-Encoding: chunked</a> headers that does not start reading the\n+     * <a href=\"https://tools.ietf.org/html/rfc7230#section-4.1\">chunked-body</a> before server closes the connection\n+     * should be considered as a legit response.\n+     * <p>\n+     * While this use-case is not supported by <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.3\">RFC 7230</a>,\n+     * some older server implementations may use connection closure as an indicator of message completion even if\n+     * {@code Transfer-Encoding: chunked} header is present:\n+     * <pre>{@code\n+     *     HTTP/1.1 200 OK\n+     *     Content-Type: text/plain\n+     *     Transfer-Encoding: chunked", "originalCommit": "a1d7d676c02f3ef4185e20b46b449c7c9c527a52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyMTc5Nw==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427721797", "bodyText": "If a response has neither Content-Length nor Transfer-Encoding: chunked this is a legit use-case that we already support today, no special flag is needed. See:\n\nhttps://tools.ietf.org/html/rfc7230#section-3.3.3, item 7;\nConnectionClosedAfterResponseTest#payloadWithoutMessageLengthHeader() test;\nHttpResponseDecoderTest#variableNoTrailersNoContent();", "author": "idelpivnitskiy", "createdAt": "2020-05-20T03:31:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MzkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5NDI2OQ==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428194269", "bodyText": "If a response has neither Content-Length nor Transfer-Encoding: chunked this is a legit use-case\n\nYes I do understand that it is a valid use-case and we support it today. My suggestion is to be less specific when describing the nature of this flag (either in name or javadoc).", "author": "NiteshKant", "createdAt": "2020-05-20T17:43:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MzkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MjcwMA==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428252700", "bodyText": "As in the comment above, I will prefer to see exceptions to be specific.\nSince other use-cases are legit and do not require this exception, it will confuse users and some users will enable this exception without need for that.", "author": "idelpivnitskiy", "createdAt": "2020-05-20T19:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MzkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM2NDQ1Ng==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428364456", "bodyText": "Discussed offline and decided to avoid mentioning chunked encoding in the API and javadoc to simplify understanding of the exception.\nDone in 64fb4cc", "author": "idelpivnitskiy", "createdAt": "2020-05-20T23:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3MzkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3NjU3NQ==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427676575", "bodyText": "It will be good if we can create a bag of spec relaxation options (expecting for more options in the future), which has the following benefits:\n\nSingle place to enable/disable all spec relaxations (better documentation around potential dangers)\nMore emphasis that these options are potentially dangerous.\nBetter visibility for users when looking for unexpected behavior, eg: check if I use one method as opposed to n.\n\nThere are a few ways to approach this:\n\nUse a hierarchical DSL like clientBuilder.secure()\nUse an independent class like H1SpecExceptions which sets the flags and then provide a method here as specExceptions(H1SpecExceptions)\nUse a single method like h1SpecExceptions(boolean allowPrematureClosureWithNoPayload) and add overloads later.\n\nOption (2) seems better to me.", "author": "NiteshKant", "createdAt": "2020-05-20T00:34:09Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H1ProtocolConfigBuilder.java", "diffHunk": "@@ -130,14 +131,39 @@ public H1ProtocolConfigBuilder trailersEncodedSizeEstimate(final int trailersEnc\n         return this;\n     }\n \n+    /**\n+     * Defines if an HTTP/1.1 response with <a href=\"https://tools.ietf.org/html/rfc7230#section-6.1\">\n+     * Connection: close</a> and <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.1\">\n+     * Transfer-Encoding: chunked</a> headers that does not start reading the\n+     * <a href=\"https://tools.ietf.org/html/rfc7230#section-4.1\">chunked-body</a> before server closes the connection\n+     * should be considered as a legit response.\n+     * <p>\n+     * While this use-case is not supported by <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.3\">RFC 7230</a>,\n+     * some older server implementations may use connection closure as an indicator of message completion even if\n+     * {@code Transfer-Encoding: chunked} header is present:\n+     * <pre>{@code\n+     *     HTTP/1.1 200 OK\n+     *     Content-Type: text/plain\n+     *     Transfer-Encoding: chunked\n+     *     Connection: close\n+     * }</pre>\n+     *\n+     * @return {@code this}\n+     */\n+    public H1ProtocolConfigBuilder allowChunkedResponseWithoutBody() {", "originalCommit": "a1d7d676c02f3ef4185e20b46b449c7c9c527a52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyMjMxOA==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427722318", "bodyText": "Good idea, I like option 2 \ud83d\udc4d", "author": "idelpivnitskiy", "createdAt": "2020-05-20T03:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3NjU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY3NzY4MA==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427677680", "bodyText": "Add a few negative cases?\n\nif headers are not complete then we do not infer empty payload.\nif content-length is present and we did not receive the entire content.\nif chunk-header is not complete then we do not infer empty payload.", "author": "NiteshKant", "createdAt": "2020-05-20T00:37:49Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ConnectionClosedAfterResponseTest.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.BlockingHttpClient;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.http.api.HttpResponse;\n+import io.servicetalk.http.api.ReservedBlockingHttpConnection;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.ServerSocketChannel;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpRequestDecoder;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+import static io.netty.channel.ChannelOption.AUTO_CLOSE;\n+import static io.netty.channel.ChannelOption.AUTO_READ;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONNECTION;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_LENGTH;\n+import static io.servicetalk.http.api.HttpHeaderNames.TRANSFER_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderValues.CHUNKED;\n+import static io.servicetalk.http.api.HttpHeaderValues.CLOSE;\n+import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.api.Matchers.contentEqualTo;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h1;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.serverChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Integer.MAX_VALUE;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class ConnectionClosedAfterResponseTest {", "originalCommit": "a1d7d676c02f3ef4185e20b46b449c7c9c527a52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0729c112ab52744a52ce39a12a6ca88a5767d629", "url": "https://github.com/apple/servicetalk/commit/0729c112ab52744a52ce39a12a6ca88a5767d629", "message": "Add more tests", "committedDate": "2020-05-20T04:09:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNTE1OA==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427735158", "bodyText": "IMHO it would be more correct to not call fireChannelRead(...) but ReferenceCountUtil.release(msg) and so consume it.", "author": "normanmaurer", "createdAt": "2020-05-20T04:31:19Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ConnectionClosedAfterResponseTest.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.BlockingHttpClient;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.http.api.HttpResponse;\n+import io.servicetalk.http.api.ReservedBlockingHttpConnection;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.ServerSocketChannel;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpRequestDecoder;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+import static io.netty.channel.ChannelOption.AUTO_CLOSE;\n+import static io.netty.channel.ChannelOption.AUTO_READ;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONNECTION;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_LENGTH;\n+import static io.servicetalk.http.api.HttpHeaderNames.TRANSFER_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderValues.CHUNKED;\n+import static io.servicetalk.http.api.HttpHeaderValues.CLOSE;\n+import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.api.Matchers.contentEqualTo;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h1;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.serverChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Integer.MAX_VALUE;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class ConnectionClosedAfterResponseTest {\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final ServerSocketChannel server;\n+    private final BlockingHttpClient client;\n+    private final AtomicReference<CharSequence> encodedResponse = new AtomicReference<>();\n+    private final CountDownLatch connectionClosedLatch = new CountDownLatch(1);\n+\n+    public ConnectionClosedAfterResponseTest() {\n+        EventLoopAwareNettyIoExecutor eventLoopAwareNettyIoExecutor =\n+                toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor());\n+        EventLoop loop = eventLoopAwareNettyIoExecutor.eventLoopGroup().next();\n+\n+        ServerBootstrap bs = new ServerBootstrap();\n+        bs.group(loop);\n+        bs.channel(serverChannel(loop, InetSocketAddress.class));\n+        bs.childHandler(new ChannelInitializer() {\n+            @Override\n+            protected void initChannel(final Channel ch) {\n+                ch.pipeline().addLast(new HttpRequestDecoder());\n+                ch.pipeline().addLast(new HttpObjectAggregator(MAX_VALUE));\n+                ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+                    @Override\n+                    public void channelRead(final ChannelHandlerContext ctx, final Object msg) {\n+                        if (msg instanceof FullHttpRequest) {\n+                            ctx.writeAndFlush(ByteBufUtil.writeAscii(ctx.alloc(), encodedResponse.get()))\n+                                    .addListener(ChannelFutureListener.CLOSE);\n+                        }\n+                        ctx.fireChannelRead(msg);", "originalCommit": "a1d7d676c02f3ef4185e20b46b449c7c9c527a52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNTYwNQ==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427735605", "bodyText": "Is this also tearing down the eventLoopAwareNettyIoExecutor ? If not we need to do this as well. That said if that's the case we should close the server first as otherwise the EventLoop will be shutdown already", "author": "normanmaurer", "createdAt": "2020-05-20T04:33:33Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ConnectionClosedAfterResponseTest.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.BlockingHttpClient;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.http.api.HttpResponse;\n+import io.servicetalk.http.api.ReservedBlockingHttpConnection;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.ServerSocketChannel;\n+import io.netty.handler.codec.http.FullHttpRequest;\n+import io.netty.handler.codec.http.HttpObjectAggregator;\n+import io.netty.handler.codec.http.HttpRequestDecoder;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+import static io.netty.channel.ChannelOption.AUTO_CLOSE;\n+import static io.netty.channel.ChannelOption.AUTO_READ;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONNECTION;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_LENGTH;\n+import static io.servicetalk.http.api.HttpHeaderNames.TRANSFER_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderValues.CHUNKED;\n+import static io.servicetalk.http.api.HttpHeaderValues.CLOSE;\n+import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.api.Matchers.contentEqualTo;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h1;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.serverChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Integer.MAX_VALUE;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThrows;\n+\n+public class ConnectionClosedAfterResponseTest {\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final ServerSocketChannel server;\n+    private final BlockingHttpClient client;\n+    private final AtomicReference<CharSequence> encodedResponse = new AtomicReference<>();\n+    private final CountDownLatch connectionClosedLatch = new CountDownLatch(1);\n+\n+    public ConnectionClosedAfterResponseTest() {\n+        EventLoopAwareNettyIoExecutor eventLoopAwareNettyIoExecutor =\n+                toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor());\n+        EventLoop loop = eventLoopAwareNettyIoExecutor.eventLoopGroup().next();\n+\n+        ServerBootstrap bs = new ServerBootstrap();\n+        bs.group(loop);\n+        bs.channel(serverChannel(loop, InetSocketAddress.class));\n+        bs.childHandler(new ChannelInitializer() {\n+            @Override\n+            protected void initChannel(final Channel ch) {\n+                ch.pipeline().addLast(new HttpRequestDecoder());\n+                ch.pipeline().addLast(new HttpObjectAggregator(MAX_VALUE));\n+                ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+                    @Override\n+                    public void channelRead(final ChannelHandlerContext ctx, final Object msg) {\n+                        if (msg instanceof FullHttpRequest) {\n+                            ctx.writeAndFlush(ByteBufUtil.writeAscii(ctx.alloc(), encodedResponse.get()))\n+                                    .addListener(ChannelFutureListener.CLOSE);\n+                        }\n+                        ctx.fireChannelRead(msg);\n+                    }\n+                });\n+            }\n+        });\n+        bs.childOption(AUTO_READ, true);\n+        bs.childOption(ALLOW_HALF_CLOSURE, true);\n+        bs.childOption(AUTO_CLOSE, false);\n+        server = (ServerSocketChannel) bs.bind(localAddress(0))\n+                .syncUninterruptibly().channel();\n+\n+        client = HttpClients.forSingleAddress(HostAndPort.of(server.localAddress()))\n+                .protocols(h1().allowChunkedResponseWithoutBody().build())\n+                .buildBlocking();\n+    }\n+\n+    @After\n+    public void turnDown() throws Exception {\n+        try {\n+            client.closeGracefully();", "originalCommit": "a1d7d676c02f3ef4185e20b46b449c7c9c527a52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc1NDg1OQ==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r427754859", "bodyText": "Both client and server use GlobalExecutionContext that never shuts down.\nClient does not take ownership of IoExecutor, neither for provided executor nor for global one.", "author": "idelpivnitskiy", "createdAt": "2020-05-20T05:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNTYwNQ=="}], "type": "inlineReview"}, {"oid": "75e2171bc168f102a6cd49c2882a1c1b991512ed", "url": "https://github.com/apple/servicetalk/commit/75e2171bc168f102a6cd49c2882a1c1b991512ed", "message": "Introduce H1SpecExceptions", "committedDate": "2020-05-20T05:32:13Z", "type": "commit"}, {"oid": "3a030ee42ff3fe02cd194ebc3d16865c0fba0492", "url": "https://github.com/apple/servicetalk/commit/3a030ee42ff3fe02cd194ebc3d16865c0fba0492", "message": "Fix PMD error", "committedDate": "2020-05-20T05:37:42Z", "type": "commit"}, {"oid": "4f80b1f1a5299b1cd3b99eeccd6159e003993445", "url": "https://github.com/apple/servicetalk/commit/4f80b1f1a5299b1cd3b99eeccd6159e003993445", "message": "Release ref counted msg in tests", "committedDate": "2020-05-20T05:46:42Z", "type": "commit"}, {"oid": "f50849c74c40aef9c2d38c15e0e97724f39be353", "url": "https://github.com/apple/servicetalk/commit/f50849c74c40aef9c2d38c15e0e97724f39be353", "message": "Update copyright years", "committedDate": "2020-05-20T05:53:46Z", "type": "commit"}, {"oid": "a5e749cf1c6445bd944aa55951bbccf45bbbcfa0", "url": "https://github.com/apple/servicetalk/commit/a5e749cf1c6445bd944aa55951bbccf45bbbcfa0", "message": "Rename constant", "committedDate": "2020-05-20T15:30:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5NDkyNA==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428194924", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Additional extensions for <a href=\"https://tools.ietf.org/html/rfc7230\">HTTP/1.1</a> specification that help to\n          \n          \n            \n                 * Additional exceptions for <a href=\"https://tools.ietf.org/html/rfc7230\">HTTP/1.1</a> specification that help to", "author": "NiteshKant", "createdAt": "2020-05-20T17:44:36Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H1ProtocolConfig.java", "diffHunk": "@@ -87,4 +87,13 @@ default String alpnId() {\n      * <a href=\"https://tools.ietf.org/html/rfc7230#section-4.1.2trailers\">trailer fields</a>\n      */\n     int trailersEncodedSizeEstimate();\n+\n+    /**\n+     * Additional extensions for <a href=\"https://tools.ietf.org/html/rfc7230\">HTTP/1.1</a> specification that help to", "originalCommit": "a5e749cf1c6445bd944aa55951bbccf45bbbcfa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5NTUwOA==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428195508", "bodyText": "I would suggest to remove the words after specification above. \"exceptions for specifications\" is sufficient.", "author": "NiteshKant", "createdAt": "2020-05-20T17:45:35Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H1ProtocolConfig.java", "diffHunk": "@@ -87,4 +87,13 @@ default String alpnId() {\n      * <a href=\"https://tools.ietf.org/html/rfc7230#section-4.1.2trailers\">trailer fields</a>\n      */\n     int trailersEncodedSizeEstimate();\n+\n+    /**\n+     * Additional extensions for <a href=\"https://tools.ietf.org/html/rfc7230\">HTTP/1.1</a> specification that help to\n+     * relax constrains for backward compatibility with older systems.", "originalCommit": "a5e749cf1c6445bd944aa55951bbccf45bbbcfa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5NTgxOQ==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428195819", "bodyText": "EXTENSIONS -> EXCEPTIONS", "author": "NiteshKant", "createdAt": "2020-05-20T17:46:06Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H1ProtocolConfigBuilder.java", "diffHunk": "@@ -29,12 +29,15 @@\n  */\n public final class H1ProtocolConfigBuilder {\n \n+    private static final H1SpecExceptions DEFAULT_H1_SPEC_EXTENSIONS = new H1SpecExceptionsBuilder().build();", "originalCommit": "a5e749cf1c6445bd944aa55951bbccf45bbbcfa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE5NzMxNw==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428197317", "bodyText": "Since this is just a collection of flags and no behavior, I would suggest to make this a concrete class with a private constructor and have the builder as an inner class. It helps to reduce the level of indirections to create an instance.", "author": "NiteshKant", "createdAt": "2020-05-20T17:48:38Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H1SpecExceptions.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+/**\n+ * Additional extensions for <a href=\"https://tools.ietf.org/html/rfc7230\">HTTP/1.1</a> specification that help to\n+ * relax constrains for backward compatibility with older systems.\n+ */\n+public interface H1SpecExceptions {", "originalCommit": "a5e749cf1c6445bd944aa55951bbccf45bbbcfa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c34b01ee5b28fd3ad7bc037e36727b81ff3eab03", "url": "https://github.com/apple/servicetalk/commit/c34b01ee5b28fd3ad7bc037e36727b81ff3eab03", "message": "Fix typos", "committedDate": "2020-05-20T18:40:43Z", "type": "commit"}, {"oid": "b40e6172e9a7510e458797ecd83cae0f6ccf5d16", "url": "https://github.com/apple/servicetalk/commit/b40e6172e9a7510e458797ecd83cae0f6ccf5d16", "message": "Make H1SpecExceptions a class", "committedDate": "2020-05-20T18:45:56Z", "type": "commit"}, {"oid": "64fb4cc1ab4a8c3316a094560bd531dd236615f3", "url": "https://github.com/apple/servicetalk/commit/64fb4cc1ab4a8c3316a094560bd531dd236615f3", "message": "Rename allowChunkedResponseWithoutBody -> allowPrematureClosureBeforePayloadBody", "committedDate": "2020-05-20T23:24:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MDE3Mg==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428380172", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Allows interpreting a premature connection closures as the end of HTTP/1.1 messages if a receiver has not started\n          \n          \n            \n                 * to read the payload body yet.\n          \n          \n            \n                 * Allows interpreting connection closures as the end of HTTP/1.1 messages if the receiver did not receive any part of the payload body before the connection closure.", "author": "NiteshKant", "createdAt": "2020-05-21T00:24:04Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H1SpecExceptions.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+/**\n+ * Additional exceptions for <a href=\"https://tools.ietf.org/html/rfc7230\">HTTP/1.1</a> specification.\n+ */\n+public final class H1SpecExceptions {\n+\n+    private final boolean allowPrematureClosureBeforePayloadBody;\n+\n+    H1SpecExceptions(final boolean allowPrematureClosureBeforePayloadBody) {\n+        this.allowPrematureClosureBeforePayloadBody = allowPrematureClosureBeforePayloadBody;\n+    }\n+\n+    /**\n+     * Allows interpreting a premature connection closures as the end of HTTP/1.1 messages if a receiver has not started\n+     * to read the payload body yet.", "originalCommit": "64fb4cc1ab4a8c3316a094560bd531dd236615f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MDI5NQ==", "url": "https://github.com/apple/servicetalk/pull/1060#discussion_r428380295", "bodyText": "Make this private?", "author": "NiteshKant", "createdAt": "2020-05-21T00:24:34Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H1SpecExceptions.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+/**\n+ * Additional exceptions for <a href=\"https://tools.ietf.org/html/rfc7230\">HTTP/1.1</a> specification.\n+ */\n+public final class H1SpecExceptions {\n+\n+    private final boolean allowPrematureClosureBeforePayloadBody;\n+\n+    H1SpecExceptions(final boolean allowPrematureClosureBeforePayloadBody) {", "originalCommit": "64fb4cc1ab4a8c3316a094560bd531dd236615f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "199cab1e56a82ffb6e0cac46414ea80c4d49e5f3", "url": "https://github.com/apple/servicetalk/commit/199cab1e56a82ffb6e0cac46414ea80c4d49e5f3", "message": "Address comments", "committedDate": "2020-05-21T00:50:10Z", "type": "commit"}]}