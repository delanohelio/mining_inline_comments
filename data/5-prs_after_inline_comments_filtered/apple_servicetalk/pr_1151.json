{"pr_number": 1151, "pr_title": "Initial support for gRPC message-encoding", "pr_createdAt": "2020-09-14T17:50:08Z", "pr_url": "https://github.com/apple/servicetalk/pull/1151", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODExNzkxOA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488117918", "bodyText": "Not a big fan of the request-encoding been defined as part of the metadata. I played with a couple of alternatives,\neg. client.withCompression(...).test(...) which is more fluent, but it has the problem of having to support multiple classes every time we add more fields, to avoid the API misbehavior of client.withCompression(...).withCompression(..)...\nIf we don't mind this API issue (which personally I have mixed feelings), then we could use that notation, lose the field from the metadata, and allow for even more flexible use-cases like\n\n.withCompression(request_encoding, response_encodings) which can override the response encodings per call, rather than use the default ones (defined per client).\n\nOn the other hand, we can always start this way, and re-visit it in the future once we collect some feedback from end-users.", "author": "tkountis", "createdAt": "2020-09-14T17:54:13Z", "path": "servicetalk-grpc-netty/src/test/java/io/servicetalk/grpc/netty/GrpcMessageEncodingTest.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.netty;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.grpc.api.GrpcMessageCodec;\n+import io.servicetalk.grpc.api.GrpcMessageEncoding;\n+import io.servicetalk.grpc.api.GrpcMessageEncodingRegistry;\n+import io.servicetalk.grpc.api.GrpcServerBuilder;\n+import io.servicetalk.grpc.api.GrpcServiceContext;\n+import io.servicetalk.grpc.api.GrpcStatusCode;\n+import io.servicetalk.grpc.api.GrpcStatusException;\n+import io.servicetalk.grpc.netty.TesterProto.TestRequest;\n+import io.servicetalk.grpc.netty.TesterProto.TestResponse;\n+import io.servicetalk.grpc.netty.TesterProto.Tester.TestRequestStreamMetadata;\n+import io.servicetalk.http.api.HttpServiceContext;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+import io.servicetalk.http.api.StreamingHttpService;\n+import io.servicetalk.http.api.StreamingHttpServiceFilter;\n+import io.servicetalk.http.api.StreamingHttpServiceFilterFactory;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import io.grpc.Status;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.function.ThrowingRunnable;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.GZIPOutputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.grpc.internal.GrpcUtil.MESSAGE_ACCEPT_ENCODING;\n+import static io.grpc.internal.GrpcUtil.MESSAGE_ENCODING;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.grpc.api.GrpcExecutionStrategies.noOffloadsStrategy;\n+import static io.servicetalk.grpc.api.GrpcMessageEncoding.toHeaderValue;\n+import static io.servicetalk.grpc.api.GrpcMessageEncodingRegistry.DEFLATE;\n+import static io.servicetalk.grpc.api.GrpcMessageEncodingRegistry.GZIP;\n+import static io.servicetalk.grpc.api.GrpcMessageEncodingRegistry.NONE;\n+import static io.servicetalk.grpc.api.GrpcMessageEncodingRegistry.encodingFor;\n+import static io.servicetalk.grpc.netty.TesterProto.Tester.ClientFactory;\n+import static io.servicetalk.grpc.netty.TesterProto.Tester.ServiceFactory;\n+import static io.servicetalk.grpc.netty.TesterProto.Tester.TestBiDiStreamMetadata;\n+import static io.servicetalk.grpc.netty.TesterProto.Tester.TestMetadata;\n+import static io.servicetalk.grpc.netty.TesterProto.Tester.TestResponseStreamMetadata;\n+import static io.servicetalk.grpc.netty.TesterProto.Tester.TesterClient;\n+import static io.servicetalk.grpc.netty.TesterProto.Tester.TesterService;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.lang.Integer.parseInt;\n+import static java.lang.String.valueOf;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singleton;\n+import static java.util.zip.GZIPInputStream.GZIP_MAGIC;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class GrpcMessageEncodingTest {\n+\n+    private static final String CUSTOM_ENCODING = \"CUSTOM_ENCODING\";\n+    private static final int ORIGINAL_PAYLOAD_SIZE = 512;\n+\n+    private static final Function<TestEncodingScenario, StreamingHttpServiceFilterFactory> REQ_RESP_VERIFIER = (options)\n+                        -> new StreamingHttpServiceFilterFactory() {\n+        @Override\n+        public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+            return new StreamingHttpServiceFilter(service) {\n+                @Override\n+\n+                public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                            final StreamingHttpRequest request,\n+                                                            final StreamingHttpResponseFactory responseFactory) {\n+\n+                    final GrpcMessageEncoding requestEncoding = options.requestEncoding;\n+                    final Set<GrpcMessageEncoding> clientSupportedEncodings = options.clientSupported;\n+                    final Set<GrpcMessageEncoding> serverSupportedEncodings = options.serverSupported;\n+\n+                    request.transformPayloadBody(bufferPublisher -> bufferPublisher.map((buffer -> {\n+                        byte compressedFlag = buffer.getByte(0);\n+\n+                        if (requestEncoding == GZIP || requestEncoding.name().equals(CUSTOM_ENCODING)) {\n+                            int actualHeader = buffer.getShortLE(5) & 0xFFFF;\n+                            assertEquals(GZIP_MAGIC, actualHeader);\n+                        }\n+\n+                        if (requestEncoding != NONE) {\n+                            assertTrue(buffer.readableBytes() < ORIGINAL_PAYLOAD_SIZE);\n+                        } else {\n+                            assertTrue(buffer.readableBytes() > ORIGINAL_PAYLOAD_SIZE);\n+                        }\n+\n+                        assertEquals(requestEncoding != NONE ? 1 : 0, compressedFlag);\n+                        return buffer;\n+                    })));\n+\n+                    final CharSequence actualReqAcceptedEncodings = request.headers()\n+                            .get(MESSAGE_ACCEPT_ENCODING, \"null\");\n+\n+                    final CharSequence expectedReqAcceptedEncodings = toHeaderValue(clientSupportedEncodings == null ?\n+                            singleton(NONE) :\n+                            clientSupportedEncodings);\n+\n+                    assertTrue(contentEquals(requestEncoding.name(), request.headers().get(MESSAGE_ENCODING, \"null\")));\n+                    assertTrue(contentEquals(actualReqAcceptedEncodings, expectedReqAcceptedEncodings));\n+\n+                    return super.handle(ctx, request, responseFactory).map((response -> {\n+\n+                        final CharSequence actualRespAcceptedEncodings = response.headers()\n+                                .get(MESSAGE_ACCEPT_ENCODING, \"null\");\n+\n+                        final CharSequence expectedRespAcceptedEncodings =\n+                                toHeaderValue(serverSupportedEncodings == null ? singleton(NONE) :\n+                                        serverSupportedEncodings);\n+\n+                        assertTrue(contentEquals(expectedRespAcceptedEncodings, actualRespAcceptedEncodings));\n+\n+                        // UNIMPLEMENTED responses will have default encoding\n+                        if (parseInt(valueOf(response.headers().get(\"grpc-status\", \"-1\")))\n+                                == Status.OK.getCode().value()) {\n+\n+                            GrpcMessageEncoding respEnc = encodingFor(valueOf(response.headers()\n+                                    .get(MESSAGE_ENCODING, \"identity\")));\n+\n+                            if (clientSupportedEncodings == null) {\n+                                assertEquals(NONE, respEnc);\n+                            } else {\n+                                if (Collections.disjoint(serverSupportedEncodings, clientSupportedEncodings)) {\n+                                    assertEquals(NONE, respEnc);\n+                                } else {\n+                                    assertTrue(\"Response encoding: [\" + respEnc + \"[ not in the \" +\n+                                                    \"client supported list [\" + clientSupportedEncodings + \"]\",\n+                                            clientSupportedEncodings.contains(respEnc));\n+                                    assertTrue(\"Response encoding: [\" + respEnc + \"[ not in the \" +\n+                                                    \"server supported list [\" + serverSupportedEncodings + \"]\",\n+                                            serverSupportedEncodings.contains(respEnc));\n+                                }\n+                            }\n+                        }\n+                        return response;\n+                    }));\n+                }\n+            };\n+        }\n+    };\n+\n+    static {\n+        GrpcMessageEncodingRegistry.registerEncoding(new GrpcMessageEncoding() {\n+            @Override\n+            public String name() {\n+                return CUSTOM_ENCODING;\n+            }\n+\n+            @Override\n+            public GrpcMessageCodec codec() {\n+                return new GrpcMessageCodec() {\n+                    private static final int OUGHT_TO_BE_ENOUGH = 1 << 20;\n+\n+                    @Override\n+                    public ByteBuffer encode(final ByteBuffer src, final BufferAllocator allocator) {\n+                        try {\n+                            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+                            GZIPOutputStream out = new GZIPOutputStream(bos);\n+                            out.write(src.array(), src.arrayOffset() + src.position(), src.remaining());\n+                            out.finish();\n+                            return ByteBuffer.wrap(bos.toByteArray());\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public ByteBuffer decode(final ByteBuffer src, final BufferAllocator allocator) {\n+                        try {\n+                            GZIPInputStream in = new GZIPInputStream(new ByteArrayInputStream(src.array(),\n+                                    src.arrayOffset() + src.position(), src.remaining()));\n+                            ByteBuffer res = ByteBuffer.allocate(OUGHT_TO_BE_ENOUGH);\n+                            int read = in.read(res.array(), res.arrayOffset() + res.position(), res.remaining());\n+                            res.position(read);\n+                            res.flip();\n+                            in.close();\n+                            return res;\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+                };\n+            }\n+        });\n+    }\n+\n+    private static class TesterServiceImpl implements TesterService {\n+\n+        @Override\n+        public Single<TestResponse> test(GrpcServiceContext ctx, TestRequest request) {\n+            return succeeded(TestResponse.newBuilder().setMessage(\"Reply: \" + request.getName()).build());\n+        }\n+\n+        @Override\n+        public Single<TestResponse> testRequestStream(GrpcServiceContext ctx, Publisher<TestRequest> request) {\n+            try {\n+                List<TestRequest> requestList = request.collect((Supplier<ArrayList<TestRequest>>) ArrayList::new,\n+                        (testRequests, testRequest) -> {\n+                            testRequests.add(testRequest);\n+                            return testRequests;\n+                        }).toFuture().get();\n+\n+                TestRequest elem = requestList.get(0);\n+                return succeeded(TestResponse.newBuilder().setMessage(\"Reply: \" + elem.getName()).build());\n+            } catch (InterruptedException | ExecutionException e) {\n+                e.printStackTrace();\n+            }\n+\n+            return failed(new IllegalStateException());\n+        }\n+\n+        @Override\n+        public Publisher<TestResponse> testBiDiStream(GrpcServiceContext ctx, Publisher<TestRequest> request) {\n+            return request.map((req) -> TestResponse.newBuilder().setMessage(\"Reply: \" + req.getName()).build());\n+        }\n+\n+        @Override\n+        public Publisher<TestResponse> testResponseStream(GrpcServiceContext ctx, TestRequest request) {\n+            return from(TestResponse.newBuilder().setMessage(\"Reply: \" + request.getName()).build());\n+        }\n+    }\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final GrpcServerBuilder grpcServerBuilder;\n+    private final ServerContext serverContext;\n+    private final TesterClient client;\n+    private final GrpcMessageEncoding requestEncoding;\n+    private final boolean expectedSuccess;\n+\n+    public GrpcMessageEncodingTest(final Set<GrpcMessageEncoding> serverSupportedEncodings,\n+                                   final Set<GrpcMessageEncoding> clientSupportedEncodings,\n+                                   final GrpcMessageEncoding requestEncoding,\n+                                   final boolean expectedSuccess) throws Exception {\n+\n+        TestEncodingScenario options = new TestEncodingScenario(requestEncoding, clientSupportedEncodings,\n+                serverSupportedEncodings);\n+\n+        grpcServerBuilder = GrpcServers.forAddress(localAddress(0));\n+        serverContext = listenAndAwait(options);\n+        client = newClient(clientSupportedEncodings);\n+        this.requestEncoding = requestEncoding;\n+        this.expectedSuccess = expectedSuccess;\n+    }\n+\n+    @Parameterized.Parameters(name = \"server-supported-encodings={0} client-supported-encodings={1} \" +\n+                                     \"request-encoding={2} expected-success={3}\")\n+    public static Object[][] params() {\n+        return new Object[][] {\n+                {null, null, NONE, true},\n+                {null, null, GZIP, false},\n+                {null, null, DEFLATE, false},\n+                {of(NONE, GZIP, DEFLATE), null, NONE, true},\n+                {of(NONE, GZIP, DEFLATE), null, GZIP, true},\n+                {of(NONE, GZIP, DEFLATE), null, DEFLATE, true},\n+                {of(NONE, GZIP), null, DEFLATE, false},\n+                {of(NONE, DEFLATE), null, GZIP, false},\n+                {of(NONE, DEFLATE), null, DEFLATE, true},\n+                {of(NONE, DEFLATE), null, NONE, true},\n+                {of(GZIP), null, NONE, true},\n+                {of(GZIP), of(GZIP), NONE, true},\n+                {of(GZIP), of(NONE, GZIP), NONE, true},\n+                {of(GZIP), of(NONE, GZIP), GZIP, true},\n+                {null, of(NONE, GZIP), GZIP, false},\n+                {null, of(NONE, GZIP), DEFLATE, false},\n+                {null, of(NONE, GZIP), NONE, true},\n+        };\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        try {\n+            client.close();\n+        } finally {\n+            serverContext.close();\n+        }\n+    }\n+\n+    private ServerContext listenAndAwait(final TestEncodingScenario encodingOptions) throws Exception {\n+\n+        StreamingHttpServiceFilterFactory filterFactory = REQ_RESP_VERIFIER.apply(encodingOptions);\n+        if (encodingOptions.serverSupported == null) {\n+            return grpcServerBuilder.appendHttpServiceFilter(filterFactory)\n+                                             .listenAndAwait(new ServiceFactory(new TesterServiceImpl()));\n+        } else {\n+            return grpcServerBuilder.appendHttpServiceFilter(filterFactory)\n+                                             .listenAndAwait(new ServiceFactory(new TesterServiceImpl(),\n+                                                     encodingOptions.serverSupported));\n+        }\n+    }\n+\n+    private TesterClient newClient(@Nullable final Set<GrpcMessageEncoding> supportedEncodings) {\n+        return GrpcClients.forAddress(serverHostAndPort(serverContext))\n+                .executionStrategy(noOffloadsStrategy())\n+                .build(supportedEncodings != null ?\n+                        new ClientFactory().supportedEncodings(supportedEncodings) :\n+                        new ClientFactory());\n+    }\n+\n+    @Test\n+    public void test() throws ExecutionException, InterruptedException {\n+        if (expectedSuccess) {\n+            assertSuccessful(requestEncoding);\n+        } else {\n+            assertUnimplemented(requestEncoding);\n+        }\n+    }\n+\n+    private static TestRequest request() {\n+        byte[] payload = new byte[ORIGINAL_PAYLOAD_SIZE];\n+        Arrays.fill(payload, (byte) 1);\n+        return TestRequest.newBuilder().setName(new String(payload, StandardCharsets.US_ASCII)).build();\n+    }\n+\n+    private void assertSuccessful(final GrpcMessageEncoding encoding) throws ExecutionException, InterruptedException {\n+        client.test(new TestMetadata(encoding), request()).toFuture().get();", "originalCommit": "63205711989fb3e59c7719bc0a5035214766fa5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c0904d6e9213b556e1c27461a964d0bd010b19e4", "url": "https://github.com/apple/servicetalk/commit/c0904d6e9213b556e1c27461a964d0bd010b19e4", "message": "Initial support for gRPC message-encoding", "committedDate": "2020-09-14T19:24:19Z", "type": "forcePushed"}, {"oid": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "url": "https://github.com/apple/servicetalk/commit/a13fd0239fc60dc7316c439b41295d9cab932e5e", "message": "Initial support for gRPC message-encoding", "committedDate": "2020-09-15T08:42:45Z", "type": "commit"}, {"oid": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "url": "https://github.com/apple/servicetalk/commit/a13fd0239fc60dc7316c439b41295d9cab932e5e", "message": "Initial support for gRPC message-encoding", "committedDate": "2020-09-15T08:42:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMjUxMg==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488902512", "bodyText": "nit: requireNonNull is not needed here as unmodifiableSet does the check.", "author": "NiteshKant", "createdAt": "2020-09-15T19:07:02Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/DefaultGrpcServiceContext.java", "diffHunk": "@@ -22,22 +22,27 @@\n \n import java.net.SocketAddress;\n import java.net.SocketOption;\n+import java.util.Set;\n import javax.annotation.Nullable;\n import javax.net.ssl.SSLSession;\n \n+import static java.util.Collections.unmodifiableSet;\n import static java.util.Objects.requireNonNull;\n \n final class DefaultGrpcServiceContext extends DefaultGrpcMetadata implements GrpcServiceContext {\n \n     private final ConnectionContext connectionContext;\n     private final GrpcExecutionContext executionContext;\n     private final GrpcProtocol protocol;\n+    final Set<GrpcMessageEncoding> supportedEncodings;\n \n-    DefaultGrpcServiceContext(final String path, final HttpServiceContext httpServiceContext) {\n+    DefaultGrpcServiceContext(final String path, final HttpServiceContext httpServiceContext,\n+                              final Set<GrpcMessageEncoding> supportedEncodings) {\n         super(path);\n         connectionContext = requireNonNull(httpServiceContext);\n         executionContext = new DefaultGrpcExecutionContext(httpServiceContext.executionContext());\n         protocol = new DefaultGrpcProtocol(httpServiceContext.protocol());\n+        this.supportedEncodings = unmodifiableSet(requireNonNull(supportedEncodings));", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMzA0MA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488903040", "bodyText": "Does this class need to be public?", "author": "NiteshKant", "createdAt": "2020-09-15T19:08:01Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/DeflateGrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.InflaterInputStream;\n+\n+public class DeflateGrpcMessageCodec extends ZipGrpcMessageCodec {", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNzE2OQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488907169", "bodyText": "Do we need both a new supportedEncodings method and a new argument for newClient()?", "author": "NiteshKant", "createdAt": "2020-09-15T19:15:43Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcClientFactory.java", "diffHunk": "@@ -112,11 +133,13 @@ final BlockingClient newBlockingClientForCallFactory(GrpcClientCallFactory clien\n      * {@link Client} contract using the passed {@link GrpcClientCallFactory}.\n      *\n      * @param clientCallFactory {@link GrpcClientCallFactory} to use for creating client calls.\n+     * @param supportedEncodings {@link GrpcMessageEncoding} supported encodings for this client.\n      * The returned {@link Client} should own the lifecycle of this factory.\n      * @return A new <a href=\"https://www.grpc.io\">gRPC</a> client following the specified\n      * <a href=\"https://www.grpc.io\">gRPC</a> {@link Client} contract.\n      */\n-    protected abstract Client newClient(GrpcClientCallFactory clientCallFactory);\n+    protected abstract Client newClient(GrpcClientCallFactory clientCallFactory,\n+                                        Set<GrpcMessageEncoding> supportedEncodings);", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1NDcwNQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r489554705", "bodyText": "Good catch, leftover.", "author": "tkountis", "createdAt": "2020-09-16T16:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNzE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNzMwMg==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488907302", "bodyText": "Javadoc?", "author": "NiteshKant", "createdAt": "2020-09-15T19:16:01Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcClientMetadata.java", "diffHunk": "@@ -31,4 +31,6 @@\n      */\n     @Nullable\n     GrpcExecutionStrategy strategy();\n+\n+    GrpcMessageEncoding requestEncoding();", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNzg5Mw==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488907893", "bodyText": "We do not use these annotations elsewhere, can we avoid adding these for now?", "author": "NiteshKant", "createdAt": "2020-09-15T19:17:15Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+\n+import java.nio.ByteBuffer;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Codec used to encode and decode gRPC messages.\n+ * This instance is shared across all requests/responses therefore it must provide thread safety semantics.\n+ */\n+\n+@ThreadSafe", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwODEzMA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488908130", "bodyText": "Extra newline, plz remove.", "author": "NiteshKant", "createdAt": "2020-09-15T19:17:42Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+\n+import java.nio.ByteBuffer;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Codec used to encode and decode gRPC messages.\n+ * This instance is shared across all requests/responses therefore it must provide thread safety semantics.\n+ */\n+", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwODMzMQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488908331", "bodyText": "Javadocs plz!", "author": "NiteshKant", "createdAt": "2020-09-15T19:18:07Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+\n+import java.nio.ByteBuffer;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Codec used to encode and decode gRPC messages.\n+ * This instance is shared across all requests/responses therefore it must provide thread safety semantics.\n+ */\n+\n+@ThreadSafe\n+public interface GrpcMessageCodec {\n+\n+    ByteBuffer encode(ByteBuffer src, BufferAllocator allocator);", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwODcxNA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488908714", "bodyText": "Why the choice of using ByteBuffer as opposed to ST Buffer API? The implementation and consumer of this API will benefit if they do not have to convert to/from ByteBuffer", "author": "NiteshKant", "createdAt": "2020-09-15T19:18:53Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+\n+import java.nio.ByteBuffer;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Codec used to encode and decode gRPC messages.\n+ * This instance is shared across all requests/responses therefore it must provide thread safety semantics.\n+ */\n+\n+@ThreadSafe\n+public interface GrpcMessageCodec {\n+\n+    ByteBuffer encode(ByteBuffer src, BufferAllocator allocator);\n+\n+    ByteBuffer decode(ByteBuffer src, BufferAllocator allocator);", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIwOTUyMA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r490209520", "bodyText": "The conversion was already happening due to protobuf parsers, so we are not really benefiting one way or the other.\nHowever, I believe using ST Buffer made the calling side easier to follow, so I followed the suggestion", "author": "tkountis", "createdAt": "2020-09-17T12:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwODcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxMDgyNw==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488910827", "bodyText": "This method is only used internally and in tests, do we need it on the public API?", "author": "NiteshKant", "createdAt": "2020-09-15T19:21:40Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageEncoding.java", "diffHunk": "@@ -15,26 +15,51 @@\n  */\n package io.servicetalk.grpc.api;\n \n+import java.util.Collection;\n+\n+import static io.servicetalk.grpc.api.GrpcMessageEncodingRegistry.NONE;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+\n /**\n  * Supported <a href=\"https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#message-encoding\">\n  *     gRPC message encoding schemes</a>.\n  */\n-public enum GrpcMessageEncoding {\n-\n-    None(\"identity\");\n-\n-    private final String encoding;\n-\n-    GrpcMessageEncoding(final String encoding) {\n-        this.encoding = encoding;\n-    }\n+public interface GrpcMessageEncoding {\n \n     /**\n      * A string representation for the message encoding.\n      *\n      * @return a string representation for the message encoding.\n      */\n-    public String encoding() {\n-        return encoding;\n+    String name();\n+\n+    /**\n+     * The codec that supports encoding/decoding for this type of message-encoding.\n+     *\n+     * @return a shared instance of the codec for that message-encoding\n+     */\n+    GrpcMessageCodec codec();\n+\n+    /**\n+     * Construct the gRPC header {@code grpc-accept-encoding} representation of the given encodings.\n+     *\n+     * @param encodings the list of encodings to be used in the string representation.\n+     * @return a comma separated string representation of the encodings for use as a header value\n+     */\n+    static CharSequence toHeaderValue(final Collection<GrpcMessageEncoding> encodings) {", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNzkwNg==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488917906", "bodyText": "We generally use the prefix Default instead of the suffic Impl so this would be named DefaultGrpcMessageEncoding", "author": "NiteshKant", "createdAt": "2020-09-15T19:30:00Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageEncodingImpl.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+public class GrpcMessageEncodingImpl implements GrpcMessageEncoding {", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxODMyNw==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488918327", "bodyText": "Does this need to be public?", "author": "NiteshKant", "createdAt": "2020-09-15T19:30:32Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageEncodingImpl.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+public class GrpcMessageEncodingImpl implements GrpcMessageEncoding {", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNTMwOA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488925308", "bodyText": "I am wary of such global registries specially when they are mutable. Can we follow a pattern of using static factories instead and a registry can be created on top when required.\nI am envisioning a GrpcMessageEncodings class with methods like none() , gzip() and deflate()", "author": "NiteshKant", "createdAt": "2020-09-15T19:38:25Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageEncodingRegistry.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public final class GrpcMessageEncodingRegistry {", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNTAxMQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491035011", "bodyText": "I believe I came up with a slightly better approach which gets rid of the registry and doesn't need factories either.\nThe logic of the supported encodings has been moved closer to the serializerprovider, which now knows of the supported-encodings per client / server. This is constructed per route (even though the user can only define it per service for now), therefore there is no need for additional structures. WDYT?", "author": "tkountis", "createdAt": "2020-09-18T15:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyNTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkzMDkyOQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488930929", "bodyText": "I was excited about different supported encodings per route but we did not extend that flexibility on this method :)\nWhat is the reason for this inconsistency?", "author": "NiteshKant", "createdAt": "2020-09-15T19:46:04Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java", "diffHunk": "@@ -209,8 +228,8 @@ private GrpcExecutionStrategy executionStrategy(final String path, final Method\n             final Class<Req> requestClass, final Class<Resp> responseClass,\n             final GrpcSerializationProvider serializationProvider) {\n         final Method method = retrieveMethod(serviceClass, methodName, GrpcServiceContext.class, requestClass);\n-        routeBuilder.addRoute(path, executionStrategy(path, method, serviceClass), route, requestClass, responseClass,\n-                serializationProvider);\n+        routeBuilder.addRoute(path, executionStrategy(path, method, serviceClass), supportedEncodings, route,", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNDk2OQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491034969", "bodyText": "Lets hold on, on this excitement :)\nThe code is ready to support it, but in order to do so, we have to expose options for each route on the factory. I don't want to commit on an API that we still don't know who and how it will be used. Unless you have hard objections, I would like to keep it simpler for now. WDYT?", "author": "tkountis", "createdAt": "2020-09-18T15:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkzMDkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyNDkzMQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r492224931", "bodyText": "ok ya makes sense.", "author": "NiteshKant", "createdAt": "2020-09-21T17:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkzMDkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkzMTQwNA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488931404", "bodyText": "javadocs", "author": "NiteshKant", "createdAt": "2020-09-15T19:46:58Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcService.java", "diffHunk": "@@ -18,12 +18,21 @@\n import io.servicetalk.concurrent.api.AsyncCloseable;\n import io.servicetalk.concurrent.api.Completable;\n \n+import java.util.Set;\n+\n import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.grpc.api.GrpcMessageEncodingRegistry.NONE;\n+import static java.util.Collections.singleton;\n \n /**\n  * A <a href=\"https://www.grpc.io\">gRPC</a> service.\n  */\n public interface GrpcService extends AsyncCloseable {\n+\n+    default Set<GrpcMessageEncoding> supportedEncodings() {", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkzMTQ3OA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488931478", "bodyText": "javadocs", "author": "NiteshKant", "createdAt": "2020-09-15T19:47:07Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcServiceContext.java", "diffHunk": "@@ -29,6 +31,8 @@\n     @Override\n     GrpcProtocol protocol();\n \n+    Set<GrpcMessageEncoding> supportedEncodings();", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0NDQ2MA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488944460", "bodyText": "We generally avoid using streams for collections due to object allocation overhead. This logic looks pretty simpe, can you convert to an iterative approach?", "author": "NiteshKant", "createdAt": "2020-09-15T20:11:13Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java", "diffHunk": "@@ -210,31 +229,96 @@ private static void ensureGrpcStatusReceived(final HttpHeaders headers) {\n         final GrpcStatusCode statusCode = extractGrpcStatusCodeFromHeaders(headers);\n         if (statusCode == null) {\n             // This is a protocol violation as we expect to receive grpc-status.\n-            throw new GrpcStatus(INTERNAL, null, \"Response does not contain \"\n-                    + GRPC_STATUS_CODE_TRAILER + \" header or trailer\").asException();\n+            throw new GrpcStatus(INTERNAL, null, \"Response does not contain \" +\n+                    GRPC_STATUS_CODE_TRAILER + \" header or trailer\").asException();\n         }\n         final GrpcStatusException grpcStatusException = convertToGrpcStatusException(statusCode, headers);\n         if (grpcStatusException != null) {\n             throw grpcStatusException;\n         }\n     }\n \n-    static GrpcMessageEncoding readGrpcMessageEncoding(final HttpMetaData httpMetaData) {\n+    static GrpcMessageEncoding readGrpcMessageEncoding(final HttpMetaData httpMetaData,\n+                                                       final Set<GrpcMessageEncoding> allowedEncodings) {\n         final CharSequence encoding = httpMetaData.headers().get(GRPC_MESSAGE_ENCODING_KEY);\n-        // identity is a special header for no compression\n-        if (encoding != null && !contentEqualsIgnoreCase(encoding, IDENTITY)) {\n+        if (encoding == null) {\n+            return NONE;\n+        }\n+\n+        GrpcMessageEncoding enc = GrpcMessageEncodingRegistry.encodingFor(allowedEncodings, encoding.toString());\n+        if (enc == null) {\n             final String lowercaseEncoding = encoding.toString().toLowerCase();\n-            throw new SerializationException(\"Compression \" + lowercaseEncoding + \" not supported\");\n-        } else {\n-            return None;\n+            throw new MessageEncodingException(lowercaseEncoding);\n+        }\n+\n+        return enc;\n+    }\n+\n+    static Set<GrpcMessageEncoding> readGrpcAcceptMessageEncoding(final HttpMetaData httpMetaData,\n+                                                                  final Set<GrpcMessageEncoding> acceptedEncodings) {\n+        final CharSequence acceptEncodingsHeaderVal = httpMetaData.headers().get(GRPC_ACCEPT_ENCODING_KEY);\n+\n+        if (acceptEncodingsHeaderVal == null || acceptEncodingsHeaderVal.length() == 0) {\n+            return GRPC_ACCEPT_ENCODING_NONE;\n+        }\n+\n+        Set<GrpcMessageEncoding> knownEncodings = new HashSet<>();\n+        List<CharSequence> acceptEncodingValues = split(acceptEncodingsHeaderVal, ',');\n+        for (CharSequence val : acceptEncodingValues) {\n+            GrpcMessageEncoding enc = GrpcMessageEncodingRegistry.encodingFor(acceptedEncodings, val.toString().trim());\n+            if (enc != null) {\n+                knownEncodings.add(enc);\n+            }\n         }\n+\n+        return knownEncodings;\n     }\n \n-    private static void initResponse(final HttpResponseMetaData response) {\n+    static GrpcMessageEncoding firstMatchingEncodingOrNone(final HttpMetaData httpMetaData,\n+                                                           final Set<GrpcMessageEncoding> serverSupportedEncodings) {\n+        // Fast path, server has no encodings configured or has only None configured as encoding\n+        if (serverSupportedEncodings.isEmpty() ||\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(NONE))) {\n+            return NONE;\n+        }\n+\n+        Set<GrpcMessageEncoding> clientSupportedEncodings =\n+                readGrpcAcceptMessageEncoding(httpMetaData, serverSupportedEncodings);\n+        return firstMatchingEncodingOrNone(clientSupportedEncodings, serverSupportedEncodings);\n+    }\n+\n+    static GrpcMessageEncoding firstMatchingEncodingOrNone(final Set<GrpcMessageEncoding> clientSupportedEncodings,\n+                                                           final Set<GrpcMessageEncoding> serverSupportedEncodings) {\n+        // Fast path, Client has no encodings configured, or has None as the only encoding configured\n+        if (clientSupportedEncodings == GRPC_ACCEPT_ENCODING_NONE ||\n+                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(NONE))) {\n+            return NONE;\n+        }\n+\n+        /*\n+         * Iterate to find the first matched encoding, if no matches are found return None\n+         *\n+         * For every message a server is requested to compress using an algorithm it knows the client doesn't support\n+         * (as indicated by the last grpc-accept-encoding header received from the client),\n+         * it SHALL send the message uncompressed.\n+         * ref: https://github.com/grpc/grpc/blob/master/doc/compression.md\n+         */\n+\n+        return serverSupportedEncodings.stream()", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0NTE5OA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488945198", "bodyText": "Make this class pkg private?", "author": "NiteshKant", "createdAt": "2020-09-15T20:12:39Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GzipGrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.GZIPOutputStream;\n+import java.util.zip.InflaterInputStream;\n+\n+public class GzipGrpcMessageCodec extends ZipGrpcMessageCodec {", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0NTQ0Nw==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488945447", "bodyText": "Make this final and add javadocs?", "author": "NiteshKant", "createdAt": "2020-09-15T20:13:10Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/MessageEncodingException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+public class MessageEncodingException extends RuntimeException {", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0NTcxNA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488945714", "bodyText": "Should we also add other constructor overloads specially to avoid filling stack?", "author": "NiteshKant", "createdAt": "2020-09-15T20:13:42Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/MessageEncodingException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+public class MessageEncodingException extends RuntimeException {\n+\n+    private final String encoding;\n+\n+    public MessageEncodingException(String encoding) {", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0NjE2OA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488946168", "bodyText": "Lets reduce visibility of all classes unless we really need them to be public", "author": "NiteshKant", "createdAt": "2020-09-15T20:14:35Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/ZipGrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+public abstract class ZipGrpcMessageCodec implements GrpcMessageCodec {", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk1MDgyMQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488950821", "bodyText": "Can we use Buffer.asOutputStream() method here instead of the custom OutputStream implementation?", "author": "NiteshKant", "createdAt": "2020-09-15T20:23:25Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/ZipGrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+public abstract class ZipGrpcMessageCodec implements GrpcMessageCodec {\n+\n+    private static final int ONE_KB = 1 << 10;\n+\n+    abstract DeflaterOutputStream newCodecOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newCodecInputStream(InputStream in) throws IOException;\n+\n+    @Override\n+    public final ByteBuffer encode(final ByteBuffer src, final BufferAllocator allocator) {\n+\n+        final Buffer buffer = allocator.newBuffer(ONE_KB);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newCodecOutputStream(new OutputStream() {", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk5ODc2NQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r488998765", "bodyText": "I am guessing read/write from these streams may block, is that correct?", "author": "NiteshKant", "createdAt": "2020-09-15T21:49:18Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/ZipGrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+public abstract class ZipGrpcMessageCodec implements GrpcMessageCodec {\n+\n+    private static final int ONE_KB = 1 << 10;\n+\n+    abstract DeflaterOutputStream newCodecOutputStream(OutputStream out) throws IOException;", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzNDc4Ng==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491134786", "bodyText": "Unless I am missing something obvious in your comment, no, they won't block. In both directions (req/resp) the streams are pre-buffered according to the message frame (message length) and only then passed to the codec.\nPlease, let me know if I missed something that you noticed.", "author": "tkountis", "createdAt": "2020-09-18T18:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk5ODc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNDExOA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491224118", "bodyText": "aah got it, makes sense. No you didn't miss anything, I misread.", "author": "NiteshKant", "createdAt": "2020-09-18T22:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk5ODc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAwODEzNQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r489008135", "bodyText": "You would have to check if the src is an array backed buffer using hasArray().\nLook at ServiceTalkBufferAllocator.wrap() as a reference", "author": "NiteshKant", "createdAt": "2020-09-15T22:00:30Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/ZipGrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+public abstract class ZipGrpcMessageCodec implements GrpcMessageCodec {\n+\n+    private static final int ONE_KB = 1 << 10;\n+\n+    abstract DeflaterOutputStream newCodecOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newCodecInputStream(InputStream in) throws IOException;\n+\n+    @Override\n+    public final ByteBuffer encode(final ByteBuffer src, final BufferAllocator allocator) {\n+\n+        final Buffer buffer = allocator.newBuffer(ONE_KB);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newCodecOutputStream(new OutputStream() {\n+                @Override\n+                public void write(final int b) throws IOException {\n+                    buffer.ensureWritable(1);\n+                    buffer.writeByte(b);\n+                }\n+\n+                @Override\n+                public void write(final byte[] b, final int off, final int len) throws IOException {\n+                    buffer.ensureWritable(len);\n+                    buffer.writeBytes(b, off, len);\n+                }\n+            });\n+            output.write(src.array(), src.arrayOffset() + src.position(), src.remaining());", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTAzMTI3Mw==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r489031273", "bodyText": "There is a method setBytesUntilEndStream on the Buffer which does what you are doing here.", "author": "NiteshKant", "createdAt": "2020-09-15T22:29:50Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/ZipGrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+public abstract class ZipGrpcMessageCodec implements GrpcMessageCodec {\n+\n+    private static final int ONE_KB = 1 << 10;\n+\n+    abstract DeflaterOutputStream newCodecOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newCodecInputStream(InputStream in) throws IOException;\n+\n+    @Override\n+    public final ByteBuffer encode(final ByteBuffer src, final BufferAllocator allocator) {\n+\n+        final Buffer buffer = allocator.newBuffer(ONE_KB);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newCodecOutputStream(new OutputStream() {\n+                @Override\n+                public void write(final int b) throws IOException {\n+                    buffer.ensureWritable(1);\n+                    buffer.writeByte(b);\n+                }\n+\n+                @Override\n+                public void write(final byte[] b, final int off, final int len) throws IOException {\n+                    buffer.ensureWritable(len);\n+                    buffer.writeBytes(b, off, len);\n+                }\n+            });\n+            output.write(src.array(), src.arrayOffset() + src.position(), src.remaining());\n+            output.finish();\n+            // Mark original as consumed\n+            src.position(src.position() + src.remaining());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return buffer.toNioBuffer();\n+    }\n+\n+    @Override\n+    public final ByteBuffer decode(final ByteBuffer src, final BufferAllocator allocator) {\n+        final Buffer buffer = allocator.newBuffer(ONE_KB);\n+        InflaterInputStream input = null;\n+        try {\n+            input = newCodecInputStream(new ByteArrayInputStream(src.array(),\n+                    src.arrayOffset() + src.position(), src.remaining()));\n+\n+            int written = 0;", "originalCommit": "a13fd0239fc60dc7316c439b41295d9cab932e5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e9651a485aa565471ab8d54e114ff3052a37a3d8", "url": "https://github.com/apple/servicetalk/commit/e9651a485aa565471ab8d54e114ff3052a37a3d8", "message": "Address comments, add response encoding validations in tests", "committedDate": "2020-09-16T16:16:02Z", "type": "commit"}, {"oid": "8ed9340958597c150af339e9adab422a736beac3", "url": "https://github.com/apple/servicetalk/commit/8ed9340958597c150af339e9adab422a736beac3", "message": "Fix comments - ST buffers & Offheap support", "committedDate": "2020-09-17T14:27:31Z", "type": "commit"}, {"oid": "473c47aca4c58508a1ffd689d36174dbc551929e", "url": "https://github.com/apple/servicetalk/commit/473c47aca4c58508a1ffd689d36174dbc551929e", "message": "Address comments Encoding registry & factory, and added tests with custom encoding", "committedDate": "2020-09-18T15:35:48Z", "type": "commit"}, {"oid": "270c5ce55d76f9f00be9c8d8b961fd7641b7a945", "url": "https://github.com/apple/servicetalk/commit/270c5ce55d76f9f00be9c8d8b961fd7641b7a945", "message": "Missed javadoc", "committedDate": "2020-09-18T15:53:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3NDc0OA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491174748", "bodyText": "It is better if we do not have to give access to mutable fields.\nPreviously you had added a getter and passed that as an argument to the newClient() method. I am fine with either of these with a slight preference towards passing the arg to the method.", "author": "NiteshKant", "createdAt": "2020-09-18T20:27:58Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcClientFactory.java", "diffHunk": "@@ -39,6 +43,9 @@\n     @Nullable\n     private FilterFactory filterFactory;\n \n+    @SuppressWarnings(\"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\")\n+    protected Set<GrpcMessageEncoding> supportedEncodings = unmodifiableSet(singleton(NONE));", "originalCommit": "270c5ce55d76f9f00be9c8d8b961fd7641b7a945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwODc2Ng==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r492608766", "bodyText": "Changed this, but followed the method approach.\nThe argument seemed better in some cases, but not all (eg. the MultiClientBuilder had no access to it unless I altered API).", "author": "tkountis", "createdAt": "2020-09-22T09:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE3NDc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE5ODM4NQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491198385", "bodyText": "Missing javadoc.", "author": "NiteshKant", "createdAt": "2020-09-18T21:26:57Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageEncodings.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class GrpcMessageEncodings {", "originalCommit": "270c5ce55d76f9f00be9c8d8b961fd7641b7a945", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxMTY1Mg==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491211652", "bodyText": "Exposing public constants makes it such that if tomorrow we have to add state to the implementations, we have to break APIs. An alternate is to expose methods instead, like none(), gzip(), etc.", "author": "NiteshKant", "createdAt": "2020-09-18T21:58:38Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageEncodings.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class GrpcMessageEncodings {\n+\n+    public static final GrpcMessageEncoding NONE = new DefaultGrpcMessageEncoding(\"identity\",", "originalCommit": "270c5ce55d76f9f00be9c8d8b961fd7641b7a945", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIxMjU2OQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491212569", "bodyText": "nit: add when we return null", "author": "NiteshKant", "createdAt": "2020-09-18T21:59:58Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageEncodings.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class GrpcMessageEncodings {\n+\n+    public static final GrpcMessageEncoding NONE = new DefaultGrpcMessageEncoding(\"identity\",\n+            new IdentityGrpcMessageCodec());\n+\n+    public static final GrpcMessageEncoding GZIP = new DefaultGrpcMessageEncoding(\"gzip\",\n+            new GzipGrpcMessageCodec());\n+\n+    public static final GrpcMessageEncoding DEFLATE = new DefaultGrpcMessageEncoding(\"deflate\",\n+            new DeflateGrpcMessageCodec());\n+\n+    public static final Set<GrpcMessageEncoding> ALL =\n+            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+\n+    private GrpcMessageEncodings() {\n+    }\n+\n+\n+\n+    /**\n+     * Returns a {@link GrpcMessageEncoding} that matches the input name.\n+     * NULL or empty names will always result in NULL {@link GrpcMessageEncoding} and \"identity\" will\n+     * always result in {@link GrpcMessageEncodings#NONE} regardless of its presence in the allowedList\n+     *\n+     * {@link GrpcMessageEncodings#NONE} is always supported\n+     *\n+     * @param allowedList the source list to find a matching encoding in\n+     * @param name the encoding name used for the matching predicate\n+     * @return an encoding from the allowed-list matching the name parameter", "originalCommit": "270c5ce55d76f9f00be9c8d8b961fd7641b7a945", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMzU4MQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491223581", "bodyText": "Is this status code appropriate? Technically the method is implemented but the encoding isn't supported?", "author": "NiteshKant", "createdAt": "2020-09-18T22:40:20Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java", "diffHunk": "@@ -145,6 +161,10 @@ static void setStatus(final HttpHeaders trailers, final Throwable cause, final B\n         if (cause instanceof GrpcStatusException) {\n             GrpcStatusException grpcStatusException = (GrpcStatusException) cause;\n             setStatus(trailers, grpcStatusException.status(), grpcStatusException.applicationStatus(), allocator);\n+        } else if (cause instanceof MessageEncodingException) {\n+            MessageEncodingException msgEncException = (MessageEncodingException) cause;\n+            setStatus(trailers, GrpcStatus.fromCodeValue(GrpcStatusCode.UNIMPLEMENTED.value()),", "originalCommit": "270c5ce55d76f9f00be9c8d8b961fd7641b7a945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQxNjY2NQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491416665", "bodyText": "I agree, but this is according to the gRPC spec [1]:\n\nA message compressed by a client in a way not supported by its server MUST fail with status UNIMPLEMENTED, its associated description indicating the unsupported condition as well as the supported ones. The returned grpc-accept-encoding header MUST NOT contain the compression method (encoding) used.\n\n\nhttps://github.com/grpc/grpc/blob/master/doc/compression.md (item 4)", "author": "tkountis", "createdAt": "2020-09-19T12:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMzU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyNDI4Mg==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r492224282", "bodyText": "aah ok!", "author": "NiteshKant", "createdAt": "2020-09-21T17:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyMzU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNDc2Mw==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491224763", "bodyText": "Add a log?", "author": "NiteshKant", "createdAt": "2020-09-18T22:45:13Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/ZipGrpcMessageCodec.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static java.lang.Math.min;\n+\n+abstract class ZipGrpcMessageCodec implements GrpcMessageCodec {\n+\n+    private static final int ONE_KB = 1 << 10;\n+\n+    abstract DeflaterOutputStream newCodecOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newCodecInputStream(InputStream in) throws IOException;\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length, final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(ONE_KB);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newCodecOutputStream(asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[min(src.readableBytes(), ONE_KB)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Buffer decode(final Buffer src, final int offset, final int length, final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(ONE_KB);\n+        InflaterInputStream input = null;\n+        try {\n+            input = newCodecInputStream(asInputStream(src));\n+\n+            int read = dst.setBytesUntilEndStream(0, input, ONE_KB);\n+            dst.writerIndex(read);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(input);\n+        }\n+\n+        return dst;\n+    }\n+\n+    private void closeQuietly(@Nullable final Closeable closeable) {\n+        try {\n+            if (closeable != null) {\n+                closeable.close();\n+            }\n+        } catch (IOException e) {\n+            // Ignore", "originalCommit": "270c5ce55d76f9f00be9c8d8b961fd7641b7a945", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyODU5Mw==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491228593", "bodyText": "The method should be private, you can add that modifier here too.", "author": "NiteshKant", "createdAt": "2020-09-18T23:01:12Z", "path": "servicetalk-grpc-protoc/src/main/java/io/servicetalk/grpc/protoc/Generator.java", "diffHunk": "@@ -214,12 +220,17 @@ private void addSerializationProviderInit(final State state, final TypeSpec.Buil\n                         builder, t, t));\n \n         staticInitBlockBuilder\n-                .addStatement(\"$L = $L.build()\", serializationProvider, builder)\n+                .addStatement(\"return $L.build()\", builder)\n                 .build();\n \n         serviceClassBuilder\n-                .addField(GrpcSerializationProvider, serializationProvider, PRIVATE, STATIC, FINAL)\n-                .addStaticBlock(staticInitBlockBuilder.build());\n+                .addMethod(methodBuilder(initSerializationProvider)\n+                        .addModifiers(STATIC)", "originalCommit": "270c5ce55d76f9f00be9c8d8b961fd7641b7a945", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyODg1NQ==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491228855", "bodyText": "Since now we are creating this serialization provider individually for each route, we can restrict the registrations to only the types required by that route. wdyt?\nIf you agree, it is OK to do that as a follow up", "author": "NiteshKant", "createdAt": "2020-09-18T23:02:26Z", "path": "servicetalk-grpc-protoc/src/main/java/io/servicetalk/grpc/protoc/Generator.java", "diffHunk": "@@ -214,12 +220,17 @@ private void addSerializationProviderInit(final State state, final TypeSpec.Buil\n                         builder, t, t));\n \n         staticInitBlockBuilder\n-                .addStatement(\"$L = $L.build()\", serializationProvider, builder)\n+                .addStatement(\"return $L.build()\", builder)\n                 .build();\n \n         serviceClassBuilder\n-                .addField(GrpcSerializationProvider, serializationProvider, PRIVATE, STATIC, FINAL)\n-                .addStaticBlock(staticInitBlockBuilder.build());\n+                .addMethod(methodBuilder(initSerializationProvider)\n+                        .addModifiers(STATIC)\n+                        .returns(GrpcSerializationProvider)\n+                        .addParameter(GrpcSupportedEncodings, supportedEncodings, FINAL)", "originalCommit": "270c5ce55d76f9f00be9c8d8b961fd7641b7a945", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQxOTY0OA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491419648", "bodyText": "I agree, I was also thinking of caching the providers when supported-encodings are the same, I will open an issue to add this work separately of this PR.", "author": "tkountis", "createdAt": "2020-09-19T12:43:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyODg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMDA3MA==", "url": "https://github.com/apple/servicetalk/pull/1151#discussion_r491230070", "bodyText": "nit: startIndex may be a better name.", "author": "NiteshKant", "createdAt": "2020-09-18T23:07:49Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java", "diffHunk": "@@ -69,6 +72,42 @@ public static CharSequence emptyAsciiString() {\n         return EMPTY_ASCII_BUFFER;\n     }\n \n+    /**\n+     * Split a given {@link CharSequence} to separate ones on the given delimiter.\n+     * The returned {@link CharSequence}s are created by invoking the {@link CharSequence#subSequence(int, int)} method\n+     * on the main one.\n+     *\n+     * This method has no support for regex.\n+     *\n+     * @param input The initial {@link CharSequence} to split, this experiences no side effects\n+     * @param delimiter The delimiter character\n+     * @return a {@link List} of {@link CharSequence} subsequences of the input with the separated values\n+     */\n+    public static List<CharSequence> split(final CharSequence input, final char delimiter) {\n+        if (input.length() == 0) {\n+            return emptyList();\n+        }\n+\n+        int lastIndex = 0;", "originalCommit": "270c5ce55d76f9f00be9c8d8b961fd7641b7a945", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "57b4f9db078f10eff5465308d0dee4e9771d687e", "url": "https://github.com/apple/servicetalk/commit/57b4f9db078f10eff5465308d0dee4e9771d687e", "message": "Address comments", "committedDate": "2020-09-19T13:15:52Z", "type": "commit"}, {"oid": "ddbc9098546add7fcf07849985d7f0a8497b0ca3", "url": "https://github.com/apple/servicetalk/commit/ddbc9098546add7fcf07849985d7f0a8497b0ca3", "message": "Address comments", "committedDate": "2020-09-22T09:46:58Z", "type": "commit"}, {"oid": "c61f762dab5157377c0ffeb84c5fa62de97c4d00", "url": "https://github.com/apple/servicetalk/commit/c61f762dab5157377c0ffeb84c5fa62de97c4d00", "message": "Remove spotbug exclusion", "committedDate": "2020-09-22T09:50:40Z", "type": "commit"}, {"oid": "e8446e86ca22bf06c3b7bc15351f5eff0de9c801", "url": "https://github.com/apple/servicetalk/commit/e8446e86ca22bf06c3b7bc15351f5eff0de9c801", "message": "Remove unused import", "committedDate": "2020-09-22T09:55:41Z", "type": "commit"}]}