{"pr_number": 1095, "pr_title": "Observability for connection level events", "pr_createdAt": "2020-07-13T16:59:14Z", "pr_url": "https://github.com/apple/servicetalk/pull/1095", "timeline": [{"oid": "e27f7a5fb76d3bef4b1b29e3f4d19ce294cc5b06", "url": "https://github.com/apple/servicetalk/commit/e27f7a5fb76d3bef4b1b29e3f4d19ce294cc5b06", "message": "TransportObserver API", "committedDate": "2020-07-13T16:55:42Z", "type": "commit"}, {"oid": "0f49706ef02f86c272dc4ec26077d703e9cb2fad", "url": "https://github.com/apple/servicetalk/commit/0f49706ef02f86c272dc4ec26077d703e9cb2fad", "message": "Support TransportObserver API for server-side", "committedDate": "2020-07-13T16:55:42Z", "type": "commit"}, {"oid": "ada69342a78b34a4542027cb22fdefdda2877cd1", "url": "https://github.com/apple/servicetalk/commit/ada69342a78b34a4542027cb22fdefdda2877cd1", "message": "Test TransportObserver API on the server-side", "committedDate": "2020-07-13T16:55:42Z", "type": "commit"}, {"oid": "d71fc9161148c4ec137e702c215f5b09b12d71ff", "url": "https://github.com/apple/servicetalk/commit/d71fc9161148c4ec137e702c215f5b09b12d71ff", "message": "Support TransportObserver API for client-side", "committedDate": "2020-07-13T16:55:42Z", "type": "commit"}, {"oid": "0c582ed93798eec00efc90f9c15112801b1dc17d", "url": "https://github.com/apple/servicetalk/commit/0c582ed93798eec00efc90f9c15112801b1dc17d", "message": "Test TransportObserver API for client-side", "committedDate": "2020-07-13T16:55:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc5NTU0MA==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453795540", "bodyText": "Started with the client builder approach for now. Will investigate impact of moving to ConnectionFactory in a follow-up PR.", "author": "idelpivnitskiy", "createdAt": "2020-07-13T17:00:54Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/BaseGrpcClientBuilder.java", "diffHunk": "@@ -73,6 +74,14 @@\n      */\n     BaseGrpcClientBuilder<U, R> enableWireLogging(String loggerName);\n \n+    /**\n+     * Sets a {@link TransportObserver} that provides visibility into transport events.\n+     *\n+     * @param transportObserver A {@link TransportObserver} that provides visibility into transport events.\n+     * @return {@code this}.\n+     */\n+    BaseGrpcClientBuilder<U, R> transportObserver(TransportObserver transportObserver);", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyNjk5OA==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453826998", "bodyText": "can you provide a summary for ConnectionFactory vs builder trade-offs and what needs to change to enable that?", "author": "Scottmitch", "createdAt": "2020-07-13T17:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc5NTU0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NjY3MA==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r454686670", "bodyText": "That will give more flexibility for users to correlate events/state before and after ConnectionFactory#newConnection invocation. Otherwise, it's hard to connect with events on the builder. Similar limitations that we discussed for DnsQueryLifecycleObserver in netty.\nIn addition, it gives users control when they need to create a new observer and for which resolved addresses.", "author": "idelpivnitskiy", "createdAt": "2020-07-14T22:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc5NTU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc5NjI4NQ==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453796285", "bodyText": "I will start using channel attributes for now and reconsider approach when all events will be implemented. Don't want to change the internal API to propagate it correctly until I see the whole picture. For now, this PR focuses on behavior correctness for notified events.", "author": "idelpivnitskiy", "createdAt": "2020-07-13T17:02:12Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverUtils.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.TransportObserver;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.util.AttributeKey;\n+\n+import javax.annotation.Nullable;\n+\n+import static io.netty.util.AttributeKey.newInstance;\n+\n+/**\n+ * Utilities for {@link TransportObserver}.\n+ */\n+public final class TransportObserverUtils {\n+\n+    private static final AttributeKey<ConnectionObserver> CONNECTION_OBSERVER = newInstance(\"ConnectionObserver\");\n+    private static final AttributeKey<Throwable> CONNECTION_ERROR = newInstance(\"ConnectionError\");\n+\n+    private TransportObserverUtils() {\n+        // No instances\n+    }\n+\n+    /**\n+     * Assigns a {@link ConnectionObserver} to the passed {@link Channel}.\n+     *\n+     * @param channel a {@link Channel} to assign a {@link ConnectionObserver} to\n+     * @param observer a {@link ConnectionObserver}\n+     */\n+    public static void assignConnectionObserver(final Channel channel, @Nullable final ConnectionObserver observer) {\n+        if (observer == null) {\n+            return;\n+        }\n+        channel.attr(CONNECTION_OBSERVER).set(observer);", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyOTM0NA==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453829344", "bodyText": "Generally for all builders; should this be a Supplier<TransportObserver>?\nSpecifically for multi-address client; we should have a way to provide per host observer", "author": "NiteshKant", "createdAt": "2020-07-13T17:57:52Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/MultiAddressHttpClientBuilder.java", "diffHunk": "@@ -62,6 +63,9 @@\n     @Override\n     public abstract MultiAddressHttpClientBuilder<U, R> enableWireLogging(String loggerName);\n \n+    @Override\n+    public abstract MultiAddressHttpClientBuilder<U, R> transportObserver(TransportObserver transportObserver);", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NjczMw==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r454686733", "bodyText": "TransportObserver works as a factory for ConnectionObservers. So, I don't think we need a supplier here.\nFor multi-address builder we have a general problem that most of the options are not per-client (except security config and filters). Taking into account that TransportObserver may move to the ConnectionFactory I will defer this enhancement.", "author": "idelpivnitskiy", "createdAt": "2020-07-14T22:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyOTM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI0MzEzOA==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r455243138", "bodyText": "Supplier is needed as many clients can be built from the same builder. It is completely fair to ask folks to set a new TransportObserver every time they create a client, is that what you intend? If so, then this is what makes the multi-address client case harder. Can we avoid adding this to multi-address client or at least follow the secure() method model where someone can provide a TransportObserver for a HostAndPort?", "author": "NiteshKant", "createdAt": "2020-07-15T18:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyOTM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ2MjQzNg==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r455462436", "bodyText": "Updated multi-address client builder to build a TransportObserver per HostAndPort.", "author": "idelpivnitskiy", "createdAt": "2020-07-16T01:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyOTM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzNDQ2OQ==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453834469", "bodyText": "I am generally concerned about creating such publicly accessible, broadly scoped utilities prematurely.", "author": "NiteshKant", "createdAt": "2020-07-13T18:06:41Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverUtils.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.TransportObserver;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.util.AttributeKey;\n+\n+import javax.annotation.Nullable;\n+\n+import static io.netty.util.AttributeKey.newInstance;\n+\n+/**\n+ * Utilities for {@link TransportObserver}.\n+ */\n+public final class TransportObserverUtils {", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4Njc5OQ==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r454686799", "bodyText": "This is an internal utility.", "author": "idelpivnitskiy", "createdAt": "2020-07-14T22:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzNDQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIzOTI3Ng==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r455239276", "bodyText": "Sure but it is a public class. Do we really want a whole utility to get and set from a channel attribute?\nIn any case, now it can be package private I think?", "author": "NiteshKant", "createdAt": "2020-07-15T18:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzNDQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzNTc3OA==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453835778", "bodyText": "Can we do this assignment in TcpServerBinder? ChannelSet is just a means to have a collection of channels for a server; adding this functionality here seems incorrect. Additionally it increases the scope of TransportObserverUtils outside the tcp-netty-internal module", "author": "NiteshKant", "createdAt": "2020-07-13T18:09:05Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ChannelSet.java", "diffHunk": "@@ -87,14 +97,17 @@ public ChannelSet(Executor offloadingExecutor) {\n      */\n     public boolean addIfAbsent(final Channel channel) {\n         final boolean added = channelMap.putIfAbsent(channel.id(), channel) == null;\n+        if (added) {\n+            final ConnectionObserver observer = this.connectionObserverFactory != null ?\n+                    this.connectionObserverFactory.get() : null;\n+            if (observer != null) {\n+                assignConnectionObserver(channel, observer);", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NjgyOA==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r454686828", "bodyText": "Good call, let me move it from ChannelSet to a better place.", "author": "idelpivnitskiy", "createdAt": "2020-07-14T22:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzNTc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzNzk1MA==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453837950", "bodyText": "In which cases does the closeFuture() complete with an error?\nI think this usage does not map to your intent of connectionClosed(Throwable) contract, does it?", "author": "NiteshKant", "createdAt": "2020-07-13T18:13:01Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverUtils.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.TransportObserver;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.util.AttributeKey;\n+\n+import javax.annotation.Nullable;\n+\n+import static io.netty.util.AttributeKey.newInstance;\n+\n+/**\n+ * Utilities for {@link TransportObserver}.\n+ */\n+public final class TransportObserverUtils {\n+\n+    private static final AttributeKey<ConnectionObserver> CONNECTION_OBSERVER = newInstance(\"ConnectionObserver\");\n+    private static final AttributeKey<Throwable> CONNECTION_ERROR = newInstance(\"ConnectionError\");\n+\n+    private TransportObserverUtils() {\n+        // No instances\n+    }\n+\n+    /**\n+     * Assigns a {@link ConnectionObserver} to the passed {@link Channel}.\n+     *\n+     * @param channel a {@link Channel} to assign a {@link ConnectionObserver} to\n+     * @param observer a {@link ConnectionObserver}\n+     */\n+    public static void assignConnectionObserver(final Channel channel, @Nullable final ConnectionObserver observer) {\n+        if (observer == null) {\n+            return;\n+        }\n+        channel.attr(CONNECTION_OBSERVER).set(observer);\n+        channel.closeFuture().addListener((ChannelFutureListener) future -> {\n+            Throwable t = connectionError(channel);\n+            if (t == null) {\n+                observer.connectionClosed();\n+            } else {\n+                observer.connectionClosed(t);", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4Njg4MA==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r454686880", "bodyText": "The cases are represented in TcpServerTransportObserverErrorsTest. The error may happen in the pipeline or in the ConnectionAcceptor.", "author": "idelpivnitskiy", "createdAt": "2020-07-14T22:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzNzk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg0MTY1NA==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453841654", "bodyText": "You are decoupling observer creation from channel initialization. Is the intent here to account for time delta between start of connect and call to init() here?\nThe init sequence of creating an observer and adding the transport handler seems convoluted. Have you thought about creating the observer in this method?", "author": "NiteshKant", "createdAt": "2020-07-13T18:19:27Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.transport.api.ConnectionObserver;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufHolder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.connectionObserver;\n+\n+/**\n+ * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n+ */\n+public final class TransportObserverInitializer implements ChannelInitializer {\n+\n+    public static final ChannelInitializer TRANSPORT_OBSERVER_INITIALIZER = new TransportObserverInitializer();\n+\n+    private TransportObserverInitializer() {\n+        // Singleton\n+    }\n+\n+    @Override\n+    public void init(final Channel channel) {\n+        final ConnectionObserver observer = connectionObserver(channel);", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NjkwNg==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r454686906", "bodyText": "Correct, the intend was to create a ConnectionObserver as soon as we have access to the Channel. But you are right, there is not much between the netty's initChannel and the current init method. Moved it to TransportObserverInitializer and it looks much better. Thanks!", "author": "idelpivnitskiy", "createdAt": "2020-07-14T22:42:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg0MTY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg0MjI3Mw==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453842273", "bodyText": "Can we also hook in close events to the observer using this handler instead of the close future?", "author": "NiteshKant", "createdAt": "2020-07-13T18:20:32Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.transport.api.ConnectionObserver;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufHolder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.connectionObserver;\n+\n+/**\n+ * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n+ */\n+public final class TransportObserverInitializer implements ChannelInitializer {\n+\n+    public static final ChannelInitializer TRANSPORT_OBSERVER_INITIALIZER = new TransportObserverInitializer();\n+\n+    private TransportObserverInitializer() {\n+        // Singleton\n+    }\n+\n+    @Override\n+    public void init(final Channel channel) {\n+        final ConnectionObserver observer = connectionObserver(channel);\n+        if (observer != null) {\n+            channel.pipeline().addLast(new TransportObserverChannelHandler(observer));\n+        }\n+    }\n+\n+    private static final class TransportObserverChannelHandler extends ChannelDuplexHandler {", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NjkzMg==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r454686932", "bodyText": "That will lose errors outside of the pipeline.", "author": "idelpivnitskiy", "createdAt": "2020-07-14T22:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg0MjI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1MjIyMQ==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453852221", "bodyText": "a single network => a network", "author": "NiteshKant", "createdAt": "2020-07-13T18:37:02Z", "path": "servicetalk-transport-api/src/main/java/io/servicetalk/transport/api/ConnectionObserver.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.api;\n+\n+/**\n+ * An observer interface that provides visibility into events associated with a single network connection.", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NTk4NQ==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453855985", "bodyText": "The method names here are in past tense \"dataWritten\", \"flushed\", etc. Is this intentional that they are associated with timing? While invoking these callbacks we are not consistent; dataRead() is after we have read from socket, dataWritten() is before we have written to the socket.\nAn alternate is to use onDataRead, onDataWrite, onFlush ... etc or whenDataRead, whenFlushed which hides the timing (before/after) and are also similar to the callbacks on our async primitives.", "author": "NiteshKant", "createdAt": "2020-07-13T18:43:44Z", "path": "servicetalk-transport-api/src/main/java/io/servicetalk/transport/api/ConnectionObserver.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.api;\n+\n+/**\n+ * An observer interface that provides visibility into events associated with a single network connection.\n+ */\n+public interface ConnectionObserver {\n+\n+    /**\n+     * Notifies when the connection reads a chunk of data.\n+     *\n+     * @param size size of the data chunk read\n+     */\n+    void dataRead(int size);", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1Njc3Ng==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453856776", "bodyText": "Suggestion: A callback when {@code size} bytes are read from the connection.", "author": "NiteshKant", "createdAt": "2020-07-13T18:45:07Z", "path": "servicetalk-transport-api/src/main/java/io/servicetalk/transport/api/ConnectionObserver.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.api;\n+\n+/**\n+ * An observer interface that provides visibility into events associated with a single network connection.\n+ */\n+public interface ConnectionObserver {\n+\n+    /**\n+     * Notifies when the connection reads a chunk of data.", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NzAyNg==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453857026", "bodyText": "Suggestion: A callback when {@code size} bytes are written to the connection.", "author": "NiteshKant", "createdAt": "2020-07-13T18:45:33Z", "path": "servicetalk-transport-api/src/main/java/io/servicetalk/transport/api/ConnectionObserver.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.api;\n+\n+/**\n+ * An observer interface that provides visibility into events associated with a single network connection.\n+ */\n+public interface ConnectionObserver {\n+\n+    /**\n+     * Notifies when the connection reads a chunk of data.\n+     *\n+     * @param size size of the data chunk read\n+     */\n+    void dataRead(int size);\n+\n+    /**\n+     * Notifies when the connection writes a chunk of data.", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NzUwMQ==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453857501", "bodyText": "Suggestion: Callback when previously written data is flushed to the connection.", "author": "NiteshKant", "createdAt": "2020-07-13T18:46:19Z", "path": "servicetalk-transport-api/src/main/java/io/servicetalk/transport/api/ConnectionObserver.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.api;\n+\n+/**\n+ * An observer interface that provides visibility into events associated with a single network connection.\n+ */\n+public interface ConnectionObserver {\n+\n+    /**\n+     * Notifies when the connection reads a chunk of data.\n+     *\n+     * @param size size of the data chunk read\n+     */\n+    void dataRead(int size);\n+\n+    /**\n+     * Notifies when the connection writes a chunk of data.\n+     *\n+     * @param size size of the data chunk written\n+     */\n+    void dataWritten(int size);\n+\n+    /**\n+     * Notifies when flush operation is made on the connection. The flush operation will try to flush out all previous", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg2MTgyNg==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453861826", "bodyText": "IIUC, the current code paths registering an error is a subset of things you would want to cover eventually.\nLooks like we need to have some association with the close-handler to determine which error should be the cause of closure instead of this \"first-writer-wins\" semantics?", "author": "NiteshKant", "createdAt": "2020-07-13T18:53:49Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverUtils.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.TransportObserver;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.util.AttributeKey;\n+\n+import javax.annotation.Nullable;\n+\n+import static io.netty.util.AttributeKey.newInstance;\n+\n+/**\n+ * Utilities for {@link TransportObserver}.\n+ */\n+public final class TransportObserverUtils {\n+\n+    private static final AttributeKey<ConnectionObserver> CONNECTION_OBSERVER = newInstance(\"ConnectionObserver\");\n+    private static final AttributeKey<Throwable> CONNECTION_ERROR = newInstance(\"ConnectionError\");\n+\n+    private TransportObserverUtils() {\n+        // No instances\n+    }\n+\n+    /**\n+     * Assigns a {@link ConnectionObserver} to the passed {@link Channel}.\n+     *\n+     * @param channel a {@link Channel} to assign a {@link ConnectionObserver} to\n+     * @param observer a {@link ConnectionObserver}\n+     */\n+    public static void assignConnectionObserver(final Channel channel, @Nullable final ConnectionObserver observer) {\n+        if (observer == null) {\n+            return;\n+        }\n+        channel.attr(CONNECTION_OBSERVER).set(observer);\n+        channel.closeFuture().addListener((ChannelFutureListener) future -> {\n+            Throwable t = connectionError(channel);\n+            if (t == null) {\n+                observer.connectionClosed();\n+            } else {\n+                observer.connectionClosed(t);\n+            }\n+            channel.attr(CONNECTION_OBSERVER).set(null);\n+        });\n+    }\n+\n+    /**\n+     * Returns {@link ConnectionObserver} associated with the passed {@link Channel}.\n+     *\n+     * @param channel {@link Channel} that may have assigned {@link ConnectionObserver}\n+     * @return {@link ConnectionObserver} associated with the passed {@link Channel}\n+     */\n+    @Nullable\n+    public static ConnectionObserver connectionObserver(final Channel channel) {\n+        return channel.attr(CONNECTION_OBSERVER).get();\n+    }\n+\n+    /**\n+     * Assigns a {@link Throwable} to the passed {@link Channel}.\n+     *\n+     * @param channel a {@link Channel} to assign a {@link Throwable} to\n+     * @param error a {@link Throwable}\n+     */\n+    public static void assignConnectionError(final Channel channel, final Throwable error) {\n+        if (connectionObserver(channel) != null) {\n+            channel.attr(CONNECTION_ERROR).setIfAbsent(error);", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NzE0MQ==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r454687141", "bodyText": "Not sure about CloseHandler because a Channel may be closed from different places. After investigating different closure cases it looks acceptable to use \"first-writer-wins\" semantics because channels are always closed right after observing an error.", "author": "idelpivnitskiy", "createdAt": "2020-07-14T22:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg2MTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIzMjkwMg==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r455232902", "bodyText": "Not sure about CloseHandler because a Channel may be closed from different places.\n\nSure close can be initiated from multiple places but close-handler holds the close state machine (for H1).\nHaving the determination here that the first error is important and the rest are silently ignored essentially is ignoring the state represented by the close state machine (close handler for h1 and netty for h2).\nThis change only contains 2 calls to this method, how about we determine the mechanism to handle connection errors as a follow-up when we have a better idea about how to handle the reason for close holistically.", "author": "NiteshKant", "createdAt": "2020-07-15T17:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg2MTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1ODI0NQ==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453858245", "bodyText": "nit: since null doesn't have a special meaning internally you can avoid double null check on every addIfAbsent and do one of the null checks here:\nthis.connectionObserverFactory = connectionObserverFactory == null ? () -> null : connectionObserverFactory;\nwhich could simplify the usage in addIfAbsent to:\nfinal ConnectionObserver observer = connectionObserverFactory.get();", "author": "Scottmitch", "createdAt": "2020-07-13T18:47:28Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ChannelSet.java", "diffHunk": "@@ -68,14 +72,20 @@ public void operationComplete(final ChannelFuture future) {\n     private final Completable onClose;\n     @SuppressWarnings(\"unused\")\n     private volatile int state;\n+    @Nullable\n+    private final Supplier<ConnectionObserver> connectionObserverFactory;\n \n     /**\n      * New instance.\n      *\n      * @param offloadingExecutor {@link Executor} to use for offloading close signals.\n+     * @param connectionObserverFactory a factory that creates a {@link ConnectionObserver} when a new {@link Channel}\n+     * is added\n      */\n-    public ChannelSet(Executor offloadingExecutor) {\n+    public ChannelSet(final Executor offloadingExecutor,\n+                      @Nullable final Supplier<ConnectionObserver> connectionObserverFactory) {\n         onClose = fromSource(onCloseProcessor).publishOn(offloadingExecutor);\n+        this.connectionObserverFactory = connectionObserverFactory;", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY4NzE2Ng==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r454687166", "bodyText": "Thanks for the suggestion! I moved the code from ChannelSet to another place.", "author": "idelpivnitskiy", "createdAt": "2020-07-14T22:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1ODI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg2NzM2OA==", "url": "https://github.com/apple/servicetalk/pull/1095#discussion_r453867368", "bodyText": "its somewhat awkward to handle the ConnectionObserver in the ChannelSet on the server, and directly in the transport code for the client. did you consider moving this into the transport as well?", "author": "Scottmitch", "createdAt": "2020-07-13T19:03:32Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ChannelSet.java", "diffHunk": "@@ -87,14 +97,17 @@ public ChannelSet(Executor offloadingExecutor) {\n      */\n     public boolean addIfAbsent(final Channel channel) {\n         final boolean added = channelMap.putIfAbsent(channel.id(), channel) == null;\n+        if (added) {\n+            final ConnectionObserver observer = this.connectionObserverFactory != null ?\n+                    this.connectionObserverFactory.get() : null;\n+            if (observer != null) {\n+                assignConnectionObserver(channel, observer);", "originalCommit": "0c582ed93798eec00efc90f9c15112801b1dc17d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "29f12f9f781ea12c915a6f9cb652fcfe9e5ea338", "url": "https://github.com/apple/servicetalk/commit/29f12f9f781ea12c915a6f9cb652fcfe9e5ea338", "message": "Move observer initialization from ChannelSet to TcpServerBinder", "committedDate": "2020-07-14T21:50:49Z", "type": "commit"}, {"oid": "5a7307012d89d4ab1e5e3d7084214df672378543", "url": "https://github.com/apple/servicetalk/commit/5a7307012d89d4ab1e5e3d7084214df672378543", "message": "Rename interface methods", "committedDate": "2020-07-14T22:20:27Z", "type": "commit"}, {"oid": "c936f7032e90ded07b9047ca92caf6d2983cf44e", "url": "https://github.com/apple/servicetalk/commit/c936f7032e90ded07b9047ca92caf6d2983cf44e", "message": "Move ConnectionObserver creation to TransportObserverInitializer", "committedDate": "2020-07-14T22:39:26Z", "type": "commit"}, {"oid": "8e362473038f05250b8375c37f913f0d291f1907", "url": "https://github.com/apple/servicetalk/commit/8e362473038f05250b8375c37f913f0d291f1907", "message": "Minor fixes", "committedDate": "2020-07-14T22:47:53Z", "type": "commit"}, {"oid": "8478921d4601268336450283abcc2cfff1596f07", "url": "https://github.com/apple/servicetalk/commit/8478921d4601268336450283abcc2cfff1596f07", "message": "Build TransportObserver per HostAndPort for MultiAddressHttpClient", "committedDate": "2020-07-16T01:33:24Z", "type": "commit"}, {"oid": "ce96cb19f20a93708d79d5fdb72539db19d90ac4", "url": "https://github.com/apple/servicetalk/commit/ce96cb19f20a93708d79d5fdb72539db19d90ac4", "message": "Make TransportObserverUtils pkg-private", "committedDate": "2020-07-16T01:37:41Z", "type": "commit"}]}