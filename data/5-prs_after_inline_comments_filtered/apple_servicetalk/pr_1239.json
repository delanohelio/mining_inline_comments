{"pr_number": 1239, "pr_title": "Http compression integration tests; combatibility with Netty", "pr_createdAt": "2020-12-04T18:02:01Z", "pr_url": "https://github.com/apple/servicetalk/pull/1239", "timeline": [{"oid": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "url": "https://github.com/apple/servicetalk/commit/88e7c74b2fc7b089419f277d90e21a8eff6caabe", "message": "Http compression integration tests; combatibility with Netty", "committedDate": "2020-12-04T13:59:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyMTk0NQ==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536321945", "bodyText": "Client and Server enums are identical. Can we rename it to the generic name and reuse?", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:14:38Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/BaseContentCodingTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runners.Parameterized;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static io.servicetalk.encoding.api.ContentCodings.deflateDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.gzipDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_FAIL;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_PASS;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H1;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H2;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Scenario.when;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h1Default;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h2Default;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+\n+public abstract class BaseContentCodingTest {\n+\n+    private static final int PAYLOAD_SIZE = 1024;\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    protected final Scenario scenario;\n+    private final boolean expectedSuccess;\n+\n+    public BaseContentCodingTest(final Scenario scenario) {\n+        this.scenario = scenario;\n+        this.expectedSuccess = scenario.valid;\n+    }\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Object[] params() {\n+        return new Object[] {\n+                when(H1, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+        };\n+    }\n+\n+    @Test\n+    public void testCompatibility() throws Exception {\n+        if (expectedSuccess) {\n+            assertSuccessful(scenario.requestEncoding);\n+        } else {\n+            assertNotSupported(scenario.requestEncoding);\n+        }\n+    }\n+\n+    protected abstract void assertSuccessful(ContentCodec requestEncoding) throws Exception;\n+\n+    protected abstract void assertNotSupported(ContentCodec requestEncoding) throws Exception;\n+\n+    protected static byte[] payload(byte b) {\n+        byte[] payload = new byte[PAYLOAD_SIZE];\n+        Arrays.fill(payload, b);\n+        return payload;\n+    }\n+\n+    protected static String payloadAsString(byte b) {\n+        return new String(payload(b), StandardCharsets.US_ASCII);\n+    }\n+\n+    protected enum Server {\n+        DEFAULT(emptyList()),\n+        GZIP_ONLY(singletonList(gzipDefault())),\n+        GZIP_ID(asList(gzipDefault(), identity())),\n+        GZIP_DEFLATE_ID(asList(gzipDefault(), deflateDefault(), identity())),\n+        ID_GZIP(asList(identity(), gzipDefault())),\n+        ID_DEFLATE(asList(identity(), deflateDefault())),\n+        ID_GZIP_DEFLATE(asList(identity(), gzipDefault(), deflateDefault())),\n+        DEFLATE_ONLY(singletonList(deflateDefault())),\n+        DEFLATE_ID(asList(deflateDefault(), identity()));\n+\n+        List<ContentCodec> list;\n+\n+        Server(List<ContentCodec> list) {\n+            this.list = list;\n+        }\n+    }\n+\n+    protected enum Client {", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQyMzUzOA==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r538423538", "bodyText": "Used different names to make the whenread better in English.\n\"when(H1, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS)\"", "author": "tkountis", "createdAt": "2020-12-08T14:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyMTk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNDEwNg==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536324106", "bodyText": "Consider reusing HttpProtocol enum we have for tests", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:17:10Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/BaseContentCodingTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runners.Parameterized;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static io.servicetalk.encoding.api.ContentCodings.deflateDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.gzipDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_FAIL;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_PASS;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H1;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H2;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Scenario.when;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h1Default;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h2Default;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+\n+public abstract class BaseContentCodingTest {\n+\n+    private static final int PAYLOAD_SIZE = 1024;\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    protected final Scenario scenario;\n+    private final boolean expectedSuccess;\n+\n+    public BaseContentCodingTest(final Scenario scenario) {\n+        this.scenario = scenario;\n+        this.expectedSuccess = scenario.valid;\n+    }\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Object[] params() {\n+        return new Object[] {\n+                when(H1, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+        };\n+    }\n+\n+    @Test\n+    public void testCompatibility() throws Exception {\n+        if (expectedSuccess) {\n+            assertSuccessful(scenario.requestEncoding);\n+        } else {\n+            assertNotSupported(scenario.requestEncoding);\n+        }\n+    }\n+\n+    protected abstract void assertSuccessful(ContentCodec requestEncoding) throws Exception;\n+\n+    protected abstract void assertNotSupported(ContentCodec requestEncoding) throws Exception;\n+\n+    protected static byte[] payload(byte b) {\n+        byte[] payload = new byte[PAYLOAD_SIZE];\n+        Arrays.fill(payload, b);\n+        return payload;\n+    }\n+\n+    protected static String payloadAsString(byte b) {\n+        return new String(payload(b), StandardCharsets.US_ASCII);\n+    }\n+\n+    protected enum Server {\n+        DEFAULT(emptyList()),\n+        GZIP_ONLY(singletonList(gzipDefault())),\n+        GZIP_ID(asList(gzipDefault(), identity())),\n+        GZIP_DEFLATE_ID(asList(gzipDefault(), deflateDefault(), identity())),\n+        ID_GZIP(asList(identity(), gzipDefault())),\n+        ID_DEFLATE(asList(identity(), deflateDefault())),\n+        ID_GZIP_DEFLATE(asList(identity(), gzipDefault(), deflateDefault())),\n+        DEFLATE_ONLY(singletonList(deflateDefault())),\n+        DEFLATE_ID(asList(deflateDefault(), identity()));\n+\n+        List<ContentCodec> list;\n+\n+        Server(List<ContentCodec> list) {\n+            this.list = list;\n+        }\n+    }\n+\n+    protected enum Client {\n+        DEFAULT(emptyList()),\n+        GZIP_ONLY(singletonList(gzipDefault())),\n+        GZIP_ID(asList(gzipDefault(), identity())),\n+        GZIP_DEFLATE_ID(asList(gzipDefault(), deflateDefault(), identity())),\n+        ID_ONLY(singletonList(identity())),\n+        ID_GZIP(asList(identity(), gzipDefault())),\n+        ID_DEFLATE(asList(identity(), deflateDefault())),\n+        ID_GZIP_DEFLATE(asList(identity(), gzipDefault(), deflateDefault())),\n+        DEFLATE_ONLY(singletonList(deflateDefault())),\n+        DEFLATE_ID(asList(deflateDefault(), identity()));\n+\n+        List<ContentCodec> list;\n+\n+        Client(List<ContentCodec> list) {\n+            this.list = list;\n+        }\n+    }\n+\n+    protected enum Request {\n+        ID(identity()),\n+        GZIP(gzipDefault()),\n+        DEFLATE(deflateDefault());\n+\n+        ContentCodec codec;\n+\n+        Request(ContentCodec codec) {\n+            this.codec = codec;\n+        }\n+    }\n+\n+    protected enum Expectation {\n+        SHOULD_PASS(true),\n+        SHOULD_FAIL(false);\n+\n+        boolean valid;\n+        Expectation(boolean valid) {\n+            this.valid = valid;\n+        }\n+    }\n+\n+    protected enum Protocol {", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQyODc4Mg==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r538428782", "bodyText": "Made it public to access it, it was in different pkg.", "author": "tkountis", "createdAt": "2020-12-08T14:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNDEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0NTkxMQ==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r538845911", "bodyText": "Hm, why do you use http.api package here. This is http-netty module, we should use http.netty package for tests.", "author": "idelpivnitskiy", "createdAt": "2020-12-08T22:11:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNDEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MzA1NA==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r538893054", "bodyText": "IIRC the 'encodingFor' is part of api and pkg private.", "author": "tkountis", "createdAt": "2020-12-08T23:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNDEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5NTg0Nw==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r538895847", "bodyText": "Consider creating a hook specifically for that method and keep everything else in http.netty", "author": "idelpivnitskiy", "createdAt": "2020-12-08T23:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNDEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNDg1MA==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536324850", "bodyText": "If we do not expect more cases consider using boolean. Otherwise, let's kill the SHOULD_ prefix.", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:18:34Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/BaseContentCodingTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runners.Parameterized;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static io.servicetalk.encoding.api.ContentCodings.deflateDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.gzipDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_FAIL;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_PASS;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H1;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H2;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Scenario.when;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h1Default;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h2Default;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+\n+public abstract class BaseContentCodingTest {\n+\n+    private static final int PAYLOAD_SIZE = 1024;\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    protected final Scenario scenario;\n+    private final boolean expectedSuccess;\n+\n+    public BaseContentCodingTest(final Scenario scenario) {\n+        this.scenario = scenario;\n+        this.expectedSuccess = scenario.valid;\n+    }\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Object[] params() {\n+        return new Object[] {\n+                when(H1, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+        };\n+    }\n+\n+    @Test\n+    public void testCompatibility() throws Exception {\n+        if (expectedSuccess) {\n+            assertSuccessful(scenario.requestEncoding);\n+        } else {\n+            assertNotSupported(scenario.requestEncoding);\n+        }\n+    }\n+\n+    protected abstract void assertSuccessful(ContentCodec requestEncoding) throws Exception;\n+\n+    protected abstract void assertNotSupported(ContentCodec requestEncoding) throws Exception;\n+\n+    protected static byte[] payload(byte b) {\n+        byte[] payload = new byte[PAYLOAD_SIZE];\n+        Arrays.fill(payload, b);\n+        return payload;\n+    }\n+\n+    protected static String payloadAsString(byte b) {\n+        return new String(payload(b), StandardCharsets.US_ASCII);\n+    }\n+\n+    protected enum Server {\n+        DEFAULT(emptyList()),\n+        GZIP_ONLY(singletonList(gzipDefault())),\n+        GZIP_ID(asList(gzipDefault(), identity())),\n+        GZIP_DEFLATE_ID(asList(gzipDefault(), deflateDefault(), identity())),\n+        ID_GZIP(asList(identity(), gzipDefault())),\n+        ID_DEFLATE(asList(identity(), deflateDefault())),\n+        ID_GZIP_DEFLATE(asList(identity(), gzipDefault(), deflateDefault())),\n+        DEFLATE_ONLY(singletonList(deflateDefault())),\n+        DEFLATE_ID(asList(deflateDefault(), identity()));\n+\n+        List<ContentCodec> list;\n+\n+        Server(List<ContentCodec> list) {\n+            this.list = list;\n+        }\n+    }\n+\n+    protected enum Client {\n+        DEFAULT(emptyList()),\n+        GZIP_ONLY(singletonList(gzipDefault())),\n+        GZIP_ID(asList(gzipDefault(), identity())),\n+        GZIP_DEFLATE_ID(asList(gzipDefault(), deflateDefault(), identity())),\n+        ID_ONLY(singletonList(identity())),\n+        ID_GZIP(asList(identity(), gzipDefault())),\n+        ID_DEFLATE(asList(identity(), deflateDefault())),\n+        ID_GZIP_DEFLATE(asList(identity(), gzipDefault(), deflateDefault())),\n+        DEFLATE_ONLY(singletonList(deflateDefault())),\n+        DEFLATE_ID(asList(deflateDefault(), identity()));\n+\n+        List<ContentCodec> list;\n+\n+        Client(List<ContentCodec> list) {\n+            this.list = list;\n+        }\n+    }\n+\n+    protected enum Request {\n+        ID(identity()),\n+        GZIP(gzipDefault()),\n+        DEFLATE(deflateDefault());\n+\n+        ContentCodec codec;\n+\n+        Request(ContentCodec codec) {\n+            this.codec = codec;\n+        }\n+    }\n+\n+    protected enum Expectation {\n+        SHOULD_PASS(true),\n+        SHOULD_FAIL(false);", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNTEzNg==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536325136", "bodyText": "Consider naming it Compression or Coding", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:19:06Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/BaseContentCodingTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runners.Parameterized;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static io.servicetalk.encoding.api.ContentCodings.deflateDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.gzipDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_FAIL;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_PASS;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H1;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H2;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Scenario.when;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h1Default;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h2Default;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+\n+public abstract class BaseContentCodingTest {\n+\n+    private static final int PAYLOAD_SIZE = 1024;\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    protected final Scenario scenario;\n+    private final boolean expectedSuccess;\n+\n+    public BaseContentCodingTest(final Scenario scenario) {\n+        this.scenario = scenario;\n+        this.expectedSuccess = scenario.valid;\n+    }\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Object[] params() {\n+        return new Object[] {\n+                when(H1, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+        };\n+    }\n+\n+    @Test\n+    public void testCompatibility() throws Exception {\n+        if (expectedSuccess) {\n+            assertSuccessful(scenario.requestEncoding);\n+        } else {\n+            assertNotSupported(scenario.requestEncoding);\n+        }\n+    }\n+\n+    protected abstract void assertSuccessful(ContentCodec requestEncoding) throws Exception;\n+\n+    protected abstract void assertNotSupported(ContentCodec requestEncoding) throws Exception;\n+\n+    protected static byte[] payload(byte b) {\n+        byte[] payload = new byte[PAYLOAD_SIZE];\n+        Arrays.fill(payload, b);\n+        return payload;\n+    }\n+\n+    protected static String payloadAsString(byte b) {\n+        return new String(payload(b), StandardCharsets.US_ASCII);\n+    }\n+\n+    protected enum Server {\n+        DEFAULT(emptyList()),\n+        GZIP_ONLY(singletonList(gzipDefault())),\n+        GZIP_ID(asList(gzipDefault(), identity())),\n+        GZIP_DEFLATE_ID(asList(gzipDefault(), deflateDefault(), identity())),\n+        ID_GZIP(asList(identity(), gzipDefault())),\n+        ID_DEFLATE(asList(identity(), deflateDefault())),\n+        ID_GZIP_DEFLATE(asList(identity(), gzipDefault(), deflateDefault())),\n+        DEFLATE_ONLY(singletonList(deflateDefault())),\n+        DEFLATE_ID(asList(deflateDefault(), identity()));\n+\n+        List<ContentCodec> list;\n+\n+        Server(List<ContentCodec> list) {\n+            this.list = list;\n+        }\n+    }\n+\n+    protected enum Client {\n+        DEFAULT(emptyList()),\n+        GZIP_ONLY(singletonList(gzipDefault())),\n+        GZIP_ID(asList(gzipDefault(), identity())),\n+        GZIP_DEFLATE_ID(asList(gzipDefault(), deflateDefault(), identity())),\n+        ID_ONLY(singletonList(identity())),\n+        ID_GZIP(asList(identity(), gzipDefault())),\n+        ID_DEFLATE(asList(identity(), deflateDefault())),\n+        ID_GZIP_DEFLATE(asList(identity(), gzipDefault(), deflateDefault())),\n+        DEFLATE_ONLY(singletonList(deflateDefault())),\n+        DEFLATE_ID(asList(deflateDefault(), identity()));\n+\n+        List<ContentCodec> list;\n+\n+        Client(List<ContentCodec> list) {\n+            this.list = list;\n+        }\n+    }\n+\n+    protected enum Request {", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyNTgyNw==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536325827", "bodyText": "Consider using scenario.valid instead of duplicating in a new variable", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:20:27Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/BaseContentCodingTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runners.Parameterized;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static io.servicetalk.encoding.api.ContentCodings.deflateDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.gzipDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_FAIL;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_PASS;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H1;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H2;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Scenario.when;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h1Default;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h2Default;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+\n+public abstract class BaseContentCodingTest {\n+\n+    private static final int PAYLOAD_SIZE = 1024;\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    protected final Scenario scenario;\n+    private final boolean expectedSuccess;\n+\n+    public BaseContentCodingTest(final Scenario scenario) {\n+        this.scenario = scenario;\n+        this.expectedSuccess = scenario.valid;", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMyODUxNQ==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536328515", "bodyText": "Consider just storing a enum, it has all the info for isH2, the protocol, and its name for logging", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:25:29Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/BaseContentCodingTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runners.Parameterized;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static io.servicetalk.encoding.api.ContentCodings.deflateDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.gzipDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_FAIL;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_PASS;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H1;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H2;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Scenario.when;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h1Default;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h2Default;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+\n+public abstract class BaseContentCodingTest {\n+\n+    private static final int PAYLOAD_SIZE = 1024;\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    protected final Scenario scenario;\n+    private final boolean expectedSuccess;\n+\n+    public BaseContentCodingTest(final Scenario scenario) {\n+        this.scenario = scenario;\n+        this.expectedSuccess = scenario.valid;\n+    }\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Object[] params() {\n+        return new Object[] {\n+                when(H1, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+        };\n+    }\n+\n+    @Test\n+    public void testCompatibility() throws Exception {\n+        if (expectedSuccess) {\n+            assertSuccessful(scenario.requestEncoding);\n+        } else {\n+            assertNotSupported(scenario.requestEncoding);\n+        }\n+    }\n+\n+    protected abstract void assertSuccessful(ContentCodec requestEncoding) throws Exception;\n+\n+    protected abstract void assertNotSupported(ContentCodec requestEncoding) throws Exception;\n+\n+    protected static byte[] payload(byte b) {\n+        byte[] payload = new byte[PAYLOAD_SIZE];\n+        Arrays.fill(payload, b);\n+        return payload;\n+    }\n+\n+    protected static String payloadAsString(byte b) {\n+        return new String(payload(b), StandardCharsets.US_ASCII);\n+    }\n+\n+    protected enum Server {\n+        DEFAULT(emptyList()),\n+        GZIP_ONLY(singletonList(gzipDefault())),\n+        GZIP_ID(asList(gzipDefault(), identity())),\n+        GZIP_DEFLATE_ID(asList(gzipDefault(), deflateDefault(), identity())),\n+        ID_GZIP(asList(identity(), gzipDefault())),\n+        ID_DEFLATE(asList(identity(), deflateDefault())),\n+        ID_GZIP_DEFLATE(asList(identity(), gzipDefault(), deflateDefault())),\n+        DEFLATE_ONLY(singletonList(deflateDefault())),\n+        DEFLATE_ID(asList(deflateDefault(), identity()));\n+\n+        List<ContentCodec> list;\n+\n+        Server(List<ContentCodec> list) {\n+            this.list = list;\n+        }\n+    }\n+\n+    protected enum Client {\n+        DEFAULT(emptyList()),\n+        GZIP_ONLY(singletonList(gzipDefault())),\n+        GZIP_ID(asList(gzipDefault(), identity())),\n+        GZIP_DEFLATE_ID(asList(gzipDefault(), deflateDefault(), identity())),\n+        ID_ONLY(singletonList(identity())),\n+        ID_GZIP(asList(identity(), gzipDefault())),\n+        ID_DEFLATE(asList(identity(), deflateDefault())),\n+        ID_GZIP_DEFLATE(asList(identity(), gzipDefault(), deflateDefault())),\n+        DEFLATE_ONLY(singletonList(deflateDefault())),\n+        DEFLATE_ID(asList(deflateDefault(), identity()));\n+\n+        List<ContentCodec> list;\n+\n+        Client(List<ContentCodec> list) {\n+            this.list = list;\n+        }\n+    }\n+\n+    protected enum Request {\n+        ID(identity()),\n+        GZIP(gzipDefault()),\n+        DEFLATE(deflateDefault());\n+\n+        ContentCodec codec;\n+\n+        Request(ContentCodec codec) {\n+            this.codec = codec;\n+        }\n+    }\n+\n+    protected enum Expectation {\n+        SHOULD_PASS(true),\n+        SHOULD_FAIL(false);\n+\n+        boolean valid;\n+        Expectation(boolean valid) {\n+            this.valid = valid;\n+        }\n+    }\n+\n+    protected enum Protocol {\n+        H1(h1Default()),\n+        H2(h2Default());\n+\n+        HttpProtocolConfig config;\n+\n+        Protocol(HttpProtocolConfig config) {\n+            this.config = config;\n+        }\n+    }\n+\n+    protected static class Scenario {\n+        final ContentCodec requestEncoding;\n+        final List<ContentCodec> clientSupported;\n+        final List<ContentCodec> serverSupported;\n+        final HttpProtocolConfig protocol;\n+        final boolean valid;\n+        final boolean isH2;\n+\n+        Scenario(final ContentCodec requestEncoding,\n+                 final List<ContentCodec> clientSupported, final List<ContentCodec> serverSupported,\n+                 final Protocol protocol, final boolean valid) {\n+            this.requestEncoding = requestEncoding;\n+            this.clientSupported = clientSupported;\n+            this.serverSupported = serverSupported;\n+            this.valid = valid;\n+            this.isH2 = protocol == H2;\n+            this.protocol = isH2 ? h2Default() : h1Default();", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzMDIxMg==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536330212", "bodyText": "Consider using identity().name()", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:28:40Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ServiceTalkContentCodingTest.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+import io.servicetalk.http.netty.HttpClients;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.HeaderUtils.encodingFor;\n+import static io.servicetalk.http.api.HttpHeaderNames.ACCEPT_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_ENCODING;\n+import static io.servicetalk.http.api.HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.util.Arrays.stream;\n+import static java.util.Collections.disjoint;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class ServiceTalkContentCodingTest extends BaseContentCodingTest {\n+\n+    private static final Function<Scenario, StreamingHttpServiceFilterFactory> REQ_VERIFIER = (scenario)\n+            -> new StreamingHttpServiceFilterFactory() {\n+        @Override\n+        public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+            return new StreamingHttpServiceFilter(service) {\n+                @Override\n+\n+                public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                            final StreamingHttpRequest request,\n+                                                            final StreamingHttpResponseFactory responseFactory) {\n+                    final ContentCodec reqEncoding = scenario.requestEncoding;\n+                    final List<ContentCodec> clientSupportedEncodings = scenario.clientSupported;\n+\n+                    try {\n+\n+                        String requestPayload = request.payloadBody(textDeserializer())\n+                                .collect(StringBuilder::new, StringBuilder::append)\n+                                .toFuture().get().toString();\n+\n+                        assertEquals(payloadAsString((byte) 'a'), requestPayload);\n+\n+                        final List<String> actualReqAcceptedEncodings = stream(request.headers()\n+                                .get(ACCEPT_ENCODING, \"NOT_PRESENT\").toString().split(\",\"))\n+                                .map((String::trim)).collect(toList());\n+\n+                        final List<String> expectedReqAcceptedEncodings = clientSupportedEncodings.stream()\n+                                .filter((enc) -> enc != identity())\n+                                .map((ContentCodec::name))\n+                                .map(CharSequence::toString)\n+                                .collect(toList());\n+\n+                        if (reqEncoding != identity()) {\n+                            assertTrue(\"Request encoding should be present in the request headers\",\n+                                    contentEquals(reqEncoding.name(),\n+                                            request.headers().get(ACCEPT_ENCODING, \"NOT_PRESENT\")));\n+                        }\n+\n+                        if (!expectedReqAcceptedEncodings.isEmpty() && !actualReqAcceptedEncodings.isEmpty()) {\n+                            assertThat(actualReqAcceptedEncodings, equalTo(expectedReqAcceptedEncodings));\n+                        }\n+\n+                        return super.handle(ctx, request, responseFactory);\n+                    } catch (Throwable t) {\n+                        t.printStackTrace();\n+                        return succeeded(responseFactory.badRequest());\n+                    }\n+                }\n+            };\n+        }\n+    };\n+\n+    static final Function<Scenario, StreamingHttpClientFilterFactory> RESP_VERIFIER = (scenario)\n+            -> new StreamingHttpClientFilterFactory() {\n+        @Override\n+        public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+            return new StreamingHttpClientFilter(client) {\n+                @Override\n+                protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                                final HttpExecutionStrategy strategy,\n+                                                                final StreamingHttpRequest request) {\n+                    return super.request(delegate, strategy, request).map(response -> {\n+                        List<ContentCodec> server = scenario.serverSupported;\n+                        List<ContentCodec> client = scenario.clientSupported;\n+\n+                        ContentCodec expected = identity();\n+                        for (ContentCodec codec : client) {\n+                            if (server.contains(codec)) {\n+                                expected = codec;\n+                                break;\n+                            }\n+                        }\n+\n+                        assertEquals(expected, encodingFor(client, response.headers()\n+                                .get(CONTENT_ENCODING, \"identity\")));", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzMDI4MA==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536330280", "bodyText": "Consider using identity().name()", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:28:47Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ServiceTalkContentCodingTest.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+import io.servicetalk.http.netty.HttpClients;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.HeaderUtils.encodingFor;\n+import static io.servicetalk.http.api.HttpHeaderNames.ACCEPT_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_ENCODING;\n+import static io.servicetalk.http.api.HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.util.Arrays.stream;\n+import static java.util.Collections.disjoint;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class ServiceTalkContentCodingTest extends BaseContentCodingTest {\n+\n+    private static final Function<Scenario, StreamingHttpServiceFilterFactory> REQ_VERIFIER = (scenario)\n+            -> new StreamingHttpServiceFilterFactory() {\n+        @Override\n+        public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+            return new StreamingHttpServiceFilter(service) {\n+                @Override\n+\n+                public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                            final StreamingHttpRequest request,\n+                                                            final StreamingHttpResponseFactory responseFactory) {\n+                    final ContentCodec reqEncoding = scenario.requestEncoding;\n+                    final List<ContentCodec> clientSupportedEncodings = scenario.clientSupported;\n+\n+                    try {\n+\n+                        String requestPayload = request.payloadBody(textDeserializer())\n+                                .collect(StringBuilder::new, StringBuilder::append)\n+                                .toFuture().get().toString();\n+\n+                        assertEquals(payloadAsString((byte) 'a'), requestPayload);\n+\n+                        final List<String> actualReqAcceptedEncodings = stream(request.headers()\n+                                .get(ACCEPT_ENCODING, \"NOT_PRESENT\").toString().split(\",\"))\n+                                .map((String::trim)).collect(toList());\n+\n+                        final List<String> expectedReqAcceptedEncodings = clientSupportedEncodings.stream()\n+                                .filter((enc) -> enc != identity())\n+                                .map((ContentCodec::name))\n+                                .map(CharSequence::toString)\n+                                .collect(toList());\n+\n+                        if (reqEncoding != identity()) {\n+                            assertTrue(\"Request encoding should be present in the request headers\",\n+                                    contentEquals(reqEncoding.name(),\n+                                            request.headers().get(ACCEPT_ENCODING, \"NOT_PRESENT\")));\n+                        }\n+\n+                        if (!expectedReqAcceptedEncodings.isEmpty() && !actualReqAcceptedEncodings.isEmpty()) {\n+                            assertThat(actualReqAcceptedEncodings, equalTo(expectedReqAcceptedEncodings));\n+                        }\n+\n+                        return super.handle(ctx, request, responseFactory);\n+                    } catch (Throwable t) {\n+                        t.printStackTrace();\n+                        return succeeded(responseFactory.badRequest());\n+                    }\n+                }\n+            };\n+        }\n+    };\n+\n+    static final Function<Scenario, StreamingHttpClientFilterFactory> RESP_VERIFIER = (scenario)\n+            -> new StreamingHttpClientFilterFactory() {\n+        @Override\n+        public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+            return new StreamingHttpClientFilter(client) {\n+                @Override\n+                protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                                final HttpExecutionStrategy strategy,\n+                                                                final StreamingHttpRequest request) {\n+                    return super.request(delegate, strategy, request).map(response -> {\n+                        List<ContentCodec> server = scenario.serverSupported;\n+                        List<ContentCodec> client = scenario.clientSupported;\n+\n+                        ContentCodec expected = identity();\n+                        for (ContentCodec codec : client) {\n+                            if (server.contains(codec)) {\n+                                expected = codec;\n+                                break;\n+                            }\n+                        }\n+\n+                        assertEquals(expected, encodingFor(client, response.headers()\n+                                .get(CONTENT_ENCODING, \"identity\")));\n+                        return response;\n+                    });\n+                }\n+            };\n+        }\n+    };\n+\n+    private ServerContext serverContext;\n+    private HttpClient client;\n+\n+    public ServiceTalkContentCodingTest(Scenario scenario) {\n+        super(scenario);\n+    }\n+\n+    @Before\n+    public void start() throws Exception {\n+        serverContext = newServiceTalkServer(scenario);\n+        client = newServiceTalkClient(serverHostAndPort(serverContext), scenario);\n+    }\n+\n+    @After\n+    public void finish() throws Exception {\n+        client.close();\n+        serverContext.close();\n+    }\n+\n+    protected HttpClient client() {\n+        return client;\n+    }\n+\n+    protected void assertSuccessful(final ContentCodec encoding) throws Exception {\n+        assertResponse(client().request(client()\n+                .get(\"/\")\n+                .encoding(encoding)\n+                .payloadBody(payloadAsString((byte) 'a'), textSerializer())).toFuture().get().toStreamingResponse());\n+\n+        final BlockingStreamingHttpClient blockingStreamingHttpClient = client().asBlockingStreamingClient();\n+        assertResponse(blockingStreamingHttpClient.request(blockingStreamingHttpClient\n+                .get(\"/\")\n+                .encoding(encoding)\n+                .payloadBody(singletonList(payloadAsString((byte) 'a')), textSerializer())).toStreamingResponse());\n+\n+        final StreamingHttpClient streamingHttpClient = client().asStreamingClient();\n+        assertResponse(streamingHttpClient.request(streamingHttpClient\n+                .get(\"/\")\n+                .encoding(encoding)\n+                .payloadBody(from(payloadAsString((byte) 'a')), textSerializer())).toFuture().get());\n+    }\n+\n+    private void assertResponse(final StreamingHttpResponse response) throws Exception {\n+        assertResponseHeaders(response.headers().get(CONTENT_ENCODING, \"identity\").toString());", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzMjY5NA==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536332694", "bodyText": "Consider simplified parametrized format:\nclient=[...], server=[...], request={}, protocol={}, shouldPass={}\n\nCurrent format is hard to read in intellij idea and hard to run via command line a specific gradle test.", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:33:16Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/BaseContentCodingTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runners.Parameterized;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static io.servicetalk.encoding.api.ContentCodings.deflateDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.gzipDefault;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_FAIL;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Expectation.SHOULD_PASS;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H1;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Protocol.H2;\n+import static io.servicetalk.http.api.BaseContentCodingTest.Scenario.when;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h1Default;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h2Default;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+\n+public abstract class BaseContentCodingTest {\n+\n+    private static final int PAYLOAD_SIZE = 1024;\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    protected final Scenario scenario;\n+    private final boolean expectedSuccess;\n+\n+    public BaseContentCodingTest(final Scenario scenario) {\n+        this.scenario = scenario;\n+        this.expectedSuccess = scenario.valid;\n+    }\n+\n+    @Parameterized.Parameters(name = \"{0}\")\n+    public static Object[] params() {\n+        return new Object[] {\n+                when(H1, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_DEFLATE_ID, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_GZIP_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.ID_GZIP, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.ID_DEFLATE, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFLATE_ID, Request.DEFLATE, SHOULD_PASS),\n+                when(H1, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H2, Server.ID_DEFLATE, Client.DEFAULT, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.ID_ONLY, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H1, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H2, Server.GZIP_ONLY, Client.GZIP_ID, Request.GZIP, SHOULD_PASS),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.GZIP, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H2, Server.DEFAULT, Client.GZIP_DEFLATE_ID, Request.DEFLATE, SHOULD_FAIL),\n+                when(H1, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+                when(H2, Server.DEFAULT, Client.GZIP_ID, Request.ID, SHOULD_PASS),\n+        };\n+    }\n+\n+    @Test\n+    public void testCompatibility() throws Exception {\n+        if (expectedSuccess) {\n+            assertSuccessful(scenario.requestEncoding);\n+        } else {\n+            assertNotSupported(scenario.requestEncoding);\n+        }\n+    }\n+\n+    protected abstract void assertSuccessful(ContentCodec requestEncoding) throws Exception;\n+\n+    protected abstract void assertNotSupported(ContentCodec requestEncoding) throws Exception;\n+\n+    protected static byte[] payload(byte b) {\n+        byte[] payload = new byte[PAYLOAD_SIZE];\n+        Arrays.fill(payload, b);\n+        return payload;\n+    }\n+\n+    protected static String payloadAsString(byte b) {\n+        return new String(payload(b), StandardCharsets.US_ASCII);\n+    }\n+\n+    protected enum Server {\n+        DEFAULT(emptyList()),\n+        GZIP_ONLY(singletonList(gzipDefault())),\n+        GZIP_ID(asList(gzipDefault(), identity())),\n+        GZIP_DEFLATE_ID(asList(gzipDefault(), deflateDefault(), identity())),\n+        ID_GZIP(asList(identity(), gzipDefault())),\n+        ID_DEFLATE(asList(identity(), deflateDefault())),\n+        ID_GZIP_DEFLATE(asList(identity(), gzipDefault(), deflateDefault())),\n+        DEFLATE_ONLY(singletonList(deflateDefault())),\n+        DEFLATE_ID(asList(deflateDefault(), identity()));\n+\n+        List<ContentCodec> list;\n+\n+        Server(List<ContentCodec> list) {\n+            this.list = list;\n+        }\n+    }\n+\n+    protected enum Client {\n+        DEFAULT(emptyList()),\n+        GZIP_ONLY(singletonList(gzipDefault())),\n+        GZIP_ID(asList(gzipDefault(), identity())),\n+        GZIP_DEFLATE_ID(asList(gzipDefault(), deflateDefault(), identity())),\n+        ID_ONLY(singletonList(identity())),\n+        ID_GZIP(asList(identity(), gzipDefault())),\n+        ID_DEFLATE(asList(identity(), deflateDefault())),\n+        ID_GZIP_DEFLATE(asList(identity(), gzipDefault(), deflateDefault())),\n+        DEFLATE_ONLY(singletonList(deflateDefault())),\n+        DEFLATE_ID(asList(deflateDefault(), identity()));\n+\n+        List<ContentCodec> list;\n+\n+        Client(List<ContentCodec> list) {\n+            this.list = list;\n+        }\n+    }\n+\n+    protected enum Request {\n+        ID(identity()),\n+        GZIP(gzipDefault()),\n+        DEFLATE(deflateDefault());\n+\n+        ContentCodec codec;\n+\n+        Request(ContentCodec codec) {\n+            this.codec = codec;\n+        }\n+    }\n+\n+    protected enum Expectation {\n+        SHOULD_PASS(true),\n+        SHOULD_FAIL(false);\n+\n+        boolean valid;\n+        Expectation(boolean valid) {\n+            this.valid = valid;\n+        }\n+    }\n+\n+    protected enum Protocol {\n+        H1(h1Default()),\n+        H2(h2Default());\n+\n+        HttpProtocolConfig config;\n+\n+        Protocol(HttpProtocolConfig config) {\n+            this.config = config;\n+        }\n+    }\n+\n+    protected static class Scenario {\n+        final ContentCodec requestEncoding;\n+        final List<ContentCodec> clientSupported;\n+        final List<ContentCodec> serverSupported;\n+        final HttpProtocolConfig protocol;\n+        final boolean valid;\n+        final boolean isH2;\n+\n+        Scenario(final ContentCodec requestEncoding,\n+                 final List<ContentCodec> clientSupported, final List<ContentCodec> serverSupported,\n+                 final Protocol protocol, final boolean valid) {\n+            this.requestEncoding = requestEncoding;\n+            this.clientSupported = clientSupported;\n+            this.serverSupported = serverSupported;\n+            this.valid = valid;\n+            this.isH2 = protocol == H2;\n+            this.protocol = isH2 ? h2Default() : h1Default();\n+        }\n+\n+        static Scenario when(final Protocol protocol, final Server server,\n+                             final Client client, final Request request, final Expectation expectation) {\n+            return new Scenario(request.codec, client.list, server.list, protocol, expectation.valid);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"When a client that supports \" + encString(clientSupported) + \", sends a request encoded with \"\n+                    + requestEncoding.name() + \", to an \" + (isH2 ? \"H2\" : \"H1\") + \" server that supports \"\n+                    + encString(serverSupported) + \", the request should be \" + (valid ? \"ACCEPTED\" : \"REJECTED\");", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQzOTg3Mg==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r539439872", "bodyText": "Included index in the params (to allow running from cmd easier [1]), and simplified the text.\n\n./gradlew --info :servicetalk-http-netty:test --tests \"io.servicetalk.http.netty.ServiceTalkContentCodingTest.testCompatibility[15*]\"", "author": "tkountis", "createdAt": "2020-12-09T16:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzMjY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNDc3Mw==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536334773", "bodyText": "Assertions work only in main test thread. If you use assertion in offloaded thread or on a server side, they won't fail the test.\nWe usually use a BlockingQueue to save the result we observed on the server side and validate the values in the queue in the main test thread.", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:37:06Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ServiceTalkContentCodingTest.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+import io.servicetalk.http.netty.HttpClients;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.HeaderUtils.encodingFor;\n+import static io.servicetalk.http.api.HttpHeaderNames.ACCEPT_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_ENCODING;\n+import static io.servicetalk.http.api.HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.util.Arrays.stream;\n+import static java.util.Collections.disjoint;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class ServiceTalkContentCodingTest extends BaseContentCodingTest {\n+\n+    private static final Function<Scenario, StreamingHttpServiceFilterFactory> REQ_VERIFIER = (scenario)\n+            -> new StreamingHttpServiceFilterFactory() {\n+        @Override\n+        public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+            return new StreamingHttpServiceFilter(service) {\n+                @Override\n+\n+                public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                            final StreamingHttpRequest request,\n+                                                            final StreamingHttpResponseFactory responseFactory) {\n+                    final ContentCodec reqEncoding = scenario.requestEncoding;\n+                    final List<ContentCodec> clientSupportedEncodings = scenario.clientSupported;\n+\n+                    try {\n+\n+                        String requestPayload = request.payloadBody(textDeserializer())\n+                                .collect(StringBuilder::new, StringBuilder::append)\n+                                .toFuture().get().toString();\n+\n+                        assertEquals(payloadAsString((byte) 'a'), requestPayload);", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNzk2MQ==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r539637961", "bodyText": "Discussed offline, the errors are surfaced with the assertion of expected successful response + printed stack trace.\nHowever, changing the logic to capture the error and re-throw under main, to help with readability.", "author": "tkountis", "createdAt": "2020-12-09T20:50:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNDc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNjA5Mg==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536336092", "bodyText": "Similar logic here. If you verify in the filter, it can be executed in offloaded thread. You need to verify results on the caller side. Read the response via client API.", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:39:31Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ServiceTalkContentCodingTest.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+import io.servicetalk.http.netty.HttpClients;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.HeaderUtils.encodingFor;\n+import static io.servicetalk.http.api.HttpHeaderNames.ACCEPT_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_ENCODING;\n+import static io.servicetalk.http.api.HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.util.Arrays.stream;\n+import static java.util.Collections.disjoint;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class ServiceTalkContentCodingTest extends BaseContentCodingTest {\n+\n+    private static final Function<Scenario, StreamingHttpServiceFilterFactory> REQ_VERIFIER = (scenario)\n+            -> new StreamingHttpServiceFilterFactory() {\n+        @Override\n+        public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+            return new StreamingHttpServiceFilter(service) {\n+                @Override\n+\n+                public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                            final StreamingHttpRequest request,\n+                                                            final StreamingHttpResponseFactory responseFactory) {\n+                    final ContentCodec reqEncoding = scenario.requestEncoding;\n+                    final List<ContentCodec> clientSupportedEncodings = scenario.clientSupported;\n+\n+                    try {\n+\n+                        String requestPayload = request.payloadBody(textDeserializer())\n+                                .collect(StringBuilder::new, StringBuilder::append)\n+                                .toFuture().get().toString();\n+\n+                        assertEquals(payloadAsString((byte) 'a'), requestPayload);\n+\n+                        final List<String> actualReqAcceptedEncodings = stream(request.headers()\n+                                .get(ACCEPT_ENCODING, \"NOT_PRESENT\").toString().split(\",\"))\n+                                .map((String::trim)).collect(toList());\n+\n+                        final List<String> expectedReqAcceptedEncodings = clientSupportedEncodings.stream()\n+                                .filter((enc) -> enc != identity())\n+                                .map((ContentCodec::name))\n+                                .map(CharSequence::toString)\n+                                .collect(toList());\n+\n+                        if (reqEncoding != identity()) {\n+                            assertTrue(\"Request encoding should be present in the request headers\",\n+                                    contentEquals(reqEncoding.name(),\n+                                            request.headers().get(ACCEPT_ENCODING, \"NOT_PRESENT\")));\n+                        }\n+\n+                        if (!expectedReqAcceptedEncodings.isEmpty() && !actualReqAcceptedEncodings.isEmpty()) {\n+                            assertThat(actualReqAcceptedEncodings, equalTo(expectedReqAcceptedEncodings));\n+                        }\n+\n+                        return super.handle(ctx, request, responseFactory);\n+                    } catch (Throwable t) {\n+                        t.printStackTrace();\n+                        return succeeded(responseFactory.badRequest());\n+                    }\n+                }\n+            };\n+        }\n+    };\n+\n+    static final Function<Scenario, StreamingHttpClientFilterFactory> RESP_VERIFIER = (scenario)\n+            -> new StreamingHttpClientFilterFactory() {\n+        @Override\n+        public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+            return new StreamingHttpClientFilter(client) {\n+                @Override\n+                protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                                final HttpExecutionStrategy strategy,\n+                                                                final StreamingHttpRequest request) {\n+                    return super.request(delegate, strategy, request).map(response -> {\n+                        List<ContentCodec> server = scenario.serverSupported;\n+                        List<ContentCodec> client = scenario.clientSupported;\n+\n+                        ContentCodec expected = identity();\n+                        for (ContentCodec codec : client) {\n+                            if (server.contains(codec)) {\n+                                expected = codec;\n+                                break;\n+                            }\n+                        }\n+\n+                        assertEquals(expected, encodingFor(client, response.headers()", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNzk1Mw==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536337953", "bodyText": "Consider using BlockingHttpClient by default", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:42:49Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ServiceTalkContentCodingTest.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+import io.servicetalk.http.netty.HttpClients;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.HeaderUtils.encodingFor;\n+import static io.servicetalk.http.api.HttpHeaderNames.ACCEPT_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_ENCODING;\n+import static io.servicetalk.http.api.HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.util.Arrays.stream;\n+import static java.util.Collections.disjoint;\n+import static java.util.Collections.singletonList;\n+import static java.util.stream.Collectors.toList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class ServiceTalkContentCodingTest extends BaseContentCodingTest {\n+\n+    private static final Function<Scenario, StreamingHttpServiceFilterFactory> REQ_VERIFIER = (scenario)\n+            -> new StreamingHttpServiceFilterFactory() {\n+        @Override\n+        public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+            return new StreamingHttpServiceFilter(service) {\n+                @Override\n+\n+                public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                            final StreamingHttpRequest request,\n+                                                            final StreamingHttpResponseFactory responseFactory) {\n+                    final ContentCodec reqEncoding = scenario.requestEncoding;\n+                    final List<ContentCodec> clientSupportedEncodings = scenario.clientSupported;\n+\n+                    try {\n+\n+                        String requestPayload = request.payloadBody(textDeserializer())\n+                                .collect(StringBuilder::new, StringBuilder::append)\n+                                .toFuture().get().toString();\n+\n+                        assertEquals(payloadAsString((byte) 'a'), requestPayload);\n+\n+                        final List<String> actualReqAcceptedEncodings = stream(request.headers()\n+                                .get(ACCEPT_ENCODING, \"NOT_PRESENT\").toString().split(\",\"))\n+                                .map((String::trim)).collect(toList());\n+\n+                        final List<String> expectedReqAcceptedEncodings = clientSupportedEncodings.stream()\n+                                .filter((enc) -> enc != identity())\n+                                .map((ContentCodec::name))\n+                                .map(CharSequence::toString)\n+                                .collect(toList());\n+\n+                        if (reqEncoding != identity()) {\n+                            assertTrue(\"Request encoding should be present in the request headers\",\n+                                    contentEquals(reqEncoding.name(),\n+                                            request.headers().get(ACCEPT_ENCODING, \"NOT_PRESENT\")));\n+                        }\n+\n+                        if (!expectedReqAcceptedEncodings.isEmpty() && !actualReqAcceptedEncodings.isEmpty()) {\n+                            assertThat(actualReqAcceptedEncodings, equalTo(expectedReqAcceptedEncodings));\n+                        }\n+\n+                        return super.handle(ctx, request, responseFactory);\n+                    } catch (Throwable t) {\n+                        t.printStackTrace();\n+                        return succeeded(responseFactory.badRequest());\n+                    }\n+                }\n+            };\n+        }\n+    };\n+\n+    static final Function<Scenario, StreamingHttpClientFilterFactory> RESP_VERIFIER = (scenario)\n+            -> new StreamingHttpClientFilterFactory() {\n+        @Override\n+        public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+            return new StreamingHttpClientFilter(client) {\n+                @Override\n+                protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                                final HttpExecutionStrategy strategy,\n+                                                                final StreamingHttpRequest request) {\n+                    return super.request(delegate, strategy, request).map(response -> {\n+                        List<ContentCodec> server = scenario.serverSupported;\n+                        List<ContentCodec> client = scenario.clientSupported;\n+\n+                        ContentCodec expected = identity();\n+                        for (ContentCodec codec : client) {\n+                            if (server.contains(codec)) {\n+                                expected = codec;\n+                                break;\n+                            }\n+                        }\n+\n+                        assertEquals(expected, encodingFor(client, response.headers()\n+                                .get(CONTENT_ENCODING, \"identity\")));\n+                        return response;\n+                    });\n+                }\n+            };\n+        }\n+    };\n+\n+    private ServerContext serverContext;\n+    private HttpClient client;\n+\n+    public ServiceTalkContentCodingTest(Scenario scenario) {\n+        super(scenario);\n+    }\n+\n+    @Before\n+    public void start() throws Exception {\n+        serverContext = newServiceTalkServer(scenario);\n+        client = newServiceTalkClient(serverHostAndPort(serverContext), scenario);\n+    }\n+\n+    @After\n+    public void finish() throws Exception {\n+        client.close();\n+        serverContext.close();\n+    }\n+\n+    protected HttpClient client() {\n+        return client;\n+    }\n+\n+    protected void assertSuccessful(final ContentCodec encoding) throws Exception {\n+        assertResponse(client().request(client()\n+                .get(\"/\")\n+                .encoding(encoding)\n+                .payloadBody(payloadAsString((byte) 'a'), textSerializer())).toFuture().get().toStreamingResponse());", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM0MDcwMA==", "url": "https://github.com/apple/servicetalk/pull/1239#discussion_r536340700", "bodyText": "For the purpose of the test, you don't need keep-alive logic. Just leave the connection open (@After will shutdown everything) or always close it, doesn't matter.", "author": "idelpivnitskiy", "createdAt": "2020-12-04T19:47:58Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/api/ServiceTalkToNettyContentCodingCompatibilityTest.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.concurrent.api.DefaultThreadFactory;\n+import io.servicetalk.transport.api.HostAndPort;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.handler.codec.http.DefaultFullHttpResponse;\n+import io.netty.handler.codec.http.FullHttpResponse;\n+import io.netty.handler.codec.http.HttpContentCompressor;\n+import io.netty.handler.codec.http.HttpContentDecompressor;\n+import io.netty.handler.codec.http.HttpObject;\n+import io.netty.handler.codec.http.HttpServerCodec;\n+import io.netty.handler.codec.http.HttpUtil;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.net.InetSocketAddress;\n+\n+import static io.netty.buffer.Unpooled.wrappedBuffer;\n+import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;\n+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\n+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.KEEP_ALIVE;\n+import static io.netty.handler.codec.http.HttpHeaderValues.TEXT_PLAIN;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.serverChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.NORM_PRIORITY;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.junit.Assume.assumeFalse;\n+import static org.junit.Assume.assumeTrue;\n+\n+@RunWith(Parameterized.class)\n+public class ServiceTalkToNettyContentCodingCompatibilityTest extends ServiceTalkContentCodingTest {\n+\n+    private EventLoopGroup serverEventLoopGroup;\n+    private Channel serverAcceptorChannel;\n+    private HttpClient client;\n+\n+    public ServiceTalkToNettyContentCodingCompatibilityTest(Scenario scenario) {\n+        super(scenario);\n+    }\n+\n+    @Before\n+    public void start() {\n+        serverEventLoopGroup = createEventLoopGroup(2, new DefaultThreadFactory(\"server-io\", true, NORM_PRIORITY));\n+        serverAcceptorChannel = newNettyServer();\n+        InetSocketAddress serverAddress = (InetSocketAddress) serverAcceptorChannel.localAddress();\n+        client = newServiceTalkClient(HostAndPort.of(serverAddress), scenario);\n+    }\n+\n+    @After\n+    public void finish() throws Exception {\n+        serverAcceptorChannel.close().syncUninterruptibly();\n+        serverEventLoopGroup.shutdownGracefully(0, 0, MILLISECONDS).syncUninterruptibly();\n+        client.close();\n+    }\n+\n+    private Channel newNettyServer() {\n+        ServerBootstrap sb = new ServerBootstrap();\n+        sb.group(serverEventLoopGroup);\n+        sb.channel(serverChannel(serverEventLoopGroup, InetSocketAddress.class));\n+\n+        sb.childHandler(new ChannelInitializer<Channel>() {\n+            @Override\n+            protected void initChannel(final Channel ch) {\n+                ChannelPipeline p = ch.pipeline();\n+                p.addLast(new HttpServerCodec());\n+                if (!scenario.serverSupported.isEmpty()) {\n+                    p.addLast(new HttpContentDecompressor());\n+                    p.addLast(new HttpContentCompressor());\n+                }\n+                p.addLast(EchoServerHandler.INSTANCE);\n+            }\n+        });\n+        return sb.bind(localAddress(0)).syncUninterruptibly().channel();\n+    }\n+\n+    @Override\n+    public void testCompatibility() throws Exception {\n+        assumeFalse(\"Only testing H1 scenarios yet.\", scenario.isH2);\n+        assumeTrue(\"Only testing successful configurations; Netty doesn't have knowledge \" +\n+                \"about unsupported compression types.\", scenario.valid);\n+\n+        super.testCompatibility();\n+    }\n+\n+    @Override\n+    protected HttpClient client() {\n+        return client;\n+    }\n+\n+    @ChannelHandler.Sharable\n+    static class EchoServerHandler extends SimpleChannelInboundHandler<HttpObject> {\n+        static final EchoServerHandler INSTANCE = new EchoServerHandler();\n+\n+        private static final byte[] CONTENT = payload((byte) 'b');\n+\n+        @Override\n+        public void channelReadComplete(ChannelHandlerContext ctx) {\n+            ctx.flush();\n+        }\n+\n+        @Override\n+        public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) {\n+            if (msg instanceof io.netty.handler.codec.http.HttpRequest) {\n+                io.netty.handler.codec.http.HttpRequest req = (io.netty.handler.codec.http.HttpRequest) msg;\n+\n+                boolean keepAlive = HttpUtil.isKeepAlive(req);\n+                FullHttpResponse response = new DefaultFullHttpResponse(req.protocolVersion(),\n+                        OK, wrappedBuffer(CONTENT));\n+\n+                response.headers()\n+                        .set(CONTENT_TYPE, TEXT_PLAIN)\n+                        .setInt(CONTENT_LENGTH, response.content().readableBytes());\n+\n+                if (keepAlive) {\n+                    if (!req.protocolVersion().isKeepAliveDefault()) {\n+                        response.headers().set(CONNECTION, KEEP_ALIVE);\n+                    }\n+                } else {\n+                    response.headers().set(CONNECTION, CLOSE);\n+                }\n+\n+                ChannelFuture f = ctx.write(response);\n+\n+                if (!keepAlive) {", "originalCommit": "88e7c74b2fc7b089419f277d90e21a8eff6caabe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0a926cede5f7015e084917ef8c369b8db83be54d", "url": "https://github.com/apple/servicetalk/commit/0a926cede5f7015e084917ef8c369b8db83be54d", "message": "Comments", "committedDate": "2020-12-09T21:26:58Z", "type": "commit"}, {"oid": "0a926cede5f7015e084917ef8c369b8db83be54d", "url": "https://github.com/apple/servicetalk/commit/0a926cede5f7015e084917ef8c369b8db83be54d", "message": "Comments", "committedDate": "2020-12-09T21:26:58Z", "type": "forcePushed"}]}