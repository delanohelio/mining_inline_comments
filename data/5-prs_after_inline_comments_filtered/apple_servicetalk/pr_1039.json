{"pr_number": 1039, "pr_title": "Improve `Processors`", "pr_createdAt": "2020-05-04T16:50:06Z", "pr_url": "https://github.com/apple/servicetalk/pull/1039", "timeline": [{"oid": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "url": "https://github.com/apple/servicetalk/commit/582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "message": "Improve `Processors`\n\n__Motivation__\n\n`Processors` is a static factory to create different `Processor` implementations but it is missing a few things:\n\n- No way to create a `Processor` for `PublisherSource`\n- `BlockingIterable.Processor` does not provide a way to create custom buffering strategies.\n\n__Modification__\n\n- Introduce `PublisherSource.Processor`.\n- Add new methods to `Processors` to create `PublisherSource.Processor` instances.\n- Since buffering for a streaming `Processor` is involved and may differ for different use cases (eg: fail on overflow, drop on overflow, etc), provide a public API for `PublisherProcessorBuffer` that can help use different strategies for buffering.\n- Use similar buffering API for `BlockingIterable.Processor`.\n- Removes the custom `SpscPublisherProcessor` implementation.\n- Replace all `SpscPublisherProcessor` usages with the new implementation.\n\n__Result__\n\nEnhanced usefulness of `Processor` static factory.", "committedDate": "2020-05-04T17:00:23Z", "type": "commit"}, {"oid": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "url": "https://github.com/apple/servicetalk/commit/582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "message": "Improve `Processors`\n\n__Motivation__\n\n`Processors` is a static factory to create different `Processor` implementations but it is missing a few things:\n\n- No way to create a `Processor` for `PublisherSource`\n- `BlockingIterable.Processor` does not provide a way to create custom buffering strategies.\n\n__Modification__\n\n- Introduce `PublisherSource.Processor`.\n- Add new methods to `Processors` to create `PublisherSource.Processor` instances.\n- Since buffering for a streaming `Processor` is involved and may differ for different use cases (eg: fail on overflow, drop on overflow, etc), provide a public API for `PublisherProcessorBuffer` that can help use different strategies for buffering.\n- Use similar buffering API for `BlockingIterable.Processor`.\n- Removes the custom `SpscPublisherProcessor` implementation.\n- Replace all `SpscPublisherProcessor` usages with the new implementation.\n\n__Result__\n\nEnhanced usefulness of `Processor` static factory.", "committedDate": "2020-05-04T17:00:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MTEzNg==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420041136", "bodyText": "nit: please add javadocs for all protected methods.", "author": "normanmaurer", "createdAt": "2020-05-05T11:33:19Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer<T> implements ProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    @Override\n+    public final void add(@Nullable final T item) {\n+        final TerminalNotification terminalNotification = terminal;\n+        if (terminalNotification != null) {\n+            throw new IllegalStateException(\"Buffer \" + this + \" is already terminated: \" + terminal);\n+        }\n+        addItem(item == null ? NULL_ITEM : item);\n+    }\n+\n+    @Override\n+    public final void terminate() {\n+        if (terminalUpdater.compareAndSet(this, null, complete())) {\n+            addTerminal(complete());\n+        }\n+    }\n+\n+    @Override\n+    public final void terminate(final Throwable cause) {\n+        TerminalNotification notification = error(cause);\n+        if (terminalUpdater.compareAndSet(this, null, notification)) {\n+            addTerminal(notification);\n+        }\n+    }\n+\n+    protected abstract void addItem(Object item);\n+\n+    protected abstract void addTerminal(TerminalNotification terminalNotification);\n+\n+    protected boolean consumeIfTerminal(final BufferConsumer<T> consumer, @Nullable final Object signal) {\n+        if (signal instanceof TerminalNotification) {\n+            TerminalNotification terminalNotification = (TerminalNotification) signal;\n+            if (terminalNotification.cause() != null) {\n+                consumer.consumeTerminal(terminalNotification.cause());\n+            } else {\n+                consumer.consumeTerminal();\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    protected boolean consumeNextItem(final BufferConsumer<T> consumer, @Nullable final Object nextItem) {\n+        if (nextItem == null) {\n+            return false;\n+        }\n+        if (nextItem == NULL_ITEM) {\n+            consumer.consumeItem(null);\n+        } else {\n+            @SuppressWarnings(\"unchecked\")\n+            T t = (T) nextItem;\n+            consumer.consumeItem(t);\n+        }\n+        return true;\n+    }", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MTk0MQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420041941", "bodyText": "nit: consider this:\nThrowable cause = ((TerminalNotification) signal).cause();\nif (cause != null) {\n    consumer.consumeTerminal(cause));\n} else {\n    consumer.consumeTerminal();\n}", "author": "normanmaurer", "createdAt": "2020-05-05T11:34:56Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer<T> implements ProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    @Override\n+    public final void add(@Nullable final T item) {\n+        final TerminalNotification terminalNotification = terminal;\n+        if (terminalNotification != null) {\n+            throw new IllegalStateException(\"Buffer \" + this + \" is already terminated: \" + terminal);\n+        }\n+        addItem(item == null ? NULL_ITEM : item);\n+    }\n+\n+    @Override\n+    public final void terminate() {\n+        if (terminalUpdater.compareAndSet(this, null, complete())) {\n+            addTerminal(complete());\n+        }\n+    }\n+\n+    @Override\n+    public final void terminate(final Throwable cause) {\n+        TerminalNotification notification = error(cause);\n+        if (terminalUpdater.compareAndSet(this, null, notification)) {\n+            addTerminal(notification);\n+        }\n+    }\n+\n+    protected abstract void addItem(Object item);\n+\n+    protected abstract void addTerminal(TerminalNotification terminalNotification);\n+\n+    protected boolean consumeIfTerminal(final BufferConsumer<T> consumer, @Nullable final Object signal) {\n+        if (signal instanceof TerminalNotification) {\n+            TerminalNotification terminalNotification = (TerminalNotification) signal;\n+            if (terminalNotification.cause() != null) {\n+                consumer.consumeTerminal(terminalNotification.cause());\n+            } else {\n+                consumer.consumeTerminal();\n+            }", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MjQxOA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420042418", "bodyText": "Consider storing the return value of complete() and use the same value for addTerminal(...). Just to be sure its the same instance at the end...", "author": "normanmaurer", "createdAt": "2020-05-05T11:35:56Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer<T> implements ProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    @Override\n+    public final void add(@Nullable final T item) {\n+        final TerminalNotification terminalNotification = terminal;\n+        if (terminalNotification != null) {\n+            throw new IllegalStateException(\"Buffer \" + this + \" is already terminated: \" + terminal);\n+        }\n+        addItem(item == null ? NULL_ITEM : item);\n+    }\n+\n+    @Override\n+    public final void terminate() {\n+        if (terminalUpdater.compareAndSet(this, null, complete())) {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MzA0Nw==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420043047", "bodyText": "imho this is quite hard to read...", "author": "normanmaurer", "createdAt": "2020-05-05T11:37:11Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractPublisherProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+abstract class AbstractPublisherProcessorBuffer<T, Q extends Queue<Object>> extends AbstractProcessorBuffer<T>\n+        implements PublisherProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<AbstractPublisherProcessorBuffer> bufferedUpdater =\n+            newUpdater(AbstractPublisherProcessorBuffer.class, \"buffered\");\n+\n+    private final int maxBuffer;\n+    private final Q signals;\n+\n+    private volatile int buffered;\n+\n+    AbstractPublisherProcessorBuffer(final int maxBuffer, final Q signals) {\n+        if (maxBuffer <= 0) {\n+            throw new IllegalArgumentException(\"maxBuffer: \" + maxBuffer + \" (expected > 0)\");\n+        }\n+        this.maxBuffer = maxBuffer;\n+        this.signals = requireNonNull(signals);\n+    }\n+\n+    @Override\n+    protected void addItem(final Object item) {\n+        if (bufferedUpdater.getAndAccumulate(this, 1,\n+                (prev, next) -> prev == maxBuffer ? maxBuffer :", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NjAwMQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421056001", "bodyText": "Based on Scott's comment below, this is a bit simpler now:\n       if (bufferedUpdater.getAndAccumulate(this, 1,\n                (prev, next) -> prev == maxBuffer ? maxBuffer : (prev + next)) == maxBuffer) {\n\ndo you still feel this is hard to read? If so, what will you suggest as an alternative?", "author": "NiteshKant", "createdAt": "2020-05-06T19:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MzA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI5MjU4NQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421292585", "bodyText": "thats fine", "author": "normanmaurer", "createdAt": "2020-05-07T07:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0MzA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0NzQ2MQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420047461", "bodyText": "I think this is racy as you may have queue.offer return false if this method is invoked by multiple threads.\nYou should do something like:\nvoid offerPastBufferSize(final Object signal, final ConcurrentLinkedQueue<Object> queue) {\n    while (!queue.offer(signal)) {\n        queue.poll();\n    }\n}", "author": "normanmaurer", "createdAt": "2020-05-05T11:45:52Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessorBuffers.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import static io.servicetalk.utils.internal.PlatformDependent.newMpscQueue;\n+\n+/**\n+ * A static factory for {@link PublisherProcessorBuffer}s.\n+ */\n+public final class PublisherProcessorBuffers {\n+    private PublisherProcessorBuffers() {\n+        // no instances.\n+    }\n+\n+    /**\n+     * Creates a new {@link PublisherProcessorBuffer} which buffers a maximum of {@code maxBuffer} items without being\n+     * consumed. If more items are {@link PublisherProcessorBuffer#add(Object) added} to the returned\n+     * {@link PublisherProcessorBuffer} then that {@link PublisherProcessorBuffer#add(Object) addition} will fail.\n+     *\n+     * @param maxBuffer Maximum number of items that can be present in the returned\n+     * @param <T> Type of items added to the returned {@link PublisherProcessorBuffer}.\n+     * @return A new {@link PublisherProcessorBuffer}.\n+     */\n+    public static <T> PublisherProcessorBuffer<T> fixedSize(final int maxBuffer) {\n+        return new AbstractPublisherProcessorBuffer<T, Queue<Object>>(maxBuffer, newMpscQueue(2, maxBuffer)) {\n+            @Override\n+            void offerPastBufferSize(final Object signal, final Queue<Object> queue) {\n+                throw new QueueFullException(\"processor-buffer\", maxBuffer);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a new {@link PublisherProcessorBuffer} which buffers a maximum of {@code maxBuffer} items without being\n+     * consumed. If more items are {@link PublisherProcessorBuffer#add(Object) added} to the returned\n+     * {@link PublisherProcessorBuffer} then that {@link PublisherProcessorBuffer#add(Object) addition} will be dropped.\n+     *\n+     * @param maxBuffer Maximum number of items that can be present in the returned\n+     * @param <T> Type of items added to the returned {@link PublisherProcessorBuffer}.\n+     * @return A new {@link PublisherProcessorBuffer}.\n+     */\n+    public static <T> PublisherProcessorBuffer<T> fixedSizeDropLatest(final int maxBuffer) {\n+        return new AbstractPublisherProcessorBuffer<T, Queue<Object>>(maxBuffer, newMpscQueue(2, maxBuffer)) {\n+            @Override\n+            void offerPastBufferSize(final Object signal, final Queue<Object> queue) {\n+                // noop => drop latest\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a new {@link PublisherProcessorBuffer} which buffers a maximum of {@code maxBuffer} items without being\n+     * consumed. If more items are {@link PublisherProcessorBuffer#add(Object) added} to the returned\n+     * {@link PublisherProcessorBuffer} then the oldest item previously added to the buffer will be dropped.\n+     *\n+     * @param maxBuffer Maximum number of items that can be present in the returned\n+     * @param <T> Type of items added to the returned {@link PublisherProcessorBuffer}.\n+     * @return A new {@link PublisherProcessorBuffer}.\n+     */\n+    public static <T> PublisherProcessorBuffer<T> fixedSizeDropOldest(final int maxBuffer) {\n+        return new AbstractPublisherProcessorBuffer<T, ConcurrentLinkedQueue<Object>>(maxBuffer,\n+                new ConcurrentLinkedQueue<>()) {\n+            @Override\n+            void offerPastBufferSize(final Object signal, final ConcurrentLinkedQueue<Object> queue) {\n+                queue.poll(); // drop oldest\n+                queue.offer(signal);", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NzA2NA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421187064", "bodyText": "Since this is a ConcurrentLinkedQueue it is unbounded, offer() never returns false.\nAs we are not touching the buffered items count (in AbstractPublisherProcessorBuffer) every buffer size breach will drop one item and add one item, eventually leading to the size == maxBuffer unless other items are drained.", "author": "NiteshKant", "createdAt": "2020-05-07T01:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0NzQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI4OTk3NA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421289974", "bodyText": "still I think it should be done to guard against problems later when the code is changed. At least I would add a comment with a warning that the queue must be unbound.", "author": "normanmaurer", "createdAt": "2020-05-07T07:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0NzQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0MjIyNA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r422342224", "bodyText": "Ok lemme add a comment.", "author": "NiteshKant", "createdAt": "2020-05-08T19:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA0NzQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyOTA0MA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420429040", "bodyText": "PublisherProcessorBuffer extends this interface and is public, but this interface is package private. Should this be public, or can they all be package private (related to another comment)?", "author": "Scottmitch", "createdAt": "2020-05-05T21:53:02Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A buffer for different {@code Processor}s.\n+ *\n+ * @param <T>  Type of items stored in this buffer.\n+ */\n+interface ProcessorBuffer<T> {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA3MDE1NQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421070155", "bodyText": "I have moved BufferConsumer to top level and removed this interface. Lets discuss public API surface area in your other comment.", "author": "NiteshKant", "createdAt": "2020-05-06T20:25:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyOTA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyOTYyMg==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420429622", "bodyText": "+ terminal -> + terminalNotification", "author": "Scottmitch", "createdAt": "2020-05-05T21:54:22Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer<T> implements ProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    @Override\n+    public final void add(@Nullable final T item) {\n+        final TerminalNotification terminalNotification = terminal;\n+        if (terminalNotification != null) {\n+            throw new IllegalStateException(\"Buffer \" + this + \" is already terminated: \" + terminal);", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMTkzMQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420431931", "bodyText": "make this method final?", "author": "Scottmitch", "createdAt": "2020-05-05T21:59:10Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer<T> implements ProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    @Override\n+    public final void add(@Nullable final T item) {\n+        final TerminalNotification terminalNotification = terminal;\n+        if (terminalNotification != null) {\n+            throw new IllegalStateException(\"Buffer \" + this + \" is already terminated: \" + terminal);\n+        }\n+        addItem(item == null ? NULL_ITEM : item);\n+    }\n+\n+    @Override\n+    public final void terminate() {\n+        if (terminalUpdater.compareAndSet(this, null, complete())) {\n+            addTerminal(complete());\n+        }\n+    }\n+\n+    @Override\n+    public final void terminate(final Throwable cause) {\n+        TerminalNotification notification = error(cause);\n+        if (terminalUpdater.compareAndSet(this, null, notification)) {\n+            addTerminal(notification);\n+        }\n+    }\n+\n+    protected abstract void addItem(Object item);\n+\n+    protected abstract void addTerminal(TerminalNotification terminalNotification);\n+\n+    protected boolean consumeIfTerminal(final BufferConsumer<T> consumer, @Nullable final Object signal) {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMjIwNA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420432204", "bodyText": "make this method final?", "author": "Scottmitch", "createdAt": "2020-05-05T21:59:51Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer<T> implements ProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    @Override\n+    public final void add(@Nullable final T item) {\n+        final TerminalNotification terminalNotification = terminal;\n+        if (terminalNotification != null) {\n+            throw new IllegalStateException(\"Buffer \" + this + \" is already terminated: \" + terminal);\n+        }\n+        addItem(item == null ? NULL_ITEM : item);\n+    }\n+\n+    @Override\n+    public final void terminate() {\n+        if (terminalUpdater.compareAndSet(this, null, complete())) {\n+            addTerminal(complete());\n+        }\n+    }\n+\n+    @Override\n+    public final void terminate(final Throwable cause) {\n+        TerminalNotification notification = error(cause);\n+        if (terminalUpdater.compareAndSet(this, null, notification)) {\n+            addTerminal(notification);\n+        }\n+    }\n+\n+    protected abstract void addItem(Object item);\n+\n+    protected abstract void addTerminal(TerminalNotification terminalNotification);\n+\n+    protected boolean consumeIfTerminal(final BufferConsumer<T> consumer, @Nullable final Object signal) {\n+        if (signal instanceof TerminalNotification) {\n+            TerminalNotification terminalNotification = (TerminalNotification) signal;\n+            if (terminalNotification.cause() != null) {\n+                consumer.consumeTerminal(terminalNotification.cause());\n+            } else {\n+                consumer.consumeTerminal();\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    protected boolean consumeNextItem(final BufferConsumer<T> consumer, @Nullable final Object nextItem) {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzNjAxOA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420436018", "bodyText": "why do we need to catch InterruptedException, re-trigger an interrupt, and clear the interrupt flag? can we just let this exception propagate if it is used in blocking APIs? consider adding a comment if not.", "author": "Scottmitch", "createdAt": "2020-05-05T22:08:49Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/DefaultBlockingProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+\n+final class DefaultBlockingProcessorBuffer<T> extends AbstractProcessorBuffer<T> implements BlockingProcessorBuffer<T> {\n+    private final BlockingQueue<Object> signals;\n+\n+    DefaultBlockingProcessorBuffer(final int maxBuffer) {\n+        this.signals = new LinkedBlockingQueue<>(maxBuffer);\n+    }\n+\n+    @Override\n+    protected void addItem(final Object item) {\n+        putSignal(item);\n+    }\n+\n+    @Override\n+    protected void addTerminal(final TerminalNotification terminalNotification) {\n+        putSignal(terminalNotification);\n+    }\n+\n+    @Override\n+    public boolean consume(final BufferConsumer<T> consumer) {\n+        if (consumeIfTerminal(consumer, signals.peek())) {\n+            return true;\n+        }\n+\n+        return consumeNextItem(consumer, signals.poll());\n+    }\n+\n+    @Override\n+    public boolean consume(final BufferConsumer<T> consumer, final long waitFor, final TimeUnit waitForUnit)\n+            throws TimeoutException, InterruptedException {\n+        if (consumeIfTerminal(consumer, signals.peek())) {\n+            return true;\n+        }\n+\n+        Object nextItem = signals.poll(waitFor, waitForUnit);\n+        if (nextItem == null) {\n+            throw new TimeoutException(\"Timed out after \" + waitFor + \"(\" + waitForUnit + \") waiting for an item.\");\n+        }\n+        return consumeNextItem(consumer, nextItem);\n+    }\n+\n+    private void putSignal(final Object signal) {\n+        try {\n+            signals.put(signal);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2ODE1NA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421068154", "bodyText": "I have restructured the APIs to only throw InterruptedException for blocking variants. This was needed before because add/terminate did not throw.", "author": "NiteshKant", "createdAt": "2020-05-06T20:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzNjAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzNjY2Mg==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420436662", "bodyText": "nit: this can be simplified to the following:\n@SuppressWarnings(\"unchecked\")\nT t = nextItem == NULL_ITEM ? null : (T) nextItem;\nconsumer.consumeItem(t);", "author": "Scottmitch", "createdAt": "2020-05-05T22:10:10Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer<T> implements ProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    @Override\n+    public final void add(@Nullable final T item) {\n+        final TerminalNotification terminalNotification = terminal;\n+        if (terminalNotification != null) {\n+            throw new IllegalStateException(\"Buffer \" + this + \" is already terminated: \" + terminal);\n+        }\n+        addItem(item == null ? NULL_ITEM : item);\n+    }\n+\n+    @Override\n+    public final void terminate() {\n+        if (terminalUpdater.compareAndSet(this, null, complete())) {\n+            addTerminal(complete());\n+        }\n+    }\n+\n+    @Override\n+    public final void terminate(final Throwable cause) {\n+        TerminalNotification notification = error(cause);\n+        if (terminalUpdater.compareAndSet(this, null, notification)) {\n+            addTerminal(notification);\n+        }\n+    }\n+\n+    protected abstract void addItem(Object item);\n+\n+    protected abstract void addTerminal(TerminalNotification terminalNotification);\n+\n+    protected boolean consumeIfTerminal(final BufferConsumer<T> consumer, @Nullable final Object signal) {\n+        if (signal instanceof TerminalNotification) {\n+            TerminalNotification terminalNotification = (TerminalNotification) signal;\n+            if (terminalNotification.cause() != null) {\n+                consumer.consumeTerminal(terminalNotification.cause());\n+            } else {\n+                consumer.consumeTerminal();\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    protected boolean consumeNextItem(final BufferConsumer<T> consumer, @Nullable final Object nextItem) {\n+        if (nextItem == null) {\n+            return false;\n+        }\n+        if (nextItem == NULL_ITEM) {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ0MTY5MA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420441690", "bodyText": "IIUC add and terminate maybe called concurrently?\n\nIf so this is a best effort check and we may still add items unless there is external synchronization. Should we remove the check as it isn't reliable (it may provide a false sense of security from code inspection and depending upon usage pattern)?\nif not can you clarify the threading/ordering semantics on the base interface?", "author": "Scottmitch", "createdAt": "2020-05-05T22:22:07Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer<T> implements ProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    @Override\n+    public final void add(@Nullable final T item) {\n+        final TerminalNotification terminalNotification = terminal;\n+        if (terminalNotification != null) {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTE0MA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421051140", "bodyText": "Removed", "author": "NiteshKant", "createdAt": "2020-05-06T19:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ0MTY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NTY4NQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420455685", "bodyText": "ProcessorBuffer, BufferConsumer, and PublisherProcessorBuffer introduce surface area for data production/consumption to the public API and have a high amount of conceptual overlap with Processor. What additional use cases beyond what is in PublisherProcessorBuffers do you have in mind? Is it reasonable to move the methods from PublisherProcessorBuffers into this class and keep the PublisherProcessorBuffer related interfaces package private for now?", "author": "Scottmitch", "createdAt": "2020-05-05T22:57:01Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Processors.java", "diffHunk": "@@ -52,14 +53,42 @@ private Processors() {\n         return new SingleProcessor<>();\n     }\n \n+    /**\n+     * Create a new {@link PublisherSource.Processor} that allows for a single\n+     * {@link PublisherSource.Subscriber#subscribe(PublisherSource.Subscriber) subscribe}.\n+     *\n+     * @param <T> The {@link PublisherSource} type and {@link PublisherSource.Subscriber} type of the\n+     * {@link PublisherSource.Processor}.\n+     * @return a new {@link PublisherSource.Processor} that allows for a single\n+     * {@link PublisherSource.Subscriber#subscribe(PublisherSource.Subscriber) subscribe}.\n+     */\n+    public static <T> PublisherSource.Processor<T, T> newPublisherProcessor() {\n+        return newPublisherProcessor(PublisherProcessorBuffers.fixedSize(32));\n+    }\n+\n+    /**\n+     * Create a new {@link PublisherSource.Processor} that allows for a single\n+     * {@link PublisherSource.Subscriber#subscribe(PublisherSource.Subscriber) subscribe}.\n+     *\n+     * @param buffer A {@link PublisherProcessorBuffer} to store items that are requested to be sent via\n+     * {@link PublisherSource.Processor#onNext(Object)} but not yet emitted to the {@link PublisherSource.Subscriber}.\n+     * @param <T> The {@link PublisherSource} type and {@link PublisherSource.Subscriber} type of the\n+     * {@link PublisherSource.Processor}.\n+     * @return a new {@link PublisherSource.Processor} that allows for a single\n+     * {@link PublisherSource.Subscriber#subscribe(PublisherSource.Subscriber) subscribe}.\n+     */\n+    public static <T> PublisherSource.Processor<T, T> newPublisherProcessor(final PublisherProcessorBuffer<T> buffer) {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE5MjEzOQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421192139", "bodyText": "The Buffer API is introduced with the following motivations:\n\nSupport different queue types\nSupport different rejection strategies\n\nThere are a few practical usecases for each of these motivation:\n\nOptimized queue types based on Processor usage: if the usage of Subscriber side is non-concurrent, one can use an spsc queue.\nDifferent queue implementations based on buffer type: Load balancer ready events today only require the last event to be buffered. So it can simply use an atomic ref instead of a queue.\nDynamic buffer sizes: For event bus kind of usecases (eg: listening to tracing spans), it is hard to determine a size for the queue. In such cases, having a dynamic queue size based on queue size EWMA (as an example) may be a good strategy to avoid pessimistic drops.\nBuffer size based on serialized size: For cases when the items are serialized and sent on the wire, one may want to buffer based on memory used(heterogeneous serialized sizes) vs items count . Tracing is one such usecase.\nReverse queue rejection strategy: For non-critical, unordered events; upon rejection, one could reverse the queue to avoid processing older events. eg if the processor is used to funnel requests to a single connection.\nNon-linear discards: For highly spikey events; one could use a non-linear rejection strategy (drop 5 items for each size breach)\n\nDecoupling buffering from the Processors enable us to support such cases which we partially know today and partially, providing these APIs can help discover such cases. For APIs like this which are by nature open ended, I have been more liberal in exposing more generic APIs instead of being pessimistically restrictive.", "author": "NiteshKant", "createdAt": "2020-05-07T01:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwNjE3NA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421806174", "bodyText": "thanks for the additional context. can you add a summary of this to the javadoc of PublisherProcessorBuffer for additional motivation?\nConsider moving the PublisherProcessorBuffers to this class to aid discoverability and keep the processors consolidated (and be consistent with the Blocking variants).\nnewPublisherProcessor(int maxBuffer)\nnewPublisherProcessorDropTail(int maxBuffer) // aka latest\nnewPublisherProcessorDropHead(int maxBuffer) // aka oldest", "author": "Scottmitch", "createdAt": "2020-05-07T21:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0MTg3Nw==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r422341877", "bodyText": "I have made the PublisherProcessorBuffers class pkg-private and folded methods into Processors as you suggest.", "author": "NiteshKant", "createdAt": "2020-05-08T19:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NzkwNQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420457905", "bodyText": "IIUC there can be no concurrency between methods on this immediate level on the interface? Consider referencing RS no-concurrency semantics [1] here and in BlockingProcessorBuffer to clarify.\n[1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.3", "author": "Scottmitch", "createdAt": "2020-05-05T23:03:19Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+\n+/**\n+ * A buffer to store items for a {@link Processor}.\n+ *\n+ * @param <T>  Type of items stored in this buffer.\n+ */\n+public interface PublisherProcessorBuffer<T> extends ProcessorBuffer<T> {\n+\n+    /**\n+     * Try to consume the next item stored in this buffer. If there are no items stored in the buffer and the buffer has\n+     * terminated {@link #terminate() successfully} or with an {@link #terminate(Throwable) error} then consume that\n+     * {@link BufferConsumer#consumeTerminal() successful} or\n+     * {@link BufferConsumer#consumeTerminal(Throwable) failed} termination.", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NDUyOA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421184528", "bodyText": "The mix of concurrent and non-concurrent methods on the same interface is kind of painful to document. I have added some documentation on the Processors class to clarify relationship b/w usage of a Processor and the buffer w.r.t concurrency. I would refrain from providing more stricter expectation at this level as it driven from the Processor that uses it.", "author": "NiteshKant", "createdAt": "2020-05-07T01:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NzkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg4MTA1OQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421881059", "bodyText": "BufferConsumer implementations that exist today do not support concurrent access, and it would be surprising to have concurrency consumption, is this something we expect when the consumer is typically a Subscriber? The connection to the Processor comments is nuanced and I think it is worth clarifying here to avoid confusion (see #1039 (comment), #1039 (comment)).", "author": "Scottmitch", "createdAt": "2020-05-08T01:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NzkwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NjgwMg==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r422346802", "bodyText": "I have added a multi-threaded section in the class javadoc as the semantics are general to production and consumption.", "author": "NiteshKant", "createdAt": "2020-05-08T20:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NzkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1OTE3Mw==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420459173", "bodyText": "you don't need addWithOverflowProtection because you are already preventing overflow with the prev == maxBuffer check.", "author": "Scottmitch", "createdAt": "2020-05-05T23:06:29Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractPublisherProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+abstract class AbstractPublisherProcessorBuffer<T, Q extends Queue<Object>> extends AbstractProcessorBuffer<T>\n+        implements PublisherProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<AbstractPublisherProcessorBuffer> bufferedUpdater =\n+            newUpdater(AbstractPublisherProcessorBuffer.class, \"buffered\");\n+\n+    private final int maxBuffer;\n+    private final Q signals;\n+\n+    private volatile int buffered;\n+\n+    AbstractPublisherProcessorBuffer(final int maxBuffer, final Q signals) {\n+        if (maxBuffer <= 0) {\n+            throw new IllegalArgumentException(\"maxBuffer: \" + maxBuffer + \" (expected > 0)\");\n+        }\n+        this.maxBuffer = maxBuffer;\n+        this.signals = requireNonNull(signals);\n+    }\n+\n+    @Override\n+    protected void addItem(final Object item) {\n+        if (bufferedUpdater.getAndAccumulate(this, 1,\n+                (prev, next) -> prev == maxBuffer ? maxBuffer :\n+                        addWithOverflowProtection(prev, next)) == maxBuffer) {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2MDg2Mg==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420460862", "bodyText": "can we just poll to avoid multiple interactions with the queue?\nObject next = signals.poll();\nif (consumeIfTerminal(consumer, next) || consumeNextItem(consumer, next)) {\n   // assuming it doesn't matter if we decrement on terminal, otherwise this can be kept separate\n  bufferedUpdater.decrementAndGet(this);\n  return true;\n}\nreturn false;", "author": "Scottmitch", "createdAt": "2020-05-05T23:11:04Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractPublisherProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+abstract class AbstractPublisherProcessorBuffer<T, Q extends Queue<Object>> extends AbstractProcessorBuffer<T>\n+        implements PublisherProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<AbstractPublisherProcessorBuffer> bufferedUpdater =\n+            newUpdater(AbstractPublisherProcessorBuffer.class, \"buffered\");\n+\n+    private final int maxBuffer;\n+    private final Q signals;\n+\n+    private volatile int buffered;\n+\n+    AbstractPublisherProcessorBuffer(final int maxBuffer, final Q signals) {\n+        if (maxBuffer <= 0) {\n+            throw new IllegalArgumentException(\"maxBuffer: \" + maxBuffer + \" (expected > 0)\");\n+        }\n+        this.maxBuffer = maxBuffer;\n+        this.signals = requireNonNull(signals);\n+    }\n+\n+    @Override\n+    protected void addItem(final Object item) {\n+        if (bufferedUpdater.getAndAccumulate(this, 1,\n+                (prev, next) -> prev == maxBuffer ? maxBuffer :\n+                        addWithOverflowProtection(prev, next)) == maxBuffer) {\n+            offerPastBufferSize(item, signals);\n+        } else {\n+            offerSignal(item);\n+        }\n+    }\n+\n+    @Override\n+    protected void addTerminal(final TerminalNotification terminalNotification) {\n+        offerSignal(terminalNotification);\n+    }\n+\n+    @Override\n+    public boolean tryConsume(final BufferConsumer<T> consumer) {\n+        if (consumeIfTerminal(consumer, signals.peek())) {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2MjY3OQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420462679", "bodyText": "newMpscQueue(2, maxBuffer) -> newMpscQueue(2, maxBuffer + 1) (with overflow protection). AbstractPublisherProcessorBuffer only enforces the size overflow for items, and not for terminal events. however queue rejection for terminal events seem unnecessary after item size checks.", "author": "Scottmitch", "createdAt": "2020-05-05T23:16:25Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessorBuffers.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import static io.servicetalk.utils.internal.PlatformDependent.newMpscQueue;\n+\n+/**\n+ * A static factory for {@link PublisherProcessorBuffer}s.\n+ */\n+public final class PublisherProcessorBuffers {\n+    private PublisherProcessorBuffers() {\n+        // no instances.\n+    }\n+\n+    /**\n+     * Creates a new {@link PublisherProcessorBuffer} which buffers a maximum of {@code maxBuffer} items without being\n+     * consumed. If more items are {@link PublisherProcessorBuffer#add(Object) added} to the returned\n+     * {@link PublisherProcessorBuffer} then that {@link PublisherProcessorBuffer#add(Object) addition} will fail.\n+     *\n+     * @param maxBuffer Maximum number of items that can be present in the returned\n+     * @param <T> Type of items added to the returned {@link PublisherProcessorBuffer}.\n+     * @return A new {@link PublisherProcessorBuffer}.\n+     */\n+    public static <T> PublisherProcessorBuffer<T> fixedSize(final int maxBuffer) {\n+        return new AbstractPublisherProcessorBuffer<T, Queue<Object>>(maxBuffer, newMpscQueue(2, maxBuffer)) {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2OTU1OQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420469559", "bodyText": "put this in a finally block incase cancel() throws?", "author": "Scottmitch", "createdAt": "2020-05-05T23:36:30Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.api.ProcessorBuffer.BufferConsumer;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class PublisherProcessor<T> extends Publisher<T> implements Processor<T, T>, Subscription {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final BufferConsumer CANCELLED = new NoopBufferConsumer();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<PublisherProcessor, BufferConsumer> consumerUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(PublisherProcessor.class, BufferConsumer.class, \"consumer\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<PublisherProcessor> emittingUpdater =\n+            newUpdater(PublisherProcessor.class, \"emitting\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicLongFieldUpdater<PublisherProcessor> pendingUpdater =\n+            AtomicLongFieldUpdater.newUpdater(PublisherProcessor.class, \"pending\");\n+\n+    private final DelayedSubscription delayedSubscription;\n+    private final PublisherProcessorBuffer<T> buffer;\n+\n+    @Nullable\n+    private Throwable fatalError; // visible via emitting\n+    @Nullable\n+    private volatile BufferConsumer<T> consumer;\n+    @SuppressWarnings(\"unused\")\n+    private volatile int emitting;\n+    private volatile long pending;\n+\n+    PublisherProcessor(final PublisherProcessorBuffer<T> buffer) {\n+        this.buffer = requireNonNull(buffer);\n+        delayedSubscription = new DelayedSubscription();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        delayedSubscription.delayedSubscription(ConcurrentSubscription.wrap(subscription));\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        buffer.add(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        buffer.terminate(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        buffer.terminate();\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final DelayedSubscription delayedSubscription = new DelayedSubscription();\n+        try {\n+            subscriber.onSubscribe(delayedSubscription);\n+        } catch (Throwable t) {\n+            handleExceptionFromOnSubscribe(subscriber, t);\n+            return;\n+        }\n+\n+        if (consumerUpdater.compareAndSet(this, null, new SubscriberBufferConsumer<>(subscriber))) {\n+            delayedSubscription.delayedSubscription(this);\n+            tryEmitSignals();\n+        } else {\n+            BufferConsumer<? super T> existingConsumer = this.consumer;\n+            assert existingConsumer != null;\n+            @SuppressWarnings(\"unchecked\")\n+            final Subscriber<? super T> existingSubscriber = existingConsumer instanceof SubscriberBufferConsumer ?\n+                    ((SubscriberBufferConsumer<T>) existingConsumer).subscriber : null;\n+            safeOnError(subscriber, new DuplicateSubscribeException(existingSubscriber, subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> subscriber) {\n+        subscribeInternal(subscriber);\n+    }\n+\n+    @Override\n+    public void request(final long n) {\n+        if (!isRequestNValid(n)) {\n+            fatalError = newExceptionForInvalidRequestN(n);\n+        } else {\n+            pendingUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+            delayedSubscription.request(n);\n+        }\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        if (pendingUpdater.getAndSet(this, Long.MIN_VALUE) >= 0) {\n+            @SuppressWarnings(\"unchecked\")\n+            BufferConsumer<T> cancelled = CANCELLED;\n+            this.consumer = cancelled;\n+            delayedSubscription.cancel();\n+        }\n+    }\n+\n+    private void tryEmitSignals() {\n+        boolean lockReleased = false;\n+        while (!lockReleased && tryAcquireLock(emittingUpdater, this)) {\n+            final BufferConsumer<T> consumer = this.consumer;\n+            try {\n+                if (consumer instanceof SubscriberBufferConsumer) {\n+                    SubscriberBufferConsumer<T> target = (SubscriberBufferConsumer<T>) consumer;\n+                    if (fatalError != null) {\n+                        earlyTerminateConsumerHoldingLock(target, fatalError);\n+                        return;\n+                    } else {\n+                        emitSignalsHoldingLock(target);\n+                    }\n+                }\n+            } finally {\n+                lockReleased = releaseLock(emittingUpdater, this);\n+            }\n+        }\n+    }\n+\n+    private void emitSignalsHoldingLock(final SubscriberBufferConsumer<T> target) {\n+        for (;;) {\n+            final long cPending = pending;\n+            if (cPending > 0 && pendingUpdater.compareAndSet(this, cPending, cPending - 1)) {\n+                boolean consumed;\n+                try {\n+                    consumed = buffer.tryConsume(target);\n+                } catch (Throwable t) {\n+                    earlyTerminateConsumerHoldingLock(target, t);\n+                    return;\n+                }\n+\n+                if (target.isTerminated()) {\n+                    pendingUpdater.getAndSet(this, Long.MIN_VALUE);\n+                } else if (!consumed) {\n+                    // we optimistically decremented pending, so increment back again.\n+                    pendingUpdater.accumulateAndGet(this, 1,\n+                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+                    return;\n+                }\n+            } else if (cPending < 0) {\n+                // cancelled or already terminated\n+                return;\n+            } else if (cPending == 0) {\n+                if (buffer.tryConsumeTerminal(target)) {\n+                    pendingUpdater.getAndSet(this, Long.MIN_VALUE);\n+                    return;\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void earlyTerminateConsumerHoldingLock(final SubscriberBufferConsumer<T> consumer, final Throwable cause) {\n+        pendingUpdater.getAndSet(this, Long.MIN_VALUE);\n+        delayedSubscription.cancel();\n+        consumer.consumeTerminal(cause);", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2OTk1NQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420469955", "bodyText": "can this just be a volatile write? if not please add a comment clarifying why GAS is necessary.\n(general question where GAS is used in termination and return value is not used)", "author": "Scottmitch", "createdAt": "2020-05-05T23:37:53Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.api.ProcessorBuffer.BufferConsumer;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class PublisherProcessor<T> extends Publisher<T> implements Processor<T, T>, Subscription {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final BufferConsumer CANCELLED = new NoopBufferConsumer();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<PublisherProcessor, BufferConsumer> consumerUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(PublisherProcessor.class, BufferConsumer.class, \"consumer\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<PublisherProcessor> emittingUpdater =\n+            newUpdater(PublisherProcessor.class, \"emitting\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicLongFieldUpdater<PublisherProcessor> pendingUpdater =\n+            AtomicLongFieldUpdater.newUpdater(PublisherProcessor.class, \"pending\");\n+\n+    private final DelayedSubscription delayedSubscription;\n+    private final PublisherProcessorBuffer<T> buffer;\n+\n+    @Nullable\n+    private Throwable fatalError; // visible via emitting\n+    @Nullable\n+    private volatile BufferConsumer<T> consumer;\n+    @SuppressWarnings(\"unused\")\n+    private volatile int emitting;\n+    private volatile long pending;\n+\n+    PublisherProcessor(final PublisherProcessorBuffer<T> buffer) {\n+        this.buffer = requireNonNull(buffer);\n+        delayedSubscription = new DelayedSubscription();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        delayedSubscription.delayedSubscription(ConcurrentSubscription.wrap(subscription));\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        buffer.add(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        buffer.terminate(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        buffer.terminate();\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final DelayedSubscription delayedSubscription = new DelayedSubscription();\n+        try {\n+            subscriber.onSubscribe(delayedSubscription);\n+        } catch (Throwable t) {\n+            handleExceptionFromOnSubscribe(subscriber, t);\n+            return;\n+        }\n+\n+        if (consumerUpdater.compareAndSet(this, null, new SubscriberBufferConsumer<>(subscriber))) {\n+            delayedSubscription.delayedSubscription(this);\n+            tryEmitSignals();\n+        } else {\n+            BufferConsumer<? super T> existingConsumer = this.consumer;\n+            assert existingConsumer != null;\n+            @SuppressWarnings(\"unchecked\")\n+            final Subscriber<? super T> existingSubscriber = existingConsumer instanceof SubscriberBufferConsumer ?\n+                    ((SubscriberBufferConsumer<T>) existingConsumer).subscriber : null;\n+            safeOnError(subscriber, new DuplicateSubscribeException(existingSubscriber, subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> subscriber) {\n+        subscribeInternal(subscriber);\n+    }\n+\n+    @Override\n+    public void request(final long n) {\n+        if (!isRequestNValid(n)) {\n+            fatalError = newExceptionForInvalidRequestN(n);\n+        } else {\n+            pendingUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+            delayedSubscription.request(n);\n+        }\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        if (pendingUpdater.getAndSet(this, Long.MIN_VALUE) >= 0) {\n+            @SuppressWarnings(\"unchecked\")\n+            BufferConsumer<T> cancelled = CANCELLED;\n+            this.consumer = cancelled;\n+            delayedSubscription.cancel();\n+        }\n+    }\n+\n+    private void tryEmitSignals() {\n+        boolean lockReleased = false;\n+        while (!lockReleased && tryAcquireLock(emittingUpdater, this)) {\n+            final BufferConsumer<T> consumer = this.consumer;\n+            try {\n+                if (consumer instanceof SubscriberBufferConsumer) {\n+                    SubscriberBufferConsumer<T> target = (SubscriberBufferConsumer<T>) consumer;\n+                    if (fatalError != null) {\n+                        earlyTerminateConsumerHoldingLock(target, fatalError);\n+                        return;\n+                    } else {\n+                        emitSignalsHoldingLock(target);\n+                    }\n+                }\n+            } finally {\n+                lockReleased = releaseLock(emittingUpdater, this);\n+            }\n+        }\n+    }\n+\n+    private void emitSignalsHoldingLock(final SubscriberBufferConsumer<T> target) {\n+        for (;;) {\n+            final long cPending = pending;\n+            if (cPending > 0 && pendingUpdater.compareAndSet(this, cPending, cPending - 1)) {\n+                boolean consumed;\n+                try {\n+                    consumed = buffer.tryConsume(target);\n+                } catch (Throwable t) {\n+                    earlyTerminateConsumerHoldingLock(target, t);\n+                    return;\n+                }\n+\n+                if (target.isTerminated()) {\n+                    pendingUpdater.getAndSet(this, Long.MIN_VALUE);", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3MDUwMw==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420470503", "bodyText": "nit: make final to re-enforce it must be set once.", "author": "Scottmitch", "createdAt": "2020-05-05T23:39:33Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.api.ProcessorBuffer.BufferConsumer;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class PublisherProcessor<T> extends Publisher<T> implements Processor<T, T>, Subscription {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final BufferConsumer CANCELLED = new NoopBufferConsumer();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<PublisherProcessor, BufferConsumer> consumerUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(PublisherProcessor.class, BufferConsumer.class, \"consumer\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<PublisherProcessor> emittingUpdater =\n+            newUpdater(PublisherProcessor.class, \"emitting\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicLongFieldUpdater<PublisherProcessor> pendingUpdater =\n+            AtomicLongFieldUpdater.newUpdater(PublisherProcessor.class, \"pending\");\n+\n+    private final DelayedSubscription delayedSubscription;\n+    private final PublisherProcessorBuffer<T> buffer;\n+\n+    @Nullable\n+    private Throwable fatalError; // visible via emitting\n+    @Nullable\n+    private volatile BufferConsumer<T> consumer;\n+    @SuppressWarnings(\"unused\")\n+    private volatile int emitting;\n+    private volatile long pending;\n+\n+    PublisherProcessor(final PublisherProcessorBuffer<T> buffer) {\n+        this.buffer = requireNonNull(buffer);\n+        delayedSubscription = new DelayedSubscription();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        delayedSubscription.delayedSubscription(ConcurrentSubscription.wrap(subscription));\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        buffer.add(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        buffer.terminate(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        buffer.terminate();\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final DelayedSubscription delayedSubscription = new DelayedSubscription();\n+        try {\n+            subscriber.onSubscribe(delayedSubscription);\n+        } catch (Throwable t) {\n+            handleExceptionFromOnSubscribe(subscriber, t);\n+            return;\n+        }\n+\n+        if (consumerUpdater.compareAndSet(this, null, new SubscriberBufferConsumer<>(subscriber))) {\n+            delayedSubscription.delayedSubscription(this);\n+            tryEmitSignals();\n+        } else {\n+            BufferConsumer<? super T> existingConsumer = this.consumer;\n+            assert existingConsumer != null;\n+            @SuppressWarnings(\"unchecked\")\n+            final Subscriber<? super T> existingSubscriber = existingConsumer instanceof SubscriberBufferConsumer ?\n+                    ((SubscriberBufferConsumer<T>) existingConsumer).subscriber : null;\n+            safeOnError(subscriber, new DuplicateSubscribeException(existingSubscriber, subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> subscriber) {\n+        subscribeInternal(subscriber);\n+    }\n+\n+    @Override\n+    public void request(final long n) {\n+        if (!isRequestNValid(n)) {\n+            fatalError = newExceptionForInvalidRequestN(n);\n+        } else {\n+            pendingUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+            delayedSubscription.request(n);\n+        }\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        if (pendingUpdater.getAndSet(this, Long.MIN_VALUE) >= 0) {\n+            @SuppressWarnings(\"unchecked\")\n+            BufferConsumer<T> cancelled = CANCELLED;\n+            this.consumer = cancelled;\n+            delayedSubscription.cancel();\n+        }\n+    }\n+\n+    private void tryEmitSignals() {\n+        boolean lockReleased = false;\n+        while (!lockReleased && tryAcquireLock(emittingUpdater, this)) {\n+            final BufferConsumer<T> consumer = this.consumer;\n+            try {\n+                if (consumer instanceof SubscriberBufferConsumer) {\n+                    SubscriberBufferConsumer<T> target = (SubscriberBufferConsumer<T>) consumer;\n+                    if (fatalError != null) {\n+                        earlyTerminateConsumerHoldingLock(target, fatalError);\n+                        return;\n+                    } else {\n+                        emitSignalsHoldingLock(target);\n+                    }\n+                }\n+            } finally {\n+                lockReleased = releaseLock(emittingUpdater, this);\n+            }\n+        }\n+    }\n+\n+    private void emitSignalsHoldingLock(final SubscriberBufferConsumer<T> target) {\n+        for (;;) {\n+            final long cPending = pending;\n+            if (cPending > 0 && pendingUpdater.compareAndSet(this, cPending, cPending - 1)) {\n+                boolean consumed;", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3MjQ1OQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420472459", "bodyText": "what is the motivation for clearing out the consumer here? if subsequent signals come do we want/need to suppress them?", "author": "Scottmitch", "createdAt": "2020-05-05T23:45:53Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.api.ProcessorBuffer.BufferConsumer;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class PublisherProcessor<T> extends Publisher<T> implements Processor<T, T>, Subscription {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final BufferConsumer CANCELLED = new NoopBufferConsumer();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<PublisherProcessor, BufferConsumer> consumerUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(PublisherProcessor.class, BufferConsumer.class, \"consumer\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<PublisherProcessor> emittingUpdater =\n+            newUpdater(PublisherProcessor.class, \"emitting\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicLongFieldUpdater<PublisherProcessor> pendingUpdater =\n+            AtomicLongFieldUpdater.newUpdater(PublisherProcessor.class, \"pending\");\n+\n+    private final DelayedSubscription delayedSubscription;\n+    private final PublisherProcessorBuffer<T> buffer;\n+\n+    @Nullable\n+    private Throwable fatalError; // visible via emitting\n+    @Nullable\n+    private volatile BufferConsumer<T> consumer;\n+    @SuppressWarnings(\"unused\")\n+    private volatile int emitting;\n+    private volatile long pending;\n+\n+    PublisherProcessor(final PublisherProcessorBuffer<T> buffer) {\n+        this.buffer = requireNonNull(buffer);\n+        delayedSubscription = new DelayedSubscription();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        delayedSubscription.delayedSubscription(ConcurrentSubscription.wrap(subscription));\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        buffer.add(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        buffer.terminate(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        buffer.terminate();\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final DelayedSubscription delayedSubscription = new DelayedSubscription();\n+        try {\n+            subscriber.onSubscribe(delayedSubscription);\n+        } catch (Throwable t) {\n+            handleExceptionFromOnSubscribe(subscriber, t);\n+            return;\n+        }\n+\n+        if (consumerUpdater.compareAndSet(this, null, new SubscriberBufferConsumer<>(subscriber))) {\n+            delayedSubscription.delayedSubscription(this);\n+            tryEmitSignals();\n+        } else {\n+            BufferConsumer<? super T> existingConsumer = this.consumer;\n+            assert existingConsumer != null;\n+            @SuppressWarnings(\"unchecked\")\n+            final Subscriber<? super T> existingSubscriber = existingConsumer instanceof SubscriberBufferConsumer ?\n+                    ((SubscriberBufferConsumer<T>) existingConsumer).subscriber : null;\n+            safeOnError(subscriber, new DuplicateSubscribeException(existingSubscriber, subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> subscriber) {\n+        subscribeInternal(subscriber);\n+    }\n+\n+    @Override\n+    public void request(final long n) {\n+        if (!isRequestNValid(n)) {\n+            fatalError = newExceptionForInvalidRequestN(n);\n+        } else {\n+            pendingUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+            delayedSubscription.request(n);\n+        }\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        if (pendingUpdater.getAndSet(this, Long.MIN_VALUE) >= 0) {\n+            @SuppressWarnings(\"unchecked\")\n+            BufferConsumer<T> cancelled = CANCELLED;\n+            this.consumer = cancelled;", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE3MTMxMw==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421171313", "bodyText": "This is to follow spec rule 3.13", "author": "NiteshKant", "createdAt": "2020-05-07T00:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3MjQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5MTI2Ng==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421791266", "bodyText": "\ud83d\udc4d consider adding a comment to clarify.", "author": "Scottmitch", "createdAt": "2020-05-07T21:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3MjQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3ODk2MA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420478960", "bodyText": "consider using a \"safe\" variant to prevent duplicate termination of the subscriber in the event of exception (since it is terminated internally)", "author": "Scottmitch", "createdAt": "2020-05-06T00:07:35Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.api.ProcessorBuffer.BufferConsumer;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class PublisherProcessor<T> extends Publisher<T> implements Processor<T, T>, Subscription {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final BufferConsumer CANCELLED = new NoopBufferConsumer();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<PublisherProcessor, BufferConsumer> consumerUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(PublisherProcessor.class, BufferConsumer.class, \"consumer\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<PublisherProcessor> emittingUpdater =\n+            newUpdater(PublisherProcessor.class, \"emitting\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicLongFieldUpdater<PublisherProcessor> pendingUpdater =\n+            AtomicLongFieldUpdater.newUpdater(PublisherProcessor.class, \"pending\");\n+\n+    private final DelayedSubscription delayedSubscription;\n+    private final PublisherProcessorBuffer<T> buffer;\n+\n+    @Nullable\n+    private Throwable fatalError; // visible via emitting\n+    @Nullable\n+    private volatile BufferConsumer<T> consumer;\n+    @SuppressWarnings(\"unused\")\n+    private volatile int emitting;\n+    private volatile long pending;\n+\n+    PublisherProcessor(final PublisherProcessorBuffer<T> buffer) {\n+        this.buffer = requireNonNull(buffer);\n+        delayedSubscription = new DelayedSubscription();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        delayedSubscription.delayedSubscription(ConcurrentSubscription.wrap(subscription));\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        buffer.add(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        buffer.terminate(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        buffer.terminate();\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final DelayedSubscription delayedSubscription = new DelayedSubscription();\n+        try {\n+            subscriber.onSubscribe(delayedSubscription);\n+        } catch (Throwable t) {\n+            handleExceptionFromOnSubscribe(subscriber, t);\n+            return;\n+        }\n+\n+        if (consumerUpdater.compareAndSet(this, null, new SubscriberBufferConsumer<>(subscriber))) {\n+            delayedSubscription.delayedSubscription(this);\n+            tryEmitSignals();", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE3MDMxOA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421170318", "bodyText": "SubscriberBufferConsumer to which this method eventually delegates uses the safe variants, did I misunderstand your comment?", "author": "NiteshKant", "createdAt": "2020-05-07T00:32:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3ODk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4ODQzNw==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421788437", "bodyText": "here is a problematic call stack:\nsafeOnError(subscriber, cause) // in finally block\ndelayedSubscription.cancel() // may throw\nearlyTerminateConsumerHoldingLock(cause)\n[emitSignalsHoldingLock] // optional in stack\ntryEmitSignals\n\nin general the tryEmitSignals seems to own the responsibility to catch exceptions and recover. in this case (as opposed to other places where this method is called) if we let exceptions propagate we may introduce duplicate termination since the Publisher#handleSubscribe will catch the exception.", "author": "Scottmitch", "createdAt": "2020-05-07T20:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3ODk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4MjA2Mg==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420482062", "bodyText": "nit: reverse boolean logic is used elsewhere, consider making them consistent.\nhttps://github.com/apple/servicetalk/blob/master/servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SetDynamicCompositeCancellable.java#L94\n        boolean tryAcquire = true;\n        while (tryAcquire && tryAcquireLock(cancelAllLockUpdater, this)) {\n            try {\n            } finally {\n                tryAcquire = !releaseLock(cancelAllLockUpdater, this);\n            }\n        }", "author": "Scottmitch", "createdAt": "2020-05-06T00:18:39Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.api.ProcessorBuffer.BufferConsumer;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class PublisherProcessor<T> extends Publisher<T> implements Processor<T, T>, Subscription {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final BufferConsumer CANCELLED = new NoopBufferConsumer();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<PublisherProcessor, BufferConsumer> consumerUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(PublisherProcessor.class, BufferConsumer.class, \"consumer\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<PublisherProcessor> emittingUpdater =\n+            newUpdater(PublisherProcessor.class, \"emitting\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicLongFieldUpdater<PublisherProcessor> pendingUpdater =\n+            AtomicLongFieldUpdater.newUpdater(PublisherProcessor.class, \"pending\");\n+\n+    private final DelayedSubscription delayedSubscription;\n+    private final PublisherProcessorBuffer<T> buffer;\n+\n+    @Nullable\n+    private Throwable fatalError; // visible via emitting\n+    @Nullable\n+    private volatile BufferConsumer<T> consumer;\n+    @SuppressWarnings(\"unused\")\n+    private volatile int emitting;\n+    private volatile long pending;\n+\n+    PublisherProcessor(final PublisherProcessorBuffer<T> buffer) {\n+        this.buffer = requireNonNull(buffer);\n+        delayedSubscription = new DelayedSubscription();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        delayedSubscription.delayedSubscription(ConcurrentSubscription.wrap(subscription));\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        buffer.add(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        buffer.terminate(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        buffer.terminate();\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final DelayedSubscription delayedSubscription = new DelayedSubscription();\n+        try {\n+            subscriber.onSubscribe(delayedSubscription);\n+        } catch (Throwable t) {\n+            handleExceptionFromOnSubscribe(subscriber, t);\n+            return;\n+        }\n+\n+        if (consumerUpdater.compareAndSet(this, null, new SubscriberBufferConsumer<>(subscriber))) {\n+            delayedSubscription.delayedSubscription(this);\n+            tryEmitSignals();\n+        } else {\n+            BufferConsumer<? super T> existingConsumer = this.consumer;\n+            assert existingConsumer != null;\n+            @SuppressWarnings(\"unchecked\")\n+            final Subscriber<? super T> existingSubscriber = existingConsumer instanceof SubscriberBufferConsumer ?\n+                    ((SubscriberBufferConsumer<T>) existingConsumer).subscriber : null;\n+            safeOnError(subscriber, new DuplicateSubscribeException(existingSubscriber, subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> subscriber) {\n+        subscribeInternal(subscriber);\n+    }\n+\n+    @Override\n+    public void request(final long n) {\n+        if (!isRequestNValid(n)) {\n+            fatalError = newExceptionForInvalidRequestN(n);\n+        } else {\n+            pendingUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+            delayedSubscription.request(n);\n+        }\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        if (pendingUpdater.getAndSet(this, Long.MIN_VALUE) >= 0) {\n+            @SuppressWarnings(\"unchecked\")\n+            BufferConsumer<T> cancelled = CANCELLED;\n+            this.consumer = cancelled;\n+            delayedSubscription.cancel();\n+        }\n+    }\n+\n+    private void tryEmitSignals() {\n+        boolean lockReleased = false;", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjY2MA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420486660", "bodyText": "this maybe called from the thread invoking the Subscription (e.g. caller of request(n)). should we clarify that if this method shouldn't throw, but if it does it is assumed to have already terminated the target? and add a comment here that we can't do anything besides set our state to terminated.", "author": "Scottmitch", "createdAt": "2020-05-06T00:35:33Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.api.ProcessorBuffer.BufferConsumer;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class PublisherProcessor<T> extends Publisher<T> implements Processor<T, T>, Subscription {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final BufferConsumer CANCELLED = new NoopBufferConsumer();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<PublisherProcessor, BufferConsumer> consumerUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(PublisherProcessor.class, BufferConsumer.class, \"consumer\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<PublisherProcessor> emittingUpdater =\n+            newUpdater(PublisherProcessor.class, \"emitting\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicLongFieldUpdater<PublisherProcessor> pendingUpdater =\n+            AtomicLongFieldUpdater.newUpdater(PublisherProcessor.class, \"pending\");\n+\n+    private final DelayedSubscription delayedSubscription;\n+    private final PublisherProcessorBuffer<T> buffer;\n+\n+    @Nullable\n+    private Throwable fatalError; // visible via emitting\n+    @Nullable\n+    private volatile BufferConsumer<T> consumer;\n+    @SuppressWarnings(\"unused\")\n+    private volatile int emitting;\n+    private volatile long pending;\n+\n+    PublisherProcessor(final PublisherProcessorBuffer<T> buffer) {\n+        this.buffer = requireNonNull(buffer);\n+        delayedSubscription = new DelayedSubscription();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        delayedSubscription.delayedSubscription(ConcurrentSubscription.wrap(subscription));\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        buffer.add(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        buffer.terminate(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        buffer.terminate();\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final DelayedSubscription delayedSubscription = new DelayedSubscription();\n+        try {\n+            subscriber.onSubscribe(delayedSubscription);\n+        } catch (Throwable t) {\n+            handleExceptionFromOnSubscribe(subscriber, t);\n+            return;\n+        }\n+\n+        if (consumerUpdater.compareAndSet(this, null, new SubscriberBufferConsumer<>(subscriber))) {\n+            delayedSubscription.delayedSubscription(this);\n+            tryEmitSignals();\n+        } else {\n+            BufferConsumer<? super T> existingConsumer = this.consumer;\n+            assert existingConsumer != null;\n+            @SuppressWarnings(\"unchecked\")\n+            final Subscriber<? super T> existingSubscriber = existingConsumer instanceof SubscriberBufferConsumer ?\n+                    ((SubscriberBufferConsumer<T>) existingConsumer).subscriber : null;\n+            safeOnError(subscriber, new DuplicateSubscribeException(existingSubscriber, subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> subscriber) {\n+        subscribeInternal(subscriber);\n+    }\n+\n+    @Override\n+    public void request(final long n) {\n+        if (!isRequestNValid(n)) {\n+            fatalError = newExceptionForInvalidRequestN(n);\n+        } else {\n+            pendingUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+            delayedSubscription.request(n);\n+        }\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        if (pendingUpdater.getAndSet(this, Long.MIN_VALUE) >= 0) {\n+            @SuppressWarnings(\"unchecked\")\n+            BufferConsumer<T> cancelled = CANCELLED;\n+            this.consumer = cancelled;\n+            delayedSubscription.cancel();\n+        }\n+    }\n+\n+    private void tryEmitSignals() {\n+        boolean lockReleased = false;\n+        while (!lockReleased && tryAcquireLock(emittingUpdater, this)) {\n+            final BufferConsumer<T> consumer = this.consumer;\n+            try {\n+                if (consumer instanceof SubscriberBufferConsumer) {\n+                    SubscriberBufferConsumer<T> target = (SubscriberBufferConsumer<T>) consumer;\n+                    if (fatalError != null) {\n+                        earlyTerminateConsumerHoldingLock(target, fatalError);\n+                        return;\n+                    } else {\n+                        emitSignalsHoldingLock(target);\n+                    }\n+                }\n+            } finally {\n+                lockReleased = releaseLock(emittingUpdater, this);\n+            }\n+        }\n+    }\n+\n+    private void emitSignalsHoldingLock(final SubscriberBufferConsumer<T> target) {\n+        for (;;) {\n+            final long cPending = pending;\n+            if (cPending > 0 && pendingUpdater.compareAndSet(this, cPending, cPending - 1)) {\n+                boolean consumed;\n+                try {\n+                    consumed = buffer.tryConsume(target);\n+                } catch (Throwable t) {\n+                    earlyTerminateConsumerHoldingLock(target, t);\n+                    return;\n+                }\n+\n+                if (target.isTerminated()) {\n+                    pendingUpdater.getAndSet(this, Long.MIN_VALUE);\n+                } else if (!consumed) {\n+                    // we optimistically decremented pending, so increment back again.\n+                    pendingUpdater.accumulateAndGet(this, 1,\n+                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+                    return;\n+                }\n+            } else if (cPending < 0) {\n+                // cancelled or already terminated\n+                return;\n+            } else if (cPending == 0) {\n+                if (buffer.tryConsumeTerminal(target)) {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4Mjk3OQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421182979", "bodyText": "Good point, I will add a try-catch and assume terminal isn't consumed.", "author": "NiteshKant", "createdAt": "2020-05-07T01:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4NjY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ4OTcwNQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420489705", "bodyText": "The javadoc says:\n\nThis method will block till an item or a terminal event is available in the buffer.\n\nshould this method use take() instead of poll()?\n        final Object next = signals.take(); // todo: handle InterruptedException\n        return consumeIfTerminal(consumer, next) || consumeNextItem(consumer, next);", "author": "Scottmitch", "createdAt": "2020-05-06T00:47:42Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/DefaultBlockingProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+\n+final class DefaultBlockingProcessorBuffer<T> extends AbstractProcessorBuffer<T> implements BlockingProcessorBuffer<T> {\n+    private final BlockingQueue<Object> signals;\n+\n+    DefaultBlockingProcessorBuffer(final int maxBuffer) {\n+        this.signals = new LinkedBlockingQueue<>(maxBuffer);\n+    }\n+\n+    @Override\n+    protected void addItem(final Object item) {\n+        putSignal(item);\n+    }\n+\n+    @Override\n+    protected void addTerminal(final TerminalNotification terminalNotification) {\n+        putSignal(terminalNotification);\n+    }\n+\n+    @Override\n+    public boolean consume(final BufferConsumer<T> consumer) {\n+        if (consumeIfTerminal(consumer, signals.peek())) {", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MDQ2Mg==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420490462", "bodyText": "IIUC there was a desire to support multi-threaded producing, but the PublisherSource.Processor API is SPSC by definition in the ReactiveStreams specification. If the intention is for the return value to always be MP safe, should we clarify this in the API (javadoc, method name, ..)?", "author": "Scottmitch", "createdAt": "2020-05-06T00:50:36Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Processors.java", "diffHunk": "@@ -52,14 +53,42 @@ private Processors() {\n         return new SingleProcessor<>();\n     }\n \n+    /**\n+     * Create a new {@link PublisherSource.Processor} that allows for a single\n+     * {@link PublisherSource.Subscriber#subscribe(PublisherSource.Subscriber) subscribe}.\n+     *\n+     * @param <T> The {@link PublisherSource} type and {@link PublisherSource.Subscriber} type of the\n+     * {@link PublisherSource.Processor}.\n+     * @return a new {@link PublisherSource.Processor} that allows for a single", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA3MjE4Mg==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421072182", "bodyText": "None of the producing side of these processors in this interface are expected to follow reactive streams specifications, eg: Single and Completable processors above do not expect to onSubscribe() call today and termination can be called multiple times. Let me add this clarification to all methods.", "author": "NiteshKant", "createdAt": "2020-05-06T20:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MDQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MzcwNQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r420493705", "bodyText": "throwException casting to a boolean doesn't look right, despite the return not being expected. Consider refactoring for clarity:\nThrowable cause = terminal.cause();\nif (cause != null) {\n  throwException(cause);\n}\nreturn false;", "author": "Scottmitch", "createdAt": "2020-05-06T01:03:25Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/DefaultBlockingIterableProcessor.java", "diffHunk": "@@ -144,43 +120,33 @@ public boolean hasNext() {\n                 return true;\n             }\n \n-            final Object next;\n+            final boolean consumed;\n             try {\n-                next = buffer.take();\n+                consumed = buffer.consume(this);\n             } catch (InterruptedException e) {\n                 return throwException(e);\n             }\n-            return processHasNext(next);\n+            return terminal == null ? consumed : hasNextWhenTerminated();\n         }\n \n-        @Nullable\n-        private T processNext() {\n-            Object next = this.next;\n-            this.next = null;\n-            if (next == NULL_MASK) {\n-                return null;\n-            } else {\n-                @SuppressWarnings(\"unchecked\")\n-                T t = (T) next;\n-                return t;\n-            }\n+        private boolean hasNextWhenTerminated() {\n+            assert terminal != null;\n+            return terminal.cause() != null && (boolean) throwException(terminal.cause());", "originalCommit": "582040f1697dff5e00d9ed20fc91dd5bfb835dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4278eee5b442e57175eed8bc56c386105c1c6318", "url": "https://github.com/apple/servicetalk/commit/4278eee5b442e57175eed8bc56c386105c1c6318", "message": "Review comments", "committedDate": "2020-05-07T02:06:56Z", "type": "commit"}, {"oid": "a58cf3e762140a0614304c030db189cfbc95d6a4", "url": "https://github.com/apple/servicetalk/commit/a58cf3e762140a0614304c030db189cfbc95d6a4", "message": "Merge remote-tracking branch 'upstream/master' into processors", "committedDate": "2020-05-07T02:06:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM0NjI4NQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421346285", "bodyText": "nit: you could merge the both lines above. That said feel free to ignore", "author": "normanmaurer", "createdAt": "2020-05-07T08:54:34Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer {\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    final boolean tryTerminate(final TerminalNotification notification) {\n+        return terminalUpdater.compareAndSet(this, null, notification);\n+    }\n+\n+    static <T> Object maskNull(@Nullable final T item) {\n+        return item == null ? NULL_ITEM : item;\n+    }\n+\n+    /**\n+     * Invokes {@link BufferConsumer#consumeTerminal(Throwable)} if the the passed {@code signal} is a\n+     * {@link TerminalNotification} representing an error termination. Invokes\n+     * {@link BufferConsumer#consumeTerminal()} if the the passed {@code signal} is a {@link TerminalNotification}\n+     * representing a successful termination. If the passed {@code signal} is not a {@link TerminalNotification} then\n+     * does nothing.\n+     *\n+     * @param consumer {@link BufferConsumer} to consume the terminal.\n+     * @param signal which may be a {@link TerminalNotification}.\n+     * @return {@code true} if any method was invoked on the passed {@link BufferConsumer}.\n+     */\n+    static boolean consumeIfTerminal(final BufferConsumer<?> consumer, @Nullable final Object signal) {\n+        if (signal instanceof TerminalNotification) {\n+            TerminalNotification terminalNotification = (TerminalNotification) signal;\n+            Throwable cause = terminalNotification.cause();", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM0NjYzMQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421346631", "bodyText": "s/the the/the/", "author": "normanmaurer", "createdAt": "2020-05-07T08:54:59Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer {\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    final boolean tryTerminate(final TerminalNotification notification) {\n+        return terminalUpdater.compareAndSet(this, null, notification);\n+    }\n+\n+    static <T> Object maskNull(@Nullable final T item) {\n+        return item == null ? NULL_ITEM : item;\n+    }\n+\n+    /**\n+     * Invokes {@link BufferConsumer#consumeTerminal(Throwable)} if the the passed {@code signal} is a", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM0Njc5MA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421346790", "bodyText": "s/the the/the/", "author": "normanmaurer", "createdAt": "2020-05-07T08:55:15Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer {\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    final boolean tryTerminate(final TerminalNotification notification) {\n+        return terminalUpdater.compareAndSet(this, null, notification);\n+    }\n+\n+    static <T> Object maskNull(@Nullable final T item) {\n+        return item == null ? NULL_ITEM : item;\n+    }\n+\n+    /**\n+     * Invokes {@link BufferConsumer#consumeTerminal(Throwable)} if the the passed {@code signal} is a\n+     * {@link TerminalNotification} representing an error termination. Invokes\n+     * {@link BufferConsumer#consumeTerminal()} if the the passed {@code signal} is a {@link TerminalNotification}", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM0NzI0OQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421347249", "bodyText": "consider adding an unmaskNull method (put it close to maskNull) and use this method here. This will ensure we keep the logic in one place and make it easier to maintain", "author": "normanmaurer", "createdAt": "2020-05-07T08:56:00Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+abstract class AbstractProcessorBuffer {\n+    private static final AtomicReferenceFieldUpdater<AbstractProcessorBuffer,\n+            TerminalNotification> terminalUpdater = newUpdater(AbstractProcessorBuffer.class,\n+            TerminalNotification.class, \"terminal\");\n+    private static final Object NULL_ITEM = new Object();\n+\n+    @Nullable\n+    private volatile TerminalNotification terminal;\n+\n+    final boolean tryTerminate(final TerminalNotification notification) {\n+        return terminalUpdater.compareAndSet(this, null, notification);\n+    }\n+\n+    static <T> Object maskNull(@Nullable final T item) {\n+        return item == null ? NULL_ITEM : item;\n+    }\n+\n+    /**\n+     * Invokes {@link BufferConsumer#consumeTerminal(Throwable)} if the the passed {@code signal} is a\n+     * {@link TerminalNotification} representing an error termination. Invokes\n+     * {@link BufferConsumer#consumeTerminal()} if the the passed {@code signal} is a {@link TerminalNotification}\n+     * representing a successful termination. If the passed {@code signal} is not a {@link TerminalNotification} then\n+     * does nothing.\n+     *\n+     * @param consumer {@link BufferConsumer} to consume the terminal.\n+     * @param signal which may be a {@link TerminalNotification}.\n+     * @return {@code true} if any method was invoked on the passed {@link BufferConsumer}.\n+     */\n+    static boolean consumeIfTerminal(final BufferConsumer<?> consumer, @Nullable final Object signal) {\n+        if (signal instanceof TerminalNotification) {\n+            TerminalNotification terminalNotification = (TerminalNotification) signal;\n+            Throwable cause = terminalNotification.cause();\n+            if (cause != null) {\n+                consumer.consumeTerminal(cause);\n+            } else {\n+                consumer.consumeTerminal();\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Invokes {@link BufferConsumer#consumeItem(Object)} if the the passed {@code signal} is not {@code null}.\n+     *\n+     * @param consumer {@link BufferConsumer} to consume the item.\n+     * @param nextItem which either can be {@code null} or an item of type {@link T}.\n+     * @param <T> Type of items consumed by {@link BufferConsumer}.\n+     * @return {@code true} if any method was invoked on the passed {@link BufferConsumer}.\n+     */\n+    static <T> boolean consumeNextItem(final BufferConsumer<T> consumer, @Nullable final Object nextItem) {\n+        if (nextItem == null) {\n+            return false;\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        T t = nextItem == NULL_ITEM ? null : (T) nextItem;", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM0OTc0NA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421349744", "bodyText": "nit: move the call to maskNull(item) out of the if / else block to simplify. It is done in both cases anyway.", "author": "normanmaurer", "createdAt": "2020-05-07T08:59:53Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AbstractPublisherProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+abstract class AbstractPublisherProcessorBuffer<T, Q extends Queue<Object>> extends AbstractProcessorBuffer\n+        implements PublisherProcessorBuffer<T> {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<AbstractPublisherProcessorBuffer> bufferedUpdater =\n+            newUpdater(AbstractPublisherProcessorBuffer.class, \"buffered\");\n+\n+    private final int maxBuffer;\n+    private final Q signals;\n+\n+    private volatile int buffered;\n+\n+    AbstractPublisherProcessorBuffer(final int maxBuffer, final Q signals) {\n+        if (maxBuffer <= 0) {\n+            throw new IllegalArgumentException(\"maxBuffer: \" + maxBuffer + \" (expected > 0)\");\n+        }\n+        this.maxBuffer = maxBuffer;\n+        this.signals = requireNonNull(signals);\n+    }\n+\n+    @Override\n+    public void add(@Nullable final T item) {\n+        if (bufferedUpdater.getAndAccumulate(this, 1,\n+                (prev, next) -> prev == maxBuffer ? maxBuffer : (prev + next)) == maxBuffer) {\n+            offerPastBufferSize(maskNull(item), signals);", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMTM5Mw==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421831393", "bodyText": "We have been preferring inlining such calls as opposed to storing it in a local field.", "author": "NiteshKant", "createdAt": "2020-05-07T22:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM0OTc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDY2Ng==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421350666", "bodyText": "maybe clarify what will happen if you try to call add(...) after it (maybe throwing).", "author": "normanmaurer", "createdAt": "2020-05-07T09:01:22Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BlockingProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.BlockingIterable.Processor;\n+\n+/**\n+ * A buffer to store items for a {@link Processor}.\n+ *\n+ * @param <T>  Type of items stored in this buffer.\n+ */\n+public interface BlockingProcessorBuffer<T> {\n+\n+    /**\n+     * Adds an item to this buffer.\n+     *\n+     * @param item to add.\n+     * @throws InterruptedException If the add was interrupted.\n+     */\n+    void add(@Nullable T item) throws InterruptedException;\n+\n+    /**\n+     * Terminates this buffer, such that no further modifications of this buffer are allowed. Subsequent", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMTc3NQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421831775", "bodyText": "actually we are not enforcing this now, so lemme change allowed => expected", "author": "NiteshKant", "createdAt": "2020-05-07T22:30:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MDY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MTI5OA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421351298", "bodyText": "is this really true ? Like will it also return true if consume was called ?", "author": "normanmaurer", "createdAt": "2020-05-07T09:02:30Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BlockingProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.BlockingIterable.Processor;\n+\n+/**\n+ * A buffer to store items for a {@link Processor}.\n+ *\n+ * @param <T>  Type of items stored in this buffer.\n+ */\n+public interface BlockingProcessorBuffer<T> {\n+\n+    /**\n+     * Adds an item to this buffer.\n+     *\n+     * @param item to add.\n+     * @throws InterruptedException If the add was interrupted.\n+     */\n+    void add(@Nullable T item) throws InterruptedException;\n+\n+    /**\n+     * Terminates this buffer, such that no further modifications of this buffer are allowed. Subsequent\n+     * {@link BufferConsumer consumptions} must first consume all previously {@link #add(Object) added} items and then\n+     * {@link BufferConsumer#consumeTerminal()}  consume termination}.\n+     * @throws InterruptedException If termination was interrupted.\n+     */\n+    void terminate() throws InterruptedException;\n+\n+    /**\n+     * Terminates this buffer, such that no further modifications of this buffer are allowed. Subsequent\n+     * {@link BufferConsumer consumptions} must first consume all previously {@link #add(Object) added} items and then\n+     * {@link BufferConsumer#consumeTerminal()}  consume termination}.\n+     *\n+     * @param cause {@link Throwable} as a cause for termination.\n+     * @throws InterruptedException If termination was interrupted.\n+     */\n+    void terminate(Throwable cause) throws InterruptedException;\n+\n+    /**\n+     * Consumes the next item stored in this buffer. If there are no items stored in the buffer and the buffer has\n+     * terminated {@link #terminate() successfully} or with an {@link #terminate(Throwable) error} then consume that\n+     * {@link BufferConsumer#consumeTerminal() successful} or {@link BufferConsumer#consumeTerminal(Throwable) failed}\n+     * termination.\n+     * <p>\n+     * This method will block till an item or a terminal event is available in the buffer.\n+     *\n+     * @param consumer {@link BufferConsumer} to consume the next item or termination in this buffer\n+     * @return {@code true} if any method was called on the passed {@link BufferConsumer}.\n+     * @throws InterruptedException If the thread was interrupted while waiting for an item or terminal event.\n+     */\n+    boolean consume(BufferConsumer<T> consumer) throws InterruptedException;\n+\n+    /**\n+     * Consumes the next item stored in this buffer. If there are no items stored in the buffer and the buffer has\n+     * terminated {@link #terminate() successfully} or with an {@link #terminate(Throwable) error} then consume that\n+     * {@link BufferConsumer#consumeTerminal() successful} or {@link BufferConsumer#consumeTerminal(Throwable) failed}\n+     * termination.\n+     * <p>\n+     * This method will block till an item or a terminal event is available in the buffer or the passed {@code waitFor}\n+     * duration has elapsed.\n+     *\n+     * @param consumer {@link BufferConsumer} to consume the next item or termination in this buffer\n+     * @param waitFor Duration to wait for an item or termination to be available.\n+     * @param waitForUnit {@link TimeUnit} for {@code waitFor}.\n+     * @return {@code true} if any method was called on the passed {@link BufferConsumer}.", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzMzM5OA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421833398", "bodyText": "Yes that is correct. Return value is indicating whether an item or terminal was consumed.", "author": "NiteshKant", "createdAt": "2020-05-07T22:36:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MTI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MjY4MA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421352680", "bodyText": "these 3 lines of code are the same as the change of line 92... Consider sharing the code via a private method:\nprivate T consumeNext() {\n    T next = this.next;\n    this.next = null;\n    return null;\n}", "author": "normanmaurer", "createdAt": "2020-05-07T09:04:50Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/DefaultBlockingIterableProcessor.java", "diffHunk": "@@ -127,7 +100,9 @@ public T next() {\n             if (!hasNext()) {\n                 throw new NoSuchElementException();\n             }\n-            return processNext();\n+            T next = this.next;\n+            this.next = null;\n+            return next;", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1Nzk2MA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421357960", "bodyText": "nit: this is the same as line 83. Maybe share ?", "author": "normanmaurer", "createdAt": "2020-05-07T09:13:24Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/DefaultBlockingIterableProcessor.java", "diffHunk": "@@ -144,43 +119,37 @@ public boolean hasNext() {\n                 return true;\n             }\n \n-            final Object next;\n+            final boolean consumed;\n             try {\n-                next = buffer.take();\n+                consumed = buffer.consume(this);\n             } catch (InterruptedException e) {\n                 return throwException(e);\n             }\n-            return processHasNext(next);\n+            return terminal == null ? consumed : hasNextWhenTerminated();", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzNDYxNQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421834615", "bodyText": "mmm .. its a one-liner which uses a method anyways. I will avoid creating a method for it", "author": "NiteshKant", "createdAt": "2020-05-07T22:39:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1Nzk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1ODM3NQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421358375", "bodyText": "how is the boolean useful here ? This always returns false....", "author": "normanmaurer", "createdAt": "2020-05-07T09:14:02Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/DefaultBlockingIterableProcessor.java", "diffHunk": "@@ -144,43 +119,37 @@ public boolean hasNext() {\n                 return true;\n             }\n \n-            final Object next;\n+            final boolean consumed;\n             try {\n-                next = buffer.take();\n+                consumed = buffer.consume(this);\n             } catch (InterruptedException e) {\n                 return throwException(e);\n             }\n-            return processHasNext(next);\n+            return terminal == null ? consumed : hasNextWhenTerminated();\n         }\n \n-        @Nullable\n-        private T processNext() {\n-            Object next = this.next;\n-            this.next = null;\n-            if (next == NULL_MASK) {\n-                return null;\n-            } else {\n-                @SuppressWarnings(\"unchecked\")\n-                T t = (T) next;\n-                return t;\n+        private boolean hasNextWhenTerminated() {", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzNTM0MQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421835341", "bodyText": "It just make it easy to use in hasNext():\nreturn hasNextWhenTerminated()\ninstead of\nhasNextWhenTerminated();\nreturn false;", "author": "NiteshKant", "createdAt": "2020-05-07T22:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1ODM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1OTg3Ng==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421359876", "bodyText": "isn't this racy? Two threads could pass the peek() above as the first item at the time of the call is not a terminal but after the first calls poll() the next would be one", "author": "normanmaurer", "createdAt": "2020-05-07T09:16:23Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/DefaultBlockingProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+\n+final class DefaultBlockingProcessorBuffer<T> extends AbstractProcessorBuffer implements BlockingProcessorBuffer<T> {\n+    private final BlockingQueue<Object> signals;\n+\n+    DefaultBlockingProcessorBuffer(final int maxBuffer) {\n+        this.signals = new LinkedBlockingQueue<>(maxBuffer);\n+    }\n+\n+    @Override\n+    public void add(@Nullable final T item) throws InterruptedException {\n+        signals.put(maskNull(item));\n+    }\n+\n+    @Override\n+    public void terminate() throws InterruptedException {\n+        TerminalNotification terminal = complete();\n+        if (tryTerminate(terminal)) {\n+            signals.put(terminal);\n+        }\n+    }\n+\n+    @Override\n+    public void terminate(final Throwable cause) throws InterruptedException {\n+        TerminalNotification terminal = error(cause);\n+        if (tryTerminate(terminal)) {\n+            signals.put(terminal);\n+        }\n+    }\n+\n+    @Override\n+    public boolean consume(final BufferConsumer<T> consumer) throws InterruptedException {\n+        Object signal = signals.take();\n+        return consumeIfTerminal(consumer, signal) || consumeNextItem(consumer, signal);\n+    }\n+\n+    @Override\n+    public boolean consume(final BufferConsumer<T> consumer, final long waitFor, final TimeUnit waitForUnit)\n+            throws TimeoutException, InterruptedException {\n+        if (consumeIfTerminal(consumer, signals.peek())) {\n+            return true;\n+        }\n+\n+        Object nextItem = signals.poll(waitFor, waitForUnit);", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzNjgwOQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421836809", "bodyText": "yikes, good catch. Lemme make this consistent with the above consume method.", "author": "NiteshKant", "createdAt": "2020-05-07T22:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1OTg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2MzU1OQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421363559", "bodyText": "nit: use return to be consistent.", "author": "normanmaurer", "createdAt": "2020-05-07T09:22:17Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class PublisherProcessor<T> extends Publisher<T> implements Processor<T, T>, Subscription {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final BufferConsumer CANCELLED = new NoopBufferConsumer();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<PublisherProcessor, BufferConsumer> consumerUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(PublisherProcessor.class, BufferConsumer.class, \"consumer\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<PublisherProcessor> emittingUpdater =\n+            newUpdater(PublisherProcessor.class, \"emitting\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicLongFieldUpdater<PublisherProcessor> pendingUpdater =\n+            AtomicLongFieldUpdater.newUpdater(PublisherProcessor.class, \"pending\");\n+\n+    private final DelayedSubscription delayedSubscription;\n+    private final PublisherProcessorBuffer<T> buffer;\n+\n+    @Nullable\n+    private Throwable fatalError; // visible via emitting\n+    @Nullable\n+    private volatile BufferConsumer<T> consumer;\n+    @SuppressWarnings(\"unused\")\n+    private volatile int emitting;\n+    private volatile long pending;\n+\n+    PublisherProcessor(final PublisherProcessorBuffer<T> buffer) {\n+        this.buffer = requireNonNull(buffer);\n+        delayedSubscription = new DelayedSubscription();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        delayedSubscription.delayedSubscription(ConcurrentSubscription.wrap(subscription));\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        buffer.add(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        buffer.terminate(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        buffer.terminate();\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final DelayedSubscription delayedSubscription = new DelayedSubscription();\n+        try {\n+            subscriber.onSubscribe(delayedSubscription);\n+        } catch (Throwable t) {\n+            handleExceptionFromOnSubscribe(subscriber, t);\n+            return;\n+        }\n+\n+        if (consumerUpdater.compareAndSet(this, null, new SubscriberBufferConsumer<>(subscriber))) {\n+            delayedSubscription.delayedSubscription(this);\n+            tryEmitSignals();\n+        } else {\n+            BufferConsumer<? super T> existingConsumer = this.consumer;\n+            assert existingConsumer != null;\n+            @SuppressWarnings(\"unchecked\")\n+            final Subscriber<? super T> existingSubscriber = existingConsumer instanceof SubscriberBufferConsumer ?\n+                    ((SubscriberBufferConsumer<T>) existingConsumer).subscriber : null;\n+            safeOnError(subscriber, new DuplicateSubscribeException(existingSubscriber, subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> subscriber) {\n+        subscribeInternal(subscriber);\n+    }\n+\n+    @Override\n+    public void request(final long n) {\n+        if (!isRequestNValid(n)) {\n+            fatalError = newExceptionForInvalidRequestN(n);\n+        } else {\n+            pendingUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+            delayedSubscription.request(n);\n+        }\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        if (pendingUpdater.getAndSet(this, Long.MIN_VALUE) >= 0) {\n+            @SuppressWarnings(\"unchecked\")\n+            BufferConsumer<T> cancelled = CANCELLED;\n+            this.consumer = cancelled;\n+            delayedSubscription.cancel();\n+        }\n+    }\n+\n+    private void tryEmitSignals() {\n+        boolean tryAcquire = true;\n+        while (tryAcquire && tryAcquireLock(emittingUpdater, this)) {\n+            final BufferConsumer<T> consumer = this.consumer;\n+            try {\n+                if (consumer instanceof SubscriberBufferConsumer) {\n+                    SubscriberBufferConsumer<T> target = (SubscriberBufferConsumer<T>) consumer;\n+                    if (fatalError != null) {\n+                        earlyTerminateConsumerHoldingLock(target, fatalError);\n+                        return;\n+                    } else {\n+                        emitSignalsHoldingLock(target);\n+                    }\n+                }\n+            } finally {\n+                tryAcquire = !releaseLock(emittingUpdater, this);\n+            }\n+        }\n+    }\n+\n+    private void emitSignalsHoldingLock(final SubscriberBufferConsumer<T> target) {\n+        for (;;) {\n+            final long cPending = pending;\n+            if (cPending > 0 && pendingUpdater.compareAndSet(this, cPending, cPending - 1)) {\n+                final boolean consumed;\n+                try {\n+                    consumed = buffer.tryConsume(target);\n+                } catch (Throwable t) {\n+                    earlyTerminateConsumerHoldingLock(target, t);\n+                    return;\n+                }\n+\n+                if (target.isTerminated()) {\n+                    pending = Long.MIN_VALUE;\n+                } else if (!consumed) {\n+                    // we optimistically decremented pending, so increment back again.\n+                    pendingUpdater.accumulateAndGet(this, 1,\n+                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+                    return;\n+                }\n+            } else if (cPending < 0) {\n+                // cancelled or already terminated\n+                return;\n+            } else if (cPending == 0) {\n+                final boolean consumed;\n+                try {\n+                    consumed = buffer.tryConsumeTerminal(target);\n+                } catch (Throwable t) {\n+                    // Assume that we did not deliver terminal to the consumer.\n+                    earlyTerminateConsumerHoldingLock(target, t);\n+                    return;\n+                }\n+                if (consumed) {\n+                    pending = Long.MIN_VALUE;\n+                    return;\n+                }\n+                break;", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTYzNw==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421365637", "bodyText": "does this need to be volatile ?", "author": "normanmaurer", "createdAt": "2020-05-07T09:25:31Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class PublisherProcessor<T> extends Publisher<T> implements Processor<T, T>, Subscription {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final BufferConsumer CANCELLED = new NoopBufferConsumer();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<PublisherProcessor, BufferConsumer> consumerUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(PublisherProcessor.class, BufferConsumer.class, \"consumer\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<PublisherProcessor> emittingUpdater =\n+            newUpdater(PublisherProcessor.class, \"emitting\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicLongFieldUpdater<PublisherProcessor> pendingUpdater =\n+            AtomicLongFieldUpdater.newUpdater(PublisherProcessor.class, \"pending\");\n+\n+    private final DelayedSubscription delayedSubscription;\n+    private final PublisherProcessorBuffer<T> buffer;\n+\n+    @Nullable\n+    private Throwable fatalError; // visible via emitting\n+    @Nullable\n+    private volatile BufferConsumer<T> consumer;\n+    @SuppressWarnings(\"unused\")\n+    private volatile int emitting;\n+    private volatile long pending;\n+\n+    PublisherProcessor(final PublisherProcessorBuffer<T> buffer) {\n+        this.buffer = requireNonNull(buffer);\n+        delayedSubscription = new DelayedSubscription();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        delayedSubscription.delayedSubscription(ConcurrentSubscription.wrap(subscription));\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        buffer.add(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        buffer.terminate(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        buffer.terminate();\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final DelayedSubscription delayedSubscription = new DelayedSubscription();\n+        try {\n+            subscriber.onSubscribe(delayedSubscription);\n+        } catch (Throwable t) {\n+            handleExceptionFromOnSubscribe(subscriber, t);\n+            return;\n+        }\n+\n+        if (consumerUpdater.compareAndSet(this, null, new SubscriberBufferConsumer<>(subscriber))) {\n+            delayedSubscription.delayedSubscription(this);\n+            tryEmitSignals();\n+        } else {\n+            BufferConsumer<? super T> existingConsumer = this.consumer;\n+            assert existingConsumer != null;\n+            @SuppressWarnings(\"unchecked\")\n+            final Subscriber<? super T> existingSubscriber = existingConsumer instanceof SubscriberBufferConsumer ?\n+                    ((SubscriberBufferConsumer<T>) existingConsumer).subscriber : null;\n+            safeOnError(subscriber, new DuplicateSubscribeException(existingSubscriber, subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> subscriber) {\n+        subscribeInternal(subscriber);\n+    }\n+\n+    @Override\n+    public void request(final long n) {\n+        if (!isRequestNValid(n)) {\n+            fatalError = newExceptionForInvalidRequestN(n);\n+        } else {\n+            pendingUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+            delayedSubscription.request(n);\n+        }\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        if (pendingUpdater.getAndSet(this, Long.MIN_VALUE) >= 0) {\n+            @SuppressWarnings(\"unchecked\")\n+            BufferConsumer<T> cancelled = CANCELLED;\n+            this.consumer = cancelled;\n+            delayedSubscription.cancel();\n+        }\n+    }\n+\n+    private void tryEmitSignals() {\n+        boolean tryAcquire = true;\n+        while (tryAcquire && tryAcquireLock(emittingUpdater, this)) {\n+            final BufferConsumer<T> consumer = this.consumer;\n+            try {\n+                if (consumer instanceof SubscriberBufferConsumer) {\n+                    SubscriberBufferConsumer<T> target = (SubscriberBufferConsumer<T>) consumer;\n+                    if (fatalError != null) {\n+                        earlyTerminateConsumerHoldingLock(target, fatalError);\n+                        return;\n+                    } else {\n+                        emitSignalsHoldingLock(target);\n+                    }\n+                }\n+            } finally {\n+                tryAcquire = !releaseLock(emittingUpdater, this);\n+            }\n+        }\n+    }\n+\n+    private void emitSignalsHoldingLock(final SubscriberBufferConsumer<T> target) {\n+        for (;;) {\n+            final long cPending = pending;\n+            if (cPending > 0 && pendingUpdater.compareAndSet(this, cPending, cPending - 1)) {\n+                final boolean consumed;\n+                try {\n+                    consumed = buffer.tryConsume(target);\n+                } catch (Throwable t) {\n+                    earlyTerminateConsumerHoldingLock(target, t);\n+                    return;\n+                }\n+\n+                if (target.isTerminated()) {\n+                    pending = Long.MIN_VALUE;\n+                } else if (!consumed) {\n+                    // we optimistically decremented pending, so increment back again.\n+                    pendingUpdater.accumulateAndGet(this, 1,\n+                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+                    return;\n+                }\n+            } else if (cPending < 0) {\n+                // cancelled or already terminated\n+                return;\n+            } else if (cPending == 0) {\n+                final boolean consumed;\n+                try {\n+                    consumed = buffer.tryConsumeTerminal(target);\n+                } catch (Throwable t) {\n+                    // Assume that we did not deliver terminal to the consumer.\n+                    earlyTerminateConsumerHoldingLock(target, t);\n+                    return;\n+                }\n+                if (consumed) {\n+                    pending = Long.MIN_VALUE;\n+                    return;\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    private void earlyTerminateConsumerHoldingLock(final SubscriberBufferConsumer<T> consumer, final Throwable cause) {\n+        pending = Long.MIN_VALUE;\n+        try {\n+            delayedSubscription.cancel();\n+        } finally {\n+            consumer.consumeTerminal(cause);\n+        }\n+    }\n+\n+    private static final class SubscriberBufferConsumer<T> implements BufferConsumer<T> {\n+        private final Subscriber<? super T> subscriber;\n+        private boolean terminated;", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgzNzk2OA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421837968", "bodyText": "nope, this class ins't used concurrently by different threads.", "author": "NiteshKant", "createdAt": "2020-05-07T22:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTYzNw=="}], "type": "inlineReview"}, {"oid": "cebd64186823b1601412d8ed623042a2661ec673", "url": "https://github.com/apple/servicetalk/commit/cebd64186823b1601412d8ed623042a2661ec673", "message": "Review comments", "committedDate": "2020-05-07T22:49:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5MjI2OQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421792269", "bodyText": "if the consumer is gone, and we will no longer emit signals, can we drain the queue here to avoid queue growth and retention of objects? also consider triggering the drain from cancel() too.", "author": "Scottmitch", "createdAt": "2020-05-07T21:02:38Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class PublisherProcessor<T> extends Publisher<T> implements Processor<T, T>, Subscription {\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final BufferConsumer CANCELLED = new NoopBufferConsumer();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<PublisherProcessor, BufferConsumer> consumerUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(PublisherProcessor.class, BufferConsumer.class, \"consumer\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicIntegerFieldUpdater<PublisherProcessor> emittingUpdater =\n+            newUpdater(PublisherProcessor.class, \"emitting\");\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicLongFieldUpdater<PublisherProcessor> pendingUpdater =\n+            AtomicLongFieldUpdater.newUpdater(PublisherProcessor.class, \"pending\");\n+\n+    private final DelayedSubscription delayedSubscription;\n+    private final PublisherProcessorBuffer<T> buffer;\n+\n+    @Nullable\n+    private Throwable fatalError; // visible via emitting\n+    @Nullable\n+    private volatile BufferConsumer<T> consumer;\n+    @SuppressWarnings(\"unused\")\n+    private volatile int emitting;\n+    private volatile long pending;\n+\n+    PublisherProcessor(final PublisherProcessorBuffer<T> buffer) {\n+        this.buffer = requireNonNull(buffer);\n+        delayedSubscription = new DelayedSubscription();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription subscription) {\n+        delayedSubscription.delayedSubscription(ConcurrentSubscription.wrap(subscription));\n+    }\n+\n+    @Override\n+    public void onNext(@Nullable final T t) {\n+        buffer.add(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        buffer.terminate(t);\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        buffer.terminate();\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final DelayedSubscription delayedSubscription = new DelayedSubscription();\n+        try {\n+            subscriber.onSubscribe(delayedSubscription);\n+        } catch (Throwable t) {\n+            handleExceptionFromOnSubscribe(subscriber, t);\n+            return;\n+        }\n+\n+        if (consumerUpdater.compareAndSet(this, null, new SubscriberBufferConsumer<>(subscriber))) {\n+            delayedSubscription.delayedSubscription(this);\n+            tryEmitSignals();\n+        } else {\n+            BufferConsumer<? super T> existingConsumer = this.consumer;\n+            assert existingConsumer != null;\n+            @SuppressWarnings(\"unchecked\")\n+            final Subscriber<? super T> existingSubscriber = existingConsumer instanceof SubscriberBufferConsumer ?\n+                    ((SubscriberBufferConsumer<T>) existingConsumer).subscriber : null;\n+            safeOnError(subscriber, new DuplicateSubscribeException(existingSubscriber, subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super T> subscriber) {\n+        subscribeInternal(subscriber);\n+    }\n+\n+    @Override\n+    public void request(final long n) {\n+        if (!isRequestNValid(n)) {\n+            fatalError = newExceptionForInvalidRequestN(n);\n+        } else {\n+            pendingUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+            delayedSubscription.request(n);\n+        }\n+        tryEmitSignals();\n+    }\n+\n+    @Override\n+    public void cancel() {\n+        if (pendingUpdater.getAndSet(this, Long.MIN_VALUE) >= 0) {\n+            @SuppressWarnings(\"unchecked\")\n+            BufferConsumer<T> cancelled = CANCELLED;\n+            this.consumer = cancelled;\n+            delayedSubscription.cancel();\n+        }\n+    }\n+\n+    private void tryEmitSignals() {\n+        boolean tryAcquire = true;\n+        while (tryAcquire && tryAcquireLock(emittingUpdater, this)) {\n+            final BufferConsumer<T> consumer = this.consumer;\n+            try {\n+                if (consumer instanceof SubscriberBufferConsumer) {\n+                    SubscriberBufferConsumer<T> target = (SubscriberBufferConsumer<T>) consumer;\n+                    if (fatalError != null) {\n+                        earlyTerminateConsumerHoldingLock(target, fatalError);\n+                        return;\n+                    } else {\n+                        emitSignalsHoldingLock(target);\n+                    }\n+                }\n+            } finally {\n+                tryAcquire = !releaseLock(emittingUpdater, this);\n+            }\n+        }\n+    }\n+\n+    private void emitSignalsHoldingLock(final SubscriberBufferConsumer<T> target) {\n+        for (;;) {\n+            final long cPending = pending;\n+            if (cPending > 0 && pendingUpdater.compareAndSet(this, cPending, cPending - 1)) {\n+                final boolean consumed;\n+                try {\n+                    consumed = buffer.tryConsume(target);\n+                } catch (Throwable t) {\n+                    earlyTerminateConsumerHoldingLock(target, t);\n+                    return;\n+                }\n+\n+                if (target.isTerminated()) {\n+                    pending = Long.MIN_VALUE;\n+                } else if (!consumed) {\n+                    // we optimistically decremented pending, so increment back again.\n+                    pendingUpdater.accumulateAndGet(this, 1,\n+                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+                    return;\n+                }\n+            } else if (cPending < 0) {\n+                // cancelled or already terminated\n+                return;", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5ODc4MA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421798780", "bodyText": "BufferConsumer is a general name that doesn't provide much context as to its intended usage. Consider:\n\nrenaming to PublisherProcessorConsumer; OR\nrename to Consumer and move as an inner interface to PublisherProcessorBuffer", "author": "Scottmitch", "createdAt": "2020-05-07T21:15:19Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferConsumer.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Consumer of items from a buffer.\n+ *\n+ * @param <T>  Type of items {@link #consumeItem(Object) consumed} by this buffer.\n+ */\n+public interface BufferConsumer<T> {", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0MzA2OA==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r422343068", "bodyText": "Note that this interface is also used for the blocking variant. Let me prefix the class with Processor to make sure the connection to processors is evident.", "author": "NiteshKant", "createdAt": "2020-05-08T19:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5ODc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwMDc3NQ==", "url": "https://github.com/apple/servicetalk/pull/1039#discussion_r421800775", "bodyText": "the \"buffer\" terminology overlaps with our buffer.api package. What about PublisherProcessorSignal[Collection | Collector | Holder] (or something similar)?", "author": "Scottmitch", "createdAt": "2020-05-07T21:19:10Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherProcessorBuffer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Processor;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A buffer to store items for a {@link Processor}.\n+ *\n+ * @param <T>  Type of items stored in this buffer.\n+ */\n+public interface PublisherProcessorBuffer<T> {", "originalCommit": "a58cf3e762140a0614304c030db189cfbc95d6a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7a769be708668f7de85a3aef0bd7b862f6e7d445", "url": "https://github.com/apple/servicetalk/commit/7a769be708668f7de85a3aef0bd7b862f6e7d445", "message": "Review comments", "committedDate": "2020-05-08T20:37:37Z", "type": "commit"}, {"oid": "4a8bb68749737e0cb4c99bb673b020d3b3eed9d1", "url": "https://github.com/apple/servicetalk/commit/4a8bb68749737e0cb4c99bb673b020d3b3eed9d1", "message": "Add motivations for `PublisherProcessorSignalsHolder` in javadoc", "committedDate": "2020-05-08T20:56:39Z", "type": "commit"}]}