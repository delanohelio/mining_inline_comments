{"pr_number": 1004, "pr_title": "AsyncContextInMemoryScopeManager to restore previous Scope on close()", "pr_createdAt": "2020-04-07T00:49:07Z", "pr_url": "https://github.com/apple/servicetalk/pull/1004", "timeline": [{"oid": "9632b529e5cc5dc005794a75a5571086997f7bab", "url": "https://github.com/apple/servicetalk/commit/9632b529e5cc5dc005794a75a5571086997f7bab", "message": "AsyncContextInMemoryScopeManager to restore previous Scope on close()\n\nMotivation:\nAsyncContextInMemoryScopeManager currently doesn't restore the previous\nScope when the current Scope is closed. This behavior is provided for\nThreadLocalScope and allows users to use try-with-resources type\nconstructs to create sub-spans more easily.\n\nModifications:\n- AsyncContextInMemoryScopeManager to save/restore the previous Scope\nwhen a new Scope is activated\n- AsyncContextInMemoryScopeManager to remove the currentScope() hack so\nlifetime of Scopes is more narrowly/correctly constrainted. This means\nthat filter ordering is important and use of after* operators should be\ndone with care!\n\nResult:\nAsyncContextInMemoryScopeManager has more consistent behavior with\nThreadLocalScope, and lifetimes of Scopes are more narrowly/correctly\nconstrainted.", "committedDate": "2020-04-07T00:43:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3Mzg5MA==", "url": "https://github.com/apple/servicetalk/pull/1004#discussion_r404473890", "bodyText": "discussed with @NiteshKant offline on possibility of splitting this filter into two:\n\nTracerExtractor\nTracerCloser\n\nhowever the complexity of implementation would be high to hand-off ownership between filters. Also I will come up with a PR to change when* operators to default to before* (instead of after*) to reduce the risk of filters inadvertently applying an \"after\" operator which would mean their filter response processing may run without trace info.", "author": "Scottmitch", "createdAt": "2020-04-07T00:52:16Z", "path": "servicetalk-opentracing-http/src/main/java/io/servicetalk/opentracing/http/TracingHttpServiceFilter.java", "diffHunk": "@@ -40,6 +43,12 @@\n \n /**\n  * A {@link StreamingHttpService} that supports open tracing.\n+ * <p>\n+ * Append this filter before others that are expected to see {@link Scope} for this request/response. Filters appended", "originalCommit": "9632b529e5cc5dc005794a75a5571086997f7bab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4MzcyMg==", "url": "https://github.com/apple/servicetalk/pull/1004#discussion_r404483722", "bodyText": "Yes agreed!\nIt seems logical to define the scope of an operation within the context of a filter. After* operators seem to extend that scope after everything else outside that scope. Drawing an analogy to an imperative programming model:\npublic Result someMethod(Caller caller) {\n\n    State state;\n    try {\n        state = new State();\n        Result result = doWork();\n        return result;\n    } finally {\n         // Code here is analogous to beforeFinally async operators.\n         state.cleanup(); \n        // In order to demonstrate cleanup from the code that is calling this method. \n        // Assume caller is passed to this method.\n        caller.cleanup();\n    }\n// Code below this is analogous to async afterFinally operators.\n}", "author": "NiteshKant", "createdAt": "2020-04-07T01:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3Mzg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4MDQ5OQ==", "url": "https://github.com/apple/servicetalk/pull/1004#discussion_r404480499", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final AsyncContextMap.Key<AsyncContextInMemoryScope> SCOPE_KEY = newKey(\"opentracing\");\n          \n          \n            \n                private static final AsyncContextMap.Key<InMemoryScope> SCOPE_KEY = newKey(\"opentracing\");", "author": "NiteshKant", "createdAt": "2020-04-07T01:16:30Z", "path": "servicetalk-opentracing-asynccontext/src/main/java/io/servicetalk/opentracing/asynccontext/AsyncContextInMemoryScopeManager.java", "diffHunk": "@@ -31,62 +31,53 @@\n  */\n public final class AsyncContextInMemoryScopeManager implements InMemoryScopeManager {\n     private static final AsyncContextMap.Key<AsyncContextInMemoryScope> SCOPE_KEY = newKey(\"opentracing\");", "originalCommit": "9632b529e5cc5dc005794a75a5571086997f7bab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4MTIyOQ==", "url": "https://github.com/apple/servicetalk/pull/1004#discussion_r404481229", "bodyText": "This disclaimer also applied for metadata in case of error, you may want to add that.", "author": "NiteshKant", "createdAt": "2020-04-07T01:19:20Z", "path": "servicetalk-opentracing-http/src/main/java/io/servicetalk/opentracing/http/TracingHttpRequesterFilter.java", "diffHunk": "@@ -34,13 +35,21 @@\n import io.opentracing.Tracer;\n import io.opentracing.Tracer.SpanBuilder;\n \n+import java.util.function.UnaryOperator;\n+\n import static io.opentracing.tag.Tags.HTTP_METHOD;\n import static io.opentracing.tag.Tags.HTTP_URL;\n import static io.opentracing.tag.Tags.SPAN_KIND;\n import static io.opentracing.tag.Tags.SPAN_KIND_CLIENT;\n \n /**\n  * An HTTP filter that supports open tracing.\n+ * <p>\n+ * Append this filter before others that are expected to to see {@link Scope} for this request/response. Filters\n+ * appended after this filter that use operators with the <strong>after*</strong> prefix on the\n+ * {@link StreamingHttpResponse#transformRawPayloadBody(UnaryOperator) response payload body} (e.g.", "originalCommit": "9632b529e5cc5dc005794a75a5571086997f7bab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7ff9dccfcd2b9b4f1ce81697bafaa4e42679d396", "url": "https://github.com/apple/servicetalk/commit/7ff9dccfcd2b9b4f1ce81697bafaa4e42679d396", "message": "review comments", "committedDate": "2020-04-07T02:22:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3Njk0OQ==", "url": "https://github.com/apple/servicetalk/pull/1004#discussion_r404576949", "bodyText": "nit: the method body could be just moved to remove.", "author": "normanmaurer", "createdAt": "2020-04-07T06:56:58Z", "path": "servicetalk-log4j2-mdc-utils/src/testFixtures/java/io/servicetalk/log4j2/mdc/utils/LoggerStringWriter.java", "diffHunk": "@@ -157,21 +165,41 @@ private static synchronized StringWriter getStringWriter() {\n         return logStringWriter;\n     }\n \n+    private static synchronized void removeStringWriter() {", "originalCommit": "7ff9dccfcd2b9b4f1ce81697bafaa4e42679d396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE3NTI5NQ==", "url": "https://github.com/apple/servicetalk/pull/1004#discussion_r405175295", "bodyText": "I'll leave this as is to avoid exposing the static synchronized on the public method and for consistency with the reset() method structure.", "author": "Scottmitch", "createdAt": "2020-04-07T23:38:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3Njk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NzkwMQ==", "url": "https://github.com/apple/servicetalk/pull/1004#discussion_r404577901", "bodyText": "nit: you could just use assertTrue(foundMatch, \"....\");", "author": "normanmaurer", "createdAt": "2020-04-07T06:59:01Z", "path": "servicetalk-opentracing-http/src/test/java/io/servicetalk/opentracing/http/TestUtils.java", "diffHunk": "@@ -43,6 +54,36 @@ private static String getRandomHexString(int numchars) {\n         return sb.toString().substring(0, numchars);\n     }\n \n+    static void verifyTraceIdPresentInLogs(String logs, String requestPath, String traceId, String spanId,\n+                                           @Nullable String parentSpanId, String[] logLinePrefix) {\n+        if (parentSpanId == null) {\n+            parentSpanId = TracingConstants.NO_PARENT_ID;\n+        }\n+        String[] lines = logs.split(\"\\\\r?\\\\n\");\n+        for (final String linePrefix : logLinePrefix) {\n+            String prefix = linePrefix.replaceFirst(\"\\\\{}\", requestPath);\n+            boolean foundMatch = false;\n+            for (String line : lines) {\n+                int matchIndex = line.indexOf(prefix);\n+                if (matchIndex != -1) {\n+                    foundMatch = true;\n+                    try {\n+                        assertContainsMdcPair(line, \"traceId=\", traceId);\n+                        assertContainsMdcPair(line, \"spanId=\", spanId);\n+                        assertContainsMdcPair(line, \"parentSpanId=\", parentSpanId);\n+                    } catch (Throwable cause) {\n+                        cause.addSuppressed(new AssertionError(\"failed on prefix: \" + prefix));\n+                        throw cause;\n+                    }\n+                    break;\n+                }\n+            }\n+            if (!foundMatch) {\n+                throw new AssertionError(\"could not find log line with prefix: \" + prefix);\n+            }", "originalCommit": "7ff9dccfcd2b9b4f1ce81697bafaa4e42679d396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE3NTMyNg==", "url": "https://github.com/apple/servicetalk/pull/1004#discussion_r405175326", "bodyText": "follow-up PR #1009", "author": "Scottmitch", "createdAt": "2020-04-07T23:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NzkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3ODUxNg==", "url": "https://github.com/apple/servicetalk/pull/1004#discussion_r404578516", "bodyText": "I guess it doesn't matter as its just used in the test but usually you should call .clone() on an array when it is passed via the constructor to ensure it can't be modified later on.", "author": "normanmaurer", "createdAt": "2020-04-07T07:00:18Z", "path": "servicetalk-opentracing-http/src/test/java/io/servicetalk/opentracing/http/TracingHttpRequesterFilterTest.java", "diffHunk": "@@ -189,4 +221,54 @@ private static ServerContext buildServer() throws Exception {\n     private static String toStringOrNull(@Nullable CharSequence cs) {\n         return cs == null ? null : cs.toString();\n     }\n+\n+    private static final class TestTracingLoggerFilter implements StreamingHttpClientFilterFactory {\n+        private final String[] logLinePrefix;\n+\n+        TestTracingLoggerFilter(final String[] logLinePrefix) {\n+            this.logLinePrefix = requireNonNull(logLinePrefix);", "originalCommit": "7ff9dccfcd2b9b4f1ce81697bafaa4e42679d396", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3ODcyMQ==", "url": "https://github.com/apple/servicetalk/pull/1004#discussion_r404578721", "bodyText": "same comment as above", "author": "normanmaurer", "createdAt": "2020-04-07T07:00:39Z", "path": "servicetalk-opentracing-http/src/test/java/io/servicetalk/opentracing/http/TracingHttpServiceFilterTest.java", "diffHunk": "@@ -176,4 +210,54 @@ public void tracerThrowsReturnsErrorResponse() throws Exception {\n             }\n         }\n     }\n+\n+    private static final class TestTracingLoggerFilter implements StreamingHttpServiceFilterFactory {\n+        private final String[] logLinePrefix;\n+\n+        private TestTracingLoggerFilter(final String[] logLinePrefix) {\n+            this.logLinePrefix = requireNonNull(logLinePrefix);", "originalCommit": "7ff9dccfcd2b9b4f1ce81697bafaa4e42679d396", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}