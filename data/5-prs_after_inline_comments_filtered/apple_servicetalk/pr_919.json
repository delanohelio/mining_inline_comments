{"pr_number": 919, "pr_title": "Protocol emits payload boundary event", "pr_createdAt": "2020-01-14T00:44:18Z", "pr_url": "https://github.com/apple/servicetalk/pull/919", "timeline": [{"oid": "490aace1e1ad7682a165427cfe8030e666f086f9", "url": "https://github.com/apple/servicetalk/commit/490aace1e1ad7682a165427cfe8030e666f086f9", "message": "Protocol emits payload boundary event\n\n__Motivation__\n\nWriteStreamSubscriber is not aware of payload boundaries, hence when a Channel becomes suddenly inactive (closed or output shutdown) it could only assume the write failed. In case of H2 the codec would perfom an output shutdown after observing and emitting trailers. This output shutdown would race with write publisher completion and occasionally result in WriteStreamSubscriber failing the write with an error even though it actually completed normally.\n\n__Modifications__\n\n- H1/H2 codecs emit payload boundaries via CloseHandler\n- CloseHandler triggers a new UserEvent on outbound payload end\n- DefaultNettyConnection intercepts above event and notifies WriteListener (WriteStreamSubscriber)\n- WriteStreamSubscriber responds to 2 triggers for write source stream completion\n\n__Result__\n\nWrites no longer fail due to race between closure of write publisher and H2 end of stream", "committedDate": "2020-01-14T00:29:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzMjc2Mg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366532762", "bodyText": "I am trying to understand the implications of having this isCient check here.\nIt seems like we are pushing the design decision of doing one write per request (as opposed to doing batch writes of multiple requests) on the client side down to the close handler implementation. IIUC, this close handler did not assume that till now, what is the reason to introduce this assumption now?", "author": "NiteshKant", "createdAt": "2020-01-14T19:34:57Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -163,6 +163,13 @@ public void protocolPayloadBeginOutbound(final ChannelHandlerContext ctx) {\n \n     @Override\n     public void protocolPayloadEndOutbound(final ChannelHandlerContext ctx) {\n+        if (isClient || has(state, CLOSING)) {", "originalCommit": "490aace1e1ad7682a165427cfe8030e666f086f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU5MjQ4Mw==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366592483", "bodyText": "Unless I misunderstood our prior discussion, I assumed you suggested implementing it in RequestResponseCloseHandler as opposed to having a more elaborate state machine inside WriteStreamSubscriber.  What was your expectation?", "author": "jayv", "createdAt": "2020-01-14T21:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzMjc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzMTc0OQ==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366631749", "bodyText": "I am not questioning the changes to RequestResponseCloseHandler but why do we need the special case for isClient. Is has(state, CLOSING) sufficient?", "author": "NiteshKant", "createdAt": "2020-01-14T23:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzMjc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzNjEzMw==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366636133", "bodyText": "I feel like there shouldn't be any condition at all, not isClient() nor has(CLOSING). end of payload should mean what it is and emit every time the codec sees one.\nBut if we did that, then we'd get into the issue down the line with H1 repeated read/single write reusing a terminated WriteStreamSubscriber. So we have to suppress this event before it reaches WSS in the case of H1 server; for H2 it doesn't matter.", "author": "jayv", "createdAt": "2020-01-15T00:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzMjc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzODMxNQ==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366638315", "bodyText": "I understand why has(CLOSING) is required and I think it is reasonable as this event is only valuable to determine if we expect any other write on this connection. Since CloseHandler has all the other information (outbound closing) it makes sense to keep this knowledge inside CloseHandler.\nI am not clear about why we need isClient check here, can you explain?", "author": "NiteshKant", "createdAt": "2020-01-15T00:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzMjc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY0MTUyMw==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366641523", "bodyText": "The discrepancy is the client WriteStreamSubscriber lifetime is tied to the request where on the server side its lifetime is aligned with the connection. Hence to be correct the client needs to trigger this event for every write, no matter if it'll be the last write on the connection.\nIn practice it doesn't matter because close handler does proper sequencing and attaches listeners to the write promise so we can't ever see a premature channel closed event.", "author": "jayv", "createdAt": "2020-01-15T00:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzMjc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY0MjAxMg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366642012", "bodyText": "Also has(CLOSING) is tied to the connection, not the lifetime of WSS which differs between client and server.", "author": "jayv", "createdAt": "2020-01-15T00:24:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzMjc2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxMDY4Nw==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367010687", "bodyText": "Ok ya makese sense, thanks for the explanation.", "author": "NiteshKant", "createdAt": "2020-01-15T17:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzMjc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MDEwMg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366560102", "bodyText": "At some point we were discussing removing the inconsistency between channelClosedOutbound() and channelClosed() implementations in WriteStreamSubscriber. Do you intend to do it in a follow up PR?", "author": "NiteshKant", "createdAt": "2020-01-14T20:37:51Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -189,6 +189,11 @@ public void channelWritable() {\n         requestMoreIfRequired(subscription);\n     }\n \n+    @Override\n+    public void protocolPayloadComplete() {\n+        onComplete();\n+    }\n+\n     @Override\n     public void channelClosedOutbound() {", "originalCommit": "490aace1e1ad7682a165427cfe8030e666f086f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU5MzMyMA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366593320", "bodyText": "It didn't seem necessary to solve the problem at hand, but I can look into it.", "author": "jayv", "createdAt": "2020-01-14T21:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MDEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MTAwOA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366561008", "bodyText": "This method is expected to be called from the eventloop, so we can add an assert to verify that and directly call promise.sourceTerminated(null)", "author": "NiteshKant", "createdAt": "2020-01-14T20:39:53Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -189,6 +189,11 @@ public void channelWritable() {\n         requestMoreIfRequired(subscription);\n     }\n \n+    @Override\n+    public void protocolPayloadComplete() {\n+        onComplete();", "originalCommit": "490aace1e1ad7682a165427cfe8030e666f086f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NDgzMw==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366564833", "bodyText": "Logically, it looks like we should error out here if we have not seen onSuccess()/onError().\nIs the noop implementation here because in practice we never write Single?", "author": "NiteshKant", "createdAt": "2020-01-14T20:48:47Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -73,6 +73,11 @@ public void channelWritable() {\n         // No op.\n     }\n \n+    @Override\n+    public void protocolPayloadComplete() {\n+        // No op.", "originalCommit": "490aace1e1ad7682a165427cfe8030e666f086f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwMDI1NA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366600254", "bodyText": "Made it noop because it doesn't seem relevant to Single and not sure we should complicate the state machine for this.", "author": "jayv", "createdAt": "2020-01-14T22:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NDgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzMzYzNQ==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366633635", "bodyText": "If we are adding a generic method to the WritableListener we should implement it in a way that makes sense for the contract. In this case it does seem like we would want to emit an error if we get protocolPayloadComplete() without onSuccess(), it will make it easier in the future to reason about the code.", "author": "NiteshKant", "createdAt": "2020-01-14T23:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NDgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NzQyOA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366567428", "bodyText": "Since we are synthetically generating an onComplete() we should now verify that we do not write any data after onComplete() is called.", "author": "NiteshKant", "createdAt": "2020-01-14T20:54:59Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -189,6 +189,11 @@ public void channelWritable() {\n         requestMoreIfRequired(subscription);\n     }\n \n+    @Override\n+    public void protocolPayloadComplete() {\n+        onComplete();", "originalCommit": "490aace1e1ad7682a165427cfe8030e666f086f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwMTI1Ng==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366601256", "bodyText": "IIUC WriteStreamSubscriber already takes care of this by not requesting more data via isWritable() ?", "author": "jayv", "createdAt": "2020-01-14T22:14:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NzQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzNTI1OQ==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366635259", "bodyText": "isWritable() only checks for !hasFlag(CHANNEL_CLOSED) && !hasFlag(SUBSCRIBER_TERMINATED); so we would have to also check for SOURCE_TERMINATED.\nAdditionally, not requesting more data does not necessarily mean we will not get any more data if we are synthetically generating onComplete() as we may have already requested more than what we have got.", "author": "NiteshKant", "createdAt": "2020-01-14T23:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NzQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY0OTU3Mg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366649572", "bodyText": "We have the same check in doWrite() actually so, adding SOURCE_TERMINATED should be sufficient then?", "author": "jayv", "createdAt": "2020-01-15T00:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NzQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2OTk3Mg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366569972", "bodyText": "I think we can leverage pre-existing concepts here instead of introducing protcol and payload knowledge inside WritableListener. What we are after here is essentially \"graceful closure\" which in this case means wait for enqueued writes to finish before closing the listener.\nI would suggest renaming this method to closeGracefully() and renaming existing channelClosed(Throwable) to close(Throwable) so that we clearly can define behaviors for abrupt and graceful closures without introducing the \"protocol concept\" here. If you get around unifying channelClosedOutbound() and channelClosed() as mentioned above then we can also remove channelClosedOutbound().", "author": "NiteshKant", "createdAt": "2020-01-14T21:01:01Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -459,6 +459,21 @@ public FlushStrategy defaultFlushStrategy() {\n          */\n         void channelWritable();\n \n+        /**\n+         * Notifies the end of payload was observed at the transport (not necessarily flushed).\n+         *\n+         * <p>\n+         * This helps coordinate state between the writer and the codec/transport. Even if the writing source may not\n+         * have completed from a Reactive Streams perspective, it means that as far as the codec and transport is\n+         * concerned it considers the write is complete and no further writes can happen. Closing of the transport after\n+         * receiving this event should not be considered a write error since the final buffer was written and\n+         * potentially flushed. A failed write promise after observing this event however indicates the end of payload\n+         * marker may not have been written correctly and should result in an error.\n+         * <p>\n+         * This is event is expected be called from the eventloop.\n+         */\n+        void protocolPayloadComplete();", "originalCommit": "490aace1e1ad7682a165427cfe8030e666f086f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxODcwOA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366618708", "bodyText": "OK I'll try", "author": "jayv", "createdAt": "2020-01-14T23:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2OTk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3Mzc2Nw==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366573767", "bodyText": "I would avoid adding supposedly protocol specific logic like this to UnsupportedProtocolHandler. IIUC, this is to support H2 so lets create a CloseHandler implementation for H2 and for now we can simply implement this method.", "author": "NiteshKant", "createdAt": "2020-01-14T21:10:21Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java", "diffHunk": "@@ -260,6 +267,11 @@ public void protocolPayloadBeginOutbound(final ChannelHandlerContext ctx) {\n \n         @Override\n         public void protocolPayloadEndOutbound(final ChannelHandlerContext ctx) {\n+            ctx.pipeline().fireUserEventTriggered(ProtocolPayloadEndEvent.OUTBOUND);", "originalCommit": "490aace1e1ad7682a165427cfe8030e666f086f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNDk0Mg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366614942", "bodyText": "I assumed all protocols would need to provide some notion of payload completion for WriteStreamSubscriber to work properly, so it seemed reasonable to provide it here.", "author": "jayv", "createdAt": "2020-01-14T22:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3Mzc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3NDQ3NQ==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366574475", "bodyText": "Can you explain the motivation for this change?\nProtocolPayloadEndEvent.OUTBOUND is for write but the comment here suggests it is due to \"repeated reads\".\nIn case you end up removing this change, we can make  the class ProtocolPayloadEndEvent package-private.", "author": "NiteshKant", "createdAt": "2020-01-14T21:12:07Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/FlushStrategyOnServerTest.java", "diffHunk": "@@ -112,19 +125,36 @@ public void flush(final ChannelHandlerContext ctx) {\n             return succeeded(resp);\n         };\n         DefaultHttpExecutionContext httpExecutionContext =\n-                new DefaultHttpExecutionContext(DEFAULT_ALLOCATOR, ioExecutor, executor, executionStrategy);\n-        ReadOnlyHttpServerConfig config = new HttpServerConfig().asReadOnly();\n+                new DefaultHttpExecutionContext(DEFAULT_ALLOCATOR, ioExecutor, executor, param.executionStrategy);\n+\n+        final ReadOnlyHttpServerConfig config = new HttpServerConfig().asReadOnly();\n         serverConnection = initChannel(channel, httpExecutionContext, config,\n-                new TcpServerChannelInitializer(config.tcpConfig()), service, true,\n+                new TcpServerChannelInitializer(config.tcpConfig()) {\n+                    @Override\n+                    public void init(final Channel channel) {\n+                        super.init(channel);\n+                        channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+                            @Override\n+                            public void userEventTriggered(final ChannelHandlerContext ctx,\n+                                                           final Object evt) throws Exception {\n+                                if (evt == CloseHandler.ProtocolPayloadEndEvent.OUTBOUND) {\n+                                    // Mute payload boundary events for this test with repeated read", "originalCommit": "490aace1e1ad7682a165427cfe8030e666f086f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMzExOA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366613118", "bodyText": "The repeated read, single perpetual write mechanism is root cause for some of the items you had remarks on. If the protocol event were to be propagated here the WriteStreamSubscriber would be terminated which effectively stops requesting data from the source. Some tests send multiple requests on the same connection.\nIt's the same reason we conditionally emit the event from the RequestResponseCloseHandler (cfr. isClient mentioned above) and the cause for piling up of listeners on server write futures until channel close.\nIf I were to split out an H2 variant from the UnsupportedProtocolCloseHandler, this would go away.", "author": "jayv", "createdAt": "2020-01-14T22:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3NDQ3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzNjAzOA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366636038", "bodyText": "If I were to split out an H2 variant from the UnsupportedProtocolCloseHandler, this would go away.\n\n\nOk I think we should split out an H2 variant and not emit the event from UnsupportedProtocolCloseHandler .", "author": "NiteshKant", "createdAt": "2020-01-15T00:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3NDQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3NjA5Ng==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366576096", "bodyText": "Is the use of enum here just a personal choice or there is a difference between the two approaches?", "author": "NiteshKant", "createdAt": "2020-01-14T21:16:10Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/FlushStrategyOnServerTest.java", "diffHunk": "@@ -112,19 +125,36 @@ public void flush(final ChannelHandlerContext ctx) {\n             return succeeded(resp);\n         };\n         DefaultHttpExecutionContext httpExecutionContext =\n-                new DefaultHttpExecutionContext(DEFAULT_ALLOCATOR, ioExecutor, executor, executionStrategy);\n-        ReadOnlyHttpServerConfig config = new HttpServerConfig().asReadOnly();\n+                new DefaultHttpExecutionContext(DEFAULT_ALLOCATOR, ioExecutor, executor, param.executionStrategy);\n+\n+        final ReadOnlyHttpServerConfig config = new HttpServerConfig().asReadOnly();\n         serverConnection = initChannel(channel, httpExecutionContext, config,\n-                new TcpServerChannelInitializer(config.tcpConfig()), service, true,\n+                new TcpServerChannelInitializer(config.tcpConfig()) {\n+                    @Override\n+                    public void init(final Channel channel) {\n+                        super.init(channel);\n+                        channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+                            @Override\n+                            public void userEventTriggered(final ChannelHandlerContext ctx,\n+                                                           final Object evt) throws Exception {\n+                                if (evt == CloseHandler.ProtocolPayloadEndEvent.OUTBOUND) {\n+                                    // Mute payload boundary events for this test with repeated read\n+                                    return;\n+                                }\n+                                super.userEventTriggered(ctx, evt);\n+                            }\n+                        });\n+                    }\n+                }, service, true,\n                 UNSUPPORTED_PROTOCOL_CLOSE_HANDLER)\n                 .toFuture().get();\n         serverConnection.process(true);\n         headersFactory = DefaultHttpHeadersFactory.INSTANCE;\n     }\n \n     @Parameters(name = \"{index}: strategy = {0}\")\n-    public static Collection<HttpExecutionStrategy> data() {\n-        return asList(noOffloadsStrategy(), defaultStrategy(), customStrategyBuilder().offloadAll().build());\n+    public static Param[][] data() {", "originalCommit": "490aace1e1ad7682a165427cfe8030e666f086f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMTIyOA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366611228", "bodyText": "Not personal choice, this improves tooling (IDE/gradle) support. With the existing approach you can't run/debug individual test-cases due to unstable name.", "author": "jayv", "createdAt": "2020-01-14T22:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3NjA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzNjE3Ng==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366636176", "bodyText": "ok, great. thanks", "author": "NiteshKant", "createdAt": "2020-01-15T00:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3NjA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU4MjI0NA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366582244", "bodyText": "We are using UnsupportedProtocolHandler which does not implement these callbacks so we are not really verifying whether these callbacks are correct. Should we hold off adding calls to CloseHandler other than protocolPayloadEndOutbound() till we need them?", "author": "NiteshKant", "createdAt": "2020-01-14T21:30:21Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ToStH1ClientDuplexHandler.java", "diffHunk": "@@ -56,15 +57,17 @@\n     @Nullable\n     private HttpRequestMethod method;\n \n-    H2ToStH1ClientDuplexHandler(boolean sslEnabled, BufferAllocator allocator, HttpHeadersFactory headersFactory) {\n-        super(headersFactory);\n+    H2ToStH1ClientDuplexHandler(boolean sslEnabled, BufferAllocator allocator, HttpHeadersFactory headersFactory,\n+                                CloseHandler closeHandler) {\n+        super(headersFactory, closeHandler);\n         this.scheme = sslEnabled ? HttpScheme.HTTPS : HttpScheme.HTTP;\n         this.allocator = allocator;\n     }\n \n     @Override\n     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n         if (msg instanceof HttpRequestMetaData) {\n+            closeHandler.protocolPayloadBeginOutbound(ctx);", "originalCommit": "490aace1e1ad7682a165427cfe8030e666f086f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNzE3OA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366617178", "bodyText": "I wanted to make it more consistent with H1, but I'm OK with leaving them out.", "author": "jayv", "createdAt": "2020-01-14T22:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU4MjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzNjQxNg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366636416", "bodyText": "Ok Ya either we validate that we are doing the rite thing or leave it out. I would prefer leaving them out.", "author": "NiteshKant", "createdAt": "2020-01-15T00:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU4MjI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU4NDU2OQ==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366584569", "bodyText": "Should we add channel.close() in this test?", "author": "NiteshKant", "createdAt": "2020-01-14T21:35:43Z", "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/DefaultNettyConnectionTest.java", "diffHunk": "@@ -500,4 +523,34 @@ public void testChannelInactiveWithNoSubscriberIsQueued() throws Exception {\n         assertThat(subscriber.takeError(), instanceOf(ClosedChannelException.class));\n         conn.onClose().toFuture().get();\n     }\n+\n+    @Test\n+    public void testChannelCloseBeforeWriteComplete() {\n+        writeListener.listen(conn.write(publisher));\n+        Buffer hello1 = newBuffer(\"Hello1\");\n+        publisher.onNext(hello1);\n+        publisher.onNext(TRAILER);\n+        pollChannelAndVerifyWrites(\"Hello1\", TRAILER_MSG);\n+\n+        channel.pipeline().fireChannelInactive();\n+        channel.close();\n+        publisher.onComplete();\n+\n+        writeListener.verifyCompletion();\n+    }\n+\n+    @Test\n+    public void testChannelCloseAfterWriteComplete() {\n+        writeListener.listen(conn.write(publisher));\n+        Buffer hello1 = newBuffer(\"Hello1\");\n+        publisher.onNext(hello1);\n+        publisher.onNext(TRAILER);\n+\n+        pollChannelAndVerifyWrites(\"Hello1\", TRAILER_MSG);\n+\n+        channel.pipeline().fireChannelInactive();\n+        publisher.onComplete();\n+\n+        writeListener.verifyCompletion();", "originalCommit": "490aace1e1ad7682a165427cfe8030e666f086f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a617beff701cc56eb816c1dab3be71f2098a7887", "url": "https://github.com/apple/servicetalk/commit/a617beff701cc56eb816c1dab3be71f2098a7887", "message": "Address comments", "committedDate": "2020-01-15T01:31:27Z", "type": "commit"}, {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "url": "https://github.com/apple/servicetalk/commit/9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "message": "Ensure graceful close is not called out of phase", "committedDate": "2020-01-15T02:58:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk3ODc3MQ==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366978771", "bodyText": "Since this is only useful for H2, should this be a package private class in htttp-netty module?", "author": "NiteshKant", "createdAt": "2020-01-15T16:33:48Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java", "diffHunk": "@@ -262,6 +270,69 @@ public void protocolPayloadBeginOutbound(final ChannelHandlerContext ctx) {\n         public void protocolPayloadEndOutbound(final ChannelHandlerContext ctx) {\n         }\n \n+        @Override\n+        public void protocolPayloadEndOutboundSuccess(final ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void protocolClosingInbound(final ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void protocolClosingOutbound(final ChannelHandlerContext ctx) {\n+        }\n+    }\n+\n+    private static final class H2ProtocolHandler extends CloseHandler {", "originalCommit": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxNDY5OQ==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367014699", "bodyText": "No can do, we deliberately made some methods pkg private on CloseHandler so it can only be implemented in this pkg.", "author": "jayv", "createdAt": "2020-01-15T17:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk3ODc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MTI5Mg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367091292", "bodyText": "Got it, thanks", "author": "NiteshKant", "createdAt": "2020-01-15T20:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk3ODc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0MDU2OA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367740568", "bodyText": "this seems like a strange trade-off. We are hiding internal details that are not protocol specific at the cost of having to put protocol specific classes outside of their intended scope. Referencing the comment below https://github.com/apple/servicetalk/pull/919/files#r366614942 , if this is intended to be used beyond h2, is it worth adjusting the names accordingly to remove the implication this is protocol specific?\nSorry for being late to the review, I created #923 for followup changes/discussion.", "author": "Scottmitch", "createdAt": "2020-01-17T02:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk3ODc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MTk0Nw==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366981947", "bodyText": "Update comments?\nI think we should leave it to the implementations as to how this is implemented and not prescribe the write-flush-close relationships.\nFrom this method perspective, we can say something like: calling close(Throwable) after closeGracefully() will be ignored.", "author": "NiteshKant", "createdAt": "2020-01-15T16:39:25Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -459,6 +458,21 @@ public FlushStrategy defaultFlushStrategy() {\n          */\n         void channelWritable();\n \n+        /**\n+         * Notifies the end of payload was observed at the transport (not necessarily flushed).", "originalCommit": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MzI0OA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366983248", "bodyText": "In this case, the subscriber waiting for write completion needs to be notified, so we should call notifyError() here instead of throwing.", "author": "NiteshKant", "createdAt": "2020-01-15T16:41:41Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -74,21 +82,28 @@ public void channelWritable() {\n     }\n \n     @Override\n-    public void channelClosed(Throwable closedException) {\n+    public void closeGracefully() {\n+        if (terminated == UNSET) {", "originalCommit": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxODQzOQ==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367018439", "bodyText": "OK I was under assumption that it would come back as a close-with-exception, but we can do it this way too.", "author": "jayv", "createdAt": "2020-01-15T17:50:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MzI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NTc0Mg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366985742", "bodyText": "Since now we may generate error prematurely, there is a valid scenario where data may arrive post termination. It will be good to add a log indicating that we are ignoring result, when we do.", "author": "NiteshKant", "createdAt": "2020-01-15T16:46:13Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -51,21 +55,25 @@ public void onSubscribe(Cancellable cancellable) {\n \n     @Override\n     public void onSuccess(@Nullable Object result) {\n-        // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n-        // ordering should be correct.\n-        channel.writeAndFlush(result).addListener(future -> {\n-            Throwable cause = future.cause();\n-            if (cause == null) {\n-                notifyComplete();\n-            } else {\n-                notifyError(cause);\n-            }\n-        });\n+        if (terminatedUpdater.compareAndSet(this, UNSET, PENDING)) {\n+            // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n+            // ordering should be correct.\n+            channel.writeAndFlush(result).addListener(future -> {\n+                Throwable cause = future.cause();\n+                if (cause == null) {\n+                    notifyComplete();\n+                } else {\n+                    notifyError(cause);\n+                }\n+            });\n+        }", "originalCommit": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NjE1OA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366986158", "bodyText": "Ditto, add a log when we ignore error.", "author": "NiteshKant", "createdAt": "2020-01-15T16:46:58Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -51,21 +55,25 @@ public void onSubscribe(Cancellable cancellable) {\n \n     @Override\n     public void onSuccess(@Nullable Object result) {\n-        // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n-        // ordering should be correct.\n-        channel.writeAndFlush(result).addListener(future -> {\n-            Throwable cause = future.cause();\n-            if (cause == null) {\n-                notifyComplete();\n-            } else {\n-                notifyError(cause);\n-            }\n-        });\n+        if (terminatedUpdater.compareAndSet(this, UNSET, PENDING)) {\n+            // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n+            // ordering should be correct.\n+            channel.writeAndFlush(result).addListener(future -> {\n+                Throwable cause = future.cause();\n+                if (cause == null) {\n+                    notifyComplete();\n+                } else {\n+                    notifyError(cause);\n+                }\n+            });\n+        }\n     }\n \n     @Override\n     public void onError(Throwable t) {\n-        notifyError(t);\n+        if (terminatedUpdater.compareAndSet(this, UNSET, PENDING)) {\n+            notifyError(t);\n+        }", "originalCommit": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NzczNA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366987734", "bodyText": "nit: We can use a bit more intuitive names:\nAWAITING_RESULT, AWAITING_WRITE_COMPLETION, TERMINATED", "author": "NiteshKant", "createdAt": "2020-01-15T16:49:47Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -35,6 +35,10 @@\n     @SuppressWarnings(\"unused\")\n     private volatile int terminated;\n \n+    private static final int UNSET = 0;", "originalCommit": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4ODkzOQ==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366988939", "bodyText": "Can we simply do a single atomic update; UNSET -> DONE and move the atomic updates out of notifyComplete() and notifyError()?", "author": "NiteshKant", "createdAt": "2020-01-15T16:51:59Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -51,21 +55,25 @@ public void onSubscribe(Cancellable cancellable) {\n \n     @Override\n     public void onSuccess(@Nullable Object result) {\n-        // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n-        // ordering should be correct.\n-        channel.writeAndFlush(result).addListener(future -> {\n-            Throwable cause = future.cause();\n-            if (cause == null) {\n-                notifyComplete();\n-            } else {\n-                notifyError(cause);\n-            }\n-        });\n+        if (terminatedUpdater.compareAndSet(this, UNSET, PENDING)) {\n+            // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n+            // ordering should be correct.\n+            channel.writeAndFlush(result).addListener(future -> {\n+                Throwable cause = future.cause();\n+                if (cause == null) {\n+                    notifyComplete();\n+                } else {\n+                    notifyError(cause);\n+                }\n+            });\n+        }\n     }\n \n     @Override\n     public void onError(Throwable t) {\n-        notifyError(t);\n+        if (terminatedUpdater.compareAndSet(this, UNSET, PENDING)) {", "originalCommit": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwODI4Mg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367008282", "bodyText": "If there are pending writes, we should not prematurely terminate the promise but wait for the promise results which will fail if the channel closed before writes were done. The following would be reasonable to do:\nvoid channelClosed(Throwable cause) {\n    assert eventLoop.inEventLoop();\n    if (hasFlag(CHANNEL_CLOSED)) {\n        return;\n    }\n    if (hasFlag(SUBSCRIBER_TERMINATED)) {\n        setFlag(CHANNEL_CLOSED);\n        // We have already terminated the subscriber (all writes have finished (one has failed)) then we\n        // just close the channel now.\n        closeHandler.closeChannelOutbound(channel);\n    } else if (activeWrites > 0) {\n        // Writes are pending, we will close the channel once writes are done.\n        setFlag(CLOSE_OUTBOUND_ON_SUBSCRIBER_TERMINATION);\n    } else {\n        setFlag(CHANNEL_CLOSED);\n        // subscriber has not terminated, no writes are pending and channel has closed so terminate the\n        // subscriber with a failure.\n        tryFailure(!written ? new AbortedFirstWrite(cause) : cause);\n    }\n}", "author": "NiteshKant", "createdAt": "2020-01-15T17:29:09Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -307,28 +306,13 @@ void sourceTerminated(@Nullable Throwable cause) {\n \n         void channelClosed(Throwable cause) {\n             assert eventLoop.inEventLoop();\n-            if (hasFlag(CHANNEL_CLOSED) || hasFlag(SUBSCRIBER_TERMINATED)) {\n+            if (hasAnyFlags(CHANNEL_CLOSED, SUBSCRIBER_TERMINATED)) {\n                 setFlag(CHANNEL_CLOSED);\n                 return;\n             }\n             tryFailure(!written ? new AbortedFirstWrite(cause) : cause);", "originalCommit": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwOTU1OA==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367009558", "bodyText": "This will be reverted if we update the channelClosed() method.", "author": "NiteshKant", "createdAt": "2020-01-15T17:31:39Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -391,7 +375,7 @@ private boolean setFailure0(Throwable cause) {\n         }\n \n         private void terminateSubscriber(@Nullable Throwable cause) {\n-            if (hasFlag(CLOSE_OUTBOUND_ON_SUBSCRIBER_TERMINATION) || cause != null) {", "originalCommit": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwOTc4Mg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367009782", "bodyText": "Maybe just call this method close() now?", "author": "NiteshKant", "createdAt": "2020-01-15T17:32:05Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -307,28 +306,13 @@ void sourceTerminated(@Nullable Throwable cause) {\n \n         void channelClosed(Throwable cause) {", "originalCommit": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c23deea36eca9a6c7e46420dfedb4678de69487", "url": "https://github.com/apple/servicetalk/commit/7c23deea36eca9a6c7e46420dfedb4678de69487", "message": "Address comments", "committedDate": "2020-01-15T19:22:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MTUwNw==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367091507", "bodyText": "is event is => event is", "author": "NiteshKant", "createdAt": "2020-01-15T20:30:14Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -459,6 +458,16 @@ public FlushStrategy defaultFlushStrategy() {\n          */\n         void channelWritable();\n \n+        /**\n+         * Close the channel after the pending writes complete.\n+         *\n+         * <p>\n+         * Calling {@link #close(Throwable)} after {@link #closeGracefully()} will be ignored.\n+         * <p>\n+         * This is event is expected be called from the eventloop.", "originalCommit": "7c23deea36eca9a6c7e46420dfedb4678de69487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MTkxMw==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367091913", "bodyText": "Also log the result?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.error(\"Failed to write data after permature close of the WriteListener.\");\n          \n          \n            \n                        LOGGER.error(\"Ignoring write {} as the listener is already closed.\", result);", "author": "NiteshKant", "createdAt": "2020-01-15T20:31:09Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -51,21 +58,29 @@ public void onSubscribe(Cancellable cancellable) {\n \n     @Override\n     public void onSuccess(@Nullable Object result) {\n-        // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n-        // ordering should be correct.\n-        channel.writeAndFlush(result).addListener(future -> {\n-            Throwable cause = future.cause();\n-            if (cause == null) {\n-                notifyComplete();\n-            } else {\n-                notifyError(cause);\n-            }\n-        });\n+        if (terminatedUpdater.compareAndSet(this, AWAITING_RESULT, TERMINATED)) {\n+            // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n+            // ordering should be correct.\n+            channel.writeAndFlush(result).addListener(future -> {\n+                Throwable cause = future.cause();\n+                if (cause == null) {\n+                    notifyComplete();\n+                } else {\n+                    notifyError(cause);\n+                }\n+            });\n+        } else {\n+            LOGGER.error(\"Failed to write data after permature close of the WriteListener.\");", "originalCommit": "7c23deea36eca9a6c7e46420dfedb4678de69487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MjcyNg==", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367092726", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.error(\"Failed to fail subscriber after permature close of the WriteListener.\");\n          \n          \n            \n                        LOGGER.error(\"Ignoring emitted error as the listener is already closed.\", t);", "author": "NiteshKant", "createdAt": "2020-01-15T20:33:03Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -51,21 +58,29 @@ public void onSubscribe(Cancellable cancellable) {\n \n     @Override\n     public void onSuccess(@Nullable Object result) {\n-        // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n-        // ordering should be correct.\n-        channel.writeAndFlush(result).addListener(future -> {\n-            Throwable cause = future.cause();\n-            if (cause == null) {\n-                notifyComplete();\n-            } else {\n-                notifyError(cause);\n-            }\n-        });\n+        if (terminatedUpdater.compareAndSet(this, AWAITING_RESULT, TERMINATED)) {\n+            // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n+            // ordering should be correct.\n+            channel.writeAndFlush(result).addListener(future -> {\n+                Throwable cause = future.cause();\n+                if (cause == null) {\n+                    notifyComplete();\n+                } else {\n+                    notifyError(cause);\n+                }\n+            });\n+        } else {\n+            LOGGER.error(\"Failed to write data after permature close of the WriteListener.\");\n+        }\n     }\n \n     @Override\n     public void onError(Throwable t) {\n-        notifyError(t);\n+        if (terminatedUpdater.compareAndSet(this, AWAITING_RESULT, TERMINATED)) {\n+            notifyError(t);\n+        } else {\n+            LOGGER.error(\"Failed to fail subscriber after permature close of the WriteListener.\");", "originalCommit": "7c23deea36eca9a6c7e46420dfedb4678de69487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a0292a13c235d28f1a4c7532afdf550e58481d0", "url": "https://github.com/apple/servicetalk/commit/1a0292a13c235d28f1a4c7532afdf550e58481d0", "message": "Update servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java\n\nCo-Authored-By: Nitesh Kant <nitesh_kant@apple.com>", "committedDate": "2020-01-15T20:42:42Z", "type": "commit"}, {"oid": "84acbf132acbba65dc3abbcdd32ef391882af09a", "url": "https://github.com/apple/servicetalk/commit/84acbf132acbba65dc3abbcdd32ef391882af09a", "message": "Update servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java\n\nCo-Authored-By: Nitesh Kant <nitesh_kant@apple.com>", "committedDate": "2020-01-15T20:43:35Z", "type": "commit"}, {"oid": "7850d12c831f5871aceda6ca01b1fb6002b0b187", "url": "https://github.com/apple/servicetalk/commit/7850d12c831f5871aceda6ca01b1fb6002b0b187", "message": "Address comments", "committedDate": "2020-01-15T20:44:15Z", "type": "commit"}]}