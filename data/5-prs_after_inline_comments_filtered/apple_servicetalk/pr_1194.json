{"pr_number": 1194, "pr_title": "Http URI related fixes and enhancements", "pr_createdAt": "2020-10-27T00:36:27Z", "pr_url": "https://github.com/apple/servicetalk/pull/1194", "timeline": [{"oid": "3076cc5861e284f8fc180edb60583914bb573e07", "url": "https://github.com/apple/servicetalk/commit/3076cc5861e284f8fc180edb60583914bb573e07", "message": "Http URI related fixes and enhancements\n\nMotivation:\nJersey's ContainerRequest requires that an API be encoded properly\nbefore processing. The user agent is expected to do the encoding [1] but\nnot all user agents do, so we attempt to encode on the server for.\nconvenience. However the method we used to encode the URI is an internal\nmethod to Jersey and doesn't cover the full scope of encoding defined in\nrfc3986 [1]. The JDK's URI class also targets an obsolete rfc2396 [2]\nand the JDK's URLEncoder class provides\napplication/x-www-form-urlencoded which is also not what we need.\n\nModifications:\n- Modify HttpUri to validate RFC 3986 semantics, extract out the host\nextraction from headers code outside the scope of this class. This\nsimplifies the logic within the Uri implementation and makes it easier\nto validate against the RFC.\n- Introduce an implementation of Uri that targets authority-form URIs\ntargeted specifically for CONNECT requests [3].\n- Introduce 3 new filters. 1 to encode the request target on the client.\n1 to decode the request target on the server. 1 to encode the request\ntarget on the server (which can be used to replicate existing behavior\nwhere Jersey is feed an encoded URI).\n- Update DefaultHttpRequestMetaData so that effective host/port doesn't\nbecome stale if the port value in the host header changes.\n\nResult:\nUri handling follows the RFC [1] and encoding/decoding can be optionally\napplied via a filter if desired.\n\n[1] https://tools.ietf.org/html/rfc3986\n[2] https://tools.ietf.org/html/rfc2396\n[3] https://tools.ietf.org/html/rfc7230#section-5.3.3", "committedDate": "2020-10-28T00:19:14Z", "type": "commit"}, {"oid": "3076cc5861e284f8fc180edb60583914bb573e07", "url": "https://github.com/apple/servicetalk/commit/3076cc5861e284f8fc180edb60583914bb573e07", "message": "Http URI related fixes and enhancements\n\nMotivation:\nJersey's ContainerRequest requires that an API be encoded properly\nbefore processing. The user agent is expected to do the encoding [1] but\nnot all user agents do, so we attempt to encode on the server for.\nconvenience. However the method we used to encode the URI is an internal\nmethod to Jersey and doesn't cover the full scope of encoding defined in\nrfc3986 [1]. The JDK's URI class also targets an obsolete rfc2396 [2]\nand the JDK's URLEncoder class provides\napplication/x-www-form-urlencoded which is also not what we need.\n\nModifications:\n- Modify HttpUri to validate RFC 3986 semantics, extract out the host\nextraction from headers code outside the scope of this class. This\nsimplifies the logic within the Uri implementation and makes it easier\nto validate against the RFC.\n- Introduce an implementation of Uri that targets authority-form URIs\ntargeted specifically for CONNECT requests [3].\n- Introduce 3 new filters. 1 to encode the request target on the client.\n1 to decode the request target on the server. 1 to encode the request\ntarget on the server (which can be used to replicate existing behavior\nwhere Jersey is feed an encoded URI).\n- Update DefaultHttpRequestMetaData so that effective host/port doesn't\nbecome stale if the port value in the host header changes.\n\nResult:\nUri handling follows the RFC [1] and encoding/decoding can be optionally\napplied via a filter if desired.\n\n[1] https://tools.ietf.org/html/rfc3986\n[2] https://tools.ietf.org/html/rfc2396\n[3] https://tools.ietf.org/html/rfc7230#section-5.3.3", "committedDate": "2020-10-28T00:19:14Z", "type": "forcePushed"}, {"oid": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "url": "https://github.com/apple/servicetalk/commit/c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "message": "cache decoded path/query. avoid string decode if no % char", "committedDate": "2020-10-29T01:47:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMzQ0Nw==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514433447", "bodyText": "The rawQuery variant takes a @Nullable string, should this param also be @Nullable for consistency?", "author": "idelpivnitskiy", "createdAt": "2020-10-29T17:19:54Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpRequestMetaData.java", "diffHunk": "@@ -186,7 +225,16 @@\n      * @param query the encoded query to set.\n      * @return {@code this}.\n      */\n-    HttpRequestMetaData rawQuery(String query);\n+    HttpRequestMetaData rawQuery(@Nullable String query);\n+\n+    /**\n+     * Sets the path, performing encoding according\n+     * to <a href=\"https://tools.ietf.org/html/rfc3986#section-3.4\">rfc3986, Query</a>.\n+     *\n+     * @param query the un-encoded query to set.\n+     * @return {@code this}.\n+     */\n+    HttpRequestMetaData query(String query);", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxMjEwMQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515212101", "bodyText": "sure, done", "author": "Scottmitch", "createdAt": "2020-10-30T16:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMzQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzNDExMw==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514434113", "bodyText": "Consider clarifying in javadoc what null param means", "author": "idelpivnitskiy", "createdAt": "2020-10-29T17:20:58Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpRequestMetaData.java", "diffHunk": "@@ -186,7 +225,16 @@\n      * @param query the encoded query to set.\n      * @return {@code this}.\n      */\n-    HttpRequestMetaData rawQuery(String query);\n+    HttpRequestMetaData rawQuery(@Nullable String query);", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIxMjEzOA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515212138", "bodyText": "done", "author": "Scottmitch", "createdAt": "2020-10-30T16:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzNDExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzNzcwOQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514437709", "bodyText": "Consider clarifying in which case users may get null here", "author": "idelpivnitskiy", "createdAt": "2020-10-29T17:26:17Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpRequestMetaData.java", "diffHunk": "@@ -358,22 +406,45 @@ default boolean hasQueryParameter(final String key) {\n      * The <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.2\">host component</a> derived\n      * from {@link #requestTarget()} and the {@code Host} header field value. This is the scheme component to use\n      * when computing an <a href=\"https://tools.ietf.org/html/rfc7230#section-5.5\">effective request URI</a>.\n-     *\n+     * <p>\n+     * @deprecated Use {@link #effectiveHostAndPort()}.\n      * @return The <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.2\">host component</a> derived\n      * from {@link #requestTarget()} and the {@code Host} header field value, or {@code null} if none can be derived.\n      */\n+    @Deprecated\n     @Nullable\n-    String effectiveHost();\n+    default String effectiveHost() {\n+        HostAndPort hostAndPort = effectiveHostAndPort();\n+        return hostAndPort == null ? null : hostAndPort.hostName();\n+    }\n \n     /**\n      * The <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.3\">port component</a> derived\n      * from {@link #requestTarget()} and the {@code Host} header field value. This is the scheme component to use\n      * when computing an <a href=\"https://tools.ietf.org/html/rfc7230#section-5.5\">effective request URI</a>.\n-     *\n+     * <p>\n+     * @deprecated Use {@link #effectiveHostAndPort()}.\n      * @return The <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.3\">port component</a> derived\n      * from {@link #requestTarget()}, and the {@code Host} header field value, or {@code <0} if none can be derived.\n      */\n-    int effectivePort();\n+    @Deprecated\n+    default int effectivePort() {\n+        HostAndPort hostAndPort = effectiveHostAndPort();\n+        return hostAndPort == null ? -1 : hostAndPort.port();\n+    }\n+\n+    /**\n+     * Get the <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.2\">host</a> and\n+     * <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.3\">port</a> components\n+     * of the <a href=\"https://tools.ietf.org/html/rfc7230#section-5.5\">effective request URI</a>.\n+     * The port component will be {@code <0} if none can be derived.\n+     *\n+     * @return The <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.2\">host</a> and\n+     * <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.3\">port</a> components\n+     * of the <a href=\"https://tools.ietf.org/html/rfc7230#section-5.5\">effective request URI</a>.", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQwOTcyNQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515409725", "bodyText": "done", "author": "Scottmitch", "createdAt": "2020-10-30T22:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzNzcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzOTAwMQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514439001", "bodyText": "I think it was helpful to know that the \"effective\" variant considers both requestTarget() and the Host header field value.", "author": "idelpivnitskiy", "createdAt": "2020-10-29T17:28:21Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpRequestMetaData.java", "diffHunk": "@@ -358,22 +406,45 @@ default boolean hasQueryParameter(final String key) {\n      * The <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.2\">host component</a> derived\n      * from {@link #requestTarget()} and the {@code Host} header field value. This is the scheme component to use\n      * when computing an <a href=\"https://tools.ietf.org/html/rfc7230#section-5.5\">effective request URI</a>.\n-     *\n+     * <p>\n+     * @deprecated Use {@link #effectiveHostAndPort()}.\n      * @return The <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.2\">host component</a> derived\n      * from {@link #requestTarget()} and the {@code Host} header field value, or {@code null} if none can be derived.\n      */\n+    @Deprecated\n     @Nullable\n-    String effectiveHost();\n+    default String effectiveHost() {\n+        HostAndPort hostAndPort = effectiveHostAndPort();\n+        return hostAndPort == null ? null : hostAndPort.hostName();\n+    }\n \n     /**\n      * The <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.3\">port component</a> derived\n      * from {@link #requestTarget()} and the {@code Host} header field value. This is the scheme component to use\n      * when computing an <a href=\"https://tools.ietf.org/html/rfc7230#section-5.5\">effective request URI</a>.\n-     *\n+     * <p>\n+     * @deprecated Use {@link #effectiveHostAndPort()}.\n      * @return The <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.3\">port component</a> derived\n      * from {@link #requestTarget()}, and the {@code Host} header field value, or {@code <0} if none can be derived.\n      */\n-    int effectivePort();\n+    @Deprecated\n+    default int effectivePort() {\n+        HostAndPort hostAndPort = effectiveHostAndPort();\n+        return hostAndPort == null ? -1 : hostAndPort.port();\n+    }\n+\n+    /**\n+     * Get the <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.2\">host</a> and\n+     * <a href=\"https://tools.ietf.org/html/rfc3986#section-3.2.3\">port</a> components\n+     * of the <a href=\"https://tools.ietf.org/html/rfc7230#section-5.5\">effective request URI</a>.", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQwOTczOA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515409738", "bodyText": "done", "author": "Scottmitch", "createdAt": "2020-10-30T22:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzOTAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0NjU0Ng==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514446546", "bodyText": "Should we allow configuring max query params value?", "author": "idelpivnitskiy", "createdAt": "2020-10-29T17:39:41Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/FormUrlEncodedHttpDeserializer.java", "diffHunk": "@@ -102,6 +105,12 @@ public boolean hasNext() {\n         if (buffer == null || buffer.readableBytes() == 0) {\n             return emptyMap();\n         }\n-        return decodeParams(buffer.toString(charset), charset);\n+        return decodeQueryParams(buffer.toString(charset), charset, DEFAULT_MAX_QUERY_PARAMS, (value, charset) -> {", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxMDU5Ng==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515410596", "bodyText": "lets consider this for a followup PR.", "author": "Scottmitch", "createdAt": "2020-10-30T22:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0NjU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0OTkwNw==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514449907", "bodyText": "It may be hard to debug the reason why some of the query params (consider POST request with form-url body) are missed. Consider throwing an exception or logging at warn level (logging may be hard to correlate with request object).", "author": "idelpivnitskiy", "createdAt": "2020-10-29T17:44:59Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/UriUtils.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import javax.annotation.Nullable;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+\n+final class UriUtils {\n+    // https://tools.ietf.org/html/rfc3986 declares that all delimiter/terminal values are US-ASCII\n+    // https://tools.ietf.org/html/rfc3986#section-2. This means values fall within the [0, 127] range. This range\n+    // can be represented as a bitset/bitmask with two longs (high, low), which reduces the amount of conditional\n+    // statements required to validate characters belonging to each character class. The following final variables\n+    // provide the bitmask for the different character classes defined in rfc3986, and isBitSet can be used to verify if\n+    // a bit is set for a particular (high, low) mask pair.\n+    //\n+    // pct-encoded is omitted below. This criteria is asserted outside this scope because it requires checking multiple\n+    // bytes and advancing the loop index accordingly.\n+\n+    private static final long DIGIT_LMASK = lowMask('0', '9');\n+    private static final long DIGIT_HMASK = highMask('0', '9');\n+\n+    private static final long ALPHA_LMASK = lowMask('a', 'z') | lowMask('A', 'Z');\n+    private static final long ALPHA_HMASK = highMask('a', 'z') | highMask('A', 'Z');\n+\n+    private static final long HEXDIG_LMASK = DIGIT_LMASK | lowMask('a', 'f') | lowMask('A', 'F');\n+    private static final long HEXDIG_HMASK = DIGIT_HMASK | highMask('a', 'f') | highMask('A', 'F');\n+\n+    // unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n+    private static final long UNRESERVED_LMASK = ALPHA_LMASK | DIGIT_LMASK | lowMask(\"-._~\");\n+    private static final long UNRESERVED_HMASK = ALPHA_HMASK | DIGIT_HMASK | highMask(\"-._~\");\n+\n+    // sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n+    //                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n+    private static final long SUBDELIM_LMASK = lowMask(\"!$&'()*+,;=\");\n+    private static final long SUBDELIM_HMASK = highMask(\"!$&'()*+,;=\");\n+\n+    // pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n+    private static final long PCHAR_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\";@\");\n+\n+    private static final long PCHAR_NOSUBDELIM_LMASK = UNRESERVED_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_NOSUBDELIM_HMASK = UNRESERVED_HMASK | highMask(\";@\");\n+\n+    // userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n+    static final long USERINFO_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\":\");\n+    static final long USERINFO_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\":\");\n+\n+    // path        = *(pchar / \"/\")\n+    static final long PATH_LMASK = PCHAR_LMASK | lowMask(\"/\");\n+    static final long PATH_HMASK = PCHAR_HMASK | highMask(\"/\");\n+\n+    static final long PATH_SEGMENT_LMASK = PCHAR_LMASK;\n+    static final long PATH_SEGMENT_HMASK = PCHAR_HMASK;\n+\n+    // query       = *( pchar / \"/\" / \"?\" )\n+    static final long QUERY_LMASK = PCHAR_LMASK | lowMask(\"/?\");\n+    static final long QUERY_HMASK = PCHAR_HMASK | highMask(\"/?\");\n+\n+    static final long QUERY_VALUE_LMASK = PCHAR_NOSUBDELIM_LMASK | lowMask(\"/?\");\n+    static final long QUERY_VALUE_HMASK = PCHAR_NOSUBDELIM_HMASK | highMask(\"/?\");\n+\n+    // fragment    = *( pchar / \"/\" / \"?\" )\n+    static final long FRAGMENT_LMASK = QUERY_LMASK;\n+    static final long FRAGMENT_HMASK = QUERY_HMASK;\n+\n+    // host        = IP-literal / IPv4address / reg-name\n+    // reg-name    = *( unreserved / pct-encoded / sub-delims )\n+    static final long HOST_NON_IP_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK;\n+    static final long HOST_NON_IP_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK;\n+\n+    private UriUtils() {\n+    }\n+\n+    /**\n+     * Decode the specified raw query with the specified {@code charset} for the specified maximum number of parameters.\n+     */\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams) {\n+        return decodeQueryParams(rawQuery, charset, maxParams, UriUtils::decodeComponent);\n+    }\n+\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams,\n+                                                       BiFunction<String, Charset, String> decoder) {\n+        if (maxParams <= 0) {\n+            throw new IllegalArgumentException(\"maxParams: \" + maxParams + \" (expected: > 0)\");\n+        }\n+\n+        if (rawQuery == null || rawQuery.isEmpty()) {\n+            return new LinkedHashMap<>(2);\n+        }\n+\n+        final Map<String, List<String>> params = new LinkedHashMap<>();\n+        int paramCountDown = maxParams;\n+        final int from = rawQuery.charAt(0) == '?' ? 1 : 0;\n+        final int len = rawQuery.length();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        loop:\n+        for (i = from; i < len; i++) {\n+            switch (rawQuery.charAt(i)) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case '&':\n+                case ';':\n+                    if (addQueryParam(rawQuery, nameStart, valueStart, i, charset, params, decoder)) {\n+                        paramCountDown--;\n+                        if (paramCountDown == 0) {\n+                            return params;", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjEwMTI2NQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r516101265", "bodyText": "this was pre-existing but I agree and will change to throwing an exception.", "author": "Scottmitch", "createdAt": "2020-11-02T16:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0OTkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NTEzNg==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514455136", "bodyText": "The preservePctEncoding param is always true, is it necessary?\nIf it makes sense to keep it for future, consider adding a private overload with the 3rd parameter, but exposing an overload without it for pkg-private scope.", "author": "idelpivnitskiy", "createdAt": "2020-10-29T17:52:36Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpAuthorityFormUri.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.nio.charset.Charset;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.UriComponentType.HOST_NON_IP;\n+import static io.servicetalk.http.api.UriUtils.decodeComponent;\n+import static io.servicetalk.http.api.UriUtils.encodeComponent;\n+import static io.servicetalk.http.api.UriUtils.parsePort;\n+\n+/**\n+ * <a href=\"https://tools.ietf.org/html/rfc7230#section-5.3.3\">authority-form</a> URI.\n+ */\n+final class HttpAuthorityFormUri implements Uri {\n+    private final String uri;\n+    private final String host;\n+    private final int port;\n+\n+    HttpAuthorityFormUri(final String uri) {\n+        int i = 0;\n+        int begin = 0;\n+        String parsedHost = null;\n+        int parsedPort = -1;\n+        byte parsingIPv6 = 0; // 0 = not parsed, 1 = parsing, 2 = already parsed\n+        boolean foundColonForPort = false;\n+        while (i < uri.length()) {\n+            final char c = uri.charAt(i);\n+            if (c == '[') {\n+                if (parsingIPv6 != 0 || parsedHost != null) {\n+                    throw new IllegalArgumentException(\"unexpected [\");\n+                }\n+                parsingIPv6 = 1;\n+                begin = i++; // post increment, preserve the '[' for original uri for pathEndIndex.\n+            } else if (c == ']') {\n+                if (parsingIPv6 == 0) {\n+                    throw new IllegalArgumentException(\"unexpected ]\");\n+                } else if (i - 1 <= begin) {\n+                    throw new IllegalArgumentException(\"empty ip literal\");\n+                }\n+                // Copy the '[' and ']' characters. pathEndIndex depends upon retaining the uri contents.\n+                parsedHost = uri.substring(begin, i + 1);\n+                foundColonForPort = false;\n+                parsingIPv6 = 2;\n+                begin = ++i;\n+            } else if (c == ':') {\n+                if (parsingIPv6 == 0) {\n+                    if (parsedHost != null) {\n+                        throw new IllegalArgumentException(\"duplicate/invalid host\");\n+                    }\n+                    parsedHost = uri.substring(begin, i);\n+                }\n+                ++i;\n+                if (parsingIPv6 != 1) {\n+                    begin = i;\n+                    foundColonForPort = true;\n+                }\n+            } else if (c == '@' || c == '?' || c == '#' || c == '/') {\n+                throw new IllegalArgumentException(\"authority-form URI doesn't allow userinfo, path, query, fragment\");\n+            } else {\n+                ++i;\n+            }\n+        }\n+\n+        if (parsedHost == null) {\n+            if (parsingIPv6 == 1) {\n+                throw new IllegalArgumentException(\"missing closing ] for IP-literal\");\n+            }\n+            parsedHost = uri;\n+        } else if (foundColonForPort) {\n+            parsedPort = parsePort(uri, begin, uri.length());\n+        } else if (parsedHost.length() != uri.length()) {\n+            throw new IllegalArgumentException(\"authority-form URI only supports the host component\");\n+        }\n+\n+        host = parsedHost;\n+        port = parsedPort;\n+        this.uri = uri;\n+    }\n+\n+    @Override\n+    public String uri() {\n+        return uri;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String scheme() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String authority() {\n+        StringBuilder sb = new StringBuilder(host.length() + 6); // 6 max port chars + `:`\n+        sb.append(host);\n+        if (port >= 0) {\n+            sb.append(':').append(port);\n+        }\n+        return sb.toString();\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String userInfo() {\n+        return null;\n+    }\n+\n+    @Override\n+    public String host() {\n+        return host;\n+    }\n+\n+    @Override\n+    public int port() {\n+        return port;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public String path(final Charset charset) {\n+        return \"\";\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String query() {\n+        return null;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String query(final Charset charset) {\n+        return null;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String fragment() {\n+        return null;\n+    }\n+\n+    static String encode(String requestTarget, Charset charset, boolean preservePctEncoding) {", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxNDYxMQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515414611", "bodyText": "I can remove it for now at this level", "author": "Scottmitch", "createdAt": "2020-10-30T22:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NTEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxNTE0MA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514515140", "bodyText": "Consider also including the parsedHostHeader value in the msg.", "author": "idelpivnitskiy", "createdAt": "2020-10-29T19:34:16Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -269,78 +383,131 @@ public boolean removeQueryParameters(final String key, final String value) {\n         return lazyParseQueryString().remove(key, value);\n     }\n \n-    @Nullable\n-    @Override\n-    public final String effectiveHost() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestHost;\n-    }\n-\n     @Override\n-    public final int effectivePort() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestPort;\n+    public HostAndPort effectiveHostAndPort() {\n+        final CharSequence hostHeader;\n+        final Uri effectiveRequestUri = lazyParseRequestTarget();\n+        final String effectiveRequestUriHost = effectiveRequestUri.host();\n+        if (effectiveRequestUriHost != null) {\n+            return HostAndPort.of(effectiveRequestUriHost, effectiveRequestUri.port());\n+        } else if ((hostHeader = headers().get(HOST)) != null) {\n+            return parseHostHeader(hostHeader.toString());\n+        }\n+        return null;\n     }\n \n     private HttpQuery lazyParseQueryString() {\n         if (httpQuery == null) {\n-            httpQuery = new HttpQuery(decodeParams(lazyParseRequestTarget().rawQuery()), this::setQueryParams);\n+            httpQuery = new HttpQuery(decodeQueryParams(lazyParseRequestTarget().query(),\n+                    REQUEST_TARGET_CHARSET, DEFAULT_MAX_QUERY_PARAMS), this::setQueryParams);\n         }\n         return httpQuery;\n     }\n \n-    private HttpUri lazyParseRequestTarget() {\n+    private Uri lazyParseRequestTarget() {\n         if (requestTargetUri == null) {\n-            requestTargetUri = new HttpUri(requestTarget());\n+            requestTargetUri = CONNECT.equals(method) ? new HttpAuthorityFormUri(requestTarget()) :\n+                    new Uri3986(requestTarget());\n         }\n         return requestTargetUri;\n     }\n \n-    private void lazyParseEffectiveRequest() {\n-        final CharSequence hostHeader = headers().get(HOST);\n-\n-        if (effectiveRequestPort == PORT_NOT_ASSIGNED || !Objects.equals(hostHeader, effectiveRequestHostHeader)) {\n-            final HttpUri effectiveRequestUri = new HttpUri(requestTarget(),\n-                    () -> hostHeader != null ? hostHeader.toString() : null);\n-            effectiveRequestHost = effectiveRequestUri.host();\n-            effectiveRequestPort = effectiveRequestUri.explicitPort();\n-            effectiveRequestHostHeader = hostHeader;\n+    private static HostAndPort parseHostHeader(String parsedHostHeader) {\n+        String parsedHost;\n+        int parsedPort = -1;\n+        final int x = parsedHostHeader.lastIndexOf(':');\n+        if (x > 0) {\n+            final int y = parsedHostHeader.lastIndexOf(':', x - 1);\n+            if (y >= 0) {\n+                // IPv6 address is present in the header\n+                // https://tools.ietf.org/html/rfc3986#section-3.2.2\n+                // A host identified by an Internet Protocol literal address, version 6\n+                // [RFC3513] or later, is distinguished by enclosing the IP literal\n+                // within square brackets (\"[\" and \"]\").  This is the only place where\n+                // square bracket characters are allowed in the URI syntax.\n+                final int cb;\n+                if (parsedHostHeader.charAt(0) != '[' || (cb = parsedHostHeader.lastIndexOf(']')) < 0) {\n+                    throw new IllegalArgumentException(\"IPv6 address should be in square brackets\");\n+                }\n+                if (cb < x) {\n+                    parsedHost = parsedHostHeader.substring(0, x);\n+                    parsedPort = parsePort(parsedHostHeader, x + 1, parsedHostHeader.length());\n+                } else if (cb != parsedHostHeader.length() - 1) {\n+                    throw new IllegalArgumentException(\n+                            \"']' should be at the end of IPv6 address or before port number\");\n+                } else {\n+                    parsedHost = parsedHostHeader;\n+                }\n+            } else {\n+                // IPv4 or literal host with port number\n+                parsedHost = parsedHostHeader.substring(0, x);\n+                parsedPort = parsePort(parsedHostHeader, x + 1, parsedHostHeader.length());\n+            }\n+        } else if (x < 0) {\n+            parsedHost = parsedHostHeader;\n+        } else {\n+            throw new IllegalArgumentException(\"Illegal position of colon in the host header\");", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxNTMyMg==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515415322", "bodyText": "lets consider for followup PR. I'm hesitant to include user data in exceptions this is pre-existing code", "author": "Scottmitch", "createdAt": "2020-10-30T22:54:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxNTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4NzM5NA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514587394", "bodyText": "Consider providing a port number in the message and the expected values", "author": "idelpivnitskiy", "createdAt": "2020-10-29T21:47:53Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/UriUtils.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import javax.annotation.Nullable;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+\n+final class UriUtils {\n+    // https://tools.ietf.org/html/rfc3986 declares that all delimiter/terminal values are US-ASCII\n+    // https://tools.ietf.org/html/rfc3986#section-2. This means values fall within the [0, 127] range. This range\n+    // can be represented as a bitset/bitmask with two longs (high, low), which reduces the amount of conditional\n+    // statements required to validate characters belonging to each character class. The following final variables\n+    // provide the bitmask for the different character classes defined in rfc3986, and isBitSet can be used to verify if\n+    // a bit is set for a particular (high, low) mask pair.\n+    //\n+    // pct-encoded is omitted below. This criteria is asserted outside this scope because it requires checking multiple\n+    // bytes and advancing the loop index accordingly.\n+\n+    private static final long DIGIT_LMASK = lowMask('0', '9');\n+    private static final long DIGIT_HMASK = highMask('0', '9');\n+\n+    private static final long ALPHA_LMASK = lowMask('a', 'z') | lowMask('A', 'Z');\n+    private static final long ALPHA_HMASK = highMask('a', 'z') | highMask('A', 'Z');\n+\n+    private static final long HEXDIG_LMASK = DIGIT_LMASK | lowMask('a', 'f') | lowMask('A', 'F');\n+    private static final long HEXDIG_HMASK = DIGIT_HMASK | highMask('a', 'f') | highMask('A', 'F');\n+\n+    // unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n+    private static final long UNRESERVED_LMASK = ALPHA_LMASK | DIGIT_LMASK | lowMask(\"-._~\");\n+    private static final long UNRESERVED_HMASK = ALPHA_HMASK | DIGIT_HMASK | highMask(\"-._~\");\n+\n+    // sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n+    //                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n+    private static final long SUBDELIM_LMASK = lowMask(\"!$&'()*+,;=\");\n+    private static final long SUBDELIM_HMASK = highMask(\"!$&'()*+,;=\");\n+\n+    // pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n+    private static final long PCHAR_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\";@\");\n+\n+    private static final long PCHAR_NOSUBDELIM_LMASK = UNRESERVED_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_NOSUBDELIM_HMASK = UNRESERVED_HMASK | highMask(\";@\");\n+\n+    // userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n+    static final long USERINFO_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\":\");\n+    static final long USERINFO_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\":\");\n+\n+    // path        = *(pchar / \"/\")\n+    static final long PATH_LMASK = PCHAR_LMASK | lowMask(\"/\");\n+    static final long PATH_HMASK = PCHAR_HMASK | highMask(\"/\");\n+\n+    static final long PATH_SEGMENT_LMASK = PCHAR_LMASK;\n+    static final long PATH_SEGMENT_HMASK = PCHAR_HMASK;\n+\n+    // query       = *( pchar / \"/\" / \"?\" )\n+    static final long QUERY_LMASK = PCHAR_LMASK | lowMask(\"/?\");\n+    static final long QUERY_HMASK = PCHAR_HMASK | highMask(\"/?\");\n+\n+    static final long QUERY_VALUE_LMASK = PCHAR_NOSUBDELIM_LMASK | lowMask(\"/?\");\n+    static final long QUERY_VALUE_HMASK = PCHAR_NOSUBDELIM_HMASK | highMask(\"/?\");\n+\n+    // fragment    = *( pchar / \"/\" / \"?\" )\n+    static final long FRAGMENT_LMASK = QUERY_LMASK;\n+    static final long FRAGMENT_HMASK = QUERY_HMASK;\n+\n+    // host        = IP-literal / IPv4address / reg-name\n+    // reg-name    = *( unreserved / pct-encoded / sub-delims )\n+    static final long HOST_NON_IP_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK;\n+    static final long HOST_NON_IP_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK;\n+\n+    private UriUtils() {\n+    }\n+\n+    /**\n+     * Decode the specified raw query with the specified {@code charset} for the specified maximum number of parameters.\n+     */\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams) {\n+        return decodeQueryParams(rawQuery, charset, maxParams, UriUtils::decodeComponent);\n+    }\n+\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams,\n+                                                       BiFunction<String, Charset, String> decoder) {\n+        if (maxParams <= 0) {\n+            throw new IllegalArgumentException(\"maxParams: \" + maxParams + \" (expected: > 0)\");\n+        }\n+\n+        if (rawQuery == null || rawQuery.isEmpty()) {\n+            return new LinkedHashMap<>(2);\n+        }\n+\n+        final Map<String, List<String>> params = new LinkedHashMap<>();\n+        int paramCountDown = maxParams;\n+        final int from = rawQuery.charAt(0) == '?' ? 1 : 0;\n+        final int len = rawQuery.length();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        loop:\n+        for (i = from; i < len; i++) {\n+            switch (rawQuery.charAt(i)) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case '&':\n+                case ';':\n+                    if (addQueryParam(rawQuery, nameStart, valueStart, i, charset, params, decoder)) {\n+                        paramCountDown--;\n+                        if (paramCountDown == 0) {\n+                            return params;\n+                        }\n+                    }\n+                    nameStart = i + 1;\n+                    break;\n+                case '#':\n+                    break loop;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addQueryParam(rawQuery, nameStart, valueStart, i, charset, params, decoder);\n+        return params;\n+    }\n+\n+    static String encodeComponent(UriComponentType type, String component, Charset charset,\n+                                  boolean preservePctEncoded) {\n+        byte[] bytes = component.getBytes(charset);\n+        for (int i = 0; i < bytes.length; ++i) {\n+            byte b = bytes[i];\n+            if (type.isValid(b)) {\n+                // noop\n+            } else if (preservePctEncoded && bytes.length - 3 >= i && isPctEncoded(bytes, b, i)) {\n+                i += 2; // only increment by 2 here, the for loop will increment 1 more\n+            } else {\n+                ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length + 16);\n+                baos.write(bytes, 0, i);\n+                encodeHexDigits(baos, b);\n+                for (int j = i + 1; j < bytes.length; ++j) {\n+                    b = bytes[j];\n+                    if (type.isValid(b)) {\n+                        baos.write(b);\n+                    } else if (preservePctEncoded && bytes.length - 3 >= j && isPctEncoded(bytes, b, j)) {\n+                        baos.write(bytes, j, 3);\n+                        j += 2; // only increment by 2 here, the for loop will increment 1 more\n+                    } else {\n+                        encodeHexDigits(baos, b);\n+                    }\n+                }\n+                return new String(baos.toByteArray(), charset);\n+            }\n+        }\n+        return component;\n+    }\n+\n+    static String decodeComponent(final String s, final Charset charset) {\n+        if (s.indexOf('%') < 0) {\n+            return s;\n+        }\n+        byte[] bytes = s.getBytes(charset);\n+        for (int i = 0; i < bytes.length; ++i) {\n+            byte b = bytes[i];\n+            if (b == '%') {\n+                ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length);\n+                baos.write(bytes, 0, i);\n+                baos.write(decodeHexDigits(bytes, i));\n+                for (int j = i + 3; j < bytes.length; ++j) {\n+                    b = bytes[j];\n+                    if (b == '%') {\n+                        baos.write(decodeHexDigits(bytes, j));\n+                        j += 2;\n+                    } else {\n+                        baos.write(b);\n+                    }\n+                }\n+                return new String(baos.toByteArray(), charset);\n+            }\n+        }\n+\n+        return s;\n+    }\n+\n+    static int parsePort(final String uri, final int begin, final int end) {\n+        final int len = end - begin;\n+        if (len == 4) {\n+            return (1000 * toDecimal(uri.charAt(begin))) +\n+                    (100 * toDecimal(uri.charAt(begin + 1))) +\n+                    (10 * toDecimal(uri.charAt(begin + 2))) +\n+                    toDecimal(uri.charAt(begin + 3));\n+        } else if (len == 3) {\n+            return (100 * toDecimal(uri.charAt(begin))) +\n+                    (10 * toDecimal(uri.charAt(begin + 1))) +\n+                    toDecimal(uri.charAt(begin + 2));\n+        } else if (len == 2) {\n+            return (10 * toDecimal(uri.charAt(begin))) +\n+                    toDecimal(uri.charAt(begin + 1));\n+        } else if (len == 5) {\n+            final int port = (10000 * toDecimal(uri.charAt(begin))) +\n+                    (1000 * toDecimal(uri.charAt(begin + 1))) +\n+                    (100 * toDecimal(uri.charAt(begin + 2))) +\n+                    (10 * toDecimal(uri.charAt(begin + 3))) +\n+                    toDecimal(uri.charAt(begin + 4));\n+            if (port > 65535) {\n+                throw new IllegalArgumentException(\"port out of bounds\");\n+            }\n+            return port;\n+        } else if (len == 1) {\n+            return toDecimal(uri.charAt(begin));\n+        } else {\n+            throw new IllegalArgumentException(\"invalid port\");", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4NzQ5NA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514587494", "bodyText": "Consider providing a port number in the message and the expected values", "author": "idelpivnitskiy", "createdAt": "2020-10-29T21:48:07Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/UriUtils.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import javax.annotation.Nullable;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+\n+final class UriUtils {\n+    // https://tools.ietf.org/html/rfc3986 declares that all delimiter/terminal values are US-ASCII\n+    // https://tools.ietf.org/html/rfc3986#section-2. This means values fall within the [0, 127] range. This range\n+    // can be represented as a bitset/bitmask with two longs (high, low), which reduces the amount of conditional\n+    // statements required to validate characters belonging to each character class. The following final variables\n+    // provide the bitmask for the different character classes defined in rfc3986, and isBitSet can be used to verify if\n+    // a bit is set for a particular (high, low) mask pair.\n+    //\n+    // pct-encoded is omitted below. This criteria is asserted outside this scope because it requires checking multiple\n+    // bytes and advancing the loop index accordingly.\n+\n+    private static final long DIGIT_LMASK = lowMask('0', '9');\n+    private static final long DIGIT_HMASK = highMask('0', '9');\n+\n+    private static final long ALPHA_LMASK = lowMask('a', 'z') | lowMask('A', 'Z');\n+    private static final long ALPHA_HMASK = highMask('a', 'z') | highMask('A', 'Z');\n+\n+    private static final long HEXDIG_LMASK = DIGIT_LMASK | lowMask('a', 'f') | lowMask('A', 'F');\n+    private static final long HEXDIG_HMASK = DIGIT_HMASK | highMask('a', 'f') | highMask('A', 'F');\n+\n+    // unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n+    private static final long UNRESERVED_LMASK = ALPHA_LMASK | DIGIT_LMASK | lowMask(\"-._~\");\n+    private static final long UNRESERVED_HMASK = ALPHA_HMASK | DIGIT_HMASK | highMask(\"-._~\");\n+\n+    // sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n+    //                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n+    private static final long SUBDELIM_LMASK = lowMask(\"!$&'()*+,;=\");\n+    private static final long SUBDELIM_HMASK = highMask(\"!$&'()*+,;=\");\n+\n+    // pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n+    private static final long PCHAR_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\";@\");\n+\n+    private static final long PCHAR_NOSUBDELIM_LMASK = UNRESERVED_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_NOSUBDELIM_HMASK = UNRESERVED_HMASK | highMask(\";@\");\n+\n+    // userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n+    static final long USERINFO_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\":\");\n+    static final long USERINFO_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\":\");\n+\n+    // path        = *(pchar / \"/\")\n+    static final long PATH_LMASK = PCHAR_LMASK | lowMask(\"/\");\n+    static final long PATH_HMASK = PCHAR_HMASK | highMask(\"/\");\n+\n+    static final long PATH_SEGMENT_LMASK = PCHAR_LMASK;\n+    static final long PATH_SEGMENT_HMASK = PCHAR_HMASK;\n+\n+    // query       = *( pchar / \"/\" / \"?\" )\n+    static final long QUERY_LMASK = PCHAR_LMASK | lowMask(\"/?\");\n+    static final long QUERY_HMASK = PCHAR_HMASK | highMask(\"/?\");\n+\n+    static final long QUERY_VALUE_LMASK = PCHAR_NOSUBDELIM_LMASK | lowMask(\"/?\");\n+    static final long QUERY_VALUE_HMASK = PCHAR_NOSUBDELIM_HMASK | highMask(\"/?\");\n+\n+    // fragment    = *( pchar / \"/\" / \"?\" )\n+    static final long FRAGMENT_LMASK = QUERY_LMASK;\n+    static final long FRAGMENT_HMASK = QUERY_HMASK;\n+\n+    // host        = IP-literal / IPv4address / reg-name\n+    // reg-name    = *( unreserved / pct-encoded / sub-delims )\n+    static final long HOST_NON_IP_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK;\n+    static final long HOST_NON_IP_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK;\n+\n+    private UriUtils() {\n+    }\n+\n+    /**\n+     * Decode the specified raw query with the specified {@code charset} for the specified maximum number of parameters.\n+     */\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams) {\n+        return decodeQueryParams(rawQuery, charset, maxParams, UriUtils::decodeComponent);\n+    }\n+\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams,\n+                                                       BiFunction<String, Charset, String> decoder) {\n+        if (maxParams <= 0) {\n+            throw new IllegalArgumentException(\"maxParams: \" + maxParams + \" (expected: > 0)\");\n+        }\n+\n+        if (rawQuery == null || rawQuery.isEmpty()) {\n+            return new LinkedHashMap<>(2);\n+        }\n+\n+        final Map<String, List<String>> params = new LinkedHashMap<>();\n+        int paramCountDown = maxParams;\n+        final int from = rawQuery.charAt(0) == '?' ? 1 : 0;\n+        final int len = rawQuery.length();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        loop:\n+        for (i = from; i < len; i++) {\n+            switch (rawQuery.charAt(i)) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case '&':\n+                case ';':\n+                    if (addQueryParam(rawQuery, nameStart, valueStart, i, charset, params, decoder)) {\n+                        paramCountDown--;\n+                        if (paramCountDown == 0) {\n+                            return params;\n+                        }\n+                    }\n+                    nameStart = i + 1;\n+                    break;\n+                case '#':\n+                    break loop;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addQueryParam(rawQuery, nameStart, valueStart, i, charset, params, decoder);\n+        return params;\n+    }\n+\n+    static String encodeComponent(UriComponentType type, String component, Charset charset,\n+                                  boolean preservePctEncoded) {\n+        byte[] bytes = component.getBytes(charset);\n+        for (int i = 0; i < bytes.length; ++i) {\n+            byte b = bytes[i];\n+            if (type.isValid(b)) {\n+                // noop\n+            } else if (preservePctEncoded && bytes.length - 3 >= i && isPctEncoded(bytes, b, i)) {\n+                i += 2; // only increment by 2 here, the for loop will increment 1 more\n+            } else {\n+                ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length + 16);\n+                baos.write(bytes, 0, i);\n+                encodeHexDigits(baos, b);\n+                for (int j = i + 1; j < bytes.length; ++j) {\n+                    b = bytes[j];\n+                    if (type.isValid(b)) {\n+                        baos.write(b);\n+                    } else if (preservePctEncoded && bytes.length - 3 >= j && isPctEncoded(bytes, b, j)) {\n+                        baos.write(bytes, j, 3);\n+                        j += 2; // only increment by 2 here, the for loop will increment 1 more\n+                    } else {\n+                        encodeHexDigits(baos, b);\n+                    }\n+                }\n+                return new String(baos.toByteArray(), charset);\n+            }\n+        }\n+        return component;\n+    }\n+\n+    static String decodeComponent(final String s, final Charset charset) {\n+        if (s.indexOf('%') < 0) {\n+            return s;\n+        }\n+        byte[] bytes = s.getBytes(charset);\n+        for (int i = 0; i < bytes.length; ++i) {\n+            byte b = bytes[i];\n+            if (b == '%') {\n+                ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length);\n+                baos.write(bytes, 0, i);\n+                baos.write(decodeHexDigits(bytes, i));\n+                for (int j = i + 3; j < bytes.length; ++j) {\n+                    b = bytes[j];\n+                    if (b == '%') {\n+                        baos.write(decodeHexDigits(bytes, j));\n+                        j += 2;\n+                    } else {\n+                        baos.write(b);\n+                    }\n+                }\n+                return new String(baos.toByteArray(), charset);\n+            }\n+        }\n+\n+        return s;\n+    }\n+\n+    static int parsePort(final String uri, final int begin, final int end) {\n+        final int len = end - begin;\n+        if (len == 4) {\n+            return (1000 * toDecimal(uri.charAt(begin))) +\n+                    (100 * toDecimal(uri.charAt(begin + 1))) +\n+                    (10 * toDecimal(uri.charAt(begin + 2))) +\n+                    toDecimal(uri.charAt(begin + 3));\n+        } else if (len == 3) {\n+            return (100 * toDecimal(uri.charAt(begin))) +\n+                    (10 * toDecimal(uri.charAt(begin + 1))) +\n+                    toDecimal(uri.charAt(begin + 2));\n+        } else if (len == 2) {\n+            return (10 * toDecimal(uri.charAt(begin))) +\n+                    toDecimal(uri.charAt(begin + 1));\n+        } else if (len == 5) {\n+            final int port = (10000 * toDecimal(uri.charAt(begin))) +\n+                    (1000 * toDecimal(uri.charAt(begin + 1))) +\n+                    (100 * toDecimal(uri.charAt(begin + 2))) +\n+                    (10 * toDecimal(uri.charAt(begin + 3))) +\n+                    toDecimal(uri.charAt(begin + 4));\n+            if (port > 65535) {\n+                throw new IllegalArgumentException(\"port out of bounds\");", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4NzYwMQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514587601", "bodyText": "Consider using switch", "author": "idelpivnitskiy", "createdAt": "2020-10-29T21:48:23Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/UriUtils.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import javax.annotation.Nullable;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+\n+final class UriUtils {\n+    // https://tools.ietf.org/html/rfc3986 declares that all delimiter/terminal values are US-ASCII\n+    // https://tools.ietf.org/html/rfc3986#section-2. This means values fall within the [0, 127] range. This range\n+    // can be represented as a bitset/bitmask with two longs (high, low), which reduces the amount of conditional\n+    // statements required to validate characters belonging to each character class. The following final variables\n+    // provide the bitmask for the different character classes defined in rfc3986, and isBitSet can be used to verify if\n+    // a bit is set for a particular (high, low) mask pair.\n+    //\n+    // pct-encoded is omitted below. This criteria is asserted outside this scope because it requires checking multiple\n+    // bytes and advancing the loop index accordingly.\n+\n+    private static final long DIGIT_LMASK = lowMask('0', '9');\n+    private static final long DIGIT_HMASK = highMask('0', '9');\n+\n+    private static final long ALPHA_LMASK = lowMask('a', 'z') | lowMask('A', 'Z');\n+    private static final long ALPHA_HMASK = highMask('a', 'z') | highMask('A', 'Z');\n+\n+    private static final long HEXDIG_LMASK = DIGIT_LMASK | lowMask('a', 'f') | lowMask('A', 'F');\n+    private static final long HEXDIG_HMASK = DIGIT_HMASK | highMask('a', 'f') | highMask('A', 'F');\n+\n+    // unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n+    private static final long UNRESERVED_LMASK = ALPHA_LMASK | DIGIT_LMASK | lowMask(\"-._~\");\n+    private static final long UNRESERVED_HMASK = ALPHA_HMASK | DIGIT_HMASK | highMask(\"-._~\");\n+\n+    // sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n+    //                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n+    private static final long SUBDELIM_LMASK = lowMask(\"!$&'()*+,;=\");\n+    private static final long SUBDELIM_HMASK = highMask(\"!$&'()*+,;=\");\n+\n+    // pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n+    private static final long PCHAR_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\";@\");\n+\n+    private static final long PCHAR_NOSUBDELIM_LMASK = UNRESERVED_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_NOSUBDELIM_HMASK = UNRESERVED_HMASK | highMask(\";@\");\n+\n+    // userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n+    static final long USERINFO_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\":\");\n+    static final long USERINFO_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\":\");\n+\n+    // path        = *(pchar / \"/\")\n+    static final long PATH_LMASK = PCHAR_LMASK | lowMask(\"/\");\n+    static final long PATH_HMASK = PCHAR_HMASK | highMask(\"/\");\n+\n+    static final long PATH_SEGMENT_LMASK = PCHAR_LMASK;\n+    static final long PATH_SEGMENT_HMASK = PCHAR_HMASK;\n+\n+    // query       = *( pchar / \"/\" / \"?\" )\n+    static final long QUERY_LMASK = PCHAR_LMASK | lowMask(\"/?\");\n+    static final long QUERY_HMASK = PCHAR_HMASK | highMask(\"/?\");\n+\n+    static final long QUERY_VALUE_LMASK = PCHAR_NOSUBDELIM_LMASK | lowMask(\"/?\");\n+    static final long QUERY_VALUE_HMASK = PCHAR_NOSUBDELIM_HMASK | highMask(\"/?\");\n+\n+    // fragment    = *( pchar / \"/\" / \"?\" )\n+    static final long FRAGMENT_LMASK = QUERY_LMASK;\n+    static final long FRAGMENT_HMASK = QUERY_HMASK;\n+\n+    // host        = IP-literal / IPv4address / reg-name\n+    // reg-name    = *( unreserved / pct-encoded / sub-delims )\n+    static final long HOST_NON_IP_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK;\n+    static final long HOST_NON_IP_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK;\n+\n+    private UriUtils() {\n+    }\n+\n+    /**\n+     * Decode the specified raw query with the specified {@code charset} for the specified maximum number of parameters.\n+     */\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams) {\n+        return decodeQueryParams(rawQuery, charset, maxParams, UriUtils::decodeComponent);\n+    }\n+\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams,\n+                                                       BiFunction<String, Charset, String> decoder) {\n+        if (maxParams <= 0) {\n+            throw new IllegalArgumentException(\"maxParams: \" + maxParams + \" (expected: > 0)\");\n+        }\n+\n+        if (rawQuery == null || rawQuery.isEmpty()) {\n+            return new LinkedHashMap<>(2);\n+        }\n+\n+        final Map<String, List<String>> params = new LinkedHashMap<>();\n+        int paramCountDown = maxParams;\n+        final int from = rawQuery.charAt(0) == '?' ? 1 : 0;\n+        final int len = rawQuery.length();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        loop:\n+        for (i = from; i < len; i++) {\n+            switch (rawQuery.charAt(i)) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case '&':\n+                case ';':\n+                    if (addQueryParam(rawQuery, nameStart, valueStart, i, charset, params, decoder)) {\n+                        paramCountDown--;\n+                        if (paramCountDown == 0) {\n+                            return params;\n+                        }\n+                    }\n+                    nameStart = i + 1;\n+                    break;\n+                case '#':\n+                    break loop;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addQueryParam(rawQuery, nameStart, valueStart, i, charset, params, decoder);\n+        return params;\n+    }\n+\n+    static String encodeComponent(UriComponentType type, String component, Charset charset,\n+                                  boolean preservePctEncoded) {\n+        byte[] bytes = component.getBytes(charset);\n+        for (int i = 0; i < bytes.length; ++i) {\n+            byte b = bytes[i];\n+            if (type.isValid(b)) {\n+                // noop\n+            } else if (preservePctEncoded && bytes.length - 3 >= i && isPctEncoded(bytes, b, i)) {\n+                i += 2; // only increment by 2 here, the for loop will increment 1 more\n+            } else {\n+                ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length + 16);\n+                baos.write(bytes, 0, i);\n+                encodeHexDigits(baos, b);\n+                for (int j = i + 1; j < bytes.length; ++j) {\n+                    b = bytes[j];\n+                    if (type.isValid(b)) {\n+                        baos.write(b);\n+                    } else if (preservePctEncoded && bytes.length - 3 >= j && isPctEncoded(bytes, b, j)) {\n+                        baos.write(bytes, j, 3);\n+                        j += 2; // only increment by 2 here, the for loop will increment 1 more\n+                    } else {\n+                        encodeHexDigits(baos, b);\n+                    }\n+                }\n+                return new String(baos.toByteArray(), charset);\n+            }\n+        }\n+        return component;\n+    }\n+\n+    static String decodeComponent(final String s, final Charset charset) {\n+        if (s.indexOf('%') < 0) {\n+            return s;\n+        }\n+        byte[] bytes = s.getBytes(charset);\n+        for (int i = 0; i < bytes.length; ++i) {\n+            byte b = bytes[i];\n+            if (b == '%') {\n+                ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length);\n+                baos.write(bytes, 0, i);\n+                baos.write(decodeHexDigits(bytes, i));\n+                for (int j = i + 3; j < bytes.length; ++j) {\n+                    b = bytes[j];\n+                    if (b == '%') {\n+                        baos.write(decodeHexDigits(bytes, j));\n+                        j += 2;\n+                    } else {\n+                        baos.write(b);\n+                    }\n+                }\n+                return new String(baos.toByteArray(), charset);\n+            }\n+        }\n+\n+        return s;\n+    }\n+\n+    static int parsePort(final String uri, final int begin, final int end) {\n+        final int len = end - begin;\n+        if (len == 4) {", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxNTYwNA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515415604", "bodyText": "I'll leave as is for this PR as this is pre-existing code which may have been perf tested based upon likelihood of port lengths.", "author": "Scottmitch", "createdAt": "2020-10-30T22:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4NzYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5MTcwNA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514591704", "bodyText": "This type of exceptions are very hard to debug. Will be great to include the full port-number here or try-catch the IllegalArgumentException at higher levels to enhance it with the full port (or full host header) value.", "author": "idelpivnitskiy", "createdAt": "2020-10-29T21:57:50Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/UriUtils.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import javax.annotation.Nullable;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+\n+final class UriUtils {\n+    // https://tools.ietf.org/html/rfc3986 declares that all delimiter/terminal values are US-ASCII\n+    // https://tools.ietf.org/html/rfc3986#section-2. This means values fall within the [0, 127] range. This range\n+    // can be represented as a bitset/bitmask with two longs (high, low), which reduces the amount of conditional\n+    // statements required to validate characters belonging to each character class. The following final variables\n+    // provide the bitmask for the different character classes defined in rfc3986, and isBitSet can be used to verify if\n+    // a bit is set for a particular (high, low) mask pair.\n+    //\n+    // pct-encoded is omitted below. This criteria is asserted outside this scope because it requires checking multiple\n+    // bytes and advancing the loop index accordingly.\n+\n+    private static final long DIGIT_LMASK = lowMask('0', '9');\n+    private static final long DIGIT_HMASK = highMask('0', '9');\n+\n+    private static final long ALPHA_LMASK = lowMask('a', 'z') | lowMask('A', 'Z');\n+    private static final long ALPHA_HMASK = highMask('a', 'z') | highMask('A', 'Z');\n+\n+    private static final long HEXDIG_LMASK = DIGIT_LMASK | lowMask('a', 'f') | lowMask('A', 'F');\n+    private static final long HEXDIG_HMASK = DIGIT_HMASK | highMask('a', 'f') | highMask('A', 'F');\n+\n+    // unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n+    private static final long UNRESERVED_LMASK = ALPHA_LMASK | DIGIT_LMASK | lowMask(\"-._~\");\n+    private static final long UNRESERVED_HMASK = ALPHA_HMASK | DIGIT_HMASK | highMask(\"-._~\");\n+\n+    // sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n+    //                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n+    private static final long SUBDELIM_LMASK = lowMask(\"!$&'()*+,;=\");\n+    private static final long SUBDELIM_HMASK = highMask(\"!$&'()*+,;=\");\n+\n+    // pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n+    private static final long PCHAR_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\";@\");\n+\n+    private static final long PCHAR_NOSUBDELIM_LMASK = UNRESERVED_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_NOSUBDELIM_HMASK = UNRESERVED_HMASK | highMask(\";@\");\n+\n+    // userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n+    static final long USERINFO_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\":\");\n+    static final long USERINFO_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\":\");\n+\n+    // path        = *(pchar / \"/\")\n+    static final long PATH_LMASK = PCHAR_LMASK | lowMask(\"/\");\n+    static final long PATH_HMASK = PCHAR_HMASK | highMask(\"/\");\n+\n+    static final long PATH_SEGMENT_LMASK = PCHAR_LMASK;\n+    static final long PATH_SEGMENT_HMASK = PCHAR_HMASK;\n+\n+    // query       = *( pchar / \"/\" / \"?\" )\n+    static final long QUERY_LMASK = PCHAR_LMASK | lowMask(\"/?\");\n+    static final long QUERY_HMASK = PCHAR_HMASK | highMask(\"/?\");\n+\n+    static final long QUERY_VALUE_LMASK = PCHAR_NOSUBDELIM_LMASK | lowMask(\"/?\");\n+    static final long QUERY_VALUE_HMASK = PCHAR_NOSUBDELIM_HMASK | highMask(\"/?\");\n+\n+    // fragment    = *( pchar / \"/\" / \"?\" )\n+    static final long FRAGMENT_LMASK = QUERY_LMASK;\n+    static final long FRAGMENT_HMASK = QUERY_HMASK;\n+\n+    // host        = IP-literal / IPv4address / reg-name\n+    // reg-name    = *( unreserved / pct-encoded / sub-delims )\n+    static final long HOST_NON_IP_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK;\n+    static final long HOST_NON_IP_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK;\n+\n+    private UriUtils() {\n+    }\n+\n+    /**\n+     * Decode the specified raw query with the specified {@code charset} for the specified maximum number of parameters.\n+     */\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams) {\n+        return decodeQueryParams(rawQuery, charset, maxParams, UriUtils::decodeComponent);\n+    }\n+\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams,\n+                                                       BiFunction<String, Charset, String> decoder) {\n+        if (maxParams <= 0) {\n+            throw new IllegalArgumentException(\"maxParams: \" + maxParams + \" (expected: > 0)\");\n+        }\n+\n+        if (rawQuery == null || rawQuery.isEmpty()) {\n+            return new LinkedHashMap<>(2);\n+        }\n+\n+        final Map<String, List<String>> params = new LinkedHashMap<>();\n+        int paramCountDown = maxParams;\n+        final int from = rawQuery.charAt(0) == '?' ? 1 : 0;\n+        final int len = rawQuery.length();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        loop:\n+        for (i = from; i < len; i++) {\n+            switch (rawQuery.charAt(i)) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case '&':\n+                case ';':\n+                    if (addQueryParam(rawQuery, nameStart, valueStart, i, charset, params, decoder)) {\n+                        paramCountDown--;\n+                        if (paramCountDown == 0) {\n+                            return params;\n+                        }\n+                    }\n+                    nameStart = i + 1;\n+                    break;\n+                case '#':\n+                    break loop;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addQueryParam(rawQuery, nameStart, valueStart, i, charset, params, decoder);\n+        return params;\n+    }\n+\n+    static String encodeComponent(UriComponentType type, String component, Charset charset,\n+                                  boolean preservePctEncoded) {\n+        byte[] bytes = component.getBytes(charset);\n+        for (int i = 0; i < bytes.length; ++i) {\n+            byte b = bytes[i];\n+            if (type.isValid(b)) {\n+                // noop\n+            } else if (preservePctEncoded && bytes.length - 3 >= i && isPctEncoded(bytes, b, i)) {\n+                i += 2; // only increment by 2 here, the for loop will increment 1 more\n+            } else {\n+                ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length + 16);\n+                baos.write(bytes, 0, i);\n+                encodeHexDigits(baos, b);\n+                for (int j = i + 1; j < bytes.length; ++j) {\n+                    b = bytes[j];\n+                    if (type.isValid(b)) {\n+                        baos.write(b);\n+                    } else if (preservePctEncoded && bytes.length - 3 >= j && isPctEncoded(bytes, b, j)) {\n+                        baos.write(bytes, j, 3);\n+                        j += 2; // only increment by 2 here, the for loop will increment 1 more\n+                    } else {\n+                        encodeHexDigits(baos, b);\n+                    }\n+                }\n+                return new String(baos.toByteArray(), charset);\n+            }\n+        }\n+        return component;\n+    }\n+\n+    static String decodeComponent(final String s, final Charset charset) {\n+        if (s.indexOf('%') < 0) {\n+            return s;\n+        }\n+        byte[] bytes = s.getBytes(charset);\n+        for (int i = 0; i < bytes.length; ++i) {\n+            byte b = bytes[i];\n+            if (b == '%') {\n+                ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length);\n+                baos.write(bytes, 0, i);\n+                baos.write(decodeHexDigits(bytes, i));\n+                for (int j = i + 3; j < bytes.length; ++j) {\n+                    b = bytes[j];\n+                    if (b == '%') {\n+                        baos.write(decodeHexDigits(bytes, j));\n+                        j += 2;\n+                    } else {\n+                        baos.write(b);\n+                    }\n+                }\n+                return new String(baos.toByteArray(), charset);\n+            }\n+        }\n+\n+        return s;\n+    }\n+\n+    static int parsePort(final String uri, final int begin, final int end) {\n+        final int len = end - begin;\n+        if (len == 4) {\n+            return (1000 * toDecimal(uri.charAt(begin))) +\n+                    (100 * toDecimal(uri.charAt(begin + 1))) +\n+                    (10 * toDecimal(uri.charAt(begin + 2))) +\n+                    toDecimal(uri.charAt(begin + 3));\n+        } else if (len == 3) {\n+            return (100 * toDecimal(uri.charAt(begin))) +\n+                    (10 * toDecimal(uri.charAt(begin + 1))) +\n+                    toDecimal(uri.charAt(begin + 2));\n+        } else if (len == 2) {\n+            return (10 * toDecimal(uri.charAt(begin))) +\n+                    toDecimal(uri.charAt(begin + 1));\n+        } else if (len == 5) {\n+            final int port = (10000 * toDecimal(uri.charAt(begin))) +\n+                    (1000 * toDecimal(uri.charAt(begin + 1))) +\n+                    (100 * toDecimal(uri.charAt(begin + 2))) +\n+                    (10 * toDecimal(uri.charAt(begin + 3))) +\n+                    toDecimal(uri.charAt(begin + 4));\n+            if (port > 65535) {\n+                throw new IllegalArgumentException(\"port out of bounds\");\n+            }\n+            return port;\n+        } else if (len == 1) {\n+            return toDecimal(uri.charAt(begin));\n+        } else {\n+            throw new IllegalArgumentException(\"invalid port\");\n+        }\n+    }\n+\n+    private static boolean addQueryParam(final String s, final int nameStart, int valueStart, final int valueEnd,\n+                                         final Charset charset, final Map<String, List<String>> params,\n+                                         final BiFunction<String, Charset, String> decoder) {\n+        if (nameStart >= valueEnd) {\n+            return false;\n+        }\n+        if (valueStart <= nameStart) {\n+            valueStart = valueEnd + 1;\n+        }\n+        final String name = decoder.apply(s.substring(nameStart, valueStart - 1), charset);\n+        final String value = decoder.apply(s.substring(valueStart, valueEnd), charset);\n+        final List<String> values = params.computeIfAbsent(name, k -> new ArrayList<>(1)); // Often there's only 1 value\n+        values.add(value);\n+        return true;\n+    }\n+\n+    private static void encodeHexDigits(ByteArrayOutputStream baos, byte b) {\n+        baos.write('%');\n+        baos.write(encodeHexNibble((b >>> 4) & 0xF));\n+        baos.write(encodeHexNibble(b & 0xF));\n+    }\n+\n+    private static byte decodeHexDigits(byte[] bytes, int i) {\n+        if (bytes.length - 2 <= i) {\n+            throw new IllegalArgumentException(\"Invalid pct-encoded at index \" + i);\n+        }\n+        final int hi = decodeHexNibble(bytes[i + 1]);\n+        final int lo = decodeHexNibble(bytes[i + 2]);\n+        if (hi == -1 || lo == -1) {\n+            throw new IllegalArgumentException(\"Invalid HEXDIG at index \" + i);\n+        }\n+        return (byte) ((hi << 4) + lo);\n+    }\n+\n+    private static byte encodeHexNibble(final int b) {\n+        // Character.forDigit() is not used here, as it addresses a larger\n+        // set of characters (both ASCII and full-width latin letters).\n+        if (b < 0 || b >= 16) {\n+            return 0;\n+        }\n+        if (b < 10) {\n+            return (byte) ('0' + b);\n+        }\n+        return (byte) ('A' - 10 + b); // uppercase\n+    }\n+\n+    /**\n+     * Helper to decode half of a hexadecimal number from a string.\n+     *\n+     * @param b The ASCII character of the hexadecimal number to decode.\n+     * Must be in the range {@code [0-9a-fA-F]}.\n+     * @return The hexadecimal value represented in the ASCII character\n+     * given, or {@code -1} if the character is invalid.\n+     */\n+    private static int decodeHexNibble(final byte b) {\n+        // Character.digit() is not used here, as it addresses a larger\n+        // set of characters (both ASCII and full-width latin letters).\n+        if (b >= '0' && b <= '9') {\n+            return b - '0';\n+        }\n+        if (b >= 'A' && b <= 'F') {\n+            return b - ('A' - 0xA);\n+        }\n+        if (b >= 'a' && b <= 'f') {\n+            return b - ('a' - 0xA);\n+        }\n+        return -1;\n+    }\n+\n+    private static int toDecimal(final char c) {\n+        if (c < '0' || c > '9') {\n+            throw new IllegalArgumentException(\"invalid port\");", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxNzM3Mw==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515417373", "bodyText": "I'll include the character for now, lets enhance the error info if necessary in a followup PR as I don't want to add multiple layers of try/catch/wrap and complicate control flow or log user data here.", "author": "Scottmitch", "createdAt": "2020-10-30T23:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5MTcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5MjU4MA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514592580", "bodyText": "Consider taking parsedHostHeader.charAt(x - 1) instead of looking for the last index of ].", "author": "idelpivnitskiy", "createdAt": "2020-10-29T21:59:54Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -269,78 +383,131 @@ public boolean removeQueryParameters(final String key, final String value) {\n         return lazyParseQueryString().remove(key, value);\n     }\n \n-    @Nullable\n-    @Override\n-    public final String effectiveHost() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestHost;\n-    }\n-\n     @Override\n-    public final int effectivePort() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestPort;\n+    public HostAndPort effectiveHostAndPort() {\n+        final CharSequence hostHeader;\n+        final Uri effectiveRequestUri = lazyParseRequestTarget();\n+        final String effectiveRequestUriHost = effectiveRequestUri.host();\n+        if (effectiveRequestUriHost != null) {\n+            return HostAndPort.of(effectiveRequestUriHost, effectiveRequestUri.port());\n+        } else if ((hostHeader = headers().get(HOST)) != null) {\n+            return parseHostHeader(hostHeader.toString());\n+        }\n+        return null;\n     }\n \n     private HttpQuery lazyParseQueryString() {\n         if (httpQuery == null) {\n-            httpQuery = new HttpQuery(decodeParams(lazyParseRequestTarget().rawQuery()), this::setQueryParams);\n+            httpQuery = new HttpQuery(decodeQueryParams(lazyParseRequestTarget().query(),\n+                    REQUEST_TARGET_CHARSET, DEFAULT_MAX_QUERY_PARAMS), this::setQueryParams);\n         }\n         return httpQuery;\n     }\n \n-    private HttpUri lazyParseRequestTarget() {\n+    private Uri lazyParseRequestTarget() {\n         if (requestTargetUri == null) {\n-            requestTargetUri = new HttpUri(requestTarget());\n+            requestTargetUri = CONNECT.equals(method) ? new HttpAuthorityFormUri(requestTarget()) :\n+                    new Uri3986(requestTarget());\n         }\n         return requestTargetUri;\n     }\n \n-    private void lazyParseEffectiveRequest() {\n-        final CharSequence hostHeader = headers().get(HOST);\n-\n-        if (effectiveRequestPort == PORT_NOT_ASSIGNED || !Objects.equals(hostHeader, effectiveRequestHostHeader)) {\n-            final HttpUri effectiveRequestUri = new HttpUri(requestTarget(),\n-                    () -> hostHeader != null ? hostHeader.toString() : null);\n-            effectiveRequestHost = effectiveRequestUri.host();\n-            effectiveRequestPort = effectiveRequestUri.explicitPort();\n-            effectiveRequestHostHeader = hostHeader;\n+    private static HostAndPort parseHostHeader(String parsedHostHeader) {\n+        String parsedHost;\n+        int parsedPort = -1;\n+        final int x = parsedHostHeader.lastIndexOf(':');\n+        if (x > 0) {\n+            final int y = parsedHostHeader.lastIndexOf(':', x - 1);\n+            if (y >= 0) {\n+                // IPv6 address is present in the header\n+                // https://tools.ietf.org/html/rfc3986#section-3.2.2\n+                // A host identified by an Internet Protocol literal address, version 6\n+                // [RFC3513] or later, is distinguished by enclosing the IP literal\n+                // within square brackets (\"[\" and \"]\").  This is the only place where\n+                // square bracket characters are allowed in the URI syntax.\n+                final int cb;\n+                if (parsedHostHeader.charAt(0) != '[' || (cb = parsedHostHeader.lastIndexOf(']')) < 0) {", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyMTc2Mg==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515421762", "bodyText": "this is pre-existing code ... however after a close look I think it can be more generally simplified (which should address your other comments here too)", "author": "Scottmitch", "createdAt": "2020-10-30T23:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5MjU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5Mjk4Mw==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514592983", "bodyText": "Please, include the parsedHostHeader value in the exception msg", "author": "idelpivnitskiy", "createdAt": "2020-10-29T22:00:52Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -269,78 +383,131 @@ public boolean removeQueryParameters(final String key, final String value) {\n         return lazyParseQueryString().remove(key, value);\n     }\n \n-    @Nullable\n-    @Override\n-    public final String effectiveHost() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestHost;\n-    }\n-\n     @Override\n-    public final int effectivePort() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestPort;\n+    public HostAndPort effectiveHostAndPort() {\n+        final CharSequence hostHeader;\n+        final Uri effectiveRequestUri = lazyParseRequestTarget();\n+        final String effectiveRequestUriHost = effectiveRequestUri.host();\n+        if (effectiveRequestUriHost != null) {\n+            return HostAndPort.of(effectiveRequestUriHost, effectiveRequestUri.port());\n+        } else if ((hostHeader = headers().get(HOST)) != null) {\n+            return parseHostHeader(hostHeader.toString());\n+        }\n+        return null;\n     }\n \n     private HttpQuery lazyParseQueryString() {\n         if (httpQuery == null) {\n-            httpQuery = new HttpQuery(decodeParams(lazyParseRequestTarget().rawQuery()), this::setQueryParams);\n+            httpQuery = new HttpQuery(decodeQueryParams(lazyParseRequestTarget().query(),\n+                    REQUEST_TARGET_CHARSET, DEFAULT_MAX_QUERY_PARAMS), this::setQueryParams);\n         }\n         return httpQuery;\n     }\n \n-    private HttpUri lazyParseRequestTarget() {\n+    private Uri lazyParseRequestTarget() {\n         if (requestTargetUri == null) {\n-            requestTargetUri = new HttpUri(requestTarget());\n+            requestTargetUri = CONNECT.equals(method) ? new HttpAuthorityFormUri(requestTarget()) :\n+                    new Uri3986(requestTarget());\n         }\n         return requestTargetUri;\n     }\n \n-    private void lazyParseEffectiveRequest() {\n-        final CharSequence hostHeader = headers().get(HOST);\n-\n-        if (effectiveRequestPort == PORT_NOT_ASSIGNED || !Objects.equals(hostHeader, effectiveRequestHostHeader)) {\n-            final HttpUri effectiveRequestUri = new HttpUri(requestTarget(),\n-                    () -> hostHeader != null ? hostHeader.toString() : null);\n-            effectiveRequestHost = effectiveRequestUri.host();\n-            effectiveRequestPort = effectiveRequestUri.explicitPort();\n-            effectiveRequestHostHeader = hostHeader;\n+    private static HostAndPort parseHostHeader(String parsedHostHeader) {\n+        String parsedHost;\n+        int parsedPort = -1;\n+        final int x = parsedHostHeader.lastIndexOf(':');\n+        if (x > 0) {\n+            final int y = parsedHostHeader.lastIndexOf(':', x - 1);\n+            if (y >= 0) {\n+                // IPv6 address is present in the header\n+                // https://tools.ietf.org/html/rfc3986#section-3.2.2\n+                // A host identified by an Internet Protocol literal address, version 6\n+                // [RFC3513] or later, is distinguished by enclosing the IP literal\n+                // within square brackets (\"[\" and \"]\").  This is the only place where\n+                // square bracket characters are allowed in the URI syntax.\n+                final int cb;\n+                if (parsedHostHeader.charAt(0) != '[' || (cb = parsedHostHeader.lastIndexOf(']')) < 0) {\n+                    throw new IllegalArgumentException(\"IPv6 address should be in square brackets\");", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5Mzg4NA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514593884", "bodyText": "It does not verify that ] is next to :", "author": "idelpivnitskiy", "createdAt": "2020-10-29T22:03:21Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -269,78 +383,131 @@ public boolean removeQueryParameters(final String key, final String value) {\n         return lazyParseQueryString().remove(key, value);\n     }\n \n-    @Nullable\n-    @Override\n-    public final String effectiveHost() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestHost;\n-    }\n-\n     @Override\n-    public final int effectivePort() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestPort;\n+    public HostAndPort effectiveHostAndPort() {\n+        final CharSequence hostHeader;\n+        final Uri effectiveRequestUri = lazyParseRequestTarget();\n+        final String effectiveRequestUriHost = effectiveRequestUri.host();\n+        if (effectiveRequestUriHost != null) {\n+            return HostAndPort.of(effectiveRequestUriHost, effectiveRequestUri.port());\n+        } else if ((hostHeader = headers().get(HOST)) != null) {\n+            return parseHostHeader(hostHeader.toString());\n+        }\n+        return null;\n     }\n \n     private HttpQuery lazyParseQueryString() {\n         if (httpQuery == null) {\n-            httpQuery = new HttpQuery(decodeParams(lazyParseRequestTarget().rawQuery()), this::setQueryParams);\n+            httpQuery = new HttpQuery(decodeQueryParams(lazyParseRequestTarget().query(),\n+                    REQUEST_TARGET_CHARSET, DEFAULT_MAX_QUERY_PARAMS), this::setQueryParams);\n         }\n         return httpQuery;\n     }\n \n-    private HttpUri lazyParseRequestTarget() {\n+    private Uri lazyParseRequestTarget() {\n         if (requestTargetUri == null) {\n-            requestTargetUri = new HttpUri(requestTarget());\n+            requestTargetUri = CONNECT.equals(method) ? new HttpAuthorityFormUri(requestTarget()) :\n+                    new Uri3986(requestTarget());\n         }\n         return requestTargetUri;\n     }\n \n-    private void lazyParseEffectiveRequest() {\n-        final CharSequence hostHeader = headers().get(HOST);\n-\n-        if (effectiveRequestPort == PORT_NOT_ASSIGNED || !Objects.equals(hostHeader, effectiveRequestHostHeader)) {\n-            final HttpUri effectiveRequestUri = new HttpUri(requestTarget(),\n-                    () -> hostHeader != null ? hostHeader.toString() : null);\n-            effectiveRequestHost = effectiveRequestUri.host();\n-            effectiveRequestPort = effectiveRequestUri.explicitPort();\n-            effectiveRequestHostHeader = hostHeader;\n+    private static HostAndPort parseHostHeader(String parsedHostHeader) {\n+        String parsedHost;\n+        int parsedPort = -1;\n+        final int x = parsedHostHeader.lastIndexOf(':');\n+        if (x > 0) {\n+            final int y = parsedHostHeader.lastIndexOf(':', x - 1);\n+            if (y >= 0) {\n+                // IPv6 address is present in the header\n+                // https://tools.ietf.org/html/rfc3986#section-3.2.2\n+                // A host identified by an Internet Protocol literal address, version 6\n+                // [RFC3513] or later, is distinguished by enclosing the IP literal\n+                // within square brackets (\"[\" and \"]\").  This is the only place where\n+                // square bracket characters are allowed in the URI syntax.\n+                final int cb;\n+                if (parsedHostHeader.charAt(0) != '[' || (cb = parsedHostHeader.lastIndexOf(']')) < 0) {\n+                    throw new IllegalArgumentException(\"IPv6 address should be in square brackets\");\n+                }\n+                if (cb < x) {", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMzE1NA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514603154", "bodyText": "In this case x > 0. Therefore, it should never happen. The above suggested changes should cover everything we need.", "author": "idelpivnitskiy", "createdAt": "2020-10-29T22:26:53Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -269,78 +383,131 @@ public boolean removeQueryParameters(final String key, final String value) {\n         return lazyParseQueryString().remove(key, value);\n     }\n \n-    @Nullable\n-    @Override\n-    public final String effectiveHost() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestHost;\n-    }\n-\n     @Override\n-    public final int effectivePort() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestPort;\n+    public HostAndPort effectiveHostAndPort() {\n+        final CharSequence hostHeader;\n+        final Uri effectiveRequestUri = lazyParseRequestTarget();\n+        final String effectiveRequestUriHost = effectiveRequestUri.host();\n+        if (effectiveRequestUriHost != null) {\n+            return HostAndPort.of(effectiveRequestUriHost, effectiveRequestUri.port());\n+        } else if ((hostHeader = headers().get(HOST)) != null) {\n+            return parseHostHeader(hostHeader.toString());\n+        }\n+        return null;\n     }\n \n     private HttpQuery lazyParseQueryString() {\n         if (httpQuery == null) {\n-            httpQuery = new HttpQuery(decodeParams(lazyParseRequestTarget().rawQuery()), this::setQueryParams);\n+            httpQuery = new HttpQuery(decodeQueryParams(lazyParseRequestTarget().query(),\n+                    REQUEST_TARGET_CHARSET, DEFAULT_MAX_QUERY_PARAMS), this::setQueryParams);\n         }\n         return httpQuery;\n     }\n \n-    private HttpUri lazyParseRequestTarget() {\n+    private Uri lazyParseRequestTarget() {\n         if (requestTargetUri == null) {\n-            requestTargetUri = new HttpUri(requestTarget());\n+            requestTargetUri = CONNECT.equals(method) ? new HttpAuthorityFormUri(requestTarget()) :\n+                    new Uri3986(requestTarget());\n         }\n         return requestTargetUri;\n     }\n \n-    private void lazyParseEffectiveRequest() {\n-        final CharSequence hostHeader = headers().get(HOST);\n-\n-        if (effectiveRequestPort == PORT_NOT_ASSIGNED || !Objects.equals(hostHeader, effectiveRequestHostHeader)) {\n-            final HttpUri effectiveRequestUri = new HttpUri(requestTarget(),\n-                    () -> hostHeader != null ? hostHeader.toString() : null);\n-            effectiveRequestHost = effectiveRequestUri.host();\n-            effectiveRequestPort = effectiveRequestUri.explicitPort();\n-            effectiveRequestHostHeader = hostHeader;\n+    private static HostAndPort parseHostHeader(String parsedHostHeader) {\n+        String parsedHost;\n+        int parsedPort = -1;\n+        final int x = parsedHostHeader.lastIndexOf(':');\n+        if (x > 0) {\n+            final int y = parsedHostHeader.lastIndexOf(':', x - 1);\n+            if (y >= 0) {\n+                // IPv6 address is present in the header\n+                // https://tools.ietf.org/html/rfc3986#section-3.2.2\n+                // A host identified by an Internet Protocol literal address, version 6\n+                // [RFC3513] or later, is distinguished by enclosing the IP literal\n+                // within square brackets (\"[\" and \"]\").  This is the only place where\n+                // square bracket characters are allowed in the URI syntax.\n+                final int cb;\n+                if (parsedHostHeader.charAt(0) != '[' || (cb = parsedHostHeader.lastIndexOf(']')) < 0) {\n+                    throw new IllegalArgumentException(\"IPv6 address should be in square brackets\");\n+                }\n+                if (cb < x) {\n+                    parsedHost = parsedHostHeader.substring(0, x);\n+                    parsedPort = parsePort(parsedHostHeader, x + 1, parsedHostHeader.length());\n+                } else if (cb != parsedHostHeader.length() - 1) {", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwNjE3MA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514606170", "bodyText": "There is a duplication with rawQuery, rawPath, and setQueryParams methods for the logic between scheme and path, as well as for fragment (and maybe even query). Consider moving those parts to a private utility methods.", "author": "idelpivnitskiy", "createdAt": "2020-10-29T22:35:16Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -121,70 +124,181 @@ public final String host() {\n \n     @Override\n     public final int port() {\n-        return lazyParseRequestTarget().explicitPort();\n+        return lazyParseRequestTarget().port();\n     }\n \n     @Override\n     public final String rawPath() {\n-        return lazyParseRequestTarget().rawPath();\n+        return lazyParseRequestTarget().path();\n     }\n \n     @Override\n     public HttpRequestMetaData rawPath(final String path) {\n+        Uri httpUri = lazyParseRequestTarget();\n+        // Potentially over estimate the size of the URL to avoid resize/copy\n+        StringBuilder sb = new StringBuilder(httpUri.uri().length() + path.length());\n+\n+        // Append everything up to and including the path\n+        if (httpUri.scheme() != null) {\n+            sb.append(httpUri.scheme()).append(':');\n+        }\n+        if (httpUri.host() != null) {\n+            // The authority component is preceded by a double slash (\"//\")\n+            // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+            sb.append(\"//\");\n+            if (httpUri.userInfo() != null) {\n+                sb.append(httpUri.userInfo()).append('@');\n+            }\n+\n+            sb.append(httpUri.host());\n+            if (httpUri.port() >= 0) {\n+                sb.append(':').append(httpUri.port());\n+            }\n+        }\n+\n+        // Append the path\n         if (!path.isEmpty() && path.charAt(0) != '/') {\n-            throw new IllegalArgumentException(\"Path must be empty or start with '/'\");\n+            sb.append('/');\n         }\n-        requestTarget(encodeRequestTarget(path, rawQuery(), null));\n-        return this;\n+        sb.append(path);\n+\n+        // Append the query string\n+        String query = httpUri.query();\n+        if (query != null) {\n+            sb.append('?').append(query);\n+        }\n+\n+        // Append the fragment\n+        String fragment = httpUri.fragment();\n+        if (fragment != null) {\n+            sb.append('#').append(fragment);\n+        }\n+\n+        return requestTarget(sb.toString());\n     }\n \n     @Override\n     public final String path() {\n-        return lazyParseRequestTarget().path();\n+        if (pathDecoded != null) {\n+            return pathDecoded;\n+        }\n+        pathDecoded = lazyParseRequestTarget().path(REQUEST_TARGET_CHARSET);\n+        return pathDecoded;\n     }\n \n     @Override\n     public HttpRequestMetaData path(String path) {\n-        if (!path.isEmpty() && path.charAt(0) != '/') {\n-            path = \"/\" + path;\n-        }\n-        // TODO This is an ugly hack!\n-        final String encodedPath = urlEncode(path).replaceAll(\"%2F\", \"/\");\n-        requestTarget(encodeRequestTarget(encodedPath, rawQuery(), null));\n-        return this;\n+        return rawPath(encodeComponent(PATH, path, REQUEST_TARGET_CHARSET, true));\n     }\n \n     @Override\n     public HttpRequestMetaData appendPathSegments(String... segments) {\n         if (segments.length == 0) {\n             throw new IllegalArgumentException(\"At least one path segment must be provided\");\n         }\n+        Uri httpUri = lazyParseRequestTarget();\n+        StringBuilder sb = new StringBuilder(httpUri.uri().length() + segments.length * 8);\n \n-        final String path = path();\n-        final StringBuilder builder = new StringBuilder(path.length() + 8 * segments.length).append(path);\n-        if (!path.isEmpty() && !path.endsWith(\"/\")) {\n-            builder.append('/');\n+        // Append everything up to and including the path\n+        if (httpUri.scheme() != null) {\n+            sb.append(httpUri.scheme()).append(':');\n         }\n-        for (int i = 0; i < segments.length; i++) {\n-            builder.append(urlEncode(segments[i]));\n+        if (httpUri.host() != null) {\n+            // The authority component is preceded by a double slash (\"//\")\n+            // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+            sb.append(\"//\");\n+            if (httpUri.userInfo() != null) {\n+                sb.append(httpUri.userInfo()).append('@');\n+            }\n \n-            if (i < (segments.length - 1)) {\n-                builder.append('/');\n+            sb.append(httpUri.host());\n+            if (httpUri.port() >= 0) {\n+                sb.append(':').append(httpUri.port());", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxMjM0OA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514612348", "bodyText": "Should we require users to begin with / instead of adding it for them?", "author": "idelpivnitskiy", "createdAt": "2020-10-29T22:52:09Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -121,70 +124,181 @@ public final String host() {\n \n     @Override\n     public final int port() {\n-        return lazyParseRequestTarget().explicitPort();\n+        return lazyParseRequestTarget().port();\n     }\n \n     @Override\n     public final String rawPath() {\n-        return lazyParseRequestTarget().rawPath();\n+        return lazyParseRequestTarget().path();\n     }\n \n     @Override\n     public HttpRequestMetaData rawPath(final String path) {\n+        Uri httpUri = lazyParseRequestTarget();\n+        // Potentially over estimate the size of the URL to avoid resize/copy\n+        StringBuilder sb = new StringBuilder(httpUri.uri().length() + path.length());\n+\n+        // Append everything up to and including the path\n+        if (httpUri.scheme() != null) {\n+            sb.append(httpUri.scheme()).append(':');\n+        }\n+        if (httpUri.host() != null) {\n+            // The authority component is preceded by a double slash (\"//\")\n+            // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+            sb.append(\"//\");\n+            if (httpUri.userInfo() != null) {\n+                sb.append(httpUri.userInfo()).append('@');\n+            }\n+\n+            sb.append(httpUri.host());\n+            if (httpUri.port() >= 0) {\n+                sb.append(':').append(httpUri.port());\n+            }\n+        }\n+\n+        // Append the path\n         if (!path.isEmpty() && path.charAt(0) != '/') {\n-            throw new IllegalArgumentException(\"Path must be empty or start with '/'\");\n+            sb.append('/');", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNzMxMQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515427311", "bodyText": "Actually I don't think we should force /, it is legit in some circumstances to not start with a /.\npath          = ..\n                    / path-noscheme   ; begins with a non-colon segment\n                    / path-rootless   ; begins with a segment\n\n      path-noscheme = segment-nz-nc *( \"/\" segment )\n      path-rootless = segment-nz *( \"/\" segment )\n\nsegment-nz    = 1*pchar\nsegment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / \"@\" )\n                    ; non-zero-length segment without any colon \":\"\npchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"", "author": "Scottmitch", "createdAt": "2020-10-30T23:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxMjM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjEwMTY5MA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r516101690", "bodyText": "I've enhanced the path validation/appending to account for this scenario.", "author": "Scottmitch", "createdAt": "2020-11-02T16:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxMjM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxMzE2MA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514613160", "bodyText": "If an authority component is absent, then the path cannot begin with an empty segment, that is with two slashes (//), as the following characters would be interpreted as an authority component.\n\nhttps://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Generic_syntax", "author": "idelpivnitskiy", "createdAt": "2020-10-29T22:54:30Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -121,70 +124,181 @@ public final String host() {\n \n     @Override\n     public final int port() {\n-        return lazyParseRequestTarget().explicitPort();\n+        return lazyParseRequestTarget().port();\n     }\n \n     @Override\n     public final String rawPath() {\n-        return lazyParseRequestTarget().rawPath();\n+        return lazyParseRequestTarget().path();\n     }\n \n     @Override\n     public HttpRequestMetaData rawPath(final String path) {\n+        Uri httpUri = lazyParseRequestTarget();\n+        // Potentially over estimate the size of the URL to avoid resize/copy\n+        StringBuilder sb = new StringBuilder(httpUri.uri().length() + path.length());\n+\n+        // Append everything up to and including the path\n+        if (httpUri.scheme() != null) {\n+            sb.append(httpUri.scheme()).append(':');\n+        }\n+        if (httpUri.host() != null) {\n+            // The authority component is preceded by a double slash (\"//\")\n+            // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+            sb.append(\"//\");\n+            if (httpUri.userInfo() != null) {\n+                sb.append(httpUri.userInfo()).append('@');\n+            }\n+\n+            sb.append(httpUri.host());\n+            if (httpUri.port() >= 0) {\n+                sb.append(':').append(httpUri.port());\n+            }\n+        }\n+\n+        // Append the path\n         if (!path.isEmpty() && path.charAt(0) != '/') {\n-            throw new IllegalArgumentException(\"Path must be empty or start with '/'\");\n+            sb.append('/');\n         }\n-        requestTarget(encodeRequestTarget(path, rawQuery(), null));\n-        return this;\n+        sb.append(path);", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzNjMwNg==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515436306", "bodyText": "IIUC you are implying that we should try to enforce that the path doesn't start with // if there is no authority component? sure I will do this", "author": "Scottmitch", "createdAt": "2020-10-31T00:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYxMzE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyMTQzNA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514621434", "bodyText": "Consider adding more tests for cases when an empty path was provided with a combination of other methods, like rawQuery.\n\n\nShould we allow setting path, query, fragment for CONNECT request?", "author": "idelpivnitskiy", "createdAt": "2020-10-29T23:18:44Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -121,70 +124,181 @@ public final String host() {\n \n     @Override\n     public final int port() {\n-        return lazyParseRequestTarget().explicitPort();\n+        return lazyParseRequestTarget().port();\n     }\n \n     @Override\n     public final String rawPath() {\n-        return lazyParseRequestTarget().rawPath();\n+        return lazyParseRequestTarget().path();\n     }\n \n     @Override\n     public HttpRequestMetaData rawPath(final String path) {", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzODUxMA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515438510", "bodyText": "good call on the tests.\nwe can be more strict about the method, but the method is mutable so it maybe awkward if the user has to sequence the methods (e.g. first change method, then change path components). lets defer being more strict here to a followup if necessary.", "author": "Scottmitch", "createdAt": "2020-10-31T01:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyMTQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyODM4Mg==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514628382", "bodyText": "It's ok to have a query param that contains only a key, but no value. In this case users can pass a null instead of an empty list. It should be ok to allow null here`.", "author": "idelpivnitskiy", "createdAt": "2020-10-29T23:40:58Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -269,78 +383,131 @@ public boolean removeQueryParameters(final String key, final String value) {\n         return lazyParseQueryString().remove(key, value);\n     }\n \n-    @Nullable\n-    @Override\n-    public final String effectiveHost() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestHost;\n-    }\n-\n     @Override\n-    public final int effectivePort() {\n-        lazyParseEffectiveRequest();\n-        return effectiveRequestPort;\n+    public HostAndPort effectiveHostAndPort() {\n+        final CharSequence hostHeader;\n+        final Uri effectiveRequestUri = lazyParseRequestTarget();\n+        final String effectiveRequestUriHost = effectiveRequestUri.host();\n+        if (effectiveRequestUriHost != null) {\n+            return HostAndPort.of(effectiveRequestUriHost, effectiveRequestUri.port());\n+        } else if ((hostHeader = headers().get(HOST)) != null) {\n+            return parseHostHeader(hostHeader.toString());\n+        }\n+        return null;\n     }\n \n     private HttpQuery lazyParseQueryString() {\n         if (httpQuery == null) {\n-            httpQuery = new HttpQuery(decodeParams(lazyParseRequestTarget().rawQuery()), this::setQueryParams);\n+            httpQuery = new HttpQuery(decodeQueryParams(lazyParseRequestTarget().query(),\n+                    REQUEST_TARGET_CHARSET, DEFAULT_MAX_QUERY_PARAMS), this::setQueryParams);\n         }\n         return httpQuery;\n     }\n \n-    private HttpUri lazyParseRequestTarget() {\n+    private Uri lazyParseRequestTarget() {\n         if (requestTargetUri == null) {\n-            requestTargetUri = new HttpUri(requestTarget());\n+            requestTargetUri = CONNECT.equals(method) ? new HttpAuthorityFormUri(requestTarget()) :\n+                    new Uri3986(requestTarget());\n         }\n         return requestTargetUri;\n     }\n \n-    private void lazyParseEffectiveRequest() {\n-        final CharSequence hostHeader = headers().get(HOST);\n-\n-        if (effectiveRequestPort == PORT_NOT_ASSIGNED || !Objects.equals(hostHeader, effectiveRequestHostHeader)) {\n-            final HttpUri effectiveRequestUri = new HttpUri(requestTarget(),\n-                    () -> hostHeader != null ? hostHeader.toString() : null);\n-            effectiveRequestHost = effectiveRequestUri.host();\n-            effectiveRequestPort = effectiveRequestUri.explicitPort();\n-            effectiveRequestHostHeader = hostHeader;\n+    private static HostAndPort parseHostHeader(String parsedHostHeader) {\n+        String parsedHost;\n+        int parsedPort = -1;\n+        final int x = parsedHostHeader.lastIndexOf(':');\n+        if (x > 0) {\n+            final int y = parsedHostHeader.lastIndexOf(':', x - 1);\n+            if (y >= 0) {\n+                // IPv6 address is present in the header\n+                // https://tools.ietf.org/html/rfc3986#section-3.2.2\n+                // A host identified by an Internet Protocol literal address, version 6\n+                // [RFC3513] or later, is distinguished by enclosing the IP literal\n+                // within square brackets (\"[\" and \"]\").  This is the only place where\n+                // square bracket characters are allowed in the URI syntax.\n+                final int cb;\n+                if (parsedHostHeader.charAt(0) != '[' || (cb = parsedHostHeader.lastIndexOf(']')) < 0) {\n+                    throw new IllegalArgumentException(\"IPv6 address should be in square brackets\");\n+                }\n+                if (cb < x) {\n+                    parsedHost = parsedHostHeader.substring(0, x);\n+                    parsedPort = parsePort(parsedHostHeader, x + 1, parsedHostHeader.length());\n+                } else if (cb != parsedHostHeader.length() - 1) {\n+                    throw new IllegalArgumentException(\n+                            \"']' should be at the end of IPv6 address or before port number\");\n+                } else {\n+                    parsedHost = parsedHostHeader;\n+                }\n+            } else {\n+                // IPv4 or literal host with port number\n+                parsedHost = parsedHostHeader.substring(0, x);\n+                parsedPort = parsePort(parsedHostHeader, x + 1, parsedHostHeader.length());\n+            }\n+        } else if (x < 0) {\n+            parsedHost = parsedHostHeader;\n+        } else {\n+            throw new IllegalArgumentException(\"Illegal position of colon in the host header\");\n         }\n+        return HostAndPort.of(parsedHost, parsedPort);\n     }\n \n     // package-private for testing.\n     void setQueryParams(final Map<String, List<String>> params) {\n-        final QueryStringEncoder encoder = new QueryStringEncoder(rawPath());\n+        Uri httpUri = lazyParseRequestTarget();\n+        StringBuilder sb = new StringBuilder(httpUri.uri().length() + params.size() * 8);\n+        if (httpUri.scheme() != null) {\n+            sb.append(httpUri.scheme()).append(':');\n+        }\n+        if (httpUri.host() != null) {\n+            // The authority component is preceded by a double slash (\"//\")\n+            // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+            sb.append(\"//\");\n+            if (httpUri.userInfo() != null) {\n+                sb.append(httpUri.userInfo()).append('@');\n+            }\n \n-        for (final Map.Entry<String, List<String>> entry : params.entrySet()) {\n-            for (final String value : entry.getValue()) {\n-                encoder.addParam(entry.getKey(), value);\n+            sb.append(httpUri.host());\n+            if (httpUri.port() >= 0) {\n+                sb.append(':').append(httpUri.port());\n             }\n         }\n \n-        requestTarget(encodeRequestTarget(null, null, encoder.toString()));\n-    }\n+        sb.append(httpUri.path());\n+\n+        // Append query params\n+        Iterator<Entry<String, List<String>>> itr = params.entrySet().iterator();\n+        char prefixChar = '?';\n+        while (itr.hasNext()) {\n+            Entry<String, List<String>> next = itr.next();\n+            String encodedKey = encodeComponent(QUERY, next.getKey(), REQUEST_TARGET_CHARSET, true);\n+            sb.append(prefixChar).append(encodedKey);\n+            Iterator<String> valuesItr = next.getValue().iterator();", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzOTE2Mw==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515439163", "bodyText": "this method is internal and it isn't possible to have a null list as the value in the map. I can account for null here though.", "author": "Scottmitch", "createdAt": "2020-10-31T01:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyODM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMTEwNQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514631105", "bodyText": "Can we return an empty map here? Consider adding a comment in the code if not", "author": "idelpivnitskiy", "createdAt": "2020-10-29T23:49:56Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/UriUtils.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import javax.annotation.Nullable;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+\n+final class UriUtils {\n+    // https://tools.ietf.org/html/rfc3986 declares that all delimiter/terminal values are US-ASCII\n+    // https://tools.ietf.org/html/rfc3986#section-2. This means values fall within the [0, 127] range. This range\n+    // can be represented as a bitset/bitmask with two longs (high, low), which reduces the amount of conditional\n+    // statements required to validate characters belonging to each character class. The following final variables\n+    // provide the bitmask for the different character classes defined in rfc3986, and isBitSet can be used to verify if\n+    // a bit is set for a particular (high, low) mask pair.\n+    //\n+    // pct-encoded is omitted below. This criteria is asserted outside this scope because it requires checking multiple\n+    // bytes and advancing the loop index accordingly.\n+\n+    private static final long DIGIT_LMASK = lowMask('0', '9');\n+    private static final long DIGIT_HMASK = highMask('0', '9');\n+\n+    private static final long ALPHA_LMASK = lowMask('a', 'z') | lowMask('A', 'Z');\n+    private static final long ALPHA_HMASK = highMask('a', 'z') | highMask('A', 'Z');\n+\n+    private static final long HEXDIG_LMASK = DIGIT_LMASK | lowMask('a', 'f') | lowMask('A', 'F');\n+    private static final long HEXDIG_HMASK = DIGIT_HMASK | highMask('a', 'f') | highMask('A', 'F');\n+\n+    // unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n+    private static final long UNRESERVED_LMASK = ALPHA_LMASK | DIGIT_LMASK | lowMask(\"-._~\");\n+    private static final long UNRESERVED_HMASK = ALPHA_HMASK | DIGIT_HMASK | highMask(\"-._~\");\n+\n+    // sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n+    //                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n+    private static final long SUBDELIM_LMASK = lowMask(\"!$&'()*+,;=\");\n+    private static final long SUBDELIM_HMASK = highMask(\"!$&'()*+,;=\");\n+\n+    // pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n+    private static final long PCHAR_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\";@\");\n+\n+    private static final long PCHAR_NOSUBDELIM_LMASK = UNRESERVED_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_NOSUBDELIM_HMASK = UNRESERVED_HMASK | highMask(\";@\");\n+\n+    // userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n+    static final long USERINFO_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\":\");\n+    static final long USERINFO_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\":\");\n+\n+    // path        = *(pchar / \"/\")\n+    static final long PATH_LMASK = PCHAR_LMASK | lowMask(\"/\");\n+    static final long PATH_HMASK = PCHAR_HMASK | highMask(\"/\");\n+\n+    static final long PATH_SEGMENT_LMASK = PCHAR_LMASK;\n+    static final long PATH_SEGMENT_HMASK = PCHAR_HMASK;\n+\n+    // query       = *( pchar / \"/\" / \"?\" )\n+    static final long QUERY_LMASK = PCHAR_LMASK | lowMask(\"/?\");\n+    static final long QUERY_HMASK = PCHAR_HMASK | highMask(\"/?\");\n+\n+    static final long QUERY_VALUE_LMASK = PCHAR_NOSUBDELIM_LMASK | lowMask(\"/?\");\n+    static final long QUERY_VALUE_HMASK = PCHAR_NOSUBDELIM_HMASK | highMask(\"/?\");\n+\n+    // fragment    = *( pchar / \"/\" / \"?\" )\n+    static final long FRAGMENT_LMASK = QUERY_LMASK;\n+    static final long FRAGMENT_HMASK = QUERY_HMASK;\n+\n+    // host        = IP-literal / IPv4address / reg-name\n+    // reg-name    = *( unreserved / pct-encoded / sub-delims )\n+    static final long HOST_NON_IP_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK;\n+    static final long HOST_NON_IP_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK;\n+\n+    private UriUtils() {\n+    }\n+\n+    /**\n+     * Decode the specified raw query with the specified {@code charset} for the specified maximum number of parameters.\n+     */\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams) {\n+        return decodeQueryParams(rawQuery, charset, maxParams, UriUtils::decodeComponent);\n+    }\n+\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams,\n+                                                       BiFunction<String, Charset, String> decoder) {\n+        if (maxParams <= 0) {\n+            throw new IllegalArgumentException(\"maxParams: \" + maxParams + \" (expected: > 0)\");\n+        }\n+\n+        if (rawQuery == null || rawQuery.isEmpty()) {\n+            return new LinkedHashMap<>(2);", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzOTYzOQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515439639", "bodyText": "this is pre-existing behavior. looks like the query modifier methods assume the returned Map is modifiable.", "author": "Scottmitch", "createdAt": "2020-10-31T01:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMTEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMTk5NA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514631994", "bodyText": "Consider adding the passed uri for all exception messages", "author": "idelpivnitskiy", "createdAt": "2020-10-29T23:53:07Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpAuthorityFormUri.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.nio.charset.Charset;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.UriComponentType.HOST_NON_IP;\n+import static io.servicetalk.http.api.UriUtils.decodeComponent;\n+import static io.servicetalk.http.api.UriUtils.encodeComponent;\n+import static io.servicetalk.http.api.UriUtils.parsePort;\n+\n+/**\n+ * <a href=\"https://tools.ietf.org/html/rfc7230#section-5.3.3\">authority-form</a> URI.\n+ */\n+final class HttpAuthorityFormUri implements Uri {\n+    private final String uri;\n+    private final String host;\n+    private final int port;\n+\n+    HttpAuthorityFormUri(final String uri) {\n+        int i = 0;\n+        int begin = 0;\n+        String parsedHost = null;\n+        int parsedPort = -1;\n+        byte parsingIPv6 = 0; // 0 = not parsed, 1 = parsing, 2 = already parsed\n+        boolean foundColonForPort = false;\n+        while (i < uri.length()) {\n+            final char c = uri.charAt(i);\n+            if (c == '[') {\n+                if (parsingIPv6 != 0 || parsedHost != null) {\n+                    throw new IllegalArgumentException(\"unexpected [\");\n+                }\n+                parsingIPv6 = 1;\n+                begin = i++; // post increment, preserve the '[' for original uri for pathEndIndex.\n+            } else if (c == ']') {\n+                if (parsingIPv6 == 0) {\n+                    throw new IllegalArgumentException(\"unexpected ]\");\n+                } else if (i - 1 <= begin) {\n+                    throw new IllegalArgumentException(\"empty ip literal\");\n+                }\n+                // Copy the '[' and ']' characters. pathEndIndex depends upon retaining the uri contents.\n+                parsedHost = uri.substring(begin, i + 1);\n+                foundColonForPort = false;\n+                parsingIPv6 = 2;\n+                begin = ++i;\n+            } else if (c == ':') {\n+                if (parsingIPv6 == 0) {\n+                    if (parsedHost != null) {\n+                        throw new IllegalArgumentException(\"duplicate/invalid host\");\n+                    }\n+                    parsedHost = uri.substring(begin, i);\n+                }\n+                ++i;\n+                if (parsingIPv6 != 1) {\n+                    begin = i;\n+                    foundColonForPort = true;\n+                }\n+            } else if (c == '@' || c == '?' || c == '#' || c == '/') {\n+                throw new IllegalArgumentException(\"authority-form URI doesn't allow userinfo, path, query, fragment\");\n+            } else {\n+                ++i;\n+            }\n+        }\n+\n+        if (parsedHost == null) {\n+            if (parsingIPv6 == 1) {\n+                throw new IllegalArgumentException(\"missing closing ] for IP-literal\");\n+            }\n+            parsedHost = uri;\n+        } else if (foundColonForPort) {\n+            parsedPort = parsePort(uri, begin, uri.length());\n+        } else if (parsedHost.length() != uri.length()) {\n+            throw new IllegalArgumentException(\"authority-form URI only supports the host component\");", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzOTk5OQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515439999", "bodyText": "I'm hesitant to include user data in exceptions. lets handle this as a followup PR so the change is more explicit", "author": "Scottmitch", "createdAt": "2020-10-31T01:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMjA3NQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514632075", "bodyText": "Consider adding the passed uri for all exception messages", "author": "idelpivnitskiy", "createdAt": "2020-10-29T23:53:25Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/Uri3986.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ * Copyright \u00a9 2018-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.servicetalk.http.api;\n+\n+import java.nio.charset.Charset;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.UriComponentType.FRAGMENT;\n+import static io.servicetalk.http.api.UriComponentType.HOST_NON_IP;\n+import static io.servicetalk.http.api.UriComponentType.PATH;\n+import static io.servicetalk.http.api.UriComponentType.QUERY;\n+import static io.servicetalk.http.api.UriComponentType.USER_INFO;\n+import static io.servicetalk.http.api.UriUtils.decodeComponent;\n+import static io.servicetalk.http.api.UriUtils.encodeComponent;\n+import static io.servicetalk.http.api.UriUtils.parsePort;\n+\n+/**\n+ * Represents the components of a <a href=\"https://tools.ietf.org/html/rfc3986\">URI</a>.\n+ * <p>\n+ * {@link java.net.URI} targets the obsolete <a href=\"https://tools.ietf.org/html/rfc2396\">rfc2732</a>. This class\n+ * also lazy parses some components which may not be as commonly used (e.g. query, fragment).\n+ */\n+final class Uri3986 implements Uri {\n+    @SuppressWarnings(\"StringOperationCanBeSimplified\")\n+    private static final String NULL_COMPONENT = new String(\"\"); // instance equality required!\n+    private final String uri;\n+    @Nullable\n+    private final String scheme;\n+    @Nullable\n+    private final String userInfo;\n+    @Nullable\n+    private final String host;\n+    private final int port;\n+    private final String path;\n+    @Nullable\n+    private String query;\n+    @Nullable\n+    private String fragment;\n+\n+    /**\n+     * Create a new instance give a {@link String} following\n+     * <a href=\"https://tools.ietf.org/html/rfc3986#section-3\">URI Syntax</a>.\n+     * <pre>\n+     * foo://example.com:8042/over/there?name=ferret#nose\n+     * \\_/   \\______________/\\_________/ \\_________/ \\__/\n+     * |           |            |            |        |\n+     * scheme     authority       path        query   fragment\n+     * </pre>\n+     * @param uri A URI string.\n+     */\n+    Uri3986(final String uri) {\n+        int i = 0;\n+        int begin = 0;\n+        String parsedScheme = null;\n+        String parsedUserInfo = null;\n+        String parsedHost = null;\n+        int parsedPort = -1;\n+        String parsedPath = null;\n+        boolean eligibleToParseScheme = true;\n+\n+        outerloop:\n+        while (i < uri.length()) {\n+            final char c = uri.charAt(i);\n+            if (c == '/') {\n+                if (begin == i && parsedHost == null && uri.length() - 1 > i && uri.charAt(i + 1) == '/') {\n+                    // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+                    i += 2;\n+                    begin = i;\n+                    final int authorityBegin = begin;\n+                    byte parsingIPv6 = 0; // 0 = not parsed, 1 = parsing, 2 = already parsed\n+                    boolean foundColonForPort = false;\n+                    while (i < uri.length()) {\n+                        final char c2 = uri.charAt(i);\n+                        if (c2 == '@') {\n+                            if (parsedUserInfo != null) {\n+                                throw new IllegalArgumentException(\"duplicate userinfo\");", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMjY0Ng==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514632646", "bodyText": "We need these additional 6 bytes only if port is present", "author": "idelpivnitskiy", "createdAt": "2020-10-29T23:55:17Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/Uri3986.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ * Copyright \u00a9 2018-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.servicetalk.http.api;\n+\n+import java.nio.charset.Charset;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.UriComponentType.FRAGMENT;\n+import static io.servicetalk.http.api.UriComponentType.HOST_NON_IP;\n+import static io.servicetalk.http.api.UriComponentType.PATH;\n+import static io.servicetalk.http.api.UriComponentType.QUERY;\n+import static io.servicetalk.http.api.UriComponentType.USER_INFO;\n+import static io.servicetalk.http.api.UriUtils.decodeComponent;\n+import static io.servicetalk.http.api.UriUtils.encodeComponent;\n+import static io.servicetalk.http.api.UriUtils.parsePort;\n+\n+/**\n+ * Represents the components of a <a href=\"https://tools.ietf.org/html/rfc3986\">URI</a>.\n+ * <p>\n+ * {@link java.net.URI} targets the obsolete <a href=\"https://tools.ietf.org/html/rfc2396\">rfc2732</a>. This class\n+ * also lazy parses some components which may not be as commonly used (e.g. query, fragment).\n+ */\n+final class Uri3986 implements Uri {\n+    @SuppressWarnings(\"StringOperationCanBeSimplified\")\n+    private static final String NULL_COMPONENT = new String(\"\"); // instance equality required!\n+    private final String uri;\n+    @Nullable\n+    private final String scheme;\n+    @Nullable\n+    private final String userInfo;\n+    @Nullable\n+    private final String host;\n+    private final int port;\n+    private final String path;\n+    @Nullable\n+    private String query;\n+    @Nullable\n+    private String fragment;\n+\n+    /**\n+     * Create a new instance give a {@link String} following\n+     * <a href=\"https://tools.ietf.org/html/rfc3986#section-3\">URI Syntax</a>.\n+     * <pre>\n+     * foo://example.com:8042/over/there?name=ferret#nose\n+     * \\_/   \\______________/\\_________/ \\_________/ \\__/\n+     * |           |            |            |        |\n+     * scheme     authority       path        query   fragment\n+     * </pre>\n+     * @param uri A URI string.\n+     */\n+    Uri3986(final String uri) {\n+        int i = 0;\n+        int begin = 0;\n+        String parsedScheme = null;\n+        String parsedUserInfo = null;\n+        String parsedHost = null;\n+        int parsedPort = -1;\n+        String parsedPath = null;\n+        boolean eligibleToParseScheme = true;\n+\n+        outerloop:\n+        while (i < uri.length()) {\n+            final char c = uri.charAt(i);\n+            if (c == '/') {\n+                if (begin == i && parsedHost == null && uri.length() - 1 > i && uri.charAt(i + 1) == '/') {\n+                    // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+                    i += 2;\n+                    begin = i;\n+                    final int authorityBegin = begin;\n+                    byte parsingIPv6 = 0; // 0 = not parsed, 1 = parsing, 2 = already parsed\n+                    boolean foundColonForPort = false;\n+                    while (i < uri.length()) {\n+                        final char c2 = uri.charAt(i);\n+                        if (c2 == '@') {\n+                            if (parsedUserInfo != null) {\n+                                throw new IllegalArgumentException(\"duplicate userinfo\");\n+                            }\n+                            // Userinfo has `:` as valid. If we previously parsed the host throw it away.\n+                            parsedUserInfo = uri.substring(authorityBegin, i);\n+                            parsedHost = null;\n+                            begin = ++i;\n+                        } else if (c2 == '[') {\n+                            if (parsingIPv6 != 0 || parsedHost != null) {\n+                                throw new IllegalArgumentException(\"unexpected [\");\n+                            }\n+                            parsingIPv6 = 1;\n+                            begin = i++; // post increment, preserve the '[' for original uri for pathEndIndex.\n+                        } else if (c2 == ']') {\n+                            if (parsingIPv6 == 0) {\n+                                throw new IllegalArgumentException(\"unexpected ]\");\n+                            } else if (i - 1 <= begin) {\n+                                throw new IllegalArgumentException(\"empty ip literal\");\n+                            }\n+                            // Copy the '[' and ']' characters. pathEndIndex depends upon retaining the uri contents.\n+                            parsedHost = uri.substring(begin, i + 1);\n+                            foundColonForPort = false;\n+                            parsingIPv6 = 2;\n+                            begin = ++i;\n+                        } else if (c2 == ':') {\n+                            if (parsingIPv6 == 0) {\n+                                if (parsedHost != null) {\n+                                    throw new IllegalArgumentException(\"duplicate/invalid host\");\n+                                }\n+                                parsedHost = uri.substring(begin, i);\n+                            }\n+                            ++i;\n+                            if (parsingIPv6 != 1) {\n+                                begin = i;\n+                                foundColonForPort = true;\n+                            }\n+                        } else if (c2 == '?' || c2 == '#' || c2 == '/') {\n+                            if (parsedHost == null) {\n+                                if (parsingIPv6 == 1) {\n+                                    throw new IllegalArgumentException(\"missing closing ] for IP-literal\");\n+                                }\n+                                parsedHost = uri.substring(begin, i);\n+                            } else if (foundColonForPort) {\n+                                parsedPort = parsePort(uri, begin, i);\n+                            }\n+                            if (c2 == '/') {\n+                                begin = i++; // post increment, preserve the '/' for original uri for pathEndIndex.\n+                                continue outerloop;\n+                            } else {\n+                                parsedPath = \"\";\n+                                begin = ++i;\n+                                break outerloop;\n+                            }\n+                        } else {\n+                            ++i;\n+                        }\n+                    }\n+                    if (i == uri.length()) {\n+                        if (parsedHost == null) {\n+                            if (parsingIPv6 == 1) {\n+                                throw new IllegalArgumentException(\"missing closing ] for IP-literal\");\n+                            }\n+                            parsedHost = uri.substring(begin);\n+                        } else if (foundColonForPort) {\n+                            parsedPort = parsePort(uri, begin, i);\n+                        }\n+                        begin = i;\n+                    }\n+                } else {\n+                    eligibleToParseScheme = false;\n+                    ++i;\n+                }\n+            } else if (c == ':' && begin == 0 && parsedScheme == null && eligibleToParseScheme) {\n+                if (i == 0) {\n+                    throw new IllegalArgumentException(\"empty scheme\");\n+                }\n+                parsedScheme = uri.substring(0, i);\n+                begin = ++i;\n+                // We don't enforce the following, browsers still generate these types of requests.\n+                // https://tools.ietf.org/html/rfc3986#section-3.3\n+                // > In addition, a URI reference (Section 4.1) may be a relative-path reference,\n+                //   in which case the first path segment cannot contain a colon (\":\") character.\n+            } else if (c == '?' || c == '#') {\n+                parsedPath = uri.substring(begin, i);\n+                break;\n+            } else {\n+                ++i;\n+            }\n+        }\n+\n+        if (i == uri.length()) {\n+            parsedPath = uri.substring(begin);\n+        }\n+        assert parsedPath != null;\n+\n+        scheme = parsedScheme;\n+        userInfo = parsedUserInfo;\n+        host = parsedHost;\n+        port = parsedPort;\n+        path = parsedPath;\n+        this.uri = uri;\n+    }\n+\n+    @Override\n+    public String uri() {\n+        return uri;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String scheme() {\n+        return scheme;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String authority() {\n+        if (host == null) {\n+            return null;\n+        }\n+        final StringBuilder sb;\n+        if (userInfo == null) {\n+            sb = new StringBuilder(host.length() + 6); // 6 max port chars + `:`\n+        } else {\n+            sb = new StringBuilder(host.length() + userInfo.length() + 7); // '@' + 6 max port chars + `:`", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0MDExMQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515440111", "bodyText": "didn't think it was worth additional conditionals to save 6 bytes.", "author": "Scottmitch", "createdAt": "2020-10-31T01:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMjY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMzQ2MQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514633461", "bodyText": "Port that is equal to 0 does not make much sense, should we allow it?", "author": "idelpivnitskiy", "createdAt": "2020-10-29T23:58:01Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/Uri3986.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ * Copyright \u00a9 2018-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.servicetalk.http.api;\n+\n+import java.nio.charset.Charset;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.UriComponentType.FRAGMENT;\n+import static io.servicetalk.http.api.UriComponentType.HOST_NON_IP;\n+import static io.servicetalk.http.api.UriComponentType.PATH;\n+import static io.servicetalk.http.api.UriComponentType.QUERY;\n+import static io.servicetalk.http.api.UriComponentType.USER_INFO;\n+import static io.servicetalk.http.api.UriUtils.decodeComponent;\n+import static io.servicetalk.http.api.UriUtils.encodeComponent;\n+import static io.servicetalk.http.api.UriUtils.parsePort;\n+\n+/**\n+ * Represents the components of a <a href=\"https://tools.ietf.org/html/rfc3986\">URI</a>.\n+ * <p>\n+ * {@link java.net.URI} targets the obsolete <a href=\"https://tools.ietf.org/html/rfc2396\">rfc2732</a>. This class\n+ * also lazy parses some components which may not be as commonly used (e.g. query, fragment).\n+ */\n+final class Uri3986 implements Uri {\n+    @SuppressWarnings(\"StringOperationCanBeSimplified\")\n+    private static final String NULL_COMPONENT = new String(\"\"); // instance equality required!\n+    private final String uri;\n+    @Nullable\n+    private final String scheme;\n+    @Nullable\n+    private final String userInfo;\n+    @Nullable\n+    private final String host;\n+    private final int port;\n+    private final String path;\n+    @Nullable\n+    private String query;\n+    @Nullable\n+    private String fragment;\n+\n+    /**\n+     * Create a new instance give a {@link String} following\n+     * <a href=\"https://tools.ietf.org/html/rfc3986#section-3\">URI Syntax</a>.\n+     * <pre>\n+     * foo://example.com:8042/over/there?name=ferret#nose\n+     * \\_/   \\______________/\\_________/ \\_________/ \\__/\n+     * |           |            |            |        |\n+     * scheme     authority       path        query   fragment\n+     * </pre>\n+     * @param uri A URI string.\n+     */\n+    Uri3986(final String uri) {\n+        int i = 0;\n+        int begin = 0;\n+        String parsedScheme = null;\n+        String parsedUserInfo = null;\n+        String parsedHost = null;\n+        int parsedPort = -1;\n+        String parsedPath = null;\n+        boolean eligibleToParseScheme = true;\n+\n+        outerloop:\n+        while (i < uri.length()) {\n+            final char c = uri.charAt(i);\n+            if (c == '/') {\n+                if (begin == i && parsedHost == null && uri.length() - 1 > i && uri.charAt(i + 1) == '/') {\n+                    // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+                    i += 2;\n+                    begin = i;\n+                    final int authorityBegin = begin;\n+                    byte parsingIPv6 = 0; // 0 = not parsed, 1 = parsing, 2 = already parsed\n+                    boolean foundColonForPort = false;\n+                    while (i < uri.length()) {\n+                        final char c2 = uri.charAt(i);\n+                        if (c2 == '@') {\n+                            if (parsedUserInfo != null) {\n+                                throw new IllegalArgumentException(\"duplicate userinfo\");\n+                            }\n+                            // Userinfo has `:` as valid. If we previously parsed the host throw it away.\n+                            parsedUserInfo = uri.substring(authorityBegin, i);\n+                            parsedHost = null;\n+                            begin = ++i;\n+                        } else if (c2 == '[') {\n+                            if (parsingIPv6 != 0 || parsedHost != null) {\n+                                throw new IllegalArgumentException(\"unexpected [\");\n+                            }\n+                            parsingIPv6 = 1;\n+                            begin = i++; // post increment, preserve the '[' for original uri for pathEndIndex.\n+                        } else if (c2 == ']') {\n+                            if (parsingIPv6 == 0) {\n+                                throw new IllegalArgumentException(\"unexpected ]\");\n+                            } else if (i - 1 <= begin) {\n+                                throw new IllegalArgumentException(\"empty ip literal\");\n+                            }\n+                            // Copy the '[' and ']' characters. pathEndIndex depends upon retaining the uri contents.\n+                            parsedHost = uri.substring(begin, i + 1);\n+                            foundColonForPort = false;\n+                            parsingIPv6 = 2;\n+                            begin = ++i;\n+                        } else if (c2 == ':') {\n+                            if (parsingIPv6 == 0) {\n+                                if (parsedHost != null) {\n+                                    throw new IllegalArgumentException(\"duplicate/invalid host\");\n+                                }\n+                                parsedHost = uri.substring(begin, i);\n+                            }\n+                            ++i;\n+                            if (parsingIPv6 != 1) {\n+                                begin = i;\n+                                foundColonForPort = true;\n+                            }\n+                        } else if (c2 == '?' || c2 == '#' || c2 == '/') {\n+                            if (parsedHost == null) {\n+                                if (parsingIPv6 == 1) {\n+                                    throw new IllegalArgumentException(\"missing closing ] for IP-literal\");\n+                                }\n+                                parsedHost = uri.substring(begin, i);\n+                            } else if (foundColonForPort) {\n+                                parsedPort = parsePort(uri, begin, i);\n+                            }\n+                            if (c2 == '/') {\n+                                begin = i++; // post increment, preserve the '/' for original uri for pathEndIndex.\n+                                continue outerloop;\n+                            } else {\n+                                parsedPath = \"\";\n+                                begin = ++i;\n+                                break outerloop;\n+                            }\n+                        } else {\n+                            ++i;\n+                        }\n+                    }\n+                    if (i == uri.length()) {\n+                        if (parsedHost == null) {\n+                            if (parsingIPv6 == 1) {\n+                                throw new IllegalArgumentException(\"missing closing ] for IP-literal\");\n+                            }\n+                            parsedHost = uri.substring(begin);\n+                        } else if (foundColonForPort) {\n+                            parsedPort = parsePort(uri, begin, i);\n+                        }\n+                        begin = i;\n+                    }\n+                } else {\n+                    eligibleToParseScheme = false;\n+                    ++i;\n+                }\n+            } else if (c == ':' && begin == 0 && parsedScheme == null && eligibleToParseScheme) {\n+                if (i == 0) {\n+                    throw new IllegalArgumentException(\"empty scheme\");\n+                }\n+                parsedScheme = uri.substring(0, i);\n+                begin = ++i;\n+                // We don't enforce the following, browsers still generate these types of requests.\n+                // https://tools.ietf.org/html/rfc3986#section-3.3\n+                // > In addition, a URI reference (Section 4.1) may be a relative-path reference,\n+                //   in which case the first path segment cannot contain a colon (\":\") character.\n+            } else if (c == '?' || c == '#') {\n+                parsedPath = uri.substring(begin, i);\n+                break;\n+            } else {\n+                ++i;\n+            }\n+        }\n+\n+        if (i == uri.length()) {\n+            parsedPath = uri.substring(begin);\n+        }\n+        assert parsedPath != null;\n+\n+        scheme = parsedScheme;\n+        userInfo = parsedUserInfo;\n+        host = parsedHost;\n+        port = parsedPort;\n+        path = parsedPath;\n+        this.uri = uri;\n+    }\n+\n+    @Override\n+    public String uri() {\n+        return uri;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String scheme() {\n+        return scheme;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String authority() {\n+        if (host == null) {\n+            return null;\n+        }\n+        final StringBuilder sb;\n+        if (userInfo == null) {\n+            sb = new StringBuilder(host.length() + 6); // 6 max port chars + `:`\n+        } else {\n+            sb = new StringBuilder(host.length() + userInfo.length() + 7); // '@' + 6 max port chars + `:`\n+            sb.append(userInfo).append('@');\n+        }\n+\n+        sb.append(host);\n+        if (port >= 0) {", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0MDIzNg==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515440236", "bodyText": "I don't think we need to prevent it for uri parsing, it is within the valid domain.", "author": "Scottmitch", "createdAt": "2020-10-31T01:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMzQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMzk5NA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514633994", "bodyText": "This method is not used anywhere else, consider doing these checks inside equals", "author": "idelpivnitskiy", "createdAt": "2020-10-29T23:59:53Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/Uri3986.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ * Copyright \u00a9 2018-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.servicetalk.http.api;\n+\n+import java.nio.charset.Charset;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.UriComponentType.FRAGMENT;\n+import static io.servicetalk.http.api.UriComponentType.HOST_NON_IP;\n+import static io.servicetalk.http.api.UriComponentType.PATH;\n+import static io.servicetalk.http.api.UriComponentType.QUERY;\n+import static io.servicetalk.http.api.UriComponentType.USER_INFO;\n+import static io.servicetalk.http.api.UriUtils.decodeComponent;\n+import static io.servicetalk.http.api.UriUtils.encodeComponent;\n+import static io.servicetalk.http.api.UriUtils.parsePort;\n+\n+/**\n+ * Represents the components of a <a href=\"https://tools.ietf.org/html/rfc3986\">URI</a>.\n+ * <p>\n+ * {@link java.net.URI} targets the obsolete <a href=\"https://tools.ietf.org/html/rfc2396\">rfc2732</a>. This class\n+ * also lazy parses some components which may not be as commonly used (e.g. query, fragment).\n+ */\n+final class Uri3986 implements Uri {\n+    @SuppressWarnings(\"StringOperationCanBeSimplified\")\n+    private static final String NULL_COMPONENT = new String(\"\"); // instance equality required!\n+    private final String uri;\n+    @Nullable\n+    private final String scheme;\n+    @Nullable\n+    private final String userInfo;\n+    @Nullable\n+    private final String host;\n+    private final int port;\n+    private final String path;\n+    @Nullable\n+    private String query;\n+    @Nullable\n+    private String fragment;\n+\n+    /**\n+     * Create a new instance give a {@link String} following\n+     * <a href=\"https://tools.ietf.org/html/rfc3986#section-3\">URI Syntax</a>.\n+     * <pre>\n+     * foo://example.com:8042/over/there?name=ferret#nose\n+     * \\_/   \\______________/\\_________/ \\_________/ \\__/\n+     * |           |            |            |        |\n+     * scheme     authority       path        query   fragment\n+     * </pre>\n+     * @param uri A URI string.\n+     */\n+    Uri3986(final String uri) {\n+        int i = 0;\n+        int begin = 0;\n+        String parsedScheme = null;\n+        String parsedUserInfo = null;\n+        String parsedHost = null;\n+        int parsedPort = -1;\n+        String parsedPath = null;\n+        boolean eligibleToParseScheme = true;\n+\n+        outerloop:\n+        while (i < uri.length()) {\n+            final char c = uri.charAt(i);\n+            if (c == '/') {\n+                if (begin == i && parsedHost == null && uri.length() - 1 > i && uri.charAt(i + 1) == '/') {\n+                    // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+                    i += 2;\n+                    begin = i;\n+                    final int authorityBegin = begin;\n+                    byte parsingIPv6 = 0; // 0 = not parsed, 1 = parsing, 2 = already parsed\n+                    boolean foundColonForPort = false;\n+                    while (i < uri.length()) {\n+                        final char c2 = uri.charAt(i);\n+                        if (c2 == '@') {\n+                            if (parsedUserInfo != null) {\n+                                throw new IllegalArgumentException(\"duplicate userinfo\");\n+                            }\n+                            // Userinfo has `:` as valid. If we previously parsed the host throw it away.\n+                            parsedUserInfo = uri.substring(authorityBegin, i);\n+                            parsedHost = null;\n+                            begin = ++i;\n+                        } else if (c2 == '[') {\n+                            if (parsingIPv6 != 0 || parsedHost != null) {\n+                                throw new IllegalArgumentException(\"unexpected [\");\n+                            }\n+                            parsingIPv6 = 1;\n+                            begin = i++; // post increment, preserve the '[' for original uri for pathEndIndex.\n+                        } else if (c2 == ']') {\n+                            if (parsingIPv6 == 0) {\n+                                throw new IllegalArgumentException(\"unexpected ]\");\n+                            } else if (i - 1 <= begin) {\n+                                throw new IllegalArgumentException(\"empty ip literal\");\n+                            }\n+                            // Copy the '[' and ']' characters. pathEndIndex depends upon retaining the uri contents.\n+                            parsedHost = uri.substring(begin, i + 1);\n+                            foundColonForPort = false;\n+                            parsingIPv6 = 2;\n+                            begin = ++i;\n+                        } else if (c2 == ':') {\n+                            if (parsingIPv6 == 0) {\n+                                if (parsedHost != null) {\n+                                    throw new IllegalArgumentException(\"duplicate/invalid host\");\n+                                }\n+                                parsedHost = uri.substring(begin, i);\n+                            }\n+                            ++i;\n+                            if (parsingIPv6 != 1) {\n+                                begin = i;\n+                                foundColonForPort = true;\n+                            }\n+                        } else if (c2 == '?' || c2 == '#' || c2 == '/') {\n+                            if (parsedHost == null) {\n+                                if (parsingIPv6 == 1) {\n+                                    throw new IllegalArgumentException(\"missing closing ] for IP-literal\");\n+                                }\n+                                parsedHost = uri.substring(begin, i);\n+                            } else if (foundColonForPort) {\n+                                parsedPort = parsePort(uri, begin, i);\n+                            }\n+                            if (c2 == '/') {\n+                                begin = i++; // post increment, preserve the '/' for original uri for pathEndIndex.\n+                                continue outerloop;\n+                            } else {\n+                                parsedPath = \"\";\n+                                begin = ++i;\n+                                break outerloop;\n+                            }\n+                        } else {\n+                            ++i;\n+                        }\n+                    }\n+                    if (i == uri.length()) {\n+                        if (parsedHost == null) {\n+                            if (parsingIPv6 == 1) {\n+                                throw new IllegalArgumentException(\"missing closing ] for IP-literal\");\n+                            }\n+                            parsedHost = uri.substring(begin);\n+                        } else if (foundColonForPort) {\n+                            parsedPort = parsePort(uri, begin, i);\n+                        }\n+                        begin = i;\n+                    }\n+                } else {\n+                    eligibleToParseScheme = false;\n+                    ++i;\n+                }\n+            } else if (c == ':' && begin == 0 && parsedScheme == null && eligibleToParseScheme) {\n+                if (i == 0) {\n+                    throw new IllegalArgumentException(\"empty scheme\");\n+                }\n+                parsedScheme = uri.substring(0, i);\n+                begin = ++i;\n+                // We don't enforce the following, browsers still generate these types of requests.\n+                // https://tools.ietf.org/html/rfc3986#section-3.3\n+                // > In addition, a URI reference (Section 4.1) may be a relative-path reference,\n+                //   in which case the first path segment cannot contain a colon (\":\") character.\n+            } else if (c == '?' || c == '#') {\n+                parsedPath = uri.substring(begin, i);\n+                break;\n+            } else {\n+                ++i;\n+            }\n+        }\n+\n+        if (i == uri.length()) {\n+            parsedPath = uri.substring(begin);\n+        }\n+        assert parsedPath != null;\n+\n+        scheme = parsedScheme;\n+        userInfo = parsedUserInfo;\n+        host = parsedHost;\n+        port = parsedPort;\n+        path = parsedPath;\n+        this.uri = uri;\n+    }\n+\n+    @Override\n+    public String uri() {\n+        return uri;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String scheme() {\n+        return scheme;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String authority() {\n+        if (host == null) {\n+            return null;\n+        }\n+        final StringBuilder sb;\n+        if (userInfo == null) {\n+            sb = new StringBuilder(host.length() + 6); // 6 max port chars + `:`\n+        } else {\n+            sb = new StringBuilder(host.length() + userInfo.length() + 7); // '@' + 6 max port chars + `:`\n+            sb.append(userInfo).append('@');\n+        }\n+\n+        sb.append(host);\n+        if (port >= 0) {\n+            sb.append(':').append(port);\n+        }\n+        return sb.toString();\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String userInfo() {\n+        return userInfo;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String host() {\n+        return host;\n+    }\n+\n+    @Override\n+    public int port() {\n+        return port;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    @Override\n+    public String path(final Charset charset) {\n+        return decodeComponent(path, charset);\n+    }\n+\n+    @Override\n+    public String query() {\n+        if (query != null) {\n+            return unwrapNullableComponent(query);\n+        }\n+\n+        final int pathEndIndex = pathEndIndex();\n+        if (pathEndIndex >= uri.length() || uri.charAt(pathEndIndex) != '?') {\n+            query = NULL_COMPONENT;\n+            return null;\n+        }\n+        final int fragmentStart = uri.indexOf('#', pathEndIndex + 1);\n+        query = fragmentStart < 0 ? uri.substring(pathEndIndex + 1) :\n+                        uri.substring(pathEndIndex + 1, fragmentStart);\n+        return query;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String query(final Charset charset) {\n+        return isNullableComponent(query) ? null : decodeComponent(query, charset);\n+    }\n+\n+    @Override\n+    public String fragment() {\n+        if (fragment != null) {\n+            return unwrapNullableComponent(fragment);\n+        }\n+\n+        final int pathEndIndex = pathEndIndex();\n+        if (pathEndIndex >= uri.length()) {\n+            fragment = NULL_COMPONENT;\n+            return null;\n+        }\n+\n+        final int fragmentStart = uri.indexOf('#', pathEndIndex);\n+        if (fragmentStart < 0) {\n+            fragment = NULL_COMPONENT;\n+            return null;\n+        }\n+        fragment = uri.substring(fragmentStart + 1);\n+        return fragment;\n+    }\n+\n+    @SuppressWarnings(\"StringEquality\")\n+    @Nullable\n+    private static String unwrapNullableComponent(String component) {\n+        return component == NULL_COMPONENT ? null : component;\n+    }\n+\n+    @SuppressWarnings(\"StringEquality\")\n+    private static boolean isNullableComponent(@Nullable String component) {\n+        return component == null || component == NULL_COMPONENT;\n+    }\n+\n+    private int pathEndIndex() {\n+        int i = 0;\n+        if (scheme != null) {\n+            i = scheme.length() + 1; // ':'\n+        }\n+        if (host != null) {\n+            // The authority component is preceded by a double slash (\"//\")\n+            // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+            i += host.length() + 2; // '/' '/'\n+            if (userInfo != null) {\n+                i += userInfo.length() + 1; // '@'\n+            }\n+            if (port >= 0) {\n+                i += numberOfDigits(port) + 1; // ':'\n+            }\n+        }\n+        i += path.length();\n+        return i;\n+    }\n+\n+    private boolean hostAndPortEqual(final Uri3986 rhs) {", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzNDM2NQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514634365", "bodyText": "Include port in the exception message", "author": "idelpivnitskiy", "createdAt": "2020-10-30T00:01:14Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/Uri3986.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ * Copyright \u00a9 2018-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.servicetalk.http.api;\n+\n+import java.nio.charset.Charset;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.UriComponentType.FRAGMENT;\n+import static io.servicetalk.http.api.UriComponentType.HOST_NON_IP;\n+import static io.servicetalk.http.api.UriComponentType.PATH;\n+import static io.servicetalk.http.api.UriComponentType.QUERY;\n+import static io.servicetalk.http.api.UriComponentType.USER_INFO;\n+import static io.servicetalk.http.api.UriUtils.decodeComponent;\n+import static io.servicetalk.http.api.UriUtils.encodeComponent;\n+import static io.servicetalk.http.api.UriUtils.parsePort;\n+\n+/**\n+ * Represents the components of a <a href=\"https://tools.ietf.org/html/rfc3986\">URI</a>.\n+ * <p>\n+ * {@link java.net.URI} targets the obsolete <a href=\"https://tools.ietf.org/html/rfc2396\">rfc2732</a>. This class\n+ * also lazy parses some components which may not be as commonly used (e.g. query, fragment).\n+ */\n+final class Uri3986 implements Uri {\n+    @SuppressWarnings(\"StringOperationCanBeSimplified\")\n+    private static final String NULL_COMPONENT = new String(\"\"); // instance equality required!\n+    private final String uri;\n+    @Nullable\n+    private final String scheme;\n+    @Nullable\n+    private final String userInfo;\n+    @Nullable\n+    private final String host;\n+    private final int port;\n+    private final String path;\n+    @Nullable\n+    private String query;\n+    @Nullable\n+    private String fragment;\n+\n+    /**\n+     * Create a new instance give a {@link String} following\n+     * <a href=\"https://tools.ietf.org/html/rfc3986#section-3\">URI Syntax</a>.\n+     * <pre>\n+     * foo://example.com:8042/over/there?name=ferret#nose\n+     * \\_/   \\______________/\\_________/ \\_________/ \\__/\n+     * |           |            |            |        |\n+     * scheme     authority       path        query   fragment\n+     * </pre>\n+     * @param uri A URI string.\n+     */\n+    Uri3986(final String uri) {\n+        int i = 0;\n+        int begin = 0;\n+        String parsedScheme = null;\n+        String parsedUserInfo = null;\n+        String parsedHost = null;\n+        int parsedPort = -1;\n+        String parsedPath = null;\n+        boolean eligibleToParseScheme = true;\n+\n+        outerloop:\n+        while (i < uri.length()) {\n+            final char c = uri.charAt(i);\n+            if (c == '/') {\n+                if (begin == i && parsedHost == null && uri.length() - 1 > i && uri.charAt(i + 1) == '/') {\n+                    // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+                    i += 2;\n+                    begin = i;\n+                    final int authorityBegin = begin;\n+                    byte parsingIPv6 = 0; // 0 = not parsed, 1 = parsing, 2 = already parsed\n+                    boolean foundColonForPort = false;\n+                    while (i < uri.length()) {\n+                        final char c2 = uri.charAt(i);\n+                        if (c2 == '@') {\n+                            if (parsedUserInfo != null) {\n+                                throw new IllegalArgumentException(\"duplicate userinfo\");\n+                            }\n+                            // Userinfo has `:` as valid. If we previously parsed the host throw it away.\n+                            parsedUserInfo = uri.substring(authorityBegin, i);\n+                            parsedHost = null;\n+                            begin = ++i;\n+                        } else if (c2 == '[') {\n+                            if (parsingIPv6 != 0 || parsedHost != null) {\n+                                throw new IllegalArgumentException(\"unexpected [\");\n+                            }\n+                            parsingIPv6 = 1;\n+                            begin = i++; // post increment, preserve the '[' for original uri for pathEndIndex.\n+                        } else if (c2 == ']') {\n+                            if (parsingIPv6 == 0) {\n+                                throw new IllegalArgumentException(\"unexpected ]\");\n+                            } else if (i - 1 <= begin) {\n+                                throw new IllegalArgumentException(\"empty ip literal\");\n+                            }\n+                            // Copy the '[' and ']' characters. pathEndIndex depends upon retaining the uri contents.\n+                            parsedHost = uri.substring(begin, i + 1);\n+                            foundColonForPort = false;\n+                            parsingIPv6 = 2;\n+                            begin = ++i;\n+                        } else if (c2 == ':') {\n+                            if (parsingIPv6 == 0) {\n+                                if (parsedHost != null) {\n+                                    throw new IllegalArgumentException(\"duplicate/invalid host\");\n+                                }\n+                                parsedHost = uri.substring(begin, i);\n+                            }\n+                            ++i;\n+                            if (parsingIPv6 != 1) {\n+                                begin = i;\n+                                foundColonForPort = true;\n+                            }\n+                        } else if (c2 == '?' || c2 == '#' || c2 == '/') {\n+                            if (parsedHost == null) {\n+                                if (parsingIPv6 == 1) {\n+                                    throw new IllegalArgumentException(\"missing closing ] for IP-literal\");\n+                                }\n+                                parsedHost = uri.substring(begin, i);\n+                            } else if (foundColonForPort) {\n+                                parsedPort = parsePort(uri, begin, i);\n+                            }\n+                            if (c2 == '/') {\n+                                begin = i++; // post increment, preserve the '/' for original uri for pathEndIndex.\n+                                continue outerloop;\n+                            } else {\n+                                parsedPath = \"\";\n+                                begin = ++i;\n+                                break outerloop;\n+                            }\n+                        } else {\n+                            ++i;\n+                        }\n+                    }\n+                    if (i == uri.length()) {\n+                        if (parsedHost == null) {\n+                            if (parsingIPv6 == 1) {\n+                                throw new IllegalArgumentException(\"missing closing ] for IP-literal\");\n+                            }\n+                            parsedHost = uri.substring(begin);\n+                        } else if (foundColonForPort) {\n+                            parsedPort = parsePort(uri, begin, i);\n+                        }\n+                        begin = i;\n+                    }\n+                } else {\n+                    eligibleToParseScheme = false;\n+                    ++i;\n+                }\n+            } else if (c == ':' && begin == 0 && parsedScheme == null && eligibleToParseScheme) {\n+                if (i == 0) {\n+                    throw new IllegalArgumentException(\"empty scheme\");\n+                }\n+                parsedScheme = uri.substring(0, i);\n+                begin = ++i;\n+                // We don't enforce the following, browsers still generate these types of requests.\n+                // https://tools.ietf.org/html/rfc3986#section-3.3\n+                // > In addition, a URI reference (Section 4.1) may be a relative-path reference,\n+                //   in which case the first path segment cannot contain a colon (\":\") character.\n+            } else if (c == '?' || c == '#') {\n+                parsedPath = uri.substring(begin, i);\n+                break;\n+            } else {\n+                ++i;\n+            }\n+        }\n+\n+        if (i == uri.length()) {\n+            parsedPath = uri.substring(begin);\n+        }\n+        assert parsedPath != null;\n+\n+        scheme = parsedScheme;\n+        userInfo = parsedUserInfo;\n+        host = parsedHost;\n+        port = parsedPort;\n+        path = parsedPath;\n+        this.uri = uri;\n+    }\n+\n+    @Override\n+    public String uri() {\n+        return uri;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String scheme() {\n+        return scheme;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String authority() {\n+        if (host == null) {\n+            return null;\n+        }\n+        final StringBuilder sb;\n+        if (userInfo == null) {\n+            sb = new StringBuilder(host.length() + 6); // 6 max port chars + `:`\n+        } else {\n+            sb = new StringBuilder(host.length() + userInfo.length() + 7); // '@' + 6 max port chars + `:`\n+            sb.append(userInfo).append('@');\n+        }\n+\n+        sb.append(host);\n+        if (port >= 0) {\n+            sb.append(':').append(port);\n+        }\n+        return sb.toString();\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String userInfo() {\n+        return userInfo;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String host() {\n+        return host;\n+    }\n+\n+    @Override\n+    public int port() {\n+        return port;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    @Override\n+    public String path(final Charset charset) {\n+        return decodeComponent(path, charset);\n+    }\n+\n+    @Override\n+    public String query() {\n+        if (query != null) {\n+            return unwrapNullableComponent(query);\n+        }\n+\n+        final int pathEndIndex = pathEndIndex();\n+        if (pathEndIndex >= uri.length() || uri.charAt(pathEndIndex) != '?') {\n+            query = NULL_COMPONENT;\n+            return null;\n+        }\n+        final int fragmentStart = uri.indexOf('#', pathEndIndex + 1);\n+        query = fragmentStart < 0 ? uri.substring(pathEndIndex + 1) :\n+                        uri.substring(pathEndIndex + 1, fragmentStart);\n+        return query;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public String query(final Charset charset) {\n+        return isNullableComponent(query) ? null : decodeComponent(query, charset);\n+    }\n+\n+    @Override\n+    public String fragment() {\n+        if (fragment != null) {\n+            return unwrapNullableComponent(fragment);\n+        }\n+\n+        final int pathEndIndex = pathEndIndex();\n+        if (pathEndIndex >= uri.length()) {\n+            fragment = NULL_COMPONENT;\n+            return null;\n+        }\n+\n+        final int fragmentStart = uri.indexOf('#', pathEndIndex);\n+        if (fragmentStart < 0) {\n+            fragment = NULL_COMPONENT;\n+            return null;\n+        }\n+        fragment = uri.substring(fragmentStart + 1);\n+        return fragment;\n+    }\n+\n+    @SuppressWarnings(\"StringEquality\")\n+    @Nullable\n+    private static String unwrapNullableComponent(String component) {\n+        return component == NULL_COMPONENT ? null : component;\n+    }\n+\n+    @SuppressWarnings(\"StringEquality\")\n+    private static boolean isNullableComponent(@Nullable String component) {\n+        return component == null || component == NULL_COMPONENT;\n+    }\n+\n+    private int pathEndIndex() {\n+        int i = 0;\n+        if (scheme != null) {\n+            i = scheme.length() + 1; // ':'\n+        }\n+        if (host != null) {\n+            // The authority component is preceded by a double slash (\"//\")\n+            // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+            i += host.length() + 2; // '/' '/'\n+            if (userInfo != null) {\n+                i += userInfo.length() + 1; // '@'\n+            }\n+            if (port >= 0) {\n+                i += numberOfDigits(port) + 1; // ':'\n+            }\n+        }\n+        i += path.length();\n+        return i;\n+    }\n+\n+    private boolean hostAndPortEqual(final Uri3986 rhs) {\n+        return port == rhs.port && Objects.equals(host, rhs.host);\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+        return o instanceof Uri3986 && hostAndPortEqual((Uri3986) o);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return 31 * (31 + port + Objects.hashCode(host));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return uri;\n+    }\n+\n+    static String encode(String requestTarget, Charset charset, boolean preservePctEncoding) {\n+        Uri3986 uri = new Uri3986(requestTarget);\n+        StringBuilder sb = new StringBuilder(uri.uri.length() + 16);\n+        if (uri.scheme != null) {\n+            sb.append(uri.scheme).append(':');\n+        }\n+        if (uri.host != null) {\n+            // The authority component is preceded by a double slash (\"//\")\n+            // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+            sb.append(\"//\");\n+            if (uri.userInfo != null) {\n+                sb.append(encodeComponent(USER_INFO, uri.userInfo, charset, preservePctEncoding)).append('@');\n+            }\n+\n+            if (!uri.host.isEmpty()) {\n+                sb.append(uri.host.charAt(0) != '[' ?\n+                        encodeComponent(HOST_NON_IP, uri.host, charset, preservePctEncoding) : uri.host);\n+            }\n+            if (uri.port >= 0) {\n+                sb.append(':').append(uri.port);\n+            }\n+        }\n+\n+        String path = uri.path();\n+        if (!path.isEmpty() && path.charAt(0) != '/') {\n+            sb.append('/');\n+        }\n+        sb.append(encodeComponent(PATH, path, charset, preservePctEncoding));\n+\n+        String query = uri.query();\n+        if (query != null) {\n+            sb.append('?').append(encodeComponent(QUERY, query, charset, preservePctEncoding));\n+        }\n+\n+        String fragment = uri.fragment();\n+        if (fragment != null) {\n+            sb.append('#').append(encodeComponent(FRAGMENT, fragment, charset, preservePctEncoding));\n+        }\n+        return sb.toString();\n+    }\n+\n+    static String decode(String requestTarget, Charset charset) {\n+        Uri3986 uri = new Uri3986(requestTarget);\n+        StringBuilder sb = new StringBuilder(uri.uri.length());\n+        if (uri.scheme != null) {\n+            sb.append(uri.scheme).append(':');\n+        }\n+        if (uri.host != null) {\n+            // The authority component is preceded by a double slash (\"//\")\n+            // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+            sb.append(\"//\");\n+            if (uri.userInfo != null) {\n+                sb.append(decodeComponent(uri.userInfo, charset)).append('@');\n+            }\n+            if (!uri.host.isEmpty()) {\n+                sb.append(uri.host.charAt(0) != '[' ? decodeComponent(uri.host, charset) : uri.host);\n+            }\n+            if (uri.port >= 0) {\n+                sb.append(':').append(uri.port);\n+            }\n+        }\n+\n+        String path = uri.path();\n+        if (!path.isEmpty() && path.charAt(0) != '/') {\n+            sb.append('/');\n+        }\n+        sb.append(decodeComponent(path, charset));\n+\n+        String query = uri.query();\n+        if (query != null) {\n+            sb.append('?').append(decodeComponent(query, charset));\n+        }\n+\n+        String fragment = uri.fragment();\n+        if (fragment != null) {\n+            sb.append('#').append(decodeComponent(fragment, charset));\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static int numberOfDigits(int port) {\n+        if (port < 10000) {\n+            if (port < 1000) {\n+                if (port < 100) {\n+                    return port < 10 ? 1 : 2;\n+                }\n+                return 3;\n+            }\n+            return 4;\n+        } else if (port <= 65535) {\n+            return 5;\n+        }\n+        throw new IllegalArgumentException(\"port out of bounds\");", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MDI0MQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514640241", "bodyText": "10 -> 0xA for consistency?", "author": "idelpivnitskiy", "createdAt": "2020-10-30T00:23:39Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/UriUtils.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import javax.annotation.Nullable;\n+\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+\n+final class UriUtils {\n+    // https://tools.ietf.org/html/rfc3986 declares that all delimiter/terminal values are US-ASCII\n+    // https://tools.ietf.org/html/rfc3986#section-2. This means values fall within the [0, 127] range. This range\n+    // can be represented as a bitset/bitmask with two longs (high, low), which reduces the amount of conditional\n+    // statements required to validate characters belonging to each character class. The following final variables\n+    // provide the bitmask for the different character classes defined in rfc3986, and isBitSet can be used to verify if\n+    // a bit is set for a particular (high, low) mask pair.\n+    //\n+    // pct-encoded is omitted below. This criteria is asserted outside this scope because it requires checking multiple\n+    // bytes and advancing the loop index accordingly.\n+\n+    private static final long DIGIT_LMASK = lowMask('0', '9');\n+    private static final long DIGIT_HMASK = highMask('0', '9');\n+\n+    private static final long ALPHA_LMASK = lowMask('a', 'z') | lowMask('A', 'Z');\n+    private static final long ALPHA_HMASK = highMask('a', 'z') | highMask('A', 'Z');\n+\n+    private static final long HEXDIG_LMASK = DIGIT_LMASK | lowMask('a', 'f') | lowMask('A', 'F');\n+    private static final long HEXDIG_HMASK = DIGIT_HMASK | highMask('a', 'f') | highMask('A', 'F');\n+\n+    // unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n+    private static final long UNRESERVED_LMASK = ALPHA_LMASK | DIGIT_LMASK | lowMask(\"-._~\");\n+    private static final long UNRESERVED_HMASK = ALPHA_HMASK | DIGIT_HMASK | highMask(\"-._~\");\n+\n+    // sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n+    //                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n+    private static final long SUBDELIM_LMASK = lowMask(\"!$&'()*+,;=\");\n+    private static final long SUBDELIM_HMASK = highMask(\"!$&'()*+,;=\");\n+\n+    // pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n+    private static final long PCHAR_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\";@\");\n+\n+    private static final long PCHAR_NOSUBDELIM_LMASK = UNRESERVED_LMASK | lowMask(\";@\");\n+    private static final long PCHAR_NOSUBDELIM_HMASK = UNRESERVED_HMASK | highMask(\";@\");\n+\n+    // userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n+    static final long USERINFO_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK | lowMask(\":\");\n+    static final long USERINFO_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK | highMask(\":\");\n+\n+    // path        = *(pchar / \"/\")\n+    static final long PATH_LMASK = PCHAR_LMASK | lowMask(\"/\");\n+    static final long PATH_HMASK = PCHAR_HMASK | highMask(\"/\");\n+\n+    static final long PATH_SEGMENT_LMASK = PCHAR_LMASK;\n+    static final long PATH_SEGMENT_HMASK = PCHAR_HMASK;\n+\n+    // query       = *( pchar / \"/\" / \"?\" )\n+    static final long QUERY_LMASK = PCHAR_LMASK | lowMask(\"/?\");\n+    static final long QUERY_HMASK = PCHAR_HMASK | highMask(\"/?\");\n+\n+    static final long QUERY_VALUE_LMASK = PCHAR_NOSUBDELIM_LMASK | lowMask(\"/?\");\n+    static final long QUERY_VALUE_HMASK = PCHAR_NOSUBDELIM_HMASK | highMask(\"/?\");\n+\n+    // fragment    = *( pchar / \"/\" / \"?\" )\n+    static final long FRAGMENT_LMASK = QUERY_LMASK;\n+    static final long FRAGMENT_HMASK = QUERY_HMASK;\n+\n+    // host        = IP-literal / IPv4address / reg-name\n+    // reg-name    = *( unreserved / pct-encoded / sub-delims )\n+    static final long HOST_NON_IP_LMASK = UNRESERVED_LMASK | SUBDELIM_LMASK;\n+    static final long HOST_NON_IP_HMASK = UNRESERVED_HMASK | SUBDELIM_HMASK;\n+\n+    private UriUtils() {\n+    }\n+\n+    /**\n+     * Decode the specified raw query with the specified {@code charset} for the specified maximum number of parameters.\n+     */\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams) {\n+        return decodeQueryParams(rawQuery, charset, maxParams, UriUtils::decodeComponent);\n+    }\n+\n+    static Map<String, List<String>> decodeQueryParams(@Nullable final String rawQuery, final Charset charset,\n+                                                       final int maxParams,\n+                                                       BiFunction<String, Charset, String> decoder) {\n+        if (maxParams <= 0) {\n+            throw new IllegalArgumentException(\"maxParams: \" + maxParams + \" (expected: > 0)\");\n+        }\n+\n+        if (rawQuery == null || rawQuery.isEmpty()) {\n+            return new LinkedHashMap<>(2);\n+        }\n+\n+        final Map<String, List<String>> params = new LinkedHashMap<>();\n+        int paramCountDown = maxParams;\n+        final int from = rawQuery.charAt(0) == '?' ? 1 : 0;\n+        final int len = rawQuery.length();\n+        int nameStart = from;\n+        int valueStart = -1;\n+        int i;\n+        loop:\n+        for (i = from; i < len; i++) {\n+            switch (rawQuery.charAt(i)) {\n+                case '=':\n+                    if (nameStart == i) {\n+                        nameStart = i + 1;\n+                    } else if (valueStart < nameStart) {\n+                        valueStart = i + 1;\n+                    }\n+                    break;\n+                case '&':\n+                case ';':\n+                    if (addQueryParam(rawQuery, nameStart, valueStart, i, charset, params, decoder)) {\n+                        paramCountDown--;\n+                        if (paramCountDown == 0) {\n+                            return params;\n+                        }\n+                    }\n+                    nameStart = i + 1;\n+                    break;\n+                case '#':\n+                    break loop;\n+                default:\n+                    // continue\n+            }\n+        }\n+        addQueryParam(rawQuery, nameStart, valueStart, i, charset, params, decoder);\n+        return params;\n+    }\n+\n+    static String encodeComponent(UriComponentType type, String component, Charset charset,\n+                                  boolean preservePctEncoded) {\n+        byte[] bytes = component.getBytes(charset);\n+        for (int i = 0; i < bytes.length; ++i) {\n+            byte b = bytes[i];\n+            if (type.isValid(b)) {\n+                // noop\n+            } else if (preservePctEncoded && bytes.length - 3 >= i && isPctEncoded(bytes, b, i)) {\n+                i += 2; // only increment by 2 here, the for loop will increment 1 more\n+            } else {\n+                ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length + 16);\n+                baos.write(bytes, 0, i);\n+                encodeHexDigits(baos, b);\n+                for (int j = i + 1; j < bytes.length; ++j) {\n+                    b = bytes[j];\n+                    if (type.isValid(b)) {\n+                        baos.write(b);\n+                    } else if (preservePctEncoded && bytes.length - 3 >= j && isPctEncoded(bytes, b, j)) {\n+                        baos.write(bytes, j, 3);\n+                        j += 2; // only increment by 2 here, the for loop will increment 1 more\n+                    } else {\n+                        encodeHexDigits(baos, b);\n+                    }\n+                }\n+                return new String(baos.toByteArray(), charset);\n+            }\n+        }\n+        return component;\n+    }\n+\n+    static String decodeComponent(final String s, final Charset charset) {\n+        if (s.indexOf('%') < 0) {\n+            return s;\n+        }\n+        byte[] bytes = s.getBytes(charset);\n+        for (int i = 0; i < bytes.length; ++i) {\n+            byte b = bytes[i];\n+            if (b == '%') {\n+                ByteArrayOutputStream baos = new ByteArrayOutputStream(bytes.length);\n+                baos.write(bytes, 0, i);\n+                baos.write(decodeHexDigits(bytes, i));\n+                for (int j = i + 3; j < bytes.length; ++j) {\n+                    b = bytes[j];\n+                    if (b == '%') {\n+                        baos.write(decodeHexDigits(bytes, j));\n+                        j += 2;\n+                    } else {\n+                        baos.write(b);\n+                    }\n+                }\n+                return new String(baos.toByteArray(), charset);\n+            }\n+        }\n+\n+        return s;\n+    }\n+\n+    static int parsePort(final String uri, final int begin, final int end) {\n+        final int len = end - begin;\n+        if (len == 4) {\n+            return (1000 * toDecimal(uri.charAt(begin))) +\n+                    (100 * toDecimal(uri.charAt(begin + 1))) +\n+                    (10 * toDecimal(uri.charAt(begin + 2))) +\n+                    toDecimal(uri.charAt(begin + 3));\n+        } else if (len == 3) {\n+            return (100 * toDecimal(uri.charAt(begin))) +\n+                    (10 * toDecimal(uri.charAt(begin + 1))) +\n+                    toDecimal(uri.charAt(begin + 2));\n+        } else if (len == 2) {\n+            return (10 * toDecimal(uri.charAt(begin))) +\n+                    toDecimal(uri.charAt(begin + 1));\n+        } else if (len == 5) {\n+            final int port = (10000 * toDecimal(uri.charAt(begin))) +\n+                    (1000 * toDecimal(uri.charAt(begin + 1))) +\n+                    (100 * toDecimal(uri.charAt(begin + 2))) +\n+                    (10 * toDecimal(uri.charAt(begin + 3))) +\n+                    toDecimal(uri.charAt(begin + 4));\n+            if (port > 65535) {\n+                throw new IllegalArgumentException(\"port out of bounds\");\n+            }\n+            return port;\n+        } else if (len == 1) {\n+            return toDecimal(uri.charAt(begin));\n+        } else {\n+            throw new IllegalArgumentException(\"invalid port\");\n+        }\n+    }\n+\n+    private static boolean addQueryParam(final String s, final int nameStart, int valueStart, final int valueEnd,\n+                                         final Charset charset, final Map<String, List<String>> params,\n+                                         final BiFunction<String, Charset, String> decoder) {\n+        if (nameStart >= valueEnd) {\n+            return false;\n+        }\n+        if (valueStart <= nameStart) {\n+            valueStart = valueEnd + 1;\n+        }\n+        final String name = decoder.apply(s.substring(nameStart, valueStart - 1), charset);\n+        final String value = decoder.apply(s.substring(valueStart, valueEnd), charset);\n+        final List<String> values = params.computeIfAbsent(name, k -> new ArrayList<>(1)); // Often there's only 1 value\n+        values.add(value);\n+        return true;\n+    }\n+\n+    private static void encodeHexDigits(ByteArrayOutputStream baos, byte b) {\n+        baos.write('%');\n+        baos.write(encodeHexNibble((b >>> 4) & 0xF));\n+        baos.write(encodeHexNibble(b & 0xF));\n+    }\n+\n+    private static byte decodeHexDigits(byte[] bytes, int i) {\n+        if (bytes.length - 2 <= i) {\n+            throw new IllegalArgumentException(\"Invalid pct-encoded at index \" + i);\n+        }\n+        final int hi = decodeHexNibble(bytes[i + 1]);\n+        final int lo = decodeHexNibble(bytes[i + 2]);\n+        if (hi == -1 || lo == -1) {\n+            throw new IllegalArgumentException(\"Invalid HEXDIG at index \" + i);\n+        }\n+        return (byte) ((hi << 4) + lo);\n+    }\n+\n+    private static byte encodeHexNibble(final int b) {\n+        // Character.forDigit() is not used here, as it addresses a larger\n+        // set of characters (both ASCII and full-width latin letters).\n+        if (b < 0 || b >= 16) {\n+            return 0;\n+        }\n+        if (b < 10) {\n+            return (byte) ('0' + b);\n+        }\n+        return (byte) ('A' - 10 + b); // uppercase", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MTEwOA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514641108", "bodyText": "Test cases when there is something else between ] and : (or end of string)", "author": "idelpivnitskiy", "createdAt": "2020-10-30T00:27:05Z", "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/HttpAuthorityFormUriTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import org.junit.Test;\n+\n+import static io.servicetalk.http.api.Uri3986Test.verifyUri;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.Assert.assertEquals;\n+\n+@SuppressWarnings(\"PMD.AvoidUsingHardCodedIP\")\n+public class HttpAuthorityFormUriTest {\n+    @Test\n+    public void regNameAndPort() {\n+        verifyAuthForm(\"www.example.com:80\", \"www.example.com\", 80);\n+    }\n+\n+    @Test\n+    public void regName() {\n+        verifyAuthForm(\"www.example.com\", \"www.example.com\", -1);\n+    }\n+\n+    @Test\n+    public void ipv6AndPort() {\n+        verifyAuthForm(\"[::1]:8080\", \"[::1]\", 8080);\n+    }\n+\n+    @Test\n+    public void ipv6() {\n+        verifyAuthForm(\"[af::98]\", \"[af::98]\", -1);\n+    }\n+\n+    @Test\n+    public void ipv4AndPort() {\n+        verifyAuthForm(\"1.2.3.4:8080\", \"1.2.3.4\", 8080);\n+    }\n+\n+    @Test\n+    public void ipv4() {\n+        verifyAuthForm(\"244.244.244.244\", \"244.244.244.244\", -1);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void ipv6InvalidNegativePort() {\n+        new HttpAuthorityFormUri(\"[::1]:-1\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void ipv6InvalidLargePort() {\n+        new HttpAuthorityFormUri(\"[::1]:65536\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void ipv6InvalidNoCloseBracketNoPort() {\n+        new HttpAuthorityFormUri(\"[::1\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void ipv6NonBracketWithScope() {\n+        // https://tools.ietf.org/html/rfc3986#section-3.2.2\n+        // IPv6 + future must be enclosed in []\n+        new HttpAuthorityFormUri(\"0:0:0:0:0:0:0:0%0:49178\");\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void ipv6InvalidNoCloseBracketWithPort() {\n+        new HttpAuthorityFormUri(\"[::1:65536\");\n+    }\n+\n+    @Test\n+    public void encodeTouchesAllComponents() {\n+        verifyEncodeDecode(\"www.foo bar.com:8080\", \"www.foo%20bar.com:8080\");\n+    }\n+\n+    @Test\n+    public void encodeIPv6() {\n+        verifyEncodeDecode(\"[::1]:8080\");", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MTU1MQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514641551", "bodyText": "This method is used in a single place, can you please move it there and kill this class?", "author": "idelpivnitskiy", "createdAt": "2020-10-30T00:28:59Z", "path": "servicetalk-http-router-jersey/src/main/java/io/servicetalk/http/router/jersey/CharSequenceUtils.java", "diffHunk": "@@ -26,23 +26,4 @@ private CharSequenceUtils() {\n     static CharSequence asCharSequence(final Object o) {", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzgwNQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514643805", "bodyText": "Do we need defer here? The handle method is expected to execute only once.", "author": "idelpivnitskiy", "createdAt": "2020-10-30T00:37:44Z", "path": "servicetalk-http-utils/src/main/java/io/servicetalk/http/utils/RequestTargetDecoderHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.utils;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpServiceContext;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+import io.servicetalk.http.api.StreamingHttpService;\n+import io.servicetalk.http.api.StreamingHttpServiceFilter;\n+import io.servicetalk.http.api.StreamingHttpServiceFilterFactory;\n+\n+import java.nio.charset.Charset;\n+\n+import static io.servicetalk.concurrent.api.Single.defer;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static java.util.Objects.requireNonNull;\n+/**\n+ * <a href=\"https://tools.ietf.org/html/rfc3986#section-2.1\">Decodes</a> the\n+ * {@link StreamingHttpRequest#requestTarget()} for each incoming request.\n+ */\n+public final class RequestTargetDecoderHttpServiceFilter implements StreamingHttpServiceFilterFactory,\n+                                                              HttpExecutionStrategyInfluencer {\n+    private final Charset charset;\n+\n+    /**\n+     * Create a new instance.\n+     */\n+    public RequestTargetDecoderHttpServiceFilter() {\n+        this(US_ASCII);\n+    }\n+\n+    /**\n+     * Create a new instance.\n+     * @param charset The charset to use for the decoding.\n+     */\n+    public RequestTargetDecoderHttpServiceFilter(Charset charset) {\n+        this.charset = requireNonNull(charset);\n+    }\n+\n+    @Override\n+    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+        return new StreamingHttpServiceFilter(service) {\n+            @Override\n+            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                        final StreamingHttpRequest request,\n+                                                        final StreamingHttpResponseFactory responseFactory) {\n+                return defer(() -> {\n+                    request.requestTarget(request.requestTarget(charset));\n+                    return delegate().handle(ctx, request, responseFactory);\n+                });", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ0MTg2OA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r515441868", "bodyText": "we are modifying state inside a method that returns a Single. In general we should do this in a lazy fashion and on subscribe.", "author": "Scottmitch", "createdAt": "2020-10-31T01:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mzg0Ng==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514643846", "bodyText": "Do we need defer here? The handle method is expected to execute only once.", "author": "idelpivnitskiy", "createdAt": "2020-10-30T00:37:54Z", "path": "servicetalk-http-utils/src/main/java/io/servicetalk/http/utils/RequestTargetEncoderHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.utils;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpServiceContext;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+import io.servicetalk.http.api.StreamingHttpService;\n+import io.servicetalk.http.api.StreamingHttpServiceFilter;\n+import io.servicetalk.http.api.StreamingHttpServiceFilterFactory;\n+\n+import java.nio.charset.Charset;\n+\n+import static io.servicetalk.concurrent.api.Single.defer;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * <a href=\"https://tools.ietf.org/html/rfc3986#section-2.1\">Encodes</a> the\n+ * {@link StreamingHttpRequest#requestTarget()} for each incoming request.\n+ * <p>\n+ * URI producers <a href=\"https://tools.ietf.org/html/rfc3986\">should encode query strings</a>, but\n+ * just in case they don't this filter will do the encoding.\n+ */\n+public final class RequestTargetEncoderHttpServiceFilter implements StreamingHttpServiceFilterFactory,\n+                                                                    HttpExecutionStrategyInfluencer {\n+    private final Charset charset;\n+\n+    /**\n+     * Create a new instance.\n+     */\n+    public RequestTargetEncoderHttpServiceFilter() {\n+        this(US_ASCII);\n+    }\n+\n+    /**\n+     * Create a new instance.\n+     * @param charset The charset to use for the encoding.\n+     */\n+    public RequestTargetEncoderHttpServiceFilter(Charset charset) {\n+        this.charset = requireNonNull(charset);\n+    }\n+\n+    @Override\n+    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+        return new StreamingHttpServiceFilter(service) {\n+            @Override\n+            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                        final StreamingHttpRequest request,\n+                                                        final StreamingHttpResponseFactory responseFactory) {\n+                return defer(() -> {\n+                    request.requestTarget(request.requestTarget(), charset);\n+                    return delegate().handle(ctx, request, responseFactory);\n+                });", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0NDIxMQ==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r514644211", "bodyText": "nit: shifter indentation", "author": "idelpivnitskiy", "createdAt": "2020-10-30T00:39:16Z", "path": "servicetalk-http-utils/src/main/java/io/servicetalk/http/utils/RequestTargetDecoderHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.utils;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpServiceContext;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+import io.servicetalk.http.api.StreamingHttpService;\n+import io.servicetalk.http.api.StreamingHttpServiceFilter;\n+import io.servicetalk.http.api.StreamingHttpServiceFilterFactory;\n+\n+import java.nio.charset.Charset;\n+\n+import static io.servicetalk.concurrent.api.Single.defer;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static java.util.Objects.requireNonNull;\n+/**\n+ * <a href=\"https://tools.ietf.org/html/rfc3986#section-2.1\">Decodes</a> the\n+ * {@link StreamingHttpRequest#requestTarget()} for each incoming request.\n+ */\n+public final class RequestTargetDecoderHttpServiceFilter implements StreamingHttpServiceFilterFactory,\n+                                                              HttpExecutionStrategyInfluencer {", "originalCommit": "c131b9cdb04caaed361fe6ba9d83bb174a2d76fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a72d706c0226ffa4be30bdfba46df6e45fc3a4a", "url": "https://github.com/apple/servicetalk/commit/1a72d706c0226ffa4be30bdfba46df6e45fc3a4a", "message": "review comments", "committedDate": "2020-10-31T01:57:36Z", "type": "commit"}, {"oid": "cc0aeb6520f93c067b50d945629c22125e4ad607", "url": "https://github.com/apple/servicetalk/commit/cc0aeb6520f93c067b50d945629c22125e4ad607", "message": "add more verification for path", "committedDate": "2020-11-02T16:34:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MTk2Nw==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r516271967", "bodyText": "It should be x + 2 now. Please, add more test to verify scenarios with IPv6. The whole parsedHostHeader.charAt(0) == '[' branch is not tested.", "author": "idelpivnitskiy", "createdAt": "2020-11-02T21:44:15Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -412,41 +356,68 @@ private Uri lazyParseRequestTarget() {\n         return requestTargetUri;\n     }\n \n+    private static void validateFirstPathSegment(final Uri httpUri, final String path) {\n+        int i = 0;\n+        final String scheme = httpUri.scheme();\n+        if (scheme == null || scheme.isEmpty()) {\n+            // https://tools.ietf.org/html/rfc3986#section-3.3\n+            // In addition, a URI reference (Section 4.1) may be a relative-path reference, in which case the first path\n+            // segment cannot contain a colon (\":\") character.\n+            for (; i < path.length(); ++i) {\n+                final char c = path.charAt(i);\n+                if (c == '/') {\n+                    break;\n+                } else if (c == ':') {\n+                    throw new IllegalArgumentException(\"relative-path cannot contain `:` in first segment\");\n+                }\n+            }\n+        }\n+        // https://tools.ietf.org/html/rfc3986#section-3.3\n+        // If a URI does not contain an authority component, then the path cannot begin with two slash characters\n+        // (\"//\").\n+        if (httpUri.host() == null && path.length() >= 2 && path.charAt(0) == '/' && path.charAt(1) == '/') {\n+            throw new IllegalArgumentException(\"No authority component, path cannot start with '//'\");\n+        }\n+        // It is assumed '?'/'#' characters that delimit query/fragment components have been escaped and are therefore\n+        // not validated.\n+    }\n+\n+    @Nullable\n     private static HostAndPort parseHostHeader(String parsedHostHeader) {\n+        if (parsedHostHeader.isEmpty()) {\n+            return null;\n+        }\n+\n         String parsedHost;\n         int parsedPort = -1;\n-        final int x = parsedHostHeader.lastIndexOf(':');\n-        if (x > 0) {\n-            final int y = parsedHostHeader.lastIndexOf(':', x - 1);\n-            if (y >= 0) {\n-                // IPv6 address is present in the header\n-                // https://tools.ietf.org/html/rfc3986#section-3.2.2\n-                // A host identified by an Internet Protocol literal address, version 6\n-                // [RFC3513] or later, is distinguished by enclosing the IP literal\n-                // within square brackets (\"[\" and \"]\").  This is the only place where\n-                // square bracket characters are allowed in the URI syntax.\n-                final int cb;\n-                if (parsedHostHeader.charAt(0) != '[' || (cb = parsedHostHeader.lastIndexOf(']')) < 0) {\n-                    throw new IllegalArgumentException(\"IPv6 address should be in square brackets\");\n-                }\n-                if (cb < x) {\n-                    parsedHost = parsedHostHeader.substring(0, x);\n+        if (parsedHostHeader.charAt(0) == '[') {\n+            // IPv6 address is present in the header\n+            // https://tools.ietf.org/html/rfc3986#section-3.2.2\n+            // A host identified by an Internet Protocol literal address, version 6\n+            // [RFC3513] or later, is distinguished by enclosing the IP literal\n+            // within square brackets (\"[\" and \"]\").  This is the only place where\n+            // square bracket characters are allowed in the URI syntax.\n+            final int x = parsedHostHeader.lastIndexOf(']');\n+            if (x <= 0) {\n+                throw new IllegalArgumentException(\"IPv6 address should be in square brackets, and not empty\");\n+            }\n+            parsedHost = parsedHostHeader.substring(0, x);\n+            if (parsedHostHeader.length() - 1 > x) {\n+                if (parsedHostHeader.charAt(x + 1) == ':') {\n                     parsedPort = parsePort(parsedHostHeader, x + 1, parsedHostHeader.length());", "originalCommit": "cc0aeb6520f93c067b50d945629c22125e4ad607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMzMTQ2Nw==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r516331467", "bodyText": "+1 for tests", "author": "Scottmitch", "createdAt": "2020-11-02T23:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MTk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzU5NA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r516273594", "bodyText": "I feel like it's a frequent mistake to forget enclosing IPv6 within square brackets. Worth keeping a check for the second occurrence of a colon.", "author": "idelpivnitskiy", "createdAt": "2020-11-02T21:47:32Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -412,41 +356,68 @@ private Uri lazyParseRequestTarget() {\n         return requestTargetUri;\n     }\n \n+    private static void validateFirstPathSegment(final Uri httpUri, final String path) {\n+        int i = 0;\n+        final String scheme = httpUri.scheme();\n+        if (scheme == null || scheme.isEmpty()) {\n+            // https://tools.ietf.org/html/rfc3986#section-3.3\n+            // In addition, a URI reference (Section 4.1) may be a relative-path reference, in which case the first path\n+            // segment cannot contain a colon (\":\") character.\n+            for (; i < path.length(); ++i) {\n+                final char c = path.charAt(i);\n+                if (c == '/') {\n+                    break;\n+                } else if (c == ':') {\n+                    throw new IllegalArgumentException(\"relative-path cannot contain `:` in first segment\");\n+                }\n+            }\n+        }\n+        // https://tools.ietf.org/html/rfc3986#section-3.3\n+        // If a URI does not contain an authority component, then the path cannot begin with two slash characters\n+        // (\"//\").\n+        if (httpUri.host() == null && path.length() >= 2 && path.charAt(0) == '/' && path.charAt(1) == '/') {\n+            throw new IllegalArgumentException(\"No authority component, path cannot start with '//'\");\n+        }\n+        // It is assumed '?'/'#' characters that delimit query/fragment components have been escaped and are therefore\n+        // not validated.\n+    }\n+\n+    @Nullable\n     private static HostAndPort parseHostHeader(String parsedHostHeader) {\n+        if (parsedHostHeader.isEmpty()) {\n+            return null;\n+        }\n+\n         String parsedHost;\n         int parsedPort = -1;\n-        final int x = parsedHostHeader.lastIndexOf(':');\n-        if (x > 0) {\n-            final int y = parsedHostHeader.lastIndexOf(':', x - 1);\n-            if (y >= 0) {\n-                // IPv6 address is present in the header\n-                // https://tools.ietf.org/html/rfc3986#section-3.2.2\n-                // A host identified by an Internet Protocol literal address, version 6\n-                // [RFC3513] or later, is distinguished by enclosing the IP literal\n-                // within square brackets (\"[\" and \"]\").  This is the only place where\n-                // square bracket characters are allowed in the URI syntax.\n-                final int cb;\n-                if (parsedHostHeader.charAt(0) != '[' || (cb = parsedHostHeader.lastIndexOf(']')) < 0) {\n-                    throw new IllegalArgumentException(\"IPv6 address should be in square brackets\");\n-                }\n-                if (cb < x) {\n-                    parsedHost = parsedHostHeader.substring(0, x);\n+        if (parsedHostHeader.charAt(0) == '[') {\n+            // IPv6 address is present in the header\n+            // https://tools.ietf.org/html/rfc3986#section-3.2.2\n+            // A host identified by an Internet Protocol literal address, version 6\n+            // [RFC3513] or later, is distinguished by enclosing the IP literal\n+            // within square brackets (\"[\" and \"]\").  This is the only place where\n+            // square bracket characters are allowed in the URI syntax.\n+            final int x = parsedHostHeader.lastIndexOf(']');\n+            if (x <= 0) {\n+                throw new IllegalArgumentException(\"IPv6 address should be in square brackets, and not empty\");\n+            }\n+            parsedHost = parsedHostHeader.substring(0, x);\n+            if (parsedHostHeader.length() - 1 > x) {\n+                if (parsedHostHeader.charAt(x + 1) == ':') {\n                     parsedPort = parsePort(parsedHostHeader, x + 1, parsedHostHeader.length());\n-                } else if (cb != parsedHostHeader.length() - 1) {\n-                    throw new IllegalArgumentException(\n-                            \"']' should be at the end of IPv6 address or before port number\");\n                 } else {\n-                    parsedHost = parsedHostHeader;\n+                    throw new IllegalArgumentException(\"Unexpected content after IPv6 address\");\n                 }\n+            }\n+        } else {\n+            // IPv4 or literal host with port number\n+            final int x = parsedHostHeader.lastIndexOf(':');", "originalCommit": "cc0aeb6520f93c067b50d945629c22125e4ad607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDQyMw==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r516394423", "bodyText": "I don't think it is necessary to validate to this level. we don't strictly validate contents of ipv4 and ipv6 and rely upon downstream code (e.g. connection logic) to catch if the address isn't legit.", "author": "Scottmitch", "createdAt": "2020-11-03T02:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3ODM3OA==", "url": "https://github.com/apple/servicetalk/pull/1194#discussion_r516278378", "bodyText": "Please, add a test with userInfo != null and port >= 0, these code paths are not tested.", "author": "idelpivnitskiy", "createdAt": "2020-11-02T21:57:33Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpRequestMetaData.java", "diffHunk": "@@ -539,4 +496,40 @@ public int hashCode() {\n         result = 31 * result + requestTarget.hashCode();\n         return result;\n     }\n+\n+    private static void appendScheme(StringBuilder sb, Uri httpUri) {\n+        if (httpUri.scheme() != null) {\n+            sb.append(httpUri.scheme()).append(':');\n+        }\n+    }\n+\n+    private static void appendAuthority(StringBuilder sb, Uri httpUri) {\n+        if (httpUri.host() != null) {\n+            // The authority component is preceded by a double slash (\"//\")\n+            // authority   = [ userinfo \"@\" ] host [ \":\" port ]\n+            sb.append(\"//\");\n+            if (httpUri.userInfo() != null) {\n+                sb.append(httpUri.userInfo()).append('@');\n+            }\n+\n+            sb.append(httpUri.host());\n+            if (httpUri.port() >= 0) {\n+                sb.append(':').append(httpUri.port());", "originalCommit": "cc0aeb6520f93c067b50d945629c22125e4ad607", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "972861a2147eb57d21fe8e444825bf6b04c14cff", "url": "https://github.com/apple/servicetalk/commit/972861a2147eb57d21fe8e444825bf6b04c14cff", "message": "review comments", "committedDate": "2020-11-03T02:28:22Z", "type": "commit"}]}