{"pr_number": 1174, "pr_title": "Introduce HTTP content encoding H1 & H2", "pr_createdAt": "2020-10-12T17:33:26Z", "pr_url": "https://github.com/apple/servicetalk/pull/1174", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkxNDE0OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r504914148", "bodyText": "Hold on reviewing this part, after some discussions, I need to consider controlling demand from within. I am looking at the Processor API to see how this can be hooked.", "author": "tkountis", "createdAt": "2020-10-14T19:17:36Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,540 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements ContentCodec {\n+\n+    protected static final int ONE_KB = 1 << 10;\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();\n+\n+    private final CharSequence encoding;\n+\n+    AbstractZipContentCodec(final CharSequence encoding) {\n+        this.encoding = encoding;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final HttpHeaders headers, final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        addContentEncoding(headers, encoding);\n+\n+        final Buffer dst = allocator.newBuffer(ONE_KB);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[min(src.readableBytes(), ONE_KB)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final HttpHeaders headers, final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        addContentEncoding(headers, encoding);\n+        return from", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE4NjA0Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508186046", "bodyText": "What is the motivation for having 2 different interfaces: ContentCoding and ContentCodec? Do we expect any other methods on ContentCoding interface in future?\nDid you consider merging these two together? Looks like the name is a required characteristic of a ContentCodec. Can not imagine a case of having ContentCoding that returns GzipContentCodec with a different name.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T03:23:31Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCoding.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+/**\n+ * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n+ */\n+public interface ContentCoding {\n+\n+    /**\n+     * A string representation for the content coding.\n+     *\n+     * @return a string representation for the content coding.\n+     */\n+    String name();\n+\n+    /**\n+     * The codec that supports encoding/decoding for this type of content coding.\n+     *\n+     * @return a shared instance of the codec for that content coding\n+     */\n+    ContentCodec codec();", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0MDU1OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508340558", "bodyText": "Agree, I believe its a leftover from my conversion between enum & interface for the coding, but there is no benefit from keeping them separate.", "author": "tkountis", "createdAt": "2020-10-20T09:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE4NjA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE4NzUxOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508187518", "bodyText": "When users may need non-streaming variants in a context of HTTP?", "author": "idelpivnitskiy", "createdAt": "2020-10-20T03:29:01Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * Codec used to encode and decode {@link Publisher} of {@link Buffer} parts.\n+ * This instance is shared therefore it must provide thread safety semantics.\n+ */\n+public interface ContentCodec {\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n+     * @param src the {@link Buffer} to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    default Buffer encode(HttpHeaders headers, Buffer src, BufferAllocator allocator) {\n+        return encode(headers, src, src.readerIndex(), src.readableBytes(), allocator);\n+    }\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param headers the {@link HttpHeaders} to update content-encoding if needed\n+     * @param src the {@link Buffer} to encode\n+     * @param offset the offset of the source to start reading from\n+     * @param length the total length available for reading\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    Buffer encode(HttpHeaders headers, Buffer src, int offset, int length, BufferAllocator allocator);", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0MTMwNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508341304", "bodyText": "This is not an exposed API to the user.\nThe service will use internally to do the work, in which case it only works with plain blocking and the streaming versions.", "author": "tkountis", "createdAt": "2020-10-20T09:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE4NzUxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyMzY2NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508723664", "bodyText": "Discussed offline, this looks like a leftover from intermediate work, we need only streaming API for HTTP.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T17:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE4NzUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTU4MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508195581", "bodyText": "Did you explore an oportunity to merge ContentCodec and MessageCodec from gRPC into one interface?\nThe main idea that components should be reused between different protocols. Serializer API is a good example. We have HttpSerializer that manages headers, but the implementation of Serializer interface is protocol-agnostic.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:01:34Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodec.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * Codec used to encode and decode {@link Publisher} of {@link Buffer} parts.\n+ * This instance is shared therefore it must provide thread safety semantics.\n+ */\n+public interface ContentCodec {", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0MzI4MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508343281", "bodyText": "A few times yes, I played with having the two together. However, at the end I chose to keep them separate. There is one fundamental difference between the Message & Content codecs, and that's their lifecycle. The former is a lifecycle per message, but the latter maintains context of the encoders for the whole payload. There are some code similarities on the aggregated signatures, but its not that much to worth keeping them in one place for now.", "author": "tkountis", "createdAt": "2020-10-20T09:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyODYwOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508728609", "bodyText": "I think we can merge streaming and non-streaming variants in a single interface and make the streaming variant in the way it applies the non-streaming method as a mapping function for each chunk. Some compression algorithms work in this way, like LZ4. It will reduce the need for implementing a streaming variant when it's not necessary, like for grpc.\nAnother way is to provide ContentCodec and StreamingContentCodec interfaces. The main idea is to make the compression/decompression logic protocol agnostic, without embedding the logic that manages headers, for cases if we have more protocols in the future. That way users will be able to reuse the codec algorithms without implementing a custom codec for each protocol.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T17:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNDkxNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518434915", "bodyText": "This discussion moves to #1198 (comment)", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTczMQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508195731", "bodyText": "This method is used only in tests and internal unitily, can we make it pkg-private for now?", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:02:06Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default available encoding implementations.\n+ * Encoding {@link #none()} is always supported regardless of the client or server settings.\n+ *\n+ * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n+ */\n+public final class ContentCodings {\n+\n+    static final CharSequence GZIP_HEADER = \"gzip\";\n+    static final CharSequence DEFLATE_HEADER = \"deflate\";\n+\n+    private static final ContentCoding NONE =\n+            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n+\n+    private static final ContentCoding GZIP =\n+            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n+\n+    private static final ContentCoding DEFLATE =\n+            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n+\n+    private static final Set<ContentCoding> ALL =\n+            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link ContentCoding}.\n+     * @return the default, always supported 'identity' {@link ContentCoding}\n+     */\n+    public static ContentCoding none() {\n+        return NONE;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static ContentCoding gzip() {\n+        return GZIP;\n+    }\n+\n+    /**\n+     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static ContentCoding deflate() {\n+        return DEFLATE;\n+    }\n+\n+    /**\n+     * Returns a list of all {@link ContentCoding}s included by default.\n+     * @return a list of all {@link ContentCoding}s included by default\n+     */\n+    public static Set<ContentCoding> all() {\n+        return ALL;\n+    }\n+\n+    /**\n+     * Returns a {@link ContentCoding} that matches the {@code name}.\n+     * Returns {@code null} if {@code name} is {@code null} or empty.\n+     * If {@code name} is {@code 'identity'} this will always result in\n+     * {@link ContentCodings#NONE} regardless of its presence in the {@code allowedList}.\n+     *\n+     * @param allowedList the source list to find a matching encoding in\n+     * @param name the encoding name used for the matching predicate\n+     * @return an encoding from the allowed-list matching the {@code name},\n+     *          otherwise {@code null} if {@code name} is {@code null} or empty\n+     */\n+    @Nullable\n+    public static ContentCoding encodingFor(final Collection<ContentCoding> allowedList,", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTg1Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508195857", "bodyText": "Why none is prefered instead of standard identity?", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:02:40Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default available encoding implementations.\n+ * Encoding {@link #none()} is always supported regardless of the client or server settings.\n+ *\n+ * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n+ */\n+public final class ContentCodings {\n+\n+    static final CharSequence GZIP_HEADER = \"gzip\";\n+    static final CharSequence DEFLATE_HEADER = \"deflate\";\n+\n+    private static final ContentCoding NONE =\n+            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n+\n+    private static final ContentCoding GZIP =\n+            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n+\n+    private static final ContentCoding DEFLATE =\n+            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n+\n+    private static final Set<ContentCoding> ALL =\n+            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link ContentCoding}.\n+     * @return the default, always supported 'identity' {@link ContentCoding}\n+     */\n+    public static ContentCoding none() {\n+        return NONE;", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NDU0MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508344541", "bodyText": "I like identity more, the only reason I kept none around was that it was already there as a keywords for gRPC and thus I kept the same language. Its a bit more fluent from a user's perspective, but I really have no hard preference.", "author": "tkountis", "createdAt": "2020-10-20T09:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODcyOTg4MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508729880", "bodyText": "Let's rename to identity in for both protocols. It helps reduce thinking when the name matches the header value.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T17:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5NTg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5ODU4Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508198586", "bodyText": "There is also arrayOffset() method that is important in this case. See an example here: \n  \n    \n      servicetalk/servicetalk-buffer-api/src/main/java/io/servicetalk/buffer/api/ReadOnlyByteBuffer.java\n    \n    \n         Line 113\n      in\n      c3b3504\n    \n    \n    \n    \n\n        \n          \n           dst.setBytes(dstIndex, buffer.array(), buffer.arrayOffset() + index, length);", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:14:02Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,540 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements ContentCodec {\n+\n+    protected static final int ONE_KB = 1 << 10;\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();\n+\n+    private final CharSequence encoding;\n+\n+    AbstractZipContentCodec(final CharSequence encoding) {\n+        this.encoding = encoding;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final HttpHeaders headers, final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        addContentEncoding(headers, encoding);\n+\n+        final Buffer dst = allocator.newBuffer(ONE_KB);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNzQ0OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518437448", "bodyText": "This is not resolved, you need to do output.write(src.array(), src.arrayOffset()+ offset, length), bcz a Buffer may have an internal offset for the backing byte array.", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5ODU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5OTA2MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508199061", "bodyText": "Did you consider using netty's implementations instead? We can create an EmbeddedChannel with a single compression codec from netty and use it for async decompression. It will also handle buffering for you.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:15:51Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,540 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.buffer.api.EmptyBuffer.EMPTY_BUFFER;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements ContentCodec {\n+\n+    protected static final int ONE_KB = 1 << 10;\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();\n+\n+    private final CharSequence encoding;\n+\n+    AbstractZipContentCodec(final CharSequence encoding) {\n+        this.encoding = encoding;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final HttpHeaders headers, final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        addContentEncoding(headers, encoding);\n+\n+        final Buffer dst = allocator.newBuffer(ONE_KB);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[min(src.readableBytes(), ONE_KB)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final HttpHeaders headers, final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        addContentEncoding(headers, encoding);\n+        return from\n+                .map((it) -> (Object) it)\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Object>() {\n+\n+                    @Nullable\n+                    Buffer dst;\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            dst = allocator.newBuffer(ONE_KB);\n+                            output = newDeflaterOutputStream(asOutputStream(dst));\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        subscriber.onSubscribe(subscription);\n+                    }\n+\n+                    @Override\n+                    public void onNext(Object next) {\n+                        assert output != null;\n+                        assert dst != null;\n+\n+                        try {\n+                            if (next == END_OF_STREAM) {\n+                                try {\n+                                    output.finish();\n+                                    subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                                return;\n+                            }\n+\n+                            Buffer src = (Buffer) next;\n+                            if (src.hasArray()) {\n+                                output.write(src.array(), src.readerIndex(), src.readableBytes());\n+                            } else {\n+                                while (src.readableBytes() > 0) {\n+                                    byte[] onHeap = new byte[min(src.readableBytes(), ONE_KB)];\n+                                    src.readBytes(onHeap);\n+                                    output.write(onHeap);\n+                                }\n+                            }\n+\n+                            output.flush();\n+                            subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable t) {\n+                        closeQuietly(output);\n+                        subscriber.onError(t);\n+                    }\n+\n+                    @Override\n+                    public void onComplete() {\n+                        closeQuietly(output);\n+                        subscriber.onComplete();\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public final Buffer decode(final Buffer src, final int offset, final int length, final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(ONE_KB);\n+        InflaterInputStream input = null;\n+        try {\n+            input = newInflaterInputStream(asInputStream(src));\n+\n+            int read = dst.setBytesUntilEndStream(0, input, ONE_KB);\n+            dst.writerIndex(read);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(input);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> decode(final Publisher<Buffer> from, final BufferAllocator allocator) {\n+        return from.liftSync(subscriber -> new PublisherSource.Subscriber<Buffer>() {\n+\n+            @Nullable\n+            Buffer dst;\n+            @Nullable\n+            Inflater inflater;\n+            @Nullable\n+            ZLibStreamDecoder streamDecoder;\n+\n+            @Override\n+            public void onSubscribe(final PublisherSource.Subscription subscription) {\n+                dst = allocator.newBuffer(ONE_KB);\n+                inflater = newRawInflater();\n+                streamDecoder = new ZLibStreamDecoder(dst, inflater, supportsChecksum());\n+                subscriber.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final Buffer src) {\n+                assert streamDecoder != null;\n+                assert src != null;\n+\n+                Buffer part;\n+                try {\n+                    if (streamDecoder.isFinished()) {\n+                        throw new IllegalStateException(\"Stream encoder previously closed but more input arrived \");\n+                    }\n+\n+                    part = streamDecoder.decode(src);\n+                    subscriber.onNext(part != null ? part : EMPTY_BUFFER);\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            @Override\n+            public void onError(final Throwable t) {\n+                assert inflater != null;\n+\n+                inflater.end();\n+                subscriber.onError(t);\n+            }\n+\n+            @Override\n+            public void onComplete() {\n+                assert inflater != null;\n+\n+                inflater.end();\n+                subscriber.onComplete();\n+            }\n+        });\n+    }\n+\n+    private void closeQuietly(@Nullable final Closeable closeable) {\n+        try {\n+            if (closeable != null) {\n+                closeable.close();\n+            }\n+        } catch (IOException e) {\n+            LOGGER.error(\"Unexpected IO exception while closing buffer streams\", e);\n+        }\n+    }\n+\n+    // Code forked from Netty's JdkZlibDecoder\n+    static class ZLibStreamDecoder {\n+        private static final int FHCRC = 0x02;\n+        private static final int FEXTRA = 0x04;\n+        private static final int FNAME = 0x08;", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0NjU3NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508346574", "bodyText": "This is Netty's implementation, unless you are referring to keeping everything on the transport layer, in which I did consider it, and chose to go with this approach for a few reasons.\n\nIt allows from a much easier codec interface for a user to implement if they want custom encoder\nIt allows for cold reads, on the receiving side, it will be decompressed when you need it, and not necessarily inside the event loop.\nIt is consistent with gRPC experience", "author": "tkountis", "createdAt": "2020-10-20T09:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5OTA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczMjU3OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508732579", "bodyText": "Discussed offline the approach with EmbeddedChannel:\nIt won't require changing our public API or doing all the work in the transport layer on the event loop, we will just use a synthetic EmbeddedChannel internally instead of Input/Output streams to avoid manual parsing of the compression headers. The only downside is that we will need to depend on netty packages. Therefore, our implementations will need to be in a separate module, something like servicetalk-content-coding-netty.\nLet's finish changes for the public API and then we can reconsider the internal implementations.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T18:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE5OTA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMDgwMQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508200801", "bodyText": "The configuration of the compressor is very important aspect. The default level and buffer size does not fit for all use-cases. Did you explore a builder approach for each implementation that will provide these options?", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:23:20Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.unmodifiableSet;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default available encoding implementations.\n+ * Encoding {@link #none()} is always supported regardless of the client or server settings.\n+ *\n+ * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n+ */\n+public final class ContentCodings {\n+\n+    static final CharSequence GZIP_HEADER = \"gzip\";\n+    static final CharSequence DEFLATE_HEADER = \"deflate\";\n+\n+    private static final ContentCoding NONE =\n+            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n+\n+    private static final ContentCoding GZIP =\n+            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n+\n+    private static final ContentCoding DEFLATE =\n+            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n+\n+    private static final Set<ContentCoding> ALL =\n+            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link ContentCoding}.\n+     * @return the default, always supported 'identity' {@link ContentCoding}\n+     */\n+    public static ContentCoding none() {\n+        return NONE;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static ContentCoding gzip() {\n+        return GZIP;\n+    }\n+\n+    /**\n+     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n+     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static ContentCoding deflate() {", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwNzk1NQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508207955", "bodyText": "Another thing to consider as part of the configuration of the decompressor is a protection against ZIP bomb [1]. Users should be able to specify a maximum size to decompress. And ST should stop decompressing if the produced output is higher than that thresold and file the request or response.\n\nhttps://en.wikipedia.org/wiki/Zip_bomb", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:52:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMDgwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0ODc3OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508348778", "bodyText": "Nice topic, hmm I didn't TBH, and even though I want to keep this simple, it might worth doing that sooner rather than later to have a complete API at least instead of possibly breaking it later. Good catch, especially the zip bomb.", "author": "tkountis", "createdAt": "2020-10-20T09:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMDgwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczMzcwMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508733703", "bodyText": "The ContentCodings factory class is good for discoverability. We can keep it, but instead of a ContentCoding it may return builders for deflate and gzip.\nLook it the approach in HttpProtocolConfigs.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T18:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMDgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMjkzNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508202934", "bodyText": "newAsciiString is useful when we have content as Buffer and want to give users its CharSequence representation without copying. If you already have a String, there is no need to wrap it with newAsciiString.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:32:18Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -636,6 +655,128 @@ private HttpCookiePair findNext(CharSequence cookieHeaderValue) {\n         }\n     }\n \n+    /**\n+     * Advertise the list of supported encodings to the request/response headers.\n+     * The list will be advertised as part of the Accept-Encoding header\n+     *\n+     * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n+     *\n+     * @param headers the headers to modify\n+     * @param encodings the list of encodings to be used in the string representation.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n+                                                  final Collection<ContentCoding> encodings) {\n+        if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n+            return;\n+        }\n+\n+        StringBuilder builder = new StringBuilder();\n+        for (ContentCoding enc : encodings) {\n+            if (enc == none()) {\n+                continue;\n+            }\n+\n+            if (builder.length() > 0) {\n+                builder.append(\", \");\n+            }\n+\n+            builder.append(enc.name());\n+        }\n+\n+        CharSequence value = newAsciiString(builder.toString());", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMzA1Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508203056", "bodyText": "Consider doing builder.toString() only if this is true.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:32:45Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -636,6 +655,128 @@ private HttpCookiePair findNext(CharSequence cookieHeaderValue) {\n         }\n     }\n \n+    /**\n+     * Advertise the list of supported encodings to the request/response headers.\n+     * The list will be advertised as part of the Accept-Encoding header\n+     *\n+     * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n+     *\n+     * @param headers the headers to modify\n+     * @param encodings the list of encodings to be used in the string representation.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n+                                                  final Collection<ContentCoding> encodings) {\n+        if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n+            return;\n+        }\n+\n+        StringBuilder builder = new StringBuilder();\n+        for (ContentCoding enc : encodings) {\n+            if (enc == none()) {\n+                continue;\n+            }\n+\n+            if (builder.length() > 0) {\n+                builder.append(\", \");\n+            }\n+\n+            builder.append(enc.name());\n+        }\n+\n+        CharSequence value = newAsciiString(builder.toString());\n+        if (value.length() > 0) {", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwNjc2NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508206764", "bodyText": "There are cases when identity can be disabled: https://tools.ietf.org/html/rfc7231#section-5.3.4\nSee identity;q=0 value.\nWe don't need to address this as part of this PR, but good thing to consider for the general control flow.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:48:11Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -636,6 +655,128 @@ private HttpCookiePair findNext(CharSequence cookieHeaderValue) {\n         }\n     }\n \n+    /**\n+     * Advertise the list of supported encodings to the request/response headers.\n+     * The list will be advertised as part of the Accept-Encoding header\n+     *\n+     * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n+     *\n+     * @param headers the headers to modify\n+     * @param encodings the list of encodings to be used in the string representation.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n+                                                  final Collection<ContentCoding> encodings) {\n+        if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n+            return;\n+        }\n+\n+        StringBuilder builder = new StringBuilder();\n+        for (ContentCoding enc : encodings) {\n+            if (enc == none()) {\n+                continue;\n+            }\n+\n+            if (builder.length() > 0) {\n+                builder.append(\", \");\n+            }\n+\n+            builder.append(enc.name());\n+        }\n+\n+        CharSequence value = newAsciiString(builder.toString());\n+        if (value.length() > 0) {\n+            headers.add(ACCEPT_ENCODING, value);\n+        }\n+    }\n+\n+    /**\n+     * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n+     * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n+     * <p>\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n+     *\n+     * @param headers The request headers\n+     * @param serverSupportedEncodings The supported encodings as configured for the server\n+     * @return The {@link ContentCoding} that satisfies both client and server needs.\n+     */\n+    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n+                                                          final Set<ContentCoding> serverSupportedEncodings) {\n+        // Fast path, server has no encodings configured or has only None configured as encoding\n+        if (serverSupportedEncodings.isEmpty() ||\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n+            return none();\n+        }\n+\n+        Set<ContentCoding> clientSupportedEncodings =\n+                readAcceptEncoding(headers, serverSupportedEncodings);\n+        return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n+    }\n+\n+    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n+                                                   final Set<ContentCoding> allowedEncodings) {\n+        // Fast path, Client has no encodings configured, or has None as the only encoding configured\n+        if (clientSupportedEncodings == NONE_CONTENT_ENCODING_SINGLETON ||\n+                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(none()))) {\n+            return none();", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI2MjE5MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525262191", "bodyText": "#1214", "author": "tkountis", "createdAt": "2020-11-17T15:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwNjc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTA5Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508209096", "bodyText": "Continuing discussion of ZIP bombs [1], there is a frequent use-case for the server-side, that users want respond with compressed data, but need to reject all requests with compressed payload body. This is a good discussion on the topic [2].\nHow can we allow this configuration for the server-side?\nAlso, worth thinking about GrpcServer builder.\nNot necessary to implement this feature as part of this PR, but good to adjust configuration API to support that in a follow-up.\n\nhttps://en.wikipedia.org/wiki/Zip_bomb\nhttps://stackoverflow.com/questions/13031968/compressing-http-post-data-sent-from-browser", "author": "idelpivnitskiy", "createdAt": "2020-10-20T04:56:17Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpProtocolConfig.java", "diffHunk": "@@ -36,4 +38,13 @@\n      * @return {@link HttpHeadersFactory} to be used for creating {@link HttpHeaders} when decoding HTTP messages\n      */\n     HttpHeadersFactory headersFactory();\n+\n+    /**\n+     * A collection of all {@link ContentCoding}s the endpoint supports.\n+     * The list will be advertised as part of the Accept-Encoding header.\n+     *\n+     * @return The list of supported {@link ContentCoding}s for this endpoint.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    Set<ContentCoding> supportedEncodings();", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0OTk3Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508349977", "bodyText": "I believe this is doable as is now. If you provide NO supported-encodings for the server, then any encoded request will fail, and you can manually enable a response encoding using the HttpMetadata.encoding()", "author": "tkountis", "createdAt": "2020-10-20T09:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczNjkzNw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508736937", "bodyText": "Agreed, this is a way to work around the issue, but it looks like a most-common use-case for the server-side to have a compression for responses only.\nIt looks like if we move this configuration to the client/server builder, we will have better control. For example, server's builder may have 2 overloads: one to support compression in both ways, another overload to support it only for responses.\nHaving it on the builder will also help:\n\nto avoid duplication. Hard to imagine that users need compression for h1, but don't need it for h2. Therefore, makes more sense to keep them applied for all supported transport protocols.\nto consolidate logic in the filter instead of expanding responsibility of NettyHttpServer and client connections.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T18:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2OTk1OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508869959", "bodyText": "Btw, we should also account for the proxy use-case: a gateway proxy service that resends the response from downstream backend as-is, when the response is already compressed.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T22:09:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwOTA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMTU3MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508211571", "bodyText": "We should also have intergration tests with some other server implementation. For example, consider running a netty server to make sure it can decompress data produced by ST and vice versa.\nFor grpc we can do that with grpc-java, in a follow-up PR.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T05:05:17Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentCodingTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.BlockingStreamingHttpClient;\n+import io.servicetalk.http.api.ContentCoding;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.HttpHeaders;\n+import io.servicetalk.http.api.HttpProtocolConfig;\n+import io.servicetalk.http.api.HttpServerBuilder;\n+import io.servicetalk.http.api.HttpServiceContext;\n+import io.servicetalk.http.api.StreamingHttpClient;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+import io.servicetalk.http.api.StreamingHttpService;\n+import io.servicetalk.http.api.StreamingHttpServiceFilter;\n+import io.servicetalk.http.api.StreamingHttpServiceFilterFactory;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.ContentCodings.deflate;\n+import static io.servicetalk.http.api.ContentCodings.encodingFor;\n+import static io.servicetalk.http.api.ContentCodings.gzip;\n+import static io.servicetalk.http.api.ContentCodings.none;\n+import static io.servicetalk.http.api.HttpHeaderNames.ACCEPT_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_ENCODING;\n+import static io.servicetalk.http.api.HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.lang.String.valueOf;\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+import static java.util.Collections.disjoint;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptySet;\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class ContentCodingTest {", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1MDQyMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508350422", "bodyText": "\ud83d\udc4d Sure, I will keep this as a separate PR.", "author": "tkountis", "createdAt": "2020-10-20T09:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMTU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI2MzM1OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525263358", "bodyText": "#1215", "author": "tkountis", "createdAt": "2020-11-17T15:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxMTU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNTM5OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508215398", "bodyText": "Can client-side users configure compression on the builder and then have it for all requests?", "author": "idelpivnitskiy", "createdAt": "2020-10-20T05:19:13Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/ContentCodingTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.BlockingStreamingHttpClient;\n+import io.servicetalk.http.api.ContentCoding;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.HttpHeaders;\n+import io.servicetalk.http.api.HttpProtocolConfig;\n+import io.servicetalk.http.api.HttpServerBuilder;\n+import io.servicetalk.http.api.HttpServiceContext;\n+import io.servicetalk.http.api.StreamingHttpClient;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+import io.servicetalk.http.api.StreamingHttpService;\n+import io.servicetalk.http.api.StreamingHttpServiceFilter;\n+import io.servicetalk.http.api.StreamingHttpServiceFilterFactory;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.ContentCodings.deflate;\n+import static io.servicetalk.http.api.ContentCodings.encodingFor;\n+import static io.servicetalk.http.api.ContentCodings.gzip;\n+import static io.servicetalk.http.api.ContentCodings.none;\n+import static io.servicetalk.http.api.HttpHeaderNames.ACCEPT_ENCODING;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_ENCODING;\n+import static io.servicetalk.http.api.HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textDeserializer;\n+import static io.servicetalk.http.api.HttpSerializationProviders.textSerializer;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.lang.String.valueOf;\n+import static java.util.Arrays.asList;\n+import static java.util.Arrays.stream;\n+import static java.util.Collections.disjoint;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptySet;\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class ContentCodingTest {\n+\n+    private static final int PAYLOAD_SIZE = 512;\n+    private static final AtomicBoolean ASYNC_ERROR = new AtomicBoolean(false);\n+\n+    private static final Function<TestEncodingScenario, StreamingHttpServiceFilterFactory> REQ_RESP_VERIFIER = (options)\n+            -> new StreamingHttpServiceFilterFactory() {\n+        @Override\n+        public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+            return new StreamingHttpServiceFilter(service) {\n+                @Override\n+\n+                public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                            final StreamingHttpRequest request,\n+                                                            final StreamingHttpResponseFactory responseFactory) {\n+                    final ContentCoding reqEncoding = options.requestEncoding;\n+                    final Set<ContentCoding> clientSupportedEncodings = options.clientSupported;\n+\n+                    try {\n+\n+                        String requestPayload = request.payloadBody(textDeserializer()).collect(StringBuilder::new,\n+                                StringBuilder::append).toFuture().get().toString();\n+\n+                        assertEquals(payload((byte) 'a'), requestPayload);\n+\n+                        final List<String> actualReqAcceptedEncodings = stream(request.headers()\n+                                .get(ACCEPT_ENCODING, \"NOT_PRESENT\").toString().split(\",\"))\n+                                .map((String::trim)).collect(toList());\n+\n+                        final List<String> expectedReqAcceptedEncodings = (clientSupportedEncodings == null) ?\n+                                emptyList() :\n+                                clientSupportedEncodings.stream()\n+                                        .filter((enc) -> enc != none())\n+                                        .map((ContentCoding::name))\n+                                        .collect(toList());\n+\n+                        if (reqEncoding != none()) {\n+                            assertTrue(\"Request encoding should be present in the request headers\",\n+                                    contentEquals(reqEncoding.name(),\n+                                            request.headers().get(ACCEPT_ENCODING, \"null\")));\n+                        }\n+\n+                        if (!expectedReqAcceptedEncodings.isEmpty() && !actualReqAcceptedEncodings.isEmpty()) {\n+                            assertEquals(expectedReqAcceptedEncodings, actualReqAcceptedEncodings);\n+                        }\n+                    } catch (Throwable t) {\n+                        ASYNC_ERROR.set(true);\n+                        t.printStackTrace();\n+                        throw new RuntimeException(t);\n+                    }\n+\n+                    return super.handle(ctx, request, responseFactory);\n+                }\n+            };\n+        }\n+    };\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final HttpServerBuilder httpServerBuilder;\n+    private final ServerContext serverContext;\n+    private final HttpClient client;\n+    protected final TestEncodingScenario testEncodingScenario;\n+    private final boolean expectedSuccess;\n+\n+    public ContentCodingTest(final Set<ContentCoding> serverSupportedEncodings,\n+                             final Set<ContentCoding> clientSupportedEncodings,\n+                             final ContentCoding requestEncoding, final boolean expectedSuccess,\n+                             final Protocol protocol) throws Exception {\n+        this.testEncodingScenario = new TestEncodingScenario(requestEncoding, clientSupportedEncodings,\n+                serverSupportedEncodings, protocol);\n+        this.expectedSuccess = expectedSuccess;\n+\n+        httpServerBuilder = HttpServers.forAddress(localAddress(0)).enableWireLogging(\"server\");\n+        serverContext = listenAndAwait();\n+        client = newClient();\n+    }\n+\n+    @Parameterized.Parameters(name = \"server-supported-encodings={0} client-supported-encodings={1} \" +\n+            \"request-encoding={2} expected-success={3} protocol={4}\")\n+    public static Object[][] params() {\n+        return new Object[][] {\n+                {null, null, none(), true, Protocol.H1},\n+                {null, null, none(), true, Protocol.H2},\n+                {null, of(gzip(), none()), gzip(), false, Protocol.H1},\n+                {null, of(gzip(), none()), gzip(), false, Protocol.H2},\n+                {null, of(deflate(), none()), deflate(), false, Protocol.H1},\n+                {null, of(deflate(), none()), deflate(), false, Protocol.H2},\n+                {of(gzip(), deflate(), none()), null, none(), true, Protocol.H1},\n+                {of(gzip(), deflate(), none()), null, none(), true, Protocol.H2},\n+                {of(none(), gzip(), deflate()), of(gzip(), none()), gzip(), true, Protocol.H1},\n+                {of(none(), gzip(), deflate()), of(gzip(), none()), gzip(), true, Protocol.H2},\n+                {of(none(), gzip(), deflate()), of(deflate(), none()), deflate(), true, Protocol.H1},\n+                {of(none(), gzip(), deflate()), of(deflate(), none()), deflate(), true, Protocol.H2},\n+                {of(none(), gzip()), of(deflate(), none()), deflate(), false, Protocol.H1},\n+                {of(none(), gzip()), of(deflate(), none()), deflate(), false, Protocol.H2},\n+                {of(none(), deflate()), of(gzip(), none()), gzip(), false, Protocol.H1},\n+                {of(none(), deflate()), of(gzip(), none()), gzip(), false, Protocol.H2},\n+                {of(none(), deflate()), of(deflate(), none()), deflate(), true, Protocol.H1},\n+                {of(none(), deflate()), of(deflate(), none()), deflate(), true, Protocol.H2},\n+                {of(none(), deflate()), null, none(), true, Protocol.H1},\n+                {of(none(), deflate()), null, none(), true, Protocol.H2},\n+                {of(gzip()), of(none()), none(), true, Protocol.H1},\n+                {of(gzip()), of(none()), none(), true, Protocol.H2},\n+                {of(gzip()), of(gzip(), none()), none(), true, Protocol.H1},\n+                {of(gzip()), of(gzip(), none()), none(), true, Protocol.H2},\n+                {of(gzip()), of(gzip(), none()), none(), true, Protocol.H1},\n+                {of(gzip()), of(gzip(), none()), none(), true, Protocol.H2},\n+                {of(gzip()), of(gzip(), none()), gzip(), true, Protocol.H1},\n+                {of(gzip()), of(gzip(), none()), gzip(), true, Protocol.H2},\n+                {null, of(gzip(), none()), gzip(), false, Protocol.H1},\n+                {null, of(gzip(), none()), gzip(), false, Protocol.H2},\n+                {null, of(gzip(), deflate(), none()), deflate(), false, Protocol.H1},\n+                {null, of(gzip(), deflate(), none()), deflate(), false, Protocol.H2},\n+                {null, of(gzip(), none()), none(), true, Protocol.H1},\n+                {null, of(gzip(), none()), none(), true, Protocol.H2},\n+        };\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        ASYNC_ERROR.set(false);\n+        try {\n+            client.close();\n+        } finally {\n+            serverContext.close();\n+        }\n+    }\n+\n+    private ServerContext listenAndAwait() throws Exception {\n+        HttpProtocolConfig config = testEncodingScenario.protocol.build(testEncodingScenario.serverSupported);\n+\n+        StreamingHttpService service = (ctx, request, responseFactory) -> Single.succeeded(responseFactory.ok()\n+                .payloadBody(from(payload((byte) 'b')), textSerializer()));\n+\n+        StreamingHttpServiceFilterFactory filterFactory = REQ_RESP_VERIFIER.apply(testEncodingScenario);\n+        return httpServerBuilder.appendServiceFilter(filterFactory)\n+                .protocols(config)\n+                .listenStreamingAndAwait(service);\n+    }\n+\n+    private HttpClient newClient() {\n+        HttpProtocolConfig config = testEncodingScenario.protocol.build(testEncodingScenario.clientSupported);\n+\n+        return HttpClients.forSingleAddress(serverHostAndPort(serverContext))\n+                .protocols(config)\n+                .build();\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        if (expectedSuccess) {\n+            assertSuccessful(testEncodingScenario.requestEncoding);\n+        } else {\n+            assertNotSupported(testEncodingScenario.requestEncoding);\n+        }\n+    }\n+\n+    private static String payload(byte b) {\n+        byte[] payload = new byte[PAYLOAD_SIZE];\n+        Arrays.fill(payload, b);\n+        return new String(payload, StandardCharsets.US_ASCII);\n+    }\n+\n+    private void assertSuccessful(final ContentCoding encoding) throws Exception {\n+        assertResponse(client.request(client\n+                .get(\"/\")\n+                .encoding(encoding)", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1MjE4NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508352184", "bodyText": "They can't as of now. My thinking was that a request isn't always a good fit for compression, eg. GET/DELETE requests, or even smaller PUTs/POSTs. It looked more fluent to enable it on-demand, rather than disable it on-demand. If you have hard objections about it, I can track it as a separate PR.", "author": "tkountis", "createdAt": "2020-10-20T09:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNTM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczNzc1OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508737759", "bodyText": "Discussed offline, users can insert a simple filter if they need compression for all requests that are sent.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T18:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNTM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNjM3MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508216370", "bodyText": "It's good that we know the answer how users can configure compression per-reqiest or per-response. They can specify different compression levels for different payloads. However, this is too advanced use-case. Wonder if we should start with a simple approach based on a filter and let users control it there. Let's discuss this offline.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T05:22:38Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java", "diffHunk": "@@ -46,6 +47,30 @@\n      */\n     HttpHeaders headers();\n \n+    /**\n+     * The {@link ContentCoding} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n+     * request or a response.\n+     * If the endpoint protocol is setup with {@link HttpProtocolConfig#supportedEncodings()} the server will\n+     * auto-establish the accepted encoding for the response, unless the caller provides a specific encoding\n+     * calling this method. Any encoding passed here, takes precedence. In other words, a compressed response, can\n+     * be disabled by passing {@link ContentCodings#none()}.\n+     *\n+     * @param encoding The {@link ContentCoding} used for the encoding of the payload.\n+     * @return {@code this}.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>\n+     */\n+    HttpMetaData encoding(ContentCoding encoding);", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1NDAzNw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508354037", "bodyText": "It is an advanced use-case indeed, and a filter would also work nicely (even though you would have to work with headers instead of using the API). The reason I kept this as part of the API is that compression/encoding is part of the vanilla HTTP spec, so it feels more natural to have an option to control that for a request/response, rather than having a proxy to do so. WDYT?", "author": "tkountis", "createdAt": "2020-10-20T09:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNjM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIxNzYyOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508217628", "bodyText": "Considere storing response.encoding() result in a local variable to avoid NPE warning for codec() method.\nYou can also move ContentCodec variable inside if.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T05:26:23Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java", "diffHunk": "@@ -385,6 +418,30 @@ public void onComplete() {\n             }\n         }\n \n+        private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n+                                                            final Set<ContentCoding> supportedEncodings,\n+                                                            final StreamingHttpResponse response,\n+                                                            final BufferAllocator allocator) {\n+            if (supportedEncodings.isEmpty()) {\n+                return;\n+            }\n+\n+            ContentCodec codec;\n+            if (response.encoding() != null) {\n+                codec = response.encoding().codec();", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczOTAxNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r508739015", "bodyText": "This API is used only by ST, consider using CharSequence here to avoid internal conversions toString(). We have CharSequences utility class that does case-insensitive comparisons.", "author": "idelpivnitskiy", "createdAt": "2020-10-20T18:14:56Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCoding.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+/**\n+ * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n+ */\n+public interface ContentCoding {\n+\n+    /**\n+     * A string representation for the content coding.\n+     *\n+     * @return a string representation for the content coding.\n+     */\n+    String name();", "originalCommit": "61ca11601f723929c65258f42b4535a3b9525849", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "url": "https://github.com/apple/servicetalk/commit/3e60ba94e6e8a8945218e8d7fa20acdcd3db03d9", "message": "Rename to Codec & rebase", "committedDate": "2020-11-04T13:38:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzMDI3Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518430273", "bodyText": "I do not see much value in having an extended interface that adds only default methods. In this case, we can just add default methods to ContentCodec interface.\nAnother approach will be to have 2 independent interfaces: one for streamin, one for non-streaming use-case. They will have a common CharSequence name() method, which is fine to duplicate.\nEach approach has pros and cons:\n\n\nWith a single interface:\n-- users who care only about a streaming variant will also need to implement non-streaming variant. They probably can just thrown UnsupportedOperationException.\n-- users who use non-streaming implementation for streaming case may be broken (depends on compression algorithm). I do not expect it to happen with our implementations.\n\n\nWith 2 interfaces builders will need to have 2  methods: for streaming (buildStreaming()) and non-streaming (build()) variant.\n\n\nI'm fine with both approaches. If we anticipate a protocol in the future that needs both variants, having everything in a single interface will be better.\n@Scottmitch wdyt?", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:22:15Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodec.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.\n+ *\n+ * Used to encode and decode {@link Publisher} of {@link Buffer} parts.\n+ * This instance is shared therefore it must provide thread safety semantics.\n+ */\n+public interface StreamingContentCodec extends ContentCodec {\n+\n+    /**\n+     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n+     * {@link Publisher} of {@link Buffer} with the encoded contents.\n+     *\n+     * @param from the {@link Publisher} buffer to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Publisher} the result publisher with the buffers encoded\n+     */\n+    default Publisher<Buffer> encode(Publisher<Buffer> from, BufferAllocator allocator) {\n+        return from.map((buffer -> encode(buffer, allocator)));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3MTk1MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519071950", "bodyText": "Lets use a single interface like we do for Serializer. The assumption is impls need to support both streaming an aggregated or else they are not usable across the APIs provided by ServiceTalk.\nI would prefer to remain as consistent as possible with the Serializer and HttpSerializer interfaces/approach. They are largely doing the same thing (serializing/deserializing data), except in this case we don't need to care about the Type parameters/conversions. For example did you consider a similar split of BufferSerializer (non protocol specific) and HttpBufferSerializer (http specific)? This may also avoid the tight coupling between HttpMetaData and StreamingContentCodec if the encoding/decoding can be done at the call sites via the payload transformation methods (with helpers from the protocol specific layer).", "author": "Scottmitch", "createdAt": "2020-11-07T00:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzMDI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzMzQxMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518433410", "bodyText": "Since the codec classes do not carry any http-related information it's better to avoid mentioning HTTP here. Adding this reference in encoding() methods on HttpMetaData is enough.\nWe have a potential to move them to another module outside of HTTP. Not sure if we need to do it now.", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:30:49Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodec.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * API for HTTP <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.1\">Content Codings</a>.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzODUyNg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518438526", "bodyText": "Use src.arrayOffset() + src.readerIndex()", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:45:40Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -153,7 +151,7 @@ public void onNext(Object next) {\n                                 output.write(src.array(), src.readerIndex(), src.readableBytes());", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc3OTQ3Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518779472", "bodyText": "Will do in the gRPC part, because the API changed there.", "author": "tkountis", "createdAt": "2020-11-06T14:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzODUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MTExMQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518441111", "bodyText": "Should we add identity to the list of header values if it's present in the collection?", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:53:46Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -656,24 +659,25 @@ private HttpCookiePair findNext(CharSequence cookieHeaderValue) {\n     }\n \n     /**\n-     * Advertise the list of supported encodings to the request/response headers.\n+     * Advertise the list of supported encodings to the request headers.\n      * The list will be advertised as part of the Accept-Encoding header\n      *\n      * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n      *\n-     * @param headers the headers to modify\n+     * @param metaData the metadata headers to modify\n      * @param encodings the list of encodings to be used in the string representation.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n      */\n-    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n-                                                  final Collection<ContentCoding> encodings) {\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpMetaData metaData,\n+                                                  final Collection<StreamingContentCodec> encodings) {\n+        final HttpHeaders headers = metaData.headers();\n         if (headers.contains(ACCEPT_ENCODING) || encodings.isEmpty()) {\n             return;\n         }\n \n         StringBuilder builder = new StringBuilder();\n-        for (ContentCoding enc : encodings) {\n-            if (enc == none()) {\n+        for (StreamingContentCodec enc : encodings) {\n+            if (enc == identity()) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY4OTgwNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518689804", "bodyText": "This is always considered acceptable, unless specifically disabled with a 'q' value. Its allowed to be skipped.\nI skipped it, to avoid having it in the headers if its the only encoding, it provides no useful info.", "author": "tkountis", "createdAt": "2020-11-06T11:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MTExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MTc4Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518441782", "bodyText": "Consider using builder.length() > 0 check instead of prematurely building a String. Otherwise, for non-empty use-case it will copy memory twice.", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:55:48Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MjIyMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518442222", "bodyText": "newAsciiString is useful when we have content as Buffer and want to give users its CharSequence representation without copying. If you already have a String, there is no need to wrap it with newAsciiString.", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:57:12Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {\n+            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MzI1OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518443258", "bodyText": "This method can be pkg-private", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:00:01Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -656,24 +659,25 @@ private HttpCookiePair findNext(CharSequence cookieHeaderValue) {\n     }\n \n     /**\n-     * Advertise the list of supported encodings to the request/response headers.\n+     * Advertise the list of supported encodings to the request headers.\n      * The list will be advertised as part of the Accept-Encoding header\n      *\n      * If {@code headers} already contain {@code 'Accept-Encoding'} header, then this method has no effect.\n      *\n-     * @param headers the headers to modify\n+     * @param metaData the metadata headers to modify\n      * @param encodings the list of encodings to be used in the string representation.\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n      */\n-    public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders headers,\n-                                                  final Collection<ContentCoding> encodings) {\n+    public static void advertiseAcceptedEncodingsIfAvailable(final HttpMetaData metaData,", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MzQyMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518443420", "bodyText": "This method can be pkg-private", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:00:31Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {\n+            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n         }\n     }\n \n     /**\n      * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link ContentCoding} that satisfies both client and server needs.\n+     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n      */\n-    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n-                                                          final Set<ContentCoding> serverSupportedEncodings) {\n+    public static StreamingContentCodec negotiateAcceptedEncoding(", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0MzU1Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518443557", "bodyText": "This method can be pkg-private", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:00:55Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -753,22 +757,24 @@ static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSu\n     }\n \n     /**\n-     * Attempts to identify the {@link ContentCoding} from a name, as found in the {@code 'Content-Encoding'} header.\n-     * of a request or a response. If the name can not be matched to any of the supported encodings on this endpoint,\n-     * then a {@link UnsupportedContentEncodingException} is thrown.\n+     * Attempts to identify the {@link StreamingContentCodec} from a name, as found in the {@code 'Content-Encoding'}\n+     * header of a request or a response.\n+     * If the name can not be matched to any of the supported encodings on this endpoint, then\n+     * a {@link UnsupportedContentEncodingException} is thrown.\n      *\n      * @param headers The headers to read the encoding name from\n      * @param allowedEncodings The supported encodings for this endpoint\n-     * @return The {@link ContentCoding} that matches the name.\n+     * @return The {@link StreamingContentCodec} that matches the name.\n      */\n-    public static ContentCoding identifyContentEncodingOrNone(final HttpHeaders headers,\n-                                                              final Set<ContentCoding> allowedEncodings) {\n+    public static StreamingContentCodec identifyContentEncodingOrNone(", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0NDc3MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518444771", "bodyText": "None -> identity", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:04:37Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {\n+            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n         }\n     }\n \n     /**\n      * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link ContentCoding} that satisfies both client and server needs.\n+     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n      */\n-    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n-                                                          final Set<ContentCoding> serverSupportedEncodings) {\n+    public static StreamingContentCodec negotiateAcceptedEncoding(\n+            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n+\n         // Fast path, server has no encodings configured or has only None configured as encoding", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0NDgwMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518444803", "bodyText": "None -> identity", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:04:43Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {\n+            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n         }\n     }\n \n     /**\n      * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link ContentCoding} that satisfies both client and server needs.\n+     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n      */\n-    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n-                                                          final Set<ContentCoding> serverSupportedEncodings) {\n+    public static StreamingContentCodec negotiateAcceptedEncoding(\n+            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n+\n         // Fast path, server has no encodings configured or has only None configured as encoding\n         if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n-            return none();\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n+            return identity();\n         }\n \n-        Set<ContentCoding> clientSupportedEncodings =\n+        List<StreamingContentCodec> clientSupportedEncodings =\n                 readAcceptEncoding(headers, serverSupportedEncodings);\n         return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n     }\n \n-    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n-                                                   final Set<ContentCoding> allowedEncodings) {\n+    static StreamingContentCodec negotiateAcceptedEncoding(final List<StreamingContentCodec> clientSupportedEncodings,\n+                                                           final List<StreamingContentCodec> allowedEncodings) {\n         // Fast path, Client has no encodings configured, or has None as the only encoding configured", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0ODQ5OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518448499", "bodyText": "Note for future improvements: we can improve split to return trimmed CharSequence values instead of doing a toString() conversion and an additional trim here that makes 2 copies of data when a space char is present.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:16:05Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -684,66 +688,66 @@ public static void advertiseAcceptedEncodingsIfAvailable(final HttpHeaders heade\n             builder.append(enc.name());\n         }\n \n-        CharSequence value = newAsciiString(builder.toString());\n-        if (value.length() > 0) {\n-            headers.add(ACCEPT_ENCODING, value);\n+        if (!builder.toString().isEmpty()) {\n+            headers.add(ACCEPT_ENCODING, newAsciiString(builder.toString()));\n         }\n     }\n \n     /**\n      * Establish a commonly accepted encoding between server and client, according to the supported-encodings\n      * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n      * <p>\n-     * If no supported encodings are configured then the result is always {@link ContentCodings#none()}\n-     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#none()}\n-     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#none()}) is preferred.\n+     * If no supported encodings are configured then the result is always {@link ContentCodings#identity()}\n+     * If no accepted encodings are present in the request then the result is always {@link ContentCodings#identity()}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred.\n      *\n      * @param headers The request headers\n      * @param serverSupportedEncodings The supported encodings as configured for the server\n-     * @return The {@link ContentCoding} that satisfies both client and server needs.\n+     * @return The {@link StreamingContentCodec} that satisfies both client and server needs.\n      */\n-    public static ContentCoding negotiateAcceptedEncoding(final HttpHeaders headers,\n-                                                          final Set<ContentCoding> serverSupportedEncodings) {\n+    public static StreamingContentCodec negotiateAcceptedEncoding(\n+            final HttpHeaders headers, final List<StreamingContentCodec> serverSupportedEncodings) {\n+\n         // Fast path, server has no encodings configured or has only None configured as encoding\n         if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(none()))) {\n-            return none();\n+                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n+            return identity();\n         }\n \n-        Set<ContentCoding> clientSupportedEncodings =\n+        List<StreamingContentCodec> clientSupportedEncodings =\n                 readAcceptEncoding(headers, serverSupportedEncodings);\n         return negotiateAcceptedEncoding(clientSupportedEncodings, serverSupportedEncodings);\n     }\n \n-    static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSupportedEncodings,\n-                                                   final Set<ContentCoding> allowedEncodings) {\n+    static StreamingContentCodec negotiateAcceptedEncoding(final List<StreamingContentCodec> clientSupportedEncodings,\n+                                                           final List<StreamingContentCodec> allowedEncodings) {\n         // Fast path, Client has no encodings configured, or has None as the only encoding configured\n         if (clientSupportedEncodings == NONE_CONTENT_ENCODING_SINGLETON ||\n-                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(none()))) {\n-            return none();\n+                (clientSupportedEncodings.size() == 1 && clientSupportedEncodings.contains(identity()))) {\n+            return identity();\n         }\n \n-        for (ContentCoding encoding : allowedEncodings) {\n-            if (encoding != none() && clientSupportedEncodings.contains(encoding)) {\n+        for (StreamingContentCodec encoding : allowedEncodings) {\n+            if (encoding != identity() && clientSupportedEncodings.contains(encoding)) {\n                 return encoding;\n             }\n         }\n \n-        return none();\n+        return identity();\n     }\n \n-    static Set<ContentCoding> readAcceptEncoding(final HttpHeaders headers,\n-                                                 final Set<ContentCoding> allowedEncodings) {\n+    static List<StreamingContentCodec> readAcceptEncoding(final HttpHeaders headers,\n+                                                          final List<StreamingContentCodec> allowedEncodings) {\n         final CharSequence acceptEncodingsHeaderVal = headers.get(ACCEPT_ENCODING);\n \n         if (acceptEncodingsHeaderVal == null || acceptEncodingsHeaderVal.length() == 0) {\n             return NONE_CONTENT_ENCODING_SINGLETON;\n         }\n \n-        Set<ContentCoding> knownEncodings = new HashSet<>();\n+        List<StreamingContentCodec> knownEncodings = new ArrayList<>();\n         List<CharSequence> acceptEncodingValues = split(acceptEncodingsHeaderVal, ',');\n         for (CharSequence val : acceptEncodingValues) {\n-            ContentCoding enc = encodingFor(allowedEncodings, val.toString().trim());\n+            StreamingContentCodec enc = encodingFor(allowedEncodings, val.toString().trim());", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY5MzU0Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518693543", "bodyText": "Yip, split was a fast convenience, I will open an issue to improve it further outside this work.", "author": "tkountis", "createdAt": "2020-11-06T11:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0ODQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI2NjAyMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525266020", "bodyText": "Issue: #1216", "author": "tkountis", "createdAt": "2020-11-17T15:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ0ODQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1MDI5Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518450293", "bodyText": "The toString() is not necessary anymore", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:21:57Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -753,22 +757,24 @@ static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSu\n     }\n \n     /**\n-     * Attempts to identify the {@link ContentCoding} from a name, as found in the {@code 'Content-Encoding'} header.\n-     * of a request or a response. If the name can not be matched to any of the supported encodings on this endpoint,\n-     * then a {@link UnsupportedContentEncodingException} is thrown.\n+     * Attempts to identify the {@link StreamingContentCodec} from a name, as found in the {@code 'Content-Encoding'}\n+     * header of a request or a response.\n+     * If the name can not be matched to any of the supported encodings on this endpoint, then\n+     * a {@link UnsupportedContentEncodingException} is thrown.\n      *\n      * @param headers The headers to read the encoding name from\n      * @param allowedEncodings The supported encodings for this endpoint\n-     * @return The {@link ContentCoding} that matches the name.\n+     * @return The {@link StreamingContentCodec} that matches the name.\n      */\n-    public static ContentCoding identifyContentEncodingOrNone(final HttpHeaders headers,\n-                                                              final Set<ContentCoding> allowedEncodings) {\n+    public static StreamingContentCodec identifyContentEncodingOrNone(\n+            final HttpHeaders headers, final List<StreamingContentCodec> allowedEncodings) {\n+\n         final CharSequence encoding = headers.get(CONTENT_ENCODING);\n         if (encoding == null) {\n-            return none();\n+            return identity();\n         }\n \n-        ContentCoding enc = encodingFor(allowedEncodings, encoding.toString());\n+        StreamingContentCodec enc = encodingFor(allowedEncodings, encoding.toString());", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1MTM1Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518451352", "bodyText": "Is it necessary to do toLowerCase() for the exception message? I think it's better to keep the value as-is.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:25:34Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -753,22 +757,24 @@ static ContentCoding negotiateAcceptedEncoding(final Set<ContentCoding> clientSu\n     }\n \n     /**\n-     * Attempts to identify the {@link ContentCoding} from a name, as found in the {@code 'Content-Encoding'} header.\n-     * of a request or a response. If the name can not be matched to any of the supported encodings on this endpoint,\n-     * then a {@link UnsupportedContentEncodingException} is thrown.\n+     * Attempts to identify the {@link StreamingContentCodec} from a name, as found in the {@code 'Content-Encoding'}\n+     * header of a request or a response.\n+     * If the name can not be matched to any of the supported encodings on this endpoint, then\n+     * a {@link UnsupportedContentEncodingException} is thrown.\n      *\n      * @param headers The headers to read the encoding name from\n      * @param allowedEncodings The supported encodings for this endpoint\n-     * @return The {@link ContentCoding} that matches the name.\n+     * @return The {@link StreamingContentCodec} that matches the name.\n      */\n-    public static ContentCoding identifyContentEncodingOrNone(final HttpHeaders headers,\n-                                                              final Set<ContentCoding> allowedEncodings) {\n+    public static StreamingContentCodec identifyContentEncodingOrNone(\n+            final HttpHeaders headers, final List<StreamingContentCodec> allowedEncodings) {\n+\n         final CharSequence encoding = headers.get(CONTENT_ENCODING);\n         if (encoding == null) {\n-            return none();\n+            return identity();\n         }\n \n-        ContentCoding enc = encodingFor(allowedEncodings, encoding.toString());\n+        StreamingContentCodec enc = encodingFor(allowedEncodings, encoding.toString());\n         if (enc == null) {\n             final String lowercaseEncoding = encoding.toString().toLowerCase();", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1MTg3OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518451879", "bodyText": "The content-coding names are case-insensitive, use contentEqualsIgnoreCase instead.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:27:10Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -15,100 +15,107 @@\n  */\n package io.servicetalk.http.api;\n \n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.DeflateStreamingContentCodecBuilder;\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.GzipStreamingContentCodecBuilder;\n+\n import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Set;\n import javax.annotation.Nullable;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Collections.unmodifiableSet;\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.CharSequences.isEmpty;\n+import static io.servicetalk.http.api.CharSequences.startsWith;\n import static java.util.Objects.requireNonNull;\n \n /**\n- * Default available encoding implementations.\n- * Encoding {@link #none()} is always supported regardless of the client or server settings.\n- *\n- * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n+ * Common available encoding implementations.\n+ * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n  */\n public final class ContentCodings {\n \n-    static final CharSequence GZIP_HEADER = \"gzip\";\n-    static final CharSequence DEFLATE_HEADER = \"deflate\";\n-\n-    private static final ContentCoding NONE =\n-            new DefaultContentCoding(\"identity\", new IdentityContentCodec());\n+    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();\n \n-    private static final ContentCoding GZIP =\n-            new DefaultContentCoding(\"gzip\", new GzipContentCodec());\n+    private static final StreamingContentCodec DEFAULT_GZIP = gzip().build();\n \n-    private static final ContentCoding DEFLATE =\n-            new DefaultContentCoding(\"deflate\", new DeflateContentCodec());\n-\n-    private static final Set<ContentCoding> ALL =\n-            unmodifiableSet(new HashSet<>(asList(NONE, GZIP, DEFLATE)));\n+    private static final StreamingContentCodec DEFAULT_DEFLATE = deflate().build();\n \n     private ContentCodings() {\n     }\n \n     /**\n-     * Returns the default, always supported 'identity' {@link ContentCoding}.\n-     * @return the default, always supported 'identity' {@link ContentCoding}\n+     * Returns the default, always supported 'identity' {@link StreamingContentCodec}.\n+     * @return the default, always supported 'identity' {@link StreamingContentCodec}\n+     */\n+    public static StreamingContentCodec identity() {\n+        return IDENTITY;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n      */\n-    public static ContentCoding none() {\n-        return NONE;\n+    public static StreamingContentCodec gzipDefault() {\n+        return DEFAULT_GZIP;\n     }\n \n     /**\n-     * Returns a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n-     * @return a GZIP based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     * Returns a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     *          a customizable GZIP {@link StreamingContentCodec}\n      */\n-    public static ContentCoding gzip() {\n-        return GZIP;\n+    public static DefaultStreamingContentCodecBuilder gzip() {\n+        return new GzipStreamingContentCodecBuilder();\n     }\n \n     /**\n-     * Returns a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}.\n-     * @return a DEFLATE based {@link ContentCoding} backed by {@link java.util.zip.Inflater}\n+     * Returns a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n      */\n-    public static ContentCoding deflate() {\n-        return DEFLATE;\n+    public static StreamingContentCodec deflateDefault() {\n+        return DEFAULT_DEFLATE;\n     }\n \n     /**\n-     * Returns a list of all {@link ContentCoding}s included by default.\n-     * @return a list of all {@link ContentCoding}s included by default\n+     * Returns a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     *          a customizable DEFLATE {@link StreamingContentCodec}\n      */\n-    public static Set<ContentCoding> all() {\n-        return ALL;\n+    public static DefaultStreamingContentCodecBuilder deflate() {\n+        return new DeflateStreamingContentCodecBuilder();\n     }\n \n     /**\n-     * Returns a {@link ContentCoding} that matches the {@code name}.\n+     * Returns a {@link StreamingContentCodec} that matches the {@code name}.\n      * Returns {@code null} if {@code name} is {@code null} or empty.\n      * If {@code name} is {@code 'identity'} this will always result in\n-     * {@link ContentCodings#NONE} regardless of its presence in the {@code allowedList}.\n+     * {@link ContentCodings#IDENTITY} regardless of its presence in the {@code allowedList}.\n      *\n      * @param allowedList the source list to find a matching encoding in\n      * @param name the encoding name used for the matching predicate\n      * @return an encoding from the allowed-list matching the {@code name},\n      *          otherwise {@code null} if {@code name} is {@code null} or empty\n      */\n     @Nullable\n-    public static ContentCoding encodingFor(final Collection<ContentCoding> allowedList,\n-                                            @Nullable final String name) {\n+    static StreamingContentCodec encodingFor(final Collection<StreamingContentCodec> allowedList,\n+                                             @Nullable final CharSequence name) {\n         requireNonNull(allowedList);\n-        if (name == null || name.isEmpty()) {\n+        if (name == null || isEmpty(name)) {\n             return null;\n         }\n \n         // Identity is always supported, regardless of its presence in the allowed-list\n-        if (name.equalsIgnoreCase(NONE.name())) {\n-            return NONE;\n+        if (contentEquals(name, IDENTITY.name())) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODAxOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518458019", "bodyText": "IIUC the correct name will be: DEcompressed payload", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:47:32Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultStreamingContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+abstract class DefaultStreamingContentCodecBuilder implements StreamingContentCodecBuilder {\n+\n+    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n+\n+    protected int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_COMPRESSED_PAYLOAD;", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518460169", "bodyText": "1. Is it possible to move this filter and all associated HeaderUtils to http-netty module and make it pkg-private?\n 2. If it's not possible to make it pkg-private, it should also implement StreamingHttpConnectionFilterFactory interface.\n 3. The filter should also implement HttpExecutionStrategyInfluencer interface. See any other filters we have as an example.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:54:47Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NTQzMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518485432", "bodyText": "Follow-up on 1: hm... it's nice that HttpServerBuilder has a protected hook. Consider adding something similar for SingleAddressHttpClientBuilder. Some method that may apply filters maybe?\n//cc @Scottmitch wdyt?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NjA0Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518486047", "bodyText": "Follow-up on 2: actually, I think it should be StreamingHttpConnectionFilterFactory only. Otherwise, if users will reserve a connection, they will lose compression/decompression.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwNTQwNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518805405", "bodyText": "Thanks for the feedback here, I implemented the interfaces. Regarding the attempt to move the logic in Netty pkg, what's the goal? Is that only an attempt to limit visibility, if so I can fix it with a hook (as you commented). I personally prefer to keep the logic under api, its not Netty specific.", "author": "tkountis", "createdAt": "2020-11-06T14:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgwNzI3Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518807272", "bodyText": "On a second read, I think we are saying the same thing. Let me know if I misunderstood.", "author": "tkountis", "createdAt": "2020-11-06T15:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5MTUxNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518991515", "bodyText": "Agreed, also prefer to keep it in http-api module. Was just thinking about how can we make this filter non-public.\nLet's finish the discussion about filter ordering [1] and then decide if we will keep it public or make a hook for the builder.\n\n#1174 (comment)", "author": "idelpivnitskiy", "createdAt": "2020-11-06T20:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2MDE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ2Mzg1NQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518463855", "bodyText": "Consider using set method instead of add for cases when this method invoked multiple times for the request object, we should not add multiple header entries.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T01:07:21Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -245,6 +244,10 @@ static void addContentEncoding(final HttpHeaders headers, CharSequence encoding)\n         headers.add(VARY, CONTENT_ENCODING);", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ3MDMxMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518470312", "bodyText": "Not necessary to add javadoc for overriden methods.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T01:28:53Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java", "diffHunk": "@@ -141,6 +141,17 @@\n         return appendClientFilter(toConditionalClientFilterFactory(predicate, factory));\n     }\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ3ODYyOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518478629", "bodyText": "MultiAddressHttpClientBuilder misses this override", "author": "idelpivnitskiy", "createdAt": "2020-11-06T01:57:07Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpClientBuilder.java", "diffHunk": "@@ -141,6 +141,17 @@\n         return appendClientFilter(toConditionalClientFilterFactory(predicate, factory));\n     }\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint.\n+     * The list will be advertised as part of the Accept-Encoding header\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n+     * @return {@code this}\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    @Override\n+    public abstract HttpClientBuilder<U, R, SDE> supportedEncodings(StreamingContentCodec... codings);", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ3OTM5MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518479391", "bodyText": "The filter should also implement HttpExecutionStrategyInfluencer interface. See any other filters we have as an example.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T01:59:23Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ3OTkxNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518479915", "bodyText": "nit: shifted indentation", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:01:03Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {\n+\n+    private final List<StreamingContentCodec> requestCodings;\n+    private final List<StreamingContentCodec> responseCodings;\n+\n+    ContentCodingHttpServiceFilter(final List<StreamingContentCodec> requestCodings,\n+                                          final List<StreamingContentCodec> responseCodings) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4MDkzNg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518480936", "bodyText": "Not necessary to apply transform operations when we deal with identity().", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:04:24Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {\n+\n+    private final List<StreamingContentCodec> requestCodings;\n+    private final List<StreamingContentCodec> responseCodings;\n+\n+    ContentCodingHttpServiceFilter(final List<StreamingContentCodec> requestCodings,\n+                                          final List<StreamingContentCodec> responseCodings) {\n+        this.requestCodings = requestCodings;\n+        this.responseCodings = responseCodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+        return new StreamingHttpServiceFilter(service) {\n+            @Override\n+            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                        final StreamingHttpRequest request,\n+                                                        final StreamingHttpResponseFactory responseFactory) {\n+\n+                BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n+                StreamingContentCodec coding = identifyContentEncodingOrNone(request.headers(), requestCodings);\n+                request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4MTg4MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518481880", "bodyText": "coding != null and it's not identity", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:07:58Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n+                encodePayloadContentIfAvailable(request, alloc);\n+\n+                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n+            }\n+        };\n+    }\n+\n+    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {\n+        StreamingContentCodec coding = request.encoding();\n+        if (coding != null) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4MjkyMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518482922", "bodyText": "Store the result of response.encoding() in a local variable and then you can remove @Nullable.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:11:48Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpServiceFilter implements StreamingHttpServiceFilterFactory {\n+\n+    private final List<StreamingContentCodec> requestCodings;\n+    private final List<StreamingContentCodec> responseCodings;\n+\n+    ContentCodingHttpServiceFilter(final List<StreamingContentCodec> requestCodings,\n+                                          final List<StreamingContentCodec> responseCodings) {\n+        this.requestCodings = requestCodings;\n+        this.responseCodings = responseCodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+        return new StreamingHttpServiceFilter(service) {\n+            @Override\n+            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                        final StreamingHttpRequest request,\n+                                                        final StreamingHttpResponseFactory responseFactory) {\n+\n+                BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n+                StreamingContentCodec coding = identifyContentEncodingOrNone(request.headers(), requestCodings);\n+                request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n+\n+                return super.handle(ctx, request, responseFactory).map(response -> {\n+                    encodePayloadContentIfAvailable(request.headers(), responseCodings, response, allocator);\n+                    return response;\n+                });\n+            }\n+        };\n+    }\n+\n+    private static void encodePayloadContentIfAvailable(final HttpHeaders requestHeaders,\n+                                                        final List<StreamingContentCodec> supportedEncodings,\n+                                                        final StreamingHttpResponse response,\n+                                                        final BufferAllocator allocator) {\n+        if (supportedEncodings.isEmpty() || hasContentEncoding(response.headers())) {\n+            return;\n+        }\n+\n+        StreamingContentCodec coding = codingForResponse(requestHeaders, response, supportedEncodings);\n+        if (coding != null && !coding.equals(identity())) {\n+            addContentEncoding(response.headers(), coding.name());\n+            response.transformPayloadBody(bufferPublisher -> coding.encode(bufferPublisher, allocator));\n+        }\n+    }\n+\n+    @Nullable\n+    private static StreamingContentCodec codingForResponse(final HttpHeaders requestHeaders,\n+                                                           final StreamingHttpResponse response,\n+                                                           final List<StreamingContentCodec> supportedEncodings) {\n+        if (response.encoding() != null) {\n+            // Enforced selection\n+            return response.encoding();", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMjI4Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518722283", "bodyText": "didn't get that.", "author": "tkountis", "createdAt": "2020-11-06T12:32:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4MjkyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNzk5Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519007996", "bodyText": "This way method does not need @Nullable annotation:\n        final StreamingContentCodec encoding = response.encoding();\n        if (encoding != null) {\n            // Enforced selection\n            return encoding;\n        }", "author": "idelpivnitskiy", "createdAt": "2020-11-06T21:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4MjkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NzA1MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518487051", "bodyText": "Suggested rename: supportedEncodings -> supportedResponseEncodings", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:26:49Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java", "diffHunk": "@@ -132,6 +138,31 @@\n      */\n     public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n+     * @return {@code this}\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {\n+        List<StreamingContentCodec> unmodifiable = unmodifiableList(asList(codings));\n+        this.requestCodings = unmodifiable;\n+        this.responseCodings = unmodifiable;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for <b>responses only</b>.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for the responses of this endpoint.\n+     * @return {@code this}\n+     */\n+    public final HttpServerBuilder supportedEncodings(final StreamingContentCodec... codings) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NzEwNg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518487106", "bodyText": "Suggested rename: supportedEncodingsBiDi -> supportedEncodings", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:27:01Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java", "diffHunk": "@@ -132,6 +138,31 @@\n      */\n     public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n+     * @return {@code this}\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NzI0Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518487243", "bodyText": "endpoint -> server?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:27:32Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java", "diffHunk": "@@ -132,6 +138,31 @@\n      */\n     public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n+     * @return {@code this}\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n+     */\n+    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {\n+        List<StreamingContentCodec> unmodifiable = unmodifiableList(asList(codings));\n+        this.requestCodings = unmodifiable;\n+        this.responseCodings = unmodifiable;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for <b>responses only</b>.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for the responses of this endpoint.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4NzMzMQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518487331", "bodyText": "endpoint -> server?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:27:53Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java", "diffHunk": "@@ -132,6 +138,31 @@\n      */\n     public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n+    /**\n+     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n+     *\n+     * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4ODY4Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518488687", "bodyText": "Let's make this interface pkg-private for now?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:32:55Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+/**\n+ * Builder for {@link StreamingContentCodec}s.\n+ */\n+public interface StreamingContentCodecBuilder extends ContentCodecBuilder {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMzc2MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518723760", "bodyText": "Needed for gRPC, depending of course the outcome of the discussion around removing it completely.", "author": "tkountis", "createdAt": "2020-11-06T12:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4ODY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTI0Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518489247", "bodyText": "This method is invoked when the server reads a request. At that point we never have encoding. Therefore, we do not need it here.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:34:58Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/StreamingHttpRequests.java", "diffHunk": "@@ -70,7 +70,7 @@ public static StreamingHttpRequest newRequest(\n      */\n     public static StreamingHttpRequest newTransportRequest(\n             final HttpRequestMethod method, final String requestTarget, final HttpProtocolVersion version,\n-            final HttpHeaders headers, @Nullable final ContentCoding encoding, final BufferAllocator allocator,\n+            final HttpHeaders headers, @Nullable final StreamingContentCodec encoding, final BufferAllocator allocator,", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyNTQ2OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518725469", "bodyText": "Leftover", "author": "tkountis", "createdAt": "2020-11-06T12:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTc2Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518489762", "bodyText": "Can this be removed now?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:36:50Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java", "diffHunk": "@@ -393,12 +397,18 @@ private StreamingHttpResponse newErrorResponse(final Throwable cause, final Exec\n                 LOGGER.error(\"Task rejected by Executor {} for service={}, connection={}\", executor, service, this,\n                         cause);\n                 response = streamingResponseFactory().serviceUnavailable();\n+            } else if (cause instanceof UnsupportedContentEncodingException) {\n+                LOGGER.error(\"Task rejected by Executor {} for service={}, connection={}\", executor, service, this,\n+                        cause);\n+                // see https://tools.ietf.org/html/rfc7231#section-3.1.2.2\n+                response = streamingResponseFactory().unsupportedMediaType();\n             } else {\n                 LOGGER.error(\"Internal server error service={} connection={}\", service, this, cause);\n                 response = streamingResponseFactory().internalServerError();\n             }\n             response.version(version)\n                     .setHeader(CONTENT_LENGTH, ZERO);\n+            // advertiseAcceptedEncodingsIfAvailable(response.headers(), supportedEncodings);", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ4OTk0MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518489941", "bodyText": "The ContentCodingHttpServiceFilter is the first filter in the chain. Let's handle this exception there for now? It will give us some time to understand how people use compression codecs without prematurely making the exception type public.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:37:28Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java", "diffHunk": "@@ -393,12 +397,18 @@ private StreamingHttpResponse newErrorResponse(final Throwable cause, final Exec\n                 LOGGER.error(\"Task rejected by Executor {} for service={}, connection={}\", executor, service, this,\n                         cause);\n                 response = streamingResponseFactory().serviceUnavailable();\n+            } else if (cause instanceof UnsupportedContentEncodingException) {\n+                LOGGER.error(\"Task rejected by Executor {} for service={}, connection={}\", executor, service, this,", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5Mjc3MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518492771", "bodyText": "1. Let's make it pkg-private for now?\n 2. Please, add serialVersionUID.\n 3. Let's remove unused ctors until we make it public?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:48:13Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/UnsupportedContentEncodingException.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+/**\n+ * Exception thrown when a payload was encoded with an unsupported encoder.\n+ */\n+public final class UnsupportedContentEncodingException extends RuntimeException {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5MzcxMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518493713", "bodyText": "This change can be reverted now", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:51:26Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java", "diffHunk": "@@ -165,7 +167,8 @@ private NettyHttpServer() {\n                 initializer.andThen(getChannelInitializer(getByteBufAllocator(httpExecutionContext.bufferAllocator()),\n                         h1Config, closeHandler)), httpExecutionContext.executionStrategy(), HTTP_1_1, observer, false)\n                 .map(conn -> new NettyHttpServerConnection(conn, service, httpExecutionContext.executionStrategy(),\n-                        h1Config.headersFactory(), drainRequestPayloadBody)), HTTP_1_1, channel);\n+                        h1Config.headersFactory(), drainRequestPayloadBody)),\n+                        HTTP_1_1, channel);", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5Mzg1Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518493853", "bodyText": "The whole change here can be reverted if we remove encoding param from newTransportRequest", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:51:59Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/NettyHttpServer.java", "diffHunk": "@@ -269,10 +272,11 @@ public String toString() {\n         void process(final boolean handleMultipleRequests) {\n             final Single<StreamingHttpRequest> requestSingle =\n                     connection.read().liftSyncToSingle(new SpliceFlatStreamToMetaSingle<>(\n-                            (HttpRequestMetaData meta, Publisher<Object> payload) ->\n-                                    newTransportRequest(meta.method(), meta.requestTarget(), meta.version(),\n-                                            meta.headers(), executionContext().bufferAllocator(), payload,\n-                                            headersFactory)));\n+                            (BiFunction<HttpRequestMetaData, Publisher<Object>, StreamingHttpRequest>) (meta, payload)\n+                                    -> newTransportRequest(meta.method(), meta.requestTarget(), meta.version(),\n+                                        meta.headers(), meta.encoding(),", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NTQ2MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518495461", "bodyText": "Why this change is required? Do you have a reproducer? Trailers should already be added.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:57:47Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java", "diffHunk": "@@ -185,7 +186,9 @@ private static void updateResponseContentLength(final int contentLength, final H\n                 for (int i = 0; i < items.size(); i++) {\n                     contentLength += calculateContentLength(items.get(i));\n                 }\n-                flatRequest = Publisher.<Object>from(metadata).concat(fromIterable(items));\n+                flatRequest = Publisher.<Object>from(metadata)\n+                        .concat(fromIterable(items))\n+                        .concat(succeeded(EmptyHttpHeaders.INSTANCE));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQyNjcwMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r521426700", "bodyText": "Removed. The actual reason this was hanging was the attempt to calculate content length on non-streaming requests. A check for content-encoding was missing to skip this length-calculation and use chunking, thus this logic was anticipating a single buffer and not multiple chunks.", "author": "tkountis", "createdAt": "2020-11-11T15:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NTQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NTkzMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518495930", "bodyText": "Please, revert the original version if there are no changes", "author": "idelpivnitskiy", "createdAt": "2020-11-06T02:59:29Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ClientParentConnectionContext.java", "diffHunk": "@@ -291,7 +291,8 @@ private void childChannelActive(Future<Http2StreamChannel> future,\n                     // pipelining on a stream so we can use the non-pipelined connection which is more light weight.\n                     // https://tools.ietf.org/html/rfc7540#section-8.1\n                     responseSingle = toSource(new NonPipelinedStreamingHttpConnection(nettyConnection,\n-                            executionContext(), reqRespFactory, headersFactory).request(strategy, request));\n+                            executionContext(), reqRespFactory, headersFactory)\n+                                .request(strategy, request));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NjI1NQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518496255", "bodyText": "Please, revert the original version if there are no changes", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:00:47Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractStreamingHttpConnection.java", "diffHunk": "@@ -111,8 +111,8 @@ public final HttpConnectionContext connectionContext() {\n             addRequestTransferEncodingIfNecessary(request);\n         }\n \n-        return strategy.invokeClient(executionContext.executor(), flatRequest, determineFlushStrategyForApi(request),\n-                this);\n+        return strategy.invokeClient(executionContext.executor(), flatRequest,\n+                determineFlushStrategyForApi(request), this);", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NzU1Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518497553", "bodyText": "HttpMetaData does not know how the payload body is represented. Consider removing reference to Buffer", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:05:45Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java", "diffHunk": "@@ -46,6 +47,33 @@\n      */\n     HttpHeaders headers();\n \n+    /**\n+     * The {@link StreamingContentCodec} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a\n+     * request or a response.\n+     * If the endpoint is setup with {@link HttpServerBuilder#supportedEncodings(StreamingContentCodec...)} ()}\n+     * or {@link HttpClientBuilder#supportedEncodings(StreamingContentCodec...)}, the server will\n+     * auto-establish the accepted encoding for the response, unless the caller provides a specific encoding\n+     * calling this method.\n+     *\n+     * Any encoding passed here, takes precedence. In other words, a compressed response, can\n+     * be disabled by passing {@link ContentCodings#identity()}.\n+     *\n+     * @param encoding The {@link StreamingContentCodec} used for the encoding of the payload.\n+     * @return {@code this}.\n+     * @see <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>\n+     */\n+    HttpMetaData encoding(StreamingContentCodec encoding);\n+\n+    /**\n+     * Returns the {@link StreamingContentCodec} used to encode the payload\n+     * {@link io.servicetalk.buffer.api.Buffer} of a request or a response.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyODk4OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518728988", "bodyText": "Good catch", "author": "tkountis", "createdAt": "2020-11-06T12:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NzU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5NzgxNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518497814", "bodyText": "HttpMetaData does not know how the payload body is represented. Consider removing reference to Buffer", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:06:54Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpMetaData.java", "diffHunk": "@@ -46,6 +47,33 @@\n      */\n     HttpHeaders headers();\n \n+    /**\n+     * The {@link StreamingContentCodec} used to encode the payload {@link io.servicetalk.buffer.api.Buffer} of a", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5OTA4Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518499082", "bodyText": "These public methods returns a pkg-private class. Let's remove them for now?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:11:41Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.DeflateStreamingContentCodecBuilder;\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.GzipStreamingContentCodecBuilder;\n+\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.CharSequences.isEmpty;\n+import static io.servicetalk.http.api.CharSequences.startsWith;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Common available encoding implementations.\n+ * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n+ */\n+public final class ContentCodings {\n+\n+    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();\n+\n+    private static final StreamingContentCodec DEFAULT_GZIP = gzip().build();\n+\n+    private static final StreamingContentCodec DEFAULT_DEFLATE = deflate().build();\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link StreamingContentCodec}.\n+     * @return the default, always supported 'identity' {@link StreamingContentCodec}\n+     */\n+    public static StreamingContentCodec identity() {\n+        return IDENTITY;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static StreamingContentCodec gzipDefault() {\n+        return DEFAULT_GZIP;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a GZIP based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     *          a customizable GZIP {@link StreamingContentCodec}\n+     */\n+    public static DefaultStreamingContentCodecBuilder gzip() {\n+        return new GzipStreamingContentCodecBuilder();\n+    }\n+\n+    /**\n+     * Returns a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a DEFLATE based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static StreamingContentCodec deflateDefault() {\n+        return DEFAULT_DEFLATE;\n+    }\n+\n+    /**\n+     * Returns a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     * a customizable {@link StreamingContentCodec}.\n+     * @return a DEFLATE based {@link DefaultStreamingContentCodecBuilder} that allows building\n+     *          a customizable DEFLATE {@link StreamingContentCodec}\n+     */\n+    public static DefaultStreamingContentCodecBuilder deflate() {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczMDY2Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518730667", "bodyText": "How is the builder accessible then?\nI am changing the signature to use the interface for now, waiting on your thoughts.", "author": "tkountis", "createdAt": "2020-11-06T12:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ5OTA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwMDIwNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518500205", "bodyText": "Consider making IdentityContentCodec class a singleton", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:16:23Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.DeflateStreamingContentCodecBuilder;\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.GzipStreamingContentCodecBuilder;\n+\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.api.CharSequences.contentEquals;\n+import static io.servicetalk.http.api.CharSequences.isEmpty;\n+import static io.servicetalk.http.api.CharSequences.startsWith;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Common available encoding implementations.\n+ * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n+ */\n+public final class ContentCodings {\n+\n+    private static final StreamingContentCodec IDENTITY = new IdentityContentCodec();", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwMjI4NQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518502285", "bodyText": "nit: unnecessary parentheses around", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:25:34Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n+                encodePayloadContentIfAvailable(request, alloc);\n+\n+                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n+            }\n+        };\n+    }\n+\n+    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {\n+        StreamingContentCodec coding = request.encoding();\n+        if (coding != null) {\n+            addContentEncoding(request.headers(), coding.name());\n+            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n+        }\n+    }\n+\n+    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n+            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n+\n+        return responseSingle.map((response -> {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwMjM0MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518502340", "bodyText": "This method can be static", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:25:47Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n+                encodePayloadContentIfAvailable(request, alloc);\n+\n+                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n+            }\n+        };\n+    }\n+\n+    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNDcxMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518504713", "bodyText": "Discussion, no action needed for now:\nI see that AHC removes Content-Length and Content-Encoding headers from the response after decompression: https://github.com/apache/httpcomponents-client/blob/23af28ddaf49544ab8a7996f1a8bb508f6441828/httpclient/src/main/java/org/apache/http/client/protocol/ResponseContentEncoding.java#L124-L125\nIt has its pros and cons... Cons is that users loose visibility into original headers that were received. Pros is that they do not need to manually remove these headers when they pass through the response from the client as a server's response (proxy use-case). Thoughts?\n//cc @Scottmitch", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:35:41Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    public ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n+                encodePayloadContentIfAvailable(request, alloc);\n+\n+                return decodePayloadContentIfEncoded(super.request(delegate, strategy, request), alloc);\n+            }\n+        };\n+    }\n+\n+    private void encodePayloadContentIfAvailable(final StreamingHttpRequest request, final BufferAllocator allocator) {\n+        StreamingContentCodec coding = request.encoding();\n+        if (coding != null) {\n+            addContentEncoding(request.headers(), coding.name());\n+            request.transformPayloadBody(pub -> coding.encode(pub, allocator));\n+        }\n+    }\n+\n+    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n+            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n+\n+        return responseSingle.map((response -> {\n+            StreamingContentCodec coding = identifyContentEncodingOrNone(response.headers(), supportedEncodings);\n+            if (!coding.equals(identity())) {\n+                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNDQxOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518734418", "bodyText": "Hmm, need to think about that, don't have any immediate observation.", "author": "tkountis", "createdAt": "2020-11-06T12:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNDk1Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518504952", "bodyText": "It's too small for the avg payload. Let's set it to 16MiB", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:36:45Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+interface ContentCodecBuilder {\n+\n+    int DEFAULT_MAX_ALLOWED_COMPRESSED_PAYLOAD = 2 << 20; //2MiB", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNTE2NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518505164", "bodyText": "IIUC this is related to the uncompressed payload size. Bcz it's possible to generate a bomb that has tiny size but results in gigabytes.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:37:42Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+interface ContentCodecBuilder {\n+\n+    int DEFAULT_MAX_ALLOWED_COMPRESSED_PAYLOAD = 2 << 20; //2MiB\n+\n+    /**\n+     * Sets the maximum allowed compressed payload size that the codec can process.", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNTMwOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518735308", "bodyText": "yes, its the actual payload. will re-phrase it.", "author": "tkountis", "createdAt": "2020-11-06T12:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNTE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNTkwMg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518505902", "bodyText": "This method is used only in one pkg-private place. Consider removing the public method.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:40:57Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java", "diffHunk": "@@ -162,6 +162,15 @@ public static boolean contentEquals(final CharSequence a, final CharSequence b)\n         return contentEqualsUnknownTypes(a, b);\n     }\n \n+    /**\n+     * Returns {@code true} if there is no content on the {@link CharSequence} value.\n+     * @param value the {@link CharSequence} to validate for emptyness\n+     * @return {@code true} if there is no content\n+     */\n+    public static boolean isEmpty(final CharSequence value) {\n+        return value.length() == 0;", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODczNjU3Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518736572", "bodyText": "gRPC needed", "author": "tkountis", "createdAt": "2020-11-06T13:01:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNTkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwODM2NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519008364", "bodyText": "It's a trivial check, better to reduce the surface of public API we expose.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T21:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwNzI2OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518507269", "bodyText": "Consider clarifying in the method name and javadoc that it checks the prefix case-insensitively.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:47:02Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java", "diffHunk": "@@ -216,6 +225,19 @@ private static boolean isUpperCase(final char value) {\n         return value >= 'A' && value <= 'Z';\n     }\n \n+    /**\n+     * Tests if the string starts with the specified prefix.\n+     *\n+     * @param   string   the value to check the presence of the prefix in.\n+     * @param   prefix   the prefix.\n+     * @return  {@code true} if the character sequence represented by the\n+     *          argument is a prefix of the character sequence represented by\n+     *          the string; {@code false} otherwise.\n+     */\n+    public static boolean startsWith(final CharSequence string, final CharSequence prefix) {", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwOTc3NQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518509775", "bodyText": "Consider allocating an Buffer of size and maxCapacity 0. This way you do not need a map operation to convert Buffer to Object.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T03:58:03Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,558 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements StreamingContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc0NTk0MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518745940", "bodyText": "I considered it, but none of the Buffer implementations are available without an allocator.\nI can complicate the API to have an allocator in the instance allowing me to do so, OR I can have my own no-op buffer class to use there. If I am missing something let me know.", "author": "tkountis", "createdAt": "2020-11-06T13:20:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwOTc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwODY3Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519008673", "bodyText": "Let's keep it as-is, not worth spending cycles on improving if we are going to replace it.\nJust FYI: you can use the static one for this purpose: ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR. We do this in other places where we need Buffer constants. Take a look at HttpProtocolVersion as an example.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T21:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUwOTc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMTQ5MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518511491", "bodyText": "The problem with readSlice here is that we keep writing new data to the original dst buffer. As the result, it will be resized multiple times and will allocate all the streaming data in memory \ud83d\ude22", "author": "idelpivnitskiy", "createdAt": "2020-11-06T04:04:53Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,558 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements StreamingContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final int chunkSize, final int maxPayloadSize) {\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[min(src.readableBytes(), chunkSize)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        return from\n+                .map((it) -> (Object) it)\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Object>() {\n+\n+                    @Nullable\n+                    Buffer dst;\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            dst = allocator.newBuffer(chunkSize);\n+                            output = newDeflaterOutputStream(asOutputStream(dst));\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        subscriber.onSubscribe(subscription);\n+                    }\n+\n+                    @Override\n+                    public void onNext(Object next) {\n+                        assert output != null;\n+                        assert dst != null;\n+\n+                        // onNext will produce AT-MOST N items (as received)\n+                        // +1 for the encoding footer (ie. END_OF_STREAM)\n+                        try {\n+                            if (next == END_OF_STREAM) {\n+                                try {\n+                                    output.finish();\n+                                    subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                                return;\n+                            }\n+\n+                            Buffer src = (Buffer) next;\n+                            if (src.hasArray()) {\n+                                output.write(src.array(), src.readerIndex(), src.readableBytes());\n+                            } else {\n+                                while (src.readableBytes() > 0) {\n+                                    byte[] onHeap = new byte[min(src.readableBytes(), chunkSize)];\n+                                    src.readBytes(onHeap);\n+                                    output.write(onHeap);\n+                                }\n+                            }\n+\n+                            output.flush();\n+                            subscriber.onNext(dst.readSlice(dst.readableBytes()));", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc0OTc2Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518749762", "bodyText": "Good catch, lets keep this out of the scope, since we are discussing about the alternative implementation with EmbeddedChannel. I will keep track of that.", "author": "tkountis", "createdAt": "2020-11-06T13:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMTQ5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwODg2Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519008867", "bodyText": "Agreed that it's not worth spending cycles on fixing implementation that is going to be replaced soon. But this is an important aspect to consider before making a decision to include these implementations in the next release. Or we should clarify in the release notes that compression should not be used with streaming clients for now.\n//cc @Scottmitch", "author": "idelpivnitskiy", "createdAt": "2020-11-06T21:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMTQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMjQ0Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518512442", "bodyText": "I suspect there is a similar issue with decompressed destination buffer.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T04:09:21Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,558 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/*\n+ * Copyright 2013 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.Buffer.asInputStream;\n+import static io.servicetalk.buffer.api.Buffer.asOutputStream;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.lang.Math.min;\n+\n+abstract class AbstractZipContentCodec implements StreamingContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Object END_OF_STREAM = new Object();\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final int chunkSize, final int maxPayloadSize) {\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[min(src.readableBytes(), chunkSize)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        return from\n+                .map((it) -> (Object) it)\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Object>() {\n+\n+                    @Nullable\n+                    Buffer dst;\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            dst = allocator.newBuffer(chunkSize);\n+                            output = newDeflaterOutputStream(asOutputStream(dst));\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        subscriber.onSubscribe(subscription);\n+                    }\n+\n+                    @Override\n+                    public void onNext(Object next) {\n+                        assert output != null;\n+                        assert dst != null;\n+\n+                        // onNext will produce AT-MOST N items (as received)\n+                        // +1 for the encoding footer (ie. END_OF_STREAM)\n+                        try {\n+                            if (next == END_OF_STREAM) {\n+                                try {\n+                                    output.finish();\n+                                    subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                                return;\n+                            }\n+\n+                            Buffer src = (Buffer) next;\n+                            if (src.hasArray()) {\n+                                output.write(src.array(), src.readerIndex(), src.readableBytes());\n+                            } else {\n+                                while (src.readableBytes() > 0) {\n+                                    byte[] onHeap = new byte[min(src.readableBytes(), chunkSize)];\n+                                    src.readBytes(onHeap);\n+                                    output.write(onHeap);\n+                                }\n+                            }\n+\n+                            output.flush();\n+                            subscriber.onNext(dst.readSlice(dst.readableBytes()));\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable t) {\n+                        closeQuietly(output);\n+                        subscriber.onError(t);\n+                    }\n+\n+                    @Override\n+                    public void onComplete() {\n+                        closeQuietly(output);\n+                        subscriber.onComplete();\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public final Buffer decode(final Buffer src, final int offset, final int length, final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize, maxPayloadSize);\n+        InflaterInputStream input = null;\n+        try {\n+            input = newInflaterInputStream(asInputStream(src));\n+\n+            int read = dst.setBytesUntilEndStream(0, input, chunkSize);\n+            dst.writerIndex(read);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(input);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> decode(final Publisher<Buffer> from, final BufferAllocator allocator) {\n+        return from.liftSync(subscriber -> new PublisherSource.Subscriber<Buffer>() {\n+\n+            @Nullable\n+            Buffer dst;\n+            @Nullable\n+            Inflater inflater;\n+            @Nullable\n+            ZLibStreamDecoder streamDecoder;\n+            @Nullable\n+            PublisherSource.Subscription subscription;\n+\n+            @Override\n+            public void onSubscribe(final PublisherSource.Subscription subscription) {\n+                dst = allocator.newBuffer(chunkSize, maxPayloadSize);\n+                inflater = newRawInflater();\n+                streamDecoder = new ZLibStreamDecoder(dst, inflater, chunkSize, supportsChecksum());\n+                this.subscription = subscription;\n+                subscriber.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final Buffer src) {\n+                assert streamDecoder != null;\n+                assert subscription != null;\n+                assert src != null;\n+\n+                // onNext will produce AT-MOST N items (as received)\n+\n+                Buffer part;\n+                try {\n+                    if (streamDecoder.isFinished()) {\n+                        throw new IllegalStateException(\"Stream encoder previously closed but more input arrived \");\n+                    }\n+\n+                    part = streamDecoder.decode(src);\n+                    if (part != null) {\n+                        subscriber.onNext(part);\n+                    }\n+\n+                    // Not enough data to decompress, ask for more\n+                    subscription.request(1);\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            @Override\n+            public void onError(final Throwable t) {\n+                assert inflater != null;\n+\n+                inflater.end();\n+                subscriber.onError(t);\n+            }\n+\n+            @Override\n+            public void onComplete() {\n+                assert inflater != null;\n+\n+                inflater.end();\n+                subscriber.onComplete();\n+            }\n+        });\n+    }\n+\n+    private void closeQuietly(@Nullable final Closeable closeable) {\n+        try {\n+            if (closeable != null) {\n+                closeable.close();\n+            }\n+        } catch (IOException e) {\n+            LOGGER.error(\"Unexpected IO exception while closing buffer streams\", e);\n+        }\n+    }\n+\n+    // Code forked from Netty's JdkZlibDecoder\n+    static class ZLibStreamDecoder {\n+        private static final int FHCRC = 0x02;\n+        private static final int FEXTRA = 0x04;\n+        private static final int FNAME = 0x08;\n+        private static final int FCOMMENT = 0x10;\n+        private static final int FRESERVED = 0xE0;\n+\n+        @Nullable\n+        private final CRC32 crc;\n+        private final Inflater inflater;\n+        private final Buffer decompressed;\n+\n+        private enum State {\n+            HEADER_START,\n+            HEADER_END,\n+            FLG_READ,\n+            XLEN_READ,\n+            SKIP_FNAME,\n+            SKIP_COMMENT,\n+            PROCESS_FHCRC,\n+            FOOTER_START,\n+        }\n+\n+        private State state = State.HEADER_START;\n+        private int flags = -1;\n+        private int xlen = -1;\n+\n+        private int chunkSize;\n+        private boolean finished;\n+\n+        ZLibStreamDecoder(Buffer destination, Inflater inflater, int chunkSize, boolean supportsChksum) {\n+            this.decompressed = destination;\n+            this.inflater = inflater;\n+            this.chunkSize = chunkSize;\n+            crc = supportsChksum ? new CRC32() : null;\n+        }\n+\n+        public boolean isFinished() {\n+            return finished;\n+        }\n+\n+        @Nullable\n+        protected Buffer decode(Buffer in) throws Exception {\n+            if (finished) {\n+                // Skip data received after finished.\n+                in.skipBytes(in.readableBytes());\n+                return null;\n+            }\n+\n+            int readableBytes = in.readableBytes();\n+            if (readableBytes == 0) {\n+                return null;\n+            }\n+\n+            if (crc != null) {\n+                switch (state) {\n+                    case FOOTER_START:\n+                        if (readGZIPFooter(in)) {\n+                            finished = true;\n+                        }\n+                        return null;\n+                    default:\n+                        if (state != State.HEADER_END && !readGZIPHeader(in)) {\n+                            return null;\n+                        }\n+                }\n+                // Some bytes may have been consumed, and so we must re-set the number of readable bytes.\n+                readableBytes = in.readableBytes();\n+            }\n+\n+            if (in.hasArray()) {\n+                inflater.setInput(in.array(), in.arrayOffset() + in.readerIndex(), readableBytes);\n+            } else {\n+                byte[] array = new byte[readableBytes];\n+                in.getBytes(in.readerIndex(), array);\n+                inflater.setInput(array);\n+            }\n+\n+            try {\n+                boolean readFooter = false;\n+                while (!inflater.needsInput()) {\n+                    byte[] outArray = decompressed.array();\n+                    int writerIndex = decompressed.writerIndex();\n+                    int outIndex = decompressed.arrayOffset() + writerIndex;\n+                    int outputLength = inflater.inflate(outArray, outIndex, decompressed.writableBytes());\n+                    if (outputLength > 0) {\n+                        decompressed.writerIndex(writerIndex + outputLength);\n+                        if (crc != null) {\n+                            crc.update(outArray, outIndex, outputLength);\n+                        }\n+                    } else {\n+                        if (inflater.needsDictionary()) {\n+                            throw new IOException(\n+                                    \"decompression failure, unable to set dictionary as non was specified\");\n+                        }\n+                    }\n+\n+                    if (inflater.finished()) {\n+                        if (crc == null) {\n+                            finished = true; // Do not decode anymore.\n+                        } else {\n+                            readFooter = true;\n+                        }\n+                        break;\n+                    } else {\n+                        decompressed.ensureWritable(chunkSize);\n+                    }\n+                }\n+\n+                in.skipBytes(readableBytes - inflater.getRemaining());\n+\n+                if (readFooter) {\n+                    state = State.FOOTER_START;\n+                    if (readGZIPFooter(in)) {\n+                        finished = true;\n+                        inflater.end();\n+                    }\n+                }\n+            } catch (DataFormatException e) {\n+                throw new IOException(\"decompression failure\", e);\n+            }\n+\n+            if (decompressed.readableBytes() > 0) {\n+                return decompressed.readSlice(decompressed.readableBytes());", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc0OTgzNg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518749836", "bodyText": "Same", "author": "tkountis", "createdAt": "2020-11-06T13:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMjQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMzg1NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518513854", "bodyText": "Can you please clarify why this filter has to be the last filter for the client (and the first for the server)?\nI worry that if we do decompression first, users have to way to intercept the original payload body size and metrics filters will show only decompressed size.\nWe may think about an alternative approach for metrics if this is a strong requirement. Otherwise, it's better to expose just a filter and let users configure it in the required order.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T04:15:17Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultSingleAddressHttpClientBuilder.java", "diffHunk": "@@ -308,6 +316,11 @@ public StreamingHttpClient buildStreaming() {\n                         ctx.builder.hostHeaderFilterFactoryFunction.apply(ctx.builder.address));\n             }\n \n+            if (ctx.builder.supportedEncodings != null) {\n+                currClientFilterFactory = appendFilter(currClientFilterFactory,", "originalCommit": "e91b9bb938ecf36f7c56d460f63565b4351aa8f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc1MjE4Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518752182", "bodyText": "I consider this to be a transport layer feature, thus the ordering. I wanted to expose as less as possible as configuration to the end-user, and relax it if we have particular needs later. I can't think of any reason for users to interact with the compressed payload, if you do (//cc @Scottmitch) then happy to make the filters public and allow this to be configurable. WDYT?", "author": "tkountis", "createdAt": "2020-11-06T13:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMzg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5MzcwMQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518993701", "bodyText": "Use-cases I think about:\n\nMetrics filters: users likely are more interested in knowing what payload size sent on the wire vs the decompressed size.\nMetrics filter: users likely are more interested in the time it took for the HTTP exchange on the network, excluding time for post-processing.\nFilter for checksum validation of the received payload body before decompression (checksum value may come in trailers).\nFilter for adding a checksum trailer after compression.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T20:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxMzg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4OTA5NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518989094", "bodyText": "The content-coding names are case-insensitive. You do contentEqualsIgnoreCase first, then we should check the startsWith prefix case-insensitively.\nBecause the startsWith method is used only in one place, let's move it as a private method in ContentCodings class for now. Better to minimize the scope of public methods we have to maintain.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T20:29:08Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/CharSequences.java", "diffHunk": "@@ -226,7 +225,7 @@ private static boolean isUpperCase(final char value) {\n     }\n \n     /**\n-     * Tests if the string starts with the specified prefix.\n+     * Tests if the string starts with the specified case-sensitive prefix.", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5NDM2Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518994362", "bodyText": "Missed that, good catch", "author": "tkountis", "createdAt": "2020-11-06T20:41:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4OTA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5NTgwOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r518995808", "bodyText": "WDYT about making it StreamingHttpConnectionFilterFactory (or both if it's going to be public)? Then reserved connection will also have compression logic.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T20:44:36Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -23,16 +23,17 @@\n import static io.servicetalk.http.api.ContentCodings.identity;\n import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n-import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNone;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n \n /**\n  * Filter responsible for encoding/decoding content according to content-codings configured.\n  */\n-public class ContentCodingHttpClientFilter implements StreamingHttpClientFilterFactory {\n+class ContentCodingHttpClientFilter\n+        implements StreamingHttpClientFilterFactory, HttpExecutionStrategyInfluencer {", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2NzgyOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519067829", "bodyText": "agreed this is common practice for our filters.", "author": "Scottmitch", "createdAt": "2020-11-07T00:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk5NTgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMDMzMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519000330", "bodyText": "Should we reset requestCodings when this method is invoked? For cases when users invoked supportedEncodings, built a server, then invoked supportedResponseEncodings and built another server.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T20:54:59Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpServerBuilder.java", "diffHunk": "@@ -139,26 +139,26 @@\n     public abstract HttpServerBuilder transportObserver(TransportObserver transportObserver);\n \n     /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for both request and response handling.\n+     * Sets the supported {@link StreamingContentCodec}s for the server, used for both request and response handling.\n      *\n      * @param codings The list of supported {@link StreamingContentCodec}s for this endpoint.\n      * @return {@code this}\n      * @see <a href=\"https://tools.ietf.org/html/rfc7231#page-41\">Accept-Encodings</a>\n      */\n-    public final HttpServerBuilder supportedEncodingsBiDi(final StreamingContentCodec... codings) {\n+    public final HttpServerBuilder supportedEncodings(final StreamingContentCodec... codings) {\n         List<StreamingContentCodec> unmodifiable = unmodifiableList(asList(codings));\n         this.requestCodings = unmodifiable;\n         this.responseCodings = unmodifiable;\n         return this;\n     }\n \n     /**\n-     * Sets the supported {@link StreamingContentCodec}s for the endpoint, used for <b>responses only</b>.\n+     * Sets the supported {@link StreamingContentCodec}s for the server, used for <b>responses only</b>.\n      *\n      * @param codings The list of supported {@link StreamingContentCodec}s for the responses of this endpoint.\n      * @return {@code this}\n      */\n-    public final HttpServerBuilder supportedEncodings(final StreamingContentCodec... codings) {\n+    public final HttpServerBuilder supportedResponseEncodings(final StreamingContentCodec... codings) {\n         this.responseCodings = unmodifiableList(asList(codings));\n         return this;", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMzQzOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519003439", "bodyText": "We usually do not clarify default values in javadoc. Saving us some room the change them later. Consider removing it.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T21:01:57Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodings.java", "diffHunk": "@@ -51,7 +51,7 @@ public static StreamingContentCodec identity() {\n \n     /**\n      * Returns a GZIP based {@link StreamingContentCodec} backed by {@link java.util.zip.Inflater}.\n-     * The max allowed payload size for this codec is 2Mib.\n+     * The max allowed payload size for this codec is 16Mib.", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MTA1NA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519061054", "bodyText": "can we cache the header value for supportedEncodings instead of recomputing on every request?", "author": "Scottmitch", "createdAt": "2020-11-06T23:57:38Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpClientFilter\n+        implements StreamingHttpClientFilterFactory, HttpExecutionStrategyInfluencer {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MTkzNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519061935", "bodyText": "can you reference the ietf publish RFC https://tools.ietf.org/html/rfc7540#section-8.1.2.2 ?", "author": "Scottmitch", "createdAt": "2020-11-07T00:01:36Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HeaderUtils.java", "diffHunk": "@@ -226,6 +236,17 @@ static void addChunkedEncoding(final HttpHeaders headers) {\n         }\n     }\n \n+    static void addContentEncoding(final HttpHeaders headers, CharSequence encoding) {\n+        // H2 does not support TE / Transfer-Encoding, so we rely in the presentation encoding only.\n+        // https://httpwg.org/specs/rfc7540.html#n-connection-specific-header-fields", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2Nzg1Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519067856", "bodyText": "nit: make this final?", "author": "Scottmitch", "createdAt": "2020-11-07T00:30:36Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpClientFilter", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2OTE2OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519069169", "bodyText": "since we are modifying state of the request we should do this in a lazy fashion (e.g. Single.defer(() -> ...))", "author": "Scottmitch", "createdAt": "2020-11-07T00:37:52Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpClientFilter.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import java.util.List;\n+\n+import static io.servicetalk.http.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.addContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.advertiseAcceptedEncodingsIfAvailable;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrIdentity;\n+\n+/**\n+ * Filter responsible for encoding/decoding content according to content-codings configured.\n+ */\n+class ContentCodingHttpClientFilter\n+        implements StreamingHttpClientFilterFactory, HttpExecutionStrategyInfluencer {\n+\n+    private final List<StreamingContentCodec> supportedEncodings;\n+\n+    ContentCodingHttpClientFilter(final List<StreamingContentCodec> supportedEncodings) {\n+        this.supportedEncodings = supportedEncodings;\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+                advertiseAcceptedEncodingsIfAvailable(request, supportedEncodings);\n+                encodePayloadContentIfAvailable(request, alloc);", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3MTU5Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519071596", "bodyText": "#1174 (comment)\nI'm hesitant to introduce the \"terminal filter\" concept on the builder. If there may be ordering constraints (as highlighted by @idelpivnitskiy) best to let the user append the filter in their preferred order.", "author": "Scottmitch", "createdAt": "2020-11-07T00:51:57Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/SingleAddressHttpClientBuilder.java", "diffHunk": "@@ -97,13 +105,38 @@\n     @Override\n     public abstract SingleAddressHttpClientBuilder<U, R> appendClientFilter(StreamingHttpClientFilterFactory factory);\n \n+    @Override\n+    public SingleAddressHttpClientBuilder<U, R> supportedEncodings(StreamingContentCodec... codings) {\n+        this.supportedEncodings = unmodifiableList(asList(codings));\n+        return this;\n+    }\n+\n     @Override\n     public SingleAddressHttpClientBuilder<U, R> appendClientFilter(Predicate<StreamingHttpRequest> predicate,\n                                                                    StreamingHttpClientFilterFactory factory) {\n         return (SingleAddressHttpClientBuilder<U, R>)\n                 super.appendClientFilter(predicate, factory);\n     }\n \n+    /**\n+     * Terminal filter chain amendments hook.\n+     * @param currClientFilterFactory Current filter factory to append new filters if needed.\n+     * @return {@code this}\n+     */\n+    @Nullable\n+    protected StreamingHttpClientFilterFactory terminalFilterAmendment(", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTg0MQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r519075841", "bodyText": "followup: I noticed in gRPC we actually encode identity on the wire. Since not including the header is equivalent to identity we should just not emit identity (for content-encoding or accept-encoding headers). encoding/decoding headers isn't free so we should avoid this when ever possible. as an implementation note we should able to simplify as treating identity() the same as null (so we don't have to check for both conditions).", "author": "Scottmitch", "createdAt": "2020-11-07T01:19:44Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java", "diffHunk": "@@ -245,7 +245,7 @@ static GrpcMessageEncoding readGrpcMessageEncoding(final HttpMetaData httpMetaDa\n                                                        final Set<GrpcMessageEncoding> allowedEncodings) {\n         final CharSequence encoding = httpMetaData.headers().get(GRPC_MESSAGE_ENCODING_KEY);\n         if (encoding == null) {\n-            return none();\n+            return identity();", "originalCommit": "c26d68d050a1e11de9550d24f3d8d65ba61f5a13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMxNTA1Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r521315053", "bodyText": "Will follow up on that on the gRPC PR #1198", "author": "tkountis", "createdAt": "2020-11-11T12:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NTg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4ODk1Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522788956", "bodyText": "It looks like encode(src, allocator) and decode(src, allocator) is enough for current use-cases. Wdyt if we will remove overloads with offset and length for now to reduce public API surface?", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:26:49Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * API to support encode and decode of {@link Buffer}s.\n+ * <p>\n+ * <em>Implementations must provide thread safety semantics, since instances could be shared across threads.</em>\n+ */\n+public interface ContentCodec {\n+\n+    /**\n+     * A unique textual representation for the coding.\n+     *\n+     * @return a unique textual representation for the coding.\n+     */\n+    CharSequence name();\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    default Buffer encode(Buffer src, BufferAllocator allocator) {\n+        return encode(src, src.readerIndex(), src.readableBytes(), allocator);\n+    }\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param offset the offset of the source to start reading from\n+     * @param length the total length available for reading\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    Buffer encode(Buffer src, int offset, int length, BufferAllocator allocator);", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTEzMTY3OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525131679", "bodyText": "Agreed, the offset part isn't needed, but the length it is in some cases to avoid creating view or slice.\nCan we keep the changes as part of this PR https://github.com/apple/servicetalk/pull/1198/files#diff-0884917fb1a61a9cdef9580cd27730bd0d9863d6c93e5138b29866276576829bR55 ?", "author": "tkountis", "createdAt": "2020-11-17T12:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc4ODk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5NzYwMA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522797600", "bodyText": "Follow-up is ok: should we respond with 413 (or 400) when the size of decompressed payload body is larger than configured value?\nOn the client-side we should double check that the connection/stream will be closed if the decompressed side is larger than client allows.\nhttps://tools.ietf.org/html/rfc7231#section-6.5.11", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:34:34Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * A {@link StreamingHttpService} that adds encoding / decoding functionality for responses and requests respectively,\n+ * as these are specified by the spec\n+ * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n+ *\n+ * <p>\n+ * Append this filter before others that are expected to to see compressed content for this request/response, and after\n+ * other filters that expect to see/manipulate the original payload.\n+ */\n+public final class ContentCodingHttpServiceFilter\n+        implements StreamingHttpServiceFilterFactory, HttpExecutionStrategyInfluencer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ContentCodingHttpServiceFilter.class);\n+\n+    private final List<ContentCodec> requestCodings;\n+    private final List<ContentCodec> responseCodings;\n+\n+    /**\n+     * Enable support of the provided encodings for this server's requests and responses.\n+     * The encodings will be used for both client request decompression where needed and server responses compression\n+     * where enabled and matched.\n+     * <p>\n+     * To disable support of compressed requests, see {@link #ContentCodingHttpServiceFilter(List, List)}.\n+     * <p>\n+     * The order of the codings provided, affect selection priority alongside the order of the incoming\n+     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n+     *\n+     * @param supportedCodings the codecs used to compress server responses and decompress client requests when needed.\n+     */\n+    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedCodings) {\n+        final List<ContentCodec> unmodifiable = unmodifiableList(supportedCodings);\n+        this.requestCodings = unmodifiable;\n+        this.responseCodings = unmodifiable;\n+    }\n+\n+    /**\n+     * Enable support of the provided encodings for this server's requests and responses.\n+     * The encodings can differ for requests and responses, allowing a server that supports compressed responses,\n+     * but allows no compressed requests.\n+     * <p>\n+     * To disable support of compressed requests use an {@link Collections#emptyList()} for the\n+     * <code>supportedRequestCodings</code> param.\n+     * <p>\n+     * The order of the codecs provided, affect selection priority alongside the order of the incoming\n+     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n+     *\n+     * @param supportedRequestCodings the codecs used to decompress client requests if compressed.\n+     * @param supportedResponseCodings the codecs used to compress server responses if client accepts them.\n+     */\n+    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedRequestCodings,\n+                                          final List<ContentCodec> supportedResponseCodings) {\n+        this.requestCodings = unmodifiableList(supportedRequestCodings);\n+        this.responseCodings = unmodifiableList(supportedResponseCodings);\n+    }\n+\n+    @Override\n+    public StreamingHttpServiceFilter create(final StreamingHttpService service) {\n+        return new StreamingHttpServiceFilter(service) {\n+            @Override\n+            public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n+                                                        final StreamingHttpRequest request,\n+                                                        final StreamingHttpResponseFactory responseFactory) {\n+\n+                return Single.defer(() -> {\n+                    BufferAllocator allocator = ctx.executionContext().bufferAllocator();\n+                    try {\n+                        ContentCodec coding =\n+                                identifyContentEncodingOrNullIfIdentity(request.headers(), requestCodings);\n+                        if (coding != null) {\n+                            request.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n+                        }\n+\n+                        return super.handle(ctx, request, responseFactory).map(response -> {\n+                            encodePayloadContentIfAvailable(request.headers(), responseCodings, response, allocator);\n+                            return response;\n+                        });\n+                    } catch (UnsupportedContentEncodingException cause) {", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI4Njk5Ng==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525286996", "bodyText": "Follow up: #1217", "author": "tkountis", "createdAt": "2020-11-17T16:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjc5NzYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMTI2Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522801262", "bodyText": "WDYT if we will remove default implementation from streaming encode/decode methods? Our implementations always implement both. Users who do not care about streaming use-cases can decide what to do: implement the same as we have here now or throw an UnsupportedOperationException. Both ways are trivial for them to implement.\nIf we will have a strong use-case for default streaming methods later, we can add them later without breaking backward compatibility of the API.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:42:06Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * API to support encode and decode of {@link Buffer}s.\n+ * <p>\n+ * <em>Implementations must provide thread safety semantics, since instances could be shared across threads.</em>\n+ */\n+public interface ContentCodec {\n+\n+    /**\n+     * A unique textual representation for the coding.\n+     *\n+     * @return a unique textual representation for the coding.\n+     */\n+    CharSequence name();\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    default Buffer encode(Buffer src, BufferAllocator allocator) {\n+        return encode(src, src.readerIndex(), src.readableBytes(), allocator);\n+    }\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param offset the offset of the source to start reading from\n+     * @param length the total length available for reading\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    Buffer encode(Buffer src, int offset, int length, BufferAllocator allocator);\n+\n+    /**\n+     * Take a {@link Buffer} and decode its contents resulting in a {@link Buffer} with the decoded content.\n+     *\n+     * @param src the {@link Buffer} to decode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content decoded\n+     */\n+    default Buffer decode(Buffer src, BufferAllocator allocator) {\n+        return decode(src, src.readerIndex(), src.readableBytes(), allocator);\n+    }\n+\n+    /**\n+     * Take a {@link Buffer} and decode its contents resulting in a {@link Buffer} with the decoded content.\n+     *\n+     * @param src the {@link Buffer} to decode\n+     * @param offset the offset of the source to start reading from\n+     * @param length the total length available for reading\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content decoded\n+     */\n+    Buffer decode(Buffer src, int offset, int length, BufferAllocator allocator);\n+\n+    /**\n+     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n+     * {@link Publisher} of {@link Buffer} with the encoded contents.\n+     *\n+     * @param from the {@link Publisher} buffer to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Publisher} the result publisher with the buffers encoded\n+     */\n+    default Publisher<Buffer> encode(Publisher<Buffer> from, BufferAllocator allocator) {\n+        return from.map((buffer -> encode(buffer, allocator)));\n+    }\n+\n+    /**\n+     * Take a {@link Publisher} of {@link Buffer} and encode its contents resulting in a\n+     * {@link Publisher} of {@link Buffer} with the decoded contents.\n+     *\n+     * @param from the {@link Publisher} to decoded\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Publisher} the result publisher with the buffers decoded\n+     */\n+    default Publisher<Buffer> decode(Publisher<Buffer> from, BufferAllocator allocator) {\n+        return from.map(buffer -> decode(buffer, allocator));", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMjkwOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522802909", "bodyText": "We usually do not tell internal specifics or what are the default values because them may change. Consider removing information about the implementation here and for deflateDefault().", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:44:15Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.encoding.api.DefaultContentCodecBuilder.DeflateContentCodecBuilder;\n+import io.servicetalk.encoding.api.DefaultContentCodecBuilder.GzipContentCodecBuilder;\n+\n+/**\n+ * Common available encoding implementations.\n+ */\n+public final class ContentCodings {\n+\n+    private static final ContentCodec IDENTITY = IdentityContentCodec.INSTANCE;\n+\n+    private static final ContentCodec DEFAULT_GZIP = gzip().build();\n+\n+    private static final ContentCodec DEFAULT_DEFLATE = deflate().build();\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link ContentCodec}.\n+     * @return the default, always supported 'identity' {@link ContentCodec}\n+     */\n+    public static ContentCodec identity() {\n+        return IDENTITY;\n+    }\n+\n+    /**\n+     * Returns the default GZIP {@link ContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * @return default GZIP based {@link ContentCodec} backed by {@link java.util.zip.Inflater}", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwMzg0Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522803842", "bodyText": "It returns ContentCodecBuilder interface, same for deflate().", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:45:17Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodings.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.encoding.api.DefaultContentCodecBuilder.DeflateContentCodecBuilder;\n+import io.servicetalk.encoding.api.DefaultContentCodecBuilder.GzipContentCodecBuilder;\n+\n+/**\n+ * Common available encoding implementations.\n+ */\n+public final class ContentCodings {\n+\n+    private static final ContentCodec IDENTITY = IdentityContentCodec.INSTANCE;\n+\n+    private static final ContentCodec DEFAULT_GZIP = gzip().build();\n+\n+    private static final ContentCodec DEFAULT_DEFLATE = deflate().build();\n+\n+    private ContentCodings() {\n+    }\n+\n+    /**\n+     * Returns the default, always supported 'identity' {@link ContentCodec}.\n+     * @return the default, always supported 'identity' {@link ContentCodec}\n+     */\n+    public static ContentCodec identity() {\n+        return IDENTITY;\n+    }\n+\n+    /**\n+     * Returns the default GZIP {@link ContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * @return default GZIP based {@link ContentCodec} backed by {@link java.util.zip.Inflater}\n+     */\n+    public static ContentCodec gzipDefault() {\n+        return DEFAULT_GZIP;\n+    }\n+\n+    /**\n+     * Returns a GZIP based {@link DefaultContentCodecBuilder} that allows building\n+     * a customizable {@link ContentCodec}.\n+     * @return a GZIP based {@link DefaultContentCodecBuilder} that allows building", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwNDQzOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522804438", "bodyText": "Can this class be pkg-private for now if we have an interface?", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:45:58Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+public abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwNzAzOQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522807039", "bodyText": "Consider adding a check, follow a consistent pattern for the exception message: \n  \n    \n      servicetalk/servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsServiceDiscovererBuilder.java\n    \n    \n        Lines 106 to 108\n      in\n      0995205\n    \n    \n    \n    \n\n        \n          \n           if (maxUdpPayloadSize <= 0) { \n        \n\n        \n          \n               throw new IllegalArgumentException(\"maxUdpPayloadSize: \" + minTTLSeconds + \" (expected > 0)\"); \n        \n\n        \n          \n           }", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:48:43Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+public abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {\n+\n+    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n+\n+    protected int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD;\n+\n+    @Override\n+    public ContentCodecBuilder setMaxAllowedPayloadSize(final int maxAllowedPayloadSize) {\n+        this.maxAllowedPayloadSize = maxAllowedPayloadSize;", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwODE0OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522808148", "bodyText": "Consider adding a pkg-private (or protected) getter method instead of allowing subclasses to modify this value without calling a setter.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:50:25Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+public abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {\n+\n+    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n+\n+    protected int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD;", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgwOTQzNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522809435", "bodyText": "offset -> src.arrayOffset() + offset", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:52:56Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,574 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.util.Objects.requireNonNull;\n+\n+abstract class AbstractZipContentCodec extends AbstractContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Buffer END_OF_STREAM = DEFAULT_RO_ALLOCATOR.fromAscii(\" \");\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final CharSequence name, final int chunkSize, final int maxPayloadSize) {\n+        super(name);\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(Buffer.asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgxMjAyOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522812028", "bodyText": "next.readerIndex() -> next.arrayOffset() + next.readerIndex()", "author": "idelpivnitskiy", "createdAt": "2020-11-13T08:57:48Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,574 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.util.Objects.requireNonNull;\n+\n+abstract class AbstractZipContentCodec extends AbstractContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Buffer END_OF_STREAM = DEFAULT_RO_ALLOCATOR.fromAscii(\" \");\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final CharSequence name, final int chunkSize, final int maxPayloadSize) {\n+        super(name);\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(Buffer.asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[Math.min(src.readableBytes(), chunkSize)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        return from\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Buffer>() {\n+                    @Nullable\n+                    SwappableBufferOutputStream stream;\n+\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    private boolean headerWritten;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            Buffer dst = allocator.newBuffer(chunkSize);\n+                            stream = new SwappableBufferOutputStream(dst);\n+                            // This will write header bytes on the stream, which will be consumed along with the first\n+                            // onNext part\n+                            output = newDeflaterOutputStream(stream);\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        subscriber.onSubscribe(subscription);\n+                    }\n+\n+                    @Override\n+                    public void onNext(Buffer next) {\n+                        assert output != null;\n+                        assert stream != null;\n+\n+                        // onNext will produce AT-MOST N items (as received)\n+                        // +1 for the encoding footer (ie. END_OF_STREAM)\n+                        try {\n+                            if (next == END_OF_STREAM) {\n+                                try {\n+                                    // ZIP footer is 10 bytes\n+                                    Buffer dst = allocator.newBuffer(10);\n+                                    stream.swap(dst);\n+                                    output.finish();\n+\n+                                    subscriber.onNext(dst);\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                                return;\n+                            }\n+\n+                            Buffer dst;\n+                            if (headerWritten) {\n+                                dst = allocator.newBuffer(chunkSize);\n+                                stream.swap(dst);\n+                            } else {\n+                                dst = stream.buffer;\n+                            }\n+\n+                            if (next.hasArray()) {\n+                                output.write(next.array(), next.readerIndex(), next.readableBytes());", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMTAyNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522821024", "bodyText": "RS spec does not allow throwing from these methods. We should call onError in case of exceptions. SunscriberUtils.deliferErrorFromSource will be helpful here.\nPlease, revisit other try-catch blocks in this class.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T09:14:33Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,574 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.util.Objects.requireNonNull;\n+\n+abstract class AbstractZipContentCodec extends AbstractContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Buffer END_OF_STREAM = DEFAULT_RO_ALLOCATOR.fromAscii(\" \");\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final CharSequence name, final int chunkSize, final int maxPayloadSize) {\n+        super(name);\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(Buffer.asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[Math.min(src.readableBytes(), chunkSize)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        return from\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Buffer>() {\n+                    @Nullable\n+                    SwappableBufferOutputStream stream;\n+\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    private boolean headerWritten;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            Buffer dst = allocator.newBuffer(chunkSize);\n+                            stream = new SwappableBufferOutputStream(dst);\n+                            // This will write header bytes on the stream, which will be consumed along with the first\n+                            // onNext part\n+                            output = newDeflaterOutputStream(stream);\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMjIwMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522822203", "bodyText": "I think we should try-catch and deliver the error using onError instead of invoking onComplete if output.close() throws an exception.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T09:16:41Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -0,0 +1,574 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.zip.CRC32;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.Inflater;\n+import java.util.zip.InflaterInputStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.buffer.api.ReadOnlyBufferAllocators.DEFAULT_RO_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static java.util.Objects.requireNonNull;\n+\n+abstract class AbstractZipContentCodec extends AbstractContentCodec {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractZipContentCodec.class);\n+    private static final Buffer END_OF_STREAM = DEFAULT_RO_ALLOCATOR.fromAscii(\" \");\n+\n+    protected final int chunkSize;\n+    private final int maxPayloadSize;\n+\n+    AbstractZipContentCodec(final CharSequence name, final int chunkSize, final int maxPayloadSize) {\n+        super(name);\n+        this.chunkSize = chunkSize;\n+        this.maxPayloadSize = maxPayloadSize;\n+    }\n+\n+    abstract boolean supportsChecksum();\n+\n+    abstract Inflater newRawInflater();\n+\n+    abstract DeflaterOutputStream newDeflaterOutputStream(OutputStream out) throws IOException;\n+\n+    abstract InflaterInputStream newInflaterInputStream(InputStream in);\n+\n+    @Override\n+    public final Buffer encode(final Buffer src, final int offset, final int length,\n+                               final BufferAllocator allocator) {\n+        final Buffer dst = allocator.newBuffer(chunkSize);\n+        DeflaterOutputStream output = null;\n+        try {\n+            output = newDeflaterOutputStream(Buffer.asOutputStream(dst));\n+\n+            if (src.hasArray()) {\n+                output.write(src.array(), offset, length);\n+            } else {\n+                while (src.readableBytes() > 0) {\n+                    byte[] onHeap = new byte[Math.min(src.readableBytes(), chunkSize)];\n+                    src.readBytes(onHeap);\n+                    output.write(onHeap);\n+                }\n+            }\n+\n+            output.finish();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            closeQuietly(output);\n+        }\n+\n+        return dst;\n+    }\n+\n+    @Override\n+    public final Publisher<Buffer> encode(final Publisher<Buffer> from,\n+                                          final BufferAllocator allocator) {\n+        return from\n+                .concat(succeeded(END_OF_STREAM))\n+                .liftSync(subscriber -> new PublisherSource.Subscriber<Buffer>() {\n+                    @Nullable\n+                    SwappableBufferOutputStream stream;\n+\n+                    @Nullable\n+                    DeflaterOutputStream output;\n+\n+                    private boolean headerWritten;\n+\n+                    @Override\n+                    public void onSubscribe(PublisherSource.Subscription subscription) {\n+                        try {\n+                            Buffer dst = allocator.newBuffer(chunkSize);\n+                            stream = new SwappableBufferOutputStream(dst);\n+                            // This will write header bytes on the stream, which will be consumed along with the first\n+                            // onNext part\n+                            output = newDeflaterOutputStream(stream);\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        subscriber.onSubscribe(subscription);\n+                    }\n+\n+                    @Override\n+                    public void onNext(Buffer next) {\n+                        assert output != null;\n+                        assert stream != null;\n+\n+                        // onNext will produce AT-MOST N items (as received)\n+                        // +1 for the encoding footer (ie. END_OF_STREAM)\n+                        try {\n+                            if (next == END_OF_STREAM) {\n+                                try {\n+                                    // ZIP footer is 10 bytes\n+                                    Buffer dst = allocator.newBuffer(10);\n+                                    stream.swap(dst);\n+                                    output.finish();\n+\n+                                    subscriber.onNext(dst);\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                                return;\n+                            }\n+\n+                            Buffer dst;\n+                            if (headerWritten) {\n+                                dst = allocator.newBuffer(chunkSize);\n+                                stream.swap(dst);\n+                            } else {\n+                                dst = stream.buffer;\n+                            }\n+\n+                            if (next.hasArray()) {\n+                                output.write(next.array(), next.readerIndex(), next.readableBytes());\n+                            } else {\n+                                while (next.readableBytes() > 0) {\n+                                    byte[] onHeap = new byte[Math.min(next.readableBytes(), chunkSize)];\n+                                    next.readBytes(onHeap);\n+                                    output.write(onHeap);\n+                                }\n+                            }\n+\n+                            output.flush();\n+                            headerWritten = true;\n+                            subscriber.onNext(dst);\n+                        } catch (IOException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable t) {\n+                        closeQuietly(output);\n+                        subscriber.onError(t);\n+                    }\n+\n+                    @Override\n+                    public void onComplete() {\n+                        closeQuietly(output);\n+                        subscriber.onComplete();", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0NDE5Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522844193", "bodyText": "I double checked, you were right. There is a bug somewhere (need more investigation, but I have a reproducer) and we may miss trailers for some scenarios. Let's leave a TODO comment to remove this additional check when the trailers bug is resolved.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T09:56:04Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HeaderUtils.java", "diffHunk": "@@ -111,7 +112,7 @@ static boolean canAddResponseTransferEncodingProtocol(final int statusCode,\n     }\n \n     private static boolean canAddContentLength(final HttpMetaData metadata) {\n-        return !hasContentHeaders(metadata.headers()) &&\n+        return !hasContentHeaders(metadata.headers()) && !hasContentEncoding(metadata.headers()) &&", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0MjUzOA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525142538", "bodyText": "Opened a separate PR for this #1213\nI will leave a TODO once that is fixed.", "author": "tkountis", "createdAt": "2020-11-17T13:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0NDE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0NjgwNw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522846807", "bodyText": "nit: unnecessary extra lines", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:00:26Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ServerParentConnectionContext.java", "diffHunk": "@@ -149,9 +149,11 @@ protected void initChannel(final Http2StreamChannel streamChannel) {\n                                         parentChannelInitializer.multiplexedObserver.onNewStream();\n \n                                 // Netty To ServiceTalk type conversion\n+\n                                 streamChannel.pipeline().addLast(new H2ToStH1ServerDuplexHandler(\n                                         connection.executionContext().bufferAllocator(),\n                                         h2ServerConfig.headersFactory(),\n+", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0OTQzNg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522849436", "bodyText": "Just curious, why Grpc prefix was removed? :)", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:05:18Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/MessageCodec.java", "diffHunk": "@@ -19,10 +19,21 @@\n import io.servicetalk.buffer.api.BufferAllocator;\n \n /**\n- * Codec used to encode and decode gRPC messages.\n- * This instance is shared across all requests/responses therefore it must provide thread safety semantics.\n+ * Codec used to encode and decode {@link Buffer} content.\n+ * This instance is shared therefore it must provide thread safety semantics.\n  */\n-public interface GrpcMessageCodec {\n+public interface MessageCodec {", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0NzA4Mg==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525147082", "bodyText": "The gRPC PR removes them completely, #1198\nShould keep the changes there, or you would rather bring them here?", "author": "tkountis", "createdAt": "2020-11-17T13:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0OTQzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYyODI2Nw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525628267", "bodyText": "Doesn't matter, let's handle it in #1198. Thanks for clarifying.", "author": "idelpivnitskiy", "createdAt": "2020-11-18T01:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0OTQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MDYyNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522850625", "bodyText": "Similar comment as I had for ContentCodec: it looks like only encode(src, allocator) variant is enough for now. Can we remove an overload with offset and length? Users can slice the required Bufferportion in necessary to encode only a part of theBuffer`.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:07:35Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/MessageCodec.java", "diffHunk": "@@ -19,10 +19,21 @@\n import io.servicetalk.buffer.api.BufferAllocator;\n \n /**\n- * Codec used to encode and decode gRPC messages.\n- * This instance is shared across all requests/responses therefore it must provide thread safety semantics.\n+ * Codec used to encode and decode {@link Buffer} content.\n+ * This instance is shared therefore it must provide thread safety semantics.\n  */\n-public interface GrpcMessageCodec {\n+public interface MessageCodec {\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    default Buffer encode(Buffer src, BufferAllocator allocator) {", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0ODY2OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525148669", "bodyText": "It is useful for gRPC (https://github.com/apple/servicetalk/pull/1198/files#diff-04a488534a209852ed234ffe65b56d079a09bae65dede9c6366116204cf00320R162) otherwise we have to create a slice or view. IMO this is cheaper", "author": "tkountis", "createdAt": "2020-11-17T13:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MDYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYyODA2Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525628063", "bodyText": "IIUC, lengthOfData is always equal to toDeserialize.readableBytes(). Therefore, we do not need a slice. Let's handle it in #1198.", "author": "idelpivnitskiy", "createdAt": "2020-11-18T01:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1MDYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1NzAwMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522857003", "bodyText": "Because this result will be cached in a variable and will be written multiple time, consider wrapping the retirned String with newAsciiString. It will let the HttpObjectEncoder write it faster.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:19:43Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpRequesterFilter.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n+import static io.servicetalk.http.api.HeaderUtils.setAcceptEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n+\n+/**\n+ * A {@link StreamingHttpClientFilter} that adds encoding / decoding functionality for requests and responses\n+ * respectively, as these are specified by the spec\n+ * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n+ *\n+ * <p>\n+ * Append this filter before others that are expected to to see compressed content for this request/response, and after\n+ * other filters that expect to manipulate the original payload.\n+ */\n+public final class ContentCodingHttpRequesterFilter\n+        implements StreamingHttpClientFilterFactory, StreamingHttpConnectionFilterFactory,\n+                   HttpExecutionStrategyInfluencer {\n+\n+    private final List<ContentCodec> supportedCodings;\n+    @Nullable\n+    private final CharSequence acceptedEncodingsHeader;\n+\n+    /**\n+     * Enable support of the provided encodings for requests and responses.\n+     * The order of the codecs provided, matters for the presentation of the header, and may affect selection priority\n+     * on the receiving endpoint.\n+     *\n+     * @param supportedCodings the codecs this clients supports to encode/decode requests and responses accordingly\n+     * and also used to advertise to the server.\n+     */\n+    public ContentCodingHttpRequesterFilter(final List<ContentCodec> supportedCodings) {\n+        this.supportedCodings = supportedCodings;\n+        this.acceptedEncodingsHeader = buildAcceptEncodingsHeader(supportedCodings);\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public StreamingHttpConnectionFilter create(final FilterableStreamingHttpConnection connection) {\n+        return new StreamingHttpConnectionFilter(connection) {\n+            @Override\n+            public Single<StreamingHttpResponse> request(final HttpExecutionStrategy strategy,\n+                                                         final StreamingHttpRequest request) {\n+                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n+        // No influence since we do not block.\n+        return strategy;\n+    }\n+\n+    private Single<StreamingHttpResponse> codecTransformBidirectionalIfNeeded(final StreamingHttpRequester delegate,\n+                                                                              final HttpExecutionStrategy strategy,\n+                                                                              final StreamingHttpRequest request) {\n+        final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+        setAcceptEncoding(request.headers(), acceptedEncodingsHeader);\n+        encodePayloadContentIfAvailable(request, alloc);\n+\n+        return decodePayloadContentIfEncoded(delegate.request(strategy, request), alloc);\n+    }\n+\n+    private Single<StreamingHttpResponse> decodePayloadContentIfEncoded(\n+            final Single<StreamingHttpResponse> responseSingle, final BufferAllocator allocator) {\n+\n+        return responseSingle.map(response -> {\n+            ContentCodec coding = identifyContentEncodingOrNullIfIdentity(response.headers(), supportedCodings);\n+            if (coding != null) {\n+                response.transformPayloadBody(bufferPublisher -> coding.decode(bufferPublisher, allocator));\n+            }\n+\n+            return response;\n+        });\n+    }\n+\n+    @Nullable\n+    private static CharSequence buildAcceptEncodingsHeader(final List<ContentCodec> codecs) {\n+        StringBuilder builder = new StringBuilder();\n+        for (ContentCodec enc : codecs) {\n+            if (enc == identity()) {\n+                continue;\n+            }\n+\n+            if (builder.length() > 0) {\n+                builder.append(\", \");\n+            }\n+\n+            builder.append(enc.name());\n+        }\n+\n+        return builder.length() > 0 ? builder.toString() : null;", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg1OTkwNQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522859905", "bodyText": "Consider moving it out of a public interface. DefaultContentCodecBuilder can be a good home for this private constant.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:24:54Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+/**\n+ * Builder for {@link ContentCodec}.\n+ */\n+public interface ContentCodecBuilder {\n+\n+    int DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD = 16 << 20; //16MiB", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NTY1OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522865658", "bodyText": "unmodifiableList is not helpful here, because users have a reference to the original modifyable list.We know that the internal code of this filter does not modify the list. Therefore, not necessary to add this wrapper.\nI don't think we should copy the passed list, up to you. Doesn't make much sense for users to change it later. If you will decide to copy it, please do the same for the requester filter.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:36:04Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * A {@link StreamingHttpService} that adds encoding / decoding functionality for responses and requests respectively,\n+ * as these are specified by the spec\n+ * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n+ *\n+ * <p>\n+ * Append this filter before others that are expected to to see compressed content for this request/response, and after\n+ * other filters that expect to see/manipulate the original payload.\n+ */\n+public final class ContentCodingHttpServiceFilter\n+        implements StreamingHttpServiceFilterFactory, HttpExecutionStrategyInfluencer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ContentCodingHttpServiceFilter.class);\n+\n+    private final List<ContentCodec> requestCodings;\n+    private final List<ContentCodec> responseCodings;\n+\n+    /**\n+     * Enable support of the provided encodings for this server's requests and responses.\n+     * The encodings will be used for both client request decompression where needed and server responses compression\n+     * where enabled and matched.\n+     * <p>\n+     * To disable support of compressed requests, see {@link #ContentCodingHttpServiceFilter(List, List)}.\n+     * <p>\n+     * The order of the codings provided, affect selection priority alongside the order of the incoming\n+     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n+     *\n+     * @param supportedCodings the codecs used to compress server responses and decompress client requests when needed.\n+     */\n+    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedCodings) {\n+        final List<ContentCodec> unmodifiable = unmodifiableList(supportedCodings);", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NjY0OQ==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522866649", "bodyText": "I think what you had on the builder was the opposite. The method that takes a single List enabled compression only for responses (the most common use-case for servers). Users who need decompression for requests are advanced users and can use a second overload.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:37:57Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpServiceFilter.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.hasContentEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n+import static io.servicetalk.http.api.HeaderUtils.negotiateAcceptedEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n+import static java.util.Collections.unmodifiableList;\n+\n+/**\n+ * A {@link StreamingHttpService} that adds encoding / decoding functionality for responses and requests respectively,\n+ * as these are specified by the spec\n+ * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n+ *\n+ * <p>\n+ * Append this filter before others that are expected to to see compressed content for this request/response, and after\n+ * other filters that expect to see/manipulate the original payload.\n+ */\n+public final class ContentCodingHttpServiceFilter\n+        implements StreamingHttpServiceFilterFactory, HttpExecutionStrategyInfluencer {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ContentCodingHttpServiceFilter.class);\n+\n+    private final List<ContentCodec> requestCodings;\n+    private final List<ContentCodec> responseCodings;\n+\n+    /**\n+     * Enable support of the provided encodings for this server's requests and responses.\n+     * The encodings will be used for both client request decompression where needed and server responses compression\n+     * where enabled and matched.\n+     * <p>\n+     * To disable support of compressed requests, see {@link #ContentCodingHttpServiceFilter(List, List)}.\n+     * <p>\n+     * The order of the codings provided, affect selection priority alongside the order of the incoming\n+     * <a href=\"https://tools.ietf.org/html/rfc7231#section-5.3.4\">accept-encoding</a> header from the client.\n+     *\n+     * @param supportedCodings the codecs used to compress server responses and decompress client requests when needed.\n+     */\n+    public ContentCodingHttpServiceFilter(final List<ContentCodec> supportedCodings) {\n+        final List<ContentCodec> unmodifiable = unmodifiableList(supportedCodings);\n+        this.requestCodings = unmodifiable;\n+        this.responseCodings = unmodifiable;", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NzE0Mw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r522867143", "bodyText": "The whole method should be wrapped with defer operator, similar to the service filter.", "author": "idelpivnitskiy", "createdAt": "2020-11-13T10:39:02Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/ContentCodingHttpRequesterFilter.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.encoding.api.ContentCodec;\n+\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.encoding.api.ContentCodings.identity;\n+import static io.servicetalk.http.api.HeaderUtils.identifyContentEncodingOrNullIfIdentity;\n+import static io.servicetalk.http.api.HeaderUtils.setAcceptEncoding;\n+import static io.servicetalk.http.api.HeaderUtils.setContentEncoding;\n+\n+/**\n+ * A {@link StreamingHttpClientFilter} that adds encoding / decoding functionality for requests and responses\n+ * respectively, as these are specified by the spec\n+ * <a href=\"https://tools.ietf.org/html/rfc7231#section-3.1.2.2\">Content-Encoding</a>.\n+ *\n+ * <p>\n+ * Append this filter before others that are expected to to see compressed content for this request/response, and after\n+ * other filters that expect to manipulate the original payload.\n+ */\n+public final class ContentCodingHttpRequesterFilter\n+        implements StreamingHttpClientFilterFactory, StreamingHttpConnectionFilterFactory,\n+                   HttpExecutionStrategyInfluencer {\n+\n+    private final List<ContentCodec> supportedCodings;\n+    @Nullable\n+    private final CharSequence acceptedEncodingsHeader;\n+\n+    /**\n+     * Enable support of the provided encodings for requests and responses.\n+     * The order of the codecs provided, matters for the presentation of the header, and may affect selection priority\n+     * on the receiving endpoint.\n+     *\n+     * @param supportedCodings the codecs this clients supports to encode/decode requests and responses accordingly\n+     * and also used to advertise to the server.\n+     */\n+    public ContentCodingHttpRequesterFilter(final List<ContentCodec> supportedCodings) {\n+        this.supportedCodings = supportedCodings;\n+        this.acceptedEncodingsHeader = buildAcceptEncodingsHeader(supportedCodings);\n+    }\n+\n+    @Override\n+    public StreamingHttpClientFilter create(final FilterableStreamingHttpClient client) {\n+        return new StreamingHttpClientFilter(client) {\n+            @Override\n+            protected Single<StreamingHttpResponse> request(final StreamingHttpRequester delegate,\n+                                                            final HttpExecutionStrategy strategy,\n+                                                            final StreamingHttpRequest request) {\n+                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public StreamingHttpConnectionFilter create(final FilterableStreamingHttpConnection connection) {\n+        return new StreamingHttpConnectionFilter(connection) {\n+            @Override\n+            public Single<StreamingHttpResponse> request(final HttpExecutionStrategy strategy,\n+                                                         final StreamingHttpRequest request) {\n+                return Single.defer(() -> codecTransformBidirectionalIfNeeded(delegate(), strategy, request));\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n+        // No influence since we do not block.\n+        return strategy;\n+    }\n+\n+    private Single<StreamingHttpResponse> codecTransformBidirectionalIfNeeded(final StreamingHttpRequester delegate,\n+                                                                              final HttpExecutionStrategy strategy,\n+                                                                              final StreamingHttpRequest request) {\n+        final BufferAllocator alloc = delegate.executionContext().bufferAllocator();\n+        setAcceptEncoding(request.headers(), acceptedEncodingsHeader);\n+        encodePayloadContentIfAvailable(request, alloc);\n+\n+        return decodePayloadContentIfEncoded(delegate.request(strategy, request), alloc);", "originalCommit": "8a1682387511352de295980af85c56963bce711a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE1MDQ3MA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525150470", "bodyText": "The factory methods (create) do wrap it.", "author": "tkountis", "createdAt": "2020-11-17T13:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg2NzE0Mw=="}], "type": "inlineReview"}, {"oid": "7b06865c7197cb7266f4c9218f23970efdf41f82", "url": "https://github.com/apple/servicetalk/commit/7b06865c7197cb7266f4c9218f23970efdf41f82", "message": "Introduce HTTP content encoding H1 & H2\n\nMotivation:\n\nOur HTTP clients & servers don't support any form of compression. There are many use cases that involve large payloads, that compression could make a difference on the HTTP timings.\n\nModifications:\n\nH1 & H2 protocols were altered to support a list of supported-encodings. We provide the default ones out of the box as part of the helper ContentEncodings.all() which offers, GZIP & DEFLATE.\nTo keep the behavior consistent between the two protocols, we chose to communicate the compression technique to the relevant endpoints through the 'Content-Encoding & Accept-Content-Encoding' headers, rather than on the 'Transfer-Encoding & TE' headers, which are not supported by H2.\n\nResult:\n\nOnce the client & server are configured to support different encodings through the protocol configuration, a client can encode a request by passing the encoding request.encoding(...) whereas the server will decide on the encoding based on the client advertised headers. To disable the encoding for a particular request, or enforce a specific encoding, one can call response.encoding(...) to do so. That, bypasses the auto-selection, and also ignores compatibility checks with the client.\n\nEncoding & Decoding is done in a streaming fashion.", "committedDate": "2020-11-17T12:59:30Z", "type": "commit"}, {"oid": "57bc44d84e891f2b68599e0fa40e661df4fa344a", "url": "https://github.com/apple/servicetalk/commit/57bc44d84e891f2b68599e0fa40e661df4fa344a", "message": "Fix broken pipeline when gzip footer is received onNext was not called", "committedDate": "2020-11-17T12:59:30Z", "type": "commit"}, {"oid": "a336216027fe7c0de6d2a3c268f1f8c50286f875", "url": "https://github.com/apple/servicetalk/commit/a336216027fe7c0de6d2a3c268f1f8c50286f875", "message": "Address comments", "committedDate": "2020-11-17T13:01:01Z", "type": "commit"}, {"oid": "c464a892ff89066ed0c4cb584e8364cbe4274514", "url": "https://github.com/apple/servicetalk/commit/c464a892ff89066ed0c4cb584e8364cbe4274514", "message": "Improvements", "committedDate": "2020-11-17T13:01:01Z", "type": "commit"}, {"oid": "a8bc7971cf60bc18b3bbbac55829a17c7ce19297", "url": "https://github.com/apple/servicetalk/commit/a8bc7971cf60bc18b3bbbac55829a17c7ce19297", "message": "Rename to Codec & rebase", "committedDate": "2020-11-17T13:01:01Z", "type": "commit"}, {"oid": "358045f70f25ec96f518351264a064dea749c191", "url": "https://github.com/apple/servicetalk/commit/358045f70f25ec96f518351264a064dea749c191", "message": "Fix build", "committedDate": "2020-11-17T13:01:02Z", "type": "commit"}, {"oid": "6ee1909087be66c93dcce05c8b322401661d7207", "url": "https://github.com/apple/servicetalk/commit/6ee1909087be66c93dcce05c8b322401661d7207", "message": "Add ContentCodecBuilder & rename to codec", "committedDate": "2020-11-17T13:01:02Z", "type": "commit"}, {"oid": "1758afb743527d6f8805b9ba540b826c8d7943a6", "url": "https://github.com/apple/servicetalk/commit/1758afb743527d6f8805b9ba540b826c8d7943a6", "message": "Address new comments pt1", "committedDate": "2020-11-17T13:01:49Z", "type": "commit"}, {"oid": "ddc0ca9d96d7ebcae7732a3506b1caa9c49d42c0", "url": "https://github.com/apple/servicetalk/commit/ddc0ca9d96d7ebcae7732a3506b1caa9c49d42c0", "message": "Fix comments", "committedDate": "2020-11-17T13:02:29Z", "type": "commit"}, {"oid": "fadb8ccd97651b29e55616536a7097d382e2cd0e", "url": "https://github.com/apple/servicetalk/commit/fadb8ccd97651b29e55616536a7097d382e2cd0e", "message": "Move encoding pieces to a new moduleP", "committedDate": "2020-11-17T13:02:29Z", "type": "commit"}, {"oid": "6577a1a04af84d823ceb681844ebd73795b0a4e6", "url": "https://github.com/apple/servicetalk/commit/6577a1a04af84d823ceb681844ebd73795b0a4e6", "message": "Fix hunging issue for non-streaming requests & minor improvements", "committedDate": "2020-11-17T13:02:29Z", "type": "commit"}, {"oid": "c7f164fbf25999ab7ddd3322406a156b8f2413d5", "url": "https://github.com/apple/servicetalk/commit/c7f164fbf25999ab7ddd3322406a156b8f2413d5", "message": "Improve max payload error message", "committedDate": "2020-11-17T13:02:29Z", "type": "commit"}, {"oid": "39ec43975c626e174396f7369f163a21afe875b6", "url": "https://github.com/apple/servicetalk/commit/39ec43975c626e174396f7369f163a21afe875b6", "message": "Address comments", "committedDate": "2020-11-17T16:07:23Z", "type": "commit"}, {"oid": "39ec43975c626e174396f7369f163a21afe875b6", "url": "https://github.com/apple/servicetalk/commit/39ec43975c626e174396f7369f163a21afe875b6", "message": "Address comments", "committedDate": "2020-11-17T16:07:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYxMzUxNA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525613514", "bodyText": "We do not add \"get\" prefix for getters, we use only \"set\" prefix for setters and \"is/has\" prefix for boolean-type getters. Consider adjusting your Intellij IDEA templates for generated getters.", "author": "idelpivnitskiy", "createdAt": "2020-11-18T00:24:13Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/DefaultContentCodecBuilder.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+abstract class DefaultContentCodecBuilder implements ContentCodecBuilder {\n+\n+    private static final int CHUNK_SIZE = 1 << 10; //1KiB\n+    private static final int DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD = 16 << 20; //16MiB\n+\n+    private int maxAllowedPayloadSize = DEFAULT_MAX_ALLOWED_DECOMPRESSED_PAYLOAD;\n+\n+    protected int getMaxAllowedPayloadSize() {", "originalCommit": "39ec43975c626e174396f7369f163a21afe875b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYxNjI0OA==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525616248", "bodyText": "I don't think this is correct. At this level we do not need to care about internal Buffer implementation, we should just take an offset based on src.readerIndex(). The implementation of decode method also adds src.arrayOffset(). As the result, you double-counting the arrayOffset.", "author": "idelpivnitskiy", "createdAt": "2020-11-18T00:31:36Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.encoding.api;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+/**\n+ * API to support encode and decode of {@link Buffer}s.\n+ * <p>\n+ * <em>Implementations must provide thread safety semantics, since instances could be shared across threads.</em>\n+ */\n+public interface ContentCodec {\n+\n+    /**\n+     * A unique textual representation for the coding.\n+     *\n+     * @return a unique textual representation for the coding.\n+     */\n+    CharSequence name();\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    default Buffer encode(Buffer src, BufferAllocator allocator) {\n+        int offset = src.hasArray() ? src.arrayOffset() : 0;\n+        return encode(src, offset + src.readerIndex(), src.readableBytes(), allocator);\n+    }\n+\n+    /**\n+     * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n+     *\n+     * @param src the {@link Buffer} to encode\n+     * @param offset the offset of the source to start reading from\n+     * @param length the total length available for reading\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content encoded\n+     */\n+    Buffer encode(Buffer src, int offset, int length, BufferAllocator allocator);\n+\n+    /**\n+     * Take a {@link Buffer} and decode its contents resulting in a {@link Buffer} with the decoded content.\n+     *\n+     * @param src the {@link Buffer} to decode\n+     * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n+     * @return {@link Buffer} the result buffer with the content decoded\n+     */\n+    default Buffer decode(Buffer src, BufferAllocator allocator) {\n+        int offset = src.hasArray() ? src.arrayOffset() : 0;\n+        return decode(src, offset + src.readerIndex(), src.readableBytes(), allocator);", "originalCommit": "39ec43975c626e174396f7369f163a21afe875b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4OTYwMw==", "url": "https://github.com/apple/servicetalk/pull/1174#discussion_r525989603", "bodyText": ":(", "author": "tkountis", "createdAt": "2020-11-18T10:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYxNjI0OA=="}], "type": "inlineReview"}, {"oid": "f134933387ac13eade5cfae1e6bfce7220422a78", "url": "https://github.com/apple/servicetalk/commit/f134933387ac13eade5cfae1e6bfce7220422a78", "message": "The end", "committedDate": "2020-11-18T14:45:15Z", "type": "commit"}]}