{"pr_number": 1018, "pr_title": "DNS SRV query support", "pr_createdAt": "2020-04-15T22:38:37Z", "pr_url": "https://github.com/apple/servicetalk/pull/1018", "timeline": [{"oid": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "url": "https://github.com/apple/servicetalk/commit/ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "message": "DNS SRV query support\n\nMotivation:\nOur DNS client currently doesn't support\n[SRV Resource Records](https://tools.ietf.org/html/rfc2782) which is a\ncommonly used type of resolution.\n\nModifications:\n- Rename DnsServiceDiscoverer to DnsClient internally to clarify the\nfeature set is inteded to cover dns client use cases.\n- Remove the ServiceDiscovererFilter related classes as the only\nimplementations are specific to DNS, can be replicated with simple\nPublisher#retryWhen operator, and the general utility of these broad\nAPIs across different clients/protocols is yet to be demonstrated.\n- Remove tracking of all outstanding streams and close() cleanup to\nreduce state. Subscribers of these sources (e.g. LoadBalancers) are\nresponsible for cancelling if they are no longer interested in demand.\nThere is best effort close cleanup when TTLs timeout fire in the event\nthe DnsClient is closed but the streams are not cancelled (which is not\nan expected use case).\n- Introduce DNS SRV record support into DefaultDnsClient. Initial\nsupport is limited to a single A/AAAA record resolution per SRV record\ndue to operator availability (e.g. flatMapMergeSingle) which is\nsufficient to get started and can be enhanced later.\n- Expose static factory methods for SRV based lookups on HttpClients and\nGrpcClients\n\nResult:\nDNS supports SRV resolution.", "committedDate": "2020-04-15T22:37:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4NTMwMw==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409185303", "bodyText": "threw => throw\n(here and below)", "author": "NiteshKant", "createdAt": "2020-04-15T23:07:11Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/SubscriberUtils.java", "diffHunk": "@@ -306,4 +306,33 @@ public static void handleExceptionFromOnSubscribe(CompletableSource.Subscriber s\n             LOGGER.info(\"Ignoring exception from onError of Subscriber {}.\", subscriber, t);\n         }\n     }\n+\n+    /**\n+     * Invokes {@link PublisherSource.Subscriber#onError(Throwable)} ignoring an occurred exception if any.\n+     * @param subscriber The {@link PublisherSource.Subscriber} that may threw an exception from", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5MDIzNw==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409190237", "bodyText": "Unintentional? DnsClientFilterFactory interface is package private.", "author": "NiteshKant", "createdAt": "2020-04-15T23:21:58Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsServiceDiscovererBuilder.java", "diffHunk": "@@ -186,14 +184,12 @@ public DefaultDnsServiceDiscovererBuilder noRetriesOnDnsFailures() {\n      *     filter1 =&gt; filter2 =&gt; filter3 =&gt; service discoverer\n      * </pre>\n      *\n-     * @param factory {@link ServiceDiscovererFilterFactory} to decorate a {@link ServiceDiscoverer} for the purpose of\n+     * @param factory {@link DnsClientFilterFactory} to decorate a {@link DnsClient} for the purpose of\n      * filtering.\n      * @return {@code this}\n      */\n-    public DefaultDnsServiceDiscovererBuilder appendFilter(\n-            final ServiceDiscovererFilterFactory<String, InetAddress, ServiceDiscovererEvent<InetAddress>>\n-                    factory) {\n-        serviceDiscoveryFilterFactory = serviceDiscoveryFilterFactory.append(factory);\n+    DefaultDnsServiceDiscovererBuilder appendFilter(final DnsClientFilterFactory factory) {", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyOTM0Nw==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409229347", "bodyText": "this method is also package private (currently used in tests)", "author": "Scottmitch", "createdAt": "2020-04-16T01:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5MDIzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY3MTgyMw==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409671823", "bodyText": "aah rite, makes sense!", "author": "NiteshKant", "createdAt": "2020-04-16T16:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5MDIzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5Njg0MQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409196841", "bodyText": "nit: add a default constructor for RetryingDnsClientFilter with these defaults.", "author": "NiteshKant", "createdAt": "2020-04-15T23:43:10Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsServiceDiscovererBuilder.java", "diffHunk": "@@ -209,75 +205,49 @@ public DefaultDnsServiceDiscovererBuilder ioExecutor(final IoExecutor ioExecutor\n     }\n \n     /**\n-     * Build a new instance of {@link ServiceDiscoverer ServiceDiscoverer&lt;String, InetAddress&gt;}.\n-     *\n-     * @return a new instance of {@link ServiceDiscoverer ServiceDiscoverer&lt;String, InetAddress&gt;}.\n+     * Build a new {@link ServiceDiscoverer} which queries\n+     * <a href=\"https://tools.ietf.org/html/rfc2782\">SRV Resource Records</a> corresponding to {@code serviceName}. For\n+     * each SRV answer capture the <strong>Port</strong> and resolve the <strong>Target</strong>.\n+     * @return a new {@link ServiceDiscoverer} which queries\n+     * <a href=\"https://tools.ietf.org/html/rfc2782\">SRV Resource Records</a> corresponding to {@code serviceName}. For\n+     * each SRV answer capture the <strong>Port</strong> and resolve the <strong>Target</strong>.\n      */\n-    public ServiceDiscoverer<String, InetAddress, ServiceDiscovererEvent<InetAddress>> buildInetDiscoverer() {\n-        return newDefaultDnsServiceDiscoverer();\n+    public ServiceDiscoverer<String, InetSocketAddress, ServiceDiscovererEvent<InetSocketAddress>>\n+            buildSrvDiscoverer() {\n+        return asSrvDiscoverer(build());\n     }\n \n     /**\n-     * Build a new instance of {@link ServiceDiscoverer ServiceDiscoverer&lt;HostAndPort, InetSocketAddress&gt;}.\n-     *\n-     * @return a new instance of {@link ServiceDiscoverer ServiceDiscoverer&lt;HostAndPort, InetSocketAddress&gt;}.\n-     * @see HostAndPort\n+     * Build a new {@link ServiceDiscoverer} which targets\n+     * <a href=\"https://tools.ietf.org/html/rfc1035\">host addresses</a> (e.g. A or AAAA records) and uses\n+     * a fixed port derived from the {@link HostAndPort}.\n+     * @return a new {@link ServiceDiscoverer} which targets\n+     * <a href=\"https://tools.ietf.org/html/rfc1035\">host addresses</a> (e.g. A or AAAA records) and uses\n+     * a fixed port derived from the {@link HostAndPort}.\n      */\n-    public ServiceDiscoverer<HostAndPort, InetSocketAddress, ServiceDiscovererEvent<InetSocketAddress>> build() {\n-        return toHostAndPortDiscoverer(newDefaultDnsServiceDiscoverer());\n-    }\n-\n-    private ServiceDiscoverer<String, InetAddress,\n-            ServiceDiscovererEvent<InetAddress>> newDefaultDnsServiceDiscoverer() {\n-        ServiceDiscovererFilterFactory<String, InetAddress, ServiceDiscovererEvent<InetAddress>> factory =\n-                this.serviceDiscoveryFilterFactory;\n-\n-        if (applyRetryFilter) {\n-            final ServiceDiscovererFilterFactory<String, InetAddress, ServiceDiscovererEvent<InetAddress>>\n-                    defaultFilterFactory = serviceDiscoverer -> new RetryingDnsServiceDiscovererFilter(\n-                    serviceDiscoverer, retryWithConstantBackoffAndJitter(\n-                    Integer.MAX_VALUE, t -> true, Duration.ofSeconds(60), immediate()));\n-            factory = defaultFilterFactory.append(factory);\n-        }\n-        return factory.create(new DefaultDnsServiceDiscoverer(\n-                ioExecutor == null ? globalExecutionContext().ioExecutor() : ioExecutor, minTTLSeconds, ndots,\n-                invalidateHostsOnDnsFailure, optResourceEnabled, queryTimeout, dnsResolverAddressTypes,\n-                dnsServerAddressStreamProvider));\n+    public ServiceDiscoverer<HostAndPort, InetSocketAddress, ServiceDiscovererEvent<InetSocketAddress>>\n+            buildARecordDiscoverer() {\n+        return asHostAndPortDiscoverer(build());\n     }\n \n     /**\n-     * Convert this object from {@link String} host names and {@link InetAddress} resolved address to\n-     * {@link HostAndPort} to {@link InetSocketAddress}.\n+     * Create a new instance of {@link DnsClient}.\n      *\n-     * @return a resolver which will convert from {@link String} host names and {@link InetAddress} resolved address to\n-     * {@link HostAndPort} to {@link InetSocketAddress}.\n+     * @return a new instance of {@link DnsClient}.\n      */\n-    private static ServiceDiscoverer<HostAndPort, InetSocketAddress,\n-            ServiceDiscovererEvent<InetSocketAddress>> toHostAndPortDiscoverer(\n-            final ServiceDiscoverer<String, InetAddress, ServiceDiscovererEvent<InetAddress>> serviceDiscoverer) {\n-        return new ServiceDiscoverer<HostAndPort, InetSocketAddress, ServiceDiscovererEvent<InetSocketAddress>>() {\n-            @Override\n-            public Completable closeAsync() {\n-                return serviceDiscoverer.closeAsync();\n-            }\n-\n-            @Override\n-            public Completable closeAsyncGracefully() {\n-                return serviceDiscoverer.closeAsyncGracefully();\n-            }\n-\n-            @Override\n-            public Completable onClose() {\n-                return serviceDiscoverer.onClose();\n-            }\n-\n-            @Override\n-            public Publisher<ServiceDiscovererEvent<InetSocketAddress>> discover(final HostAndPort hostAndPort) {\n-                return serviceDiscoverer.discover(hostAndPort.hostName()).map(originalEvent ->\n-                        new DefaultServiceDiscovererEvent<>(new InetSocketAddress(originalEvent.address(),\n-                                hostAndPort.port()), originalEvent.isAvailable())\n-                );\n-            }\n-        };\n+    DnsClient build() {\n+        DnsClient rawClient = new DefaultDnsClient(\n+                ioExecutor == null ? globalExecutionContext().ioExecutor() : ioExecutor, minTTLSeconds, ndots,\n+                invalidateHostsOnDnsFailure, optResourceEnabled, queryTimeout, dnsResolverAddressTypes,\n+                dnsServerAddressStreamProvider);\n+        DnsClientFilterFactory rawFilterFactory = filterFactory;\n+        if (applyRetryFilter) {\n+            DnsClientFilterFactory retryFilterFactory = client -> new RetryingDnsClientFilter(client,", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzMDE3Ng==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409230176", "bodyText": "done", "author": "Scottmitch", "createdAt": "2020-04-16T01:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5Njg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5ODAwNQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409198005", "bodyText": "I suggest to name this forServiceAddress to be more relatable. And also improve the javadoc like:\nCreates a {@link GrpcClientBuilder} for the passed  {@code serviceName} with default {@link LoadBalancer} and a DNS {@link ServiceDiscoverer} using <a href=\"https://tools.ietf.org/html/rfc2782\">SRV record</a> lookups.", "author": "NiteshKant", "createdAt": "2020-04-15T23:46:56Z", "path": "servicetalk-grpc-netty/src/main/java/io/servicetalk/grpc/netty/GrpcClients.java", "diffHunk": "@@ -57,6 +57,17 @@ private GrpcClients() {\n         return new DefaultGrpcClientBuilder<>(HttpClients.forSingleAddress(address));\n     }\n \n+    /**\n+     * Creates a {@link GrpcClientBuilder} for a service name with default {@link LoadBalancer} and\n+     * <a href=\"https://tools.ietf.org/html/rfc2782\">SRV DNS</a> resolution.\n+     *\n+     * @param serviceName the service name to query via <a href=\"https://tools.ietf.org/html/rfc2782\">SRV DNS</a>.\n+     * @return new builder for the address\n+     */\n+    public static GrpcClientBuilder<String, InetSocketAddress> forSrvAddress(final String serviceName) {", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5OTM5NA==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409199394", "bodyText": "Since this is always returning ServiceDiscoverer can we keep the name same and reduce public API breakage?", "author": "NiteshKant", "createdAt": "2020-04-15T23:51:08Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/GlobalDnsClient.java", "diffHunk": "@@ -32,35 +32,55 @@\n  * A lazily initialized singleton DNS {@link ServiceDiscoverer} using a default {@link ExecutionContext}, the lifecycle\n  * of this instance shouldn't need to be managed by the user. Don't attempt to close the {@link ServiceDiscoverer}.\n  */\n-final class GlobalDnsServiceDiscoverer {\n+final class GlobalDnsClient {", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzMTQ0OA==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409231448", "bodyText": "This is a package private API, but I can change back since the client is no longer visible here.", "author": "Scottmitch", "createdAt": "2020-04-16T01:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5OTM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMDE1NA==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409200154", "bodyText": "I think the old name still is relevant.", "author": "NiteshKant", "createdAt": "2020-04-15T23:53:23Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/GlobalDnsClient.java", "diffHunk": "@@ -32,35 +32,55 @@\n  * A lazily initialized singleton DNS {@link ServiceDiscoverer} using a default {@link ExecutionContext}, the lifecycle\n  * of this instance shouldn't need to be managed by the user. Don't attempt to close the {@link ServiceDiscoverer}.\n  */\n-final class GlobalDnsServiceDiscoverer {\n+final class GlobalDnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GlobalDnsClient.class);\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(GlobalDnsServiceDiscoverer.class);\n-\n-    private GlobalDnsServiceDiscoverer() {\n+    private GlobalDnsClient() {\n         // No instances\n     }\n \n     /**\n-     * Get the {@link GlobalDnsServiceDiscoverer}.\n+     * Get the {@link ServiceDiscoverer} targeting fixed ports.\n      *\n      * @return the singleton instance\n      */\n     static ServiceDiscoverer<HostAndPort, InetSocketAddress,\n-            ServiceDiscovererEvent<InetSocketAddress>> globalDnsServiceDiscoverer() {\n-        return GlobalDnsServiceDiscovererInitializer.INSTANCE;\n+            ServiceDiscovererEvent<InetSocketAddress>> globalDnsWithFixedPort() {", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMDQxOQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409200419", "bodyText": "globalSrvDnsServiceDiscoverer()?", "author": "NiteshKant", "createdAt": "2020-04-15T23:54:11Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/GlobalDnsClient.java", "diffHunk": "@@ -32,35 +32,55 @@\n  * A lazily initialized singleton DNS {@link ServiceDiscoverer} using a default {@link ExecutionContext}, the lifecycle\n  * of this instance shouldn't need to be managed by the user. Don't attempt to close the {@link ServiceDiscoverer}.\n  */\n-final class GlobalDnsServiceDiscoverer {\n+final class GlobalDnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GlobalDnsClient.class);\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(GlobalDnsServiceDiscoverer.class);\n-\n-    private GlobalDnsServiceDiscoverer() {\n+    private GlobalDnsClient() {\n         // No instances\n     }\n \n     /**\n-     * Get the {@link GlobalDnsServiceDiscoverer}.\n+     * Get the {@link ServiceDiscoverer} targeting fixed ports.\n      *\n      * @return the singleton instance\n      */\n     static ServiceDiscoverer<HostAndPort, InetSocketAddress,\n-            ServiceDiscovererEvent<InetSocketAddress>> globalDnsServiceDiscoverer() {\n-        return GlobalDnsServiceDiscovererInitializer.INSTANCE;\n+            ServiceDiscovererEvent<InetSocketAddress>> globalDnsWithFixedPort() {\n+        return HostAndPortClientInitializer.HOST_PORT_SD;\n+    }\n+\n+    /**\n+     * Get the {@link ServiceDiscoverer} targeting SRV records.\n+     *\n+     * @return the singleton instance\n+     */\n+    static ServiceDiscoverer<String, InetSocketAddress,\n+            ServiceDiscovererEvent<InetSocketAddress>> globalDnsSrv() {", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwMTM5MQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409201391", "bodyText": "Make this a DnsClientFilterFactory to follow the general pattern in other clients?", "author": "NiteshKant", "createdAt": "2020-04-15T23:57:22Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/RetryingDnsClientFilter.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Retry {@link DnsClient} operations upon failure.\n+ */\n+final class RetryingDnsClientFilter extends DnsClientFilter {", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNDQ2OQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409204469", "bodyText": "The formatting looks off here.", "author": "NiteshKant", "createdAt": "2020-04-16T00:07:39Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.CompletableSource.Processor;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribableCompletable;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtectionIfNotNegative;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable WAITING_FOR_REQUEST_N = () -> { };\n+\n+    private final Processor closeCompletable = newCompletableProcessor();\n+    private final Map<String, List<ARecordPublisher>> srvARecordMap = new HashMap<>(8);\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+        LOGGER.debug(\"Created a new DNS discoverer {} with minimum TTL (seconds): {}, ndots: {}, \" +\n+                        \"optResourceEnabled {}, dnsResolverAddressTypes {}, dnsServerAddressStreamProvider {}.\",\n+                this, minTTL, ndots, optResourceEnabled, dnsResolverAddressTypes, dnsServerAddressStreamProvider);\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                .<ServiceDiscovererEvent<InetSocketAddress>>flatMapMergeSingle(srvEvent -> {\n+            assertInEventloop();", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MTM2OA==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409271368", "bodyText": "This is how the IDE lined it up. what would you suggest as an alternative? lets not hold up this PR over formatting issues. ideally we can update the checkstyle rules to clarify/automate expectations if necessary.", "author": "Scottmitch", "createdAt": "2020-04-16T04:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNDQ2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY3Mjk3Mg==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409672972", "bodyText": "+1 for not holding off the PR; I just reformatted using IDE.", "author": "NiteshKant", "createdAt": "2020-04-16T16:03:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNDQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNjE1NQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409206155", "bodyText": "Actually on thinkin about it more, throwing an error from here would error out the whole SRV lookup. It seems we can be tolerant of bad DNS names expecting other records being present. An alternative could be to log at warn and ignore such entries. If you think otherwise, the error message here needs to be changed:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                       throw new IllegalStateException(\"0 SRV records found. 1 SRV record is required!\");\n          \n          \n            \n                                        throw new IllegalStateException(\"No A records found for DNS name: \" + \n          \n          \n            \n                                                srvEvent.address().hostName() + \" corresponding to SRV name: \" + serviceName);", "author": "NiteshKant", "createdAt": "2020-04-16T00:13:11Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.CompletableSource.Processor;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribableCompletable;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtectionIfNotNegative;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable WAITING_FOR_REQUEST_N = () -> { };\n+\n+    private final Processor closeCompletable = newCompletableProcessor();\n+    private final Map<String, List<ARecordPublisher>> srvARecordMap = new HashMap<>(8);\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+        LOGGER.debug(\"Created a new DNS discoverer {} with minimum TTL (seconds): {}, ndots: {}, \" +\n+                        \"optResourceEnabled {}, dnsResolverAddressTypes {}, dnsServerAddressStreamProvider {}.\",\n+                this, minTTL, ndots, optResourceEnabled, dnsResolverAddressTypes, dnsServerAddressStreamProvider);\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                .<ServiceDiscovererEvent<InetSocketAddress>>flatMapMergeSingle(srvEvent -> {\n+            assertInEventloop();\n+\n+            if (srvEvent.isAvailable()) {\n+                ARecordPublisher entry = new ARecordPublisher(srvEvent.address().hostName()) {\n+                    @Override\n+                    protected void onFinallyCleanup() {\n+                        removeSrvEntry0(this);\n+                    }\n+                };\n+                addSrvEntry0(entry);\n+                return entry.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                        new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+                       ).firstOrElse(() -> {\n+                           throw new IllegalStateException(\"0 SRV records found. 1 SRV record is required!\");", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIzNDAxNw==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409234017", "bodyText": "I agree we actually don't need to error out here and can just return null, which we filter later.", "author": "Scottmitch", "createdAt": "2020-04-16T01:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwNjE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIwOTU0Ng==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409209546", "bodyText": "I think this code existed before we added AsyncCloseables#toAsyncCloseable(). You can use this method in the constructor like:\nAsyncCloseables.toAsyncCloseable(graceful -> {\n            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n                closeAsync0();\n            } else {\n                nettyIoExecutor.asExecutor().execute(DefaultDnsClient.this::closeAsync0);\n            }\n            return Completable.completed();\n        })\nand then each of the close methods can delegate to that ListenableAsyncCloseable.", "author": "NiteshKant", "createdAt": "2020-04-16T00:24:37Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.CompletableSource.Processor;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribableCompletable;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtectionIfNotNegative;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable WAITING_FOR_REQUEST_N = () -> { };\n+\n+    private final Processor closeCompletable = newCompletableProcessor();\n+    private final Map<String, List<ARecordPublisher>> srvARecordMap = new HashMap<>(8);\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+        LOGGER.debug(\"Created a new DNS discoverer {} with minimum TTL (seconds): {}, ndots: {}, \" +\n+                        \"optResourceEnabled {}, dnsResolverAddressTypes {}, dnsServerAddressStreamProvider {}.\",\n+                this, minTTL, ndots, optResourceEnabled, dnsResolverAddressTypes, dnsServerAddressStreamProvider);\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                .<ServiceDiscovererEvent<InetSocketAddress>>flatMapMergeSingle(srvEvent -> {\n+            assertInEventloop();\n+\n+            if (srvEvent.isAvailable()) {\n+                ARecordPublisher entry = new ARecordPublisher(srvEvent.address().hostName()) {\n+                    @Override\n+                    protected void onFinallyCleanup() {\n+                        removeSrvEntry0(this);\n+                    }\n+                };\n+                addSrvEntry0(entry);\n+                return entry.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                        new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+                       ).firstOrElse(() -> {\n+                           throw new IllegalStateException(\"0 SRV records found. 1 SRV record is required!\");\n+                       });\n+            } else {\n+                final List<ARecordPublisher> inetWatchers = srvARecordMap.remove(srvEvent.address().hostName());\n+                if (inetWatchers != null) {\n+                    for (ARecordPublisher inetWatcher : inetWatchers) {\n+                        inetWatcher.close0();\n+                    }\n+                }\n+\n+                // We will filter the null value out on the outer flatMap transformation.\n+                return Single.succeeded(null);\n+            }\n+        })\n+        // When the SRV record becomes unavailable we clean up state and return a Single.succeeded(null), but\n+        // we don't want to propagate this downstream, so filter it out.\n+        .filter(Objects::nonNull);\n+    }\n+\n+    private void addSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        srvARecordMap.computeIfAbsent(entry.inetHost, k -> new ArrayList<>(2)).add(entry);\n+    }\n+\n+    private void removeSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        final List<ARecordPublisher> inetWatchers = srvARecordMap.get(entry.inetHost);\n+        if (inetWatchers == null) {\n+            return;\n+        }\n+        inetWatchers.remove(entry);\n+        if (inetWatchers.isEmpty()) {\n+            srvARecordMap.remove(entry.inetHost);\n+        }\n+    }\n+\n+    @Override\n+    public Completable onClose() {", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxMTk1Nw==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409211957", "bodyText": "Are the trace and debug log statements intentionally removed from here and below?", "author": "NiteshKant", "createdAt": "2020-04-16T00:33:13Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.CompletableSource.Processor;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribableCompletable;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtectionIfNotNegative;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable WAITING_FOR_REQUEST_N = () -> { };\n+\n+    private final Processor closeCompletable = newCompletableProcessor();\n+    private final Map<String, List<ARecordPublisher>> srvARecordMap = new HashMap<>(8);\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+        LOGGER.debug(\"Created a new DNS discoverer {} with minimum TTL (seconds): {}, ndots: {}, \" +\n+                        \"optResourceEnabled {}, dnsResolverAddressTypes {}, dnsServerAddressStreamProvider {}.\",\n+                this, minTTL, ndots, optResourceEnabled, dnsResolverAddressTypes, dnsServerAddressStreamProvider);\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                .<ServiceDiscovererEvent<InetSocketAddress>>flatMapMergeSingle(srvEvent -> {\n+            assertInEventloop();\n+\n+            if (srvEvent.isAvailable()) {\n+                ARecordPublisher entry = new ARecordPublisher(srvEvent.address().hostName()) {\n+                    @Override\n+                    protected void onFinallyCleanup() {\n+                        removeSrvEntry0(this);\n+                    }\n+                };\n+                addSrvEntry0(entry);\n+                return entry.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                        new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+                       ).firstOrElse(() -> {\n+                           throw new IllegalStateException(\"0 SRV records found. 1 SRV record is required!\");\n+                       });\n+            } else {\n+                final List<ARecordPublisher> inetWatchers = srvARecordMap.remove(srvEvent.address().hostName());\n+                if (inetWatchers != null) {\n+                    for (ARecordPublisher inetWatcher : inetWatchers) {\n+                        inetWatcher.close0();\n+                    }\n+                }\n+\n+                // We will filter the null value out on the outer flatMap transformation.\n+                return Single.succeeded(null);\n+            }\n+        })\n+        // When the SRV record becomes unavailable we clean up state and return a Single.succeeded(null), but\n+        // we don't want to propagate this downstream, so filter it out.\n+        .filter(Objects::nonNull);\n+    }\n+\n+    private void addSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        srvARecordMap.computeIfAbsent(entry.inetHost, k -> new ArrayList<>(2)).add(entry);\n+    }\n+\n+    private void removeSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        final List<ARecordPublisher> inetWatchers = srvARecordMap.get(entry.inetHost);\n+        if (inetWatchers == null) {\n+            return;\n+        }\n+        inetWatchers.remove(entry);\n+        if (inetWatchers.isEmpty()) {\n+            srvARecordMap.remove(entry.inetHost);\n+        }\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return fromSource(closeCompletable);\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return new SubscribableCompletable() {\n+            @Override\n+            protected void handleSubscribe(final CompletableSource.Subscriber subscriber) {\n+                closeCompletable.subscribe(subscriber);\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    closeAsync0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(DefaultDnsClient.this::closeAsync0);\n+                }\n+            }\n+        };\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+        closeCompletable.onComplete();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends EntriesPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(new DefaultDnsQuestion(serviceName, SRV))\n+                            .addListener((Future<? super List<DnsRecord>> completedFuture) -> {\n+                                Throwable cause = completedFuture.cause();\n+                                if (cause != null) {\n+                                    promise.setFailure(cause);\n+                                } else {\n+                                    final DnsAnswer<HostAndPort> dnsAnswer;\n+                                    long minTTLSeconds = Long.MAX_VALUE;\n+                                    try {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final List<DnsRecord> dnsRecords = (List<DnsRecord>) completedFuture.getNow();\n+                                        final List<HostAndPort> hostAndPorts = new ArrayList<>(dnsRecords.size());\n+                                        for (DnsRecord dnsRecord : dnsRecords) {\n+                                            if (!SRV.equals(dnsRecord.type()) || !(dnsRecord instanceof DnsRawRecord)) {\n+                                                throw new IllegalArgumentException(\n+                                                        \"Unsupported DNS record type for SRV query: \" + dnsRecord);\n+                                            }\n+                                            if (dnsRecord.timeToLive() < minTTLSeconds) {\n+                                                minTTLSeconds = dnsRecord.timeToLive();\n+                                            }\n+                                            ByteBuf content = ((DnsRawRecord) dnsRecord).content();\n+                                            // https://tools.ietf.org/html/rfc2782\n+                                            // Priority(16u) Weight(16u) Port(16u) Target(varstring)\n+                                            content.skipBytes(4); // ignore Priority and Weight for now\n+                                            final int port = content.readUnsignedShort();\n+                                            hostAndPorts.add(HostAndPort.of(decodeName(content), port));\n+                                        }\n+                                        dnsAnswer = new DnsAnswer<>(hostAndPorts, SECONDS.toNanos(minTTLSeconds));\n+                                    } catch (Throwable cause2) {\n+                                        promise.setFailure(cause2);\n+                                        return;\n+                                    }\n+                                    promise.setSuccess(dnsAnswer);\n+                                }\n+                            });\n+                    return promise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<HostAndPort>> calculateDifference(\n+                        final List<HostAndPort> previousList, final List<HostAndPort> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, HOST_AND_PORT_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                }\n+            };\n+        }\n+    }\n+\n+    private class ARecordPublisher extends EntriesPublisher<InetAddress> {\n+        private final String inetHost;\n+\n+        ARecordPublisher(String inetHost) {\n+            this.inetHost = inetHost;\n+        }\n+\n+        protected void onFinallyCleanup() {\n+            // overridable for any cleanup\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<InetAddress>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<InetAddress>> doDnsQuery() {\n+                    ttlCache.prepareForResolution(inetHost);\n+                    Promise<DnsAnswer<InetAddress>> dnsAnswerPromise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(inetHost).addListener(completedFuture -> {\n+                        Throwable cause = completedFuture.cause();\n+                        if (cause != null) {\n+                            dnsAnswerPromise.setFailure(cause);\n+                        } else {\n+                            final DnsAnswer<InetAddress> dnsAnswer;\n+                            try {\n+                                @SuppressWarnings(\"unchecked\")\n+                                final List<InetAddress> addresses = (List<InetAddress>) completedFuture.getNow();\n+                                dnsAnswer = new DnsAnswer<>(addresses, SECONDS.toNanos(ttlCache.minTtl(inetHost)));\n+                            } catch (Throwable cause2) {\n+                                dnsAnswerPromise.setFailure(cause2);\n+                                return;\n+                            }\n+                            dnsAnswerPromise.setSuccess(dnsAnswer);\n+                        }\n+                    });\n+                    return dnsAnswerPromise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<InetAddress>> calculateDifference(\n+                        final List<InetAddress> previousList, final List<InetAddress> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, INET_ADDRESS_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                    onFinallyCleanup();\n+                }\n+            };\n+        }\n+    }\n+\n+    private static final class DnsAnswer<T> {\n+        private final List<T> answer;\n+        private final long ttlNanos;\n+\n+        DnsAnswer(final List<T> answer, final long ttlNanos) {\n+            this.answer = answer;\n+            this.ttlNanos = ttlNanos;\n+        }\n+\n+        List<T> answer() {\n+            return answer;\n+        }\n+\n+        long ttlNanos() {\n+            return ttlNanos;\n+        }\n+    }\n+\n+    private abstract class EntriesPublisher<T>\n+            extends SubscribablePublisher<Iterable<ServiceDiscovererEvent<T>>> {\n+        @Nullable\n+        private Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> discoverySubscriber;\n+        @Nullable\n+        private AbstractEntriesPublisherSubscription subscription;\n+\n+        protected abstract AbstractEntriesPublisherSubscription\n+        newSubscription(Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber);\n+\n+        @Override\n+        protected final void handleSubscribe(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                handleSubscribe0(subscriber);\n+            } else {\n+                nettyIoExecutor.asExecutor().execute(() -> handleSubscribe0(subscriber));\n+            }\n+        }\n+\n+        private void handleSubscribe0(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            assertInEventloop();\n+\n+            if (discoverySubscriber != null) {\n+                deliverTerminalFromSource(subscriber,\n+                        new DuplicateSubscribeException(discoverySubscriber, subscriber));\n+            } else if (closed) {\n+                deliverTerminalFromSource(subscriber,\n+                        new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                                \" has been closed!\"));\n+            } else {\n+                subscription = newSubscription(subscriber);\n+                discoverySubscriber = subscriber;\n+                subscriber.onSubscribe(subscription);\n+            }\n+        }\n+\n+        final void close0() {\n+            assertInEventloop();\n+\n+            final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> oldSubscriber = discoverySubscriber;\n+            discoverySubscriber = null;\n+            if (oldSubscriber != null) {\n+                assert subscription != null;\n+                subscription.cancelWithoutRemove0(true);\n+            }\n+        }\n+\n+        abstract class AbstractEntriesPublisherSubscription implements Subscription {\n+            private final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber;\n+            private long pendingRequests;\n+            private List<T> activeAddresses;\n+            private long resolveDoneNoScheduleTime;\n+            @Nullable\n+            private Cancellable cancellableForQuery;\n+            private long ttlNanos;\n+\n+            AbstractEntriesPublisherSubscription(\n+                    final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+                this.subscriber = subscriber;\n+                activeAddresses = emptyList();\n+                ttlNanos = -1;\n+            }\n+\n+            protected abstract Future<DnsAnswer<T>> doDnsQuery();\n+\n+            @Nullable\n+            protected abstract List<ServiceDiscovererEvent<T>>\n+            calculateDifference(List<T> previousList, List<T> newList);\n+\n+            protected abstract void removeFromWatchers();\n+\n+            @Override\n+            public final void request(final long n) {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    request0(n);\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(() -> request0(n));\n+                }\n+            }\n+\n+            @Override\n+            public final void cancel() {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    cancel0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(this::cancel0);\n+                }\n+            }\n+\n+            private void request0(final long n) {\n+                assertInEventloop();\n+\n+                if (!isRequestNValid(n)) {\n+                    handleError0(newExceptionForInvalidRequestN(n), __ -> false);\n+                    return;\n+                }\n+\n+                pendingRequests = addWithOverflowProtectionIfNotNegative(pendingRequests, n);\n+                if (cancellableForQuery == null) {\n+                    if (ttlNanos < 0) {\n+                        doQuery0();\n+                    } else {\n+                        final long durationNs = nanoTime() - resolveDoneNoScheduleTime;\n+                        if (durationNs > ttlNanos) {\n+                            doQuery0();\n+                        } else {\n+                            scheduleQuery0(ttlNanos - durationNs);\n+                        }\n+                    }\n+                } else if (cancellableForQuery == WAITING_FOR_REQUEST_N) {\n+                    cancellableForQuery = TERMINATED;\n+                    terminateOnComplete();\n+                }\n+            }\n+\n+            private void doQuery0() {\n+                assertInEventloop();\n+\n+                if (closed) {\n+                    // best effort check to cleanup state after close.\n+                    handleError0(new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                            \" has been closed!\"), __ -> false);\n+                } else {\n+                    final Future<DnsAnswer<T>> addressFuture = doDnsQuery();\n+                    cancellableForQuery = () -> addressFuture.cancel(true);\n+                    if (addressFuture.isDone()) {\n+                        handleResolveDone0(addressFuture);\n+                    } else {\n+                        addressFuture.addListener((FutureListener<DnsAnswer<T>>) this::handleResolveDone0);\n+                    }\n+                }\n+            }\n+\n+            private void cancel0() {\n+                assertInEventloop();\n+\n+                removeFromWatchers();\n+                cancelWithoutRemove0(false);\n+            }\n+\n+            private void cancelWithoutRemove0(boolean tryGenerateInactiveEvents) {\n+                if (cancellableForQuery != null) {\n+                    cancellableForQuery = TERMINATED;\n+                    discoverySubscriber = null;\n+                    pendingRequests = -1;\n+                    cancellableForQuery.cancel();\n+                }\n+                if (tryGenerateInactiveEvents) {\n+                    if (activeAddresses.isEmpty() || pendingRequests > 0) {\n+                        terminateOnComplete();\n+                    } else {\n+                        cancellableForQuery = WAITING_FOR_REQUEST_N;\n+                    }\n+                }\n+            }\n+\n+            private void terminateOnComplete() {\n+                try {\n+                    clearAddressesAndPropagateRemovalEvents();\n+                } catch (Throwable cause) {\n+                    safeOnError(subscriber, cause);\n+                    return;\n+                }\n+                safeOnComplete(subscriber);\n+            }\n+\n+            private void scheduleQuery0(final long nanos) {\n+                assertInEventloop();\n+\n+                // This value is coming from DNS TTL for which the unit is seconds and the minimum value we accept\n+                // in the builder is 1 second.\n+                cancellableForQuery = nettyIoExecutor.asExecutor().schedule(\n+                        this::doQuery0, nanos, NANOSECONDS);\n+            }\n+\n+            private void handleResolveDone0(final Future<DnsAnswer<T>> addressFuture) {\n+                assertInEventloop();\n+\n+                // If `discoverySubscriber` is null, then this publisher has terminated, so we can't send any more\n+                // signals. There's no point in even scheduling a query in that case.\n+                if (discoverySubscriber != null) {\n+                    final Throwable cause = addressFuture.cause();\n+                    if (cause != null) {\n+                        handleError0(cause, invalidateHostsOnDnsFailure);\n+                    } else {\n+                        // DNS lookup can return duplicate InetAddress\n+                        DnsAnswer<T> dnsAnswer = addressFuture.getNow();\n+                        final List<T> addresses = dnsAnswer.answer();\n+                        final List<ServiceDiscovererEvent<T>> events = calculateDifference(activeAddresses, addresses);\n+                        ttlNanos = dnsAnswer.ttlNanos();\n+                        if (events != null) {\n+                            activeAddresses = addresses;\n+                            --pendingRequests;\n+                            if (pendingRequests > 0) {\n+                                scheduleQuery0(ttlNanos);\n+                            } else {\n+                                resolveDoneNoScheduleTime = nanoTime();\n+                                cancellableForQuery = null;\n+                            }\n+                            try {\n+                                subscriber.onNext(events);", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI0MTQwOQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409241409", "bodyText": "they got lost in the shuffle. let me add some back.", "author": "Scottmitch", "createdAt": "2020-04-16T02:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxMTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxMjM3Mw==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409212373", "bodyText": "add an assert for in eventloop?", "author": "NiteshKant", "createdAt": "2020-04-16T00:34:38Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.CompletableSource.Processor;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribableCompletable;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtectionIfNotNegative;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable WAITING_FOR_REQUEST_N = () -> { };\n+\n+    private final Processor closeCompletable = newCompletableProcessor();\n+    private final Map<String, List<ARecordPublisher>> srvARecordMap = new HashMap<>(8);\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+        LOGGER.debug(\"Created a new DNS discoverer {} with minimum TTL (seconds): {}, ndots: {}, \" +\n+                        \"optResourceEnabled {}, dnsResolverAddressTypes {}, dnsServerAddressStreamProvider {}.\",\n+                this, minTTL, ndots, optResourceEnabled, dnsResolverAddressTypes, dnsServerAddressStreamProvider);\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                .<ServiceDiscovererEvent<InetSocketAddress>>flatMapMergeSingle(srvEvent -> {\n+            assertInEventloop();\n+\n+            if (srvEvent.isAvailable()) {\n+                ARecordPublisher entry = new ARecordPublisher(srvEvent.address().hostName()) {\n+                    @Override\n+                    protected void onFinallyCleanup() {\n+                        removeSrvEntry0(this);\n+                    }\n+                };\n+                addSrvEntry0(entry);\n+                return entry.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                        new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+                       ).firstOrElse(() -> {\n+                           throw new IllegalStateException(\"0 SRV records found. 1 SRV record is required!\");\n+                       });\n+            } else {\n+                final List<ARecordPublisher> inetWatchers = srvARecordMap.remove(srvEvent.address().hostName());\n+                if (inetWatchers != null) {\n+                    for (ARecordPublisher inetWatcher : inetWatchers) {\n+                        inetWatcher.close0();\n+                    }\n+                }\n+\n+                // We will filter the null value out on the outer flatMap transformation.\n+                return Single.succeeded(null);\n+            }\n+        })\n+        // When the SRV record becomes unavailable we clean up state and return a Single.succeeded(null), but\n+        // we don't want to propagate this downstream, so filter it out.\n+        .filter(Objects::nonNull);\n+    }\n+\n+    private void addSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        srvARecordMap.computeIfAbsent(entry.inetHost, k -> new ArrayList<>(2)).add(entry);\n+    }\n+\n+    private void removeSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        final List<ARecordPublisher> inetWatchers = srvARecordMap.get(entry.inetHost);\n+        if (inetWatchers == null) {\n+            return;\n+        }\n+        inetWatchers.remove(entry);\n+        if (inetWatchers.isEmpty()) {\n+            srvARecordMap.remove(entry.inetHost);\n+        }\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return fromSource(closeCompletable);\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return new SubscribableCompletable() {\n+            @Override\n+            protected void handleSubscribe(final CompletableSource.Subscriber subscriber) {\n+                closeCompletable.subscribe(subscriber);\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    closeAsync0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(DefaultDnsClient.this::closeAsync0);\n+                }\n+            }\n+        };\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+        closeCompletable.onComplete();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends EntriesPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(new DefaultDnsQuestion(serviceName, SRV))\n+                            .addListener((Future<? super List<DnsRecord>> completedFuture) -> {\n+                                Throwable cause = completedFuture.cause();\n+                                if (cause != null) {\n+                                    promise.setFailure(cause);\n+                                } else {\n+                                    final DnsAnswer<HostAndPort> dnsAnswer;\n+                                    long minTTLSeconds = Long.MAX_VALUE;\n+                                    try {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final List<DnsRecord> dnsRecords = (List<DnsRecord>) completedFuture.getNow();\n+                                        final List<HostAndPort> hostAndPorts = new ArrayList<>(dnsRecords.size());\n+                                        for (DnsRecord dnsRecord : dnsRecords) {\n+                                            if (!SRV.equals(dnsRecord.type()) || !(dnsRecord instanceof DnsRawRecord)) {\n+                                                throw new IllegalArgumentException(\n+                                                        \"Unsupported DNS record type for SRV query: \" + dnsRecord);\n+                                            }\n+                                            if (dnsRecord.timeToLive() < minTTLSeconds) {\n+                                                minTTLSeconds = dnsRecord.timeToLive();\n+                                            }\n+                                            ByteBuf content = ((DnsRawRecord) dnsRecord).content();\n+                                            // https://tools.ietf.org/html/rfc2782\n+                                            // Priority(16u) Weight(16u) Port(16u) Target(varstring)\n+                                            content.skipBytes(4); // ignore Priority and Weight for now\n+                                            final int port = content.readUnsignedShort();\n+                                            hostAndPorts.add(HostAndPort.of(decodeName(content), port));\n+                                        }\n+                                        dnsAnswer = new DnsAnswer<>(hostAndPorts, SECONDS.toNanos(minTTLSeconds));\n+                                    } catch (Throwable cause2) {\n+                                        promise.setFailure(cause2);\n+                                        return;\n+                                    }\n+                                    promise.setSuccess(dnsAnswer);\n+                                }\n+                            });\n+                    return promise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<HostAndPort>> calculateDifference(\n+                        final List<HostAndPort> previousList, final List<HostAndPort> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, HOST_AND_PORT_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                }\n+            };\n+        }\n+    }\n+\n+    private class ARecordPublisher extends EntriesPublisher<InetAddress> {\n+        private final String inetHost;\n+\n+        ARecordPublisher(String inetHost) {\n+            this.inetHost = inetHost;\n+        }\n+\n+        protected void onFinallyCleanup() {\n+            // overridable for any cleanup\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<InetAddress>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<InetAddress>> doDnsQuery() {\n+                    ttlCache.prepareForResolution(inetHost);\n+                    Promise<DnsAnswer<InetAddress>> dnsAnswerPromise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(inetHost).addListener(completedFuture -> {\n+                        Throwable cause = completedFuture.cause();\n+                        if (cause != null) {\n+                            dnsAnswerPromise.setFailure(cause);\n+                        } else {\n+                            final DnsAnswer<InetAddress> dnsAnswer;\n+                            try {\n+                                @SuppressWarnings(\"unchecked\")\n+                                final List<InetAddress> addresses = (List<InetAddress>) completedFuture.getNow();\n+                                dnsAnswer = new DnsAnswer<>(addresses, SECONDS.toNanos(ttlCache.minTtl(inetHost)));\n+                            } catch (Throwable cause2) {\n+                                dnsAnswerPromise.setFailure(cause2);\n+                                return;\n+                            }\n+                            dnsAnswerPromise.setSuccess(dnsAnswer);\n+                        }\n+                    });\n+                    return dnsAnswerPromise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<InetAddress>> calculateDifference(\n+                        final List<InetAddress> previousList, final List<InetAddress> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, INET_ADDRESS_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                    onFinallyCleanup();\n+                }\n+            };\n+        }\n+    }\n+\n+    private static final class DnsAnswer<T> {\n+        private final List<T> answer;\n+        private final long ttlNanos;\n+\n+        DnsAnswer(final List<T> answer, final long ttlNanos) {\n+            this.answer = answer;\n+            this.ttlNanos = ttlNanos;\n+        }\n+\n+        List<T> answer() {\n+            return answer;\n+        }\n+\n+        long ttlNanos() {\n+            return ttlNanos;\n+        }\n+    }\n+\n+    private abstract class EntriesPublisher<T>\n+            extends SubscribablePublisher<Iterable<ServiceDiscovererEvent<T>>> {\n+        @Nullable\n+        private Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> discoverySubscriber;\n+        @Nullable\n+        private AbstractEntriesPublisherSubscription subscription;\n+\n+        protected abstract AbstractEntriesPublisherSubscription\n+        newSubscription(Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber);\n+\n+        @Override\n+        protected final void handleSubscribe(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                handleSubscribe0(subscriber);\n+            } else {\n+                nettyIoExecutor.asExecutor().execute(() -> handleSubscribe0(subscriber));\n+            }\n+        }\n+\n+        private void handleSubscribe0(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            assertInEventloop();\n+\n+            if (discoverySubscriber != null) {\n+                deliverTerminalFromSource(subscriber,\n+                        new DuplicateSubscribeException(discoverySubscriber, subscriber));\n+            } else if (closed) {\n+                deliverTerminalFromSource(subscriber,\n+                        new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                                \" has been closed!\"));\n+            } else {\n+                subscription = newSubscription(subscriber);\n+                discoverySubscriber = subscriber;\n+                subscriber.onSubscribe(subscription);\n+            }\n+        }\n+\n+        final void close0() {\n+            assertInEventloop();\n+\n+            final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> oldSubscriber = discoverySubscriber;\n+            discoverySubscriber = null;\n+            if (oldSubscriber != null) {\n+                assert subscription != null;\n+                subscription.cancelWithoutRemove0(true);\n+            }\n+        }\n+\n+        abstract class AbstractEntriesPublisherSubscription implements Subscription {\n+            private final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber;\n+            private long pendingRequests;\n+            private List<T> activeAddresses;\n+            private long resolveDoneNoScheduleTime;\n+            @Nullable\n+            private Cancellable cancellableForQuery;\n+            private long ttlNanos;\n+\n+            AbstractEntriesPublisherSubscription(\n+                    final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+                this.subscriber = subscriber;\n+                activeAddresses = emptyList();\n+                ttlNanos = -1;\n+            }\n+\n+            protected abstract Future<DnsAnswer<T>> doDnsQuery();\n+\n+            @Nullable\n+            protected abstract List<ServiceDiscovererEvent<T>>\n+            calculateDifference(List<T> previousList, List<T> newList);\n+\n+            protected abstract void removeFromWatchers();\n+\n+            @Override\n+            public final void request(final long n) {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    request0(n);\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(() -> request0(n));\n+                }\n+            }\n+\n+            @Override\n+            public final void cancel() {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    cancel0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(this::cancel0);\n+                }\n+            }\n+\n+            private void request0(final long n) {\n+                assertInEventloop();\n+\n+                if (!isRequestNValid(n)) {\n+                    handleError0(newExceptionForInvalidRequestN(n), __ -> false);\n+                    return;\n+                }\n+\n+                pendingRequests = addWithOverflowProtectionIfNotNegative(pendingRequests, n);\n+                if (cancellableForQuery == null) {\n+                    if (ttlNanos < 0) {\n+                        doQuery0();\n+                    } else {\n+                        final long durationNs = nanoTime() - resolveDoneNoScheduleTime;\n+                        if (durationNs > ttlNanos) {\n+                            doQuery0();\n+                        } else {\n+                            scheduleQuery0(ttlNanos - durationNs);\n+                        }\n+                    }\n+                } else if (cancellableForQuery == WAITING_FOR_REQUEST_N) {\n+                    cancellableForQuery = TERMINATED;\n+                    terminateOnComplete();\n+                }\n+            }\n+\n+            private void doQuery0() {\n+                assertInEventloop();\n+\n+                if (closed) {\n+                    // best effort check to cleanup state after close.\n+                    handleError0(new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                            \" has been closed!\"), __ -> false);\n+                } else {\n+                    final Future<DnsAnswer<T>> addressFuture = doDnsQuery();\n+                    cancellableForQuery = () -> addressFuture.cancel(true);\n+                    if (addressFuture.isDone()) {\n+                        handleResolveDone0(addressFuture);\n+                    } else {\n+                        addressFuture.addListener((FutureListener<DnsAnswer<T>>) this::handleResolveDone0);\n+                    }\n+                }\n+            }\n+\n+            private void cancel0() {\n+                assertInEventloop();\n+\n+                removeFromWatchers();\n+                cancelWithoutRemove0(false);\n+            }\n+\n+            private void cancelWithoutRemove0(boolean tryGenerateInactiveEvents) {\n+                if (cancellableForQuery != null) {\n+                    cancellableForQuery = TERMINATED;\n+                    discoverySubscriber = null;\n+                    pendingRequests = -1;\n+                    cancellableForQuery.cancel();\n+                }\n+                if (tryGenerateInactiveEvents) {\n+                    if (activeAddresses.isEmpty() || pendingRequests > 0) {\n+                        terminateOnComplete();\n+                    } else {\n+                        cancellableForQuery = WAITING_FOR_REQUEST_N;\n+                    }\n+                }\n+            }\n+\n+            private void terminateOnComplete() {\n+                try {\n+                    clearAddressesAndPropagateRemovalEvents();\n+                } catch (Throwable cause) {\n+                    safeOnError(subscriber, cause);\n+                    return;\n+                }\n+                safeOnComplete(subscriber);\n+            }\n+\n+            private void scheduleQuery0(final long nanos) {\n+                assertInEventloop();\n+\n+                // This value is coming from DNS TTL for which the unit is seconds and the minimum value we accept\n+                // in the builder is 1 second.\n+                cancellableForQuery = nettyIoExecutor.asExecutor().schedule(\n+                        this::doQuery0, nanos, NANOSECONDS);\n+            }\n+\n+            private void handleResolveDone0(final Future<DnsAnswer<T>> addressFuture) {\n+                assertInEventloop();\n+\n+                // If `discoverySubscriber` is null, then this publisher has terminated, so we can't send any more\n+                // signals. There's no point in even scheduling a query in that case.\n+                if (discoverySubscriber != null) {\n+                    final Throwable cause = addressFuture.cause();\n+                    if (cause != null) {\n+                        handleError0(cause, invalidateHostsOnDnsFailure);\n+                    } else {\n+                        // DNS lookup can return duplicate InetAddress\n+                        DnsAnswer<T> dnsAnswer = addressFuture.getNow();\n+                        final List<T> addresses = dnsAnswer.answer();\n+                        final List<ServiceDiscovererEvent<T>> events = calculateDifference(activeAddresses, addresses);\n+                        ttlNanos = dnsAnswer.ttlNanos();\n+                        if (events != null) {\n+                            activeAddresses = addresses;\n+                            --pendingRequests;\n+                            if (pendingRequests > 0) {\n+                                scheduleQuery0(ttlNanos);\n+                            } else {\n+                                resolveDoneNoScheduleTime = nanoTime();\n+                                cancellableForQuery = null;\n+                            }\n+                            try {\n+                                subscriber.onNext(events);\n+                            } catch (final Throwable error) {\n+                                handleError0(error, __ -> false);\n+                            }\n+                        } else {\n+                            scheduleQuery0(ttlNanos);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            private void handleError0(final Throwable cause,\n+                                      final Predicate<Throwable> invalidateHostsOnDnsFailure) {\n+                assertInEventloop();\n+\n+                final boolean wasAlreadyTerminated = discoverySubscriber == null;\n+                discoverySubscriber = null; // allow sequential subscriptions\n+                cancel0();\n+                if (wasAlreadyTerminated) {\n+                    return;\n+                }\n+\n+                if (invalidateHostsOnDnsFailure.test(cause)) {\n+                    try {\n+                        clearAddressesAndPropagateRemovalEvents();\n+                    } catch (final Throwable e) {\n+                        logUnexpectedException(e);\n+                    }\n+                }\n+                safeOnError(subscriber, cause);\n+            }\n+\n+            private void logUnexpectedException(Throwable cause) {\n+                LOGGER.warn(\"Exception from subscriber {} while handling error in DNS subscription {}\",\n+                        subscriber, this, cause);\n+            }\n+\n+            @SuppressWarnings(\"ForLoopReplaceableByForEach\")\n+            private void clearAddressesAndPropagateRemovalEvents() {\n+                if (!activeAddresses.isEmpty()) {", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxNDIwNA==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409214204", "bodyText": "For the case when this is called from handleResolveDone0, we would have already decremented pendingRequests in handleResolveDone0.  Also, when called from cancelWithoutRemove0 we could have already set pendingRequests to -1. The assert and this decrement looks off here.", "author": "NiteshKant", "createdAt": "2020-04-16T00:41:02Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.CompletableSource.Processor;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribableCompletable;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtectionIfNotNegative;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable WAITING_FOR_REQUEST_N = () -> { };\n+\n+    private final Processor closeCompletable = newCompletableProcessor();\n+    private final Map<String, List<ARecordPublisher>> srvARecordMap = new HashMap<>(8);\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+        LOGGER.debug(\"Created a new DNS discoverer {} with minimum TTL (seconds): {}, ndots: {}, \" +\n+                        \"optResourceEnabled {}, dnsResolverAddressTypes {}, dnsServerAddressStreamProvider {}.\",\n+                this, minTTL, ndots, optResourceEnabled, dnsResolverAddressTypes, dnsServerAddressStreamProvider);\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                .<ServiceDiscovererEvent<InetSocketAddress>>flatMapMergeSingle(srvEvent -> {\n+            assertInEventloop();\n+\n+            if (srvEvent.isAvailable()) {\n+                ARecordPublisher entry = new ARecordPublisher(srvEvent.address().hostName()) {\n+                    @Override\n+                    protected void onFinallyCleanup() {\n+                        removeSrvEntry0(this);\n+                    }\n+                };\n+                addSrvEntry0(entry);\n+                return entry.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                        new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+                       ).firstOrElse(() -> {\n+                           throw new IllegalStateException(\"0 SRV records found. 1 SRV record is required!\");\n+                       });\n+            } else {\n+                final List<ARecordPublisher> inetWatchers = srvARecordMap.remove(srvEvent.address().hostName());\n+                if (inetWatchers != null) {\n+                    for (ARecordPublisher inetWatcher : inetWatchers) {\n+                        inetWatcher.close0();\n+                    }\n+                }\n+\n+                // We will filter the null value out on the outer flatMap transformation.\n+                return Single.succeeded(null);\n+            }\n+        })\n+        // When the SRV record becomes unavailable we clean up state and return a Single.succeeded(null), but\n+        // we don't want to propagate this downstream, so filter it out.\n+        .filter(Objects::nonNull);\n+    }\n+\n+    private void addSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        srvARecordMap.computeIfAbsent(entry.inetHost, k -> new ArrayList<>(2)).add(entry);\n+    }\n+\n+    private void removeSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        final List<ARecordPublisher> inetWatchers = srvARecordMap.get(entry.inetHost);\n+        if (inetWatchers == null) {\n+            return;\n+        }\n+        inetWatchers.remove(entry);\n+        if (inetWatchers.isEmpty()) {\n+            srvARecordMap.remove(entry.inetHost);\n+        }\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return fromSource(closeCompletable);\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return new SubscribableCompletable() {\n+            @Override\n+            protected void handleSubscribe(final CompletableSource.Subscriber subscriber) {\n+                closeCompletable.subscribe(subscriber);\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    closeAsync0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(DefaultDnsClient.this::closeAsync0);\n+                }\n+            }\n+        };\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+        closeCompletable.onComplete();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends EntriesPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(new DefaultDnsQuestion(serviceName, SRV))\n+                            .addListener((Future<? super List<DnsRecord>> completedFuture) -> {\n+                                Throwable cause = completedFuture.cause();\n+                                if (cause != null) {\n+                                    promise.setFailure(cause);\n+                                } else {\n+                                    final DnsAnswer<HostAndPort> dnsAnswer;\n+                                    long minTTLSeconds = Long.MAX_VALUE;\n+                                    try {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final List<DnsRecord> dnsRecords = (List<DnsRecord>) completedFuture.getNow();\n+                                        final List<HostAndPort> hostAndPorts = new ArrayList<>(dnsRecords.size());\n+                                        for (DnsRecord dnsRecord : dnsRecords) {\n+                                            if (!SRV.equals(dnsRecord.type()) || !(dnsRecord instanceof DnsRawRecord)) {\n+                                                throw new IllegalArgumentException(\n+                                                        \"Unsupported DNS record type for SRV query: \" + dnsRecord);\n+                                            }\n+                                            if (dnsRecord.timeToLive() < minTTLSeconds) {\n+                                                minTTLSeconds = dnsRecord.timeToLive();\n+                                            }\n+                                            ByteBuf content = ((DnsRawRecord) dnsRecord).content();\n+                                            // https://tools.ietf.org/html/rfc2782\n+                                            // Priority(16u) Weight(16u) Port(16u) Target(varstring)\n+                                            content.skipBytes(4); // ignore Priority and Weight for now\n+                                            final int port = content.readUnsignedShort();\n+                                            hostAndPorts.add(HostAndPort.of(decodeName(content), port));\n+                                        }\n+                                        dnsAnswer = new DnsAnswer<>(hostAndPorts, SECONDS.toNanos(minTTLSeconds));\n+                                    } catch (Throwable cause2) {\n+                                        promise.setFailure(cause2);\n+                                        return;\n+                                    }\n+                                    promise.setSuccess(dnsAnswer);\n+                                }\n+                            });\n+                    return promise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<HostAndPort>> calculateDifference(\n+                        final List<HostAndPort> previousList, final List<HostAndPort> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, HOST_AND_PORT_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                }\n+            };\n+        }\n+    }\n+\n+    private class ARecordPublisher extends EntriesPublisher<InetAddress> {\n+        private final String inetHost;\n+\n+        ARecordPublisher(String inetHost) {\n+            this.inetHost = inetHost;\n+        }\n+\n+        protected void onFinallyCleanup() {\n+            // overridable for any cleanup\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<InetAddress>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<InetAddress>> doDnsQuery() {\n+                    ttlCache.prepareForResolution(inetHost);\n+                    Promise<DnsAnswer<InetAddress>> dnsAnswerPromise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(inetHost).addListener(completedFuture -> {\n+                        Throwable cause = completedFuture.cause();\n+                        if (cause != null) {\n+                            dnsAnswerPromise.setFailure(cause);\n+                        } else {\n+                            final DnsAnswer<InetAddress> dnsAnswer;\n+                            try {\n+                                @SuppressWarnings(\"unchecked\")\n+                                final List<InetAddress> addresses = (List<InetAddress>) completedFuture.getNow();\n+                                dnsAnswer = new DnsAnswer<>(addresses, SECONDS.toNanos(ttlCache.minTtl(inetHost)));\n+                            } catch (Throwable cause2) {\n+                                dnsAnswerPromise.setFailure(cause2);\n+                                return;\n+                            }\n+                            dnsAnswerPromise.setSuccess(dnsAnswer);\n+                        }\n+                    });\n+                    return dnsAnswerPromise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<InetAddress>> calculateDifference(\n+                        final List<InetAddress> previousList, final List<InetAddress> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, INET_ADDRESS_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                    onFinallyCleanup();\n+                }\n+            };\n+        }\n+    }\n+\n+    private static final class DnsAnswer<T> {\n+        private final List<T> answer;\n+        private final long ttlNanos;\n+\n+        DnsAnswer(final List<T> answer, final long ttlNanos) {\n+            this.answer = answer;\n+            this.ttlNanos = ttlNanos;\n+        }\n+\n+        List<T> answer() {\n+            return answer;\n+        }\n+\n+        long ttlNanos() {\n+            return ttlNanos;\n+        }\n+    }\n+\n+    private abstract class EntriesPublisher<T>\n+            extends SubscribablePublisher<Iterable<ServiceDiscovererEvent<T>>> {\n+        @Nullable\n+        private Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> discoverySubscriber;\n+        @Nullable\n+        private AbstractEntriesPublisherSubscription subscription;\n+\n+        protected abstract AbstractEntriesPublisherSubscription\n+        newSubscription(Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber);\n+\n+        @Override\n+        protected final void handleSubscribe(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                handleSubscribe0(subscriber);\n+            } else {\n+                nettyIoExecutor.asExecutor().execute(() -> handleSubscribe0(subscriber));\n+            }\n+        }\n+\n+        private void handleSubscribe0(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            assertInEventloop();\n+\n+            if (discoverySubscriber != null) {\n+                deliverTerminalFromSource(subscriber,\n+                        new DuplicateSubscribeException(discoverySubscriber, subscriber));\n+            } else if (closed) {\n+                deliverTerminalFromSource(subscriber,\n+                        new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                                \" has been closed!\"));\n+            } else {\n+                subscription = newSubscription(subscriber);\n+                discoverySubscriber = subscriber;\n+                subscriber.onSubscribe(subscription);\n+            }\n+        }\n+\n+        final void close0() {\n+            assertInEventloop();\n+\n+            final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> oldSubscriber = discoverySubscriber;\n+            discoverySubscriber = null;\n+            if (oldSubscriber != null) {\n+                assert subscription != null;\n+                subscription.cancelWithoutRemove0(true);\n+            }\n+        }\n+\n+        abstract class AbstractEntriesPublisherSubscription implements Subscription {\n+            private final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber;\n+            private long pendingRequests;\n+            private List<T> activeAddresses;\n+            private long resolveDoneNoScheduleTime;\n+            @Nullable\n+            private Cancellable cancellableForQuery;\n+            private long ttlNanos;\n+\n+            AbstractEntriesPublisherSubscription(\n+                    final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+                this.subscriber = subscriber;\n+                activeAddresses = emptyList();\n+                ttlNanos = -1;\n+            }\n+\n+            protected abstract Future<DnsAnswer<T>> doDnsQuery();\n+\n+            @Nullable\n+            protected abstract List<ServiceDiscovererEvent<T>>\n+            calculateDifference(List<T> previousList, List<T> newList);\n+\n+            protected abstract void removeFromWatchers();\n+\n+            @Override\n+            public final void request(final long n) {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    request0(n);\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(() -> request0(n));\n+                }\n+            }\n+\n+            @Override\n+            public final void cancel() {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    cancel0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(this::cancel0);\n+                }\n+            }\n+\n+            private void request0(final long n) {\n+                assertInEventloop();\n+\n+                if (!isRequestNValid(n)) {\n+                    handleError0(newExceptionForInvalidRequestN(n), __ -> false);\n+                    return;\n+                }\n+\n+                pendingRequests = addWithOverflowProtectionIfNotNegative(pendingRequests, n);\n+                if (cancellableForQuery == null) {\n+                    if (ttlNanos < 0) {\n+                        doQuery0();\n+                    } else {\n+                        final long durationNs = nanoTime() - resolveDoneNoScheduleTime;\n+                        if (durationNs > ttlNanos) {\n+                            doQuery0();\n+                        } else {\n+                            scheduleQuery0(ttlNanos - durationNs);\n+                        }\n+                    }\n+                } else if (cancellableForQuery == WAITING_FOR_REQUEST_N) {\n+                    cancellableForQuery = TERMINATED;\n+                    terminateOnComplete();\n+                }\n+            }\n+\n+            private void doQuery0() {\n+                assertInEventloop();\n+\n+                if (closed) {\n+                    // best effort check to cleanup state after close.\n+                    handleError0(new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                            \" has been closed!\"), __ -> false);\n+                } else {\n+                    final Future<DnsAnswer<T>> addressFuture = doDnsQuery();\n+                    cancellableForQuery = () -> addressFuture.cancel(true);\n+                    if (addressFuture.isDone()) {\n+                        handleResolveDone0(addressFuture);\n+                    } else {\n+                        addressFuture.addListener((FutureListener<DnsAnswer<T>>) this::handleResolveDone0);\n+                    }\n+                }\n+            }\n+\n+            private void cancel0() {\n+                assertInEventloop();\n+\n+                removeFromWatchers();\n+                cancelWithoutRemove0(false);\n+            }\n+\n+            private void cancelWithoutRemove0(boolean tryGenerateInactiveEvents) {\n+                if (cancellableForQuery != null) {\n+                    cancellableForQuery = TERMINATED;\n+                    discoverySubscriber = null;\n+                    pendingRequests = -1;\n+                    cancellableForQuery.cancel();\n+                }\n+                if (tryGenerateInactiveEvents) {\n+                    if (activeAddresses.isEmpty() || pendingRequests > 0) {\n+                        terminateOnComplete();\n+                    } else {\n+                        cancellableForQuery = WAITING_FOR_REQUEST_N;\n+                    }\n+                }\n+            }\n+\n+            private void terminateOnComplete() {\n+                try {\n+                    clearAddressesAndPropagateRemovalEvents();\n+                } catch (Throwable cause) {\n+                    safeOnError(subscriber, cause);\n+                    return;\n+                }\n+                safeOnComplete(subscriber);\n+            }\n+\n+            private void scheduleQuery0(final long nanos) {\n+                assertInEventloop();\n+\n+                // This value is coming from DNS TTL for which the unit is seconds and the minimum value we accept\n+                // in the builder is 1 second.\n+                cancellableForQuery = nettyIoExecutor.asExecutor().schedule(\n+                        this::doQuery0, nanos, NANOSECONDS);\n+            }\n+\n+            private void handleResolveDone0(final Future<DnsAnswer<T>> addressFuture) {\n+                assertInEventloop();\n+\n+                // If `discoverySubscriber` is null, then this publisher has terminated, so we can't send any more\n+                // signals. There's no point in even scheduling a query in that case.\n+                if (discoverySubscriber != null) {\n+                    final Throwable cause = addressFuture.cause();\n+                    if (cause != null) {\n+                        handleError0(cause, invalidateHostsOnDnsFailure);\n+                    } else {\n+                        // DNS lookup can return duplicate InetAddress\n+                        DnsAnswer<T> dnsAnswer = addressFuture.getNow();\n+                        final List<T> addresses = dnsAnswer.answer();\n+                        final List<ServiceDiscovererEvent<T>> events = calculateDifference(activeAddresses, addresses);\n+                        ttlNanos = dnsAnswer.ttlNanos();\n+                        if (events != null) {\n+                            activeAddresses = addresses;\n+                            --pendingRequests;\n+                            if (pendingRequests > 0) {\n+                                scheduleQuery0(ttlNanos);\n+                            } else {\n+                                resolveDoneNoScheduleTime = nanoTime();\n+                                cancellableForQuery = null;\n+                            }\n+                            try {\n+                                subscriber.onNext(events);\n+                            } catch (final Throwable error) {\n+                                handleError0(error, __ -> false);\n+                            }\n+                        } else {\n+                            scheduleQuery0(ttlNanos);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            private void handleError0(final Throwable cause,\n+                                      final Predicate<Throwable> invalidateHostsOnDnsFailure) {\n+                assertInEventloop();\n+\n+                final boolean wasAlreadyTerminated = discoverySubscriber == null;\n+                discoverySubscriber = null; // allow sequential subscriptions\n+                cancel0();\n+                if (wasAlreadyTerminated) {\n+                    return;\n+                }\n+\n+                if (invalidateHostsOnDnsFailure.test(cause)) {\n+                    try {\n+                        clearAddressesAndPropagateRemovalEvents();\n+                    } catch (final Throwable e) {\n+                        logUnexpectedException(e);\n+                    }\n+                }\n+                safeOnError(subscriber, cause);\n+            }\n+\n+            private void logUnexpectedException(Throwable cause) {\n+                LOGGER.warn(\"Exception from subscriber {} while handling error in DNS subscription {}\",\n+                        subscriber, this, cause);\n+            }\n+\n+            @SuppressWarnings(\"ForLoopReplaceableByForEach\")\n+            private void clearAddressesAndPropagateRemovalEvents() {\n+                if (!activeAddresses.isEmpty()) {\n+                    // cleanup code may invoke this method after pendingRequests is set to negative\n+                    assert pendingRequests != 0;\n+                    --pendingRequests;", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI0Njg2Nw==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409246867", "bodyText": "the predicate in handleResolveDone0 doesn't allow this method to be called after onNext ... however I agree the control flow is convoluted here let me fix this up", "author": "Scottmitch", "createdAt": "2020-04-16T02:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxNDIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxNjE1NQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409216155", "bodyText": "This method is only called from 2 places with distinct values fortryGenerateInactiveEvents. The method name containing cancel does not indicate that we also send terminal event. Can we move the logic inside this if to the place where it is required? It will make the code flow easier to understand.", "author": "NiteshKant", "createdAt": "2020-04-16T00:48:09Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.CompletableSource.Processor;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribableCompletable;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtectionIfNotNegative;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable WAITING_FOR_REQUEST_N = () -> { };\n+\n+    private final Processor closeCompletable = newCompletableProcessor();\n+    private final Map<String, List<ARecordPublisher>> srvARecordMap = new HashMap<>(8);\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+        LOGGER.debug(\"Created a new DNS discoverer {} with minimum TTL (seconds): {}, ndots: {}, \" +\n+                        \"optResourceEnabled {}, dnsResolverAddressTypes {}, dnsServerAddressStreamProvider {}.\",\n+                this, minTTL, ndots, optResourceEnabled, dnsResolverAddressTypes, dnsServerAddressStreamProvider);\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                .<ServiceDiscovererEvent<InetSocketAddress>>flatMapMergeSingle(srvEvent -> {\n+            assertInEventloop();\n+\n+            if (srvEvent.isAvailable()) {\n+                ARecordPublisher entry = new ARecordPublisher(srvEvent.address().hostName()) {\n+                    @Override\n+                    protected void onFinallyCleanup() {\n+                        removeSrvEntry0(this);\n+                    }\n+                };\n+                addSrvEntry0(entry);\n+                return entry.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                        new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+                       ).firstOrElse(() -> {\n+                           throw new IllegalStateException(\"0 SRV records found. 1 SRV record is required!\");\n+                       });\n+            } else {\n+                final List<ARecordPublisher> inetWatchers = srvARecordMap.remove(srvEvent.address().hostName());\n+                if (inetWatchers != null) {\n+                    for (ARecordPublisher inetWatcher : inetWatchers) {\n+                        inetWatcher.close0();\n+                    }\n+                }\n+\n+                // We will filter the null value out on the outer flatMap transformation.\n+                return Single.succeeded(null);\n+            }\n+        })\n+        // When the SRV record becomes unavailable we clean up state and return a Single.succeeded(null), but\n+        // we don't want to propagate this downstream, so filter it out.\n+        .filter(Objects::nonNull);\n+    }\n+\n+    private void addSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        srvARecordMap.computeIfAbsent(entry.inetHost, k -> new ArrayList<>(2)).add(entry);\n+    }\n+\n+    private void removeSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        final List<ARecordPublisher> inetWatchers = srvARecordMap.get(entry.inetHost);\n+        if (inetWatchers == null) {\n+            return;\n+        }\n+        inetWatchers.remove(entry);\n+        if (inetWatchers.isEmpty()) {\n+            srvARecordMap.remove(entry.inetHost);\n+        }\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return fromSource(closeCompletable);\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return new SubscribableCompletable() {\n+            @Override\n+            protected void handleSubscribe(final CompletableSource.Subscriber subscriber) {\n+                closeCompletable.subscribe(subscriber);\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    closeAsync0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(DefaultDnsClient.this::closeAsync0);\n+                }\n+            }\n+        };\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+        closeCompletable.onComplete();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends EntriesPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(new DefaultDnsQuestion(serviceName, SRV))\n+                            .addListener((Future<? super List<DnsRecord>> completedFuture) -> {\n+                                Throwable cause = completedFuture.cause();\n+                                if (cause != null) {\n+                                    promise.setFailure(cause);\n+                                } else {\n+                                    final DnsAnswer<HostAndPort> dnsAnswer;\n+                                    long minTTLSeconds = Long.MAX_VALUE;\n+                                    try {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final List<DnsRecord> dnsRecords = (List<DnsRecord>) completedFuture.getNow();\n+                                        final List<HostAndPort> hostAndPorts = new ArrayList<>(dnsRecords.size());\n+                                        for (DnsRecord dnsRecord : dnsRecords) {\n+                                            if (!SRV.equals(dnsRecord.type()) || !(dnsRecord instanceof DnsRawRecord)) {\n+                                                throw new IllegalArgumentException(\n+                                                        \"Unsupported DNS record type for SRV query: \" + dnsRecord);\n+                                            }\n+                                            if (dnsRecord.timeToLive() < minTTLSeconds) {\n+                                                minTTLSeconds = dnsRecord.timeToLive();\n+                                            }\n+                                            ByteBuf content = ((DnsRawRecord) dnsRecord).content();\n+                                            // https://tools.ietf.org/html/rfc2782\n+                                            // Priority(16u) Weight(16u) Port(16u) Target(varstring)\n+                                            content.skipBytes(4); // ignore Priority and Weight for now\n+                                            final int port = content.readUnsignedShort();\n+                                            hostAndPorts.add(HostAndPort.of(decodeName(content), port));\n+                                        }\n+                                        dnsAnswer = new DnsAnswer<>(hostAndPorts, SECONDS.toNanos(minTTLSeconds));\n+                                    } catch (Throwable cause2) {\n+                                        promise.setFailure(cause2);\n+                                        return;\n+                                    }\n+                                    promise.setSuccess(dnsAnswer);\n+                                }\n+                            });\n+                    return promise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<HostAndPort>> calculateDifference(\n+                        final List<HostAndPort> previousList, final List<HostAndPort> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, HOST_AND_PORT_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                }\n+            };\n+        }\n+    }\n+\n+    private class ARecordPublisher extends EntriesPublisher<InetAddress> {\n+        private final String inetHost;\n+\n+        ARecordPublisher(String inetHost) {\n+            this.inetHost = inetHost;\n+        }\n+\n+        protected void onFinallyCleanup() {\n+            // overridable for any cleanup\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<InetAddress>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<InetAddress>> doDnsQuery() {\n+                    ttlCache.prepareForResolution(inetHost);\n+                    Promise<DnsAnswer<InetAddress>> dnsAnswerPromise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(inetHost).addListener(completedFuture -> {\n+                        Throwable cause = completedFuture.cause();\n+                        if (cause != null) {\n+                            dnsAnswerPromise.setFailure(cause);\n+                        } else {\n+                            final DnsAnswer<InetAddress> dnsAnswer;\n+                            try {\n+                                @SuppressWarnings(\"unchecked\")\n+                                final List<InetAddress> addresses = (List<InetAddress>) completedFuture.getNow();\n+                                dnsAnswer = new DnsAnswer<>(addresses, SECONDS.toNanos(ttlCache.minTtl(inetHost)));\n+                            } catch (Throwable cause2) {\n+                                dnsAnswerPromise.setFailure(cause2);\n+                                return;\n+                            }\n+                            dnsAnswerPromise.setSuccess(dnsAnswer);\n+                        }\n+                    });\n+                    return dnsAnswerPromise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<InetAddress>> calculateDifference(\n+                        final List<InetAddress> previousList, final List<InetAddress> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, INET_ADDRESS_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                    onFinallyCleanup();\n+                }\n+            };\n+        }\n+    }\n+\n+    private static final class DnsAnswer<T> {\n+        private final List<T> answer;\n+        private final long ttlNanos;\n+\n+        DnsAnswer(final List<T> answer, final long ttlNanos) {\n+            this.answer = answer;\n+            this.ttlNanos = ttlNanos;\n+        }\n+\n+        List<T> answer() {\n+            return answer;\n+        }\n+\n+        long ttlNanos() {\n+            return ttlNanos;\n+        }\n+    }\n+\n+    private abstract class EntriesPublisher<T>\n+            extends SubscribablePublisher<Iterable<ServiceDiscovererEvent<T>>> {\n+        @Nullable\n+        private Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> discoverySubscriber;\n+        @Nullable\n+        private AbstractEntriesPublisherSubscription subscription;\n+\n+        protected abstract AbstractEntriesPublisherSubscription\n+        newSubscription(Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber);\n+\n+        @Override\n+        protected final void handleSubscribe(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                handleSubscribe0(subscriber);\n+            } else {\n+                nettyIoExecutor.asExecutor().execute(() -> handleSubscribe0(subscriber));\n+            }\n+        }\n+\n+        private void handleSubscribe0(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            assertInEventloop();\n+\n+            if (discoverySubscriber != null) {\n+                deliverTerminalFromSource(subscriber,\n+                        new DuplicateSubscribeException(discoverySubscriber, subscriber));\n+            } else if (closed) {\n+                deliverTerminalFromSource(subscriber,\n+                        new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                                \" has been closed!\"));\n+            } else {\n+                subscription = newSubscription(subscriber);\n+                discoverySubscriber = subscriber;\n+                subscriber.onSubscribe(subscription);\n+            }\n+        }\n+\n+        final void close0() {\n+            assertInEventloop();\n+\n+            final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> oldSubscriber = discoverySubscriber;\n+            discoverySubscriber = null;\n+            if (oldSubscriber != null) {\n+                assert subscription != null;\n+                subscription.cancelWithoutRemove0(true);\n+            }\n+        }\n+\n+        abstract class AbstractEntriesPublisherSubscription implements Subscription {\n+            private final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber;\n+            private long pendingRequests;\n+            private List<T> activeAddresses;\n+            private long resolveDoneNoScheduleTime;\n+            @Nullable\n+            private Cancellable cancellableForQuery;\n+            private long ttlNanos;\n+\n+            AbstractEntriesPublisherSubscription(\n+                    final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+                this.subscriber = subscriber;\n+                activeAddresses = emptyList();\n+                ttlNanos = -1;\n+            }\n+\n+            protected abstract Future<DnsAnswer<T>> doDnsQuery();\n+\n+            @Nullable\n+            protected abstract List<ServiceDiscovererEvent<T>>\n+            calculateDifference(List<T> previousList, List<T> newList);\n+\n+            protected abstract void removeFromWatchers();\n+\n+            @Override\n+            public final void request(final long n) {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    request0(n);\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(() -> request0(n));\n+                }\n+            }\n+\n+            @Override\n+            public final void cancel() {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    cancel0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(this::cancel0);\n+                }\n+            }\n+\n+            private void request0(final long n) {\n+                assertInEventloop();\n+\n+                if (!isRequestNValid(n)) {\n+                    handleError0(newExceptionForInvalidRequestN(n), __ -> false);\n+                    return;\n+                }\n+\n+                pendingRequests = addWithOverflowProtectionIfNotNegative(pendingRequests, n);\n+                if (cancellableForQuery == null) {\n+                    if (ttlNanos < 0) {\n+                        doQuery0();\n+                    } else {\n+                        final long durationNs = nanoTime() - resolveDoneNoScheduleTime;\n+                        if (durationNs > ttlNanos) {\n+                            doQuery0();\n+                        } else {\n+                            scheduleQuery0(ttlNanos - durationNs);\n+                        }\n+                    }\n+                } else if (cancellableForQuery == WAITING_FOR_REQUEST_N) {\n+                    cancellableForQuery = TERMINATED;\n+                    terminateOnComplete();\n+                }\n+            }\n+\n+            private void doQuery0() {\n+                assertInEventloop();\n+\n+                if (closed) {\n+                    // best effort check to cleanup state after close.\n+                    handleError0(new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                            \" has been closed!\"), __ -> false);\n+                } else {\n+                    final Future<DnsAnswer<T>> addressFuture = doDnsQuery();\n+                    cancellableForQuery = () -> addressFuture.cancel(true);\n+                    if (addressFuture.isDone()) {\n+                        handleResolveDone0(addressFuture);\n+                    } else {\n+                        addressFuture.addListener((FutureListener<DnsAnswer<T>>) this::handleResolveDone0);\n+                    }\n+                }\n+            }\n+\n+            private void cancel0() {\n+                assertInEventloop();\n+\n+                removeFromWatchers();\n+                cancelWithoutRemove0(false);\n+            }\n+\n+            private void cancelWithoutRemove0(boolean tryGenerateInactiveEvents) {\n+                if (cancellableForQuery != null) {\n+                    cancellableForQuery = TERMINATED;\n+                    discoverySubscriber = null;\n+                    pendingRequests = -1;\n+                    cancellableForQuery.cancel();\n+                }\n+                if (tryGenerateInactiveEvents) {", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxNjQyMQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409216421", "bodyText": "Previously we were sending an error to the subscriber upon close() but now we are sending onComplete(). Can we revert to sending error which seems more appropriate due to the close.", "author": "NiteshKant", "createdAt": "2020-04-16T00:49:01Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.CompletableSource.Processor;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribableCompletable;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtectionIfNotNegative;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable WAITING_FOR_REQUEST_N = () -> { };\n+\n+    private final Processor closeCompletable = newCompletableProcessor();\n+    private final Map<String, List<ARecordPublisher>> srvARecordMap = new HashMap<>(8);\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+        LOGGER.debug(\"Created a new DNS discoverer {} with minimum TTL (seconds): {}, ndots: {}, \" +\n+                        \"optResourceEnabled {}, dnsResolverAddressTypes {}, dnsServerAddressStreamProvider {}.\",\n+                this, minTTL, ndots, optResourceEnabled, dnsResolverAddressTypes, dnsServerAddressStreamProvider);\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                .<ServiceDiscovererEvent<InetSocketAddress>>flatMapMergeSingle(srvEvent -> {\n+            assertInEventloop();\n+\n+            if (srvEvent.isAvailable()) {\n+                ARecordPublisher entry = new ARecordPublisher(srvEvent.address().hostName()) {\n+                    @Override\n+                    protected void onFinallyCleanup() {\n+                        removeSrvEntry0(this);\n+                    }\n+                };\n+                addSrvEntry0(entry);\n+                return entry.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                        new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+                       ).firstOrElse(() -> {\n+                           throw new IllegalStateException(\"0 SRV records found. 1 SRV record is required!\");\n+                       });\n+            } else {\n+                final List<ARecordPublisher> inetWatchers = srvARecordMap.remove(srvEvent.address().hostName());\n+                if (inetWatchers != null) {\n+                    for (ARecordPublisher inetWatcher : inetWatchers) {\n+                        inetWatcher.close0();\n+                    }\n+                }\n+\n+                // We will filter the null value out on the outer flatMap transformation.\n+                return Single.succeeded(null);\n+            }\n+        })\n+        // When the SRV record becomes unavailable we clean up state and return a Single.succeeded(null), but\n+        // we don't want to propagate this downstream, so filter it out.\n+        .filter(Objects::nonNull);\n+    }\n+\n+    private void addSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        srvARecordMap.computeIfAbsent(entry.inetHost, k -> new ArrayList<>(2)).add(entry);\n+    }\n+\n+    private void removeSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        final List<ARecordPublisher> inetWatchers = srvARecordMap.get(entry.inetHost);\n+        if (inetWatchers == null) {\n+            return;\n+        }\n+        inetWatchers.remove(entry);\n+        if (inetWatchers.isEmpty()) {\n+            srvARecordMap.remove(entry.inetHost);\n+        }\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return fromSource(closeCompletable);\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return new SubscribableCompletable() {\n+            @Override\n+            protected void handleSubscribe(final CompletableSource.Subscriber subscriber) {\n+                closeCompletable.subscribe(subscriber);\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    closeAsync0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(DefaultDnsClient.this::closeAsync0);\n+                }\n+            }\n+        };\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+        closeCompletable.onComplete();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends EntriesPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(new DefaultDnsQuestion(serviceName, SRV))\n+                            .addListener((Future<? super List<DnsRecord>> completedFuture) -> {\n+                                Throwable cause = completedFuture.cause();\n+                                if (cause != null) {\n+                                    promise.setFailure(cause);\n+                                } else {\n+                                    final DnsAnswer<HostAndPort> dnsAnswer;\n+                                    long minTTLSeconds = Long.MAX_VALUE;\n+                                    try {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final List<DnsRecord> dnsRecords = (List<DnsRecord>) completedFuture.getNow();\n+                                        final List<HostAndPort> hostAndPorts = new ArrayList<>(dnsRecords.size());\n+                                        for (DnsRecord dnsRecord : dnsRecords) {\n+                                            if (!SRV.equals(dnsRecord.type()) || !(dnsRecord instanceof DnsRawRecord)) {\n+                                                throw new IllegalArgumentException(\n+                                                        \"Unsupported DNS record type for SRV query: \" + dnsRecord);\n+                                            }\n+                                            if (dnsRecord.timeToLive() < minTTLSeconds) {\n+                                                minTTLSeconds = dnsRecord.timeToLive();\n+                                            }\n+                                            ByteBuf content = ((DnsRawRecord) dnsRecord).content();\n+                                            // https://tools.ietf.org/html/rfc2782\n+                                            // Priority(16u) Weight(16u) Port(16u) Target(varstring)\n+                                            content.skipBytes(4); // ignore Priority and Weight for now\n+                                            final int port = content.readUnsignedShort();\n+                                            hostAndPorts.add(HostAndPort.of(decodeName(content), port));\n+                                        }\n+                                        dnsAnswer = new DnsAnswer<>(hostAndPorts, SECONDS.toNanos(minTTLSeconds));\n+                                    } catch (Throwable cause2) {\n+                                        promise.setFailure(cause2);\n+                                        return;\n+                                    }\n+                                    promise.setSuccess(dnsAnswer);\n+                                }\n+                            });\n+                    return promise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<HostAndPort>> calculateDifference(\n+                        final List<HostAndPort> previousList, final List<HostAndPort> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, HOST_AND_PORT_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                }\n+            };\n+        }\n+    }\n+\n+    private class ARecordPublisher extends EntriesPublisher<InetAddress> {\n+        private final String inetHost;\n+\n+        ARecordPublisher(String inetHost) {\n+            this.inetHost = inetHost;\n+        }\n+\n+        protected void onFinallyCleanup() {\n+            // overridable for any cleanup\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<InetAddress>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<InetAddress>> doDnsQuery() {\n+                    ttlCache.prepareForResolution(inetHost);\n+                    Promise<DnsAnswer<InetAddress>> dnsAnswerPromise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(inetHost).addListener(completedFuture -> {\n+                        Throwable cause = completedFuture.cause();\n+                        if (cause != null) {\n+                            dnsAnswerPromise.setFailure(cause);\n+                        } else {\n+                            final DnsAnswer<InetAddress> dnsAnswer;\n+                            try {\n+                                @SuppressWarnings(\"unchecked\")\n+                                final List<InetAddress> addresses = (List<InetAddress>) completedFuture.getNow();\n+                                dnsAnswer = new DnsAnswer<>(addresses, SECONDS.toNanos(ttlCache.minTtl(inetHost)));\n+                            } catch (Throwable cause2) {\n+                                dnsAnswerPromise.setFailure(cause2);\n+                                return;\n+                            }\n+                            dnsAnswerPromise.setSuccess(dnsAnswer);\n+                        }\n+                    });\n+                    return dnsAnswerPromise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<InetAddress>> calculateDifference(\n+                        final List<InetAddress> previousList, final List<InetAddress> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, INET_ADDRESS_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                    onFinallyCleanup();\n+                }\n+            };\n+        }\n+    }\n+\n+    private static final class DnsAnswer<T> {\n+        private final List<T> answer;\n+        private final long ttlNanos;\n+\n+        DnsAnswer(final List<T> answer, final long ttlNanos) {\n+            this.answer = answer;\n+            this.ttlNanos = ttlNanos;\n+        }\n+\n+        List<T> answer() {\n+            return answer;\n+        }\n+\n+        long ttlNanos() {\n+            return ttlNanos;\n+        }\n+    }\n+\n+    private abstract class EntriesPublisher<T>\n+            extends SubscribablePublisher<Iterable<ServiceDiscovererEvent<T>>> {\n+        @Nullable\n+        private Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> discoverySubscriber;\n+        @Nullable\n+        private AbstractEntriesPublisherSubscription subscription;\n+\n+        protected abstract AbstractEntriesPublisherSubscription\n+        newSubscription(Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber);\n+\n+        @Override\n+        protected final void handleSubscribe(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                handleSubscribe0(subscriber);\n+            } else {\n+                nettyIoExecutor.asExecutor().execute(() -> handleSubscribe0(subscriber));\n+            }\n+        }\n+\n+        private void handleSubscribe0(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            assertInEventloop();\n+\n+            if (discoverySubscriber != null) {\n+                deliverTerminalFromSource(subscriber,\n+                        new DuplicateSubscribeException(discoverySubscriber, subscriber));\n+            } else if (closed) {\n+                deliverTerminalFromSource(subscriber,\n+                        new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                                \" has been closed!\"));\n+            } else {\n+                subscription = newSubscription(subscriber);\n+                discoverySubscriber = subscriber;\n+                subscriber.onSubscribe(subscription);\n+            }\n+        }\n+\n+        final void close0() {\n+            assertInEventloop();\n+\n+            final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> oldSubscriber = discoverySubscriber;\n+            discoverySubscriber = null;\n+            if (oldSubscriber != null) {\n+                assert subscription != null;\n+                subscription.cancelWithoutRemove0(true);\n+            }\n+        }\n+\n+        abstract class AbstractEntriesPublisherSubscription implements Subscription {\n+            private final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber;\n+            private long pendingRequests;\n+            private List<T> activeAddresses;\n+            private long resolveDoneNoScheduleTime;\n+            @Nullable\n+            private Cancellable cancellableForQuery;\n+            private long ttlNanos;\n+\n+            AbstractEntriesPublisherSubscription(\n+                    final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+                this.subscriber = subscriber;\n+                activeAddresses = emptyList();\n+                ttlNanos = -1;\n+            }\n+\n+            protected abstract Future<DnsAnswer<T>> doDnsQuery();\n+\n+            @Nullable\n+            protected abstract List<ServiceDiscovererEvent<T>>\n+            calculateDifference(List<T> previousList, List<T> newList);\n+\n+            protected abstract void removeFromWatchers();\n+\n+            @Override\n+            public final void request(final long n) {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    request0(n);\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(() -> request0(n));\n+                }\n+            }\n+\n+            @Override\n+            public final void cancel() {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    cancel0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(this::cancel0);\n+                }\n+            }\n+\n+            private void request0(final long n) {\n+                assertInEventloop();\n+\n+                if (!isRequestNValid(n)) {\n+                    handleError0(newExceptionForInvalidRequestN(n), __ -> false);\n+                    return;\n+                }\n+\n+                pendingRequests = addWithOverflowProtectionIfNotNegative(pendingRequests, n);\n+                if (cancellableForQuery == null) {\n+                    if (ttlNanos < 0) {\n+                        doQuery0();\n+                    } else {\n+                        final long durationNs = nanoTime() - resolveDoneNoScheduleTime;\n+                        if (durationNs > ttlNanos) {\n+                            doQuery0();\n+                        } else {\n+                            scheduleQuery0(ttlNanos - durationNs);\n+                        }\n+                    }\n+                } else if (cancellableForQuery == WAITING_FOR_REQUEST_N) {\n+                    cancellableForQuery = TERMINATED;\n+                    terminateOnComplete();\n+                }\n+            }\n+\n+            private void doQuery0() {\n+                assertInEventloop();\n+\n+                if (closed) {\n+                    // best effort check to cleanup state after close.\n+                    handleError0(new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                            \" has been closed!\"), __ -> false);\n+                } else {\n+                    final Future<DnsAnswer<T>> addressFuture = doDnsQuery();\n+                    cancellableForQuery = () -> addressFuture.cancel(true);\n+                    if (addressFuture.isDone()) {\n+                        handleResolveDone0(addressFuture);\n+                    } else {\n+                        addressFuture.addListener((FutureListener<DnsAnswer<T>>) this::handleResolveDone0);\n+                    }\n+                }\n+            }\n+\n+            private void cancel0() {\n+                assertInEventloop();\n+\n+                removeFromWatchers();\n+                cancelWithoutRemove0(false);\n+            }\n+\n+            private void cancelWithoutRemove0(boolean tryGenerateInactiveEvents) {\n+                if (cancellableForQuery != null) {\n+                    cancellableForQuery = TERMINATED;\n+                    discoverySubscriber = null;\n+                    pendingRequests = -1;\n+                    cancellableForQuery.cancel();\n+                }\n+                if (tryGenerateInactiveEvents) {\n+                    if (activeAddresses.isEmpty() || pendingRequests > 0) {\n+                        terminateOnComplete();", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2NTIwNA==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409265204", "bodyText": "the close operation on the publisher is only used when the SRV resolution comes back as \"unavailable\" we then lookup the corresponding ARecordPublisher and close it. In this case we want the publisher to complete normally so in the case of Publisher#flatMapMerge it shouldn't take down the entire stream.", "author": "Scottmitch", "createdAt": "2020-04-16T03:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxNjQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxODU5NA==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409218594", "bodyText": "I think renaming WAITING_FOR_REQUEST_N => TERMINATE_ON_NEXT_REQUEST_N or something that indicates the intent correctly will be more intuitive.", "author": "NiteshKant", "createdAt": "2020-04-16T00:56:45Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.CompletableSource.Processor;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribableCompletable;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtectionIfNotNegative;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable WAITING_FOR_REQUEST_N = () -> { };\n+\n+    private final Processor closeCompletable = newCompletableProcessor();\n+    private final Map<String, List<ARecordPublisher>> srvARecordMap = new HashMap<>(8);\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+        LOGGER.debug(\"Created a new DNS discoverer {} with minimum TTL (seconds): {}, ndots: {}, \" +\n+                        \"optResourceEnabled {}, dnsResolverAddressTypes {}, dnsServerAddressStreamProvider {}.\",\n+                this, minTTL, ndots, optResourceEnabled, dnsResolverAddressTypes, dnsServerAddressStreamProvider);\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                .<ServiceDiscovererEvent<InetSocketAddress>>flatMapMergeSingle(srvEvent -> {\n+            assertInEventloop();\n+\n+            if (srvEvent.isAvailable()) {\n+                ARecordPublisher entry = new ARecordPublisher(srvEvent.address().hostName()) {\n+                    @Override\n+                    protected void onFinallyCleanup() {\n+                        removeSrvEntry0(this);\n+                    }\n+                };\n+                addSrvEntry0(entry);\n+                return entry.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                        new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+                       ).firstOrElse(() -> {\n+                           throw new IllegalStateException(\"0 SRV records found. 1 SRV record is required!\");\n+                       });\n+            } else {\n+                final List<ARecordPublisher> inetWatchers = srvARecordMap.remove(srvEvent.address().hostName());\n+                if (inetWatchers != null) {\n+                    for (ARecordPublisher inetWatcher : inetWatchers) {\n+                        inetWatcher.close0();\n+                    }\n+                }\n+\n+                // We will filter the null value out on the outer flatMap transformation.\n+                return Single.succeeded(null);\n+            }\n+        })\n+        // When the SRV record becomes unavailable we clean up state and return a Single.succeeded(null), but\n+        // we don't want to propagate this downstream, so filter it out.\n+        .filter(Objects::nonNull);\n+    }\n+\n+    private void addSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        srvARecordMap.computeIfAbsent(entry.inetHost, k -> new ArrayList<>(2)).add(entry);\n+    }\n+\n+    private void removeSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        final List<ARecordPublisher> inetWatchers = srvARecordMap.get(entry.inetHost);\n+        if (inetWatchers == null) {\n+            return;\n+        }\n+        inetWatchers.remove(entry);\n+        if (inetWatchers.isEmpty()) {\n+            srvARecordMap.remove(entry.inetHost);\n+        }\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return fromSource(closeCompletable);\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return new SubscribableCompletable() {\n+            @Override\n+            protected void handleSubscribe(final CompletableSource.Subscriber subscriber) {\n+                closeCompletable.subscribe(subscriber);\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    closeAsync0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(DefaultDnsClient.this::closeAsync0);\n+                }\n+            }\n+        };\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+        closeCompletable.onComplete();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends EntriesPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(new DefaultDnsQuestion(serviceName, SRV))\n+                            .addListener((Future<? super List<DnsRecord>> completedFuture) -> {\n+                                Throwable cause = completedFuture.cause();\n+                                if (cause != null) {\n+                                    promise.setFailure(cause);\n+                                } else {\n+                                    final DnsAnswer<HostAndPort> dnsAnswer;\n+                                    long minTTLSeconds = Long.MAX_VALUE;\n+                                    try {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final List<DnsRecord> dnsRecords = (List<DnsRecord>) completedFuture.getNow();\n+                                        final List<HostAndPort> hostAndPorts = new ArrayList<>(dnsRecords.size());\n+                                        for (DnsRecord dnsRecord : dnsRecords) {\n+                                            if (!SRV.equals(dnsRecord.type()) || !(dnsRecord instanceof DnsRawRecord)) {\n+                                                throw new IllegalArgumentException(\n+                                                        \"Unsupported DNS record type for SRV query: \" + dnsRecord);\n+                                            }\n+                                            if (dnsRecord.timeToLive() < minTTLSeconds) {\n+                                                minTTLSeconds = dnsRecord.timeToLive();\n+                                            }\n+                                            ByteBuf content = ((DnsRawRecord) dnsRecord).content();\n+                                            // https://tools.ietf.org/html/rfc2782\n+                                            // Priority(16u) Weight(16u) Port(16u) Target(varstring)\n+                                            content.skipBytes(4); // ignore Priority and Weight for now\n+                                            final int port = content.readUnsignedShort();\n+                                            hostAndPorts.add(HostAndPort.of(decodeName(content), port));\n+                                        }\n+                                        dnsAnswer = new DnsAnswer<>(hostAndPorts, SECONDS.toNanos(minTTLSeconds));\n+                                    } catch (Throwable cause2) {\n+                                        promise.setFailure(cause2);\n+                                        return;\n+                                    }\n+                                    promise.setSuccess(dnsAnswer);\n+                                }\n+                            });\n+                    return promise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<HostAndPort>> calculateDifference(\n+                        final List<HostAndPort> previousList, final List<HostAndPort> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, HOST_AND_PORT_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                }\n+            };\n+        }\n+    }\n+\n+    private class ARecordPublisher extends EntriesPublisher<InetAddress> {\n+        private final String inetHost;\n+\n+        ARecordPublisher(String inetHost) {\n+            this.inetHost = inetHost;\n+        }\n+\n+        protected void onFinallyCleanup() {\n+            // overridable for any cleanup\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<InetAddress>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<InetAddress>> doDnsQuery() {\n+                    ttlCache.prepareForResolution(inetHost);\n+                    Promise<DnsAnswer<InetAddress>> dnsAnswerPromise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(inetHost).addListener(completedFuture -> {\n+                        Throwable cause = completedFuture.cause();\n+                        if (cause != null) {\n+                            dnsAnswerPromise.setFailure(cause);\n+                        } else {\n+                            final DnsAnswer<InetAddress> dnsAnswer;\n+                            try {\n+                                @SuppressWarnings(\"unchecked\")\n+                                final List<InetAddress> addresses = (List<InetAddress>) completedFuture.getNow();\n+                                dnsAnswer = new DnsAnswer<>(addresses, SECONDS.toNanos(ttlCache.minTtl(inetHost)));\n+                            } catch (Throwable cause2) {\n+                                dnsAnswerPromise.setFailure(cause2);\n+                                return;\n+                            }\n+                            dnsAnswerPromise.setSuccess(dnsAnswer);\n+                        }\n+                    });\n+                    return dnsAnswerPromise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<InetAddress>> calculateDifference(\n+                        final List<InetAddress> previousList, final List<InetAddress> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, INET_ADDRESS_COMPARATOR);\n+                }\n+\n+                @Override\n+                protected void removeFromWatchers() {\n+                    onFinallyCleanup();\n+                }\n+            };\n+        }\n+    }\n+\n+    private static final class DnsAnswer<T> {\n+        private final List<T> answer;\n+        private final long ttlNanos;\n+\n+        DnsAnswer(final List<T> answer, final long ttlNanos) {\n+            this.answer = answer;\n+            this.ttlNanos = ttlNanos;\n+        }\n+\n+        List<T> answer() {\n+            return answer;\n+        }\n+\n+        long ttlNanos() {\n+            return ttlNanos;\n+        }\n+    }\n+\n+    private abstract class EntriesPublisher<T>\n+            extends SubscribablePublisher<Iterable<ServiceDiscovererEvent<T>>> {\n+        @Nullable\n+        private Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> discoverySubscriber;\n+        @Nullable\n+        private AbstractEntriesPublisherSubscription subscription;\n+\n+        protected abstract AbstractEntriesPublisherSubscription\n+        newSubscription(Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber);\n+\n+        @Override\n+        protected final void handleSubscribe(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                handleSubscribe0(subscriber);\n+            } else {\n+                nettyIoExecutor.asExecutor().execute(() -> handleSubscribe0(subscriber));\n+            }\n+        }\n+\n+        private void handleSubscribe0(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            assertInEventloop();\n+\n+            if (discoverySubscriber != null) {\n+                deliverTerminalFromSource(subscriber,\n+                        new DuplicateSubscribeException(discoverySubscriber, subscriber));\n+            } else if (closed) {\n+                deliverTerminalFromSource(subscriber,\n+                        new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                                \" has been closed!\"));\n+            } else {\n+                subscription = newSubscription(subscriber);\n+                discoverySubscriber = subscriber;\n+                subscriber.onSubscribe(subscription);\n+            }\n+        }\n+\n+        final void close0() {\n+            assertInEventloop();\n+\n+            final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> oldSubscriber = discoverySubscriber;\n+            discoverySubscriber = null;\n+            if (oldSubscriber != null) {\n+                assert subscription != null;\n+                subscription.cancelWithoutRemove0(true);\n+            }\n+        }\n+\n+        abstract class AbstractEntriesPublisherSubscription implements Subscription {\n+            private final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber;\n+            private long pendingRequests;\n+            private List<T> activeAddresses;\n+            private long resolveDoneNoScheduleTime;\n+            @Nullable\n+            private Cancellable cancellableForQuery;\n+            private long ttlNanos;\n+\n+            AbstractEntriesPublisherSubscription(\n+                    final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+                this.subscriber = subscriber;\n+                activeAddresses = emptyList();\n+                ttlNanos = -1;\n+            }\n+\n+            protected abstract Future<DnsAnswer<T>> doDnsQuery();\n+\n+            @Nullable\n+            protected abstract List<ServiceDiscovererEvent<T>>\n+            calculateDifference(List<T> previousList, List<T> newList);\n+\n+            protected abstract void removeFromWatchers();\n+\n+            @Override\n+            public final void request(final long n) {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    request0(n);\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(() -> request0(n));\n+                }\n+            }\n+\n+            @Override\n+            public final void cancel() {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    cancel0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(this::cancel0);\n+                }\n+            }\n+\n+            private void request0(final long n) {\n+                assertInEventloop();\n+\n+                if (!isRequestNValid(n)) {\n+                    handleError0(newExceptionForInvalidRequestN(n), __ -> false);\n+                    return;\n+                }\n+\n+                pendingRequests = addWithOverflowProtectionIfNotNegative(pendingRequests, n);\n+                if (cancellableForQuery == null) {\n+                    if (ttlNanos < 0) {\n+                        doQuery0();\n+                    } else {\n+                        final long durationNs = nanoTime() - resolveDoneNoScheduleTime;\n+                        if (durationNs > ttlNanos) {\n+                            doQuery0();\n+                        } else {\n+                            scheduleQuery0(ttlNanos - durationNs);\n+                        }\n+                    }\n+                } else if (cancellableForQuery == WAITING_FOR_REQUEST_N) {", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyMDk1MQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409220951", "bodyText": "This can just be a follow up but it looks like we have all the context here to actually do the A lookup when the SRV lookup finishes in netty itself. This will simplify the control flow by eliminating the flatMap on the SRV publisher and the whole mechanics of representing the DNS A record lookup as an infinite Publisher.\nI am still not convinced that we need to keep listening to the A lookup on the SRV record result. It feels surprising to have both SRV record and a changing A record for each SRV record result.", "author": "NiteshKant", "createdAt": "2020-04-16T01:05:32Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.CompletableSource.Processor;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribableCompletable;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtectionIfNotNegative;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable WAITING_FOR_REQUEST_N = () -> { };\n+\n+    private final Processor closeCompletable = newCompletableProcessor();\n+    private final Map<String, List<ARecordPublisher>> srvARecordMap = new HashMap<>(8);\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+        LOGGER.debug(\"Created a new DNS discoverer {} with minimum TTL (seconds): {}, ndots: {}, \" +\n+                        \"optResourceEnabled {}, dnsResolverAddressTypes {}, dnsServerAddressStreamProvider {}.\",\n+                this, minTTL, ndots, optResourceEnabled, dnsResolverAddressTypes, dnsServerAddressStreamProvider);\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                .<ServiceDiscovererEvent<InetSocketAddress>>flatMapMergeSingle(srvEvent -> {\n+            assertInEventloop();\n+\n+            if (srvEvent.isAvailable()) {\n+                ARecordPublisher entry = new ARecordPublisher(srvEvent.address().hostName()) {\n+                    @Override\n+                    protected void onFinallyCleanup() {\n+                        removeSrvEntry0(this);\n+                    }\n+                };\n+                addSrvEntry0(entry);\n+                return entry.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                        new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+                       ).firstOrElse(() -> {\n+                           throw new IllegalStateException(\"0 SRV records found. 1 SRV record is required!\");\n+                       });\n+            } else {\n+                final List<ARecordPublisher> inetWatchers = srvARecordMap.remove(srvEvent.address().hostName());\n+                if (inetWatchers != null) {\n+                    for (ARecordPublisher inetWatcher : inetWatchers) {\n+                        inetWatcher.close0();\n+                    }\n+                }\n+\n+                // We will filter the null value out on the outer flatMap transformation.\n+                return Single.succeeded(null);\n+            }\n+        })\n+        // When the SRV record becomes unavailable we clean up state and return a Single.succeeded(null), but\n+        // we don't want to propagate this downstream, so filter it out.\n+        .filter(Objects::nonNull);\n+    }\n+\n+    private void addSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        srvARecordMap.computeIfAbsent(entry.inetHost, k -> new ArrayList<>(2)).add(entry);\n+    }\n+\n+    private void removeSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        final List<ARecordPublisher> inetWatchers = srvARecordMap.get(entry.inetHost);\n+        if (inetWatchers == null) {\n+            return;\n+        }\n+        inetWatchers.remove(entry);\n+        if (inetWatchers.isEmpty()) {\n+            srvARecordMap.remove(entry.inetHost);\n+        }\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return fromSource(closeCompletable);\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return new SubscribableCompletable() {\n+            @Override\n+            protected void handleSubscribe(final CompletableSource.Subscriber subscriber) {\n+                closeCompletable.subscribe(subscriber);\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    closeAsync0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(DefaultDnsClient.this::closeAsync0);\n+                }\n+            }\n+        };\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+        closeCompletable.onComplete();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends EntriesPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractEntriesPublisherSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractEntriesPublisherSubscription(subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();", "originalCommit": "ee541a48c751e9fbd74ae38d9eb349cf49ec142d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2ODE4MA==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409268180", "bodyText": "lets discuss as followup.\ncurrent goals are:\n\nre-use existing code control flow/logic\nrepresent the DNS control flow as defined in the DNS SRV RFC [1]\n\n[1] https://tools.ietf.org/html/rfc2782\n\nTarget\nThe domain name of the target host.  There MUST be one or more\naddress records for this name,", "author": "Scottmitch", "createdAt": "2020-04-16T04:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyMDk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY0MDIxNQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409640215", "bodyText": "The domain name of the target host.  There MUST be one or more\n\nTo be clear; I am suggesting to do a one time lookup in netty for each SRV record entry which will give all A* records.\nThe difference is that with the ARecordPublisher we are also listening to changes on that A record over time which seems unnecessary in this case.", "author": "NiteshKant", "createdAt": "2020-04-16T15:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyMDk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTgzOTE3NQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409839175", "bodyText": "The only constraint from the SRV RFC is target can't be an alias, other than that it is a normal A* resolution (which has its own TTL and may change over time). If the DNS server provides the A* resolution in the Additional section of the SRV answer we may be able to avoid the secondary lookup, but depends upon the DNS server behavior (we can explore this optimization later).", "author": "Scottmitch", "createdAt": "2020-04-16T20:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIyMDk1MQ=="}], "type": "inlineReview"}, {"oid": "e44805c94e8039fcd016b3842783dbe4b07a9b57", "url": "https://github.com/apple/servicetalk/commit/e44805c94e8039fcd016b3842783dbe4b07a9b57", "message": "review comments, clarify control flow", "committedDate": "2020-04-16T04:11:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcxNjM2OQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409716369", "bodyText": "So previously[1] we were terminating all active queries in close(). I don't see a test for the close behavior in the current master but looks like this something that is missing from this change?\n[1] https://github.com/apple/servicetalk/blob/master/servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsServiceDiscoverer.java#L209-L223", "author": "NiteshKant", "createdAt": "2020-04-16T17:10:02Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable TERMINATE_ON_NEXT_REQUEST_N = () -> { };\n+\n+    private final Map<String, List<ARecordPublisher>> srvARecordMap = new HashMap<>(8);\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private final ListenableAsyncCloseable asyncCloseable;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        asyncCloseable = toAsyncCloseable(graceful -> {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                closeAsync0();\n+                return completed();\n+            }\n+            return nettyIoExecutor.asExecutor().submit(this::closeAsync0);\n+        });\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                .<ServiceDiscovererEvent<InetSocketAddress>>flatMapMergeSingle(srvEvent -> {\n+            assertInEventloop();\n+\n+            if (srvEvent.isAvailable()) {\n+                ARecordPublisher entry = new ARecordPublisher(srvEvent.address().hostName()) {\n+                    @Override\n+                    protected void onFinallyCleanup() {\n+                        removeSrvEntry0(this);\n+                    }\n+                };\n+                addSrvEntry0(entry);\n+                return entry.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                        new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+                       ).firstOrElse(() -> {\n+                           LOGGER.info(\"No A/AAAA records found for hostname {} corresponding to SRV name {}\",\n+                                   srvEvent.address().hostName(), serviceName);\n+                           return null;\n+                       });\n+            } else {\n+                final List<ARecordPublisher> inetWatchers = srvARecordMap.remove(srvEvent.address().hostName());\n+                if (inetWatchers != null) {\n+                    for (ARecordPublisher inetWatcher : inetWatchers) {\n+                        inetWatcher.close0();\n+                    }\n+                }\n+\n+                // We will filter the null value out on the outer flatMap transformation.\n+                return Single.succeeded(null);\n+            }\n+        })\n+        // When the SRV record becomes unavailable we clean up state and return a Single.succeeded(null), but\n+        // we don't want to propagate this downstream, so filter it out.\n+        .filter(Objects::nonNull);\n+    }\n+\n+    private void addSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        srvARecordMap.computeIfAbsent(entry.inetHost, k -> new ArrayList<>(2)).add(entry);\n+    }\n+\n+    private void removeSrvEntry0(final ARecordPublisher entry) {\n+        assertInEventloop();\n+\n+        final List<ARecordPublisher> inetWatchers = srvARecordMap.get(entry.inetHost);\n+        if (inetWatchers == null) {\n+            return;\n+        }\n+        inetWatchers.remove(entry);\n+        if (inetWatchers.isEmpty()) {\n+            srvARecordMap.remove(entry.inetHost);\n+        }\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return asyncCloseable.onClose();\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return asyncCloseable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return asyncCloseable.closeAsyncGracefully();\n+    }\n+\n+    private void closeAsync0() {", "originalCommit": "e44805c94e8039fcd016b3842783dbe4b07a9b57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg0MTM2Mw==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409841363", "bodyText": "Remove tracking of all outstanding streams and close() cleanup to\nreduce state. Subscribers of these sources (e.g. LoadBalancers) are\nresponsible for cancelling if they are no longer interested in demand.\nThere is best effort close cleanup when TTLs timeout fire in the event\nthe DnsClient is closed but the streams are not cancelled (which is not\nan expected use case).\n\nThis was removed as it isn't guaranteed by the interface and subscribers are currently responsible for managing lifetime/cancellation. Removing this constraint simplified the code but we can add it back if necessary.", "author": "Scottmitch", "createdAt": "2020-04-16T20:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcxNjM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcyMzA1MA==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409723050", "bodyText": "This can be done as a followup if you have verified that changes to SRV records are reflected in the lookup, but it will be good to have a unit test for it.", "author": "NiteshKant", "createdAt": "2020-04-16T17:21:13Z", "path": "servicetalk-dns-discovery-netty/src/test/java/io/servicetalk/dns/discovery/netty/DefaultDnsClientTest.java", "diffHunk": "@@ -123,10 +121,112 @@ public void unknownHostDiscover() throws Exception {\n             assertThat(subscriber.activeCount(), equalTo(0));\n             assertThat(subscriber.inactiveCount(), equalTo(0));\n         } finally {\n-            discoverer.closeAsync().toFuture().get();\n+            filteredClient.closeAsync().toFuture().get();\n         }\n     }\n \n+    @Test\n+    public void singleSrvSingleADiscover() throws InterruptedException {\n+        final String domain = \"mysvc.apple.com\";\n+        final String targetDomain = \"target.mysvc.apple.com\";\n+        final int targetPort = 9876;\n+        recordStore.addSrvResponse(domain, targetDomain, 10, 10, targetPort);\n+        recordStore.addResponse(targetDomain, A, nextIp());\n+        final int expectedActiveCount = 1;\n+        final int expectedInactiveCount = 0;\n+\n+        CountDownLatch latch = new CountDownLatch(expectedActiveCount + expectedInactiveCount);\n+        AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n+        Publisher<ServiceDiscovererEvent<InetSocketAddress>> publisher = client.dnsSrvQuery(domain);\n+        ServiceDiscovererTestSubscriber<InetSocketAddress> subscriber =\n+                new ServiceDiscovererTestSubscriber<>(latch, throwableRef, expectedActiveCount);\n+        toSource(publisher).subscribe(subscriber);\n+\n+        latch.await();\n+        assertNull(throwableRef.get());\n+        assertThat(subscriber.activeCount(), equalTo(expectedActiveCount));\n+        assertThat(subscriber.inactiveCount(), equalTo(expectedInactiveCount));\n+    }\n+\n+    @Ignore(\"Publisher#flatMapMerge required https://github.com/apple/servicetalk/pull/1011\")\n+    @Test\n+    public void singleSrvMultipleADiscover() throws InterruptedException {\n+        final String domain = \"mysvc.apple.com\";\n+        final String targetDomain = \"target.mysvc.apple.com\";\n+        final int targetPort = 9876;\n+        recordStore.addSrvResponse(domain, targetDomain, 10, 10, targetPort);\n+        recordStore.addResponse(targetDomain, A, nextIp(), nextIp());\n+        final int expectedActiveCount = 2;\n+        final int expectedInactiveCount = 0;\n+\n+        CountDownLatch latch = new CountDownLatch(expectedActiveCount + expectedInactiveCount);\n+        AtomicReference<Throwable> throwableRef = new AtomicReference<>();\n+        Publisher<ServiceDiscovererEvent<InetSocketAddress>> publisher = client.dnsSrvQuery(domain);\n+        ServiceDiscovererTestSubscriber<InetSocketAddress> subscriber =\n+                new ServiceDiscovererTestSubscriber<>(latch, throwableRef, expectedActiveCount);\n+        toSource(publisher).subscribe(subscriber);\n+\n+        latch.await();\n+        assertNull(throwableRef.get());\n+        assertThat(subscriber.activeCount(), equalTo(expectedActiveCount));\n+        assertThat(subscriber.inactiveCount(), equalTo(expectedInactiveCount));\n+    }\n+\n+    @Test\n+    public void multipleSrvSingleADiscover() throws InterruptedException {", "originalCommit": "e44805c94e8039fcd016b3842783dbe4b07a9b57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk4OTQ5NQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409989495", "bodyText": "good call, I added a test. The test class was introduced before we had testing utilities and is difficult to control/analyze. Here is an issue to analyze #1022.", "author": "Scottmitch", "createdAt": "2020-04-17T04:42:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcyMzA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc1MDgyMw==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409750823", "bodyText": "Because we do not expose DnsClient as a public API, can we keep existing ServiceDiscovererFilter and ServiceDiscovererFilterFactory and apply them in buildSrvDiscoverer and buildARecordDiscoverer methods respectively?\nThen we do not need to change the pre-existing retrying filter as we can apply it on top of the returned ServiceDiscoverer interface.", "author": "idelpivnitskiy", "createdAt": "2020-04-16T18:06:17Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsServiceDiscovererBuilder.java", "diffHunk": "@@ -209,75 +202,47 @@ public DefaultDnsServiceDiscovererBuilder ioExecutor(final IoExecutor ioExecutor\n     }\n \n     /**\n-     * Build a new instance of {@link ServiceDiscoverer ServiceDiscoverer&lt;String, InetAddress&gt;}.\n-     *\n-     * @return a new instance of {@link ServiceDiscoverer ServiceDiscoverer&lt;String, InetAddress&gt;}.\n+     * Build a new {@link ServiceDiscoverer} which queries\n+     * <a href=\"https://tools.ietf.org/html/rfc2782\">SRV Resource Records</a> corresponding to {@code serviceName}. For\n+     * each SRV answer capture the <strong>Port</strong> and resolve the <strong>Target</strong>.\n+     * @return a new {@link ServiceDiscoverer} which queries\n+     * <a href=\"https://tools.ietf.org/html/rfc2782\">SRV Resource Records</a> corresponding to {@code serviceName}. For\n+     * each SRV answer capture the <strong>Port</strong> and resolve the <strong>Target</strong>.\n      */\n-    public ServiceDiscoverer<String, InetAddress, ServiceDiscovererEvent<InetAddress>> buildInetDiscoverer() {\n-        return newDefaultDnsServiceDiscoverer();\n+    public ServiceDiscoverer<String, InetSocketAddress, ServiceDiscovererEvent<InetSocketAddress>>\n+            buildSrvDiscoverer() {\n+        return asSrvDiscoverer(build());\n     }\n \n     /**\n-     * Build a new instance of {@link ServiceDiscoverer ServiceDiscoverer&lt;HostAndPort, InetSocketAddress&gt;}.\n-     *\n-     * @return a new instance of {@link ServiceDiscoverer ServiceDiscoverer&lt;HostAndPort, InetSocketAddress&gt;}.\n-     * @see HostAndPort\n+     * Build a new {@link ServiceDiscoverer} which targets\n+     * <a href=\"https://tools.ietf.org/html/rfc1035\">host addresses</a> (e.g. A or AAAA records) and uses\n+     * a fixed port derived from the {@link HostAndPort}.\n+     * @return a new {@link ServiceDiscoverer} which targets\n+     * <a href=\"https://tools.ietf.org/html/rfc1035\">host addresses</a> (e.g. A or AAAA records) and uses\n+     * a fixed port derived from the {@link HostAndPort}.\n      */\n-    public ServiceDiscoverer<HostAndPort, InetSocketAddress, ServiceDiscovererEvent<InetSocketAddress>> build() {\n-        return toHostAndPortDiscoverer(newDefaultDnsServiceDiscoverer());\n-    }\n-\n-    private ServiceDiscoverer<String, InetAddress,\n-            ServiceDiscovererEvent<InetAddress>> newDefaultDnsServiceDiscoverer() {\n-        ServiceDiscovererFilterFactory<String, InetAddress, ServiceDiscovererEvent<InetAddress>> factory =\n-                this.serviceDiscoveryFilterFactory;\n-\n-        if (applyRetryFilter) {\n-            final ServiceDiscovererFilterFactory<String, InetAddress, ServiceDiscovererEvent<InetAddress>>\n-                    defaultFilterFactory = serviceDiscoverer -> new RetryingDnsServiceDiscovererFilter(\n-                    serviceDiscoverer, retryWithConstantBackoffAndJitter(\n-                    Integer.MAX_VALUE, t -> true, Duration.ofSeconds(60), immediate()));\n-            factory = defaultFilterFactory.append(factory);\n-        }\n-        return factory.create(new DefaultDnsServiceDiscoverer(\n-                ioExecutor == null ? globalExecutionContext().ioExecutor() : ioExecutor, minTTLSeconds, ndots,\n-                invalidateHostsOnDnsFailure, optResourceEnabled, queryTimeout, dnsResolverAddressTypes,\n-                dnsServerAddressStreamProvider));\n+    public ServiceDiscoverer<HostAndPort, InetSocketAddress, ServiceDiscovererEvent<InetSocketAddress>>\n+            buildARecordDiscoverer() {\n+        return asHostAndPortDiscoverer(build());\n     }\n \n     /**\n-     * Convert this object from {@link String} host names and {@link InetAddress} resolved address to\n-     * {@link HostAndPort} to {@link InetSocketAddress}.\n+     * Create a new instance of {@link DnsClient}.\n      *\n-     * @return a resolver which will convert from {@link String} host names and {@link InetAddress} resolved address to\n-     * {@link HostAndPort} to {@link InetSocketAddress}.\n+     * @return a new instance of {@link DnsClient}.\n      */\n-    private static ServiceDiscoverer<HostAndPort, InetSocketAddress,\n-            ServiceDiscovererEvent<InetSocketAddress>> toHostAndPortDiscoverer(\n-            final ServiceDiscoverer<String, InetAddress, ServiceDiscovererEvent<InetAddress>> serviceDiscoverer) {\n-        return new ServiceDiscoverer<HostAndPort, InetSocketAddress, ServiceDiscovererEvent<InetSocketAddress>>() {\n-            @Override\n-            public Completable closeAsync() {\n-                return serviceDiscoverer.closeAsync();\n-            }\n-\n-            @Override\n-            public Completable closeAsyncGracefully() {\n-                return serviceDiscoverer.closeAsyncGracefully();\n-            }\n-\n-            @Override\n-            public Completable onClose() {\n-                return serviceDiscoverer.onClose();\n-            }\n-\n-            @Override\n-            public Publisher<ServiceDiscovererEvent<InetSocketAddress>> discover(final HostAndPort hostAndPort) {\n-                return serviceDiscoverer.discover(hostAndPort.hostName()).map(originalEvent ->\n-                        new DefaultServiceDiscovererEvent<>(new InetSocketAddress(originalEvent.address(),\n-                                hostAndPort.port()), originalEvent.isAvailable())\n-                );\n-            }\n-        };\n+    DnsClient build() {\n+        DnsClient rawClient = new DefaultDnsClient(\n+                ioExecutor == null ? globalExecutionContext().ioExecutor() : ioExecutor, minTTLSeconds, ndots,\n+                invalidateHostsOnDnsFailure, optResourceEnabled, queryTimeout, dnsResolverAddressTypes,\n+                dnsServerAddressStreamProvider);\n+        DnsClientFilterFactory rawFilterFactory = filterFactory;\n+        if (applyRetryFilter) {\n+            DnsClientFilterFactory retryFilterFactory = new RetryingDnsClientFilter();\n+            rawFilterFactory = rawFilterFactory == null ? retryFilterFactory :\n+                    retryFilterFactory.append(rawFilterFactory);", "originalCommit": "e44805c94e8039fcd016b3842783dbe4b07a9b57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk4MDk0OA==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r409980948", "bodyText": "discussed offline. lets hold off on the ServiceDiscovererFilterFactory general APIs for now and re-evaluate after we get more experience with DNS and other implementations if the general APIs are worth it.", "author": "Scottmitch", "createdAt": "2020-04-17T04:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTc1MDgyMw=="}], "type": "inlineReview"}, {"oid": "c40cc59c54755380f6dafb6d9a1c7ffd87f60f97", "url": "https://github.com/apple/servicetalk/commit/c40cc59c54755380f6dafb6d9a1c7ffd87f60f97", "message": "adjust control flow to generate inactive events with flatMapSingle, add tests to verify", "committedDate": "2020-04-17T03:52:02Z", "type": "commit"}, {"oid": "fbd69139ef6ef0efb50896ba2bde708963674a71", "url": "https://github.com/apple/servicetalk/commit/fbd69139ef6ef0efb50896ba2bde708963674a71", "message": "re-enable test timeout", "committedDate": "2020-04-17T04:32:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2NDYwMQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r410164601", "bodyText": "nit: 2020 ?", "author": "normanmaurer", "createdAt": "2020-04-17T11:34:11Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors", "originalCommit": "fbd69139ef6ef0efb50896ba2bde708963674a71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2NTk5Ng==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r410165996", "bodyText": "@Scottmitch I think you also need to call ReferenceCounted.release(dnsRecord)here.", "author": "normanmaurer", "createdAt": "2020-04-17T11:37:20Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable TERMINATE_ON_NEXT_REQUEST_N = () -> { };\n+\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private final ListenableAsyncCloseable asyncCloseable;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        asyncCloseable = toAsyncCloseable(graceful -> {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                closeAsync0();\n+                return completed();\n+            }\n+            return nettyIoExecutor.asExecutor().submit(this::closeAsync0);\n+        });\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(true, address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return Publisher.defer(() -> {\n+            // State per subscribe requires defer so each subscribe gets independent state.\n+            final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n+            return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                    .flatMapMergeSingle(srvEvent -> {\n+                assertInEventloop();\n+                if (srvEvent.isAvailable()) {\n+                    final ARecordPublisher aPublisher = new ARecordPublisher(false, srvEvent.address().hostName());\n+                    final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n+                    if (prevAPublisher != null) {\n+                        return failed(new IllegalStateException(\"Only 1 A* record per SRV record is supported. \" +\n+                                srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n+                                \" had a pre-existing A* record:\" + prevAPublisher.inetHost +\n+                                \" when new A* record arrived: \" + aPublisher.inetHost));\n+                    }\n+\n+                    return srvARecordPubToSingle(aPublisher, srvEvent, serviceName);\n+                } else {\n+                    final ARecordPublisher aPublisher = aRecordMap.remove(srvEvent.address());\n+                    if (aPublisher != null) {\n+                        final List<ServiceDiscovererEvent<InetAddress>> list = aPublisher.close0();\n+                        if (list != null) {\n+                            return srvARecordPubToSingle(Publisher.from(list), srvEvent, serviceName);\n+                        }\n+                    }\n+\n+                    return failed(new IllegalStateException(\"Received an SRV inactive event for \" +\n+                            srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n+                            \" but failed to find the corresponding A* record Publisher.\"));\n+                }\n+            });\n+        });\n+    }\n+\n+    private static Single<? extends ServiceDiscovererEvent<InetSocketAddress>> srvARecordPubToSingle(\n+            Publisher<Iterable<ServiceDiscovererEvent<InetAddress>>> aRecordPublisher,\n+            ServiceDiscovererEvent<HostAndPort> srvEvent, String serviceName) {\n+        return aRecordPublisher.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+        ).firstOrElse(() -> {\n+            LOGGER.info(\"No A* records found for {} corresponding to SRV name {}\", srvEvent.address(), serviceName);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return asyncCloseable.onClose();\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return asyncCloseable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return asyncCloseable.closeAsyncGracefully();\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends AbstractDnsPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = requireNonNull(serviceName);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractDnsSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractDnsSubscription(true, subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(new DefaultDnsQuestion(serviceName, SRV))\n+                            .addListener((Future<? super List<DnsRecord>> completedFuture) -> {\n+                                Throwable cause = completedFuture.cause();\n+                                if (cause != null) {\n+                                    promise.setFailure(cause);\n+                                } else {\n+                                    final DnsAnswer<HostAndPort> dnsAnswer;\n+                                    long minTTLSeconds = Long.MAX_VALUE;\n+                                    try {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final List<DnsRecord> dnsRecords = (List<DnsRecord>) completedFuture.getNow();\n+                                        final List<HostAndPort> hostAndPorts = new ArrayList<>(dnsRecords.size());\n+                                        for (DnsRecord dnsRecord : dnsRecords) {\n+                                            if (!SRV.equals(dnsRecord.type()) || !(dnsRecord instanceof DnsRawRecord)) {\n+                                                throw new IllegalArgumentException(\n+                                                        \"Unsupported DNS record type for SRV query: \" + dnsRecord);\n+                                            }\n+                                            if (dnsRecord.timeToLive() < minTTLSeconds) {\n+                                                minTTLSeconds = dnsRecord.timeToLive();\n+                                            }\n+                                            ByteBuf content = ((DnsRawRecord) dnsRecord).content();", "originalCommit": "fbd69139ef6ef0efb50896ba2bde708963674a71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTU5OA==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r422361598", "bodyText": "Fixed in #1044", "author": "idelpivnitskiy", "createdAt": "2020-05-08T20:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2NTk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2NjI0Mg==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r410166242", "bodyText": "ensure to release all records that were not released before throwing here.", "author": "normanmaurer", "createdAt": "2020-04-17T11:37:53Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable TERMINATE_ON_NEXT_REQUEST_N = () -> { };\n+\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private final ListenableAsyncCloseable asyncCloseable;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        asyncCloseable = toAsyncCloseable(graceful -> {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                closeAsync0();\n+                return completed();\n+            }\n+            return nettyIoExecutor.asExecutor().submit(this::closeAsync0);\n+        });\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(true, address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return Publisher.defer(() -> {\n+            // State per subscribe requires defer so each subscribe gets independent state.\n+            final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n+            return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                    .flatMapMergeSingle(srvEvent -> {\n+                assertInEventloop();\n+                if (srvEvent.isAvailable()) {\n+                    final ARecordPublisher aPublisher = new ARecordPublisher(false, srvEvent.address().hostName());\n+                    final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n+                    if (prevAPublisher != null) {\n+                        return failed(new IllegalStateException(\"Only 1 A* record per SRV record is supported. \" +\n+                                srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n+                                \" had a pre-existing A* record:\" + prevAPublisher.inetHost +\n+                                \" when new A* record arrived: \" + aPublisher.inetHost));\n+                    }\n+\n+                    return srvARecordPubToSingle(aPublisher, srvEvent, serviceName);\n+                } else {\n+                    final ARecordPublisher aPublisher = aRecordMap.remove(srvEvent.address());\n+                    if (aPublisher != null) {\n+                        final List<ServiceDiscovererEvent<InetAddress>> list = aPublisher.close0();\n+                        if (list != null) {\n+                            return srvARecordPubToSingle(Publisher.from(list), srvEvent, serviceName);\n+                        }\n+                    }\n+\n+                    return failed(new IllegalStateException(\"Received an SRV inactive event for \" +\n+                            srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n+                            \" but failed to find the corresponding A* record Publisher.\"));\n+                }\n+            });\n+        });\n+    }\n+\n+    private static Single<? extends ServiceDiscovererEvent<InetSocketAddress>> srvARecordPubToSingle(\n+            Publisher<Iterable<ServiceDiscovererEvent<InetAddress>>> aRecordPublisher,\n+            ServiceDiscovererEvent<HostAndPort> srvEvent, String serviceName) {\n+        return aRecordPublisher.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+        ).firstOrElse(() -> {\n+            LOGGER.info(\"No A* records found for {} corresponding to SRV name {}\", srvEvent.address(), serviceName);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return asyncCloseable.onClose();\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return asyncCloseable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return asyncCloseable.closeAsyncGracefully();\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends AbstractDnsPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = requireNonNull(serviceName);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractDnsSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractDnsSubscription(true, subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(new DefaultDnsQuestion(serviceName, SRV))\n+                            .addListener((Future<? super List<DnsRecord>> completedFuture) -> {\n+                                Throwable cause = completedFuture.cause();\n+                                if (cause != null) {\n+                                    promise.setFailure(cause);\n+                                } else {\n+                                    final DnsAnswer<HostAndPort> dnsAnswer;\n+                                    long minTTLSeconds = Long.MAX_VALUE;\n+                                    try {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final List<DnsRecord> dnsRecords = (List<DnsRecord>) completedFuture.getNow();\n+                                        final List<HostAndPort> hostAndPorts = new ArrayList<>(dnsRecords.size());\n+                                        for (DnsRecord dnsRecord : dnsRecords) {\n+                                            if (!SRV.equals(dnsRecord.type()) || !(dnsRecord instanceof DnsRawRecord)) {\n+                                                throw new IllegalArgumentException(", "originalCommit": "fbd69139ef6ef0efb50896ba2bde708963674a71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2NjUwNw==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r410166507", "bodyText": "ensure you release all records.", "author": "normanmaurer", "createdAt": "2020-04-17T11:38:27Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable TERMINATE_ON_NEXT_REQUEST_N = () -> { };\n+\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private final ListenableAsyncCloseable asyncCloseable;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        asyncCloseable = toAsyncCloseable(graceful -> {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                closeAsync0();\n+                return completed();\n+            }\n+            return nettyIoExecutor.asExecutor().submit(this::closeAsync0);\n+        });\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(true, address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return Publisher.defer(() -> {\n+            // State per subscribe requires defer so each subscribe gets independent state.\n+            final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n+            return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                    .flatMapMergeSingle(srvEvent -> {\n+                assertInEventloop();\n+                if (srvEvent.isAvailable()) {\n+                    final ARecordPublisher aPublisher = new ARecordPublisher(false, srvEvent.address().hostName());\n+                    final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n+                    if (prevAPublisher != null) {\n+                        return failed(new IllegalStateException(\"Only 1 A* record per SRV record is supported. \" +\n+                                srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n+                                \" had a pre-existing A* record:\" + prevAPublisher.inetHost +\n+                                \" when new A* record arrived: \" + aPublisher.inetHost));\n+                    }\n+\n+                    return srvARecordPubToSingle(aPublisher, srvEvent, serviceName);\n+                } else {\n+                    final ARecordPublisher aPublisher = aRecordMap.remove(srvEvent.address());\n+                    if (aPublisher != null) {\n+                        final List<ServiceDiscovererEvent<InetAddress>> list = aPublisher.close0();\n+                        if (list != null) {\n+                            return srvARecordPubToSingle(Publisher.from(list), srvEvent, serviceName);\n+                        }\n+                    }\n+\n+                    return failed(new IllegalStateException(\"Received an SRV inactive event for \" +\n+                            srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n+                            \" but failed to find the corresponding A* record Publisher.\"));\n+                }\n+            });\n+        });\n+    }\n+\n+    private static Single<? extends ServiceDiscovererEvent<InetSocketAddress>> srvARecordPubToSingle(\n+            Publisher<Iterable<ServiceDiscovererEvent<InetAddress>>> aRecordPublisher,\n+            ServiceDiscovererEvent<HostAndPort> srvEvent, String serviceName) {\n+        return aRecordPublisher.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+        ).firstOrElse(() -> {\n+            LOGGER.info(\"No A* records found for {} corresponding to SRV name {}\", srvEvent.address(), serviceName);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return asyncCloseable.onClose();\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return asyncCloseable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return asyncCloseable.closeAsyncGracefully();\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends AbstractDnsPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = requireNonNull(serviceName);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractDnsSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractDnsSubscription(true, subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(new DefaultDnsQuestion(serviceName, SRV))\n+                            .addListener((Future<? super List<DnsRecord>> completedFuture) -> {\n+                                Throwable cause = completedFuture.cause();\n+                                if (cause != null) {\n+                                    promise.setFailure(cause);\n+                                } else {\n+                                    final DnsAnswer<HostAndPort> dnsAnswer;\n+                                    long minTTLSeconds = Long.MAX_VALUE;\n+                                    try {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final List<DnsRecord> dnsRecords = (List<DnsRecord>) completedFuture.getNow();\n+                                        final List<HostAndPort> hostAndPorts = new ArrayList<>(dnsRecords.size());\n+                                        for (DnsRecord dnsRecord : dnsRecords) {\n+                                            if (!SRV.equals(dnsRecord.type()) || !(dnsRecord instanceof DnsRawRecord)) {\n+                                                throw new IllegalArgumentException(\n+                                                        \"Unsupported DNS record type for SRV query: \" + dnsRecord);\n+                                            }\n+                                            if (dnsRecord.timeToLive() < minTTLSeconds) {\n+                                                minTTLSeconds = dnsRecord.timeToLive();\n+                                            }\n+                                            ByteBuf content = ((DnsRawRecord) dnsRecord).content();\n+                                            // https://tools.ietf.org/html/rfc2782\n+                                            // Priority(16u) Weight(16u) Port(16u) Target(varstring)\n+                                            content.skipBytes(4); // ignore Priority and Weight for now\n+                                            final int port = content.readUnsignedShort();\n+                                            hostAndPorts.add(HostAndPort.of(decodeName(content), port));\n+                                        }\n+                                        dnsAnswer = new DnsAnswer<>(hostAndPorts, SECONDS.toNanos(minTTLSeconds));\n+                                    } catch (Throwable cause2) {\n+                                        promise.setFailure(cause2);", "originalCommit": "fbd69139ef6ef0efb50896ba2bde708963674a71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2NzQ5NQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r410167495", "bodyText": "nit: you could remove the else here", "author": "normanmaurer", "createdAt": "2020-04-17T11:40:43Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable TERMINATE_ON_NEXT_REQUEST_N = () -> { };\n+\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private final ListenableAsyncCloseable asyncCloseable;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        asyncCloseable = toAsyncCloseable(graceful -> {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                closeAsync0();\n+                return completed();\n+            }\n+            return nettyIoExecutor.asExecutor().submit(this::closeAsync0);\n+        });\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(true, address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return Publisher.defer(() -> {\n+            // State per subscribe requires defer so each subscribe gets independent state.\n+            final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n+            return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                    .flatMapMergeSingle(srvEvent -> {\n+                assertInEventloop();\n+                if (srvEvent.isAvailable()) {\n+                    final ARecordPublisher aPublisher = new ARecordPublisher(false, srvEvent.address().hostName());\n+                    final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n+                    if (prevAPublisher != null) {\n+                        return failed(new IllegalStateException(\"Only 1 A* record per SRV record is supported. \" +\n+                                srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n+                                \" had a pre-existing A* record:\" + prevAPublisher.inetHost +\n+                                \" when new A* record arrived: \" + aPublisher.inetHost));\n+                    }\n+\n+                    return srvARecordPubToSingle(aPublisher, srvEvent, serviceName);\n+                } else {\n+                    final ARecordPublisher aPublisher = aRecordMap.remove(srvEvent.address());\n+                    if (aPublisher != null) {\n+                        final List<ServiceDiscovererEvent<InetAddress>> list = aPublisher.close0();\n+                        if (list != null) {\n+                            return srvARecordPubToSingle(Publisher.from(list), srvEvent, serviceName);\n+                        }\n+                    }\n+\n+                    return failed(new IllegalStateException(\"Received an SRV inactive event for \" +\n+                            srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n+                            \" but failed to find the corresponding A* record Publisher.\"));\n+                }\n+            });\n+        });\n+    }\n+\n+    private static Single<? extends ServiceDiscovererEvent<InetSocketAddress>> srvARecordPubToSingle(\n+            Publisher<Iterable<ServiceDiscovererEvent<InetAddress>>> aRecordPublisher,\n+            ServiceDiscovererEvent<HostAndPort> srvEvent, String serviceName) {\n+        return aRecordPublisher.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+        ).firstOrElse(() -> {\n+            LOGGER.info(\"No A* records found for {} corresponding to SRV name {}\", srvEvent.address(), serviceName);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return asyncCloseable.onClose();\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return asyncCloseable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return asyncCloseable.closeAsyncGracefully();\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends AbstractDnsPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = requireNonNull(serviceName);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractDnsSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractDnsSubscription(true, subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(new DefaultDnsQuestion(serviceName, SRV))\n+                            .addListener((Future<? super List<DnsRecord>> completedFuture) -> {\n+                                Throwable cause = completedFuture.cause();\n+                                if (cause != null) {\n+                                    promise.setFailure(cause);\n+                                } else {\n+                                    final DnsAnswer<HostAndPort> dnsAnswer;\n+                                    long minTTLSeconds = Long.MAX_VALUE;\n+                                    try {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final List<DnsRecord> dnsRecords = (List<DnsRecord>) completedFuture.getNow();\n+                                        final List<HostAndPort> hostAndPorts = new ArrayList<>(dnsRecords.size());\n+                                        for (DnsRecord dnsRecord : dnsRecords) {\n+                                            if (!SRV.equals(dnsRecord.type()) || !(dnsRecord instanceof DnsRawRecord)) {\n+                                                throw new IllegalArgumentException(\n+                                                        \"Unsupported DNS record type for SRV query: \" + dnsRecord);\n+                                            }\n+                                            if (dnsRecord.timeToLive() < minTTLSeconds) {\n+                                                minTTLSeconds = dnsRecord.timeToLive();\n+                                            }\n+                                            ByteBuf content = ((DnsRawRecord) dnsRecord).content();\n+                                            // https://tools.ietf.org/html/rfc2782\n+                                            // Priority(16u) Weight(16u) Port(16u) Target(varstring)\n+                                            content.skipBytes(4); // ignore Priority and Weight for now\n+                                            final int port = content.readUnsignedShort();\n+                                            hostAndPorts.add(HostAndPort.of(decodeName(content), port));\n+                                        }\n+                                        dnsAnswer = new DnsAnswer<>(hostAndPorts, SECONDS.toNanos(minTTLSeconds));\n+                                    } catch (Throwable cause2) {\n+                                        promise.setFailure(cause2);\n+                                        return;\n+                                    }\n+                                    promise.setSuccess(dnsAnswer);\n+                                }\n+                            });\n+                    return promise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<HostAndPort>> calculateDifference(\n+                        final List<HostAndPort> previousList, final List<HostAndPort> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, HOST_AND_PORT_COMPARATOR);\n+                }\n+            };\n+        }\n+    }\n+\n+    private class ARecordPublisher extends AbstractDnsPublisher<InetAddress> {\n+        private final String inetHost;\n+        private final boolean cancelClearsSubscription;\n+\n+        ARecordPublisher(boolean cancelClearsSubscription, String inetHost) {\n+            this.cancelClearsSubscription = cancelClearsSubscription;\n+            this.inetHost = inetHost;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return inetHost;\n+        }\n+\n+        @Override\n+        protected AbstractDnsSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<InetAddress>>> subscriber) {\n+            return new AbstractDnsSubscription(cancelClearsSubscription, subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<InetAddress>> doDnsQuery() {\n+                    ttlCache.prepareForResolution(inetHost);\n+                    Promise<DnsAnswer<InetAddress>> dnsAnswerPromise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(inetHost).addListener(completedFuture -> {\n+                        Throwable cause = completedFuture.cause();\n+                        if (cause != null) {\n+                            dnsAnswerPromise.setFailure(cause);\n+                        } else {\n+                            final DnsAnswer<InetAddress> dnsAnswer;\n+                            try {\n+                                @SuppressWarnings(\"unchecked\")\n+                                final List<InetAddress> addresses = (List<InetAddress>) completedFuture.getNow();\n+                                dnsAnswer = new DnsAnswer<>(addresses, SECONDS.toNanos(ttlCache.minTtl(inetHost)));\n+                            } catch (Throwable cause2) {\n+                                dnsAnswerPromise.setFailure(cause2);\n+                                return;\n+                            }\n+                            dnsAnswerPromise.setSuccess(dnsAnswer);\n+                        }\n+                    });\n+                    return dnsAnswerPromise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<InetAddress>> calculateDifference(\n+                        final List<InetAddress> previousList, final List<InetAddress> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, INET_ADDRESS_COMPARATOR);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static final class DnsAnswer<T> {\n+        private final List<T> answer;\n+        private final long ttlNanos;\n+\n+        DnsAnswer(final List<T> answer, final long ttlNanos) {\n+            this.answer = answer;\n+            this.ttlNanos = ttlNanos;\n+        }\n+\n+        List<T> answer() {\n+            return answer;\n+        }\n+\n+        long ttlNanos() {\n+            return ttlNanos;\n+        }\n+    }\n+\n+    private abstract class AbstractDnsPublisher<T>\n+            extends SubscribablePublisher<Iterable<ServiceDiscovererEvent<T>>> {\n+        @Nullable\n+        private AbstractDnsSubscription subscription;\n+\n+        protected abstract AbstractDnsSubscription\n+                newSubscription(Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber);\n+\n+        @Override\n+        protected final void handleSubscribe(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                handleSubscribe0(subscriber);\n+            } else {\n+                nettyIoExecutor.asExecutor().execute(() -> handleSubscribe0(subscriber));\n+            }\n+        }\n+\n+        private void handleSubscribe0(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            assertInEventloop();\n+\n+            if (subscription != null) {\n+                deliverTerminalFromSource(subscriber,\n+                        new DuplicateSubscribeException(subscription, subscriber));\n+            } else if (closed) {\n+                deliverTerminalFromSource(subscriber,\n+                        new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                                \" has been closed!\"));\n+            } else {\n+                subscription = newSubscription(subscriber);\n+                subscriber.onSubscribe(subscription);\n+            }\n+        }\n+\n+        @Nullable\n+        final List<ServiceDiscovererEvent<T>> close0() {\n+            assertInEventloop();\n+\n+            if (subscription != null) {\n+                List<ServiceDiscovererEvent<T>> events = subscription.cancelClearsSubscription ? null :\n+                        subscription.generateInactiveEvent();\n+\n+                // this method call will null out the subscription reference after it is terminated.\n+                subscription.closeAndTerminate0();\n+\n+                return events;\n+            }\n+            return null;\n+        }\n+\n+        abstract class AbstractDnsSubscription implements Subscription {\n+            private final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber;\n+            /**\n+             * A record resolution for SRV uses flatMapSingle and firstOnOrError which will cancel inline with the\n+             * first onNext signal. However when we encounter a SRV in-active event we need to manually generate a A*\n+             * record in-active event corresponding for the currently active A* addresses. This means when the cancel\n+             * occurs we need to preserve the {@link #activeAddresses} state for {@link #generateInactiveEvent()}.\n+             */\n+            private final boolean cancelClearsSubscription;\n+            private long pendingRequests;\n+            private List<T> activeAddresses;\n+            private long resolveDoneNoScheduleTime;\n+            @Nullable\n+            private Cancellable cancellableForQuery;\n+            private long ttlNanos;\n+\n+            AbstractDnsSubscription(boolean cancelClearsSubscription,\n+                                    final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+                this.cancelClearsSubscription = cancelClearsSubscription;\n+                this.subscriber = subscriber;\n+                activeAddresses = emptyList();\n+                ttlNanos = -1;\n+            }\n+\n+            protected abstract Future<DnsAnswer<T>> doDnsQuery();\n+\n+            @Nullable\n+            protected abstract List<ServiceDiscovererEvent<T>>\n+                    calculateDifference(List<T> previousList, List<T> newList);\n+\n+            @Override\n+            public final void request(final long n) {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    request0(n);\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(() -> request0(n));\n+                }\n+            }\n+\n+            @Override\n+            public final void cancel() {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    cancel0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(this::cancel0);\n+                }\n+            }\n+\n+            private void request0(final long n) {\n+                assertInEventloop();\n+\n+                if (!isRequestNValid(n)) {\n+                    handleTerminalError0(newExceptionForInvalidRequestN(n));\n+                    return;\n+                }\n+\n+                pendingRequests = addWithOverflowProtection(pendingRequests, n);\n+                if (cancellableForQuery == null) {\n+                    if (ttlNanos < 0) {\n+                        doQuery0();\n+                    } else {\n+                        final long durationNs = nanoTime() - resolveDoneNoScheduleTime;\n+                        if (durationNs > ttlNanos) {\n+                            doQuery0();\n+                        } else {\n+                            scheduleQuery0(ttlNanos - durationNs);\n+                        }\n+                    }\n+                } else if (cancellableForQuery == TERMINATE_ON_NEXT_REQUEST_N) {\n+                    assert pendingRequests > 0;\n+                    tryTerminateOnComplete(); // we were waiting for demand, and got it. time to deliver the data.\n+                }\n+            }\n+\n+            private void doQuery0() {\n+                assertInEventloop();\n+\n+                if (closed) {\n+                    // best effort check to cleanup state after close.\n+                    handleTerminalError0(new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                            \" has been closed!\"));\n+                } else {\n+                    LOGGER.trace(\"DnsClient {}, querying DNS for {}\", DefaultDnsClient.this, AbstractDnsPublisher.this);\n+                    final Future<DnsAnswer<T>> addressFuture = doDnsQuery();\n+                    cancellableForQuery = () -> addressFuture.cancel(true);\n+                    if (addressFuture.isDone()) {\n+                        handleResolveDone0(addressFuture);\n+                    } else {\n+                        addressFuture.addListener((FutureListener<DnsAnswer<T>>) this::handleResolveDone0);\n+                    }\n+                }\n+            }\n+\n+            private void cancel0() {\n+                assertInEventloop();\n+                if (cancellableForQuery != null) {\n+                    cancellableForQuery.cancel();\n+                }\n+                if (cancelClearsSubscription) {\n+                    clearState();\n+                }\n+            }\n+\n+            private void clearState() {\n+                cancellableForQuery = TERMINATED;\n+                subscription = null;\n+            }\n+\n+            private void closeAndTerminate0() {\n+                if (cancellableForQuery != null) {\n+                    cancellableForQuery.cancel();\n+                }\n+                tryTerminateOnComplete();\n+            }\n+\n+            private void tryTerminateOnComplete() {\n+                final boolean deliverTerminal;\n+                try {\n+                    deliverTerminal = clearAddressesAndPropagateRemovalEvents();\n+                } catch (Throwable cause) {\n+                    clearState(); // must null out subscription before terminating to allow for re-subscribe.\n+                    safeOnError(subscriber, cause);\n+                    return;\n+                }\n+                if (deliverTerminal) {\n+                    clearState(); // must null out subscription before terminating to allow for re-subscribe.\n+                    safeOnComplete(subscriber);\n+                } else {\n+                    cancellableForQuery = TERMINATE_ON_NEXT_REQUEST_N;\n+                }\n+            }\n+\n+            private void scheduleQuery0(final long nanos) {\n+                assertInEventloop();\n+\n+                LOGGER.trace(\"DnsClient {}, scheduling DNS query for {} after {} nanos.\",\n+                        DefaultDnsClient.this, AbstractDnsPublisher.this, nanos);\n+\n+                // This value is coming from DNS TTL for which the unit is seconds and the minimum value we accept\n+                // in the builder is 1 second.\n+                cancellableForQuery = nettyIoExecutor.asExecutor().schedule(\n+                        this::doQuery0, nanos, NANOSECONDS);\n+            }\n+\n+            private void handleResolveDone0(final Future<DnsAnswer<T>> addressFuture) {\n+                assertInEventloop();\n+                assert pendingRequests > 0;\n+                if (cancellableForQuery == TERMINATED) {\n+                    return;\n+                } else if (cancellableForQuery == TERMINATE_ON_NEXT_REQUEST_N) {", "originalCommit": "fbd69139ef6ef0efb50896ba2bde708963674a71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2ODA0MQ==", "url": "https://github.com/apple/servicetalk/pull/1018#discussion_r410168041", "bodyText": "nit: you could remove the else here", "author": "normanmaurer", "createdAt": "2020-04-17T11:41:58Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -0,0 +1,715 @@\n+/*\n+ * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.dns.discovery.netty;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.internal.ServiceDiscovererUtils;\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.api.internal.SubscribablePublisher;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+import io.servicetalk.concurrent.internal.RejectedSubscribeError;\n+import io.servicetalk.transport.api.HostAndPort;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutor;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.handler.codec.dns.DefaultDnsQuestion;\n+import io.netty.handler.codec.dns.DnsRawRecord;\n+import io.netty.handler.codec.dns.DnsRecord;\n+import io.netty.resolver.ResolvedAddressTypes;\n+import io.netty.resolver.dns.DefaultDnsCache;\n+import io.netty.resolver.dns.DnsNameResolver;\n+import io.netty.resolver.dns.DnsNameResolverBuilder;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n+import io.netty.util.concurrent.ImmediateEventExecutor;\n+import io.netty.util.concurrent.Promise;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.RandomAccess;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.dns.DefaultDnsRecordDecoder.decodeName;\n+import static io.netty.handler.codec.dns.DnsRecordType.SRV;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverTerminalFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.socketChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static java.lang.System.nanoTime;\n+import static java.nio.ByteBuffer.wrap;\n+import static java.util.Collections.emptyList;\n+import static java.util.Comparator.comparing;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.function.Function.identity;\n+\n+final class DefaultDnsClient implements DnsClient {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultDnsClient.class);\n+    private static final Comparator<InetAddress> INET_ADDRESS_COMPARATOR = comparing(o -> wrap(o.getAddress()));\n+    private static final Comparator<HostAndPort> HOST_AND_PORT_COMPARATOR = comparing(HostAndPort::hostName)\n+            .thenComparingInt(HostAndPort::port);\n+    private static final Cancellable TERMINATED = () -> { };\n+    private static final Cancellable TERMINATE_ON_NEXT_REQUEST_N = () -> { };\n+\n+    private final EventLoopAwareNettyIoExecutor nettyIoExecutor;\n+    private final DnsNameResolver resolver;\n+    private final MinTtlCache ttlCache;\n+    private final Predicate<Throwable> invalidateHostsOnDnsFailure;\n+    private final ListenableAsyncCloseable asyncCloseable;\n+    private boolean closed;\n+\n+    DefaultDnsClient(final IoExecutor ioExecutor, final int minTTL,\n+                     @Nullable final Integer ndots, final Predicate<Throwable> invalidateHostsOnDnsFailure,\n+                     @Nullable final Boolean optResourceEnabled, @Nullable final Duration queryTimeout,\n+                     @Nullable final DnsResolverAddressTypes dnsResolverAddressTypes,\n+                     @Nullable final DnsServerAddressStreamProvider dnsServerAddressStreamProvider) {\n+        // Implementation of this class expects to use only single EventLoop from IoExecutor\n+        this.nettyIoExecutor = toEventLoopAwareNettyIoExecutor(ioExecutor).next();\n+        this.ttlCache = new MinTtlCache(new DefaultDnsCache(minTTL, Integer.MAX_VALUE, minTTL), minTTL);\n+        this.invalidateHostsOnDnsFailure = invalidateHostsOnDnsFailure;\n+        asyncCloseable = toAsyncCloseable(graceful -> {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                closeAsync0();\n+                return completed();\n+            }\n+            return nettyIoExecutor.asExecutor().submit(this::closeAsync0);\n+        });\n+        final EventLoop eventLoop = this.nettyIoExecutor.eventLoopGroup().next();\n+        @SuppressWarnings(\"unchecked\")\n+        final Class<? extends SocketChannel> socketChannelClass =\n+                (Class<? extends SocketChannel>) socketChannel(eventLoop, InetSocketAddress.class);\n+        final DnsNameResolverBuilder builder = new DnsNameResolverBuilder(eventLoop)\n+                .resolveCache(ttlCache)\n+                .channelType(datagramChannel(eventLoop))\n+                // Enable TCP fallback to be able to handle truncated responses.\n+                // https://tools.ietf.org/html/rfc7766\n+                .socketChannelType(socketChannelClass)\n+                // We should complete once the preferred address types could be resolved to ensure we always\n+                // respond as fast as possible.\n+                .completeOncePreferredResolved(true);\n+        if (queryTimeout != null) {\n+            builder.queryTimeoutMillis(queryTimeout.toMillis());\n+        }\n+        if (ndots != null) {\n+            builder.ndots(ndots);\n+        }\n+        if (optResourceEnabled != null) {\n+            builder.optResourceEnabled(optResourceEnabled);\n+        }\n+        if (dnsServerAddressStreamProvider != null) {\n+            builder.nameServerProvider(toNettyType(dnsServerAddressStreamProvider));\n+        }\n+        if (dnsResolverAddressTypes != null) {\n+            builder.resolvedAddressTypes(toNettyType(dnsResolverAddressTypes));\n+        }\n+\n+        resolver = builder.build();\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetAddress>> dnsQuery(final String address) {\n+        return new ARecordPublisher(true, address).flatMapConcatIterable(identity());\n+    }\n+\n+    @Override\n+    public Publisher<ServiceDiscovererEvent<InetSocketAddress>> dnsSrvQuery(final String serviceName) {\n+        return Publisher.defer(() -> {\n+            // State per subscribe requires defer so each subscribe gets independent state.\n+            final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n+            return new SrvRecordPublisher(serviceName).flatMapConcatIterable(identity())\n+                    .flatMapMergeSingle(srvEvent -> {\n+                assertInEventloop();\n+                if (srvEvent.isAvailable()) {\n+                    final ARecordPublisher aPublisher = new ARecordPublisher(false, srvEvent.address().hostName());\n+                    final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n+                    if (prevAPublisher != null) {\n+                        return failed(new IllegalStateException(\"Only 1 A* record per SRV record is supported. \" +\n+                                srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n+                                \" had a pre-existing A* record:\" + prevAPublisher.inetHost +\n+                                \" when new A* record arrived: \" + aPublisher.inetHost));\n+                    }\n+\n+                    return srvARecordPubToSingle(aPublisher, srvEvent, serviceName);\n+                } else {\n+                    final ARecordPublisher aPublisher = aRecordMap.remove(srvEvent.address());\n+                    if (aPublisher != null) {\n+                        final List<ServiceDiscovererEvent<InetAddress>> list = aPublisher.close0();\n+                        if (list != null) {\n+                            return srvARecordPubToSingle(Publisher.from(list), srvEvent, serviceName);\n+                        }\n+                    }\n+\n+                    return failed(new IllegalStateException(\"Received an SRV inactive event for \" +\n+                            srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n+                            \" but failed to find the corresponding A* record Publisher.\"));\n+                }\n+            });\n+        });\n+    }\n+\n+    private static Single<? extends ServiceDiscovererEvent<InetSocketAddress>> srvARecordPubToSingle(\n+            Publisher<Iterable<ServiceDiscovererEvent<InetAddress>>> aRecordPublisher,\n+            ServiceDiscovererEvent<HostAndPort> srvEvent, String serviceName) {\n+        return aRecordPublisher.flatMapConcatIterable(identity()).map(inetEvent -> new DefaultServiceDiscovererEvent<>(\n+                new InetSocketAddress(inetEvent.address(), srvEvent.address().port()), inetEvent.isAvailable())\n+        ).firstOrElse(() -> {\n+            LOGGER.info(\"No A* records found for {} corresponding to SRV name {}\", srvEvent.address(), serviceName);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public Completable onClose() {\n+        return asyncCloseable.onClose();\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return asyncCloseable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return asyncCloseable.closeAsyncGracefully();\n+    }\n+\n+    private void closeAsync0() {\n+        assertInEventloop();\n+\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        resolver.close();\n+        ttlCache.clear();\n+    }\n+\n+    private void assertInEventloop() {\n+        assert nettyIoExecutor.isCurrentThreadEventLoop() : \"Must be called from the associated eventloop.\";\n+    }\n+\n+    private final class SrvRecordPublisher extends AbstractDnsPublisher<HostAndPort> {\n+        private final String serviceName;\n+\n+        private SrvRecordPublisher(String serviceName) {\n+            this.serviceName = requireNonNull(serviceName);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return serviceName;\n+        }\n+\n+        @Override\n+        protected AbstractDnsSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<HostAndPort>>> subscriber) {\n+            return new AbstractDnsSubscription(true, subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<HostAndPort>> doDnsQuery() {\n+                    Promise<DnsAnswer<HostAndPort>> promise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(new DefaultDnsQuestion(serviceName, SRV))\n+                            .addListener((Future<? super List<DnsRecord>> completedFuture) -> {\n+                                Throwable cause = completedFuture.cause();\n+                                if (cause != null) {\n+                                    promise.setFailure(cause);\n+                                } else {\n+                                    final DnsAnswer<HostAndPort> dnsAnswer;\n+                                    long minTTLSeconds = Long.MAX_VALUE;\n+                                    try {\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final List<DnsRecord> dnsRecords = (List<DnsRecord>) completedFuture.getNow();\n+                                        final List<HostAndPort> hostAndPorts = new ArrayList<>(dnsRecords.size());\n+                                        for (DnsRecord dnsRecord : dnsRecords) {\n+                                            if (!SRV.equals(dnsRecord.type()) || !(dnsRecord instanceof DnsRawRecord)) {\n+                                                throw new IllegalArgumentException(\n+                                                        \"Unsupported DNS record type for SRV query: \" + dnsRecord);\n+                                            }\n+                                            if (dnsRecord.timeToLive() < minTTLSeconds) {\n+                                                minTTLSeconds = dnsRecord.timeToLive();\n+                                            }\n+                                            ByteBuf content = ((DnsRawRecord) dnsRecord).content();\n+                                            // https://tools.ietf.org/html/rfc2782\n+                                            // Priority(16u) Weight(16u) Port(16u) Target(varstring)\n+                                            content.skipBytes(4); // ignore Priority and Weight for now\n+                                            final int port = content.readUnsignedShort();\n+                                            hostAndPorts.add(HostAndPort.of(decodeName(content), port));\n+                                        }\n+                                        dnsAnswer = new DnsAnswer<>(hostAndPorts, SECONDS.toNanos(minTTLSeconds));\n+                                    } catch (Throwable cause2) {\n+                                        promise.setFailure(cause2);\n+                                        return;\n+                                    }\n+                                    promise.setSuccess(dnsAnswer);\n+                                }\n+                            });\n+                    return promise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<HostAndPort>> calculateDifference(\n+                        final List<HostAndPort> previousList, final List<HostAndPort> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, HOST_AND_PORT_COMPARATOR);\n+                }\n+            };\n+        }\n+    }\n+\n+    private class ARecordPublisher extends AbstractDnsPublisher<InetAddress> {\n+        private final String inetHost;\n+        private final boolean cancelClearsSubscription;\n+\n+        ARecordPublisher(boolean cancelClearsSubscription, String inetHost) {\n+            this.cancelClearsSubscription = cancelClearsSubscription;\n+            this.inetHost = inetHost;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return inetHost;\n+        }\n+\n+        @Override\n+        protected AbstractDnsSubscription newSubscription(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<InetAddress>>> subscriber) {\n+            return new AbstractDnsSubscription(cancelClearsSubscription, subscriber) {\n+                @Override\n+                protected Future<DnsAnswer<InetAddress>> doDnsQuery() {\n+                    ttlCache.prepareForResolution(inetHost);\n+                    Promise<DnsAnswer<InetAddress>> dnsAnswerPromise = ImmediateEventExecutor.INSTANCE.newPromise();\n+                    resolver.resolveAll(inetHost).addListener(completedFuture -> {\n+                        Throwable cause = completedFuture.cause();\n+                        if (cause != null) {\n+                            dnsAnswerPromise.setFailure(cause);\n+                        } else {\n+                            final DnsAnswer<InetAddress> dnsAnswer;\n+                            try {\n+                                @SuppressWarnings(\"unchecked\")\n+                                final List<InetAddress> addresses = (List<InetAddress>) completedFuture.getNow();\n+                                dnsAnswer = new DnsAnswer<>(addresses, SECONDS.toNanos(ttlCache.minTtl(inetHost)));\n+                            } catch (Throwable cause2) {\n+                                dnsAnswerPromise.setFailure(cause2);\n+                                return;\n+                            }\n+                            dnsAnswerPromise.setSuccess(dnsAnswer);\n+                        }\n+                    });\n+                    return dnsAnswerPromise;\n+                }\n+\n+                @Nullable\n+                @Override\n+                protected List<ServiceDiscovererEvent<InetAddress>> calculateDifference(\n+                        final List<InetAddress> previousList, final List<InetAddress> newList) {\n+                    return ServiceDiscovererUtils.calculateDifference(\n+                            previousList, newList, INET_ADDRESS_COMPARATOR);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static final class DnsAnswer<T> {\n+        private final List<T> answer;\n+        private final long ttlNanos;\n+\n+        DnsAnswer(final List<T> answer, final long ttlNanos) {\n+            this.answer = answer;\n+            this.ttlNanos = ttlNanos;\n+        }\n+\n+        List<T> answer() {\n+            return answer;\n+        }\n+\n+        long ttlNanos() {\n+            return ttlNanos;\n+        }\n+    }\n+\n+    private abstract class AbstractDnsPublisher<T>\n+            extends SubscribablePublisher<Iterable<ServiceDiscovererEvent<T>>> {\n+        @Nullable\n+        private AbstractDnsSubscription subscription;\n+\n+        protected abstract AbstractDnsSubscription\n+                newSubscription(Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber);\n+\n+        @Override\n+        protected final void handleSubscribe(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                handleSubscribe0(subscriber);\n+            } else {\n+                nettyIoExecutor.asExecutor().execute(() -> handleSubscribe0(subscriber));\n+            }\n+        }\n+\n+        private void handleSubscribe0(\n+                final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+            assertInEventloop();\n+\n+            if (subscription != null) {\n+                deliverTerminalFromSource(subscriber,\n+                        new DuplicateSubscribeException(subscription, subscriber));\n+            } else if (closed) {\n+                deliverTerminalFromSource(subscriber,\n+                        new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                                \" has been closed!\"));\n+            } else {\n+                subscription = newSubscription(subscriber);\n+                subscriber.onSubscribe(subscription);\n+            }\n+        }\n+\n+        @Nullable\n+        final List<ServiceDiscovererEvent<T>> close0() {\n+            assertInEventloop();\n+\n+            if (subscription != null) {\n+                List<ServiceDiscovererEvent<T>> events = subscription.cancelClearsSubscription ? null :\n+                        subscription.generateInactiveEvent();\n+\n+                // this method call will null out the subscription reference after it is terminated.\n+                subscription.closeAndTerminate0();\n+\n+                return events;\n+            }\n+            return null;\n+        }\n+\n+        abstract class AbstractDnsSubscription implements Subscription {\n+            private final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber;\n+            /**\n+             * A record resolution for SRV uses flatMapSingle and firstOnOrError which will cancel inline with the\n+             * first onNext signal. However when we encounter a SRV in-active event we need to manually generate a A*\n+             * record in-active event corresponding for the currently active A* addresses. This means when the cancel\n+             * occurs we need to preserve the {@link #activeAddresses} state for {@link #generateInactiveEvent()}.\n+             */\n+            private final boolean cancelClearsSubscription;\n+            private long pendingRequests;\n+            private List<T> activeAddresses;\n+            private long resolveDoneNoScheduleTime;\n+            @Nullable\n+            private Cancellable cancellableForQuery;\n+            private long ttlNanos;\n+\n+            AbstractDnsSubscription(boolean cancelClearsSubscription,\n+                                    final Subscriber<? super Iterable<ServiceDiscovererEvent<T>>> subscriber) {\n+                this.cancelClearsSubscription = cancelClearsSubscription;\n+                this.subscriber = subscriber;\n+                activeAddresses = emptyList();\n+                ttlNanos = -1;\n+            }\n+\n+            protected abstract Future<DnsAnswer<T>> doDnsQuery();\n+\n+            @Nullable\n+            protected abstract List<ServiceDiscovererEvent<T>>\n+                    calculateDifference(List<T> previousList, List<T> newList);\n+\n+            @Override\n+            public final void request(final long n) {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    request0(n);\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(() -> request0(n));\n+                }\n+            }\n+\n+            @Override\n+            public final void cancel() {\n+                if (nettyIoExecutor.isCurrentThreadEventLoop()) {\n+                    cancel0();\n+                } else {\n+                    nettyIoExecutor.asExecutor().execute(this::cancel0);\n+                }\n+            }\n+\n+            private void request0(final long n) {\n+                assertInEventloop();\n+\n+                if (!isRequestNValid(n)) {\n+                    handleTerminalError0(newExceptionForInvalidRequestN(n));\n+                    return;\n+                }\n+\n+                pendingRequests = addWithOverflowProtection(pendingRequests, n);\n+                if (cancellableForQuery == null) {\n+                    if (ttlNanos < 0) {\n+                        doQuery0();\n+                    } else {\n+                        final long durationNs = nanoTime() - resolveDoneNoScheduleTime;\n+                        if (durationNs > ttlNanos) {\n+                            doQuery0();\n+                        } else {\n+                            scheduleQuery0(ttlNanos - durationNs);\n+                        }\n+                    }\n+                } else if (cancellableForQuery == TERMINATE_ON_NEXT_REQUEST_N) {\n+                    assert pendingRequests > 0;\n+                    tryTerminateOnComplete(); // we were waiting for demand, and got it. time to deliver the data.\n+                }\n+            }\n+\n+            private void doQuery0() {\n+                assertInEventloop();\n+\n+                if (closed) {\n+                    // best effort check to cleanup state after close.\n+                    handleTerminalError0(new ClosedServiceDiscovererException(DefaultDnsClient.this +\n+                            \" has been closed!\"));\n+                } else {\n+                    LOGGER.trace(\"DnsClient {}, querying DNS for {}\", DefaultDnsClient.this, AbstractDnsPublisher.this);\n+                    final Future<DnsAnswer<T>> addressFuture = doDnsQuery();\n+                    cancellableForQuery = () -> addressFuture.cancel(true);\n+                    if (addressFuture.isDone()) {\n+                        handleResolveDone0(addressFuture);\n+                    } else {\n+                        addressFuture.addListener((FutureListener<DnsAnswer<T>>) this::handleResolveDone0);\n+                    }\n+                }\n+            }\n+\n+            private void cancel0() {\n+                assertInEventloop();\n+                if (cancellableForQuery != null) {\n+                    cancellableForQuery.cancel();\n+                }\n+                if (cancelClearsSubscription) {\n+                    clearState();\n+                }\n+            }\n+\n+            private void clearState() {\n+                cancellableForQuery = TERMINATED;\n+                subscription = null;\n+            }\n+\n+            private void closeAndTerminate0() {\n+                if (cancellableForQuery != null) {\n+                    cancellableForQuery.cancel();\n+                }\n+                tryTerminateOnComplete();\n+            }\n+\n+            private void tryTerminateOnComplete() {\n+                final boolean deliverTerminal;\n+                try {\n+                    deliverTerminal = clearAddressesAndPropagateRemovalEvents();\n+                } catch (Throwable cause) {\n+                    clearState(); // must null out subscription before terminating to allow for re-subscribe.\n+                    safeOnError(subscriber, cause);\n+                    return;\n+                }\n+                if (deliverTerminal) {\n+                    clearState(); // must null out subscription before terminating to allow for re-subscribe.\n+                    safeOnComplete(subscriber);\n+                } else {\n+                    cancellableForQuery = TERMINATE_ON_NEXT_REQUEST_N;\n+                }\n+            }\n+\n+            private void scheduleQuery0(final long nanos) {\n+                assertInEventloop();\n+\n+                LOGGER.trace(\"DnsClient {}, scheduling DNS query for {} after {} nanos.\",\n+                        DefaultDnsClient.this, AbstractDnsPublisher.this, nanos);\n+\n+                // This value is coming from DNS TTL for which the unit is seconds and the minimum value we accept\n+                // in the builder is 1 second.\n+                cancellableForQuery = nettyIoExecutor.asExecutor().schedule(\n+                        this::doQuery0, nanos, NANOSECONDS);\n+            }\n+\n+            private void handleResolveDone0(final Future<DnsAnswer<T>> addressFuture) {\n+                assertInEventloop();\n+                assert pendingRequests > 0;\n+                if (cancellableForQuery == TERMINATED) {\n+                    return;\n+                } else if (cancellableForQuery == TERMINATE_ON_NEXT_REQUEST_N) {\n+                    tryTerminateOnComplete();\n+                    return;\n+                }\n+                final Throwable cause = addressFuture.cause();\n+                if (cause != null) {\n+                    boolean deliverTerminal = true;\n+                    try {\n+                        deliverTerminal = !invalidateHostsOnDnsFailure.test(cause) ||\n+                                clearAddressesAndPropagateRemovalEvents();\n+                    } catch (Throwable cause2) {\n+                        logUnexpectedException(cause2);\n+                    }\n+\n+                    if (deliverTerminal) {\n+                        cancel0();\n+                        safeOnError(subscriber, cause);\n+                    } else {\n+                        cancellableForQuery = TERMINATE_ON_NEXT_REQUEST_N;\n+                    }\n+                } else {\n+                    // DNS lookup can return duplicate InetAddress\n+                    DnsAnswer<T> dnsAnswer = addressFuture.getNow();\n+                    final List<T> addresses = dnsAnswer.answer();\n+                    final List<ServiceDiscovererEvent<T>> events = calculateDifference(activeAddresses, addresses);\n+                    ttlNanos = dnsAnswer.ttlNanos();\n+                    if (events != null) {\n+                        activeAddresses = addresses;\n+                        if (--pendingRequests > 0) {\n+                            scheduleQuery0(ttlNanos);\n+                        } else {\n+                            resolveDoneNoScheduleTime = nanoTime();\n+                            cancellableForQuery = null;\n+                        }\n+                        try {\n+                            LOGGER.debug(\"DnsClient {}, sending events for address: {} (size {}) {}.\",\n+                                    DefaultDnsClient.this, AbstractDnsPublisher.this, events.size(), events);\n+\n+                            subscriber.onNext(events);\n+                        } catch (final Throwable error) {\n+                            handleTerminalError0(error);\n+                        }\n+                    } else {\n+                        LOGGER.trace(\"DnsClient {}, resolution done but no changes for address: {} (size {}) {}.\",\n+                                DefaultDnsClient.this, AbstractDnsPublisher.this, activeAddresses.size(),\n+                                activeAddresses);\n+\n+                        scheduleQuery0(ttlNanos);\n+                    }\n+                }\n+            }\n+\n+            private void handleTerminalError0(final Throwable cause) {\n+                assertInEventloop();\n+                if (cancellableForQuery != TERMINATED) {\n+                    cancel0();\n+                    safeOnError(subscriber, cause);\n+                }\n+            }\n+\n+            private void logUnexpectedException(Throwable cause) {\n+                LOGGER.warn(\"Exception from subscriber {} while handling error in DNS subscription {}\",\n+                        subscriber, this, cause);\n+            }\n+\n+            private boolean clearAddressesAndPropagateRemovalEvents() {\n+                assertInEventloop();\n+\n+                if (activeAddresses.isEmpty()) {\n+                    return true;\n+                } else if (pendingRequests > 0) {", "originalCommit": "fbd69139ef6ef0efb50896ba2bde708963674a71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}