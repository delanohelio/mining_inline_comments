{"pr_number": 1015, "pr_title": "ConcurrentSubscripiton avoid concurrent access for invalid demand", "pr_createdAt": "2020-04-14T20:48:57Z", "pr_url": "https://github.com/apple/servicetalk/pull/1015", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMjI4Mg==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r408602282", "bodyText": "nit: consider define a static field for 0 so its a bit less of a magic number", "author": "normanmaurer", "createdAt": "2020-04-15T06:11:16Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -36,6 +37,49 @@ private ConcurrentUtils() {\n         // No instances.\n     }\n \n+    /**\n+     * Acquire a lock that allows reentry and attempts to acquire the lock while it is\n+     * held can be detected by {@link #releasePendingReentrantLock(AtomicLongFieldUpdater, long, Object)}.\n+     * @param lockUpdater The {@link AtomicLongFieldUpdater} used to control the lock state.\n+     * @param owner The owner of the lock object.\n+     * @param <T> The type of object that owns the lock.\n+     * @return {@code 0} if the acquire was unsuccessful, otherwise an identifier that must be passed to a subsequent\n+     * call of {@link #releasePendingReentrantLock(AtomicLongFieldUpdater, long, Object)}.\n+     */\n+    public static <T> long acquirePendingReentrantLock(final AtomicLongFieldUpdater<T> lockUpdater, final T owner) {\n+        final long threadId = Thread.currentThread().getId();\n+        for (;;) {\n+            final long prevThreadId = lockUpdater.get(owner);\n+            if (prevThreadId == 0) {\n+                if (lockUpdater.compareAndSet(owner, 0, threadId)) {\n+                    return threadId;\n+                }\n+            } else if (prevThreadId == threadId || prevThreadId == -threadId) {\n+                return -threadId;\n+            } else if (lockUpdater.compareAndSet(owner, prevThreadId,\n+                    prevThreadId > 0 ? -prevThreadId : prevThreadId)) {\n+                return 0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Release a lock that was previously acquired via\n+     * {@link #acquirePendingReentrantLock(AtomicLongFieldUpdater, Object)}.\n+     * @param lockUpdater The {@link AtomicLongFieldUpdater} used to control the lock state.\n+     * @param acquireId The value returned from the previous call to\n+     * {@link #acquirePendingReentrantLock(AtomicLongFieldUpdater, Object)}.\n+     * @param owner The owner of the lock object.\n+     * @param <T> The type of object that owns the lock.\n+     * @return {@code true} if the lock was released, or this method call corresponds to a prior re-entrant call\n+     * to {@link #acquirePendingReentrantLock(AtomicLongFieldUpdater, Object)}.\n+     */\n+    public static <T> boolean releasePendingReentrantLock(final AtomicLongFieldUpdater<T> lockUpdater,\n+                                                          final long acquireId, final T owner) {\n+        assert acquireId != 0;\n+        return acquireId < 0 || lockUpdater.getAndSet(owner, 0) == acquireId;", "originalCommit": "d7a6ca3fad3fd46ba377f7e97ae4d492919886f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4NzU2NA==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r408987564", "bodyText": "done", "author": "Scottmitch", "createdAt": "2020-04-15T16:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMjI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMjc2Nw==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r408602767", "bodyText": "nit: Imho chaining stuff like this is really not readable. Consider using a branch", "author": "normanmaurer", "createdAt": "2020-04-15T06:12:51Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +74,59 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,\n+                                prevPendingDemand + min(Long.MAX_VALUE - prevPendingDemand, n))) {\n+                    break;\n                 }\n             }\n-            if (n < 0) {\n-                subscription.cancel();\n-                return; // Don't set subscriptionLockOwner = 0 ... we don't want to request any more!\n+        }\n+        Throwable delayedCause = null;\n+        for (;;) {\n+            final long acquireId = acquirePendingReentrantLock(subscriptionLockUpdater, this);\n+            if (acquireId == 0) {\n+                break;\n             }\n+\n             try {\n-                subscription.request(n);\n+                final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                if (prevPendingDemand == CANCELLED) {\n+                    subscription.cancel();\n+                } else if (prevPendingDemand != 0) {\n+                    subscription.request(prevPendingDemand);\n+                }\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {\n+                    delayedCause = cause;\n+                }\n             } finally {\n-                subscriptionLockOwner = null;\n+                if (releasePendingReentrantLock(subscriptionLockUpdater, acquireId, this)) {\n+                    break;\n+                }\n             }\n-            n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-        } while (n != 0);\n+        }\n+\n+        if (delayedCause != null) {\n+            throwException(delayedCause);\n+        }\n     }\n \n     @Override\n     public void cancel() {\n-        // Set the queue to MIN_VALUE and this will be detected in request(n).\n-        // We unconditionally set this value just in case there is re-entry with request(n) we will avoid calling\n-        // the subscription's request(n) after cancel().\n-        subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-\n-        final Thread currentThread = Thread.currentThread();\n-        final Thread subscriptionLockOwner = this.subscriptionLockOwner;\n-        if (subscriptionLockOwner == currentThread || subscriptionLockOwnerUpdater.compareAndSet(this, null,\n-                currentThread)) {\n+        pendingDemand = CANCELLED;\n+        if (acquirePendingReentrantLock(subscriptionLockUpdater, this) != 0) {\n             subscription.cancel();\n+            // poison subscriptionLockUpdater\n         }\n     }\n+\n+    private static long mapInvalidRequestN(long n) {\n+        // We map zero to a negative number because zero could later be overwritten by a subsequent legit value of\n+        // n, and we want to ensure the invalid use gets propagated.\n+        return n == CANCELLED ? CANCELLED + 1 : n == 0 ? -1 : n;", "originalCommit": "d7a6ca3fad3fd46ba377f7e97ae4d492919886f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU5NzQzMg==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r416597432", "bodyText": "@Scottmitch ^^", "author": "normanmaurer", "createdAt": "2020-04-28T13:07:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMjc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1MjYyMw==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417652623", "bodyText": "I prefer to keep the code as is as it is more compact and I don't think readability is dramatically different between the two options:\ncurrent option:\nreturn n == CANCELLED ? CANCELLED + 1 : n == 0 ? -1 : n;\n\nsuggested option:\nif (n == CANCELLED) {\n  return CANCELLED + 1;\n}\nreturn n == 0 ? -1 : n;", "author": "Scottmitch", "createdAt": "2020-04-29T22:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMjc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMjk0Nw==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r408602947", "bodyText": "should we use addSuppressed(...) if delayCause != null ?", "author": "normanmaurer", "createdAt": "2020-04-15T06:13:24Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +74,59 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,\n+                                prevPendingDemand + min(Long.MAX_VALUE - prevPendingDemand, n))) {\n+                    break;\n                 }\n             }\n-            if (n < 0) {\n-                subscription.cancel();\n-                return; // Don't set subscriptionLockOwner = 0 ... we don't want to request any more!\n+        }\n+        Throwable delayedCause = null;\n+        for (;;) {\n+            final long acquireId = acquirePendingReentrantLock(subscriptionLockUpdater, this);\n+            if (acquireId == 0) {\n+                break;\n             }\n+\n             try {\n-                subscription.request(n);\n+                final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                if (prevPendingDemand == CANCELLED) {\n+                    subscription.cancel();\n+                } else if (prevPendingDemand != 0) {\n+                    subscription.request(prevPendingDemand);\n+                }\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {\n+                    delayedCause = cause;\n+                }", "originalCommit": "d7a6ca3fad3fd46ba377f7e97ae4d492919886f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3OTA3Nw==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r409179077", "bodyText": "lets discuss on #1011 (comment)", "author": "Scottmitch", "createdAt": "2020-04-15T22:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMjk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMzEyMg==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r408603122", "bodyText": "nit: why this change ?", "author": "normanmaurer", "createdAt": "2020-04-15T06:13:55Z", "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/PublisherFlatMapSingleTest.java", "diffHunk": "@@ -67,7 +67,7 @@\n \n public class PublisherFlatMapSingleTest {\n     @Rule\n-    public final Timeout timeout = new ServiceTalkTestTimeout(30, SECONDS);\n+    public final Timeout timeout = new ServiceTalkTestTimeout();", "originalCommit": "d7a6ca3fad3fd46ba377f7e97ae4d492919886f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4OTI4Nw==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r408989287", "bodyText": "the test doesn't need a special timeout and can use the default value. we now have a higher default value for CI that didn't exist when this timeout was originally configured.", "author": "Scottmitch", "createdAt": "2020-04-15T16:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMzEyMg=="}], "type": "inlineReview"}, {"oid": "825e5c2c280ab021b10aefbeeb761f4513703fd5", "url": "https://github.com/apple/servicetalk/commit/825e5c2c280ab021b10aefbeeb761f4513703fd5", "message": "ConcurrentSubscripiton avoid concurrent access for invalid demand\n\nMotivation:\nConcurrentSubscription currently propagates invalid demand without any\nconcurrency protection. In general this is invalid use of the API but\nmay invalidate underlying data structures that are not thread safe and\nresult in undefined results.\n\nModifications:\n- Use a simpler locking scheme inspired by Publisher#flatMapMerge design\nwhich allows for re-entry and also notification is another thread has\nattempted to acquire the lock which will trigger re-processing.\n\nResult:\nConcurrentSubscripiton no longer allows any concurrent access and uses a\nmore common/shareable locking utility.", "committedDate": "2020-04-28T03:56:06Z", "type": "forcePushed"}, {"oid": "71b94a4a2c3d55e01781b69866d54807a7c64501", "url": "https://github.com/apple/servicetalk/commit/71b94a4a2c3d55e01781b69866d54807a7c64501", "message": "ConcurrentSubscripiton avoid concurrent access for invalid demand\n\nMotivation:\nConcurrentSubscription currently propagates invalid demand without any\nconcurrency protection. In general this is invalid use of the API but\nmay invalidate underlying data structures that are not thread safe and\nresult in undefined results.\n\nModifications:\n- Use a simpler locking scheme inspired by Publisher#flatMapMerge design\nwhich allows for re-entry and also notification is another thread has\nattempted to acquire the lock which will trigger re-processing.\n\nResult:\nConcurrentSubscripiton no longer allows any concurrent access and uses a\nmore common/shareable locking utility.", "committedDate": "2020-04-28T04:37:08Z", "type": "forcePushed"}, {"oid": "064f892a42d2c6f8925d779057ad8936dc0bc0c6", "url": "https://github.com/apple/servicetalk/commit/064f892a42d2c6f8925d779057ad8936dc0bc0c6", "message": "ConcurrentSubscripiton avoid concurrent access for invalid demand\n\nMotivation:\nConcurrentSubscription currently propagates invalid demand without any\nconcurrency protection. In general this is invalid use of the API but\nmay invalidate underlying data structures that are not thread safe and\nresult in undefined results.\n\nModifications:\n- Use a simpler locking scheme inspired by Publisher#flatMapMerge design\nwhich allows for re-entry and also notification is another thread has\nattempted to acquire the lock which will trigger re-processing.\n\nResult:\nConcurrentSubscripiton no longer allows any concurrent access and uses a\nmore common/shareable locking utility.", "committedDate": "2020-04-28T04:55:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMzUxMg==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417523512", "bodyText": "thread IDs are reusable upon thread termination[1]. So, if a thread dies while acquiring the lock, this method will not be able to identify that situation. Did you consider this?\n[1]\n    /**\n     * Returns the identifier of this Thread.  The thread ID is a positive\n     * {@code long} number generated when this thread was created.\n     * The thread ID is unique and remains unchanged during its lifetime.\n     * When a thread is terminated, this thread ID may be reused.\n     *\n     * @return this thread's ID.\n     * @since 1.5\n     */\n    public long getId() {\n        return tid;\n    }", "author": "NiteshKant", "createdAt": "2020-04-29T18:28:01Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -65,6 +76,49 @@ private ConcurrentUtils() {\n         return lockUpdater.getAndSet(owner, CONCURRENT_IDLE) == CONCURRENT_EMITTING;\n     }\n \n+    /**\n+     * Acquire a lock that allows reentry and attempts to acquire the lock while it is\n+     * held can be detected by {@link #releaseReentrantLock(AtomicLongFieldUpdater, long, Object)}.\n+     * @param lockUpdater The {@link AtomicLongFieldUpdater} used to control the lock state.\n+     * @param owner The owner of the lock object.\n+     * @param <T> The type of object that owns the lock.\n+     * @return {@code 0} if the acquire was unsuccessful, otherwise an identifier that must be passed to a subsequent\n+     * call of {@link #releaseReentrantLock(AtomicLongFieldUpdater, long, Object)}.\n+     */\n+    public static <T> long tryAcquireReentrantLock(final AtomicLongFieldUpdater<T> lockUpdater, final T owner) {\n+        final long threadId = Thread.currentThread().getId();\n+        for (;;) {\n+            final long prevThreadId = lockUpdater.get(owner);\n+            if (prevThreadId == REENTRANT_LOCK_ZERO_THREAD_ID) {\n+                if (lockUpdater.compareAndSet(owner, REENTRANT_LOCK_ZERO_THREAD_ID, threadId)) {\n+                    return threadId;\n+                }\n+            } else if (prevThreadId == threadId || prevThreadId == -threadId) {", "originalCommit": "064f892a42d2c6f8925d779057ad8936dc0bc0c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU2OTc2OQ==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417569769", "bodyText": "A thread which acquires the lock cannot be \"terminated\" (e.g. complete execution) without releasing the lock as the thread is currently executing the code inside the try {} finally {} scope where the lock is held. So either this is the same thread in a reentrant situation, or it is a different thread which will have a different ID (as thread IDs are unique for live threads).\nThread#stop exists which in theory could called by a method while the lock is held, but the thread doesn't \"terminate\" until exiting the stack. On a related note Thread#stop is @Deprecated and marked as inherently unsafe ... potentially resulting in arbitrary behavior.", "author": "Scottmitch", "createdAt": "2020-04-29T19:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMzUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY3NzU2OQ==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r419677569", "bodyText": "Ok so I think this means that this method must only be called when used with try-finally and not across thread boundaries like we do in NettyPipelinedConnection.  If there are inherent assumptions like this then either we should mention it in the method name or in javadocs.", "author": "NiteshKant", "createdAt": "2020-05-04T19:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMzUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxMjk3NA==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r419712974", "bodyText": "Good point, there are some additional constraints worth clarifying.\n\nThis lock must eventually be released by the same thread that acquired the lock. If the thread\nthat acquires this lock is terminated before releasing the lock state is undefined.\n\nfwiw the lock can be used across thread boundaries, and shared characteristics with the non-reentrant lock where usage outside of a try/finally can lead to undefined state (e.g. missed unlock), however the interesting part here is if the thread which acquires the lock is terminated before release that leads to an undefined state (clarified in comments above).", "author": "Scottmitch", "createdAt": "2020-05-04T20:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMzUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyOTk4NA==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417529984", "bodyText": "Is this any different than:\npendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);", "author": "NiteshKant", "createdAt": "2020-04-29T18:39:00Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +70,58 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,", "originalCommit": "064f892a42d2c6f8925d779057ad8936dc0bc0c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU3MjkwMg==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417572902", "bodyText": "hum good point this should be the equivalent. only difference is with a negative value here we just move on (no CAS), accumulateAndGet will still do the CAS-loop, but this is fine.", "author": "Scottmitch", "createdAt": "2020-04-29T19:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyOTk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUzNjc0OQ==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417536749", "bodyText": "Strangely there are no tests for ConcurrentSubscription \ud83d\ude2d .. can we add now since we are modifying the implementation?", "author": "NiteshKant", "createdAt": "2020-04-29T18:50:34Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -33,21 +35,18 @@\n  * </a> rule. It also allows a custom {@link Cancellable} to be used in the event that there maybe multiple cancel\n  * operations which are linked, but we still need to prevent concurrent invocation of the {@link Subscription#cancel()}\n  * and {@link Subscription#cancel()} methods.\n- * <p>\n- * Be aware with invalid input to {@link #request(long)} we don't attempt to enforce concurrency and rely upon the\n- * subscription to enforce the specification\n- * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9\">3.9</a> rule.\n  */\n public class ConcurrentSubscription implements Subscription {", "originalCommit": "064f892a42d2c6f8925d779057ad8936dc0bc0c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUzODM4OA==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417538388", "bodyText": "Do we need to allow reentrancy here? I am aware that request(n) can be reentrant but it seems like we can avoid allowing reentrancy and just request more when unrolling the stack like we usually do with other concurrent-queue-drain-pattern elsewhere. Am I missing something here?\n@Override\npublic void request(long n) {\n    if (!isRequestNValid(n)) {\n        pendingDemand = mapInvalidRequestN(n);\n    } else {\n        pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n    }\n    do {\n        if (!tryAcquireLock(subscriptionLockUpdater, this)) {\n            break;\n        }\n\n        final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n        if (prevPendingDemand == CANCELLED) {\n            subscription.cancel();\n        } else if (prevPendingDemand != 0) {\n            subscription.request(prevPendingDemand);\n        }\n    } while (!releaseLock(subscriptionLockUpdater, this));\n}\n\n@Override\npublic void cancel() {\n    pendingDemand = CANCELLED;\n    if (tryAcquireLock(subscriptionLockUpdater, this)) {\n        subscription.cancel();\n        // poison subscriptionLockUpdater\n    }\n}", "author": "NiteshKant", "createdAt": "2020-04-29T18:53:16Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +70,58 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,\n+                                prevPendingDemand + min(Long.MAX_VALUE - prevPendingDemand, n))) {\n+                    break;\n                 }\n             }\n-            if (n < 0) {\n-                subscription.cancel();\n-                return; // Don't set subscriptionLockOwner = 0 ... we don't want to request any more!\n+        }\n+        Throwable delayedCause = null;\n+        boolean tryAcquire;\n+        do {\n+            final long acquireId = tryAcquireReentrantLock(subscriptionLockUpdater, this);", "originalCommit": "064f892a42d2c6f8925d779057ad8936dc0bc0c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1MDUzOA==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417650538", "bodyText": "good point, I also considered this. the re-entrant lock isn't strictly necessary for correctness as we could use the non-reentrant lock which also requires re-acquire semantics. for re-entry scenarios this approach saves a CAS on each re-entrant operation and trades it for a Thread.getId() (which is thread local state). Current approach preserves the previous re-entrant semantics in this class to minimize behavior difference and also shows perf improvement:\n# Reentrant lock (this PR)\nBenchmark                                     Mode  Cnt         Score        Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  47753164.225 \u00b1 850903.330  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5    714751.803 \u00b1   8155.984  ops/s\n\nBenchmark                                     Mode  Cnt         Score         Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  48522938.411 \u00b1 1065238.470  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5    723176.975 \u00b1   11730.345  ops/s\n\nBenchmark                                     Mode  Cnt         Score        Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  48460738.326 \u00b1 918765.253  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5    718663.755 \u00b1  22510.103  ops/s\n\n# Non-reentrant (this PR modified to use tryAcquireLock)\nBenchmark                                     Mode  Cnt         Score         Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  46236169.698 \u00b1 1304606.373  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5    379186.656 \u00b1    7327.488  ops/s\n\nBenchmark                                     Mode  Cnt         Score        Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  46554069.756 \u00b1 770443.754  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5    374243.264 \u00b1   4981.803  ops/s\n\nBenchmark                                     Mode  Cnt         Score        Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  46420860.395 \u00b1 906316.830  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5    379715.245 \u00b1   7939.865  ops/s", "author": "Scottmitch", "createdAt": "2020-04-29T22:30:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUzODM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MzI4MQ==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417663281", "bodyText": "Current approach preserves the previous re-entrant semantics in this class to minimize behavior difference\n\nWe are modifying an internal class in a way that adheres to the specifications. If we do not depend on this behavior (which we shouldn't), I don't think there is anything wrong in simplification. Allowing re-entrancy here adds more complexity in this code and additionally in ConcurrentUtils. Removing re-entrancy reduces thread-stack which is a net win.\nI don't think the small perf win trumps the other benefits.", "author": "NiteshKant", "createdAt": "2020-04-29T23:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUzODM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NDc1OA==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417664758", "bodyText": "The benchmark was helpful :) detected regression from master on the no-reentrant case. master skips the atomic long accumulator if we are able to acquire the lock, but trades some concurrency. I added a fast path when no concurrency is detected and we now gain in both cases (re-entrant and non-reentrant).\n# Re-entrant with fast path\nBenchmark                                     Mode  Cnt         Score        Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  74805386.276 \u00b1 746665.173  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5   1895818.132 \u00b1  31661.798  ops/s\n\nBenchmark                                     Mode  Cnt         Score        Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  74602546.497 \u00b1 972834.986  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5   2035494.125 \u00b1  28986.077  ops/s\n\nBenchmark                                     Mode  Cnt         Score        Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  74724470.463 \u00b1 809942.225  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5   1864583.823 \u00b1  48146.217  ops/s\n\n# master\nBenchmark                                     Mode  Cnt         Score        Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  59009939.298 \u00b1 913522.147  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5    449874.916 \u00b1  10856.180  ops/s\n\nBenchmark                                     Mode  Cnt         Score        Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  58815916.826 \u00b1 963463.757  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5    447968.057 \u00b1   6171.099  ops/s\n\nBenchmark                                     Mode  Cnt         Score         Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  58929994.344 \u00b1 1208720.403  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5    446883.247 \u00b1   15198.500  ops/s", "author": "Scottmitch", "createdAt": "2020-04-29T23:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUzODM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY3NDAzOQ==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417674039", "bodyText": "Here are the numbers for the tryAcquireLock version with fast path. The noReentrant is similar as expected now but the re-entrant case is much worse (only ~18% of the perf). In order to avoid regression I think it makes sense to move forward with the approach in this PR (as opposed to using tryAcquireLock).\n# Non-reentrant (this PR with fast path, modified to use tryAcquireLock)\nBenchmark                                     Mode  Cnt         Score         Error  Units\nConcurrentSubscriptionBenchmark.noReentrant  thrpt    5  75341058.045 \u00b1 1011207.561  ops/s\nConcurrentSubscriptionBenchmark.reentrant    thrpt    5    337948.564 \u00b1    5698.630  ops/s", "author": "Scottmitch", "createdAt": "2020-04-29T23:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUzODM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyNjgxNQ==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r418226815", "bodyText": "From my perspective, breaking recursion here is better than allowing it as it cuts down the thread stack.\nI would suggest avoiding the complexity of adding reentrant lock semantics in ConcurrentUtils. I am also not completely convinced about the approach for the reentrant lock but we can discuss that in #1015 (comment)", "author": "NiteshKant", "createdAt": "2020-04-30T19:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUzODM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxODk3OQ==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r418318979", "bodyText": "It isn't the responsibility of this class to limit recursion/stack depth. Limiting stack depth is shown in the benchmarks to reduce performance.", "author": "Scottmitch", "createdAt": "2020-04-30T22:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUzODM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MTk4NA==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417541984", "bodyText": "Do we need to delay the throw from here?", "author": "NiteshKant", "createdAt": "2020-04-29T18:59:08Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +70,58 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,\n+                                prevPendingDemand + min(Long.MAX_VALUE - prevPendingDemand, n))) {\n+                    break;\n                 }\n             }\n-            if (n < 0) {\n-                subscription.cancel();\n-                return; // Don't set subscriptionLockOwner = 0 ... we don't want to request any more!\n+        }\n+        Throwable delayedCause = null;\n+        boolean tryAcquire;\n+        do {\n+            final long acquireId = tryAcquireReentrantLock(subscriptionLockUpdater, this);\n+            if (acquireId == 0) {\n+                break;\n             }\n+\n             try {\n-                subscription.request(n);\n+                final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                if (prevPendingDemand == CANCELLED) {\n+                    subscription.cancel();\n+                } else if (prevPendingDemand != 0) {\n+                    subscription.request(prevPendingDemand);\n+                }\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {", "originalCommit": "064f892a42d2c6f8925d779057ad8936dc0bc0c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5MDExMg==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417590112", "bodyText": "A general characteristics of the ConcurrentUtil locks is if an exception occurs while we hold the lock, we have to successfully release the lock otherwise we may miss events from other threads. In this case that mean we miss a cancel which is not desirable. We could assume it is the caller's responsibility to recover/cancel but if the cleanup has already been done from the caller's perspective it may not happen again.", "author": "Scottmitch", "createdAt": "2020-04-29T20:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MTUxNg==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417661516", "bodyText": "Practically, we are discussing the case when subscription.request() or subscription.cancel() throws which in turn makes this request() method throws.\nOnce a Subscription throws thus violating the spec, any expectation around further interaction with the Subscription doing anything meaningful isn't really justified. If this helps us simplify control-flow, I think it is a valid approach to take.", "author": "NiteshKant", "createdAt": "2020-04-29T23:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2OTkxNQ==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417669915", "bodyText": "any expectation around further interaction with the Subscription doing anything meaningful isn't really justified.\n\nAgreed in general the RS spec is violated but this may happen in practice and will be challenging to debug if a pending (due to concurrency) or subsequent (cleanup outside this class scope) cancel() is not propagated because an in process request(..) throws. The concurrency is introduced by this class, error recovery can be encapsulated in the class, and IMHO the simplification on control flow to remove error handling is not worth the potential complexity to debug later. The control flow is also different between request and cancel so it isn't necessarily the case that an exception/bug in request means cancel also has a bug. Making a best effort to propagate means the problem would be debugged elsewhere and won't require unrolling concurrent access trying to understand when/how signals were dropped.", "author": "Scottmitch", "createdAt": "2020-04-29T23:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyNTM1Mw==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r418225353", "bodyText": "I agree that the control-flow simplification isn't substantial.\nYou are correct that the following sequence of events is safe to allow:\nrequest(1) <- throws\ncancel() <- passes\n\nbut are the following sequence of events also safe or improve debuggability:\nrequest(1) <- throws\nrequest(1) <- passes\n\nnow, the Subscriber is expecting 2 items but only will ever get 1", "author": "NiteshKant", "createdAt": "2020-04-30T19:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5ODc1Mw==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r418298753", "bodyText": "the second sequence is in the undefined behavior territory. I think reasonable behavior for ConcurrentSubscription, which is an intermediate layer, is to deliver signals as it receives them instead of dropping/filtering signals because it doesn't have scope to know if they will be useful or not (e.g. debugging, making progress, etc.). The canonical usage of the ConcurrentUtil locks facilitate this (e.g. while(tryAcquire) { try { /* critical section */ } finally { release } }) without custom exception handling. Are you suggesting actively preventing scenario 2 but allowing scenario 1, and what would we gain (we are in unexpected error territory)?", "author": "Scottmitch", "createdAt": "2020-04-30T21:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MTk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MjQxOA==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417542418", "bodyText": "Perhaps we do not need to release if we throw, effectively poisoning the lock.", "author": "NiteshKant", "createdAt": "2020-04-29T18:59:55Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +70,58 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,\n+                                prevPendingDemand + min(Long.MAX_VALUE - prevPendingDemand, n))) {\n+                    break;\n                 }\n             }\n-            if (n < 0) {\n-                subscription.cancel();\n-                return; // Don't set subscriptionLockOwner = 0 ... we don't want to request any more!\n+        }\n+        Throwable delayedCause = null;\n+        boolean tryAcquire;\n+        do {\n+            final long acquireId = tryAcquireReentrantLock(subscriptionLockUpdater, this);\n+            if (acquireId == 0) {\n+                break;\n             }\n+\n             try {\n-                subscription.request(n);\n+                final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                if (prevPendingDemand == CANCELLED) {\n+                    subscription.cancel();\n+                } else if (prevPendingDemand != 0) {\n+                    subscription.request(prevPendingDemand);\n+                }\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {\n+                    delayedCause = cause;\n+                }\n             } finally {\n-                subscriptionLockOwner = null;\n+                tryAcquire = !releaseReentrantLock(subscriptionLockUpdater, acquireId, this);", "originalCommit": "064f892a42d2c6f8925d779057ad8936dc0bc0c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5MDY2NQ==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417590665", "bodyText": "lets discuss above in #1015 (comment). I don't think we want todo this.", "author": "Scottmitch", "createdAt": "2020-04-29T20:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MjQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY4MTEwMA==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r419681100", "bodyText": "I am still not sure about the approach here of continuing to call the subscription if a previous call to it threw. If we are not comfortable about poisoning the lock then an alternate is to set the pending = CANCELLED and hence ignoring any subsequent calls. If we do this, then the fast-path in request(n) can also avoid calling drain() from inside a finally block.", "author": "NiteshKant", "createdAt": "2020-05-04T19:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MjQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcyNjA2OQ==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r419726069", "bodyText": "If we do this, then the fast-path in request(n) can also avoid calling drain() from inside a finally block.\n\nWe have two options for reacting to exceptions:\n\nforce cleanup internally to ConcurrentSubscription\nallow cleanup to happen externally to ConcurrentSubscription\n\nfor (1) we have to catch the exception, force a call to cancel(), and we can optionally release the lock. This would require a catch in the fast path request(n) method, and a catch in the drain(), and we could release the lock outside the finally for the non-exception path.\nfor (2) we have to catch/ignore exceptions while we hold the lock (because cancel() may come concurrently). this is the general pattern of the ConcurrentUtil locks in which you keep draining until you can release the lock, otherwise you may miss an event.\nI would like to avoid forcing cancel() from ConcurrentSubscription as it is an interim layer and not the root cause of the exception. If the ConcurrentSubscription was removed from the scenario the caller would still have the same concerns related to dealing with exceptions.", "author": "Scottmitch", "createdAt": "2020-05-04T21:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MjQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgxOTc1MA==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r419819750", "bodyText": "discussed offline #1015 (comment)", "author": "Scottmitch", "createdAt": "2020-05-05T01:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MjQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2NDIyNw==", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r419664227", "bodyText": "Add an assert for releasing acquiredId2?\nassertTrue(releaseReentrantLock(reentrantLockUpdater, acquireId2, this));", "author": "NiteshKant", "createdAt": "2020-05-04T19:10:11Z", "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/ConcurrentUtilsTest.java", "diffHunk": "@@ -56,13 +66,22 @@ public void tearDown() throws Exception {\n     }\n \n     @Test\n-    public void singleThread() {\n+    public void lockSingleThread() {\n         assertTrue(tryAcquireLock(lockUpdater, this));\n         assertTrue(releaseLock(lockUpdater, this));\n     }\n \n     @Test\n-    public void pendingFromDifferentThread() throws Exception {\n+    public void reentrantLockSingleThread() {\n+        long acquireId = tryAcquireReentrantLock(reentrantLockUpdater, this);\n+        assertThat(acquireId, greaterThan(0L));\n+        long acquireId2 = tryAcquireReentrantLock(reentrantLockUpdater, this);\n+        assertThat(acquireId2, is(-acquireId));\n+        assertTrue(releaseReentrantLock(reentrantLockUpdater, acquireId, this));", "originalCommit": "02f122472e10d09caf72e710213e3dd9519fd907", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d259d2c933b0adf9b4615d551b586e16f4003cf2", "url": "https://github.com/apple/servicetalk/commit/d259d2c933b0adf9b4615d551b586e16f4003cf2", "message": "review comments", "committedDate": "2020-05-04T21:02:23Z", "type": "forcePushed"}, {"oid": "8de868c4f849a44028cc4111f397379ac25b73b9", "url": "https://github.com/apple/servicetalk/commit/8de868c4f849a44028cc4111f397379ac25b73b9", "message": "ConcurrentSubscripiton avoid concurrent access for invalid demand\n\nMotivation:\nConcurrentSubscription currently propagates invalid demand without any\nconcurrency protection. In general this is invalid use of the API but\nmay invalidate underlying data structures that are not thread safe and\nresult in undefined results.\n\nModifications:\n- Use a simpler locking scheme inspired by Publisher#flatMapMerge design\nwhich allows for re-entry and also notification is another thread has\nattempted to acquire the lock which will trigger re-processing.\n\nResult:\nConcurrentSubscripiton no longer allows any concurrent access and uses a\nmore common/shareable locking utility.", "committedDate": "2020-05-04T22:50:12Z", "type": "commit"}, {"oid": "814dfa7d50f3c0cf9b564d1746ec6a636226af19", "url": "https://github.com/apple/servicetalk/commit/814dfa7d50f3c0cf9b564d1746ec6a636226af19", "message": "review feedback, tests, benchmark", "committedDate": "2020-05-04T22:50:15Z", "type": "commit"}, {"oid": "a372625d278af249a43030a211bc551893c62f2d", "url": "https://github.com/apple/servicetalk/commit/a372625d278af249a43030a211bc551893c62f2d", "message": "add fast path for no concurrency case", "committedDate": "2020-05-04T22:50:15Z", "type": "commit"}, {"oid": "52b7130f2cb166c8819c580b49a34f11759c7d3a", "url": "https://github.com/apple/servicetalk/commit/52b7130f2cb166c8819c580b49a34f11759c7d3a", "message": "add more tests", "committedDate": "2020-05-04T22:50:15Z", "type": "commit"}, {"oid": "71165d8e8ee4bd0e0e8362676335d74ad267c7f1", "url": "https://github.com/apple/servicetalk/commit/71165d8e8ee4bd0e0e8362676335d74ad267c7f1", "message": "more tests, split benchmarks", "committedDate": "2020-05-04T22:50:15Z", "type": "commit"}, {"oid": "39cbe87a498513821420be402b3975ea39cf0e40", "url": "https://github.com/apple/servicetalk/commit/39cbe87a498513821420be402b3975ea39cf0e40", "message": "fix comment", "committedDate": "2020-05-04T22:50:15Z", "type": "commit"}, {"oid": "14ab4d2aba32b9090d5e4e2e009324a3672de9a7", "url": "https://github.com/apple/servicetalk/commit/14ab4d2aba32b9090d5e4e2e009324a3672de9a7", "message": "add more tests", "committedDate": "2020-05-04T22:50:15Z", "type": "commit"}, {"oid": "5c9f9252f3f59df6788f99b2cca4c8d9c865d8e4", "url": "https://github.com/apple/servicetalk/commit/5c9f9252f3f59df6788f99b2cca4c8d9c865d8e4", "message": "review comments", "committedDate": "2020-05-04T22:50:15Z", "type": "commit"}, {"oid": "5c9f9252f3f59df6788f99b2cca4c8d9c865d8e4", "url": "https://github.com/apple/servicetalk/commit/5c9f9252f3f59df6788f99b2cca4c8d9c865d8e4", "message": "review comments", "committedDate": "2020-05-04T22:50:15Z", "type": "forcePushed"}, {"oid": "daf1ab72d5276adc774fe32e00c1563f6819c064", "url": "https://github.com/apple/servicetalk/commit/daf1ab72d5276adc774fe32e00c1563f6819c064", "message": "relax locking release strategy and exception catching", "committedDate": "2020-05-05T01:22:55Z", "type": "commit"}]}