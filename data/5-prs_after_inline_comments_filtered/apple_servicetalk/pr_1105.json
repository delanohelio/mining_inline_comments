{"pr_number": 1105, "pr_title": "Observability for connection establishment and read-write events", "pr_createdAt": "2020-07-27T04:27:59Z", "pr_url": "https://github.com/apple/servicetalk/pull/1105", "timeline": [{"oid": "61980f69e095d73540917b4a55e199bc2aa13087", "url": "https://github.com/apple/servicetalk/commit/61980f69e095d73540917b4a55e199bc2aa13087", "message": "Observability for connection establishment and read-write events\n\nMotivation:\n\nProvide users ways to know when connection is established and ready for\nusage, what was the type of connection (multiplexed or non-multiplexed),\nread-write events associated with the connection.\n\nModifications:\n\n- Add `NonMultiplexedObserver`, `MultiplexedObserver`, `StreamObserver`,\n`ReadObserver`, and `WriteObserver` interfaces;\n- Implement trigger points for new observability interfaces;\n- Extract immutable methods of `ConnectionContext` into `ConnectionInfo`\ninterface;\n- Test new functionality;\n\nResult:\n\nObservability for connection establishment and read-write events on the\nconnection.", "committedDate": "2020-07-25T03:02:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxMjE5Mg==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461812192", "bodyText": "Do we really want a util class to wrap a single method call?", "author": "NiteshKant", "createdAt": "2020-07-28T19:14:56Z", "path": "servicetalk-transport-netty-internal/src/testFixtures/java/io/servicetalk/transport/netty/internal/MockitoUtils.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import org.mockito.Mockito;\n+import org.mockito.verification.VerificationWithTimeout;\n+\n+/**\n+ * Utilities for {@link Mockito}.\n+ */\n+public final class MockitoUtils {\n+\n+    private MockitoUtils() {\n+        // No instances.\n+    }\n+\n+    /**\n+     * Alias for {@link Mockito#timeout(long)} that awaits indefinitely.\n+     * <p>\n+     * Because the client is just a trigger for server-side events sometimes we need to await for invocations to verify\n+     * them.\n+     */\n+    public static VerificationWithTimeout await() {\n+        return Mockito.timeout(Long.MAX_VALUE);", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyMTQxOA==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461821418", "bodyText": "Do we envision any other method added to this interface apart from what is data related?\nIf not, then rather than having a name reflect what it is not, will be better to reflect what it is about. An example can be DataObserver which is observing data related events (read/write)", "author": "NiteshKant", "createdAt": "2020-07-28T19:30:26Z", "path": "servicetalk-transport-api/src/main/java/io/servicetalk/transport/api/ConnectionObserver.java", "diffHunk": "@@ -79,4 +95,135 @@\n          */\n         void handshakeComplete(SSLSession sslSession);\n     }\n+\n+    /**\n+     * An observer interface that provides visibility into read and write events of a non-multiplexed connection.\n+     */\n+    interface NonMultiplexedObserver {", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1NzQ1Ng==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461857456", "bodyText": "+1 to consider rename. the name is also awkward because StreamObserver extends NonMultiplexedObserver but StreamObserver exists in a multiplex context. here are some options to consider:\nNonMultiplexedObserver:\n\nDataObserverFactory (Observer APIs have callbacks to \"observe\" events, but this API is just a factory to create other observers)\nReadWriteObserverFactory\n\nMultiplexedObserver:\n\nStreamObserverFactory", "author": "Scottmitch", "createdAt": "2020-07-28T20:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyMTQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxODUwOQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r462518509", "bodyText": "I would prefer to avoid the word Factory and keep just an Observer suffix everywhere for consistency. Observer provides callbacks for events, we don't need to be too specific for events that return another observer.\nRenamed to DataObserver.", "author": "idelpivnitskiy", "createdAt": "2020-07-29T18:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyMTQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyMzIzMw==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461823233", "bodyText": "At some place in these interfaces (including ConnectionObserver) we should specify semantics of whether we expect both *Closed(Throwable) and *closed() to be called. Similar comment about read/write/failed/completed/cancelled", "author": "NiteshKant", "createdAt": "2020-07-28T19:33:55Z", "path": "servicetalk-transport-api/src/main/java/io/servicetalk/transport/api/ConnectionObserver.java", "diffHunk": "@@ -79,4 +95,135 @@\n          */\n         void handshakeComplete(SSLSession sslSession);\n     }\n+\n+    /**\n+     * An observer interface that provides visibility into read and write events of a non-multiplexed connection.\n+     */\n+    interface NonMultiplexedObserver {\n+\n+        /**\n+         * Callback when the connection starts reading a new message.\n+         *\n+         * @return {@link ReadObserver} that provides visibility into <strong>read</strong> events\n+         */\n+        ReadObserver onNewRead();\n+\n+        /**\n+         * Callback when the connection starts writing a new message.\n+         *\n+         * @return {@link WriteObserver} that provides visibility into <strong>write</strong> events\n+         */\n+        WriteObserver onNewWrite();\n+    }\n+\n+    /**\n+     * An observer interface that provides visibility into new streams created by a multiplexed connection.\n+     */\n+    interface MultiplexedObserver {\n+\n+        /**\n+         * Callback when the connection creates a new stream.\n+         *\n+         * @return {@link StreamObserver} that provides visibility into stream events\n+         */\n+        StreamObserver onNewStream();\n+    }\n+\n+    /**\n+     * An observer interface that provides visibility into stream events.\n+     */\n+    interface StreamObserver extends NonMultiplexedObserver {", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyNTU2OQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r462525569", "bodyText": "Good idea! Added this to the interface javadoc, ptal: c336f39", "author": "idelpivnitskiy", "createdAt": "2020-07-29T19:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyMzIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyNjY5MQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461826691", "bodyText": "If any of these two lines throw we will not invoke subscriber.onError(). We should handle such scenarios and ensure we always invoke the Subscriber to complete the async control flow.", "author": "NiteshKant", "createdAt": "2020-07-28T19:39:04Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ClientParentConnectionContext.java", "diffHunk": "@@ -265,14 +278,17 @@ private void childChannelActive(Future<Http2StreamChannel> future,\n                                     parentContext.executionContext().executionStrategy(),\n                                     HTTP_2_0,\n                                     parentContext.sslSession(),\n-                                    parentContext.nettyChannel().config());\n+                                    parentContext.nettyChannel().config(),\n+                                    streamObserver);\n \n                     // In h2 a stream is 1 to 1 with a request/response life cycle. This means there is no concept of\n                     // pipelining on a stream so we can use the non-pipelined connection which is more light weight.\n                     // https://tools.ietf.org/html/rfc7540#section-8.1\n                     responseSingle = toSource(new NonPipelinedStreamingHttpConnection(nettyConnection,\n                             executionContext(), reqRespFactory, headersFactory).request(strategy, request));\n                 } catch (Throwable cause) {\n+                    assignConnectionError(streamChannel, cause);", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyNzg0Nw==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461827847", "bodyText": "Are these two lines intentionally moved out of try-catch block?\nIf you only need the streamChannel reference then just move the variable declaration outside and continue to do the assignment inside try-catch", "author": "NiteshKant", "createdAt": "2020-07-28T19:40:32Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ClientParentConnectionContext.java", "diffHunk": "@@ -247,9 +259,10 @@ private void childChannelActive(Future<Http2StreamChannel> future,\n             final SingleSource<StreamingHttpResponse> responseSingle;\n             Throwable futureCause = future.cause(); // assume this doesn't throw\n             if (futureCause == null) {\n+                Http2StreamChannel streamChannel = future.getNow();", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzODEwOQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461838109", "bodyText": "Looks like we are missing a callback when a new stream creation was requested but failed (perhaps due to max_concurrent_streams). Is that correct?", "author": "NiteshKant", "createdAt": "2020-07-28T19:53:51Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ServerParentConnectionContext.java", "diffHunk": "@@ -128,13 +134,17 @@ protected void handleSubscribe(final Subscriber<? super H2ServerParentConnection\n                     pipeline = channel.pipeline();\n \n                     parentChannelInitializer = new DefaultH2ServerParentConnection(connection, subscriber,\n-                            delayedCancellable, NettyPipelineSslUtils.isSslEnabled(pipeline));\n+                            delayedCancellable, NettyPipelineSslUtils.isSslEnabled(pipeline),\n+                            connectionObserver(channel));\n \n                     new H2ServerParentChannelInitializer(h2ServerConfig,\n-                        new io.netty.channel.ChannelInitializer<Channel>() {\n+                        new io.netty.channel.ChannelInitializer<Http2StreamChannel>() {\n                             @Override\n-                            protected void initChannel(final Channel streamChannel) {\n+                            protected void initChannel(final Http2StreamChannel streamChannel) {\n                                 connection.trackActiveStream(streamChannel);\n+                                final StreamObserver streamObserver = registerStreamObserver(streamChannel,", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2OTgwNA==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461869804", "bodyText": "@NiteshKant - can you clarify what use case you had in mind? IIRC we \"should\" avoid this case with our concurrency control on the client, and if someone attempts this on the connection they will get an error on the request/response.", "author": "Scottmitch", "createdAt": "2020-07-28T20:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzODEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzMzE1Nw==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461933157", "bodyText": "If this throws, do we cleanup and propagate async control flow?", "author": "Scottmitch", "createdAt": "2020-07-28T22:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzODEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxODg3OQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r462518879", "bodyText": "@NiteshKant this scenario should be visible via ConnectionObserver.connectionClosed(Throwable) because netty will propagate this exception through the pipeline.\n@Scottmitch added try-catch for an observer invocation.", "author": "idelpivnitskiy", "createdAt": "2020-07-29T18:58:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzODEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyNTQyMQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r462625421", "bodyText": "Hmm wrong place to add the comment, it is more clear on the client side.\nOn the client side (H2ClientParentConnectionContext) we are creating a new StreamObserver when a stream is active (in childChannelActive()).\nI am generally highlighting the transition differences between connection and stream:\nTransportObserver#onNewConnection() => ConnectionObserver#established*() => DataObserver#*\nvs:\nMultiplexedObserver#onNewStream() => DataObserver#*\nso we are missing established for stream. Trying to find out the repercussions", "author": "NiteshKant", "createdAt": "2020-07-29T22:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzODEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMTg5MQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r463411891", "bodyText": "For the connection, time delta between onNewConnection() and established*() is significant because it involves a TCP syn-ack and optionally an SSL handshake.\nStream creation happens locally without network interaction. Therefore, the time between a request for a new stream and childChannelActive is negligible. Can not imagine a use-case when having 2 events will provide value for users.", "author": "idelpivnitskiy", "createdAt": "2020-07-31T05:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzODEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzOTI0Ng==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461839246", "bodyText": "variable name and class name mismatch", "author": "NiteshKant", "createdAt": "2020-07-28T19:55:52Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -123,22 +126,18 @@\n     private SSLSession sslSession;\n     @Nullable\n     private final ChannelConfig parentChannelConfig;\n-\n-    private DefaultNettyConnection(Channel channel, BufferAllocator allocator, Executor executor,\n-                                   Predicate<Read> terminalPredicate, CloseHandler closeHandler,\n-                                   FlushStrategy flushStrategy, @Nullable Long idleTimeoutMs,\n-                                   ExecutionStrategy executionStrategy, Protocol protocol) {\n-        this(channel, allocator, executor, terminalPredicate, closeHandler, flushStrategy, idleTimeoutMs,\n-                executionStrategy, protocol, null, null);\n-    }\n+    @Nullable\n+    private volatile NonMultiplexedObserver readWriteObserver;\n \n     private DefaultNettyConnection(Channel channel, BufferAllocator allocator, Executor executor,\n                                    Predicate<Read> terminalPredicate, CloseHandler closeHandler,\n                                    FlushStrategy flushStrategy, @Nullable Long idleTimeoutMs,\n                                    ExecutionStrategy executionStrategy, Protocol protocol,\n-                                   @Nullable SSLSession sslSession, @Nullable ChannelConfig parentChannelConfig) {\n+                                   @Nullable SSLSession sslSession, @Nullable ChannelConfig parentChannelConfig,\n+                                   @Nullable NonMultiplexedObserver readWriteObserver) {", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0NDAxOA==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461844018", "bodyText": "The @Nullable semantics are not ideal here (and in other places) specially here when we can set this later through readWriteObserver() method below.\nIt seems there are two scenarios here:\n\nThere is no observer configured\nObserver is configured but is not available because of how our APIs are structured (observer is returned as part of established() call)\n\nInstead of wiring in null and late set behavior everywhere can we scope it to an observer implementation:\n\nFor case (1) have a NOOP observer\nFor case (2) have a place holder observer at the creation time of connection which delegates to an actual observer, when available.", "author": "NiteshKant", "createdAt": "2020-07-28T20:04:38Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyChannelPublisher.java", "diffHunk": "@@ -47,17 +49,21 @@\n     private Queue<Object> pending;\n     @Nullable\n     private Throwable fatalError;\n+    @Nullable\n+    private NonMultiplexedObserver readWriteObserver;\n \n     private final Channel channel;\n     private final CloseHandler closeHandler;\n     private final EventLoop eventLoop;\n     private final Predicate<T> terminalSignalPredicate;\n \n-    NettyChannelPublisher(Channel channel, Predicate<T> terminalSignalPredicate, CloseHandler closeHandler) {\n+    NettyChannelPublisher(Channel channel, Predicate<T> terminalSignalPredicate, CloseHandler closeHandler,\n+                          @Nullable NonMultiplexedObserver readWriteObserver) {", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxOTA1OQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r462519059", "bodyText": "There is also a 3rd case when an observer is available at the ctor time for HTTP/2 stream.\nYour suggestion to use when* operators on NettyChannelPublisher helped to simplify it a bit. I will defer further improvements of internal implementation for the follow-up PR.", "author": "idelpivnitskiy", "createdAt": "2020-07-29T18:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0NDAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0NDMyMQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461844321", "bodyText": "If you do end up doing this, clarify and verify whether this should only be accessed/assigned from the eventloop", "author": "NiteshKant", "createdAt": "2020-07-28T20:05:13Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyChannelPublisher.java", "diffHunk": "@@ -69,6 +75,10 @@ protected void handleSubscribe(Subscriber<? super T> nextSubscriber) {\n         }\n     }\n \n+    void readWriteObserver(@Nullable final NonMultiplexedObserver readWriteObserver) {\n+        this.readWriteObserver = readWriteObserver;", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0NjAwNg==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461846006", "bodyText": "this seems backward to wrap the Subscriber inside a Subscription. Also, we are not handling errors thrown from the observer.\nCan we start with using when* methods on the NettyChannelPublisher for this instrumentation instead of baking it in here?", "author": "NiteshKant", "createdAt": "2020-07-28T20:08:22Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyChannelPublisher.java", "diffHunk": "@@ -318,14 +333,44 @@ private void assertInEventloop() {\n \n     private final class SubscriptionImpl implements Subscription {\n \n+        @Nullable\n+        private final ReadObserver observer;\n         final Subscriber<? super T> associatedSub;\n \n-        private SubscriptionImpl(Subscriber<? super T> associatedSub) {\n-            this.associatedSub = associatedSub;\n+        private SubscriptionImpl(final Subscriber<? super T> subscriber,\n+                                 @Nullable final NonMultiplexedObserver readWriteObserver) {\n+            observer = readWriteObserver == null ? null : requireNonNull(readWriteObserver.onNewRead());\n+            this.associatedSub = observer == null ? subscriber : new Subscriber<T>() {", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0NzMyOA==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461847328", "bodyText": "I am getting increasingly concerned about the number of utilities that we are creating as part of this work. It smells like we are missing an abstraction but I can't put my finger on it yet.", "author": "NiteshKant", "createdAt": "2020-07-28T20:10:55Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverUtils.java", "diffHunk": "@@ -27,7 +28,10 @@\n import static io.netty.util.AttributeKey.newInstance;\n import static java.util.Objects.requireNonNull;\n \n-final class TransportObserverUtils {\n+/**\n+ * Utilities for {@link TransportObserver}.\n+ */\n+public final class TransportObserverUtils {", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxODk5NQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r462518995", "bodyText": "The current goal is to build the API and provide test coverage to ensure that callbacks are triggered at the correct time. Implementation intentionally uses a simplified approach to minimize internal changes until the full picture is there. The follow-up PR will reconsider the internal implementation approach.", "author": "idelpivnitskiy", "createdAt": "2020-07-29T18:58:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0NzMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2MzExOQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461863119", "bodyText": "(pre-existing, so followup PR but discuss while we are here)\nSecurityHandshakeObserver -> SSLHandshakeObserver? A method in this interface already couple it to SSL (e.g. handshakeComplete(SSLSession)) and seems like we can make the name less ambiguous.", "author": "Scottmitch", "createdAt": "2020-07-28T20:37:27Z", "path": "servicetalk-transport-api/src/main/java/io/servicetalk/transport/api/ConnectionObserver.java", "diffHunk": "@@ -48,6 +48,22 @@\n      */\n     SecurityHandshakeObserver onSecurityHandshake();", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxOTMwMw==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r462519303", "bodyText": "The motivation was to avoid having a specific protocol name, like SSL or TLS, and be consistent with other ST API: secure() method on the builders and SecurityConfigurator interfaces. SSLSession is a java class that we can not change, therefore decided not to stick to its name.", "author": "idelpivnitskiy", "createdAt": "2020-07-29T18:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2MzExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2NTI5OQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461865299", "bodyText": "giving access to the item allows for \"out of bounds modifications\", but also limiting from a visibility perspective (e.g. how large is the object, is it empty, etc..). is it worth clarifying why there is no object provided (e.g. it is assumed contents can be inspected at higher levels like filters, and adequate request-n demand is provided to dequeue the items, etc.)", "author": "Scottmitch", "createdAt": "2020-07-28T20:41:22Z", "path": "servicetalk-transport-api/src/main/java/io/servicetalk/transport/api/ConnectionObserver.java", "diffHunk": "@@ -79,4 +95,135 @@\n          */\n         void handshakeComplete(SSLSession sslSession);\n     }\n+\n+    /**\n+     * An observer interface that provides visibility into read and write events of a non-multiplexed connection.\n+     */\n+    interface NonMultiplexedObserver {\n+\n+        /**\n+         * Callback when the connection starts reading a new message.\n+         *\n+         * @return {@link ReadObserver} that provides visibility into <strong>read</strong> events\n+         */\n+        ReadObserver onNewRead();\n+\n+        /**\n+         * Callback when the connection starts writing a new message.\n+         *\n+         * @return {@link WriteObserver} that provides visibility into <strong>write</strong> events\n+         */\n+        WriteObserver onNewWrite();\n+    }\n+\n+    /**\n+     * An observer interface that provides visibility into new streams created by a multiplexed connection.\n+     */\n+    interface MultiplexedObserver {\n+\n+        /**\n+         * Callback when the connection creates a new stream.\n+         *\n+         * @return {@link StreamObserver} that provides visibility into stream events\n+         */\n+        StreamObserver onNewStream();\n+    }\n+\n+    /**\n+     * An observer interface that provides visibility into stream events.\n+     */\n+    interface StreamObserver extends NonMultiplexedObserver {\n+\n+        /**\n+         * Callback when the stream is closed due to an {@link Throwable error}.\n+         *\n+         * @param error an occurred error\n+         */\n+        void streamClosed(Throwable error);\n+\n+        /**\n+         * Callback when the stream is closed.\n+         */\n+        void streamClosed();\n+    }\n+\n+    /**\n+     * An observer interface that provides visibility into <strong>read</strong> events.\n+     */\n+    interface ReadObserver {\n+\n+        /**\n+         * Callback when new items are requested to read.\n+         *\n+         * @param n number of requested items to read\n+         */\n+        void requestedToRead(long n);\n+\n+        /**\n+         * Invokes when a new item is read.\n+         */\n+        void itemRead();", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMDc5OQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r462520799", "bodyText": "Improved javadoc.", "author": "idelpivnitskiy", "createdAt": "2020-07-29T19:01:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2NTI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3MTQyOQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461871429", "bodyText": "lets be defensive if this throws as otherwise we may not complete async control flow.", "author": "Scottmitch", "createdAt": "2020-07-28T20:52:22Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ServerParentConnectionContext.java", "diffHunk": "@@ -200,6 +217,9 @@ void tryCompleteSubscriber() {\n             if (subscriber != null) {\n                 Subscriber<? super H2ServerParentConnectionContext> subscriberCopy = subscriber;\n                 subscriber = null;\n+                if (connectionObserver != null) {\n+                    multiplexedObserver = requireNonNull(connectionObserver.establishedMultiplexed(parentContext));", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzNTAzNw==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461935037", "bodyText": "can you clarify the motivation for this change? is this to prevent folks from closing in the observer APIs?", "author": "Scottmitch", "createdAt": "2020-07-28T22:44:14Z", "path": "servicetalk-transport-api/src/main/java/io/servicetalk/transport/api/ConnectionContext.java", "diffHunk": "@@ -17,79 +17,8 @@\n \n import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n \n-import java.net.SocketAddress;\n-import java.net.SocketOption;\n-import java.net.StandardSocketOptions;\n-import javax.annotation.Nullable;\n-import javax.net.ssl.SSLSession;\n-\n /**\n  * A context for a connection.\n  */\n-public interface ConnectionContext extends ListenableAsyncCloseable {\n-    /**\n-     * The {@link SocketAddress} to which the associated connection is bound.\n-     *\n-     * @return The {@link SocketAddress} to which the associated connection is bound.\n-     */\n-    SocketAddress localAddress();\n-\n-    /**\n-     * The {@link SocketAddress} to which the associated connection is connected.\n-     *\n-     * @return The {@link SocketAddress} to which the associated connection is connected.\n-     */\n-    SocketAddress remoteAddress();\n-\n-    /**\n-     * Get the {@link SSLSession} for this connection.\n-     *\n-     * @return The {@link SSLSession} if SSL/TLS is enabled, or {@code null} otherwise.\n-     */\n-    @Nullable\n-    SSLSession sslSession();\n-\n-    /**\n-     * Get the {@link ExecutionContext} for this {@link ConnectionContext}.\n-     * <p>\n-     * The {@link ExecutionContext#ioExecutor()} will represent the thread responsible for IO for this\n-     * {@link ConnectionContext}. Note that this maybe different that what was used to create this object because\n-     * at this time a specific {@link IoExecutor} has been selected.\n-     *\n-     * @return the {@link ExecutionContext} for this {@link ConnectionContext}.\n-     */\n-    ExecutionContext executionContext();\n-\n-    /**\n-     * Get the {@link SocketOption} value of type {@code T} for this {@link ConnectionContext}.\n-     *\n-     * @param option {@link SocketOption} to get.\n-     * @param <T> the type of the {@link SocketOption} value.\n-     * @return the {@link SocketOption} value of type {@code T} for this {@link ConnectionContext} or {@code null} if\n-     * this {@link SocketOption} is not supported by this {@link ConnectionContext}.\n-     * @see StandardSocketOptions\n-     * @see ServiceTalkSocketOptions\n-     */\n-    @Nullable\n-    <T> T socketOption(SocketOption<T> option);\n-\n-    /**\n-     * Get the {@link Protocol} for this {@link ConnectionContext}.\n-     *\n-     * @return the {@link Protocol} for this {@link ConnectionContext}.\n-     */\n-    Protocol protocol();\n-\n-    /**\n-     * Provides information about the network protocol.\n-     */\n-    interface Protocol {\n-\n-        /**\n-         * Returns name of the protocol.\n-         *\n-         * @return name of the protocol\n-         */\n-        String name();\n-    }\n+public interface ConnectionContext extends ConnectionInfo, ListenableAsyncCloseable {", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxOTQyOA==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r462519428", "bodyText": "Correct, ConnectionInfo is a read-only view on the connection to prevent modifications of its state, like closing.", "author": "idelpivnitskiy", "createdAt": "2020-07-29T18:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzNTAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzNjg3MQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461936871", "bodyText": "should we be more defensive here and account for exceptions?", "author": "Scottmitch", "createdAt": "2020-07-28T22:48:38Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/Flush.java", "diffHunk": "@@ -80,11 +92,17 @@ public void onSubscribe(Subscription subscription) {\n                 subscriber.onSubscribe(new Subscription() {\n                     @Override\n                     public void request(long n) {\n+                        if (observer != null) {\n+                            observer.requestedToWrite(n);\n+                        }\n                         subscription.request(n);\n                     }\n \n                     @Override\n                     public void cancel() {\n+                        if (observer != null) {\n+                            observer.writeCancelled();", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTkzNzY0Nw==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r461937647", "bodyText": "should we be more defensive here and account for exceptions? we are invoking user code that may throw and break async control flow notification to subscriberCopy IIUC.", "author": "Scottmitch", "createdAt": "2020-07-28T22:50:35Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -626,6 +646,9 @@ private void completeSubscriber() {\n             assert subscriber != null;\n             SingleSource.Subscriber<? super DefaultNettyConnection<Read, Write>> subscriberCopy = subscriber;\n             subscriber = null;\n+            if (observer != null) {\n+                connection.readWriteObserver(requireNonNull(observer.established(connection)));", "originalCommit": "61980f69e095d73540917b4a55e199bc2aa13087", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2bfb16c46bd2f9175a0adf772cbc71b5ec45fb74", "url": "https://github.com/apple/servicetalk/commit/2bfb16c46bd2f9175a0adf772cbc71b5ec45fb74", "message": "Improve HttpTransportObserverTest", "committedDate": "2020-07-28T23:24:16Z", "type": "commit"}, {"oid": "92fe1c2f02a3f123653ee0970ad7c2f2f7d72af3", "url": "https://github.com/apple/servicetalk/commit/92fe1c2f02a3f123653ee0970ad7c2f2f7d72af3", "message": "Remove MockitoUtils", "committedDate": "2020-07-28T23:30:11Z", "type": "commit"}, {"oid": "603dd440dfe3553094f3c9057043fa10575901bd", "url": "https://github.com/apple/servicetalk/commit/603dd440dfe3553094f3c9057043fa10575901bd", "message": "Rename NonMultiplexedObserver -> DataObserver", "committedDate": "2020-07-29T00:00:32Z", "type": "commit"}, {"oid": "ebc3b818e19edb2d0532366f9517936c25ab9a28", "url": "https://github.com/apple/servicetalk/commit/ebc3b818e19edb2d0532366f9517936c25ab9a28", "message": "Address comments", "committedDate": "2020-07-29T05:59:11Z", "type": "commit"}, {"oid": "23b185b816c606f5104e6e66bbda3a6ca729fcda", "url": "https://github.com/apple/servicetalk/commit/23b185b816c606f5104e6e66bbda3a6ca729fcda", "message": "Log and ignore all exceptions produced by observers", "committedDate": "2020-07-29T18:54:08Z", "type": "commit"}, {"oid": "ad7fb248a29eccaf2dcc4e2b6317c43a9b701624", "url": "https://github.com/apple/servicetalk/commit/ad7fb248a29eccaf2dcc4e2b6317c43a9b701624", "message": "Update copyright years", "committedDate": "2020-07-29T18:56:31Z", "type": "commit"}, {"oid": "c336f398494e708d78cddc30351a4b07ce73d4bf", "url": "https://github.com/apple/servicetalk/commit/c336f398494e708d78cddc30351a4b07ce73d4bf", "message": "Clarify terminal signals in javadoc", "committedDate": "2020-07-29T19:08:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyOTc1MQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r462529751", "bodyText": "@NiteshKant @Scottmitch wdyt about this?\nThe problem here is that connection is closed, but the connection.read() did not terminate and was not canceled. This happens because service did not subscribe to the payload body publisher and auto-draining does not happen if response body publisher fails because the connection (or stream) will be closed anyway. Therefore, NettyChannelPublisher#pending queue has 2 elements:\n\nempty trailers\nClosedChannelException\n\nBecause there are trailers, the terminal event is not delivered. IIUC the control flow the terminal signal is delayed intentionally to let the subscriber consume a successful request before terminating it.\nIs it ok that we do not terminate connection.read() when connection (or stream) is closed due to a response payload error?", "author": "idelpivnitskiy", "createdAt": "2020-07-29T19:17:10Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/HttpTransportObserverTest.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.HttpProtocolConfig;\n+import io.servicetalk.http.api.HttpProtocolVersion;\n+import io.servicetalk.http.api.HttpResponseStatus;\n+import io.servicetalk.http.api.HttpServiceContext;\n+import io.servicetalk.http.api.StreamingHttpConnection;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+import io.servicetalk.http.api.StreamingHttpServiceFilter;\n+import io.servicetalk.http.netty.H2ToStH1Utils.H2StreamResetException;\n+import io.servicetalk.transport.api.ConnectionInfo;\n+import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.DataObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.MultiplexedObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.ReadObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.StreamObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.WriteObserver;\n+import io.servicetalk.transport.api.TransportObserver;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.mockito.Mockito;\n+import org.mockito.verification.VerificationWithTimeout;\n+\n+import java.io.IOException;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.Publisher.failed;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_LENGTH;\n+import static io.servicetalk.http.api.HttpHeaderValues.ZERO;\n+import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_1_1;\n+import static io.servicetalk.http.api.HttpProtocolVersion.HTTP_2_0;\n+import static io.servicetalk.http.api.HttpResponseStatus.INTERNAL_SERVER_ERROR;\n+import static io.servicetalk.http.api.HttpResponseStatus.OK;\n+import static io.servicetalk.http.netty.AbstractNettyHttpServerTest.ExecutorSupplier.CACHED;\n+import static io.servicetalk.http.netty.AbstractNettyHttpServerTest.ExecutorSupplier.CACHED_SERVER;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h1Default;\n+import static io.servicetalk.http.netty.HttpProtocolConfigs.h2Default;\n+import static io.servicetalk.http.netty.TestServiceStreaming.SVC_ECHO;\n+import static io.servicetalk.http.netty.TestServiceStreaming.SVC_ERROR_BEFORE_READ;\n+import static io.servicetalk.http.netty.TestServiceStreaming.SVC_ERROR_DURING_READ;\n+import static io.servicetalk.http.netty.TestServiceStreaming.SVC_THROW_ERROR;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.atMostOnce;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(Parameterized.class)\n+public class HttpTransportObserverTest extends AbstractNettyHttpServerTest {\n+\n+    private enum Protocol {\n+        HTTP_1(h1Default(), HTTP_1_1),\n+        HTTP_2(h2Default(), HTTP_2_0);\n+\n+        private final HttpProtocolConfig config;\n+        private final HttpProtocolVersion version;\n+\n+        Protocol(HttpProtocolConfig config, HttpProtocolVersion version) {\n+            this.config = config;\n+            this.version = version;\n+        }\n+    }\n+\n+    private final Protocol protocol;\n+\n+    private final TransportObserver clientTransportObserver;\n+    private final ConnectionObserver clientConnectionObserver;\n+    private final DataObserver clientDataObserver;\n+    private final MultiplexedObserver clientMultiplexedObserver;\n+    private final StreamObserver clientStreamObserver;\n+    private final ReadObserver clientReadObserver;\n+    private final WriteObserver clientWriteObserver;\n+\n+    private final TransportObserver serverTransportObserver;\n+    private final ConnectionObserver serverConnectionObserver;\n+    private final DataObserver serverDataObserver;\n+    private final MultiplexedObserver serverMultiplexedObserver;\n+    private final StreamObserver serverStreamObserver;\n+    private final ReadObserver serverReadObserver;\n+    private final WriteObserver serverWriteObserver;\n+\n+    private final CountDownLatch serverConnectionClosed = new CountDownLatch(1);\n+    private final CountDownLatch requestReceived = new CountDownLatch(1);\n+    private final CountDownLatch processRequest = new CountDownLatch(1);\n+\n+    public HttpTransportObserverTest(Protocol protocol) {\n+        super(CACHED, CACHED_SERVER);\n+        this.protocol = protocol;\n+        protocol(protocol.config);\n+        connectionAcceptor(ctx -> {\n+            ctx.onClose().whenFinally(serverConnectionClosed::countDown).subscribe();\n+            return completed();\n+        });\n+        serviceFilterFactory(service -> new StreamingHttpServiceFilter(service) {\n+            @Override\n+            public Single<StreamingHttpResponse> handle(HttpServiceContext ctx,\n+                                                        StreamingHttpRequest request,\n+                                                        StreamingHttpResponseFactory responseFactory) {\n+                requestReceived.countDown();\n+                try {\n+                    processRequest.await();\n+                } catch (InterruptedException e) {\n+                    return throwException(e);\n+                }\n+                return delegate().handle(ctx, request, responseFactory);\n+            }\n+        });\n+\n+        clientTransportObserver = mock(TransportObserver.class, \"clientTransportObserver\");\n+        clientConnectionObserver = mock(ConnectionObserver.class, \"clientConnectionObserver\");\n+        clientDataObserver = mock(DataObserver.class, \"clientDataObserver\");\n+        clientMultiplexedObserver = mock(MultiplexedObserver.class, \"clientMultiplexedObserver\");\n+        clientStreamObserver = mock(StreamObserver.class, \"clientStreamObserver\");\n+        clientReadObserver = mock(ReadObserver.class, \"clientReadObserver\");\n+        clientWriteObserver = mock(WriteObserver.class, \"clientWriteObserver\");\n+        when(clientTransportObserver.onNewConnection()).thenReturn(clientConnectionObserver);\n+        when(clientConnectionObserver.established(any(ConnectionInfo.class))).thenReturn(clientDataObserver);\n+        when(clientConnectionObserver.establishedMultiplexed(any(ConnectionInfo.class)))\n+                .thenReturn(clientMultiplexedObserver);\n+        when(clientMultiplexedObserver.onNewStream()).thenReturn(clientStreamObserver);\n+        when(clientDataObserver.onNewRead()).thenReturn(clientReadObserver);\n+        when(clientDataObserver.onNewWrite()).thenReturn(clientWriteObserver);\n+        when(clientStreamObserver.onNewRead()).thenReturn(clientReadObserver);\n+        when(clientStreamObserver.onNewWrite()).thenReturn(clientWriteObserver);\n+\n+        serverTransportObserver = mock(TransportObserver.class, \"serverTransportObserver\");\n+        serverConnectionObserver = mock(ConnectionObserver.class, \"serverConnectionObserver\");\n+        serverDataObserver = mock(DataObserver.class, \"serverDataObserver\");\n+        serverMultiplexedObserver = mock(MultiplexedObserver.class, \"serverMultiplexedObserver\");\n+        serverStreamObserver = mock(StreamObserver.class, \"serverStreamObserver\");\n+        serverReadObserver = mock(ReadObserver.class, \"serverReadObserver\");\n+        serverWriteObserver = mock(WriteObserver.class, \"serverWriteObserver\");\n+        when(serverTransportObserver.onNewConnection()).thenReturn(serverConnectionObserver);\n+        when(serverConnectionObserver.established(any(ConnectionInfo.class))).thenReturn(serverDataObserver);\n+        when(serverConnectionObserver.establishedMultiplexed(any(ConnectionInfo.class)))\n+                .thenReturn(serverMultiplexedObserver);\n+        when(serverMultiplexedObserver.onNewStream()).thenReturn(serverStreamObserver);\n+        when(serverDataObserver.onNewRead()).thenReturn(serverReadObserver);\n+        when(serverDataObserver.onNewWrite()).thenReturn(serverWriteObserver);\n+        when(serverStreamObserver.onNewRead()).thenReturn(serverReadObserver);\n+        when(serverStreamObserver.onNewWrite()).thenReturn(serverWriteObserver);\n+\n+        transportObserver(clientTransportObserver, serverTransportObserver);\n+    }\n+\n+    @Parameters(name = \"protocol={0}\")\n+    public static Protocol[] data() {\n+        return Protocol.values();\n+    }\n+\n+    @Test\n+    public void connectionEstablished() throws Exception {\n+        processRequest.countDown();\n+        StreamingHttpConnection connection = streamingHttpConnection();\n+\n+        verify(clientTransportObserver).onNewConnection();\n+        verify(serverTransportObserver, await()).onNewConnection();\n+        if (protocol == Protocol.HTTP_1) {\n+            verify(clientConnectionObserver).established(any(ConnectionInfo.class));\n+            verify(serverConnectionObserver, await()).established(any(ConnectionInfo.class));\n+\n+            verify(serverDataObserver, await()).onNewRead();\n+            verify(serverDataObserver, await()).onNewWrite();\n+        } else {\n+            verify(clientConnectionObserver).establishedMultiplexed(any(ConnectionInfo.class));\n+            verify(serverConnectionObserver, await()).establishedMultiplexed(any(ConnectionInfo.class));\n+        }\n+\n+        connection.closeGracefully();\n+        assertConnectionClosed();\n+        verify(clientConnectionObserver).connectionClosed();\n+        verify(serverConnectionObserver, await()).connectionClosed();\n+\n+        verifyNoMoreInteractions(clientTransportObserver, clientDataObserver, clientMultiplexedObserver,\n+                serverTransportObserver, serverDataObserver, serverMultiplexedObserver);\n+        if (protocol != Protocol.HTTP_2) {\n+            // HTTP/2 coded adds additional write/flush events related to connection preface. Also, it may emit more\n+            // flush events on the pipeline after the connection is closed.\n+            verifyNoMoreInteractions(clientConnectionObserver, serverConnectionObserver);\n+        }\n+    }\n+\n+    @Test\n+    public void echoRequestResponse() throws Exception {\n+        String requestContent = \"request_content\";\n+        testRequestResponse(streamingHttpConnection().post(SVC_ECHO)\n+                .addHeader(CONTENT_LENGTH, String.valueOf(requestContent.length()))\n+                .payloadBody(getChunkPublisherFromStrings(requestContent)), OK, requestContent.length());\n+    }\n+\n+    @Test\n+    public void serverHandlerError() throws Exception {\n+        testRequestResponse(streamingHttpConnection().get(SVC_THROW_ERROR).addHeader(CONTENT_LENGTH, ZERO),\n+                INTERNAL_SERVER_ERROR, 0);\n+    }\n+\n+    public void testRequestResponse(StreamingHttpRequest request, HttpResponseStatus expectedStatus,\n+                                    int expectedResponseLength) throws Exception {\n+        processRequest.countDown();\n+        assertResponse(makeRequest(request), protocol.version, expectedStatus, expectedResponseLength);\n+\n+        verifyNewReadAndNewWrite(2);\n+\n+        verify(clientWriteObserver, atLeastOnce()).requestedToWrite(anyLong());\n+        verify(clientWriteObserver, atLeastOnce()).itemReceived();\n+        verify(clientWriteObserver, atLeastOnce()).onFlushRequest();\n+        verify(clientWriteObserver, atLeastOnce()).itemWritten();\n+        verify(clientWriteObserver).writeComplete();\n+\n+        verify(serverReadObserver, atLeastOnce()).requestedToRead(anyLong());\n+        verify(serverReadObserver, atLeastOnce()).itemRead();\n+        verify(serverReadObserver, await()).readComplete();\n+\n+        verify(serverWriteObserver, atLeastOnce()).requestedToWrite(anyLong());\n+        verify(serverWriteObserver, atLeastOnce()).itemReceived();\n+        verify(serverWriteObserver, atLeastOnce()).onFlushRequest();\n+        verify(serverWriteObserver, atLeastOnce()).itemWritten();\n+        if (protocol == Protocol.HTTP_2) {\n+            // HTTP/1.x has a single write publisher across all requests that does not complete after each response\n+            verify(serverWriteObserver).writeComplete();\n+        }\n+\n+        verify(clientReadObserver, atLeastOnce()).requestedToRead(anyLong());\n+        verify(clientReadObserver, atLeastOnce()).itemRead();\n+        verify(clientReadObserver).readComplete();\n+\n+        verifyNoMoreInteractions(\n+                clientDataObserver, clientMultiplexedObserver, clientReadObserver, clientWriteObserver,\n+                serverDataObserver, serverMultiplexedObserver, serverReadObserver, serverWriteObserver);\n+    }\n+\n+    @Test\n+    public void serverFailsResponsePayloadBodyBeforeRead() throws Exception {\n+        testServerFailsResponsePayloadBody(SVC_ERROR_BEFORE_READ, false);\n+    }\n+\n+    @Test\n+    public void serverFailsResponsePayloadBodyDuringRead() throws Exception {\n+        testServerFailsResponsePayloadBody(SVC_ERROR_DURING_READ, true);\n+    }\n+\n+    public void testServerFailsResponsePayloadBody(String path, boolean serverReadCompletes) throws Exception {\n+        processRequest.countDown();\n+        StreamingHttpConnection connection = streamingHttpConnection();\n+        StreamingHttpResponse response = makeRequest(connection.post(path)\n+                .addHeader(CONTENT_LENGTH, ZERO));\n+        assertThat(response.status(), is(OK));\n+        assertThat(response.version(), is(protocol.version));\n+\n+        ExecutionException e = assertThrows(ExecutionException.class,\n+                () -> response.payloadBody().ignoreElements().toFuture().get());\n+        Class<? extends Throwable> causeType = protocol == Protocol.HTTP_1 ?\n+                ClosedChannelException.class : H2StreamResetException.class;\n+        assertThat(e.getCause(), instanceOf(causeType));\n+\n+        if (protocol == Protocol.HTTP_2) {\n+            connection.closeGracefully();\n+        }\n+        assertConnectionClosed();\n+        verifyNewReadAndNewWrite(1);\n+\n+        verify(clientWriteObserver, atLeastOnce()).requestedToWrite(anyLong());\n+        verify(clientWriteObserver, atLeastOnce()).itemReceived();\n+        verify(clientWriteObserver, atLeastOnce()).onFlushRequest();\n+        verify(clientWriteObserver, atLeastOnce()).itemWritten();\n+        verify(clientWriteObserver).writeComplete();\n+        // Failure of the read triggers cancellation of the write.\n+        verify(clientWriteObserver, await()).writeCancelled();\n+\n+        verify(serverReadObserver, atLeastOnce()).requestedToRead(anyLong());\n+        verify(serverReadObserver, atLeastOnce()).itemRead();\n+        if (serverReadCompletes) {\n+            verify(serverReadObserver).readComplete();\n+        } else {\n+            // FIXME: because nobody subscribes to the request payload publisher, the terminal signal is not delivered\n+            // verify(serverReadObserver).readFailed(any(ClosedChannelException.class));", "originalCommit": "c336f398494e708d78cddc30351a4b07ce73d4bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA5NDUwOA==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r463094508", "bodyText": "the connection.read() did not terminate and was not canceled.\n\nThe server side subscribes to connection.read() to read the request so it should be cancelled if the response failed which in turn shuts down the connection processing. Looks like something is missing in this analysis/test.", "author": "NiteshKant", "createdAt": "2020-07-30T15:47:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyOTc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxNDY1MA==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r463414650", "bodyText": "Agreed, readCancel is expected here instead, but does not happen:\nWanted but not invoked:\nserverReadObserver.readCancelled();\n-> at io.servicetalk.http.netty.HttpTransportObserverTest.testServerFailsResponsePayloadBody(HttpTransportObserverTest.java:310)\n\nHowever, there were exactly 2 interactions with this mock:\nserverReadObserver.requestedToRead(1L);\n-> at io.servicetalk.transport.netty.internal.DefaultNettyConnection$2$1.lambda$request$0(DefaultNettyConnection.java:291)\n\nserverReadObserver.itemRead();\n-> at io.servicetalk.transport.netty.internal.TransportObserverUtils.safeReport(TransportObserverUtils.java:124)\n\nOpened #1112", "author": "idelpivnitskiy", "createdAt": "2020-07-31T05:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyOTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA2ODk2Mg==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r463068962", "bodyText": "Prefer operators over new source creation and context propagation handling complexity.\n        return readPublisher.liftSync(target -> {\n            final DataObserver dataObserver = this.dataObserver;\n            final ReadObserver observer;\n            if (dataObserver == null ||\n                    (observer = safeReport(dataObserver::onNewRead, dataObserver, \"new read\")) == null) {\n                return target;\n            }\n            return new PublisherSource.Subscriber<Read>() {\n                @Override\n                public void onSubscribe(final Subscription subscription) {\n                    target.onSubscribe(new Subscription() {\n                        @Override\n                        public void request(final long n) {\n                            safeReport(() -> observer.requestedToRead(n), observer, \"requested to read\");\n                            subscription.request(n);\n                        }\n\n                        @Override\n                        public void cancel() {\n                            safeReport(observer::readCancelled, observer, \"read cancelled\");\n                            subscription.cancel();\n                        }\n                    });\n                }\n\n                @Override\n                public void onNext(@Nullable final Read read) {\n                    safeReport(observer::itemRead, observer, \"item read\");\n                    target.onNext(read);\n                }\n\n                @Override\n                public void onError(final Throwable t) {\n                    safeReport(() -> observer.readFailed(t), observer, \"read failed\", t);\n                    target.onError(t);\n                }\n\n                @Override\n                public void onComplete() {\n                    safeReport(observer::readComplete, observer, \"read complete\");\n                    target.onComplete();\n                }\n            };\n        });", "author": "NiteshKant", "createdAt": "2020-07-30T15:10:59Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -268,6 +275,49 @@ protected void handleSubscribe(\n         };\n     }\n \n+    private Publisher<Read> registerReadObserver(final Publisher<Read> readPublisher) {\n+        return defer(() -> {\n+            final DataObserver dataObserver = this.dataObserver;\n+            final ReadObserver observer;\n+            if (dataObserver == null ||\n+                    (observer = safeReport(dataObserver::onNewRead, dataObserver, \"new read\")) == null) {\n+                return readPublisher.subscribeShareContext();", "originalCommit": "c336f398494e708d78cddc30351a4b07ce73d4bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA3MTkxNA==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r463071914", "bodyText": "An alternate to having call sites worry about unexpected error handling is to wrap the Observer with a catch-all implementation. The positives are:\n\nLess pollution on every call-site and danger of missing the error handling at some call-sites.\nCentral place where certain observer implementations can avoid allocation if they are known to be safe.\n\nThe cons are arguably higher allocation which is debatable when compared to this approach which allocates a new Runnable (capturing lambdas mostly) on each call.\nDid you consider this alternative?", "author": "NiteshKant", "createdAt": "2020-07-30T15:15:14Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverUtils.java", "diffHunk": "@@ -68,25 +83,84 @@ static ConnectionObserver connectionObserver(final Channel channel) {\n      * @param channel a {@link Channel} to assign a {@link Throwable} to\n      * @param error a {@link Throwable}\n      */\n-    static void assignConnectionError(final Channel channel, final Throwable error) {\n+    public static void assignConnectionError(final Channel channel, final Throwable error) {\n         if (connectionObserver(channel) != null) {\n             channel.attr(CONNECTION_ERROR).setIfAbsent(error);\n         }\n     }\n \n+    /**\n+     * Returns an {@link Throwable error} assigned with the specified {@link Channel}.\n+     *\n+     * @param channel to look for a {@link Throwable}\n+     * @return an {@link Throwable error} assigned with the specified {@link Channel}.\n+     */\n     @Nullable\n-    private static Throwable connectionError(final Channel channel) {\n+    public static Throwable connectionError(final Channel channel) {\n         return channel.attr(CONNECTION_ERROR).getAndSet(null);\n     }\n \n     static void reportSecurityHandshakeStarting(final Channel channel) {\n         final ConnectionObserver observer = connectionObserver(channel);\n         assert observer != null;\n-        channel.attr(SECURITY_HANDSHAKE_OBSERVER).set(requireNonNull(observer.onSecurityHandshake()));\n+        channel.attr(SECURITY_HANDSHAKE_OBSERVER)\n+                .set(safeReport(observer::onSecurityHandshake, observer, \"security handshake\"));\n     }\n \n     @Nullable\n     static SecurityHandshakeObserver securityHandshakeObserver(final Channel channel) {\n         return channel.attr(SECURITY_HANDSHAKE_OBSERVER).get();\n     }\n+\n+    /**\n+     * Safely executes the passed {@link Runnable} and logs unexpected exception if any.\n+     *\n+     * @param runnable {@link Runnable} to run\n+     * @param observer {@link Object} that is invoked\n+     * @param event event that is invoked\n+     */\n+    public static void safeReport(final Runnable runnable, final Object observer, final String event) {", "originalCommit": "c336f398494e708d78cddc30351a4b07ce73d4bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQxMTk3MQ==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r463411971", "bodyText": "Yes, I considered this alternative and do not worry much about the allocation overhead of catch-all implementation.\nThe case that I couldn't solve with that approach is when the original observer unexpectedly returns null, instead of another observer layer. If I do\nfinal class CatchAllTransportObserver implements TransportObserver {\n    //...\n    @Override\n    public ConnectionObserver onNewConnection() {\n        final ConnectionObserver connectionObserver = safeReport(delegate::onNewConnection, delegate, \"new connection\");\n        if (connectionObserver == null) {\n            return null;\n        }\n        return new CatchAllConnectionObserver(connectionObserver);\n    }\nThen intellij idea and spotbugs both complain:\nio.servicetalk.transport.netty.internal.CatchAllTransportObserver.onNewConnection() may return null, but is declared @Nonnull\n\nAlso, the caller of an observer API should always do something like:\n        final ConnectionObserver observer = transportObserver.onNewConnection();\n        if (observer == null) {\n            return;\n        }\nwhere intellij idea and spotbugs again complain:\nRedundant nullcheck of observer, which is known to be non-null in io.servicetalk.transport.netty.internal.TransportObserverInitializer.init(Channel)\n\nI decided that it will be annoying to suppress all these warnings twice: in spotbugs exclusion XML and an intellij idea via comments/annotations. And don't think that we need to annotate all methods as @Nullable.\nLMK what you think and I can address it in a follow-up.", "author": "idelpivnitskiy", "createdAt": "2020-07-31T05:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA3MTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1MjExNA==", "url": "https://github.com/apple/servicetalk/pull/1105#discussion_r463752114", "bodyText": "if (connectionObserver == null) {\n            return null;\n}\n\nreturn a NoopConnectionObserver instead of null?", "author": "NiteshKant", "createdAt": "2020-07-31T17:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA3MTkxNA=="}], "type": "inlineReview"}, {"oid": "ac2f7ff6e1039667c214e3e6eac6533bdfd16780", "url": "https://github.com/apple/servicetalk/commit/ac2f7ff6e1039667c214e3e6eac6533bdfd16780", "message": "Use liftSync instead of defer for registerReadObserver", "committedDate": "2020-07-31T01:19:15Z", "type": "commit"}, {"oid": "73fe1242f688d006f5fac9f72137a94366e516b0", "url": "https://github.com/apple/servicetalk/commit/73fe1242f688d006f5fac9f72137a94366e516b0", "message": "Update test fixme", "committedDate": "2020-07-31T05:29:05Z", "type": "commit"}]}