{"pr_number": 1240, "pr_title": "Add concurrent-api-test module", "pr_createdAt": "2020-12-05T01:00:46Z", "pr_url": "https://github.com/apple/servicetalk/pull/1240", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEwNTMwNw==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538105307", "bodyText": "Consider using ExecutorRule", "author": "idelpivnitskiy", "createdAt": "2020-12-08T07:41:59Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODExNzg1MA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538117850", "bodyText": "Do we need overrides for PublisherSource, SingleSource, and CompletableSource?", "author": "idelpivnitskiy", "createdAt": "2020-12-08T08:04:25Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/StepVerifiers.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.api.test.TimeSources.nanoTimeNormalized;\n+\n+/**\n+ * Create new test utilities to verify each step in the lifecycle of a {@link Publisher}, {@link Single},\n+ * and {@link Completable}. The steps are typically from the perspective of a {@link Subscriber}'s lifecycle.\n+ */\n+public final class StepVerifiers {\n+    private StepVerifiers() {\n+    }\n+\n+    /**\n+     * Create a new {@link PublisherFirstStep}.\n+     * @param source The {@link Publisher} to verify.\n+     * @param <T> The type of {@link Publisher}.\n+     * @return A {@link PublisherFirstStep} that can be used to verify {@code source}'s signal emission(s).\n+     */\n+    public static <T> PublisherFirstStep<T> create(Publisher<T> source) {", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MDUxMg==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r539550512", "bodyText": "are there common use cases you think these will be required? If not, folks can always do create(fromSource(source)) for the less common cases.", "author": "Scottmitch", "createdAt": "2020-12-09T18:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODExNzg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEzMjEyNw==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538132127", "bodyText": "I see the same pattern we use everywhere else, when we have a static factory class with the same name but in plural form: StepVerifier and StepVerifiers. However, this case looks different to me. These factory methods does not return StepVerifier interface. They return *FirstStep. So, no requirement to follow the pattern.\nWDYT abot the following ideas:\n\nStatic methods on StepVerifier interface.\nSome factory that will have stepVerifier methods instead of create. For example, Verifiers.stepVerifier(...) or Steps.stepVerifier(...).\n\nBecause we usually prefer static imports, having methods with stepVerifier name will help improve readability in tests. Current create(completed()) harder to understand.", "author": "idelpivnitskiy", "createdAt": "2020-12-08T08:26:15Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/StepVerifiers.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.api.test.TimeSources.nanoTimeNormalized;\n+\n+/**\n+ * Create new test utilities to verify each step in the lifecycle of a {@link Publisher}, {@link Single},\n+ * and {@link Completable}. The steps are typically from the perspective of a {@link Subscriber}'s lifecycle.\n+ */\n+public final class StepVerifiers {\n+    private StepVerifiers() {\n+    }\n+\n+    /**\n+     * Create a new {@link PublisherFirstStep}.\n+     * @param source The {@link Publisher} to verify.\n+     * @param <T> The type of {@link Publisher}.\n+     * @return A {@link PublisherFirstStep} that can be used to verify {@code source}'s signal emission(s).\n+     */\n+    public static <T> PublisherFirstStep<T> create(Publisher<T> source) {\n+        return new InlinePublisherFirstStep<>(toSource(source), nanoTimeNormalized());\n+    }\n+\n+    /**\n+     * Create a new {@link SingleFirstStep}.\n+     * @param source The {@link Single} to verify.\n+     * @param <T> The type of {@link Single}.\n+     * @return A {@link SingleFirstStep} that can be used to verify {@code source}'s signal emission(s).\n+     */\n+    public static <T> SingleFirstStep<T> create(Single<T> source) {", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NTM2MA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r539555360", "bodyText": "what about renaming the class to FirstSteps and keeping the create name? When folks use a static import they don't have as much naming/type information to digest this way, and if they want to be more explicit that they are creating a *FirstStep object they can do FirstSteps.create(..).", "author": "Scottmitch", "createdAt": "2020-12-09T18:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEzMjEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEzNTI0Mg==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538135242", "bodyText": "It can also be a SingleSource or CompletableSource. Consider listing all of them or avoiding the link. Something like \"This method will trigger a subscribe operation.\" looks enough to me.", "author": "idelpivnitskiy", "createdAt": "2020-12-08T08:30:29Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/StepVerifier.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+\n+import java.time.Duration;\n+\n+/**\n+ * Provides the ability to verify expectations on asynchronous sources.\n+ */\n+public interface StepVerifier {\n+    /**\n+     * Verify the none of the previously declared expectations are violated.\n+     * <p>\n+     * This method will trigger a {@link PublisherSource#subscribe(Subscriber) subscribe} operation.", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEzODI4Mw==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538138283", "bodyText": "Consider using assertThrows", "author": "idelpivnitskiy", "createdAt": "2020-12-08T08:35:19Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,649 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestSubscription;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.hamcrest.Matchers;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.Publisher.empty;\n+import static io.servicetalk.concurrent.api.Publisher.failed;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Publisher.never;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class PublisherStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectSubscription() {\n+        create(from(\"foo\"))\n+                .expectSubscription(Assert::assertNotNull)\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectSubscriptionTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(from(\"foo\").publishAndSubscribeOn(executor))\n+                    .expectSubscription(subscription -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectNext(\"foo\")\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void emptyItemsNonEmptyPublisher() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(emptyList())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void emptyItemsEmptyPublisher() {\n+        create(empty())\n+                .expectNext(emptyList())\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void singleItem() {\n+        assertNotNull(create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void singleItemNull() {\n+        assertNotNull(create(from((String) null))\n+                .expectNext((String) null)\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void singleItemDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(from(\"foo\"))\n+                .expectNext(next -> {\n+                    assertEquals(\"foo\", next);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void singleItemLargeTimeout() {\n+        assertNotNull(create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test\n+    public void twoItems() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void twoItemsIterable() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(() -> asList(\"foo\", \"bar\").iterator())\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justError() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(cause -> cause instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(cause -> {\n+                    assertThat(cause, instanceOf(DeliberateException.class));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void errorIgnoreNextFails() {\n+        verifyException(() -> create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectError(cause -> cause instanceof DeliberateException)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void completeIgnoreNextConsumer() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void justErrorTimeout() {\n+        verifyException(() -> create(never())\n+                .expectError(DeliberateException.class)\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onNextThenError() {\n+        create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectNext(\"foo\")\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void incorrectOnNextExpectation() {\n+        verifyException(() -> create(from(\"foo\"))\n+                    .expectNext(\"bar\")\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void timeoutOnNever() {\n+        verifyException(() -> create(never())\n+            .expectComplete()\n+            .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void expectNextCount() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNextCount(2)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextConsumer() {\n+        create(from(\"foo\"))\n+                .expectNext(next -> assertEquals(\"foo\", next))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextConsumerTimeout() {\n+        verifyException(() -> create(from(\"foo\").concat(never()))\n+                .expectNext(next -> assertEquals(\"foo\", next))\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextArrayMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextCollectionMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(asList(\"foo\", \"bar\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextIterableMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext((Iterable<String>) asList(\"foo\", \"bar\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextArrayLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextCollectionLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                        .expectNext(singletonList(\"foo\"))\n+                        .expectComplete()\n+                        .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextIterableLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                        .expectNext((Iterable<String>) singletonList(\"foo\"))\n+                        .expectComplete()\n+                        .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextConsumerFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(next -> assertEquals(\"bar\", next))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumer() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\", \"bar\")))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextMultiConsumerFail() {\n+        verifyException(() -> create(from(\"foo\", \"bar\"))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerMinComplete() {\n+        create(from(\"foo\"))\n+                .expectNext(1, 2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerMinFail() {\n+        create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectNext(1, 2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerZero() {\n+        create(empty())\n+                .expectNext(0, 2, nextIterable -> assertThat(nextIterable, Matchers.empty()))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextMultiConsumerTimeout() {\n+        verifyException(() -> create(from(\"foo\", \"bar\").concat(never()))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\", \"bar\")))\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnCompleteWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterNextThenCancelSucceeds() {\n+        create(from(\"foo\").concat(never()))\n+                .expectNext(\"foo\")\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsSubscriptionCompleteFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+        assertTrue(subscription.isCancelled());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(never())\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenCancel() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\")\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRequest() {\n+        create(from(\"foo\", \"bar\"))\n+                .thenRequest(Long.MAX_VALUE)\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRequestInvalidZero() {\n+        thenRequestInvalid(0);\n+    }\n+\n+    @Test\n+    public void thenRequestInvalidMin() {\n+        thenRequestInvalid(Long.MIN_VALUE);\n+    }\n+\n+    private static void thenRequestInvalid(long invalidN) {\n+        create(from(\"foo\", \"bar\"))\n+                .thenRequest(invalidN)\n+                .expectError(IllegalArgumentException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void multipleRequests() {\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .thenRequest(1)\n+                .thenRequest(2)\n+                .then(() -> {\n+                    assertThat(subscription.requested(), greaterThanOrEqualTo(3L));\n+                    publisher.onNext(\"foo\", \"bar\");\n+                    publisher.onComplete();\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+        assertThat(subscription.requested(), greaterThanOrEqualTo(5L));\n+    }\n+\n+    @Test\n+    public void requestThenCancel() {\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .thenRequest(100)\n+                .then(() -> {\n+                    assertThat(subscription.requested(), greaterThanOrEqualTo(100L));\n+                    publisher.onNext(\"foo\", \"bar\");\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .thenCancel()\n+                .verify();\n+        assertTrue(subscription.isCancelled());\n+    }\n+\n+    @Test\n+    public void thenRun() {\n+        PublisherSource.Processor<String, String> processor = newPublisherProcessor();\n+        create(fromSource(processor))\n+                .then(() -> {\n+                    processor.onNext(\"foo\");\n+                    processor.onNext(\"bar\");\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .then(processor::onComplete)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void thenRunThrows() {\n+        create(from(\"foo\"))\n+                .then(() -> {\n+                    throw new IllegalStateException();\n+                })\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void asyncContextOnComplete() {\n+        assert executor != null;\n+        create(from(\"foo\").publishAndSubscribeOn(executor))\n+                .expectSubscription(s -> {\n+                    assertNotNull(s);\n+                    AsyncContext.put(ASYNC_KEY, 10);\n+                })\n+                .expectNext(next -> {\n+                    assertEquals(\"foo\", next);\n+                    assertThat(AsyncContext.get(ASYNC_KEY), is(10));\n+                })\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void asyncContextOnError() {\n+        assert executor != null;\n+        create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)).publishAndSubscribeOn(executor))\n+                .expectSubscription(s -> {\n+                    assertNotNull(s);\n+                    AsyncContext.put(ASYNC_KEY, 10);\n+                })\n+                .expectNext(next -> {\n+                    assertEquals(\"foo\", next);\n+                    assertThat(AsyncContext.get(ASYNC_KEY), is(10));\n+                    AsyncContext.put(ASYNC_KEY, 15);\n+                })\n+                .expectError(error -> {\n+                    assertSame(DELIBERATE_EXCEPTION, error);\n+                    assertThat(AsyncContext.get(ASYNC_KEY), is(15));\n+                })\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenAwaitExitsWhenVerifyComplete() {\n+        create(from(\"foo\"))\n+                .thenAwait(ofDays(1))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenAwaitRespectsDelaysComplete() {\n+        PublisherSource.Processor<String, String> processor = newPublisherProcessor();\n+        new InlinePublisherFirstStep<>(processor, new DefaultModifiableTimeSource())\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofDays(500))\n+                .thenAwait(ofDays(1000))\n+                .then(() -> processor.onNext(\"foo\"))\n+                .expectNext(\"foo\")\n+                .then(processor::onComplete)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void thenAwaitRespectsDelaysEqualsFail() {\n+        thenAwaitRespectsDelaysFail(true);\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void thenAwaitRespectsDelaysGTFail() {\n+        thenAwaitRespectsDelaysFail(false);\n+    }\n+\n+    private static void thenAwaitRespectsDelaysFail(boolean equals) {\n+        PublisherSource.Processor<String, String> processor = newPublisherProcessor();\n+        verifyException(() -> new InlinePublisherFirstStep<>(processor, new DefaultModifiableTimeSource())\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofDays(equals ? 1000 : 1001))\n+                .thenAwait(ofDays(1000))\n+                .then(() -> processor.onNext(\"foo\"))\n+                .expectNext(\"foo\")\n+                .then(processor::onComplete)\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    private static void verifyException(Supplier<Duration> verifier) {\n+        verifyException(verifier, PublisherStepVerifierTest.class.getName());\n+    }\n+\n+    static void verifyException(Supplier<Duration> verifier, String classNamePrefix) {\n+        try {\n+            verifier.get();\n+        } catch (AssertionError error) {\n+            StackTraceElement[] stackTraceElements = error.getStackTrace();\n+            if (stackTraceElements.length == 0 || !stackTraceElements[0].getClassName().startsWith(classNamePrefix)) {\n+                // the tests expect AssertionError, we need to throw a different type of exception!\n+                throw new IllegalStateException(\"stacktrace does not start with classNamePrefix: \" + classNamePrefix,\n+                        error);\n+            }\n+            throw error;\n+        }\n+        throw new IllegalStateException(\"expected test to fail, but it didn't\");", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1ODYwNg==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r539558606", "bodyText": "I'll clarify the comment but we can't use assert* methods bcz the tests that fail expect AssertionError which means they would pass even if these checks failed.\n// The tests expect AssertionErrors, we need to throw a different type of exception so we use\n// IllegalStateException below.", "author": "Scottmitch", "createdAt": "2020-12-09T18:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEzODI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwODMwMA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541108300", "bodyText": "I will adjust so that these tests are verifying the actual method that is expected to be thrown, and this will change the exception verification. I'm not sure if assertThrows can be used though, as it seems limited to exception class type.", "author": "Scottmitch", "createdAt": "2020-12-11T17:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEzODI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE0MDczNg==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538140736", "bodyText": "This won't be necessary if verifyException uses assertThrows. assertThrows gives more control over the returned exception and allows to perform additional validataion: msg, cause, etc.\nexpected = AssertionError.class doesn't help to understand which \"expect*\" step causes an error.", "author": "idelpivnitskiy", "createdAt": "2020-12-08T08:39:10Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(completed())\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwNzU3OA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541107578", "bodyText": "I will adjust so that these tests are verifying the actual method that is expected to be thrown.", "author": "Scottmitch", "createdAt": "2020-12-11T17:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE0MDczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE0NDQ0OQ==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538144449", "bodyText": "Single -> Completable", "author": "idelpivnitskiy", "createdAt": "2020-12-08T08:44:48Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(completed())\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))\n+                    .expectCancellable(cancellable -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test\n+    public void onComplete() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onCompleteDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(completed())\n+                .expectCancellable(cancellable -> {\n+                    assertNotNull(cancellable);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void onCompleteLargeTimeout() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void onCompleteTimeout() {\n+        verifyException(() -> create(never())\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onErrorClass() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> error instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> {\n+                    assertThat(error, is(DELIBERATE_EXCEPTION));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(completed())\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnSuccessWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        create(never())\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(completed())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(Single.never())", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE0OTQ2Ng==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538149466", "bodyText": "Consider adding a test for failed(...)).thenCancel()", "author": "idelpivnitskiy", "createdAt": "2020-12-08T08:52:43Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(completed())\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))\n+                    .expectCancellable(cancellable -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test\n+    public void onComplete() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onCompleteDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(completed())\n+                .expectCancellable(cancellable -> {\n+                    assertNotNull(cancellable);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void onCompleteLargeTimeout() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void onCompleteTimeout() {\n+        verifyException(() -> create(never())\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onErrorClass() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> error instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> {\n+                    assertThat(error, is(DELIBERATE_EXCEPTION));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(completed())\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnSuccessWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        create(never())\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(completed())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(Single.never())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenCancel() {\n+        create(completed())\n+                .thenCancel()", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE1MjY4NA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538152684", "bodyText": "IIUC, it simulates exception from onSubscribe. Then we should expect onError and the test should not have expected = IllegalStateException.class.\nAlso, consider using DeliberateException.", "author": "idelpivnitskiy", "createdAt": "2020-12-08T08:57:29Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(completed())\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))\n+                    .expectCancellable(cancellable -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test\n+    public void onComplete() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onCompleteDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(completed())\n+                .expectCancellable(cancellable -> {\n+                    assertNotNull(cancellable);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void onCompleteLargeTimeout() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void onCompleteTimeout() {\n+        verifyException(() -> create(never())\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onErrorClass() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> error instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> {\n+                    assertThat(error, is(DELIBERATE_EXCEPTION));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(completed())\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnSuccessWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        create(never())\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(completed())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(Single.never())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenCancel() {\n+        create(completed())\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRun() {\n+        CompletableSource.Processor processor = newCompletableProcessor();\n+        create(fromSource(processor))\n+                .then(processor::onComplete)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void asyncContextOnError() {\n+        assert executor != null;\n+        create(failed(DELIBERATE_EXCEPTION).publishAndSubscribeOn(executor))\n+                .expectCancellable(s -> {\n+                    assertNotNull(s);\n+                    AsyncContext.put(ASYNC_KEY, 10);\n+                })\n+                .expectError(error -> {\n+                    assertSame(DELIBERATE_EXCEPTION, error);\n+                    assertThat(AsyncContext.get(ASYNC_KEY), is(10));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void thenRunThrows() {\n+        create(completed())\n+                .then(() -> {\n+                    throw new IllegalStateException();", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTExMDY0MQ==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541110641", "bodyText": "this is meant to highlight that the then() is invoked on the test thread, and will be propagated into the test. then() is a mechanism to orchestrate test sequencing items (e.g. publish new data, etc.).\n+1 for DeliberateException", "author": "Scottmitch", "createdAt": "2020-12-11T17:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE1MjY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE1NzEwNw==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538157107", "bodyText": "This class can be final.\nThis is the only Inline* class that is public. Can we make it pkg-private. If necessary, we should use static factories to create *Step implementations.\nIf it should be public, it misses javadoc.", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:03:42Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/InlineCompletableFirstStep.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.NoSignalForDurationEvent;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.OnSubscriptionEvent;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.OnTerminalCompleteEvent;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.OnTerminalErrorClassChecker;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.OnTerminalErrorEvent;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.OnTerminalErrorPredicate;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.VerifyThreadAwaitEvent;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.VerifyThreadRunEvent;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+import static io.servicetalk.concurrent.api.test.InlineStepVerifier.PublisherEvent;\n+import static java.util.Objects.requireNonNull;\n+\n+public class InlineCompletableFirstStep implements CompletableFirstStep {", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTExMTI3Nw==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541111277", "bodyText": "+1 to your comments (should be package private and final)", "author": "Scottmitch", "createdAt": "2020-12-11T17:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE1NzEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2MDg1Mg==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538160852", "bodyText": "Consider using ExecutorRule", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:09:05Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,649 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestSubscription;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.hamcrest.Matchers;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.Publisher.empty;\n+import static io.servicetalk.concurrent.api.Publisher.failed;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Publisher.never;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class PublisherStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2MDk0Mg==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538160942", "bodyText": "Consider using ExecutorRule", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:09:14Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/SingleStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.SingleSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newSingleProcessor;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.never;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SingleStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2NzM3NQ==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538167375", "bodyText": "Consider using DeliberateException", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:18:05Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,649 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestSubscription;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.hamcrest.Matchers;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.Publisher.empty;\n+import static io.servicetalk.concurrent.api.Publisher.failed;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Publisher.never;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class PublisherStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectSubscription() {\n+        create(from(\"foo\"))\n+                .expectSubscription(Assert::assertNotNull)\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectSubscriptionTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(from(\"foo\").publishAndSubscribeOn(executor))\n+                    .expectSubscription(subscription -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectNext(\"foo\")\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void emptyItemsNonEmptyPublisher() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(emptyList())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void emptyItemsEmptyPublisher() {\n+        create(empty())\n+                .expectNext(emptyList())\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void singleItem() {\n+        assertNotNull(create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void singleItemNull() {\n+        assertNotNull(create(from((String) null))\n+                .expectNext((String) null)\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void singleItemDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(from(\"foo\"))\n+                .expectNext(next -> {\n+                    assertEquals(\"foo\", next);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void singleItemLargeTimeout() {\n+        assertNotNull(create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test\n+    public void twoItems() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void twoItemsIterable() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(() -> asList(\"foo\", \"bar\").iterator())\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justError() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(cause -> cause instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(cause -> {\n+                    assertThat(cause, instanceOf(DeliberateException.class));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void errorIgnoreNextFails() {\n+        verifyException(() -> create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectError(cause -> cause instanceof DeliberateException)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void completeIgnoreNextConsumer() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void justErrorTimeout() {\n+        verifyException(() -> create(never())\n+                .expectError(DeliberateException.class)\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onNextThenError() {\n+        create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectNext(\"foo\")\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void incorrectOnNextExpectation() {\n+        verifyException(() -> create(from(\"foo\"))\n+                    .expectNext(\"bar\")\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void timeoutOnNever() {\n+        verifyException(() -> create(never())\n+            .expectComplete()\n+            .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void expectNextCount() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNextCount(2)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextConsumer() {\n+        create(from(\"foo\"))\n+                .expectNext(next -> assertEquals(\"foo\", next))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextConsumerTimeout() {\n+        verifyException(() -> create(from(\"foo\").concat(never()))\n+                .expectNext(next -> assertEquals(\"foo\", next))\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextArrayMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextCollectionMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(asList(\"foo\", \"bar\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextIterableMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext((Iterable<String>) asList(\"foo\", \"bar\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextArrayLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextCollectionLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                        .expectNext(singletonList(\"foo\"))\n+                        .expectComplete()\n+                        .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextIterableLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                        .expectNext((Iterable<String>) singletonList(\"foo\"))\n+                        .expectComplete()\n+                        .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextConsumerFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(next -> assertEquals(\"bar\", next))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumer() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\", \"bar\")))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextMultiConsumerFail() {\n+        verifyException(() -> create(from(\"foo\", \"bar\"))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerMinComplete() {\n+        create(from(\"foo\"))\n+                .expectNext(1, 2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerMinFail() {\n+        create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectNext(1, 2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerZero() {\n+        create(empty())\n+                .expectNext(0, 2, nextIterable -> assertThat(nextIterable, Matchers.empty()))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextMultiConsumerTimeout() {\n+        verifyException(() -> create(from(\"foo\", \"bar\").concat(never()))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\", \"bar\")))\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnCompleteWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterNextThenCancelSucceeds() {\n+        create(from(\"foo\").concat(never()))\n+                .expectNext(\"foo\")\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsSubscriptionCompleteFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+        assertTrue(subscription.isCancelled());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(never())\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenCancel() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\")\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRequest() {\n+        create(from(\"foo\", \"bar\"))\n+                .thenRequest(Long.MAX_VALUE)\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRequestInvalidZero() {\n+        thenRequestInvalid(0);\n+    }\n+\n+    @Test\n+    public void thenRequestInvalidMin() {\n+        thenRequestInvalid(Long.MIN_VALUE);\n+    }\n+\n+    private static void thenRequestInvalid(long invalidN) {\n+        create(from(\"foo\", \"bar\"))\n+                .thenRequest(invalidN)\n+                .expectError(IllegalArgumentException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void multipleRequests() {\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .thenRequest(1)\n+                .thenRequest(2)\n+                .then(() -> {\n+                    assertThat(subscription.requested(), greaterThanOrEqualTo(3L));\n+                    publisher.onNext(\"foo\", \"bar\");\n+                    publisher.onComplete();\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+        assertThat(subscription.requested(), greaterThanOrEqualTo(5L));\n+    }\n+\n+    @Test\n+    public void requestThenCancel() {\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .thenRequest(100)\n+                .then(() -> {\n+                    assertThat(subscription.requested(), greaterThanOrEqualTo(100L));\n+                    publisher.onNext(\"foo\", \"bar\");\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .thenCancel()\n+                .verify();\n+        assertTrue(subscription.isCancelled());\n+    }\n+\n+    @Test\n+    public void thenRun() {\n+        PublisherSource.Processor<String, String> processor = newPublisherProcessor();\n+        create(fromSource(processor))\n+                .then(() -> {\n+                    processor.onNext(\"foo\");\n+                    processor.onNext(\"bar\");\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .then(processor::onComplete)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void thenRunThrows() {\n+        create(from(\"foo\"))\n+                .then(() -> {\n+                    throw new IllegalStateException();", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2NzY3Ng==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538167676", "bodyText": "Consider using DeliberateException", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:18:33Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/SingleStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.SingleSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newSingleProcessor;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.never;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SingleStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(succeeded(\"foo\"))\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectSuccess(\"foo\")\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))\n+                    .expectCancellable(cancellable -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test\n+    public void onSuccessDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(succeeded(\"foo\"))\n+                .expectCancellable(cancellable -> {\n+                    assertNotNull(cancellable);\n+                    latch.countDown();\n+                })\n+                .expectSuccess(\"foo\");\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void onSuccess() {\n+        assertNotNull(create(succeeded(\"foo\"))\n+                .expectSuccess(\"foo\")\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onSuccessNull() {\n+        assertNotNull(create(succeeded(null))\n+                .expectSuccess((String) null)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onSuccessLargeTimeout() {\n+        assertNotNull(create(succeeded(\"foo\"))\n+                .expectSuccess(\"foo\")\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void onSuccessTimeout() {\n+        verifyException(() -> create(never())\n+                .expectSuccess(\"foo\")\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onErrorClass() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> error instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> {\n+                    assertThat(error, is(DELIBERATE_EXCEPTION));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnSuccess() {\n+        verifyException(() -> create(succeeded(\"foo\"))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnSuccessWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                    .expectSuccess(\"foo\")\n+                    .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        create(never())\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsSuccessFail() {\n+        verifyException(() -> create(succeeded(\"foo\"))\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectSuccess(\"foo\")\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(Single.never())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenCancel() {\n+        create(succeeded(\"foo\"))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRun() {\n+        SingleSource.Processor<String, String> processor = newSingleProcessor();\n+        create(fromSource(processor))\n+                .then(() -> processor.onSuccess(\"foo\"))\n+                .expectSuccess(\"foo\")\n+                .verify();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void thenRunThrows() {\n+        create(succeeded(\"foo\"))\n+                .then(() -> {\n+                    throw new IllegalStateException();", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2ODYyNw==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538168627", "bodyText": "completed -> Single.succeeded", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:19:47Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/SingleStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.SingleSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newSingleProcessor;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.never;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SingleStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(succeeded(\"foo\"))\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectSuccess(\"foo\")\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTc2OQ==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538171769", "bodyText": "This is a popular pattern when users don't need to do anything with the Cancellable, consider adding expectCancellable() overload that will perform non-null check only.", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:23:57Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(completed())\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))\n+                    .expectCancellable(cancellable -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test\n+    public void onComplete() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onCompleteDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(completed())\n+                .expectCancellable(cancellable -> {\n+                    assertNotNull(cancellable);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void onCompleteLargeTimeout() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void onCompleteTimeout() {\n+        verifyException(() -> create(never())\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onErrorClass() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> error instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> {\n+                    assertThat(error, is(DELIBERATE_EXCEPTION));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(completed())\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnSuccessWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        create(never())\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(completed())\n+                .expectCancellable(c -> { })", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTExMzU0Mg==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541113542", "bodyText": "This isn't necessary as the test utilities will fail if there is no Subscription before other signals are delivered because this is never valid per RS spec.", "author": "Scottmitch", "createdAt": "2020-12-11T17:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTMzMDU0NA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541330544", "bodyText": "Does that mean that we can remove all .expectCancellable(c -> { }) and .expectCancellable(Assert::assertNotNull) from all existing tests?", "author": "idelpivnitskiy", "createdAt": "2020-12-11T21:50:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM1NTYwMg==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541355602", "bodyText": "After thinking about it the expectCancellable() maybe helpful to sequence then(() -> {}) and other events that run on the verify thread ... let me add them.\nWe will test both methods in our tests here.", "author": "Scottmitch", "createdAt": "2020-12-11T22:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3NTg0OA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538175848", "bodyText": "This is a popular pattern when users don't need to do anything with the Subscription, consider adding expectSubscription() overload that will perform a non-null check only.", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:29:30Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,649 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestSubscription;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.hamcrest.Matchers;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.Publisher.empty;\n+import static io.servicetalk.concurrent.api.Publisher.failed;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Publisher.never;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class PublisherStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectSubscription() {\n+        create(from(\"foo\"))\n+                .expectSubscription(Assert::assertNotNull)", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTMyNzIzNQ==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541327235", "bodyText": "lets discuss above, same topic as #1240 (comment)", "author": "Scottmitch", "createdAt": "2020-12-11T21:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3NTg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3NjE4OQ==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538176189", "bodyText": "This is a popular pattern when users don't need to do anything with the Cancellable, consider adding expectCancellable() overload that will perform a non-null check only.", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:29:56Z", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/SingleStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.SingleSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newSingleProcessor;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.never;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SingleStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(succeeded(\"foo\"))\n+                .expectCancellable(Assert::assertNotNull)", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTMyNzI4OA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541327288", "bodyText": "lets discuss above, same topic as #1240 (comment)", "author": "Scottmitch", "createdAt": "2020-12-11T21:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3NjE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3OTMxNQ==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538179315", "bodyText": "Consider adding expectError() overload that will expect any error for Completable, Publisher, and Single last step.", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:34:24Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/CompletableLastStep.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides the ability to express expectations for the terminal signals (e.g.\n+ * {@link Subscriber#onComplete() onComplete} or {@link Subscriber#onError(Throwable) onError}) of a {@link Subscriber}.\n+ */\n+public interface CompletableLastStep {\n+    /**\n+     * Expect no signals in {@code duration} time.\n+     * @param duration The amount of time to assert that no signals are received.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    CompletableLastStep expectNoSignals(Duration duration);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and evaluate it\n+     * with {@code errorPredicate}.\n+     * @param errorPredicate Will be invoked when {@link Subscriber#onError(Throwable) onError} is called and will raise\n+     * a {@link AssertionError} if the predicate returns {@code false}.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Predicate<Throwable> errorPredicate);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and it will be\n+     * of type {@code errorClass}.\n+     * @param errorClass The type of error which is expected.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Class<? extends Throwable> errorClass);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and evaluate it\n+     * with {@code errorConsumer}.\n+     * @param errorConsumer Will be invoked when {@link Subscriber#onError(Throwable) onError} is called.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Consumer<Throwable> errorConsumer);", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4NDgzMg==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538184832", "bodyText": "Consider adding expectNext(Predicate) overload to be consistent with expectError(Predicate)", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:41:52Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/PublisherStep.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides the ability to express expectations for the {@link Subscriber#onNext(Object)} stages of a\n+ * {@link Subscriber Subscriber}'s lifecycle.\n+ * @param <T> The type of {@link Subscriber}.\n+ */\n+public interface PublisherStep<T> extends PublisherLastStep {\n+    /**\n+     * Declare an expectation that {@code signal} will be the next {@link Subscriber#onNext(Object) signal}.\n+     * @param signal The next signal which is expected.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(@Nullable T signal);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    PublisherStep<T> expectNext(T... signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Iterable<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Collection<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that can be asserted when the {@link Subscriber#onNext(Object) onNext} method is invoked.\n+     * @param signalConsumer Consumes the next {@link Subscriber#onNext(Object) onNext} signal.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Consumer<? super T> signalConsumer);", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0MjY3Ng==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541142676", "bodyText": "sounds good, I will have to qualify the method name to avoid ambiguity.", "author": "Scottmitch", "createdAt": "2020-12-11T18:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4NDgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4ODQwOA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538188408", "bodyText": "All collections are Iterable. Do we need an additional overload for Collection?", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:46:11Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/PublisherStep.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides the ability to express expectations for the {@link Subscriber#onNext(Object)} stages of a\n+ * {@link Subscriber Subscriber}'s lifecycle.\n+ * @param <T> The type of {@link Subscriber}.\n+ */\n+public interface PublisherStep<T> extends PublisherLastStep {\n+    /**\n+     * Declare an expectation that {@code signal} will be the next {@link Subscriber#onNext(Object) signal}.\n+     * @param signal The next signal which is expected.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(@Nullable T signal);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    PublisherStep<T> expectNext(T... signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Iterable<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Collection<? extends T> signals);", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NDk5NQ==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541144995", "bodyText": "good point, Iterable was added later and can cover the API bases.", "author": "Scottmitch", "createdAt": "2020-12-11T18:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4ODQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4OTUxMw==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538189513", "bodyText": "requestN takes long, we should allow n in long range here.", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:47:38Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/PublisherStep.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides the ability to express expectations for the {@link Subscriber#onNext(Object)} stages of a\n+ * {@link Subscriber Subscriber}'s lifecycle.\n+ * @param <T> The type of {@link Subscriber}.\n+ */\n+public interface PublisherStep<T> extends PublisherLastStep {\n+    /**\n+     * Declare an expectation that {@code signal} will be the next {@link Subscriber#onNext(Object) signal}.\n+     * @param signal The next signal which is expected.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(@Nullable T signal);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    PublisherStep<T> expectNext(T... signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Iterable<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Collection<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that can be asserted when the {@link Subscriber#onNext(Object) onNext} method is invoked.\n+     * @param signalConsumer Consumes the next {@link Subscriber#onNext(Object) onNext} signal.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Consumer<? super T> signalConsumer);\n+\n+    /**\n+     * Expect {@code n} {@link Subscriber#onNext(Object) onNext} signals, and assert their values via\n+     * {@code signalsConsumer}.\n+     * @param n The number of {@link Subscriber#onNext(Object) onNext} signals that are expected.\n+     * @param signalsConsumer A {@link Consumer} that accepts an {@link Collection} which has {@code n} items.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(int n, Consumer<? super Collection<? extends T>> signalsConsumer);", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTMyNTIyNQ==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541325225", "bodyText": "discussed offline Collection.size() returns an int, I will use an Iterable for now. We can add a more sophisticated API that doesn't require in memory aggregation in the future if necessary.", "author": "Scottmitch", "createdAt": "2020-12-11T21:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4OTUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4OTczMA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538189730", "bodyText": "Consider using long instead of int", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:47:58Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/PublisherStep.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides the ability to express expectations for the {@link Subscriber#onNext(Object)} stages of a\n+ * {@link Subscriber Subscriber}'s lifecycle.\n+ * @param <T> The type of {@link Subscriber}.\n+ */\n+public interface PublisherStep<T> extends PublisherLastStep {\n+    /**\n+     * Declare an expectation that {@code signal} will be the next {@link Subscriber#onNext(Object) signal}.\n+     * @param signal The next signal which is expected.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(@Nullable T signal);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    PublisherStep<T> expectNext(T... signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Iterable<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Collection<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that can be asserted when the {@link Subscriber#onNext(Object) onNext} method is invoked.\n+     * @param signalConsumer Consumes the next {@link Subscriber#onNext(Object) onNext} signal.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Consumer<? super T> signalConsumer);\n+\n+    /**\n+     * Expect {@code n} {@link Subscriber#onNext(Object) onNext} signals, and assert their values via\n+     * {@code signalsConsumer}.\n+     * @param n The number of {@link Subscriber#onNext(Object) onNext} signals that are expected.\n+     * @param signalsConsumer A {@link Consumer} that accepts an {@link Collection} which has {@code n} items.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(int n, Consumer<? super Collection<? extends T>> signalsConsumer);\n+\n+    /**\n+     * Expect between {@code [min, max]} {@link Subscriber#onNext(Object) onNext} signals, and assert their values via\n+     * {@code signalsConsumer}.\n+     * @param min The minimum number of {@link Subscriber#onNext(Object) onNext} signals that are required before\n+     * invoking {@code signalsConsumer}. If a terminal signal is processed and the number of accumulated\n+     * {@link Subscriber#onNext(Object) onNext} signals is {@code >=} this value the {@code signalsConsumer} will be\n+     * invoked for verification, otherwise the expectation will fail.\n+     * @param max The maximum number of {@link Subscriber#onNext(Object) onNext} signals that will be accumulated\n+     * before invoking {@code signalsConsumer}.\n+     * @param signalsConsumer A {@link Consumer} that accepts an {@link Collection} which has between\n+     * {@code [min, max]} items and preforms verification.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(int min, int max, Consumer<? super Collection<? extends T>> signalsConsumer);", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5MDg5Mg==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538190892", "bodyText": "Consider adding expectSuccess(Predicate) for consistency with expectError(Predicate)", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:49:33Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/SingleLastStep.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides the ability to express expectations for the terminal signals (e.g.\n+ * {@link Subscriber#onSuccess(Object) onSuccess} or {@link Subscriber#onError(Throwable) onError}) of a\n+ * {@link Subscriber}.\n+ * @param <T> The type of {@link Subscriber}.\n+ */\n+public interface SingleLastStep<T> {\n+    /**\n+     * Expect no signals in {@code duration} time.\n+     * @param duration The amount of time to assert that no signals are received.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    SingleLastStep<T> expectNoSignals(Duration duration);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and evaluate it\n+     * with {@code errorPredicate}.\n+     * @param errorPredicate Will be invoked when {@link Subscriber#onError(Throwable) onError} is called and will raise\n+     * a {@link AssertionError} if the predicate returns {@code false}.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Predicate<Throwable> errorPredicate);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and it will be\n+     * of type {@code errorClass}.\n+     * @param errorClass The type of error which is expected.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Class<? extends Throwable> errorClass);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and evaluate it\n+     * with {@code errorConsumer}.\n+     * @param errorConsumer Will be invoked when {@link Subscriber#onError(Throwable) onError} is called.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Consumer<Throwable> errorConsumer);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onSuccess(Object) onSuccess} will be the next signal.\n+     * @param onSuccess The expected value of {@link Subscriber#onSuccess(Object) onSuccess}.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectSuccess(@Nullable T onSuccess);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onSuccess(Object) onSuccess} will be the next signal and verify it\n+     * with {@code onSuccessConsumer}.\n+     * @param onSuccessConsumer Used to verify {@link Subscriber#onSuccess(Object) onSuccess}.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectSuccess(Consumer<? super T> onSuccessConsumer);", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5NjgzMA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538196830", "bodyText": "This can overflow if one of them is negative", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:57:30Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/TimeSource.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+\n+import static io.servicetalk.concurrent.api.test.TimeUtils.convert;\n+import static io.servicetalk.concurrent.api.test.TimeUtils.toChronoUnit;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * A time source. This time source can be used to determine when a specific duration of time has passed. This process\n+ * requires saving a start time, and then using a fixed expiration duration:\n+ *\n+ * <pre>\n+ * TimeSource timeSource = timeSource();\n+ * long startTime = timeSource.get();\n+ * doWork();\n+ * boolean expired = timeSource.isExpired(startTime, 100, NANOSECONDS);\n+ * &#47;&#47; If expired is true then at least 100 nanoseconds have passed since startTime\n+ * </pre>\n+ */\n+@FunctionalInterface\n+interface TimeSource {\n+    /**\n+     * Get the current time. The units are determined by {@link #currentTimeUnits()}.\n+     * @return The current time. The units are determined by {@link #currentTimeUnits()}.\n+     */\n+    long currentTime();\n+\n+    /**\n+     * Get the units for {@link #currentTime()}.\n+     * @return The units for {@link #currentTime()}.\n+     */\n+    default TimeUnit currentTimeUnits() {\n+        return NANOSECONDS;\n+    }\n+\n+    /**\n+     * Determine if at least {@code duration} ticks have passed since {@code startTime} time.\n+     *\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired. Must be {@code >= 0}.\n+     * @param durationUnit The units for {@code duration}.\n+     * @return {@code true} if at least {@code duration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, long duration, TimeUnit durationUnit) {\n+        assert duration >= 0;\n+        return currentTime() - startTime >= currentTimeUnits().convert(duration, durationUnit);", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTM4MjEzNQ==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r541382135", "bodyText": "discussed offline, this assumes a monotonic time source, and cannot overcome numerical overflow. javadocs updated to reflect this.", "author": "Scottmitch", "createdAt": "2020-12-11T22:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5NjgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5ODQzMg==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538198432", "bodyText": "It looks more like IllegalArgumentException, not an assertion", "author": "idelpivnitskiy", "createdAt": "2020-12-08T09:59:40Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/TimeSource.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+\n+import static io.servicetalk.concurrent.api.test.TimeUtils.convert;\n+import static io.servicetalk.concurrent.api.test.TimeUtils.toChronoUnit;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * A time source. This time source can be used to determine when a specific duration of time has passed. This process\n+ * requires saving a start time, and then using a fixed expiration duration:\n+ *\n+ * <pre>\n+ * TimeSource timeSource = timeSource();\n+ * long startTime = timeSource.get();\n+ * doWork();\n+ * boolean expired = timeSource.isExpired(startTime, 100, NANOSECONDS);\n+ * &#47;&#47; If expired is true then at least 100 nanoseconds have passed since startTime\n+ * </pre>\n+ */\n+@FunctionalInterface\n+interface TimeSource {\n+    /**\n+     * Get the current time. The units are determined by {@link #currentTimeUnits()}.\n+     * @return The current time. The units are determined by {@link #currentTimeUnits()}.\n+     */\n+    long currentTime();\n+\n+    /**\n+     * Get the units for {@link #currentTime()}.\n+     * @return The units for {@link #currentTime()}.\n+     */\n+    default TimeUnit currentTimeUnits() {\n+        return NANOSECONDS;\n+    }\n+\n+    /**\n+     * Determine if at least {@code duration} ticks have passed since {@code startTime} time.\n+     *\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired. Must be {@code >= 0}.\n+     * @param durationUnit The units for {@code duration}.\n+     * @return {@code true} if at least {@code duration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, long duration, TimeUnit durationUnit) {\n+        assert duration >= 0;\n+        return currentTime() - startTime >= currentTimeUnits().convert(duration, durationUnit);\n+    }\n+\n+    /**\n+     * Determine if at least {@code expireDuration} ticks have passed since {@code startTime} time.\n+     *\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired. Must be {@code >= 0}.\n+     * @return {@code true} if at least {@code expireDuration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, Duration duration) {\n+        assert !duration.isNegative();", "originalCommit": "64421feb99b329e2f9ab2407d114d477dac2b924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYxMDY2MA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r543610660", "bodyText": "let me just remove this restriction for now, as folks may have negative durations which may be considered expired.", "author": "Scottmitch", "createdAt": "2020-12-15T19:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5ODQzMg=="}], "type": "inlineReview"}, {"oid": "8773e41b4568f45b8e08b42655a0aea35a24041f", "url": "https://github.com/apple/servicetalk/commit/8773e41b4568f45b8e08b42655a0aea35a24041f", "message": "review comments", "committedDate": "2020-12-11T21:44:36Z", "type": "forcePushed"}, {"oid": "75148784ffc0546f70ed33b8f27ae58b58721581", "url": "https://github.com/apple/servicetalk/commit/75148784ffc0546f70ed33b8f27ae58b58721581", "message": "Add concurrent-api-test module\n\nMotivation:\nThere is currently a servicetalk-concurrent-test-internal module for low\nlevel testing of concurrent utilities. However there is no user facing\ntesting utility for dealing with concurrent-api primitives.\n\nModifications:\n- Introduce the concurrent-api-test module which has the StepVerifiers\nentry point. There are 3 entry points one for each async source type:\n  - PublisherFirstStep\n  - SingleFirstStep\n  - CompletableFirstStep\n\nEach of these APIs exposes a sequence of further APIs which represents\nthe expected signal flow of each respective source (e.g. onSubscribe,\nonNext*, [onComplete | onError]?). This approach is inspired by\n[reactor-test](https://projectreactor.io/docs/core/release/reference/index.html#testing).\n\nResult:\nUser facing test utilities exist for concurrent-api.", "committedDate": "2020-12-14T21:07:22Z", "type": "commit"}, {"oid": "694902972f89eb14d7373ba2e60efaf31c765757", "url": "https://github.com/apple/servicetalk/commit/694902972f89eb14d7373ba2e60efaf31c765757", "message": "remove state from events to avoid copying the queue, use a List and an index to track current location in each test execution, enhance tests to verify multiple subscription events.", "committedDate": "2020-12-14T21:07:22Z", "type": "commit"}, {"oid": "d657eecb13bf3de68b0e0d296407dfbeadbc219e", "url": "https://github.com/apple/servicetalk/commit/d657eecb13bf3de68b0e0d296407dfbeadbc219e", "message": "init state for OnNextAggregateEvent upfront", "committedDate": "2020-12-14T21:07:22Z", "type": "commit"}, {"oid": "71a812b09b80d1a842658486021b4a26bda3614e", "url": "https://github.com/apple/servicetalk/commit/71a812b09b80d1a842658486021b4a26bda3614e", "message": "allow empty aggregate event", "committedDate": "2020-12-14T21:07:22Z", "type": "commit"}, {"oid": "c8623287e7dbbe72c703a641ff59f5dd2937cdfd", "url": "https://github.com/apple/servicetalk/commit/c8623287e7dbbe72c703a641ff59f5dd2937cdfd", "message": "add null check and use import", "committedDate": "2020-12-14T21:07:22Z", "type": "commit"}, {"oid": "0fc5d3f871c52ba49bd1624fc87e7113b5c03660", "url": "https://github.com/apple/servicetalk/commit/0fc5d3f871c52ba49bd1624fc87e7113b5c03660", "message": "review comments", "committedDate": "2020-12-14T21:07:22Z", "type": "commit"}, {"oid": "c55e1a13a5a4ab00c6e218fd0922bc4b761a81f2", "url": "https://github.com/apple/servicetalk/commit/c55e1a13a5a4ab00c6e218fd0922bc4b761a81f2", "message": "clarify TimeSource methods need monotonic", "committedDate": "2020-12-14T21:07:22Z", "type": "commit"}, {"oid": "8ae27a2a22eb7e8750a898538412542014eb8743", "url": "https://github.com/apple/servicetalk/commit/8ae27a2a22eb7e8750a898538412542014eb8743", "message": "add expectSubscription() method, clarify TimeSource limitations", "committedDate": "2020-12-14T21:07:22Z", "type": "commit"}, {"oid": "8ae27a2a22eb7e8750a898538412542014eb8743", "url": "https://github.com/apple/servicetalk/commit/8ae27a2a22eb7e8750a898538412542014eb8743", "message": "add expectSubscription() method, clarify TimeSource limitations", "committedDate": "2020-12-14T21:07:22Z", "type": "forcePushed"}, {"oid": "86e10ac28dd08988be5d2c828165df73d98bffc1", "url": "https://github.com/apple/servicetalk/commit/86e10ac28dd08988be5d2c828165df73d98bffc1", "message": "revert concurrent-api dependency due to intellij issue https://youtrack.jetbrains.com/issue/IDEA-159568", "committedDate": "2020-12-15T04:24:31Z", "type": "commit"}, {"oid": "dd3924e6516f128c4bf09afbdef8781f66cace2e", "url": "https://github.com/apple/servicetalk/commit/dd3924e6516f128c4bf09afbdef8781f66cace2e", "message": "Use ExecutorRule", "committedDate": "2020-12-15T04:35:21Z", "type": "commit"}, {"oid": "dfd4e6954aad874ecd690942bdc6736f097c7218", "url": "https://github.com/apple/servicetalk/commit/dfd4e6954aad874ecd690942bdc6736f097c7218", "message": "update TimeSource methods", "committedDate": "2020-12-15T19:05:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0MTAyNA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r543641024", "bodyText": "We discussed offline that isExpired methods should return true if diff between start and current time is more than Long.MAX_VALUE.", "author": "idelpivnitskiy", "createdAt": "2020-12-15T19:50:57Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/TimeSource.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+\n+import static io.servicetalk.concurrent.api.test.TimeUtils.convert;\n+import static io.servicetalk.concurrent.api.test.TimeUtils.toChronoUnit;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * A source of time that can be represented as a {@code long}.\n+ * <p>\n+ * If the underlying time source is monotonic, utility methods are provided to determine if specific duration of time\n+ * has elapsed (aka expired). This process requires saving a start time, and then using a fixed expiration duration:\n+ *\n+ * <pre>\n+ * TimeSource timeSource = timeSource();\n+ * long startTime = timeSource.get();\n+ * doWork();\n+ * boolean expired = timeSource.isExpired(startTime, 100, NANOSECONDS);\n+ * &#47;&#47; If expired is true then at least 100 nanoseconds have passed since startTime\n+ * </pre>\n+ */\n+@FunctionalInterface\n+interface TimeSource {\n+    /**\n+     * Get the current time. The units are determined by {@link #currentTimeUnits()}.\n+     * @return The current time. The units are determined by {@link #currentTimeUnits()}.\n+     */\n+    long currentTime();\n+\n+    /**\n+     * Get the units for {@link #currentTime()}.\n+     * @return The units for {@link #currentTime()}.\n+     */\n+    default TimeUnit currentTimeUnits() {\n+        return NANOSECONDS;\n+    }\n+\n+    /**\n+     * Determine if at least {@code duration} ticks have passed since {@code startTime} time.\n+     * <p>\n+     * If this {@link TimeSource} is not monotonic, and time goes \"backwards\" the behavior of this method is undefined.\n+     * <p>\n+     * Differences between {@code startTime} and {@link #currentTime()} that span greater than 2<sup>63</sup> (~292\n+     * years if {@link #currentTimeUnits()} is {@link TimeUnit#NANOSECONDS}) will not correctly compute elapsed time due\n+     * to numerical overflow.\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired. Units are {@link #currentTime()}.\n+     * @return {@code true} if at least {@code duration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, long duration) {\n+        return currentTime() - startTime >= duration;\n+    }\n+\n+    /**\n+     * Determine if at least {@code duration} ticks have passed since {@code startTime} time.\n+     * <p>\n+     * If this {@link TimeSource} is not monotonic, and time goes \"backwards\" the behavior of this method is undefined.\n+     * <p>\n+     * Differences between {@code startTime} and {@link #currentTime()} that span greater than 2<sup>63</sup> (~292\n+     * years if {@link #currentTimeUnits()} is {@link TimeUnit#NANOSECONDS}) will not correctly compute elapsed time due\n+     * to numerical overflow.\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired.\n+     * @param durationUnit The units for {@code duration}.\n+     * @return {@code true} if at least {@code duration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, long duration, TimeUnit durationUnit) {\n+        return currentTime() - startTime >= currentTimeUnits().convert(duration, durationUnit);\n+    }\n+\n+    /**\n+     * Determine if at least {@code expireDuration} ticks have passed since {@code startTime} time.\n+     * <p>\n+     * If this {@link TimeSource} is not monotonic, and time goes \"backwards\" the behavior of this method is undefined.\n+     * <p>\n+     * Differences between {@code startTime} and {@link #currentTime()} that span greater than 2<sup>63</sup> (~292\n+     * years if {@link #currentTimeUnits()} is {@link TimeUnit#NANOSECONDS}) will not correctly compute elapsed time due\n+     * to numerical overflow.\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired.\n+     * @return {@code true} if at least {@code expireDuration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, Duration duration) {\n+        return currentTime() - startTime >= convert(currentTimeUnits(), duration);", "originalCommit": "dfd4e6954aad874ecd690942bdc6736f097c7218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5NTQ5NA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r543795494", "bodyText": "difference of more than Long.MAX_VALUE means the value would overflow (and be negative, or may underflow back to positive, etc.). lets hold off on overflow detection for now as it is unlikely to occur (292+ years for ns) in any real scenarios.", "author": "Scottmitch", "createdAt": "2020-12-16T00:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0MTAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1MDEwNA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r543650104", "bodyText": "IMHO, FirstSteps is harder to discover compare to previous StepVerifiers factory. Not clear what the FirstSteps should be used for. StepVerifiers terminology is likely more familiar for users.", "author": "idelpivnitskiy", "createdAt": "2020-12-15T20:05:09Z", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/FirstSteps.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.api.test.TimeSources.nanoTimeNormalized;\n+\n+/**\n+ * Create new test utilities to verify each step in the lifecycle of a {@link Publisher}, {@link Single},\n+ * and {@link Completable}. The steps are typically from the perspective of a {@link Subscriber}'s lifecycle.\n+ */\n+public final class FirstSteps {", "originalCommit": "dfd4e6954aad874ecd690942bdc6736f097c7218", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzczMjA5OA==", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r543732098", "bodyText": "sgtm. lets stick with StepVerifiers.", "author": "Scottmitch", "createdAt": "2020-12-15T22:26:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1MDEwNA=="}], "type": "inlineReview"}, {"oid": "1bae5ca642eab1bc5ab4f3d8466e400fd69f38ce", "url": "https://github.com/apple/servicetalk/commit/1bae5ca642eab1bc5ab4f3d8466e400fd69f38ce", "message": "update time source methods", "committedDate": "2020-12-16T00:51:37Z", "type": "commit"}]}