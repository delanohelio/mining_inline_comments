{"pr_number": 967, "pr_title": "Ensure `TcpConnector#connect` does not emit error after success", "pr_createdAt": "2020-03-13T21:45:48Z", "pr_url": "https://github.com/apple/servicetalk/pull/967", "timeline": [{"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c", "url": "https://github.com/apple/servicetalk/commit/ddf547d43170486fa7ef4ca4866ec92155f3328c", "message": "Ensure `TcpConnector#connect` does not emit error after success\n\n__Motivation__\n\n`TcpConnector#connect` eagerly terminates the `Single` when the channel is registered. It also terminates the `Single` with failure if connect fails.\nThis violates the contract of the `Subscriber` that there should only be a single termination signal.\n\n__Modification__\n\nAs we have to complete the returned `Single` with the channel as soon as the channel is registered to ensure we do not miss channel events and we also have to propagate connect failures, we can not abide by the `Single<Channel>` contract. Instead of returning `Single<Channel>` now returning `Single<Connection>` and do the translation of `Channel` -> `Connection` using a supplied `Function`.\n\n__Result__\n\n`TcpConnector#connect` abides by the `Subscriber` contract.", "committedDate": "2020-03-13T21:44:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5ODU5Ng==", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r392898596", "bodyText": "nit: is this really what happens ? It seems like it is not blocking and so not await.", "author": "normanmaurer", "createdAt": "2020-03-16T09:57:10Z", "path": "servicetalk-tcp-netty-internal/src/testFixtures/java/io/servicetalk/tcp/netty/internal/TcpClient.java", "diffHunk": "@@ -82,13 +83,24 @@ public TcpClient(TcpClientConfig config) {\n      */\n     public NettyConnection<Buffer, Buffer> connectBlocking(ExecutionContext executionContext, SocketAddress address)\n             throws ExecutionException, InterruptedException {\n-        return TcpConnector.connect(null, address, config, false, executionContext)\n-                .flatMap(channel -> DefaultNettyConnection.<Buffer, Buffer>initChannel(channel,\n+        return connect(executionContext, address).toFuture().get();\n+    }\n+\n+    /**\n+     * Connect and await for the connection.", "originalCommit": "ddf547d43170486fa7ef4ca4866ec92155f3328c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3NzkwNw==", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393377907", "bodyText": "Yep .. copy-pasta, lemme fix", "author": "NiteshKant", "createdAt": "2020-03-17T00:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5ODU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0OTc2Mw==", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393349763", "bodyText": "Consider verifying if connectFuture is already done before applying the listener, as we do in other places:\n\n  \n    \n      servicetalk/servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsServiceDiscoverer.java\n    \n    \n        Lines 370 to 376\n      in\n      e5f4c56\n    \n    \n    \n    \n\n        \n          \n           final Future<List<InetAddress>> addressFuture = resolver.resolveAll(inetHost); \n        \n\n        \n          \n           cancellableForQuery = () -> addressFuture.cancel(true); \n        \n\n        \n          \n           if (addressFuture.isDone()) { \n        \n\n        \n          \n               handleResolveDone0(addressFuture); \n        \n\n        \n          \n           } else { \n        \n\n        \n          \n               addressFuture.addListener((FutureListener<List<InetAddress>>) this::handleResolveDone0); \n        \n\n        \n          \n           }", "author": "idelpivnitskiy", "createdAt": "2020-03-16T22:41:31Z", "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -68,67 +76,74 @@ private TcpConnector() {\n      * @param config The {@link ReadOnlyTcpClientConfig} to use while connecting.\n      * @param autoRead if {@code true} auto read will be enabled for new {@link Channel}s.\n      * @param executionContext The {@link ExecutionContext} to use for the returned {@link NettyConnection}.\n+     * @param connectionFactory {@link Function} to create a {@link NettyConnection} asynchronously.\n+     * @param <C> Type of the created connection.\n      * @return A {@link Single} that completes with a new {@link Channel} when connected.\n      */\n-    public static Single<Channel> connect(@Nullable SocketAddress localAddress, Object resolvedRemoteAddress,\n-                                          ReadOnlyTcpClientConfig config, boolean autoRead,\n-                                          ExecutionContext executionContext) {\n+    public static <C extends ListenableAsyncCloseable> Single<C> connect(\n+            final @Nullable SocketAddress localAddress, final Object resolvedRemoteAddress,\n+            final ReadOnlyTcpClientConfig config, final boolean autoRead, final ExecutionContext executionContext,\n+            final Function<Channel, Single<? extends C>> connectionFactory) {\n         requireNonNull(resolvedRemoteAddress);\n         requireNonNull(config);\n         requireNonNull(executionContext);\n-        return new SubscribableSingle<Channel>() {\n+        return new SubscribableSingle<C>() {\n             @Override\n-            protected void handleSubscribe(final Subscriber<? super Channel> subscriber) {\n-                connectFutureToListener(localAddress, resolvedRemoteAddress, subscriber,\n-                        connect0(localAddress, resolvedRemoteAddress, config, autoRead, executionContext, subscriber));\n+            protected void handleSubscribe(final Subscriber<? super C> subscriber) {\n+                ConnectHandler<C> connectHandler = new ConnectHandler<>(subscriber, connectionFactory);\n+                try {\n+                    Future<?> connectFuture = connect0(localAddress, resolvedRemoteAddress, config, autoRead,\n+                            executionContext, connectHandler);\n+                    connectHandler.connectFuture(connectFuture);\n+                    connectFuture.addListener(f -> {", "originalCommit": "ddf547d43170486fa7ef4ca4866ec92155f3328c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3NzA4MA==", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393377080", "bodyText": "We do that when we are already on the eventloop and no ordering guarantees are required. In this case, adding a listener makes sure that the Single is completed on the eventloop.\n(This code was just refactored, so I would continue with the approach what was present before but if you feel we need to change this in general in all places, we can discuss/do that separately)", "author": "NiteshKant", "createdAt": "2020-03-17T00:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0OTc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MTgzNw==", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393351837", "bodyText": "SingleSource.Subscriber defines a parameter for onSuccess as @Nullable. Instead of throwing from here, should we propagate onError instead?", "author": "idelpivnitskiy", "createdAt": "2020-03-16T22:47:57Z", "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -209,4 +206,87 @@ private NoopNettyAddressResolverGroup() {\n             return NOOP_ADDRESS_RESOLVER;\n         }\n     }\n+\n+    private static final class ConnectHandler<C extends ListenableAsyncCloseable> implements Consumer<Channel> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(ConnectHandler.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<ConnectHandler> terminatedUpdater =\n+                newUpdater(ConnectHandler.class, \"terminated\");\n+\n+        private final DelayedCancellable futureCancellable = new DelayedCancellable();\n+        private final DelayedCancellable flatMapCancellable = new DelayedCancellable();\n+        private final Subscriber<? super C> target;\n+        private final Function<Channel, Single<? extends C>> connectionFactory;\n+\n+        private volatile int terminated;\n+\n+        ConnectHandler(final Subscriber<? super C> target,\n+                       final Function<Channel, Single<? extends C>> connectionFactory) {\n+            this.target = target;\n+            this.connectionFactory = connectionFactory;\n+            target.onSubscribe(() -> {\n+                try {\n+                    futureCancellable.cancel();\n+                } finally {\n+                    flatMapCancellable.cancel();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void accept(final Channel channel) {\n+            toSource(connectionFactory.apply(channel)\n+                    .subscribeShareContext())\n+                    .subscribe(new Subscriber<C>() {\n+                        @Override\n+                        public void onSubscribe(final Cancellable cancellable) {\n+                            flatMapCancellable.delayedCancellable(cancellable);\n+                        }\n+\n+                        @Override\n+                        public void onSuccess(final C connection) {\n+                            requireNonNull(connection);", "originalCommit": "ddf547d43170486fa7ef4ca4866ec92155f3328c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3NzcxNg==", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393377716", "bodyText": "Good point, the null-check is only required for when we want to call close() so instead of disallowing null, lemme guard the close.", "author": "NiteshKant", "createdAt": "2020-03-17T00:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MTgzNw=="}], "type": "inlineReview"}, {"oid": "c4f1cd98ba8a101b240047482564f7303c28b064", "url": "https://github.com/apple/servicetalk/commit/c4f1cd98ba8a101b240047482564f7303c28b064", "message": "Review comments", "committedDate": "2020-03-17T00:11:43Z", "type": "commit"}, {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e", "url": "https://github.com/apple/servicetalk/commit/e1ae0305f9655f24e37383e5ab65e73601a3b06e", "message": "Merge remote-tracking branch 'upstream/master' into connector-fix", "committedDate": "2020-03-17T00:12:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4MDE3OA==", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393380178", "bodyText": "Do we assume that downstream target Subscriber will handle null instead of a connection? I think it's easy to assume from the caller side that it's expected to receive non-null connection. Was suggesting to invoke target.onError instead of throwing from onSuccess.", "author": "idelpivnitskiy", "createdAt": "2020-03-17T00:20:38Z", "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -244,15 +244,16 @@ public void onSubscribe(final Cancellable cancellable) {\n                         }\n \n                         @Override\n-                        public void onSuccess(final C connection) {\n-                            requireNonNull(connection);\n+                        public void onSuccess(@Nullable final C connection) {\n                             if (terminatedUpdater.compareAndSet(ConnectHandler.this, 0, 1)) {\n                                 target.onSuccess(connection);", "originalCommit": "e1ae0305f9655f24e37383e5ab65e73601a3b06e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc5MjQyOA==", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393792428", "bodyText": "Do we assume that downstream target Subscriber will handle null instead of a connection?\n\n\nYes, in general in operators we pass-through what we get unless we use it.\n\n\nWas suggesting to invoke target.onError instead of throwing from onSuccess.\n\n\nI understood the suggestion but I am following the general pattern I mention above.", "author": "NiteshKant", "createdAt": "2020-03-17T16:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4MDE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzEzOQ==", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393507139", "bodyText": "nit: This logging message will read a bit strange and may be confusing if connection == null.", "author": "normanmaurer", "createdAt": "2020-03-17T08:18:56Z", "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -209,4 +206,88 @@ private NoopNettyAddressResolverGroup() {\n             return NOOP_ADDRESS_RESOLVER;\n         }\n     }\n+\n+    private static final class ConnectHandler<C extends ListenableAsyncCloseable> implements Consumer<Channel> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(ConnectHandler.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<ConnectHandler> terminatedUpdater =\n+                newUpdater(ConnectHandler.class, \"terminated\");\n+\n+        private final DelayedCancellable futureCancellable = new DelayedCancellable();\n+        private final DelayedCancellable flatMapCancellable = new DelayedCancellable();\n+        private final Subscriber<? super C> target;\n+        private final Function<Channel, Single<? extends C>> connectionFactory;\n+\n+        private volatile int terminated;\n+\n+        ConnectHandler(final Subscriber<? super C> target,\n+                       final Function<Channel, Single<? extends C>> connectionFactory) {\n+            this.target = target;\n+            this.connectionFactory = connectionFactory;\n+            target.onSubscribe(() -> {\n+                try {\n+                    futureCancellable.cancel();\n+                } finally {\n+                    flatMapCancellable.cancel();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void accept(final Channel channel) {\n+            toSource(connectionFactory.apply(channel)\n+                    .subscribeShareContext())\n+                    .subscribe(new Subscriber<C>() {\n+                        @Override\n+                        public void onSubscribe(final Cancellable cancellable) {\n+                            flatMapCancellable.delayedCancellable(cancellable);\n+                        }\n+\n+                        @Override\n+                        public void onSuccess(@Nullable final C connection) {\n+                            if (terminatedUpdater.compareAndSet(ConnectHandler.this, 0, 1)) {\n+                                target.onSuccess(connection);\n+                            } else {\n+                                LOGGER.info(\"Connection {} created for a channel: {} but connect failed previously. \" +\n+                                                \"Closing connection\",\n+                                        connection, channel);", "originalCommit": "e1ae0305f9655f24e37383e5ab65e73601a3b06e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc5NTkwMg==", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393795902", "bodyText": "mmm ya but as we do not expect the connection to be null and I want to add a log if we are closing the connection, I think it is OK to not add more conditional to handle null. I will change the level to debug though as there isn't anything a user is expected to do here.", "author": "NiteshKant", "createdAt": "2020-03-17T16:09:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzk5NA==", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393507994", "bodyText": "also nit.... All other log messages end with a ..", "author": "normanmaurer", "createdAt": "2020-03-17T08:20:46Z", "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -209,4 +206,88 @@ private NoopNettyAddressResolverGroup() {\n             return NOOP_ADDRESS_RESOLVER;\n         }\n     }\n+\n+    private static final class ConnectHandler<C extends ListenableAsyncCloseable> implements Consumer<Channel> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(ConnectHandler.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<ConnectHandler> terminatedUpdater =\n+                newUpdater(ConnectHandler.class, \"terminated\");\n+\n+        private final DelayedCancellable futureCancellable = new DelayedCancellable();\n+        private final DelayedCancellable flatMapCancellable = new DelayedCancellable();\n+        private final Subscriber<? super C> target;\n+        private final Function<Channel, Single<? extends C>> connectionFactory;\n+\n+        private volatile int terminated;\n+\n+        ConnectHandler(final Subscriber<? super C> target,\n+                       final Function<Channel, Single<? extends C>> connectionFactory) {\n+            this.target = target;\n+            this.connectionFactory = connectionFactory;\n+            target.onSubscribe(() -> {\n+                try {\n+                    futureCancellable.cancel();\n+                } finally {\n+                    flatMapCancellable.cancel();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void accept(final Channel channel) {\n+            toSource(connectionFactory.apply(channel)\n+                    .subscribeShareContext())\n+                    .subscribe(new Subscriber<C>() {\n+                        @Override\n+                        public void onSubscribe(final Cancellable cancellable) {\n+                            flatMapCancellable.delayedCancellable(cancellable);\n+                        }\n+\n+                        @Override\n+                        public void onSuccess(@Nullable final C connection) {\n+                            if (terminatedUpdater.compareAndSet(ConnectHandler.this, 0, 1)) {\n+                                target.onSuccess(connection);\n+                            } else {\n+                                LOGGER.info(\"Connection {} created for a channel: {} but connect failed previously. \" +\n+                                                \"Closing connection\",", "originalCommit": "e1ae0305f9655f24e37383e5ab65e73601a3b06e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "787ec3834c8bc12a33aa752d6a20e2e7ced92794", "url": "https://github.com/apple/servicetalk/commit/787ec3834c8bc12a33aa752d6a20e2e7ced92794", "message": "Review comments", "committedDate": "2020-03-17T16:11:07Z", "type": "commit"}]}