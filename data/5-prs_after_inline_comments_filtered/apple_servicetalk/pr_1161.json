{"pr_number": 1161, "pr_title": "Publisher#flatMapMerge queue not drained bug", "pr_createdAt": "2020-09-30T03:32:34Z", "pr_url": "https://github.com/apple/servicetalk/pull/1161", "timeline": [{"oid": "72ff7cbdc1e6d07194e6798d151d7e2358596eed", "url": "https://github.com/apple/servicetalk/commit/72ff7cbdc1e6d07194e6798d151d7e2358596eed", "message": "Publisher#flatMapMerge queue not drained bug\n\nMotivation:\nPublisher#flatMapMerge may not drain the queue if an item is enqueued\nand the item doesn't require demand. This may happen for example if the\nmapped subscriber exhausts its demand, and had signals previously\nqueued. This may lead to dead lock and lack of progress.\n\nModifications:\n- Modify tryEmitItem to only lock for item delivery. For other cases\nthat go through the queue use enqueueAndDrain which will enqueue,\nacquire the drain lock, and drain the queue.\n\nResults:\nNo more deadlock and smaller lock critical section in tryEmitItem for\nPublisher#flatMapMerge.", "committedDate": "2020-09-30T03:29:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY4MDE0OA==", "url": "https://github.com/apple/servicetalk/pull/1161#discussion_r497680148", "bodyText": "the issue was here if the item doesn't require demand we should force a drain as we can't rely upon more demand to trigger a domain. however I refactored this method a bit to reduce the critical area and make the drain less conditional (e.g. now we can just use enqueueAndDrain).", "author": "Scottmitch", "createdAt": "2020-09-30T17:24:49Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -304,33 +304,32 @@ private boolean tryDecrementPendingDemand() {\n         }\n \n         private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n-            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n-                boolean mappedSourcesCompleted = false;\n+            // We can skip the queue if the following conditions are meet:\n+            // 1. There is downstream requestN demand.\n+            // 2. The mapped subscriber doesn't have any signals already in the queue. We only need to preserve the\n+            //    ordering for each mapped source, and there is no \"overall\" ordering.\n+            // 3. We don't concurrently invoke the downstream subscriber. Concurrency control is provided by the\n+            //    emitting lock.\n+            final boolean needsDemand;\n+            if (subscriber.hasSignalsQueued() || ((needsDemand = needsDemand(item)) && !tryDecrementPendingDemand())) {\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                requestMoreFromUpstream(1);\n+            } else if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n                 try {\n-                    // We can skip the queue if the following conditions are meet:\n-                    // 1. There is downstream requestN demand.\n-                    // 2. The mapped subscriber doesn't have any signals already in the queue. We only need to preserve\n-                    //    the ordering for each mapped source, and there is no \"overall\" ordering.\n-                    // 3. We don't concurrently invoke the downstream subscriber. Concurrency control is provided by the\n-                    //    emitting lock.\n-                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n-                        subscriber.markSignalsQueued();\n-                        enqueueItem(item);", "originalCommit": "72ff7cbdc1e6d07194e6798d151d7e2358596eed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "801727b98cf3cecbe3b01f44be13b6acccec7ba4", "url": "https://github.com/apple/servicetalk/commit/801727b98cf3cecbe3b01f44be13b6acccec7ba4", "message": "add unit test", "committedDate": "2020-10-02T01:23:07Z", "type": "commit"}, {"oid": "da076901e90d991fe20c0950b7d48f26f62175f4", "url": "https://github.com/apple/servicetalk/commit/da076901e90d991fe20c0950b7d48f26f62175f4", "message": "fix checkstyle", "committedDate": "2020-10-02T01:52:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MDA2MA==", "url": "https://github.com/apple/servicetalk/pull/1161#discussion_r498980060", "bodyText": "debugging leftover? :)", "author": "NiteshKant", "createdAt": "2020-10-02T18:19:34Z", "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/PublisherFlatMapMergeTest.java", "diffHunk": "@@ -69,7 +69,7 @@\n \n public class PublisherFlatMapMergeTest {\n     private static final long TERMINAL_POLL_MS = 10;\n-    @Rule\n+    // @Rule", "originalCommit": "801727b98cf3cecbe3b01f44be13b6acccec7ba4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MTAyNw==", "url": "https://github.com/apple/servicetalk/pull/1161#discussion_r498981027", "bodyText": "YEES. \ud83d\udd25 \ud83c\udf96\ufe0f", "author": "Scottmitch", "createdAt": "2020-10-02T18:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MDA2MA=="}], "type": "inlineReview"}, {"oid": "837ec732209edf4d4d980d5f37be791caba389fd", "url": "https://github.com/apple/servicetalk/commit/837ec732209edf4d4d980d5f37be791caba389fd", "message": "restore test timeout", "committedDate": "2020-10-02T18:22:19Z", "type": "commit"}, {"oid": "c17642adbe8b5070d6370487a476d84d6a983d2f", "url": "https://github.com/apple/servicetalk/commit/c17642adbe8b5070d6370487a476d84d6a983d2f", "message": "review newlines before test", "committedDate": "2020-10-02T18:23:39Z", "type": "commit"}]}