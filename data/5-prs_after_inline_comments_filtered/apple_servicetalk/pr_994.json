{"pr_number": 994, "pr_title": "Introduce `HttpLoadBalancerFactory`", "pr_createdAt": "2020-04-02T23:00:35Z", "pr_url": "https://github.com/apple/servicetalk/pull/994", "timeline": [{"oid": "6c732bf84514a721cf0030d1ce0e8f789922a441", "url": "https://github.com/apple/servicetalk/commit/6c732bf84514a721cf0030d1ce0e8f789922a441", "message": "Introduce `HttpLoadBalancerFactory`\n\n__Motivation__\n\nToday `HttpClientBuilder` takes two separate implementations of `LoadBalancerFactory` as well as `Function` as a protocol binder. As `LoadBalancerFactory` is protocol neutral, it does make sense to have the protocol binding separate but having two separate entities makes the generic ugly and it is hard to understand what the parameters stand for.\n\n__Modification__\n\nIntroduce `HttpLoadBalancerFactory` that combines these two aspects and makes the usage easier.\nAdd a `DefaultHttpLoadBalancerFactory` to provide the default implementation using Round robin load balancer and in the future more load balancer implementations geared towards HTTP.\n\n__Result__\n\nEasier to understand interface for HTTP layer load balancing.", "committedDate": "2020-04-02T22:55:52Z", "type": "commit"}, {"oid": "b2b3a00745b0ff30aa527d3d3b5ec67dbe52a347", "url": "https://github.com/apple/servicetalk/commit/b2b3a00745b0ff30aa527d3d3b5ec67dbe52a347", "message": "Correctly implement exec strategy influencing", "committedDate": "2020-04-03T00:11:18Z", "type": "commit"}, {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1", "url": "https://github.com/apple/servicetalk/commit/1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1", "message": "Making checkstyle happy", "committedDate": "2020-04-03T00:21:14Z", "type": "commit"}, {"oid": "ee43fa56b3916bbfb4f07b4bd74d52f51a2b3404", "url": "https://github.com/apple/servicetalk/commit/ee43fa56b3916bbfb4f07b4bd74d52f51a2b3404", "message": "Making checkstyle happy - take 2", "committedDate": "2020-04-03T00:47:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NTg2Mw==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402675863", "bodyText": "consider killing the Config object and unrolling to just pass the fields directly from the builder:\nprivate final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory;\nprivate final HttpExecutionStrategyInfluencer strategyInfluencer;", "author": "Scottmitch", "createdAt": "2020-04-03T00:45:46Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final Config<ResolvedAddress> config;", "originalCommit": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NjE3Mw==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402676173", "bodyText": "nit: consider using // comments", "author": "Scottmitch", "createdAt": "2020-04-03T00:46:53Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final Config<ResolvedAddress> config;\n+\n+    private DefaultHttpLoadBalancerFactory(final Config<ResolvedAddress> config) {\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public LoadBalancer<? extends FilterableStreamingHttpLoadBalancedConnection> newLoadBalancer(\n+            final Publisher<? extends ServiceDiscovererEvent<ResolvedAddress>> eventPublisher,\n+            final ConnectionFactory<ResolvedAddress, ? extends FilterableStreamingHttpLoadBalancedConnection> cf) {\n+        return config.rawFactory.newLoadBalancer(eventPublisher, cf);\n+    }\n+\n+    @Override\n+    public FilterableStreamingHttpLoadBalancedConnection toLoadBalancedConnection(\n+            final FilterableStreamingHttpConnection connection) {\n+        return new AbstractFilterableStreamingHttpLoadBalancedConnection(connection) {\n+            @Override\n+            public float score() {\n+                return 1;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n+        return config.strategyInfluencer.influenceStrategy(strategy);\n+    }\n+\n+    /**\n+     * A builder for creating instances of {@link DefaultHttpLoadBalancerFactory}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution for the {@link HttpLoadBalancerFactory} built by\n+     * this builder.\n+     */\n+    public static final class Builder<ResolvedAddress> {\n+        private final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory;\n+        private final HttpExecutionStrategyInfluencer strategyInfluencer;\n+\n+        private Builder(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory,\n+                final HttpExecutionStrategyInfluencer strategyInfluencer) {\n+            this.rawFactory = rawFactory;\n+            this.strategyInfluencer = strategyInfluencer;\n+        }\n+\n+        /**\n+         * Builds a {@link DefaultHttpLoadBalancerFactory} using the properties configured on this builder.\n+         *\n+         * @return A {@link DefaultHttpLoadBalancerFactory}.\n+         */\n+        public DefaultHttpLoadBalancerFactory<ResolvedAddress> build() {\n+            return new DefaultHttpLoadBalancerFactory<>(new Config<>(rawFactory, strategyInfluencer));\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} instance using the default {@link LoadBalancer} implementation.\n+         *\n+         * @param <ResolvedAddress> The type of address after resolution for the {@link LoadBalancerFactory} built by\n+         * the returned builder.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> fromDefaults() {\n+            return from(newRoundRobinFactory());\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} using the passed {@link LoadBalancerFactory}.\n+         *\n+         * @param rawFactory {@link LoadBalancerFactory} to use for creating a {@link HttpLoadBalancerFactory} from the\n+         * returned {@link Builder}.\n+         * @param <ResolvedAddress> The type of address after resolution for a {@link HttpLoadBalancerFactory} created\n+         * by the returned {@link Builder}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> from(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory) {\n+            final HttpExecutionStrategyInfluencer strategyInfluencer;\n+            if (rawFactory instanceof HttpExecutionStrategyInfluencer) {\n+                strategyInfluencer = (HttpExecutionStrategyInfluencer) rawFactory;\n+            } else if(rawFactory instanceof RoundRobinLoadBalancerFactory) {\n+                strategyInfluencer = strategy -> strategy; // RoundRobinLoadBalancer is non-blocking.\n+            } else {\n+                /* user provided load balancer assumed to be blocking unless told otherwise */", "originalCommit": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NjM4OA==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402676388", "bodyText": "nit: consider clarifying, the only supported way to override the rawFactory to implement HttpExecutionStrategyInfluencer.", "author": "Scottmitch", "createdAt": "2020-04-03T00:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NjE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzAyNg==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402677026", "bodyText": "can you clarify why this needs to be exposed as public type and have a static factory method to create a new one?", "author": "Scottmitch", "createdAt": "2020-04-03T00:50:01Z", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -331,6 +329,25 @@ public Completable closeAsyncGracefully() {\n         return asyncCloseable.closeAsyncGracefully();\n     }\n \n+    /**\n+     * {@link LoadBalancerFactory} for {@link RoundRobinLoadBalancer}.\n+     *\n+     * @param <ResolvedAddress> The resolved address type.\n+     * @param <C> The type of connection.\n+     */\n+    public static final class RoundRobinLoadBalancerFactory<ResolvedAddress, C extends LoadBalancedConnection>", "originalCommit": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzMwMTkzMQ==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r403301931", "bodyText": "The complexity here is that we want to make sure a LoadBalancerFactory can specify that it does not block (implement HttpExecutionStrategyInfluencer) but LoadBalancerFactory is protocol agnostic hence it can not implement that.\nNow, users can specify RoundRobinLoadBalancer factory to the client without realizing that they need to wrap with HttpExecutionStrategyInfluencer. This is an attempt to identify that the passed LoadBalancerFactory is provided by ST and hence we can make some assumptions.\nAlternatively, we can say that if a user provides any LB factory (even if it is RRLB) we will offload and they should make sure to wrap, it seemed we can do better than that.", "author": "NiteshKant", "createdAt": "2020-04-03T20:18:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDQyOQ==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402670429", "bodyText": "This is a pkg-private abstract class that is used only in one place - DefaultHttpLoadBalancerFactory. Consider implementing it as a private static final class of DefaultHttpLoadBalancerFactory. Extend StreamingHttpConnectionFilter to avoid duplicating delegate logic.", "author": "idelpivnitskiy", "createdAt": "2020-04-03T00:26:21Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractFilterableStreamingHttpLoadBalancedConnection.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpConnectionContext;\n+import io.servicetalk.http.api.HttpEventKey;\n+import io.servicetalk.http.api.HttpExecutionContext;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpRequestMethod;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+abstract class AbstractFilterableStreamingHttpLoadBalancedConnection", "originalCommit": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3Mjc0NA==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402672744", "bodyText": "Unused import statement", "author": "idelpivnitskiy", "createdAt": "2020-04-03T00:34:22Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;", "originalCommit": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzU2Ng==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402673566", "bodyText": "Looking at #996, should it be Integer.MAX_VALUE?\nConcurrent PRs :) this returns float. Will keep this comment as a reminder to update.", "author": "idelpivnitskiy", "createdAt": "2020-04-03T00:37:39Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final Config<ResolvedAddress> config;\n+\n+    private DefaultHttpLoadBalancerFactory(final Config<ResolvedAddress> config) {\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public LoadBalancer<? extends FilterableStreamingHttpLoadBalancedConnection> newLoadBalancer(\n+            final Publisher<? extends ServiceDiscovererEvent<ResolvedAddress>> eventPublisher,\n+            final ConnectionFactory<ResolvedAddress, ? extends FilterableStreamingHttpLoadBalancedConnection> cf) {\n+        return config.rawFactory.newLoadBalancer(eventPublisher, cf);\n+    }\n+\n+    @Override\n+    public FilterableStreamingHttpLoadBalancedConnection toLoadBalancedConnection(\n+            final FilterableStreamingHttpConnection connection) {\n+        return new AbstractFilterableStreamingHttpLoadBalancedConnection(connection) {\n+            @Override\n+            public float score() {\n+                return 1;", "originalCommit": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzkwNQ==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402677905", "bodyText": "Should we provide any way for users to configure this value? For example, consider adding a method for the builder that will take Function<FilterableStreamingHttpConnection, FilterableStreamingHttpLoadBalancedConnection>.", "author": "idelpivnitskiy", "createdAt": "2020-04-03T00:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI5MDIzMw==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r403290233", "bodyText": "Looking at #996, should it be Integer.MAX_VALUE?\n\n\nYes! I will change it here or in the other PR depending on which gets merged first.\nHow scores are used/specified depends on the load balancer requirements. eg: the only load balancer we have ATM does not use the scores. I will avoid adding new APIs speculating usage. Once we have something that uses the scores, we can decide the APIs. Until then, one can create their own HttpLoadBalancerFactory implementation.", "author": "NiteshKant", "createdAt": "2020-04-03T20:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NTAzOQ==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402675039", "bodyText": "The LB provided by users may be implemented in the same way as RoundRobinLoadBalancerFactory: it may not have a dependency on http-api. Therefore, it won't be able to implement HttpExecutionStrategyInfluencer. Consider providing a builder method that can take HttpExecutionStrategyInfluencer.", "author": "idelpivnitskiy", "createdAt": "2020-04-03T00:42:50Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final Config<ResolvedAddress> config;\n+\n+    private DefaultHttpLoadBalancerFactory(final Config<ResolvedAddress> config) {\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public LoadBalancer<? extends FilterableStreamingHttpLoadBalancedConnection> newLoadBalancer(\n+            final Publisher<? extends ServiceDiscovererEvent<ResolvedAddress>> eventPublisher,\n+            final ConnectionFactory<ResolvedAddress, ? extends FilterableStreamingHttpLoadBalancedConnection> cf) {\n+        return config.rawFactory.newLoadBalancer(eventPublisher, cf);\n+    }\n+\n+    @Override\n+    public FilterableStreamingHttpLoadBalancedConnection toLoadBalancedConnection(\n+            final FilterableStreamingHttpConnection connection) {\n+        return new AbstractFilterableStreamingHttpLoadBalancedConnection(connection) {\n+            @Override\n+            public float score() {\n+                return 1;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n+        return config.strategyInfluencer.influenceStrategy(strategy);\n+    }\n+\n+    /**\n+     * A builder for creating instances of {@link DefaultHttpLoadBalancerFactory}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution for the {@link HttpLoadBalancerFactory} built by\n+     * this builder.\n+     */\n+    public static final class Builder<ResolvedAddress> {\n+        private final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory;\n+        private final HttpExecutionStrategyInfluencer strategyInfluencer;\n+\n+        private Builder(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory,\n+                final HttpExecutionStrategyInfluencer strategyInfluencer) {\n+            this.rawFactory = rawFactory;\n+            this.strategyInfluencer = strategyInfluencer;\n+        }\n+\n+        /**\n+         * Builds a {@link DefaultHttpLoadBalancerFactory} using the properties configured on this builder.\n+         *\n+         * @return A {@link DefaultHttpLoadBalancerFactory}.\n+         */\n+        public DefaultHttpLoadBalancerFactory<ResolvedAddress> build() {\n+            return new DefaultHttpLoadBalancerFactory<>(new Config<>(rawFactory, strategyInfluencer));\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} instance using the default {@link LoadBalancer} implementation.\n+         *\n+         * @param <ResolvedAddress> The type of address after resolution for the {@link LoadBalancerFactory} built by\n+         * the returned builder.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> fromDefaults() {\n+            return from(newRoundRobinFactory());\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} using the passed {@link LoadBalancerFactory}.\n+         *\n+         * @param rawFactory {@link LoadBalancerFactory} to use for creating a {@link HttpLoadBalancerFactory} from the\n+         * returned {@link Builder}.\n+         * @param <ResolvedAddress> The type of address after resolution for a {@link HttpLoadBalancerFactory} created\n+         * by the returned {@link Builder}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> from(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory) {\n+            final HttpExecutionStrategyInfluencer strategyInfluencer;\n+            if (rawFactory instanceof HttpExecutionStrategyInfluencer) {\n+                strategyInfluencer = (HttpExecutionStrategyInfluencer) rawFactory;\n+            } else if(rawFactory instanceof RoundRobinLoadBalancerFactory) {\n+                strategyInfluencer = strategy -> strategy; // RoundRobinLoadBalancer is non-blocking.\n+            } else {\n+                /* user provided load balancer assumed to be blocking unless told otherwise */\n+                strategyInfluencer = defaultStreamingInfluencer();", "originalCommit": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI5MzkyNw==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r403293927", "bodyText": "it may not have a dependency on http-api.\n\n\nIf someone wants to influence the strategy then the only way to do it is to have dependency on the http-api. If there is a generic load balancer implementation, it can be wrapped and the strategy influencer can be added.\npublic class NoInfluenceLBFactory<R, C extends LoadBalancedConnection> \n        implements LoadBalancerFactory<R, C>, HttpExecutionStrategyInfluencer {\n    \n    private final LoadBalancerFactory<R, C> delegate;\n\n    public NoInfluenceLBFactory(final LoadBalancerFactory<R, C> delegate) {\n        this.delegate = delegate;\n    }\n\n    @Override\n    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n        return strategy;\n    }\n\n    @Override\n    public LoadBalancer<? extends C> newLoadBalancer(\n            final Publisher<? extends ServiceDiscovererEvent<R>> eventPublisher, \n            final ConnectionFactory<R, ? extends C> connectionFactory) {\n        return delegate.newLoadBalancer(eventPublisher, connectionFactory);\n    }\n}\nDecoupling strategy influencing from actual code creates scopes for bugs as the implementations change.", "author": "NiteshKant", "createdAt": "2020-04-03T20:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NTAzOQ=="}], "type": "inlineReview"}, {"oid": "33dcb99c3fae038fec1498b8954eb02a6ac1e26c", "url": "https://github.com/apple/servicetalk/commit/33dcb99c3fae038fec1498b8954eb02a6ac1e26c", "message": "Merge remote-tracking branch 'upstream/master' into http-lb-factory", "committedDate": "2020-04-03T19:30:03Z", "type": "commit"}, {"oid": "b31bd22b03dab8a861cec3f31c1d74fab62cb506", "url": "https://github.com/apple/servicetalk/commit/b31bd22b03dab8a861cec3f31c1d74fab62cb506", "message": "Review comments", "committedDate": "2020-04-03T20:40:04Z", "type": "commit"}, {"oid": "835e25a8180ababde87ae5661ff1a93c6e9fcc18", "url": "https://github.com/apple/servicetalk/commit/835e25a8180ababde87ae5661ff1a93c6e9fcc18", "message": "Merge remote-tracking branch 'upstream/master' into http-lb-factory", "committedDate": "2020-04-03T20:56:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzMzMDQzNQ==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r403330435", "bodyText": "Consider extending StreamingHttpConnectionFilter to avoid duplicating delegate logic.", "author": "idelpivnitskiy", "createdAt": "2020-04-03T20:56:20Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpConnectionContext;\n+import io.servicetalk.http.api.HttpEventKey;\n+import io.servicetalk.http.api.HttpExecutionContext;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.http.api.HttpRequestMethod;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory;\n+    private final HttpExecutionStrategyInfluencer strategyInfluencer;\n+\n+    DefaultHttpLoadBalancerFactory(\n+            final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory,\n+            final HttpExecutionStrategyInfluencer strategyInfluencer) {\n+        this.rawFactory = rawFactory;\n+        this.strategyInfluencer = strategyInfluencer;\n+    }\n+\n+    @Override\n+    public LoadBalancer<? extends FilterableStreamingHttpLoadBalancedConnection> newLoadBalancer(\n+            final Publisher<? extends ServiceDiscovererEvent<ResolvedAddress>> eventPublisher,\n+            final ConnectionFactory<ResolvedAddress, ? extends FilterableStreamingHttpLoadBalancedConnection> cf) {\n+        return rawFactory.newLoadBalancer(eventPublisher, cf);\n+    }\n+\n+    @Override\n+    public FilterableStreamingHttpLoadBalancedConnection toLoadBalancedConnection(\n+            final FilterableStreamingHttpConnection connection) {\n+        return new DefaultFilterableStreamingHttpLoadBalancedConnection(connection);\n+    }\n+\n+    @Override\n+    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n+        return strategyInfluencer.influenceStrategy(strategy);\n+    }\n+\n+    /**\n+     * A builder for creating instances of {@link DefaultHttpLoadBalancerFactory}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution for the {@link HttpLoadBalancerFactory} built by\n+     * this builder.\n+     */\n+    public static final class Builder<ResolvedAddress> {\n+        private final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory;\n+        private final HttpExecutionStrategyInfluencer strategyInfluencer;\n+\n+        private Builder(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory,\n+                final HttpExecutionStrategyInfluencer strategyInfluencer) {\n+            this.rawFactory = rawFactory;\n+            this.strategyInfluencer = strategyInfluencer;\n+        }\n+\n+        /**\n+         * Builds a {@link DefaultHttpLoadBalancerFactory} using the properties configured on this builder.\n+         *\n+         * @return A {@link DefaultHttpLoadBalancerFactory}.\n+         */\n+        public DefaultHttpLoadBalancerFactory<ResolvedAddress> build() {\n+            return new DefaultHttpLoadBalancerFactory<>(rawFactory, strategyInfluencer);\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} instance using the default {@link LoadBalancer} implementation.\n+         *\n+         * @param <ResolvedAddress> The type of address after resolution for the {@link LoadBalancerFactory} built by\n+         * the returned builder.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> fromDefaults() {\n+            return from(newRoundRobinFactory());\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} using the passed {@link LoadBalancerFactory}.\n+         *\n+         * @param rawFactory {@link LoadBalancerFactory} to use for creating a {@link HttpLoadBalancerFactory} from the\n+         * returned {@link Builder}.\n+         * @param <ResolvedAddress> The type of address after resolution for a {@link HttpLoadBalancerFactory} created\n+         * by the returned {@link Builder}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> from(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory) {\n+            final HttpExecutionStrategyInfluencer strategyInfluencer;\n+            if (rawFactory instanceof HttpExecutionStrategyInfluencer) {\n+                strategyInfluencer = (HttpExecutionStrategyInfluencer) rawFactory;\n+            } else if (rawFactory instanceof RoundRobinLoadBalancerFactory) {\n+                strategyInfluencer = strategy -> strategy; // RoundRobinLoadBalancer is non-blocking.\n+            } else {\n+                // user provided load balancer assumed to be blocking unless it implements\n+                // HttpExecutionStrategyInfluencer\n+                strategyInfluencer = defaultStreamingInfluencer();\n+            }\n+            return new Builder<>(rawFactory, strategyInfluencer);\n+        }\n+    }\n+\n+    private static final class DefaultFilterableStreamingHttpLoadBalancedConnection\n+            implements FilterableStreamingHttpLoadBalancedConnection {", "originalCommit": "b31bd22b03dab8a861cec3f31c1d74fab62cb506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM2MjI0MQ==", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r403362241", "bodyText": "But it is not a connection filter!\nI expect this to be made public later as we do not have a delegating FilterableStreamingHttpLoadBalancedConnection implementation, which was my original intent but did not do it due to lack of usage.", "author": "NiteshKant", "createdAt": "2020-04-03T22:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzMzMDQzNQ=="}], "type": "inlineReview"}, {"oid": "6b94d524d337361eabe75e7cf820e30ca21cf0bf", "url": "https://github.com/apple/servicetalk/commit/6b94d524d337361eabe75e7cf820e30ca21cf0bf", "message": "Review comments", "committedDate": "2020-04-03T21:19:42Z", "type": "commit"}]}