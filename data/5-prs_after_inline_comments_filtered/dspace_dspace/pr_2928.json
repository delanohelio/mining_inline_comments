{"pr_number": 2928, "pr_title": "[DS-4036] Delete EPersons even if they are referenced", "pr_createdAt": "2020-08-13T12:25:24Z", "pr_url": "https://github.com/DSpace/DSpace/pull/2928", "timeline": [{"oid": "9a41e6fece0ee2d428060cc6dd42a00be44e2a17", "url": "https://github.com/DSpace/DSpace/commit/9a41e6fece0ee2d428060cc6dd42a00be44e2a17", "message": "[DS-4036] Delete EPersons even if they are referenced\n\nDSpace references EPersons in different database tables like the\nsubmitter of an item or like the EPerson that gets special rights\ngranted in the resourcepolicy table. This PR changes DSpace so it can\nhandle references that are set null instead of referencing an actual\nEPerson. This is important to be able to delete EPersons which is\ndemanded by several data protection laws like GDPR in the European\nUnion.", "committedDate": "2018-11-30T10:43:08Z", "type": "commit"}, {"oid": "a3d37c3b5b9946e89de0ed8b2cca7bdd3f38d3ff", "url": "https://github.com/DSpace/DSpace/commit/a3d37c3b5b9946e89de0ed8b2cca7bdd3f38d3ff", "message": "[DS-4036] Resolving changes requested enduring review.", "committedDate": "2018-11-30T12:04:50Z", "type": "commit"}, {"oid": "3890c11bf7ab28dc465f3a24dc6296b466b67fa4", "url": "https://github.com/DSpace/DSpace/commit/3890c11bf7ab28dc465f3a24dc6296b466b67fa4", "message": "[DS-4036] Resolving merge conflicts.", "committedDate": "2018-11-30T12:05:03Z", "type": "commit"}, {"oid": "435235abe48e8fba56ac0592de2b40d5d97522b8", "url": "https://github.com/DSpace/DSpace/commit/435235abe48e8fba56ac0592de2b40d5d97522b8", "message": "Merge remote-tracking branch 'upstream/main' into w2p-72472_Delete-eperson", "committedDate": "2020-08-11T08:30:04Z", "type": "commit"}, {"oid": "705b2b544f5106785e211a2999b4a6a32280f551", "url": "https://github.com/DSpace/DSpace/commit/705b2b544f5106785e211a2999b4a6a32280f551", "message": "Delete eperson when in workflow", "committedDate": "2020-08-13T08:25:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMTQ5Nw==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474211497", "bodyText": "Tiny thing...not sure I understand this rename of the i18n key.  It no longer matches the package/classname where it is used.  However, if you want it renamed, we could change it to something like itemRequest.helpdeskname as I see there are a number of other keys starting with itemRequest.*", "author": "tdonohue", "createdAt": "2020-08-20T19:13:23Z", "path": "dspace-api/src/main/java/org/dspace/app/requestitem/RequestItemHelpdeskStrategy.java", "diffHunk": "@@ -74,8 +74,7 @@ public RequestItemAuthor getHelpDeskPerson(Context context, String helpDeskEmail\n             return new RequestItemAuthor(helpdeskEPerson);\n         } else {\n             String helpdeskName = I18nUtil.getMessage(\n-                \"org.dspace.app.requestitem.RequestItemHelpdeskStrategy.helpdeskname\",\n-                context);\n+                \"org.dspace.app.requestitem.helpdeskname\", context);", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNTgzMw==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493915833", "bodyText": "This feedback hasn't been addressed yet.", "author": "tdonohue", "createdAt": "2020-09-23T21:50:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMTQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEzODg2Ng==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r494138866", "bodyText": "We actually don't have any idea why this was changed either, this PR started from #2229 which contained this change\nShall we simply revert it?", "author": "benbosman", "createdAt": "2020-09-24T08:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMTQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwOTE4NQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497009185", "bodyText": "Yes, reverting this change seems reasonable. I don't see a reason to rename this at this time.  If we find a reason at a later date, we can give it a better name then.", "author": "tdonohue", "createdAt": "2020-09-29T20:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMTQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNDA1Ng==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474214056", "bodyText": "I don't believe we have an admin.name configuration.  That said, I'm OK with adding one, but I'd recommend we name it mail.admin.name, as it looks (to me) like it will correspond to the mail.admin property.\nSimilarly, just above this, we could add a mail.helpdesk.name instead of storing that value in i18n.  That said, we should treat these similarly. Either put them both in Configuration or both in i18n.", "author": "tdonohue", "createdAt": "2020-08-20T19:17:57Z", "path": "dspace-api/src/main/java/org/dspace/app/requestitem/RequestItemMetadataStrategy.java", "diffHunk": "@@ -49,19 +51,37 @@ public RequestItemAuthor getRequestItemAuthor(Context context, Item item)\n                         fullname = nameVals.iterator().next().getValue();\n                     }\n                 }\n-\n                 if (StringUtils.isBlank(fullname)) {\n                     fullname = I18nUtil\n-                        .getMessage(\n-                            \"org.dspace.app.requestitem.RequestItemMetadataStrategy.unnamed\",\n-                            context);\n+                            .getMessage(\n+                                    \"org.dspace.app.requestitem.RequestItemMetadataStrategy.unnamed\",\n+                                    context);\n                 }\n-                RequestItemAuthor author = new RequestItemAuthor(\n-                    fullname, email);\n+                author = new RequestItemAuthor(fullname, email);\n                 return author;\n             }\n+        } else {\n+            // Uses the basic strategy to look for the original submitter\n+            author = super.getRequestItemAuthor(context, item);\n+            // Is the author or his email  null, so get the help desk or admin name and email\n+            if (null == author || null == author.getEmail()) {\n+                String email = null;\n+                String name = null;\n+                //First get help desk name and email\n+                email = DSpaceServicesFactory.getInstance()\n+                        .getConfigurationService().getProperty(\"mail.helpdesk\");\n+                name = I18nUtil.getMessage(\"org.dspace.app.requestitem.helpdeskname\", context);\n+                // If help desk mail is null get the mail and name of admin\n+                if (email == null) {\n+                    email = DSpaceServicesFactory.getInstance()\n+                            .getConfigurationService().getProperty(\"mail.admin\");\n+                    name = DSpaceServicesFactory.getInstance()\n+                            .getConfigurationService().getProperty(\"admin.name\");", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNTkyMQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493915921", "bodyText": "This feedback hasn't been addressed yet", "author": "tdonohue", "createdAt": "2020-09-23T21:51:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNDA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE0MTc2Nw==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r494141767", "bodyText": "This is another change from #2229, I'd prefer to use config here. We can modify it", "author": "benbosman", "createdAt": "2020-09-24T08:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNDA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyODAxNg==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497328016", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-09-30T08:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNDA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNDk5OA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474214998", "bodyText": "probably should be renamed deleteByEPerson() to match the other deleteBy* methods in this same DAO.  We should also take this opportunity to add Javadocs here & to the new findByEPerson() method above.", "author": "tdonohue", "createdAt": "2020-08-20T19:19:49Z", "path": "dspace-api/src/main/java/org/dspace/authorize/dao/ResourcePolicyDAO.java", "diffHunk": "@@ -66,6 +68,8 @@\n \n     public void deleteByDsoEPersonPolicies(Context context, DSpaceObject dso, EPerson ePerson) throws SQLException;\n \n+    public void deleteAllEPersonPolicies(Context context, EPerson ePerson) throws SQLException;", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjAyOA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916028", "bodyText": "This feedback hasn't been addressed yet", "author": "tdonohue", "createdAt": "2020-09-23T21:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNDk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE0OTkyNQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r494149925", "bodyText": "This is another change from #2229. We can modify it", "author": "benbosman", "createdAt": "2020-09-24T08:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNDk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNjI3NA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474216274", "bodyText": "Typo here. Should be \"Deletion\"", "author": "tdonohue", "createdAt": "2020-08-20T19:22:09Z", "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonCLITool.java", "diffHunk": "@@ -259,16 +262,27 @@ private static int cmdDelete(Context context, String[] argv) {\n         }\n \n         try {\n-            ePersonService.delete(context, eperson);\n-            context.complete();\n-            System.out.printf(\"Deleted EPerson %s\\n\", eperson.getID().toString());\n-        } catch (SQLException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (AuthorizeException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (IOException ex) {\n+            List<String> tableList = ePersonService.getDeleteConstraints(context, eperson);\n+            if (!tableList.isEmpty()) {\n+                System.out.printf(\"This EPerson with ID: %s is referring to this tables:%n \",\n+                        eperson.getID().toString());\n+                tableList.forEach((s) -> {\n+                    System.out.println(s);\n+                });\n+            }\n+            System.out.printf(\"Are you sure you want to delete this EPerson with ID: %s? (y or n): \",\n+                    eperson.getID().toString());\n+            BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n+            System.out.flush();\n+            String s = input.readLine();\n+            if (s != null && s.trim().toLowerCase().startsWith(\"y\")) {\n+                ePersonService.delete(context, eperson);\n+                context.complete();\n+                System.out.printf(\"%nDeleted EPerson with ID: %s\", eperson.getID().toString());\n+            } else {\n+                System.out.printf(\"%nAbort Deletetion of EPerson with ID: %s %n\", eperson.getID().toString());", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjI3NQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916275", "bodyText": "This feedback hasn't been addressed yet", "author": "tdonohue", "createdAt": "2020-09-23T21:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyODg1OQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497328859", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-09-30T08:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNjI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNzE5OQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474217199", "bodyText": "Should not call context.complete() here as the Context is being managed in the main method and is already calling complete() there.  We should never close/complete a Context that is passed into a method, as it can result in odd behaviors.", "author": "tdonohue", "createdAt": "2020-08-20T19:24:05Z", "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonCLITool.java", "diffHunk": "@@ -259,16 +262,27 @@ private static int cmdDelete(Context context, String[] argv) {\n         }\n \n         try {\n-            ePersonService.delete(context, eperson);\n-            context.complete();\n-            System.out.printf(\"Deleted EPerson %s\\n\", eperson.getID().toString());\n-        } catch (SQLException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (AuthorizeException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (IOException ex) {\n+            List<String> tableList = ePersonService.getDeleteConstraints(context, eperson);\n+            if (!tableList.isEmpty()) {\n+                System.out.printf(\"This EPerson with ID: %s is referring to this tables:%n \",\n+                        eperson.getID().toString());\n+                tableList.forEach((s) -> {\n+                    System.out.println(s);\n+                });\n+            }\n+            System.out.printf(\"Are you sure you want to delete this EPerson with ID: %s? (y or n): \",\n+                    eperson.getID().toString());\n+            BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n+            System.out.flush();\n+            String s = input.readLine();\n+            if (s != null && s.trim().toLowerCase().startsWith(\"y\")) {\n+                ePersonService.delete(context, eperson);\n+                context.complete();", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjIxNQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916215", "bodyText": "This feedback hasn't been addressed yet", "author": "tdonohue", "createdAt": "2020-09-23T21:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNzE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1MTQ1Mg==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r494151452", "bodyText": "We actually don't have any idea why this is used here either, this PR started from #2229 which contained this change\nWe'll remove it and verify whether it causes any issues", "author": "benbosman", "createdAt": "2020-09-24T08:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNzE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyOTIxMg==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497329212", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-09-30T08:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNzE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxODEwNQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474218105", "bodyText": "Reword to say something like \"The EPerson with ID: %s is referenced by the following database tables:%n\"   This aligns better with the EPersonDeletionException error message you wrote below.", "author": "tdonohue", "createdAt": "2020-08-20T19:25:49Z", "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonCLITool.java", "diffHunk": "@@ -259,16 +262,27 @@ private static int cmdDelete(Context context, String[] argv) {\n         }\n \n         try {\n-            ePersonService.delete(context, eperson);\n-            context.complete();\n-            System.out.printf(\"Deleted EPerson %s\\n\", eperson.getID().toString());\n-        } catch (SQLException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (AuthorizeException ex) {\n-            System.err.println(ex.getMessage());\n-            return 1;\n-        } catch (IOException ex) {\n+            List<String> tableList = ePersonService.getDeleteConstraints(context, eperson);\n+            if (!tableList.isEmpty()) {\n+                System.out.printf(\"This EPerson with ID: %s is referring to this tables:%n \",", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjEzNQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916135", "bodyText": "This feedback hasn't been addressed yet", "author": "tdonohue", "createdAt": "2020-09-23T21:51:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxODEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTM1NA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474219354", "bodyText": "I think this should say simply throw ex;  I'm not sure why we'd need to wrap an AuthorizeException in another AuthorizeException.", "author": "tdonohue", "createdAt": "2020-08-20T19:28:19Z", "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjM4Nw==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916387", "bodyText": "This feedback hasn't been addressed yet", "author": "tdonohue", "createdAt": "2020-09-23T21:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNDgyMQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497014821", "bodyText": "Again, this needs addressing.  We seem to be throwing away the entire stacktrace in this statement.  Shouldn't this be replaced with something simple like throw ex;?", "author": "tdonohue", "createdAt": "2020-09-29T20:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTgxMA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474219810", "bodyText": "This thrown error no longer has the details of the IOException.  We'd probably want a way to ensure those details are kept, as they may provide important info.", "author": "tdonohue", "createdAt": "2020-08-20T19:29:11Z", "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(new EPersonDeletionException());", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjQ3Mw==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916473", "bodyText": "This feedback hasn't been addressed yet", "author": "tdonohue", "createdAt": "2020-09-23T21:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyOTg2OA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497329868", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-09-30T08:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyMDM4OQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474220389", "bodyText": "I think this should be throw new IllegalStateException(e); so that it keeps the stacktrace info, etc.", "author": "tdonohue", "createdAt": "2020-08-20T19:30:16Z", "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(new EPersonDeletionException());\n+        } catch (EPersonDeletionException e) {\n+            throw new IllegalStateException(e.getMessage());", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1MzYxNg==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r494153616", "bodyText": "This was solved", "author": "benbosman", "createdAt": "2020-09-24T09:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyMDM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyMzk1NQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474223955", "bodyText": "The word \"it's\" in this message looks like it has special backtick character instead of a normal apostrophe.   It's likely not a big deal, but I wanted to point it out as we might want to fix it just in case it'd case issues.", "author": "tdonohue", "createdAt": "2020-08-20T19:34:40Z", "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(new EPersonDeletionException());\n+        } catch (EPersonDeletionException e) {\n+            throw new IllegalStateException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Deletes an EPerson. The argument cascade defines whether all references\n+     * on an EPerson should be deleted as well (by either deleting the\n+     * referencing object - e.g. WorkspaceItem, ResourcePolicy - or by setting\n+     * the foreign key null - e.g. archived Items). If cascade is set to false\n+     * and the EPerson is referenced somewhere, this leads to an\n+     * AuthorizeException. EPersons may be referenced by Items, ResourcePolicies\n+     * and workflow tasks.\n+     *\n+     * @param context DSpace context\n+     * @param ePerson The EPerson to delete.\n+     * @param cascade Whether to delete references on the EPerson (cascade =\n+     * true) or to abort the deletion (cascade = false) if the EPerson is\n+     * referenced within DSpace.\n+     *\n+     * @throws SQLException\n+     * @throws AuthorizeException\n+     * @throws IOException\n+     */\n+    public void delete(Context context, EPerson ePerson, boolean cascade)\n+            throws SQLException, AuthorizeException, IOException, EPersonDeletionException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to delete an EPerson\");\n+                    \"You must be an admin to delete an EPerson\");\n+        }\n+        Set<Group> workFlowGroups = getAllWorkFlowGroups(context, ePerson);\n+        for (Group group: workFlowGroups) {\n+            List<EPerson> ePeople = groupService.allMembers(context, group);\n+            if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n+                throw new IllegalStateException(\n+                        \"Refused to delete user \" + ePerson.getID() + \" because it\u2019s part of the group \" + group", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1NDEzOQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r494154139", "bodyText": "This was solved", "author": "benbosman", "createdAt": "2020-09-24T09:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyMzk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyODUwNg==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474228506", "bodyText": "I don't understand the logic of this code (maybe it needs inline comments here).  Why would we refuse to remove the last member of a group?  Are empty Groups not allowed here?  I have the same questions about the other removeMember() method in this same class.", "author": "tdonohue", "createdAt": "2020-08-20T19:39:46Z", "path": "dspace-api/src/main/java/org/dspace/eperson/GroupServiceImpl.java", "diffHunk": "@@ -144,7 +152,20 @@ public void addMember(Context context, Group groupParent, Group groupChild) thro\n     }\n \n     @Override\n-    public void removeMember(Context context, Group group, EPerson ePerson) {\n+    public void removeMember(Context context, Group group, EPerson ePerson) throws SQLException {\n+        List<CollectionRole> collectionRoles = collectionRoleService.findByGroup(context, group);\n+        if (!collectionRoles.isEmpty()) {\n+            List<PoolTask> poolTasks = poolTaskService.findByGroup(context, group);\n+            if (!poolTasks.isEmpty()) {\n+                List<EPerson> ePeople = allMembers(context, group);\n+                if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n+                    throw new IllegalStateException(\n+                            \"Refused to remove user \" + ePerson\n+                                    .getID() + \" from workflow group because the group \" + group\n+                                    .getID() + \" has no other members\");", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU5MzA1NQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r476593055", "bodyText": "Now that you've added more details to the description, I see that this method is likely covering the scenario where the EPerson is the only member of a Workflow group with items assigned.\nIf that's the case, we probably should note that in the exception.  So, update the exception to say something like \"Refused to remove user [id] from workflow group because the group [id] has tasks assigned and no other members\".\nThis same small update to the error message should also occur in the other removeMember() method below.", "author": "tdonohue", "createdAt": "2020-08-25T16:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyODUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMzMDUzMg==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497330532", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-09-30T08:24:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyODUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzNDc3Ng==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474234776", "bodyText": "I'm not entirely sure that we need to update the org.dspace.workflowbasic.* classes in this PR.  I thought these were all only used by the old, Traditional Workflow system.  Remember that old system no longer works with DSpace 7..only the Configurable Workflow works.  So, I think we can remove all these old classes, unless I'm missing something?  See https://jira.lyrasis.org/browse/DS-3041\nThat doesn't need to be part of this PR...but, if you agree, I can create a separate task/ticket to remove these old classes.", "author": "tdonohue", "createdAt": "2020-08-20T19:50:13Z", "path": "dspace-api/src/main/java/org/dspace/workflowbasic/BasicWorkflowServiceImpl.java", "diffHunk": "@@ -798,33 +798,37 @@ protected void notifyOfArchive(Context context, Item item, Collection coll)\n         try {\n             // Get submitter\n             EPerson ep = item.getSubmitter();\n-            // Get the Locale\n-            Locale supportedLocale = I18nUtil.getEPersonLocale(ep);\n-            Email email = Email.getEmail(I18nUtil.getEmailFilename(supportedLocale, \"submit_archive\"));\n \n-            // Get the item handle to email to user\n-            String handle = handleService.findHandle(context, item);\n-\n-            // Get title\n-            String title = item.getName();\n-            if (StringUtils.isBlank(title)) {\n-                try {\n-                    title = I18nUtil.getMessage(\"org.dspace.workflow.WorkflowManager.untitled\");\n-                } catch (MissingResourceException e) {\n-                    title = \"Untitled\";\n+            // send the notification to the submitter unless the submitter eperson has been deleted\n+            if (ep != null) {", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNjg4MQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493916881", "bodyText": "This feedback hasn't been addressed (or maybe just answered) yet.  Not sure what approach you think is better.", "author": "tdonohue", "createdAt": "2020-09-23T21:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzNDc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1NTkxMg==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r494155912", "bodyText": "Possibly #2229 was created prior to this decision, no idea.\nI'd suggest we just leave this, and create a separate ticket to remove the legacy workflow system", "author": "benbosman", "createdAt": "2020-09-24T09:03:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzNDc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMzUyNA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r494323524", "bodyText": "That seems fine to me. I'll mark this as resolved & we'll remove this code when the legacy workflow system is removed", "author": "tdonohue", "createdAt": "2020-09-24T13:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzNDc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0MzgzMA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r474243830", "bodyText": "@benbosman : The scenario above doesn't make total sense to me. I don't see why deletion of user B must fail until they are removed from both approval groups?   Why wouldn't a deletion just remove them from those approval groups (and let the approval proceed with other users in those groups)?\nDoes this have to do with whether a EPerson is the only member of a workflow role Group?\nSimply put, I think we need to think about this more:\n\nIf an EPerson is only one (of many) member of a workflow role Group, then it seems like deleting them should just remove them from the group.  I.e. no error should occur.\nIf an EPerson is the only member of a workflow role Group, then we have two options:\n\nWe delete both the EPerson & the Workflow Role Group (i.e. you are deleting that workflow step by deleting the only member of it).  We could warn an Admin here if needed by saying: \"By deleting this person, you will also remove these workflow steps of which they are the only member: \"\nWe refuse to delete the EPerson until they are removed from each of the Workflow Role Groups.  This is easier for us, but potentially more work for the DSpace Admin, who may have to go in and edit/delete the EPerson from a number of Groups one by one.", "author": "tdonohue", "createdAt": "2020-08-20T20:08:21Z", "path": "dspace-api/src/test/java/org/dspace/eperson/EPersonInWorkflowTest.java", "diffHunk": "@@ -0,0 +1,1477 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.eperson;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.AbstractIntegrationTestWithDatabase;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.workflow.WorkflowItemService;\n+import org.dspace.workflow.WorkflowService;\n+import org.dspace.workflow.factory.WorkflowServiceFactory;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.state.Workflow;\n+import org.dspace.xmlworkflow.storedcomponents.CollectionRole;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\n+import org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.XmlWorkflowItemService;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class EPersonInWorkflowTest extends AbstractIntegrationTestWithDatabase {\n+\n+    private final String REVIEW_STEP = \"reviewstep\";\n+    private final String CLAIM_ACTION = \"claimaction\";\n+    private final String REVIEW_ACTION = \"reviewaction\";\n+    private final String REVIEW_ROLE = \"reviewer\";\n+    private final String EDIT_STEP = \"editstep\";\n+    private final String EDIT_ACTION = \"editaction\";\n+    private final String FINAL_EDIT_ROLE = \"finaleditor\";\n+    private final String FINAL_EDIT_STEP = \"finaleditstep\";\n+    private final String FINAL_EDIT_ACTION = \"finaleditaction\";\n+    private final String EDIT_ROLE = \"editor\";\n+    protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n+    protected GroupService groupService = EPersonServiceFactory.getInstance().getGroupService();\n+    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected WorkflowItemService workflowItemService = WorkflowServiceFactory.getInstance().getWorkflowItemService();\n+    protected XmlWorkflowItemService xmlWorkflowItemService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                       .getXmlWorkflowItemService();\n+    protected WorkflowService workflowService = WorkflowServiceFactory.getInstance().getWorkflowService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                               .getWorkspaceItemService();\n+    protected ClaimedTaskService claimedTaskService = XmlWorkflowServiceFactory.getInstance().getClaimedTaskService();\n+    protected PoolTaskService poolTaskService = XmlWorkflowServiceFactory.getInstance().getPoolTaskService();\n+\n+    protected XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory.getInstance().getXmlWorkflowService();\n+    protected CollectionRoleService collectionRoleService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                     .getCollectionRoleService();\n+\n+\n+    private EPerson workflowUserA;\n+    private EPerson workflowUserB;\n+    private EPerson workflowUserC;\n+    private EPerson workflowUserD;\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(EPersonInWorkflowTest.class);\n+\n+    /**\n+     * This method will be run before every test as per @Before. It will\n+     * initialize resources required for the tests.\n+     *\n+     * Other methods can be annotated with @Before here or in subclasses but no\n+     * execution order is guaranteed\n+     */\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        workflowUserA = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserA@example.org\").build();\n+        workflowUserB = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserB@example.org\").build();\n+        workflowUserC = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserC@example.org\").build();\n+        workflowUserD = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserD@example.org\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+\n+    /**\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - approve it by user B\n+     * - verify that the item moved to step 2\n+     * - Claim it by user C\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 3\n+     * - approve it by user C\n+     * - verify that the item is archived without any actions apart from removing user B\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - delete user B\n+     * - verify the delete succeeds", "originalCommit": "705b2b544f5106785e211a2999b4a6a32280f551", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU5NjQ0OA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r476596448", "bodyText": "I now realize (after you added more details on the new \"rules\" here to the PR description) that my above comment is a misunderstanding of this test code.  I had previously (wrongly) assumed this test was verifying that \"no workflow group can be empty\".\nBut, now I see that this test is likely verifying that the user cannot be removed if they are the only member of a Workflow Group that has items assigned.\nI think this PR would be much easier to review if these tests all documented the scenario they are trying to tests.  So, while the list of checks is useful here, it'd be nice to summarize them at the top by saying something like \"This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has tasks currently assigned to it.\"\nSo, please disregard my prior request/comment..the only action here is to add a summary comment at the top of each test to summarize the scenario you are testing for.", "author": "tdonohue", "createdAt": "2020-08-25T16:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0MzgzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkxNzk5NQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r493917995", "bodyText": "Most of this prior feedback can be ignored, except as noted, it'd be useful to update the comments above these tests to simply summarize the scenario that each test is attempting to verify.  The detailed list of steps is sometimes confusing to follow.  So, I think this test could say something like: This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has tasks currently assigned to it.\nThe same is true for all tests in this class...it's sometimes hard to follow exactly why they are performing the steps they are performing. So, a simple summary sentence would help describe the scenario much more clearly.", "author": "tdonohue", "createdAt": "2020-09-23T21:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0MzgzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE1NzI3Ng==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r494157276", "bodyText": "AFAIK this has already been done as well", "author": "benbosman", "createdAt": "2020-09-24T09:06:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0MzgzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMzEzNA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r494323134", "bodyText": "@benbosman : I'm not seeing the requested changes to this EPersonInWorkflowTest class methods.", "author": "tdonohue", "createdAt": "2020-09-24T13:37:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0MzgzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4NjYxNA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497086614", "bodyText": "I'd still appreciate simple summary notes at the beginning of each of these tests.  It's very hard to follow these tests & the detailed \"This test will perform the following checks:\" does not always make it clear which scenario is being tested for.\nAs I noted previously, I think this test method can be easily summarized as \"This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has tasks currently assigned to it.\"  However, I'm not sure that's accurate, as it also seems like it might be testing that a user with claimed tasks cannot be deleted?\nI think these tests would be a lot easier to understand if the JavaDocs just had a brief summary of the scenarios tested, and you moved the step-by-step summary into inline comments.  Otherwise, I'm stuck reading a line and then having to scroll up to the JavaDocs to see which step it might be referencing, then reading the next line, and scroll back up, etc.\nIt's also extremely difficult determining the differences between  testDeleteUserWhenOnlyUserInGroup1, testDeleteUserWhenOnlyUserInGroup2, ``testDeleteUserWhenOnlyUserInGroup3`...all the way to 7.  Again, I think it'd be easier to understand if the JavaDocs had a simple summary of what makes this tests unique, and you move more of the details to inline (to describe what each line is doing).\nI realize this would take work, but without these changes, this test class is very hard to review.  I've taken 30mins to just check the first method looks correct (it does). But, I don't know how it differs from all the rest yet.  (And, at a glance many of these test methods look like they run the same check over and over again...for instance, each one keeps checking that User B cannot be deleted if they are the last member of the first step group... it seems like we only need to make that check once)", "author": "tdonohue", "createdAt": "2020-09-29T22:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0MzgzMA=="}], "type": "inlineReview"}, {"oid": "e25cea2bb000a2118eccd250f61a60386f6c3f1b", "url": "https://github.com/DSpace/DSpace/commit/e25cea2bb000a2118eccd250f61a60386f6c3f1b", "message": "72750: Finalize Delete eperson: workflow", "committedDate": "2020-08-27T13:00:11Z", "type": "commit"}, {"oid": "548e0355eff403ae0d729759a75929fe2195d0c1", "url": "https://github.com/DSpace/DSpace/commit/548e0355eff403ae0d729759a75929fe2195d0c1", "message": "72774: Delete eperson: workspace", "committedDate": "2020-09-01T09:41:17Z", "type": "commit"}, {"oid": "81f58b473f56d92e53f36393efb0531d321dcbff", "url": "https://github.com/DSpace/DSpace/commit/81f58b473f56d92e53f36393efb0531d321dcbff", "message": "Merge pull request #32 from atmire/w2p-72774_Delete-eperson-workspace\n\n72774: Delete eperson: workspace", "committedDate": "2020-09-16T10:44:15Z", "type": "commit"}, {"oid": "3977fe72c815083d7f821a2fc3aa19f55ed582c1", "url": "https://github.com/DSpace/DSpace/commit/3977fe72c815083d7f821a2fc3aa19f55ed582c1", "message": "Merge remote-tracking branch 'upstream/main' into w2p-72472_Delete-eperson", "committedDate": "2020-09-17T12:03:44Z", "type": "commit"}, {"oid": "f71202c8c33475888e2ef10bbf22881637bcc592", "url": "https://github.com/DSpace/DSpace/commit/f71202c8c33475888e2ef10bbf22881637bcc592", "message": "Fix to tests post merge", "committedDate": "2020-09-17T12:03:50Z", "type": "commit"}, {"oid": "3b563e4906100a1b7632269043df46a97a3e237b", "url": "https://github.com/DSpace/DSpace/commit/3b563e4906100a1b7632269043df46a97a3e237b", "message": "73422: Delete eperson: community feedback", "committedDate": "2020-09-28T15:31:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxMDM4NA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497010384", "bodyText": "Please add JavaDocs to describe this new method so that it's clear what retrieveAllItems does when true or false.\nUPDATE: I realized you do describe this in ItemService.findBySubmitter().  But, I'd recommend copying the same JavaDocs over here as well, just to document this method.", "author": "tdonohue", "createdAt": "2020-09-29T20:02:32Z", "path": "dspace-api/src/main/java/org/dspace/content/dao/ItemDAO.java", "diffHunk": "@@ -47,6 +47,9 @@\n \n     public Iterator<Item> findBySubmitter(Context context, EPerson eperson) throws SQLException;\n \n+    public Iterator<Item> findBySubmitter(Context context, EPerson eperson, boolean retrieveAllItems)", "originalCommit": "3b563e4906100a1b7632269043df46a97a3e237b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxMDc1MQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497010751", "bodyText": "JavaDocs please.  Also, please add them to the new find() method in this same class", "author": "tdonohue", "createdAt": "2020-09-29T20:03:18Z", "path": "dspace-api/src/main/java/org/dspace/authorize/service/ResourcePolicyService.java", "diffHunk": "@@ -72,6 +74,8 @@ public void removeDsoGroupPolicies(Context context, DSpaceObject dso, Group grou\n     public void removeDsoEPersonPolicies(Context context, DSpaceObject dso, EPerson ePerson)\n         throws SQLException, AuthorizeException;\n \n+    public void removeAllEPersonPolicies(Context context, EPerson ePerson) throws SQLException, AuthorizeException;", "originalCommit": "3b563e4906100a1b7632269043df46a97a3e237b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxMTUwNw==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497011507", "bodyText": "We likely shouldn't be building the Query object until after this if statement.  It seems odd to build the Query only to throw it out if retrieveAllItems=false", "author": "tdonohue", "createdAt": "2020-09-29T20:04:48Z", "path": "dspace-api/src/main/java/org/dspace/content/dao/impl/ItemDAOImpl.java", "diffHunk": "@@ -108,6 +108,17 @@ protected ItemDAOImpl() {\n         return iterate(query);\n     }\n \n+    @Override\n+    public Iterator<Item> findBySubmitter(Context context, EPerson eperson, boolean retrieveAllItems)\n+        throws SQLException {\n+        Query query = createQuery(context, \"FROM Item WHERE submitter= :submitter\");\n+        if (!retrieveAllItems) {", "originalCommit": "3b563e4906100a1b7632269043df46a97a3e237b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxMzEyNw==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497013127", "bodyText": "Not sure I understand this description.  If retrieveAllItems=true, does that mean you are retrieving both archived and unarchived items?  I'm assuming so.  If that's the case, we could reword this to say something like:\nIf true, all items (regardless of status) are returned. If false, only archived items will be returned.", "author": "tdonohue", "createdAt": "2020-09-29T20:07:56Z", "path": "dspace-api/src/main/java/org/dspace/content/service/ItemService.java", "diffHunk": "@@ -113,6 +113,19 @@\n     public Iterator<Item> findBySubmitter(Context context, EPerson eperson)\n         throws SQLException;\n \n+    /**\n+     * Find all the items by a given submitter. The order is\n+     * indeterminate. All items are included.\n+     *\n+     * @param context DSpace context object\n+     * @param eperson the submitter\n+     * @param retrieveAllItems flag to determine if only archive should be returned", "originalCommit": "3b563e4906100a1b7632269043df46a97a3e237b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAxNTgxNg==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r497015816", "bodyText": "I'd recommend we cleanup this error message (as it's a bit inaccurate...the problem is that this person is the only member of the group).  It likely should say:\n\"Refused to delete user \" + ePerson.getID() + \" because it the only member of the group \" + group.getID() + \". Delete the group first if you want to remove this user.\"", "author": "tdonohue", "createdAt": "2020-09-29T20:13:16Z", "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex.getMessage());\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(ex);\n+        } catch (EPersonDeletionException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Deletes an EPerson. The argument cascade defines whether all references\n+     * on an EPerson should be deleted as well (by either deleting the\n+     * referencing object - e.g. WorkspaceItem, ResourcePolicy - or by setting\n+     * the foreign key null - e.g. archived Items). If cascade is set to false\n+     * and the EPerson is referenced somewhere, this leads to an\n+     * AuthorizeException. EPersons may be referenced by Items, ResourcePolicies\n+     * and workflow tasks.\n+     *\n+     * @param context DSpace context\n+     * @param ePerson The EPerson to delete.\n+     * @param cascade Whether to delete references on the EPerson (cascade =\n+     * true) or to abort the deletion (cascade = false) if the EPerson is\n+     * referenced within DSpace.\n+     *\n+     * @throws SQLException\n+     * @throws AuthorizeException\n+     * @throws IOException\n+     */\n+    public void delete(Context context, EPerson ePerson, boolean cascade)\n+            throws SQLException, AuthorizeException, IOException, EPersonDeletionException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to delete an EPerson\");\n+                    \"You must be an admin to delete an EPerson\");\n+        }\n+        Set<Group> workFlowGroups = getAllWorkFlowGroups(context, ePerson);\n+        for (Group group: workFlowGroups) {\n+            List<EPerson> ePeople = groupService.allMembers(context, group);\n+            if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n+                throw new IllegalStateException(\n+                        \"Refused to delete user \" + ePerson.getID() + \" because it is part of the group \" + group", "originalCommit": "3b563e4906100a1b7632269043df46a97a3e237b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9b169afd3544b31cec4298bb49d6459ac876519d", "url": "https://github.com/DSpace/DSpace/commit/9b169afd3544b31cec4298bb49d6459ac876519d", "message": "73783: Delete eperson: community feedback part 2", "committedDate": "2020-10-01T08:48:46Z", "type": "commit"}, {"oid": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4", "url": "https://github.com/DSpace/DSpace/commit/d5e28e8a7c5d207bba920193415dcc10c1caf0c4", "message": "Merge remote-tracking branch 'upstream/main' into w2p-72472_Delete-eperson", "committedDate": "2020-10-01T08:49:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyOTE4NQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r498529185", "bodyText": "How does this differ from testDeleteUserWhenOnlyUserInGroup1()?  I'm not seeing clear differences in why we need a second test here & the description doesn't describe any differences...both methods are described identically as:  This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has tasks currently assigned to it. This test also verifies that after user has been removed from the workflow group and the task has been passed, the EPerson can be removed.\nIt's very hard to tell the differences between these methods, and (to me) it looks like we are running some of the same tests as in  testDeleteUserWhenOnlyUserInGroup1().  Duplicative tests are not really necessary, as they just take up more time (and will cause this overall Test class to take longer to complete/pass).  It's possible I'm misunderstanding the purpose of these test methods...but the purpose is just not clear to me as a reviewer, so I'm finding these test methods very difficult to review.\nThis same comment applies to all the other testDeleteUserWhenOnlyUserInGroup() tests below (numbered 2-7).  They all have had the exact same summary added to them, & the code is similar but not exactly the same.  So, I'd like to understand why they are all needed. Are there different scenarios here that you are trying to test are not causing a different behavior?  If so, we need to describe those different scenarios better in the comments, so that it's easier for reviewers to understand what they are attempting to test for.", "author": "tdonohue", "createdAt": "2020-10-01T21:45:56Z", "path": "dspace-api/src/test/java/org/dspace/eperson/EPersonInWorkflowTest.java", "diffHunk": "@@ -0,0 +1,1498 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.eperson;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.AbstractIntegrationTestWithDatabase;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.workflow.WorkflowItemService;\n+import org.dspace.workflow.WorkflowService;\n+import org.dspace.workflow.factory.WorkflowServiceFactory;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.state.Workflow;\n+import org.dspace.xmlworkflow.storedcomponents.CollectionRole;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\n+import org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.XmlWorkflowItemService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class EPersonInWorkflowTest extends AbstractIntegrationTestWithDatabase {\n+\n+    private final String REVIEW_STEP = \"reviewstep\";\n+    private final String CLAIM_ACTION = \"claimaction\";\n+    private final String REVIEW_ACTION = \"reviewaction\";\n+    private final String REVIEW_ROLE = \"reviewer\";\n+    private final String EDIT_STEP = \"editstep\";\n+    private final String EDIT_ACTION = \"editaction\";\n+    private final String FINAL_EDIT_ROLE = \"finaleditor\";\n+    private final String FINAL_EDIT_STEP = \"finaleditstep\";\n+    private final String FINAL_EDIT_ACTION = \"finaleditaction\";\n+    private final String EDIT_ROLE = \"editor\";\n+    protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n+    protected GroupService groupService = EPersonServiceFactory.getInstance().getGroupService();\n+    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected WorkflowItemService workflowItemService = WorkflowServiceFactory.getInstance().getWorkflowItemService();\n+    protected XmlWorkflowItemService xmlWorkflowItemService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                       .getXmlWorkflowItemService();\n+    protected WorkflowService workflowService = WorkflowServiceFactory.getInstance().getWorkflowService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                               .getWorkspaceItemService();\n+    protected ClaimedTaskService claimedTaskService = XmlWorkflowServiceFactory.getInstance().getClaimedTaskService();\n+    protected PoolTaskService poolTaskService = XmlWorkflowServiceFactory.getInstance().getPoolTaskService();\n+\n+    protected XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory.getInstance().getXmlWorkflowService();\n+    protected CollectionRoleService collectionRoleService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                     .getCollectionRoleService();\n+\n+\n+    private EPerson workflowUserA;\n+    private EPerson workflowUserB;\n+    private EPerson workflowUserC;\n+    private EPerson workflowUserD;\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(EPersonInWorkflowTest.class);\n+\n+    /**\n+     * This method will be run before every test as per @Before. It will\n+     * initialize resources required for the tests.\n+     *\n+     * Other methods can be annotated with @Before here or in subclasses but no\n+     * execution order is guaranteed\n+     */\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        workflowUserA = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserA@example.org\").build();\n+        workflowUserB = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserB@example.org\").build();\n+        workflowUserC = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserC@example.org\").build();\n+        workflowUserD = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserD@example.org\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - claim it by user B\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - verify that the removal is refused due to B being the last member in the workflow group and the group having\n+     * a claimed item\n+     * - approve it by user B and let it move to step 2\n+     * - remove user B from step 3\n+     * - approve it by user C\n+     * - verify that the item is archived without any actions apart from removing user B\n+     * - delete user B\n+     * - verify the delete succeeds\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup1() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, false);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, FINAL_EDIT_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, true);\n+\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - verify that the removal is refused due to B being the last member in the workflow group and the group having a\n+     * pool task\n+     * - approve it by user B and let it move to step 2\n+     * - remove user B from step 3\n+     * - delete user B\n+     * - verify the delete succeeds\n+     * - Approve it by user C\n+     * - verify that the item is archived without any actions apart from the approving in step 2\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup2() throws Exception {", "originalCommit": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMzY4NQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r498533685", "bodyText": "The same questions above apply to these methods.  I'm finding it hard to determine the differences between testDeleteUserAfterReplacingUser2() and testDeleteUserAfterReplacingUser1().  I can see the descriptions are identical & the setup is identical.  The steps seem like they are very similar but in a slightly different order.  And, why does this test need to verify that the Item can be archived after approvals occur? It seems like it that's beyond the scope of testing whether User B can be deleted after another user is added?\nSo, again, this is confusing to me to review as I'm not understanding what this test is attempting to test for that is different from the prior test.  It also seems like these tests are doing more than they need to, as I don't think they need to complete the entire workflow process (unless I'm misunderstanding the goals of these tests)\nThis same comment applies to the other tests named testDeleteUserAfterReplacingUser*() as they are all quite similar in nature.", "author": "tdonohue", "createdAt": "2020-10-01T21:58:25Z", "path": "dspace-api/src/test/java/org/dspace/eperson/EPersonInWorkflowTest.java", "diffHunk": "@@ -0,0 +1,1498 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.eperson;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.AbstractIntegrationTestWithDatabase;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.workflow.WorkflowItemService;\n+import org.dspace.workflow.WorkflowService;\n+import org.dspace.workflow.factory.WorkflowServiceFactory;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.state.Workflow;\n+import org.dspace.xmlworkflow.storedcomponents.CollectionRole;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\n+import org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.XmlWorkflowItemService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class EPersonInWorkflowTest extends AbstractIntegrationTestWithDatabase {\n+\n+    private final String REVIEW_STEP = \"reviewstep\";\n+    private final String CLAIM_ACTION = \"claimaction\";\n+    private final String REVIEW_ACTION = \"reviewaction\";\n+    private final String REVIEW_ROLE = \"reviewer\";\n+    private final String EDIT_STEP = \"editstep\";\n+    private final String EDIT_ACTION = \"editaction\";\n+    private final String FINAL_EDIT_ROLE = \"finaleditor\";\n+    private final String FINAL_EDIT_STEP = \"finaleditstep\";\n+    private final String FINAL_EDIT_ACTION = \"finaleditaction\";\n+    private final String EDIT_ROLE = \"editor\";\n+    protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n+    protected GroupService groupService = EPersonServiceFactory.getInstance().getGroupService();\n+    protected CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected WorkflowItemService workflowItemService = WorkflowServiceFactory.getInstance().getWorkflowItemService();\n+    protected XmlWorkflowItemService xmlWorkflowItemService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                       .getXmlWorkflowItemService();\n+    protected WorkflowService workflowService = WorkflowServiceFactory.getInstance().getWorkflowService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                               .getWorkspaceItemService();\n+    protected ClaimedTaskService claimedTaskService = XmlWorkflowServiceFactory.getInstance().getClaimedTaskService();\n+    protected PoolTaskService poolTaskService = XmlWorkflowServiceFactory.getInstance().getPoolTaskService();\n+\n+    protected XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory.getInstance().getXmlWorkflowService();\n+    protected CollectionRoleService collectionRoleService = XmlWorkflowServiceFactory.getInstance()\n+                                                                                     .getCollectionRoleService();\n+\n+\n+    private EPerson workflowUserA;\n+    private EPerson workflowUserB;\n+    private EPerson workflowUserC;\n+    private EPerson workflowUserD;\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(EPersonInWorkflowTest.class);\n+\n+    /**\n+     * This method will be run before every test as per @Before. It will\n+     * initialize resources required for the tests.\n+     *\n+     * Other methods can be annotated with @Before here or in subclasses but no\n+     * execution order is guaranteed\n+     */\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        workflowUserA = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserA@example.org\").build();\n+        workflowUserB = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserB@example.org\").build();\n+        workflowUserC = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserC@example.org\").build();\n+        workflowUserD = EPersonBuilder.createEPerson(context).withEmail(\"workflowUserD@example.org\").build();\n+\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - claim it by user B\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - verify that the removal is refused due to B being the last member in the workflow group and the group having\n+     * a claimed item\n+     * - approve it by user B and let it move to step 2\n+     * - remove user B from step 3\n+     * - approve it by user C\n+     * - verify that the item is archived without any actions apart from removing user B\n+     * - delete user B\n+     * - verify the delete succeeds\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup1() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, false);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, FINAL_EDIT_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, true);\n+\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - verify that the removal is refused due to B being the last member in the workflow group and the group having a\n+     * pool task\n+     * - approve it by user B and let it move to step 2\n+     * - remove user B from step 3\n+     * - delete user B\n+     * - verify the delete succeeds\n+     * - Approve it by user C\n+     * - verify that the item is archived without any actions apart from the approving in step 2\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup2() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, false);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, \"finaleditor\", true);\n+\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - delete user C\n+     * - verify the delete is refused\n+     * - remove user C from step 2\n+     * - delete user C\n+     * - verify the delete succeeds\n+     * - Approve it by user B\n+     * - verify that the item moved to step 3 without any actions apart from the approving in step 1\n+     * - Approve it by user B\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup3() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        assertDeletionOfEperson(workflowUserC, false);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserC, collection, EDIT_ROLE, true);\n+\n+        assertDeletionOfEperson(workflowUserC, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP,\n+                              CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP,\n+                              FINAL_EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - approve it by user B, and let it move to step 2\n+     * - approve it by user C, and let it move to step 3\n+     * - claim it by user B\n+     * - remove user B from step 1\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 3, verify that the removal is refused due to user B having a claimed task and there\n+     * being no other members in step 3\n+     * - approve it by user B\n+     * - delete user B\n+     * - verify the delete suceeds\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup4() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP, CLAIM_ACTION);\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, FINAL_EDIT_ROLE, false);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP,\n+                              FINAL_EDIT_ACTION);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, FINAL_EDIT_ROLE, true);\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Collection A - Step 1: user B\n+     * - Collection A - Step 2: user C\n+     * - Collection A - Step 3: user B\n+     *\n+     * - Collection B - Step 1: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item in Collection A, and let it move to step 1\n+     * - claim it by user B\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from Col A - step 3\n+     * - remove user B from Col B - step 1\n+     * - remove user B from Col A - step 1\n+     * - Verify that the removal from Col A - step 1 is refused because user B has a claimed task in that collection and\n+     * no other user is present\n+     * - approve it by user B, and let it move to step 2\n+     * - remove user B from Col A - step 1\n+     * - verify it succeeds\n+     * - delete user B\n+     * - verify it succeeds\n+     * - approve it by user C\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup5() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collectionA = CollectionBuilder.createCollection(context, parent)\n+                                                  .withWorkflowGroup(1, workflowUserB)\n+                                                  .withWorkflowGroup(2, workflowUserC)\n+                                                  .withWorkflowGroup(3, workflowUserB)\n+                                                  .build();\n+\n+        Collection collectionB = CollectionBuilder.createCollection(context, parent)\n+                                                  .withWorkflowGroup(1, workflowUserB)\n+                                                  .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collectionA)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collectionA);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collectionA, FINAL_EDIT_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collectionB, REVIEW_ROLE, true);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collectionA, REVIEW_ROLE, false);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collectionA, REVIEW_ROLE, true);\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * - create a workspace item, and let it move to step 1\n+     * - Approve it by user B\n+     * - verify that the item moved to step 2\n+     * - claim it by user C, but don\u2019t approve it\n+     * - delete user C\n+     * - verify the delete is refused\n+     * - remove user C from step 2\n+     * - delete user C\n+     * - verify the delete succeeds\n+     * - verify that the item moved to step 3 without any actions apart from deleting user C\n+     * - Approve it by user B\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup6() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        assertDeletionOfEperson(workflowUserA, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, FINAL_EDIT_STEP,\n+                              FINAL_EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after user has been removed from the workflow\n+     * group and the task has been passed, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - remove user B from step 1\n+     * - verify the removal is refused\n+     * - remove user B from step 3\n+     * - verify the removal succeeds\n+     * - approve it by user B\n+     * - verify that the item moved to step 2\n+     * - remove user B from step 1\n+     * - delete user B\n+     * - verify the delete succeeds\n+     * - approve it by user C\n+     * - verify that the item is archived without any actions apart from removing user B\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserWhenOnlyUserInGroup7() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, false);\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, FINAL_EDIT_ROLE, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+        assertRemovalOfEpersonFromWorkflowGroup(workflowUserB, collection, REVIEW_ROLE, true);\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after another user has been added to the workflow\n+     * group, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - approve it by user B\n+     * - verify that the item moved to step 2\n+     * - Approve it by user C\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - add user D to workflow step 3\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - add user D to workflow step 1\n+     * - delete user B\n+     * - verify the delete succeeds\n+     * - Approve it by user D\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserAfterReplacingUser1() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .withWorkflowGroup(1, workflowUserB)\n+                                                 .withWorkflowGroup(2, workflowUserC)\n+                                                 .withWorkflowGroup(3, workflowUserB)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(workflowUserA)\n+                                                .withTitle(\"Test item full workflow\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Workflow workflow = XmlWorkflowServiceFactory.getInstance().getWorkflowFactory().getWorkflow(collection);\n+\n+        XmlWorkflowItem workflowItem = xmlWorkflowService.startWithoutNotify(context, wsi);\n+        MockHttpServletRequest httpServletRequest = new MockHttpServletRequest();\n+        httpServletRequest.setParameter(\"submit_approve\", \"submit_approve\");\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserB, workflow, workflowItem, REVIEW_STEP, REVIEW_ACTION);\n+\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserC, workflow, workflowItem, EDIT_STEP, EDIT_ACTION);\n+\n+        assertDeletionOfEperson(workflowUserB, false);\n+\n+        addUserToWorkflowGroup(workflowUserD, collection, FINAL_EDIT_ROLE);\n+        assertDeletionOfEperson(workflowUserB, false);\n+        addUserToWorkflowGroup(workflowUserD, collection, REVIEW_ROLE);\n+\n+        assertDeletionOfEperson(workflowUserB, true);\n+\n+        executeWorkflowAction(httpServletRequest, workflowUserD, workflow, workflowItem, FINAL_EDIT_STEP, CLAIM_ACTION);\n+        executeWorkflowAction(httpServletRequest, workflowUserD, workflow, workflowItem, FINAL_EDIT_STEP,\n+                              FINAL_EDIT_ACTION);\n+\n+        assertTrue(workflowItem.getItem().isArchived());\n+\n+    }\n+\n+    /**\n+     * This test verifies that an EPerson cannot be removed if they are the only member of a Workflow Group that has\n+     * tasks currently assigned to it. This test also verifies that after another user has been added to the workflow\n+     * group, the EPerson can be removed.\n+     *\n+     * This test has the following setup:\n+     * - Step 1: user B\n+     * - Step 2: user C\n+     * - Step 3: user B\n+     *\n+     * This test will perform the following checks:\n+     * - create a workspace item, and let it move to step 1\n+     * - delete user B\n+     * - verify the delete is refused\n+     * - add user D to workflow step 1\n+     * - add user D to workflow step 3\n+     * - delete user B\n+     * - verify the delete succeeds\n+     * - Approve it by user D\n+     * - verify that the item moved to step 2\n+     * - Approve it by user C\n+     * - Approve it by user D\n+     * - verify that the item is archived\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testDeleteUserAfterReplacingUser2() throws Exception {", "originalCommit": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0MzU2NA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r498943564", "bodyText": "If this class is an AbstractIntegrationTestWithDatabase then it is not a unit test and should be named EPersonInWorkflowIT.\nBeing an IT would help to explain why it runs so long.  Actually, as our ITs go, its execution is rather brief.", "author": "mwoodiupui", "createdAt": "2020-10-02T17:05:58Z", "path": "dspace-api/src/test/java/org/dspace/eperson/EPersonInWorkflowTest.java", "diffHunk": "@@ -0,0 +1,1498 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.eperson;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.AbstractIntegrationTestWithDatabase;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.workflow.WorkflowItemService;\n+import org.dspace.workflow.WorkflowService;\n+import org.dspace.workflow.factory.WorkflowServiceFactory;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.state.Workflow;\n+import org.dspace.xmlworkflow.storedcomponents.CollectionRole;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.dspace.xmlworkflow.storedcomponents.service.ClaimedTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.CollectionRoleService;\n+import org.dspace.xmlworkflow.storedcomponents.service.PoolTaskService;\n+import org.dspace.xmlworkflow.storedcomponents.service.XmlWorkflowItemService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class EPersonInWorkflowTest extends AbstractIntegrationTestWithDatabase {", "originalCommit": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYxMDgzNw==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r499610837", "bodyText": "@mwoodiupui : good catch! I somehow overlooked that.\nI agree with @mwoodiupui here, @benbosman ....this class is misnamed.  Since it's obviously an IT, it must be named EPersonInWorkflowIT.java in order to be run as an IT.  Just a reminder, classes with \"Test\" in them are run as Unit Tests, while classes with \"IT\" in them are run as Integration Tests.", "author": "tdonohue", "createdAt": "2020-10-05T13:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0MzU2NA=="}], "type": "inlineReview"}, {"oid": "d6046dc7ffa0e49ade99e8d39a6aecfb34e7432c", "url": "https://github.com/DSpace/DSpace/commit/d6046dc7ffa0e49ade99e8d39a6aecfb34e7432c", "message": "updated JavaDocs to explain the goal of the tests in more detail", "committedDate": "2020-10-05T07:51:22Z", "type": "commit"}, {"oid": "01cc8560675059cc74838d914a3b965166f1bde5", "url": "https://github.com/DSpace/DSpace/commit/01cc8560675059cc74838d914a3b965166f1bde5", "message": "checkstyle", "committedDate": "2020-10-05T08:35:23Z", "type": "commit"}, {"oid": "4103b016ec100ba1fadfe36c979cf6cd2bc4a9bb", "url": "https://github.com/DSpace/DSpace/commit/4103b016ec100ba1fadfe36c979cf6cd2bc4a9bb", "message": "73977: Delete eperson: community feedback part 3", "committedDate": "2020-10-06T15:16:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ0NDg5NA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r500444894", "bodyText": "Minor thing.  This test seems to have an @Ignore.  Is there a reason for that?  If so, we should add a TODO comment here.\nAlso, I think this test may be incorrect.  In EPersonTest.testCascadingDeleteSubmitterPreservesWorkflowItems(), the test proves that a WorkflowItem is kept even if the Submitter is deleted.  This test seems to be trying to prove the opposite as the final line in this method is trying to prove that the WorkflowItem isNotFound() after the Submitter is deleted.  I suspect that last line should be changed to isOk(), as the WorkflowItem should still exist even if the Submitter is deleted.", "author": "tdonohue", "createdAt": "2020-10-06T16:43:28Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/eperson/DeleteEPersonSubmitterIT.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.eperson;\n+\n+import static com.jayway.jsonpath.JsonPath.read;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.patch;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.requestitem.RequestItemAuthor;\n+import org.dspace.app.requestitem.RequestItemAuthorExtractor;\n+import org.dspace.app.rest.model.patch.Operation;\n+import org.dspace.app.rest.model.patch.ReplaceOperation;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.builder.CollectionBuilder;\n+import org.dspace.builder.CommunityBuilder;\n+import org.dspace.builder.EPersonBuilder;\n+import org.dspace.builder.WorkspaceItemBuilder;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.factory.EPersonServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.dspace.versioning.Version;\n+import org.dspace.versioning.factory.VersionServiceFactory;\n+import org.dspace.versioning.service.VersioningService;\n+import org.dspace.xmlworkflow.factory.XmlWorkflowServiceFactory;\n+import org.dspace.xmlworkflow.service.XmlWorkflowService;\n+import org.dspace.xmlworkflow.storedcomponents.XmlWorkflowItem;\n+import org.hamcrest.Matchers;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+/**\n+ * Class to test interaction between EPerson deletion and tasks present in the workflow\n+ */\n+public class DeleteEPersonSubmitterIT extends AbstractControllerIntegrationTest {\n+\n+    protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                               .getWorkspaceItemService();\n+    protected XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory.getInstance().getXmlWorkflowService();\n+    protected VersioningService versioningService = VersionServiceFactory.getInstance().getVersionService();\n+\n+    protected RequestItemAuthorExtractor requestItemAuthorExtractor =\n+            DSpaceServicesFactory.getInstance()\n+                                 .getServiceManager()\n+                                 .getServiceByName(\"org.dspace.app.requestitem.RequestItemAuthorExtractor\",\n+                                         RequestItemAuthorExtractor.class);\n+\n+\n+    private EPerson submitter;\n+    private EPerson submitterForVersion1;\n+    private EPerson submitterForVersion2;\n+    private EPerson workflowUser;\n+\n+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(DeleteEPersonSubmitterIT.class);\n+\n+    /**\n+     * This method will be run before every test as per @Before. It will\n+     * initialize resources required for the tests.\n+     *\n+     * Other methods can be annotated with @Before here or in subclasses but no\n+     * execution order is guaranteed\n+     */\n+    @Before\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        submitter = EPersonBuilder.createEPerson(context).withEmail(\"submitter@example.org\").build();\n+        workflowUser = EPersonBuilder.createEPerson(context).withEmail(\"workflowUser@example.org\").build();\n+        submitterForVersion1 = EPersonBuilder.createEPerson(context).withEmail(\"submitterForVersion1@example.org\")\n+                                             .build();\n+        submitterForVersion2 = EPersonBuilder.createEPerson(context).withEmail(\"submitterForVersion2@example.org\")\n+                                             .build();\n+\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+\n+    /**\n+     * This test verifies that when the submitter Eperson is deleted, the delete succeeds and the item will have\n+     * 'null' as submitter\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testArchivedItemSubmitterDelete() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(submitter)\n+                                                .withTitle(\"Test Item\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Item installItem = installItemService.installItem(context, wsi);\n+\n+        assertDeletionOfEperson(submitter);\n+\n+        assertNull(retrieveItemSubmitter(installItem.getID()));\n+\n+\n+        Item item = itemService.find(context, installItem.getID());\n+        RequestItemAuthor requestItemAuthor = requestItemAuthorExtractor.getRequestItemAuthor(context, item);\n+\n+        assertEquals(\"Help Desk\", requestItemAuthor.getFullName());\n+        assertEquals(\"dspace-help@myu.edu\", requestItemAuthor.getEmail());\n+    }\n+\n+    /**\n+     * This test verifies that when the submitter Eperson is deleted, the delete succeeds and the item will have\n+     * 'null' as submitter\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testWIthdrawnItemSubmitterDelete() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(submitter)\n+                                                .withTitle(\"Test Item\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Item item = installItemService.installItem(context, wsi);\n+\n+        List<Operation> opsToWithDraw = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperationToWithDraw = new ReplaceOperation(\"/withdrawn\", true);\n+        opsToWithDraw.add(replaceOperationToWithDraw);\n+        String patchBodyToWithdraw = getPatchContent(opsToWithDraw);\n+\n+        // withdraw item\n+        String token = getAuthToken(admin.getEmail(), password);\n+        getClient(token).perform(patch(\"/api/core/items/\" + item.getID())\n+                                         .content(patchBodyToWithdraw)\n+                                         .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$.uuid\", Matchers.is(item.getID().toString())))\n+                        .andExpect(jsonPath(\"$.withdrawn\", Matchers.is(true)))\n+                        .andExpect(jsonPath(\"$.inArchive\", Matchers.is(false)));\n+\n+\n+        assertDeletionOfEperson(submitter);\n+\n+        assertNull(retrieveItemSubmitter(item.getID()));\n+\n+        List<Operation> opsToReinstate = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperationToReinstate = new ReplaceOperation(\"/withdrawn\", false);\n+        opsToReinstate.add(replaceOperationToReinstate);\n+        String patchBodyToReinstate = getPatchContent(opsToReinstate);\n+\n+        // reinstate item\n+        getClient(token).perform(patch(\"/api/core/items/\" + item.getID())\n+                                         .content(patchBodyToReinstate)\n+                                         .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$.uuid\", Matchers.is(item.getID().toString())))\n+                        .andExpect(jsonPath(\"$.withdrawn\", Matchers.is(false)))\n+                        .andExpect(jsonPath(\"$.inArchive\", Matchers.is(true)));\n+\n+        assertNull(retrieveItemSubmitter(item.getID()));\n+\n+\n+        // withdraw item again\n+        getClient(token).perform(patch(\"/api/core/items/\" + item.getID())\n+                                         .content(patchBodyToWithdraw)\n+                                         .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$.uuid\", Matchers.is(item.getID().toString())))\n+                        .andExpect(jsonPath(\"$.withdrawn\", Matchers.is(true)))\n+                        .andExpect(jsonPath(\"$.inArchive\", Matchers.is(false)));\n+\n+        assertNull(retrieveItemSubmitter(item.getID()));\n+\n+    }\n+\n+    @Test\n+    public void testVersionItemSubmitterDelete() throws Exception {\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(submitter)\n+                                                .withTitle(\"Test Item\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+        Item item = installItemService.installItem(context, wsi);\n+\n+        context.setCurrentUser(submitter);\n+        //TODO: Replace this with a REST call when possible\n+        Version version1 = versioningService.createNewVersion(context, item);\n+        Integer version1ID = version1.getID();\n+        WorkspaceItem version1WorkspaceItem = workspaceItemService.findByItem(context, version1.getItem());\n+        installItemService.installItem(context, version1WorkspaceItem);\n+\n+        assertDeletionOfEperson(submitter);\n+        assertNull(retrieveItemSubmitter(item.getID()));\n+\n+        Item version1Item = retrieveVersionItem(version1ID);\n+        assertNull(retrieveItemSubmitter(version1Item.getID()));\n+\n+\n+        context.setCurrentUser(submitterForVersion1);\n+\n+        Version version2 = versioningService.createNewVersion(context, item);\n+        Integer version2ID = version2.getID();\n+        WorkspaceItem version2WorkspaceItem = workspaceItemService.findByItem(context, version2.getItem());\n+        installItemService.installItem(context, version2WorkspaceItem);\n+        Item version2Item = retrieveVersionItem(version2ID);\n+        assertEquals(submitterForVersion1.getID(), retrieveItemSubmitter(version2Item.getID()).getID());\n+\n+        context.setCurrentUser(submitterForVersion2);\n+        Version version3 = versioningService.createNewVersion(context, version2Item);\n+        Integer version3ID = version3.getID();\n+        assertDeletionOfEperson(submitterForVersion2);\n+\n+        getClient(token).perform(get(\"/api/versioning/versions/\" + version3ID + \"/item\"))\n+                        .andExpect(status().isNoContent());\n+\n+\n+        // Clean up versions\n+        cleanupVersion(version1ID);\n+        cleanupVersion(version2ID);\n+        cleanupVersion(version3ID);\n+\n+    }\n+\n+\n+    @Test\n+    public void testWorkspaceItemSubmitterDelete() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        Community parent = CommunityBuilder.createCommunity(context).build();\n+        Collection collection = CollectionBuilder.createCollection(context, parent)\n+                                                 .build();\n+\n+        WorkspaceItem wsi = WorkspaceItemBuilder.createWorkspaceItem(context, collection)\n+                                                .withSubmitter(submitter)\n+                                                .withTitle(\"Test Item\")\n+                                                .withIssueDate(\"2019-03-06\")\n+                                                .withSubject(\"ExtraEntry\")\n+                                                .build();\n+\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        getClient(token).perform(get(\"/api/submission/workspaceitems/\" + wsi.getID()))\n+                        .andExpect(status().isOk());\n+\n+        assertDeletionOfEperson(submitter);\n+\n+        getClient(token).perform(get(\"/api/submission/workspaceitems/\" + wsi.getID()))\n+                        .andExpect(status().isNotFound());\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void testWorkflowItemSubmitterDelete() throws Exception {", "originalCommit": "4103b016ec100ba1fadfe36c979cf6cd2bc4a9bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAzMjcxMA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r501032710", "bodyText": "I've logged the above Ignored test as part of #2994.  It's related to the minor bug that I described there.", "author": "tdonohue", "createdAt": "2020-10-07T13:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ0NDg5NA=="}], "type": "inlineReview"}, {"oid": "9ae42397bf8ee8ab24201c3ef824c8d99e49306b", "url": "https://github.com/DSpace/DSpace/commit/9ae42397bf8ee8ab24201c3ef824c8d99e49306b", "message": "add TODO message", "committedDate": "2020-10-07T07:52:21Z", "type": "commit"}, {"oid": "9ae42397bf8ee8ab24201c3ef824c8d99e49306b", "url": "https://github.com/DSpace/DSpace/commit/9ae42397bf8ee8ab24201c3ef824c8d99e49306b", "message": "add TODO message", "committedDate": "2020-10-07T07:52:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MzU1OA==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r499273558", "bodyText": "nothing serious, basic javadoc is missing", "author": "abollini", "createdAt": "2020-10-04T18:15:07Z", "path": "dspace-api/src/main/java/org/dspace/authorize/dao/ResourcePolicyDAO.java", "diffHunk": "@@ -33,6 +33,8 @@\n     public List<ResourcePolicy> findByDsoAndType(Context context, DSpaceObject dSpaceObject, String type)\n         throws SQLException;\n \n+    public List<ResourcePolicy> findByEPerson(Context context, EPerson ePerson) throws SQLException;", "originalCommit": "d5e28e8a7c5d207bba920193415dcc10c1caf0c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ2OTkzMw==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r501469933", "bodyText": "this seems to be not fully accurate. In the code below there are scenario where the EPersonDeletionException is thrown directly (btw it should be also added to the list of throws in the javadoc) and in another case it is wrapped inside an IllegalArgumentException. Can we always return it directly? any reason to wrap it in another exception?", "author": "abollini", "createdAt": "2020-10-08T06:11:23Z", "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex);\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(ex);\n+        } catch (EPersonDeletionException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Deletes an EPerson. The argument cascade defines whether all references\n+     * on an EPerson should be deleted as well (by either deleting the\n+     * referencing object - e.g. WorkspaceItem, ResourcePolicy - or by setting\n+     * the foreign key null - e.g. archived Items). If cascade is set to false\n+     * and the EPerson is referenced somewhere, this leads to an\n+     * AuthorizeException. EPersons may be referenced by Items, ResourcePolicies", "originalCommit": "9ae42397bf8ee8ab24201c3ef824c8d99e49306b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MjI1MQ==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r501472251", "bodyText": "The basic workflow must be removed in dspace 7 as we switched to the configurable workflow and this cannot be reverted... anyway as the basic workflow code is still here I looked to this code as well\nI doubt that this code is never executed. It could stay to deal with inconsistent data but it would be useful to add a note in the comment to say that the claimed tasks are normally processed by the code in the previous if (L377-L388) and turned into pool tasks)", "author": "abollini", "createdAt": "2020-10-08T06:17:48Z", "path": "dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java", "diffHunk": "@@ -179,45 +222,202 @@ public EPerson create(Context context) throws SQLException, AuthorizeException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to create an EPerson\");\n+                    \"You must be an admin to create an EPerson\");\n         }\n \n         // Create a table row\n         EPerson e = ePersonDAO.create(context, new EPerson());\n \n         log.info(LogManager.getHeader(context, \"create_eperson\", \"eperson_id=\"\n-            + e.getID()));\n+                + e.getID()));\n \n         context.addEvent(new Event(Event.CREATE, Constants.EPERSON, e.getID(),\n-                                   null, getIdentifiers(context, e)));\n+                null, getIdentifiers(context, e)));\n \n         return e;\n     }\n \n     @Override\n     public void delete(Context context, EPerson ePerson) throws SQLException, AuthorizeException {\n+        try {\n+            delete(context, ePerson, true);\n+        } catch (AuthorizeException ex) {\n+            log.error(\"This AuthorizeException: \" + ex + \" occured while deleting Eperson with the ID: \" +\n+                      ePerson.getID());\n+            throw new AuthorizeException(ex);\n+        } catch (IOException ex) {\n+            log.error(\"This IOException: \" + ex + \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+            throw new AuthorizeException(ex);\n+        } catch (EPersonDeletionException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Deletes an EPerson. The argument cascade defines whether all references\n+     * on an EPerson should be deleted as well (by either deleting the\n+     * referencing object - e.g. WorkspaceItem, ResourcePolicy - or by setting\n+     * the foreign key null - e.g. archived Items). If cascade is set to false\n+     * and the EPerson is referenced somewhere, this leads to an\n+     * AuthorizeException. EPersons may be referenced by Items, ResourcePolicies\n+     * and workflow tasks.\n+     *\n+     * @param context DSpace context\n+     * @param ePerson The EPerson to delete.\n+     * @param cascade Whether to delete references on the EPerson (cascade =\n+     * true) or to abort the deletion (cascade = false) if the EPerson is\n+     * referenced within DSpace.\n+     *\n+     * @throws SQLException\n+     * @throws AuthorizeException\n+     * @throws IOException\n+     */\n+    public void delete(Context context, EPerson ePerson, boolean cascade)\n+            throws SQLException, AuthorizeException, IOException, EPersonDeletionException {\n         // authorized?\n         if (!authorizeService.isAdmin(context)) {\n             throw new AuthorizeException(\n-                \"You must be an admin to delete an EPerson\");\n+                    \"You must be an admin to delete an EPerson\");\n+        }\n+        Set<Group> workFlowGroups = getAllWorkFlowGroups(context, ePerson);\n+        for (Group group: workFlowGroups) {\n+            List<EPerson> ePeople = groupService.allMembers(context, group);\n+            if (ePeople.size() == 1 && ePeople.contains(ePerson)) {\n+                throw new IllegalStateException(\n+                    \"Refused to delete user \" + ePerson.getID() + \" because it the only member of the workflow group\"\n+                    + group.getID() + \". Delete the tasks and group first if you want to remove this user.\");\n+            }\n         }\n-\n         // check for presence of eperson in tables that\n         // have constraints on eperson_id\n         List<String> constraintList = getDeleteConstraints(context, ePerson);\n-\n-        // if eperson exists in tables that have constraints\n-        // on eperson, throw an exception\n         if (constraintList.size() > 0) {\n-            throw new AuthorizeException(new EPersonDeletionException(constraintList));\n+            // Check if the constraints we found should be deleted\n+            if (cascade) {\n+                boolean isBasicFramework = WorkflowServiceFactory.getInstance().getWorkflowService()\n+                                           instanceof BasicWorkflowService;\n+                boolean isXmlFramework = WorkflowServiceFactory.getInstance().getWorkflowService()\n+                                         instanceof XmlWorkflowService;\n+                Iterator<String> constraintsIterator = constraintList.iterator();\n+\n+                while (constraintsIterator.hasNext()) {\n+                    String tableName = constraintsIterator.next();\n+                    if (StringUtils.equals(tableName, \"item\") || StringUtils.equals(tableName, \"workspaceitem\")) {\n+                        Iterator<Item> itemIterator = itemService.findBySubmitter(context, ePerson, true);\n+\n+                        VersionHistoryService versionHistoryService = VersionServiceFactory.getInstance()\n+                                                                      .getVersionHistoryService();\n+                        VersioningService versioningService = VersionServiceFactory.getInstance().getVersionService();\n+\n+                        while (itemIterator.hasNext()) {\n+                            Item item = itemIterator.next();\n+\n+                            VersionHistory versionHistory = versionHistoryService.findByItem(context, item);\n+                            if (null != versionHistory) {\n+                                for (Version version : versioningService.getVersionsByHistory(context,\n+                                                                                              versionHistory)) {\n+                                    version.setePerson(null);\n+                                    versionDAO.save(context, version);\n+                                }\n+                            }\n+                            WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance()\n+                                                                        .getWorkspaceItemService();\n+                            WorkspaceItem wsi = workspaceItemService.findByItem(context, item);\n+\n+                            if (null != wsi) {\n+                                workspaceItemService.deleteAll(context, wsi);\n+                            } else {\n+                                // we can do that as dc.provenance still contains\n+                                // information about who submitted and who\n+                                // archived an item.\n+                                item.setSubmitter(null);\n+                                itemService.update(context, item);\n+                            }\n+                        }\n+                    } else if (StringUtils.equals(tableName, \"cwf_claimtask\") && isXmlFramework) {\n+                         // Unclaim all XmlWorkflow tasks\n+                        XmlWorkflowItemService xmlWorkflowItemService = XmlWorkflowServiceFactory\n+                                                                        .getInstance().getXmlWorkflowItemService();\n+                        ClaimedTaskService claimedTaskService = XmlWorkflowServiceFactory\n+                                                                .getInstance().getClaimedTaskService();\n+                        XmlWorkflowService xmlWorkflowService = XmlWorkflowServiceFactory\n+                                                                .getInstance().getXmlWorkflowService();\n+                        WorkflowRequirementsService workflowRequirementsService = XmlWorkflowServiceFactory\n+                                                                       .getInstance().getWorkflowRequirementsService();\n+\n+                        List<XmlWorkflowItem> xmlWorkflowItems = xmlWorkflowItemService\n+                                                                 .findBySubmitter(context, ePerson);\n+                        List<ClaimedTask> claimedTasks = claimedTaskService.findByEperson(context, ePerson);\n+\n+                        for (ClaimedTask task : claimedTasks) {\n+                            xmlWorkflowService.deleteClaimedTask(context, task.getWorkflowItem(), task);\n+\n+                            try {\n+                                workflowRequirementsService.removeClaimedUser(context, task.getWorkflowItem(),\n+                                                                              ePerson, task.getStepID());\n+                            } catch (WorkflowConfigurationException ex) {\n+                                log.error(\"This WorkflowConfigurationException: \" + ex +\n+                                          \" occured while deleting Eperson with the ID: \" + ePerson.getID());\n+                                throw new AuthorizeException(new EPersonDeletionException(Collections\n+                                                                                          .singletonList(tableName)));\n+                            }\n+                        }\n+                    } else if (StringUtils.equals(tableName, \"workflowitem\") && isBasicFramework) {\n+                        // Remove basicWorkflow workflowitem and unclaim them\n+                        BasicWorkflowItemService basicWorkflowItemService = BasicWorkflowServiceFactory.getInstance()\n+                                                                            .getBasicWorkflowItemService();\n+                        BasicWorkflowService basicWorkflowService = BasicWorkflowServiceFactory.getInstance()\n+                                                                    .getBasicWorkflowService();\n+                        TaskListItemService taskListItemService = BasicWorkflowServiceFactory.getInstance()\n+                                                                  .getTaskListItemService();\n+                        List<BasicWorkflowItem> workflowItems = basicWorkflowItemService.findByOwner(context, ePerson);\n+                        for (BasicWorkflowItem workflowItem : workflowItems) {\n+                            int state = workflowItem.getState();\n+                            // unclaim tasks that are in the pool.\n+                            if (state == BasicWorkflowServiceImpl.WFSTATE_STEP1\n+                                    || state == BasicWorkflowServiceImpl.WFSTATE_STEP2\n+                                    || state == BasicWorkflowServiceImpl.WFSTATE_STEP3) {\n+                                log.info(LogManager.getHeader(context, \"unclaim_workflow\",\n+                                        \"workflow_id=\" + workflowItem.getID() + \", claiming EPerson is deleted\"));\n+                                basicWorkflowService.unclaim(context, workflowItem, context.getCurrentUser());\n+                                // remove the EPerson from the list of persons that can (re-)claim the task\n+                                // while we are doing it below, we must do this here as well as the previously\n+                                // unclaimed tasks was put back into pool and we do not know the order the tables\n+                                // are checked.\n+                                taskListItemService.deleteByWorkflowItemAndEPerson(context, workflowItem, ePerson);\n+                            }\n+                        }\n+                    } else if (StringUtils.equals(tableName, \"resourcepolicy\")) {\n+                        // we delete the EPerson, it won't need any rights anymore.\n+                        authorizeService.removeAllEPersonPolicies(context, ePerson);\n+                    } else if (StringUtils.equals(tableName, \"tasklistitem\") && isBasicFramework) {\n+                        // remove EPerson from the list of EPersons that may claim some specific workflow tasks.\n+                        TaskListItemService taskListItemService = BasicWorkflowServiceFactory.getInstance()\n+                                                                  .getTaskListItemService();\n+                        taskListItemService.deleteByEPerson(context, ePerson);", "originalCommit": "9ae42397bf8ee8ab24201c3ef824c8d99e49306b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg2MzE1Nw==", "url": "https://github.com/DSpace/DSpace/pull/2928#discussion_r501863157", "bodyText": "Yes, good point, @abollini.  I've created a ticket to remove Basic Workflow code & database tables entirely.  It seems we never completed that cleanup.  #2995", "author": "tdonohue", "createdAt": "2020-10-08T16:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ3MjI1MQ=="}], "type": "inlineReview"}]}