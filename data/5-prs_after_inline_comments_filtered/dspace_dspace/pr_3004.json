{"pr_number": 3004, "pr_title": "Entities update item metadata outside rest", "pr_createdAt": "2020-10-14T14:18:11Z", "pr_url": "https://github.com/DSpace/DSpace/pull/3004", "timeline": [{"oid": "5ad45fe7b6867659bdbadc17d30b8cd076d5aec8", "url": "https://github.com/DSpace/DSpace/commit/5ad45fe7b6867659bdbadc17d30b8cd076d5aec8", "message": "Entities features: update the item metadata on relationship create/update/delete also when not using REST", "committedDate": "2020-06-25T13:37:02Z", "type": "commit"}, {"oid": "b39facf1d14dd05bad7e2f0f8521ca0c0844b0bf", "url": "https://github.com/DSpace/DSpace/commit/b39facf1d14dd05bad7e2f0f8521ca0c0844b0bf", "message": "Entities features: update the item metadata on relationship create/update/delete also when not using REST", "committedDate": "2020-06-25T15:27:52Z", "type": "commit"}, {"oid": "612acbdc36f9cb622f95bb53fff64756362957d4", "url": "https://github.com/DSpace/DSpace/commit/612acbdc36f9cb622f95bb53fff64756362957d4", "message": "Entities features: update the item metadata on relationship create/delete also when not using REST\non update this is causing problems with the place changes", "committedDate": "2020-06-25T16:10:16Z", "type": "commit"}, {"oid": "048381ef874f51844a459076f781b3f60afb2077", "url": "https://github.com/DSpace/DSpace/commit/048381ef874f51844a459076f781b3f60afb2077", "message": "[Task 71757] added the virtual metadata looping and item updating in the uodateItemsInRelationship method", "committedDate": "2020-07-09T14:01:22Z", "type": "commit"}, {"oid": "b65ed11bdc6ea3ec6ece0860b273877a6aef03c4", "url": "https://github.com/DSpace/DSpace/commit/b65ed11bdc6ea3ec6ece0860b273877a6aef03c4", "message": "[Task 71757] added configurable max amount on items and reverted testing change", "committedDate": "2020-07-10T07:12:13Z", "type": "commit"}, {"oid": "245af53f4351378317fad8e432c47472b8e2d461", "url": "https://github.com/DSpace/DSpace/commit/245af53f4351378317fad8e432c47472b8e2d461", "message": "Merge remote-tracking branch 'origin/master' into entities-update-item-metadata-outside-rest", "committedDate": "2020-09-10T13:47:25Z", "type": "commit"}, {"oid": "0a1aa90cda031bc4b148b28a8168c3c9a4e799e5", "url": "https://github.com/DSpace/DSpace/commit/0a1aa90cda031bc4b148b28a8168c3c9a4e799e5", "message": "[Task 71757] added mock configuration service to the test class", "committedDate": "2020-09-14T13:39:03Z", "type": "commit"}, {"oid": "9895049a99ce80ec4aa4c01c4ef45f6e8012d9a1", "url": "https://github.com/DSpace/DSpace/commit/9895049a99ce80ec4aa4c01c4ef45f6e8012d9a1", "message": "Merge remote-tracking branch 'community/main' into entities-update-item-metadata-outside-rest", "committedDate": "2020-10-14T12:45:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NzE1NA==", "url": "https://github.com/DSpace/DSpace/pull/3004#discussion_r513777154", "bodyText": "I'm a little confused by the logic in these methods as there's no inline comments or JavaDocs.  If we already know that this item is the \"RightItem\", then why do we need to check if it's actually the left item (when would isLeft ever be \"true\")?\nI'm assuming I'm misunderstanding this code, but I wanted to point out that it's not clear to me.  I would appreciate more inline comments, as I don't understand the logic in this method", "author": "tdonohue", "createdAt": "2020-10-28T21:38:14Z", "path": "dspace-api/src/main/java/org/dspace/content/RelationshipServiceImpl.java", "diffHunk": "@@ -346,6 +357,119 @@ public void delete(Context context, Relationship relationship, boolean copyToLef\n         }\n     }\n \n+\n+    /**\n+     * Utility method to ensure discovery is updated for the 2 items\n+     * This method is used when creating, modifying or deleting a relationship\n+     * The virtual metadata of the 2 items may need to be updated, so they should be re-indexed\n+     *\n+     * @param context           The relevant DSpace context\n+     * @param relationship      The relationship which has been created, updated or deleted\n+     * @throws SQLException     If something goes wrong\n+     */\n+    private void updateItemsInRelationship(Context context, Relationship relationship) throws SQLException {\n+        // Since this call is performed after creating, updating or deleting the relationships, the permissions have\n+        // already been verified. The following updateItem calls can however call the\n+        // ItemService.update() functions which would fail if the user doesn't have permission on both items.\n+        // Since we allow this edits to happen under these circumstances, we need to turn off the\n+        // authorization system here so that this failure doesn't happen when the items need to be update\n+        context.turnOffAuthorisationSystem();\n+        try {\n+            int max = configurationService.getIntProperty(\"relationship.update.relateditems.max\", 5);\n+            List<Item> itemsToUpdate = new LinkedList<>();\n+            itemsToUpdate.add(relationship.getLeftItem());\n+            itemsToUpdate.add(relationship.getRightItem());\n+\n+            itemsToUpdate = getRelatedItemsForLeftItem(context, relationship.getLeftItem(),\n+                                                       relationship, itemsToUpdate, max);\n+            itemsToUpdate = getRelatedItemsForRightItem(context, relationship.getRightItem(),\n+                                                        relationship, itemsToUpdate, max);\n+\n+            for (Item item : itemsToUpdate) {\n+                if (!item.isMetadataModified()) {\n+                    updateItem(context, item);\n+                }\n+            }\n+\n+        } catch (AuthorizeException e) {\n+            log.error(\"Authorization Exception while authorization has been disabled\", e);\n+        }\n+        context.restoreAuthSystemState();\n+    }\n+\n+    private List<Item> getRelatedItemsForRightItem(Context context, Item item, Relationship relationship,\n+                                                   List<Item> itemsToUpdate, int max)\n+        throws SQLException {\n+        if (itemsToUpdate.size() >= max) {\n+            return itemsToUpdate;\n+        }\n+        List<RelationshipType> relationshipTypes = new LinkedList<>();\n+        EntityType leftType = relationship.getRelationshipType().getLeftType();\n+        String entityTypeStringFromMetadata = relationshipMetadataService.getEntityTypeStringFromMetadata(item);\n+        EntityType actualEntityType = entityTypeService.findByEntityType(context, entityTypeStringFromMetadata);\n+        boolean isLeft = false;\n+        if (StringUtils.equalsIgnoreCase(leftType.getLabel(),\n+                                         entityTypeStringFromMetadata)) {\n+            relationshipTypes = relationshipTypeService.findByEntityType(context, actualEntityType, false);\n+        } else {\n+            isLeft = true;", "originalCommit": "9895049a99ce80ec4aa4c01c4ef45f6e8012d9a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc3NzgxMQ==", "url": "https://github.com/DSpace/DSpace/pull/3004#discussion_r513777811", "bodyText": "Same here...the logic is still confusing.  We already know this item is the \"LeftItem\", so when would this else ever be triggered?  Why again do we need the isLeft variable, if we know it should always be true?", "author": "tdonohue", "createdAt": "2020-10-28T21:39:40Z", "path": "dspace-api/src/main/java/org/dspace/content/RelationshipServiceImpl.java", "diffHunk": "@@ -346,6 +357,119 @@ public void delete(Context context, Relationship relationship, boolean copyToLef\n         }\n     }\n \n+\n+    /**\n+     * Utility method to ensure discovery is updated for the 2 items\n+     * This method is used when creating, modifying or deleting a relationship\n+     * The virtual metadata of the 2 items may need to be updated, so they should be re-indexed\n+     *\n+     * @param context           The relevant DSpace context\n+     * @param relationship      The relationship which has been created, updated or deleted\n+     * @throws SQLException     If something goes wrong\n+     */\n+    private void updateItemsInRelationship(Context context, Relationship relationship) throws SQLException {\n+        // Since this call is performed after creating, updating or deleting the relationships, the permissions have\n+        // already been verified. The following updateItem calls can however call the\n+        // ItemService.update() functions which would fail if the user doesn't have permission on both items.\n+        // Since we allow this edits to happen under these circumstances, we need to turn off the\n+        // authorization system here so that this failure doesn't happen when the items need to be update\n+        context.turnOffAuthorisationSystem();\n+        try {\n+            int max = configurationService.getIntProperty(\"relationship.update.relateditems.max\", 5);\n+            List<Item> itemsToUpdate = new LinkedList<>();\n+            itemsToUpdate.add(relationship.getLeftItem());\n+            itemsToUpdate.add(relationship.getRightItem());\n+\n+            itemsToUpdate = getRelatedItemsForLeftItem(context, relationship.getLeftItem(),\n+                                                       relationship, itemsToUpdate, max);\n+            itemsToUpdate = getRelatedItemsForRightItem(context, relationship.getRightItem(),\n+                                                        relationship, itemsToUpdate, max);\n+\n+            for (Item item : itemsToUpdate) {\n+                if (!item.isMetadataModified()) {\n+                    updateItem(context, item);\n+                }\n+            }\n+\n+        } catch (AuthorizeException e) {\n+            log.error(\"Authorization Exception while authorization has been disabled\", e);\n+        }\n+        context.restoreAuthSystemState();\n+    }\n+\n+    private List<Item> getRelatedItemsForRightItem(Context context, Item item, Relationship relationship,\n+                                                   List<Item> itemsToUpdate, int max)\n+        throws SQLException {\n+        if (itemsToUpdate.size() >= max) {\n+            return itemsToUpdate;\n+        }\n+        List<RelationshipType> relationshipTypes = new LinkedList<>();\n+        EntityType leftType = relationship.getRelationshipType().getLeftType();\n+        String entityTypeStringFromMetadata = relationshipMetadataService.getEntityTypeStringFromMetadata(item);\n+        EntityType actualEntityType = entityTypeService.findByEntityType(context, entityTypeStringFromMetadata);\n+        boolean isLeft = false;\n+        if (StringUtils.equalsIgnoreCase(leftType.getLabel(),\n+                                         entityTypeStringFromMetadata)) {\n+            relationshipTypes = relationshipTypeService.findByEntityType(context, actualEntityType, false);\n+        } else {\n+            isLeft = true;\n+            relationshipTypes = relationshipTypeService.findByEntityType(context, actualEntityType, true);\n+        }\n+        for (RelationshipType relationshipType : relationshipTypes) {\n+            if (virtualMetadataPopulator.getMap().containsKey(relationshipType.getRightwardType())) {\n+                List<Relationship> list = findByItemAndRelationshipType(context, item, relationshipType, isLeft);\n+                for (Relationship foundRelationship : list) {\n+                    if (isLeft) {\n+                        itemsToUpdate.add(foundRelationship.getRightItem());\n+                        return getRelatedItemsForRightItem(context, foundRelationship.getRightItem(), foundRelationship,\n+                                                           itemsToUpdate, max);\n+                    } else {\n+                        itemsToUpdate.add(foundRelationship.getLeftItem());\n+                        return getRelatedItemsForLeftItem(context, foundRelationship.getLeftItem(), foundRelationship,\n+                                                          itemsToUpdate, max);\n+                    }\n+                }\n+            }\n+        }\n+        return itemsToUpdate;\n+    }\n+\n+    private List<Item> getRelatedItemsForLeftItem(Context context, Item item, Relationship relationship,\n+                                                  List<Item> itemsToUpdate, int max)\n+        throws SQLException {\n+        if (itemsToUpdate.size() >= max) {\n+            return itemsToUpdate;\n+        }\n+        List<RelationshipType> relationshipTypes = new LinkedList<>();\n+        EntityType rightType = relationship.getRelationshipType().getRightType();\n+        String entityTypeStringFromMetadata = relationshipMetadataService.getEntityTypeStringFromMetadata(item);\n+        EntityType actualEntityType = entityTypeService.findByEntityType(context, entityTypeStringFromMetadata);\n+        boolean isLeft = false;\n+        if (StringUtils.equalsIgnoreCase(rightType.getLabel(),\n+                                         relationshipMetadataService.getEntityTypeStringFromMetadata(item))) {\n+            isLeft = true;\n+            relationshipTypes = relationshipTypeService.findByEntityType(context, actualEntityType, true);\n+        } else {", "originalCommit": "9895049a99ce80ec4aa4c01c4ef45f6e8012d9a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg0MjY3Mg==", "url": "https://github.com/DSpace/DSpace/pull/3004#discussion_r515842672", "bodyText": "Why to attribute to itemsToUpdate a different value again?", "author": "paulo-graca", "createdAt": "2020-11-02T09:33:13Z", "path": "dspace-api/src/main/java/org/dspace/content/RelationshipServiceImpl.java", "diffHunk": "@@ -346,6 +357,119 @@ public void delete(Context context, Relationship relationship, boolean copyToLef\n         }\n     }\n \n+\n+    /**\n+     * Utility method to ensure discovery is updated for the 2 items\n+     * This method is used when creating, modifying or deleting a relationship\n+     * The virtual metadata of the 2 items may need to be updated, so they should be re-indexed\n+     *\n+     * @param context           The relevant DSpace context\n+     * @param relationship      The relationship which has been created, updated or deleted\n+     * @throws SQLException     If something goes wrong\n+     */\n+    private void updateItemsInRelationship(Context context, Relationship relationship) throws SQLException {\n+        // Since this call is performed after creating, updating or deleting the relationships, the permissions have\n+        // already been verified. The following updateItem calls can however call the\n+        // ItemService.update() functions which would fail if the user doesn't have permission on both items.\n+        // Since we allow this edits to happen under these circumstances, we need to turn off the\n+        // authorization system here so that this failure doesn't happen when the items need to be update\n+        context.turnOffAuthorisationSystem();\n+        try {\n+            int max = configurationService.getIntProperty(\"relationship.update.relateditems.max\", 5);\n+            List<Item> itemsToUpdate = new LinkedList<>();\n+            itemsToUpdate.add(relationship.getLeftItem());\n+            itemsToUpdate.add(relationship.getRightItem());\n+\n+            itemsToUpdate = getRelatedItemsForLeftItem(context, relationship.getLeftItem(),\n+                                                       relationship, itemsToUpdate, max);\n+            itemsToUpdate = getRelatedItemsForRightItem(context, relationship.getRightItem(),", "originalCommit": "9895049a99ce80ec4aa4c01c4ef45f6e8012d9a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e3b15bfa920897e7dc5d0872f6d20184571426b3", "url": "https://github.com/DSpace/DSpace/commit/e3b15bfa920897e7dc5d0872f6d20184571426b3", "message": "Bugfix indirect relationship discovery updates", "committedDate": "2020-12-16T13:36:28Z", "type": "commit"}, {"oid": "098b273a854b57f767ca8c7c05d25c41802badea", "url": "https://github.com/DSpace/DSpace/commit/098b273a854b57f767ca8c7c05d25c41802badea", "message": "Bugfix indirect relationship discovery updates", "committedDate": "2020-12-17T10:24:22Z", "type": "commit"}, {"oid": "97feeecd95a5bbc222db6147c4024fa1749153ab", "url": "https://github.com/DSpace/DSpace/commit/97feeecd95a5bbc222db6147c4024fa1749153ab", "message": "Bugfix indirect relationship discovery updates", "committedDate": "2020-12-17T10:41:02Z", "type": "commit"}, {"oid": "1eaf75e1bdf39b89bd057bf1f75c8b9262943e1b", "url": "https://github.com/DSpace/DSpace/commit/1eaf75e1bdf39b89bd057bf1f75c8b9262943e1b", "message": "Merge remote-tracking branch 'community/main' into entities-update-item-metadata-outside-rest-v2", "committedDate": "2020-12-17T11:05:27Z", "type": "commit"}, {"oid": "ea24d6168c2c6b43e0aa04a06548d906e6f53f6e", "url": "https://github.com/DSpace/DSpace/commit/ea24d6168c2c6b43e0aa04a06548d906e6f53f6e", "message": "Bugfix indirect relationship discovery updates", "committedDate": "2020-12-17T11:23:00Z", "type": "commit"}, {"oid": "71cfab142c96eab47b96ef01b57950fc71b56266", "url": "https://github.com/DSpace/DSpace/commit/71cfab142c96eab47b96ef01b57950fc71b56266", "message": "Bugfix indirect relationship discovery updates", "committedDate": "2020-12-17T11:33:55Z", "type": "commit"}, {"oid": "47888e7975d85900f2870029f582229b44040447", "url": "https://github.com/DSpace/DSpace/commit/47888e7975d85900f2870029f582229b44040447", "message": "Bugfix indirect relationship discovery updates", "committedDate": "2020-12-17T12:06:21Z", "type": "commit"}, {"oid": "fbfc352768642c9aec9270c54ca9fd146c143c7b", "url": "https://github.com/DSpace/DSpace/commit/fbfc352768642c9aec9270c54ca9fd146c143c7b", "message": "Bugfix indirect relationship discovery updates", "committedDate": "2020-12-17T12:24:12Z", "type": "commit"}, {"oid": "b0efee2a491023cb9245bedb94c8b8d083484d52", "url": "https://github.com/DSpace/DSpace/commit/b0efee2a491023cb9245bedb94c8b8d083484d52", "message": "Bugfix indirect relationship discovery updates", "committedDate": "2020-12-17T13:44:23Z", "type": "commit"}, {"oid": "c4d4b181501b8b7617af107e16e8ceaca0dbeb60", "url": "https://github.com/DSpace/DSpace/commit/c4d4b181501b8b7617af107e16e8ceaca0dbeb60", "message": "Bugfix indirect relationship discovery updates", "committedDate": "2020-12-17T14:04:12Z", "type": "commit"}, {"oid": "7b346e75849ddb5cad35620d7a5f33c91928e49b", "url": "https://github.com/DSpace/DSpace/commit/7b346e75849ddb5cad35620d7a5f33c91928e49b", "message": "Bugfix indirect relationship discovery updates", "committedDate": "2020-12-17T14:46:38Z", "type": "commit"}, {"oid": "eb47a84e01d76a039146418ca85e2d2020f63911", "url": "https://github.com/DSpace/DSpace/commit/eb47a84e01d76a039146418ca85e2d2020f63911", "message": "Docs indirect relationship discovery updates", "committedDate": "2020-12-24T09:33:45Z", "type": "commit"}, {"oid": "4cab1633e8542fe7b4c1ed335269f52aaa59c04b", "url": "https://github.com/DSpace/DSpace/commit/4cab1633e8542fe7b4c1ed335269f52aaa59c04b", "message": "75473: Test to verify implicit virtual metadata is updated +\nfix for entity type match", "committedDate": "2021-01-06T14:02:50Z", "type": "commit"}, {"oid": "54a844e033ef69d51e1e2a9b4d6c0a5e5b3855cb", "url": "https://github.com/DSpace/DSpace/commit/54a844e033ef69d51e1e2a9b4d6c0a5e5b3855cb", "message": "Merge pull request #52 from atmire/w2p-75473-Test-to-verify-implicit-virtual-metadata-is-updated\n\nW2p 75473 test to verify implicit virtual metadata is updated", "committedDate": "2021-01-07T12:49:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjE3Mg==", "url": "https://github.com/DSpace/DSpace/pull/3004#discussion_r555242172", "bodyText": "Ideally, this statement should be placed in a finally section in order to ensure it is also run if an error occurs.", "author": "tdonohue", "createdAt": "2021-01-11T18:08:11Z", "path": "dspace-api/src/main/java/org/dspace/content/RelationshipServiceImpl.java", "diffHunk": "@@ -347,6 +358,130 @@ public void delete(Context context, Relationship relationship, boolean copyToLef\n         }\n     }\n \n+\n+    /**\n+     * Utility method to ensure discovery is updated for the 2 items\n+     * This method is used when creating, modifying or deleting a relationship\n+     * The virtual metadata of the 2 items may need to be updated, so they should be re-indexed\n+     *\n+     * @param context           The relevant DSpace context\n+     * @param relationship      The relationship which has been created, updated or deleted\n+     * @throws SQLException     If something goes wrong\n+     */\n+    private void updateItemsInRelationship(Context context, Relationship relationship) throws SQLException {\n+        // Since this call is performed after creating, updating or deleting the relationships, the permissions have\n+        // already been verified. The following updateItem calls can however call the\n+        // ItemService.update() functions which would fail if the user doesn't have permission on both items.\n+        // Since we allow this edits to happen under these circumstances, we need to turn off the\n+        // authorization system here so that this failure doesn't happen when the items need to be update\n+        context.turnOffAuthorisationSystem();\n+        try {\n+            // Set a limit on the total amount of items to update at once during a relationship change\n+            int max = configurationService.getIntProperty(\"relationship.update.relateditems.max\", 20);\n+            // Set a limit on the total depth of relationships to traverse during a relationship change\n+            int maxDepth = configurationService.getIntProperty(\"relationship.update.relateditems.maxdepth\", 5);\n+            // This is the list containing all items which will have changes to their virtual metadata\n+            List<Item> itemsToUpdate = new LinkedList<>();\n+            itemsToUpdate.add(relationship.getLeftItem());\n+            itemsToUpdate.add(relationship.getRightItem());\n+\n+            if (containsVirtualMetadata(relationship.getRelationshipType().getLeftwardType())) {\n+                findModifiedDiscoveryItemsForCurrentItem(context, relationship.getLeftItem(),\n+                                           itemsToUpdate, max, 0, maxDepth);\n+            }\n+            if (containsVirtualMetadata(relationship.getRelationshipType().getRightwardType())) {\n+                findModifiedDiscoveryItemsForCurrentItem(context, relationship.getRightItem(),\n+                                            itemsToUpdate, max, 0, maxDepth);\n+            }\n+\n+            for (Item item : itemsToUpdate) {\n+                if (!item.isMetadataModified()) {\n+                    updateItem(context, item);\n+                }\n+            }\n+\n+        } catch (AuthorizeException e) {\n+            log.error(\"Authorization Exception while authorization has been disabled\", e);\n+        }\n+        context.restoreAuthSystemState();", "originalCommit": "54a844e033ef69d51e1e2a9b4d6c0a5e5b3855cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNjk0Nw==", "url": "https://github.com/DSpace/DSpace/pull/3004#discussion_r556406947", "bodyText": "This has been moved", "author": "benbosman", "createdAt": "2021-01-13T10:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5MDYwNw==", "url": "https://github.com/DSpace/DSpace/pull/3004#discussion_r555290607", "bodyText": "These two configs probably should be added to a config file (maybe a new relationships.cfg?) so that they may be described.  It looks (to me) like these settings need clarification, as both the max and the maxdepth seem to define how many items are updated via each of the left and right item relationships (and the both seem to exclude the immediate left & right item)...\nSo, if I'm understanding correctly:\n\nmax defines the maximum number of items to be updated for both the left and right items in the relationship.  So, a value of 20 means a max of 20 on the left side and a max of 20 on the right side (so a max of 40 total).\nmaxdepth is similar except specific to the depth...so a value of 5 means that a maximum of 5 levels deep will be scanned for updates on both the left side and the right side.", "author": "tdonohue", "createdAt": "2021-01-11T19:36:03Z", "path": "dspace-api/src/main/java/org/dspace/content/RelationshipServiceImpl.java", "diffHunk": "@@ -347,6 +358,130 @@ public void delete(Context context, Relationship relationship, boolean copyToLef\n         }\n     }\n \n+\n+    /**\n+     * Utility method to ensure discovery is updated for the 2 items\n+     * This method is used when creating, modifying or deleting a relationship\n+     * The virtual metadata of the 2 items may need to be updated, so they should be re-indexed\n+     *\n+     * @param context           The relevant DSpace context\n+     * @param relationship      The relationship which has been created, updated or deleted\n+     * @throws SQLException     If something goes wrong\n+     */\n+    private void updateItemsInRelationship(Context context, Relationship relationship) throws SQLException {\n+        // Since this call is performed after creating, updating or deleting the relationships, the permissions have\n+        // already been verified. The following updateItem calls can however call the\n+        // ItemService.update() functions which would fail if the user doesn't have permission on both items.\n+        // Since we allow this edits to happen under these circumstances, we need to turn off the\n+        // authorization system here so that this failure doesn't happen when the items need to be update\n+        context.turnOffAuthorisationSystem();\n+        try {\n+            // Set a limit on the total amount of items to update at once during a relationship change\n+            int max = configurationService.getIntProperty(\"relationship.update.relateditems.max\", 20);\n+            // Set a limit on the total depth of relationships to traverse during a relationship change\n+            int maxDepth = configurationService.getIntProperty(\"relationship.update.relateditems.maxdepth\", 5);", "originalCommit": "54a844e033ef69d51e1e2a9b4d6c0a5e5b3855cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwNzMzMw==", "url": "https://github.com/DSpace/DSpace/pull/3004#discussion_r556407333", "bodyText": "the config has been created, the max is not separate for left and right, so it deviates a bit from your description", "author": "benbosman", "createdAt": "2021-01-13T10:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5MDYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5NzcyNA==", "url": "https://github.com/DSpace/DSpace/pull/3004#discussion_r555297724", "bodyText": "Shouldn't we also verify that every object in between the publication and the journal also contains the virtual metadata journal.title?  That might be a more complete test that your recursion is working properly. As, I believe both Journal Volume & Journal Issues should also have journal.title...correct?", "author": "tdonohue", "createdAt": "2021-01-11T19:49:23Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RelationshipRestRepositoryIT.java", "diffHunk": "@@ -2673,4 +2684,118 @@ public void orgUnitLeftMaxCardinalityTest() throws Exception {\n             RelationshipBuilder.deleteRelationship(idRef.get());\n         }\n     }\n+    @Test\n+    public void testVirtualMdInRESTAndSolrDoc() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        // Create entity types if needed\n+        EntityType journalEntityType = entityTypeService.findByEntityType(context, \"Journal\");\n+        if (journalEntityType == null) {\n+            journalEntityType = EntityTypeBuilder.createEntityTypeBuilder(context, \"Journal\").build();\n+        }\n+        EntityType journalVolumeEntityType = entityTypeService.findByEntityType(context, \"JournalVolume\");\n+        if (journalVolumeEntityType == null) {\n+            journalVolumeEntityType = EntityTypeBuilder.createEntityTypeBuilder(context, \"JournalVolume\").build();\n+        }\n+        EntityType journalIssueEntityType = entityTypeService.findByEntityType(context, \"JournalIssue\");\n+        if (journalIssueEntityType == null) {\n+            journalIssueEntityType = EntityTypeBuilder.createEntityTypeBuilder(context, \"JournalIssue\").build();\n+        }\n+        EntityType publicationEntityType = entityTypeService.findByEntityType(context, \"Publication\");\n+        if (publicationEntityType == null) {\n+            publicationEntityType = EntityTypeBuilder.createEntityTypeBuilder(context, \"Publication\").build();\n+        }\n+\n+        // Create relationship types if needed\n+        RelationshipType isPublicationOfJournalIssue = relationshipTypeService\n+            .findbyTypesAndTypeName(context, journalIssueEntityType, publicationEntityType,\n+                \"isPublicationOfJournalIssue\", \"isJournalIssueOfPublication\");\n+        if (isPublicationOfJournalIssue == null) {\n+            isPublicationOfJournalIssue = RelationshipTypeBuilder.createRelationshipTypeBuilder(context,\n+                journalIssueEntityType, publicationEntityType, \"isPublicationOfJournalIssue\",\n+                \"isJournalIssueOfPublication\", null, null, null, null).build();\n+        }\n+        RelationshipType isIssueOfJournalVolume = relationshipTypeService\n+            .findbyTypesAndTypeName(context, journalVolumeEntityType, journalIssueEntityType,\n+                \"isIssueOfJournalVolume\", \"isJournalVolumeOfIssue\");\n+        if (isIssueOfJournalVolume == null) {\n+            isIssueOfJournalVolume = RelationshipTypeBuilder.createRelationshipTypeBuilder(context,\n+                journalVolumeEntityType, journalIssueEntityType, \"isIssueOfJournalVolume\",\n+                \"isJournalVolumeOfIssue\", null, null, null, null).build();\n+        } else {\n+            // Otherwise error in destroy methods when removing Journal Issue-Journal Volume relationship\n+            // since the rightMinCardinality constraint would be violated upon deletion\n+            isIssueOfJournalVolume.setRightMinCardinality(0);\n+        }\n+        RelationshipType isVolumeOfJournal = relationshipTypeService\n+            .findbyTypesAndTypeName(context, journalEntityType, journalVolumeEntityType,\n+                \"isVolumeOfJournal\", \"isJournalOfVolume\");\n+        if (isVolumeOfJournal == null) {\n+            isVolumeOfJournal = RelationshipTypeBuilder.createRelationshipTypeBuilder(context,\n+                journalEntityType, journalVolumeEntityType, \"isVolumeOfJournal\", \"isJournalOfVolume\",\n+                null, null, null, null).build();\n+        } else {\n+            // Otherwise error in destroy methods when removing Journal Volume - Journal relationship\n+            // since the rightMinCardinality constraint would be violated upon deletion\n+            isVolumeOfJournal.setRightMinCardinality(0);\n+        }\n+\n+        // Create virtual metadata fields if needed\n+        MetadataSchema journalSchema = metadataSchemaService.find(context, \"journal\");\n+        if (journalSchema == null) {\n+            journalSchema = metadataSchemaService.create(context, \"journal\", \"journal\");\n+        }\n+        MetadataField journalTitleField = metadataFieldService.findByString(context, \"journal.title\", '.');\n+        if (journalTitleField == null) {\n+            journalTitleField = metadataFieldService.create(context, journalSchema, \"title\", null, \"Journal Title\");\n+        }\n+\n+        // Create entity items\n+        Item journal =\n+            ItemBuilder.createItem(context, col1).withRelationshipType(\"Journal\").withTitle(\"Journal\").build();\n+        Item journalVolume =\n+            ItemBuilder.createItem(context, col1).withRelationshipType(\"JournalVolume\").withTitle(\"JournalVolume\")\n+                       .build();\n+        Item journalIssue =\n+            ItemBuilder.createItem(context, col1).withRelationshipType(\"JournalIssue\").withTitle(\"JournalIssue\")\n+                       .build();\n+        Item publication =\n+            ItemBuilder.createItem(context, col1).withRelationshipType(\"Publication\").withTitle(\"Publication\").build();\n+\n+        // Link Publication-Journal Issue\n+        RelationshipBuilder.createRelationshipBuilder(context, journalIssue, publication, isPublicationOfJournalIssue)\n+                           .build();\n+        // Link Journal Issue-Journal Volume\n+        RelationshipBuilder.createRelationshipBuilder(context, journalVolume, journalIssue, isIssueOfJournalVolume)\n+                           .build();\n+        mockSolrSearchCore.getSolr().commit(false, false);\n+\n+        // Verify Publication item via REST does not contain virtual md journal.title\n+        getClient().perform(get(\"/api/core/items/\" + publication.getID()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(jsonPath(\"$.metadata.journal.title\").doesNotExist());\n+\n+        // Verify Publication item via Solr does not contain virtual md journal.title\n+        SolrQuery solrQuery = new SolrQuery();\n+        solrQuery.setQuery(\"search.resourceid:\" + publication.getID());\n+        QueryResponse queryResponse = mockSolrSearchCore.getSolr().query(solrQuery);\n+        assertThat(queryResponse.getResults().size(), equalTo(1));\n+        assertTrue(queryResponse.getResults().get(0).getFieldValues(\"journal.title\") == null);\n+\n+        // Link Journal Volume - Journal\n+        RelationshipBuilder.createRelationshipBuilder(context, journal, journalVolume, isVolumeOfJournal).build();\n+        mockSolrSearchCore.getSolr().commit(false, false);\n+\n+        // Verify Publication item via REST does contain virtual md journal.title\n+        getClient().perform(get(\"/api/core/items/\" + publication.getID()))", "originalCommit": "54a844e033ef69d51e1e2a9b4d6c0a5e5b3855cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQwODYzNA==", "url": "https://github.com/DSpace/DSpace/pull/3004#discussion_r556408634", "bodyText": "This has been included, and it revealed the JournalVolume metadata was not indexed correctly when creating the relationship. This has been fixed as well", "author": "benbosman", "createdAt": "2021-01-13T10:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5NzcyNA=="}], "type": "inlineReview"}, {"oid": "b77b9949ee0d9f1cfd93462e04f7ed765140c081", "url": "https://github.com/DSpace/DSpace/commit/b77b9949ee0d9f1cfd93462e04f7ed765140c081", "message": "75922: Feedback PR #3004", "committedDate": "2021-01-12T16:22:18Z", "type": "commit"}]}