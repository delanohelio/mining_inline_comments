{"pr_number": 2740, "pr_title": "Assume login feature", "pr_createdAt": "2020-04-07T10:02:36Z", "pr_url": "https://github.com/DSpace/DSpace/pull/2740", "timeline": [{"oid": "4698ebcdbc87fdc9201f494c5db73e9f4cda4a5c", "url": "https://github.com/DSpace/DSpace/commit/4698ebcdbc87fdc9201f494c5db73e9f4cda4a5c", "message": "[Task 70131] added support for the login as feature and added simple test", "committedDate": "2020-03-31T13:55:36Z", "type": "commit"}, {"oid": "c12d83fb76092b2ac031ae0fcc45935eb9d3fa32", "url": "https://github.com/DSpace/DSpace/commit/c12d83fb76092b2ac031ae0fcc45935eb9d3fa32", "message": "[Task 70131] intermediate fixes error handling", "committedDate": "2020-04-01T11:37:55Z", "type": "commit"}, {"oid": "91242285bca96412b8d8e9f670c68071621fd973", "url": "https://github.com/DSpace/DSpace/commit/91242285bca96412b8d8e9f670c68071621fd973", "message": "[Task 70131] cleanup and futher implement login as feature", "committedDate": "2020-04-01T14:20:26Z", "type": "commit"}, {"oid": "1f6e1e067b36fd3db904c81e7707d6b49d88d962", "url": "https://github.com/DSpace/DSpace/commit/1f6e1e067b36fd3db904c81e7707d6b49d88d962", "message": "[Task 70140] implemented loginOnBehalfOfFeature and tests, cleaned up unneeded code in StatelessAuthenticationFilter", "committedDate": "2020-04-02T13:31:13Z", "type": "commit"}, {"oid": "3389a2c857c37d4010e22fa97ccab4c625b6d558", "url": "https://github.com/DSpace/DSpace/commit/3389a2c857c37d4010e22fa97ccab4c625b6d558", "message": "[Task 70178] applied feedback to the LoginAs feature", "committedDate": "2020-04-03T10:59:32Z", "type": "commit"}, {"oid": "fb1a90b7dced44615776db3971b0cb596261e567", "url": "https://github.com/DSpace/DSpace/commit/fb1a90b7dced44615776db3971b0cb596261e567", "message": "Removing enter in a file that we didn't need to modify", "committedDate": "2020-04-07T09:18:31Z", "type": "commit"}, {"oid": "153786cac5978edf24d1e314d4c175c6dd55f070", "url": "https://github.com/DSpace/DSpace/commit/153786cac5978edf24d1e314d4c175c6dd55f070", "message": "[Task 70131] added X-On-Behalf-Of to allowedHeaders", "committedDate": "2020-04-14T12:41:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0MzU4Ng==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r408243586", "bodyText": "I suggest to support also EPersonRest object as we will need a way to inform the UI that the loginAs can or cannot be used on a specific user (You cannot assume the login of another admin in the current version)", "author": "abollini", "createdAt": "2020-04-14T15:48:30Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/LoginOnBehalfOfFeature.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.services.ConfigurationService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The LoginOnBehalfOf feature. It can be used by Administrators when the webui.user.assumelogin property is set to true\n+ * to allow the admin to login as another user\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = LoginOnBehalfOfFeature.NAME,\n+    description = \"It can be used by administrators to login on behalf of a different user\")\n+public class LoginOnBehalfOfFeature implements AuthorizationFeature {\n+\n+    public static final String NAME = \"loginOnBehalfOf\";\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException {\n+        if (!StringUtils.equals(object.getType(), SiteRest.NAME)) {\n+            return false;\n+        }\n+        if (!authorizeService.isAdmin(context)) {\n+            return false;\n+        }\n+        if (!configurationService.getBooleanProperty(\"webui.user.assumelogin\")) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public String[] getSupportedTypes() {\n+        return new String[] { SiteRest.CATEGORY + \".\" + SiteRest.NAME };", "originalCommit": "153786cac5978edf24d1e314d4c175c6dd55f070", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0NjQ2MA==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r408246460", "bodyText": "please move this test in a dedicated class. This class should contains only general tests to validate the authorization framework and not specific features. See for instance https://github.com/DSpace/DSpace/blob/0039b309d11e3d55a2a92699b25458fe9bfc4740/dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/WithdrawFeatureRestIT.java", "author": "abollini", "createdAt": "2020-04-14T15:52:20Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -1325,4 +1341,113 @@ private String getAuthorizationID(String epersonUuid, String featureName, String\n                 + id.toString();\n     }\n \n+    @Test\n+    public void loginOnBehalfOfTest() throws Exception {", "originalCommit": "153786cac5978edf24d1e314d4c175c6dd55f070", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0ODUyOQ==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r408248529", "bodyText": "I would suggest to check for an empty list here instead than exclude the authorization object", "author": "abollini", "createdAt": "2020-04-14T15:55:03Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -1325,4 +1341,113 @@ private String getAuthorizationID(String epersonUuid, String featureName, String\n                 + id.toString();\n     }\n \n+    @Test\n+    public void loginOnBehalfOfTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        configurationService.setProperty(\"webui.user.assumelogin\", true);\n+\n+        Authorization loginOnBehalfOfAuthorization = new Authorization(admin, loginOnBehalfOf, siteRest);\n+        getClient(token).perform(get(\"/api/authz/authorizations/search/object\")\n+                                .param(\"uri\", siteUri)\n+                                .param(\"eperson\", String.valueOf(admin.getID()))\n+                                .param(\"feature\", loginOnBehalfOf.getName()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasItem(\n+                        AuthorizationMatcher.matchAuthorization(loginOnBehalfOfAuthorization))));\n+    }\n+\n+    @Test\n+    public void loginOnBehalfNonSiteObjectOfTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        parentCommunity = CommunityBuilder.createCommunity(context)\n+                                          .withName(\"Parent Community\")\n+                                          .build();\n+        context.restoreAuthSystemState();\n+\n+        CommunityRest communityRest = communityConverter.convert(parentCommunity, Projection.DEFAULT);\n+        String communityUri = utils.linkToSingleResource(communityRest, \"self\").getHref();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        configurationService.setProperty(\"webui.user.assumelogin\", true);\n+\n+        Authorization loginOnBehalfOfAuthorization = new Authorization(admin, loginOnBehalfOf, communityRest);\n+        getClient(token).perform(get(\"/api/authz/authorizations/search/object\")\n+                                     .param(\"uri\", communityUri)\n+                                     .param(\"eperson\", String.valueOf(admin.getID()))\n+                                     .param(\"feature\", loginOnBehalfOf.getName()))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.not(Matchers.hasItem(\n+                            AuthorizationMatcher.matchAuthorization(loginOnBehalfOfAuthorization)))));\n+    }\n+\n+    @Test\n+    public void loginOnBehalfOfNonAdminUserNotFoundTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        configurationService.setProperty(\"webui.user.assumelogin\", true);\n+\n+        Authorization loginOnBehalfOfAuthorization = new Authorization(eperson, loginOnBehalfOf, siteRest);\n+        getClient(token).perform(get(\"/api/authz/authorizations/search/object\")\n+                                     .param(\"uri\", siteUri)\n+                                     .param(\"eperson\", String.valueOf(eperson.getID()))\n+                                     .param(\"feature\", loginOnBehalfOf.getName()))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.not(", "originalCommit": "153786cac5978edf24d1e314d4c175c6dd55f070", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwMDUwMQ==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r412800501", "bodyText": "@abollini We can't test on an empty list here as some features are always returned by default. For example the \"AlwaysTrueFeature\". As we can't anticipate which features will be returned it would be best to check for an exclusion.", "author": "KevinVdV", "createdAt": "2020-04-22T08:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI0ODUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1MDY5MA==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r408250690", "bodyText": "we should have test to verify that we cannot loginas another admin", "author": "abollini", "createdAt": "2020-04-14T15:58:01Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -1325,4 +1341,113 @@ private String getAuthorizationID(String epersonUuid, String featureName, String\n                 + id.toString();\n     }\n \n+    @Test\n+    public void loginOnBehalfOfTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        configurationService.setProperty(\"webui.user.assumelogin\", true);\n+\n+        Authorization loginOnBehalfOfAuthorization = new Authorization(admin, loginOnBehalfOf, siteRest);\n+        getClient(token).perform(get(\"/api/authz/authorizations/search/object\")\n+                                .param(\"uri\", siteUri)\n+                                .param(\"eperson\", String.valueOf(admin.getID()))\n+                                .param(\"feature\", loginOnBehalfOf.getName()))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.hasItem(\n+                        AuthorizationMatcher.matchAuthorization(loginOnBehalfOfAuthorization))));\n+    }\n+\n+    @Test\n+    public void loginOnBehalfNonSiteObjectOfTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        parentCommunity = CommunityBuilder.createCommunity(context)\n+                                          .withName(\"Parent Community\")\n+                                          .build();\n+        context.restoreAuthSystemState();\n+\n+        CommunityRest communityRest = communityConverter.convert(parentCommunity, Projection.DEFAULT);\n+        String communityUri = utils.linkToSingleResource(communityRest, \"self\").getHref();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        configurationService.setProperty(\"webui.user.assumelogin\", true);\n+\n+        Authorization loginOnBehalfOfAuthorization = new Authorization(admin, loginOnBehalfOf, communityRest);\n+        getClient(token).perform(get(\"/api/authz/authorizations/search/object\")\n+                                     .param(\"uri\", communityUri)\n+                                     .param(\"eperson\", String.valueOf(admin.getID()))\n+                                     .param(\"feature\", loginOnBehalfOf.getName()))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.not(Matchers.hasItem(\n+                            AuthorizationMatcher.matchAuthorization(loginOnBehalfOfAuthorization)))));\n+    }\n+\n+    @Test\n+    public void loginOnBehalfOfNonAdminUserNotFoundTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        configurationService.setProperty(\"webui.user.assumelogin\", true);\n+\n+        Authorization loginOnBehalfOfAuthorization = new Authorization(eperson, loginOnBehalfOf, siteRest);\n+        getClient(token).perform(get(\"/api/authz/authorizations/search/object\")\n+                                     .param(\"uri\", siteUri)\n+                                     .param(\"eperson\", String.valueOf(eperson.getID()))\n+                                     .param(\"feature\", loginOnBehalfOf.getName()))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.not(\n+                            Matchers.hasItem(AuthorizationMatcher.matchAuthorization(loginOnBehalfOfAuthorization)))));\n+    }\n+\n+    @Test\n+    public void loginOnBehalfOfNonAdminUserAssumeLoginPropertyFalseNotFoundTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        configurationService.setProperty(\"webui.user.assumelogin\", false);\n+\n+        Authorization loginOnBehalfOfAuthorization = new Authorization(eperson, loginOnBehalfOf, siteRest);\n+        getClient(token).perform(get(\"/api/authz/authorizations/search/object\")\n+                                     .param(\"uri\", siteUri)\n+                                     .param(\"eperson\", String.valueOf(eperson.getID()))\n+                                     .param(\"feature\", loginOnBehalfOf.getName()))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.not(\n+                            Matchers.hasItem(AuthorizationMatcher.matchAuthorization(loginOnBehalfOfAuthorization)))));\n+    }\n+\n+    @Test\n+    public void loginOnBehalfOfAssumeLoginPropertyFalseNotFoundTest() throws Exception {\n+        Site site = siteService.findSite(context);\n+        SiteRest siteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(siteRest, \"self\").getHref();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        configurationService.setProperty(\"org.dspace.app.rest.authorization.AlwaysThrowExceptionFeature.turnoff\", true);\n+        configurationService.setProperty(\"webui.user.assumelogin\", false);\n+\n+        Authorization loginOnBehalfOfAuthorization = new Authorization(admin, loginOnBehalfOf, siteRest);\n+        getClient(token).perform(get(\"/api/authz/authorizations/search/object\")\n+                                     .param(\"uri\", siteUri)\n+                                     .param(\"eperson\", String.valueOf(admin.getID()))\n+                                     .param(\"feature\", loginOnBehalfOf.getName()))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$._embedded.authorizations\", Matchers.not(\n+                            Matchers.hasItem(AuthorizationMatcher.matchAuthorization(loginOnBehalfOfAuthorization)))));\n+    }\n }", "originalCommit": "153786cac5978edf24d1e314d4c175c6dd55f070", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1NzQyMQ==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r408257421", "bodyText": "this cannot be an instance attribute otherwise there are issue when multiple login request are processed at the same time", "author": "abollini", "createdAt": "2020-04-14T16:07:22Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/StatelessAuthenticationFilter.java", "diffHunk": "@@ -37,12 +46,22 @@\n \n     private static final Logger log = LoggerFactory.getLogger(StatelessAuthenticationFilter.class);\n \n+    private static final String ON_BEHALF_OF_REQUEST_PARAM = \"X-On-Behalf-Of\";\n+\n     private RestAuthenticationService restAuthenticationService;\n \n     private EPersonRestAuthenticationProvider authenticationProvider;\n \n     private RequestService requestService;\n \n+    private AuthorizeService authorizeService = AuthorizeServiceFactory.getInstance().getAuthorizeService();\n+\n+    private EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n+\n+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();\n+\n+    private boolean inErrorOnBehalfOf = false;", "originalCommit": "153786cac5978edf24d1e314d4c175c6dd55f070", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1ODIwMQ==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r408258201", "bodyText": "it is not really needed, we can simplify the code here", "author": "abollini", "createdAt": "2020-04-14T16:08:24Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/LoginAsEPersonIT.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.matcher.EPersonMatcher;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.Group;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class LoginAsEPersonIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private GroupService groupService;\n+\n+    @Before\n+    public void setup() {\n+        context.turnOffAuthorisationSystem();", "originalCommit": "153786cac5978edf24d1e314d4c175c6dd55f070", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1ODUyMA==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r408258520", "bodyText": "the turnOff is not really needed", "author": "abollini", "createdAt": "2020-04-14T16:08:52Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/LoginAsEPersonIT.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.matcher.EPersonMatcher;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.Group;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class LoginAsEPersonIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private GroupService groupService;\n+\n+    @Before\n+    public void setup() {\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"webui.user.assumelogin\", true);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void loggedInUserRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                    .param(\"projection\", \"full\"))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$._embedded.eperson\", EPersonMatcher.matchEPersonOnEmail(admin.getEmail())));\n+\n+\n+    }\n+    @Test\n+    public void loggedInAsOtherUserRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                    .param(\"projection\", \"full\")\n+                                    .header(\"X-On-Behalf-Of\", eperson.getID()))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$._embedded.eperson\",\n+                                            EPersonMatcher.matchEPersonOnEmail(eperson.getEmail())));\n+\n+\n+    }\n+\n+    @Test\n+    public void loggedInAsOtherUserNotAUuidInHeaderBadRequestRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .param(\"projection\", \"full\")\n+                                     .header(\"X-On-Behalf-Of\", \"not-a-uuid\"))\n+                        .andExpect(status().isBadRequest());\n+\n+\n+    }\n+\n+    @Test\n+    public void loggedInAsOtherUserWrongUuidInHeaderBadRequestRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .param(\"projection\", \"full\")\n+                                     .header(\"X-On-Behalf-Of\", UUID.randomUUID()))\n+                        .andExpect(status().isBadRequest());\n+\n+\n+    }\n+\n+    @Test\n+    public void loggedInAsOtherUserNoPermissionForbiddenRetrievalTest() throws Exception {\n+\n+\n+        String token = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .param(\"projection\", \"full\")\n+                                     .header(\"X-On-Behalf-Of\", eperson.getID()))\n+                        .andExpect(status().isForbidden());\n+\n+\n+    }\n+\n+\n+    @Test\n+    public void loggedInUserPropertyFalseTest() throws Exception {\n+        context.turnOffAuthorisationSystem();", "originalCommit": "153786cac5978edf24d1e314d4c175c6dd55f070", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1OTQ1NA==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r408259454", "bodyText": "I would suggest to don't revert the configuration manually here the change as this is already done in a Before method (just to avoid in future confusion in other developers)", "author": "abollini", "createdAt": "2020-04-14T16:10:11Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/LoginAsEPersonIT.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.matcher.EPersonMatcher;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.Group;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class LoginAsEPersonIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private GroupService groupService;\n+\n+    @Before\n+    public void setup() {\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"webui.user.assumelogin\", true);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void loggedInUserRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                    .param(\"projection\", \"full\"))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$._embedded.eperson\", EPersonMatcher.matchEPersonOnEmail(admin.getEmail())));\n+\n+\n+    }\n+    @Test\n+    public void loggedInAsOtherUserRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                    .param(\"projection\", \"full\")\n+                                    .header(\"X-On-Behalf-Of\", eperson.getID()))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$._embedded.eperson\",\n+                                            EPersonMatcher.matchEPersonOnEmail(eperson.getEmail())));\n+\n+\n+    }\n+\n+    @Test\n+    public void loggedInAsOtherUserNotAUuidInHeaderBadRequestRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .param(\"projection\", \"full\")\n+                                     .header(\"X-On-Behalf-Of\", \"not-a-uuid\"))\n+                        .andExpect(status().isBadRequest());\n+\n+\n+    }\n+\n+    @Test\n+    public void loggedInAsOtherUserWrongUuidInHeaderBadRequestRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .param(\"projection\", \"full\")\n+                                     .header(\"X-On-Behalf-Of\", UUID.randomUUID()))\n+                        .andExpect(status().isBadRequest());\n+\n+\n+    }\n+\n+    @Test\n+    public void loggedInAsOtherUserNoPermissionForbiddenRetrievalTest() throws Exception {\n+\n+\n+        String token = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .param(\"projection\", \"full\")\n+                                     .header(\"X-On-Behalf-Of\", eperson.getID()))\n+                        .andExpect(status().isForbidden());\n+\n+\n+    }\n+\n+\n+    @Test\n+    public void loggedInUserPropertyFalseTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"webui.user.assumelogin\", false);\n+        context.restoreAuthSystemState();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .header(\"X-On-Behalf-Of\", eperson.getID()))\n+                        .andExpect(status().isBadRequest());\n+\n+        context.turnOffAuthorisationSystem();", "originalCommit": "153786cac5978edf24d1e314d4c175c6dd55f070", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2MjA1MQ==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r408262051", "bodyText": "I would like to have an additional test using the loginAs feature in some core functionalities like\n\nworkspaceitems (to check that the item created with the loginAs are owned by the impersonated user or that the user can search for his items)\ntasks are claimed according to the loginas\nactions reserved to an admin are prevent to the loginAs (for instance trying to delete an archived item after loginas a normal user)", "author": "abollini", "createdAt": "2020-04-14T16:13:51Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/LoginAsEPersonIT.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.UUID;\n+\n+import org.dspace.app.rest.builder.EPersonBuilder;\n+import org.dspace.app.rest.matcher.EPersonMatcher;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.Group;\n+import org.dspace.eperson.service.GroupService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class LoginAsEPersonIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private GroupService groupService;\n+\n+    @Before\n+    public void setup() {\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"webui.user.assumelogin\", true);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void loggedInUserRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                    .param(\"projection\", \"full\"))\n+                    .andExpect(status().isOk())\n+                    .andExpect(jsonPath(\"$._embedded.eperson\", EPersonMatcher.matchEPersonOnEmail(admin.getEmail())));\n+\n+\n+    }\n+    @Test\n+    public void loggedInAsOtherUserRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                    .param(\"projection\", \"full\")\n+                                    .header(\"X-On-Behalf-Of\", eperson.getID()))\n+                        .andExpect(status().isOk())\n+                        .andExpect(jsonPath(\"$._embedded.eperson\",\n+                                            EPersonMatcher.matchEPersonOnEmail(eperson.getEmail())));\n+\n+\n+    }\n+\n+    @Test\n+    public void loggedInAsOtherUserNotAUuidInHeaderBadRequestRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .param(\"projection\", \"full\")\n+                                     .header(\"X-On-Behalf-Of\", \"not-a-uuid\"))\n+                        .andExpect(status().isBadRequest());\n+\n+\n+    }\n+\n+    @Test\n+    public void loggedInAsOtherUserWrongUuidInHeaderBadRequestRetrievalTest() throws Exception {\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .param(\"projection\", \"full\")\n+                                     .header(\"X-On-Behalf-Of\", UUID.randomUUID()))\n+                        .andExpect(status().isBadRequest());\n+\n+\n+    }\n+\n+    @Test\n+    public void loggedInAsOtherUserNoPermissionForbiddenRetrievalTest() throws Exception {\n+\n+\n+        String token = getAuthToken(eperson.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .param(\"projection\", \"full\")\n+                                     .header(\"X-On-Behalf-Of\", eperson.getID()))\n+                        .andExpect(status().isForbidden());\n+\n+\n+    }\n+\n+\n+    @Test\n+    public void loggedInUserPropertyFalseTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"webui.user.assumelogin\", false);\n+        context.restoreAuthSystemState();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .header(\"X-On-Behalf-Of\", eperson.getID()))\n+                        .andExpect(status().isBadRequest());\n+\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"webui.user.assumelogin\", true);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void loggedInUserOtherAdminTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson testEperson = EPersonBuilder.createEPerson(context).withEmail(\"loginasuseradmin@test.com\").build();\n+\n+\n+        Group adminGroup = groupService.findByName(context, Group.ADMIN);\n+        groupService.addMember(context, adminGroup, testEperson);\n+        context.restoreAuthSystemState();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+\n+        getClient(token).perform(get(\"/api/authn/status\")\n+                                     .header(\"X-On-Behalf-Of\", testEperson.getID()))\n+                        .andExpect(status().isBadRequest());\n+\n+\n+\n+\n+    }\n+", "originalCommit": "153786cac5978edf24d1e314d4c175c6dd55f070", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEzNDc5MQ==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r409134791", "bodyText": "This isErrorOnBehalfOf flag is really odd to me & doesn't seem to be necessary.  It seems like you should be able to refactor this code to no longer use it....ideally you should return immediately after any call to response.sendError() (to avoid anything else trying to add to the response).  So, maybe this method could be refactored to simply check for the header here, and call getOnBehalfOfAuthentication.  If that method throws an error, catch it and call sendError().  Otherwise, proceed as normal.", "author": "tdonohue", "createdAt": "2020-04-15T21:08:15Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/StatelessAuthenticationFilter.java", "diffHunk": "@@ -58,16 +77,19 @@ protected void doFilterInternal(HttpServletRequest req,\n                                     HttpServletResponse res,\n                                     FilterChain chain) throws IOException, ServletException {\n \n-        Authentication authentication = getAuthentication(req);\n+        inErrorOnBehalfOf = false;\n+        Authentication authentication = getAuthentication(req, res);\n         if (authentication != null) {\n             SecurityContextHolder.getContext().setAuthentication(authentication);\n             restAuthenticationService.invalidateAuthenticationCookie(res);\n         }\n-\n+        if (inErrorOnBehalfOf) {\n+            return;\n+        }", "originalCommit": "153786cac5978edf24d1e314d4c175c6dd55f070", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cf61ae987e09c275146aa86c88b1e075d2241213", "url": "https://github.com/DSpace/DSpace/commit/cf61ae987e09c275146aa86c88b1e075d2241213", "message": "[Task 70478] applied feedback to the login as eperson functionality and tests", "committedDate": "2020-04-22T07:11:28Z", "type": "commit"}, {"oid": "3c28c6550148f98f3144bc90126908f502286a55", "url": "https://github.com/DSpace/DSpace/commit/3c28c6550148f98f3144bc90126908f502286a55", "message": "[Task 70478] applied feedback to the login as feature", "committedDate": "2020-04-22T10:56:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczMDI4MA==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r419730280", "bodyText": "Could we add some comments to this method. It's not well described currently.  It looks like it's covering some scenarios that are not described in the class JavaDocs.  Namely, it looks like you have LoginOnBehalfOf  rights if:\n\nFeature is enabled, you request it on a Site and you are an admin  (I'm not sure what Site LoginOnBehalfOf means...does this mean you can have this right on every user?  What about other users that are also Admins?)\nOr, Feature is enabled, you request it on an EPerson and you are NOT that EPerson and that EPerson is NOT and Admin.\n\nAm I reading the code correctly?  The logic here is a bit hard to read, so it'd be good to describe in a comment. or two.", "author": "tdonohue", "createdAt": "2020-05-04T21:09:39Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/LoginOnBehalfOfFeature.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization.impl;\n+\n+import java.sql.SQLException;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationFeature;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;\n+import org.dspace.app.rest.model.BaseObjectRest;\n+import org.dspace.app.rest.model.EPersonRest;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.authorize.service.AuthorizeService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.services.ConfigurationService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+/**\n+ * The LoginOnBehalfOf feature. It can be used by Administrators when the webui.user.assumelogin property is set to true\n+ * to allow the admin to login as another user\n+ */\n+@Component\n+@AuthorizationFeatureDocumentation(name = LoginOnBehalfOfFeature.NAME,\n+    description = \"It can be used by administrators to login on behalf of a different user\")\n+public class LoginOnBehalfOfFeature implements AuthorizationFeature {\n+\n+    public static final String NAME = \"loginOnBehalfOf\";\n+\n+    @Autowired\n+    private AuthorizeService authorizeService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private EPersonService ePersonService;\n+\n+    @Override\n+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException {\n+        if (!StringUtils.equals(object.getType(), SiteRest.NAME) &&\n+            !StringUtils.equals(object.getType(), EPersonRest.NAME)) {\n+            return false;\n+        }\n+        if (!authorizeService.isAdmin(context)) {\n+            return false;\n+        }\n+        if (!configurationService.getBooleanProperty(\"webui.user.assumelogin\")) {\n+            return false;\n+        }\n+        if (StringUtils.equals(object.getType(), EPersonRest.NAME)) {\n+            EPersonRest ePersonRest = (EPersonRest) object;\n+            EPerson currentUser = context.getCurrentUser();\n+            if (StringUtils.equalsIgnoreCase(currentUser.getEmail(), ePersonRest.getEmail())) {\n+                return false;\n+            }\n+\n+            EPerson ePerson = ePersonService.findByEmail(context, ePersonRest.getEmail());\n+            if (authorizeService.isAdmin(context, ePerson)) {\n+                return false;", "originalCommit": "3c28c6550148f98f3144bc90126908f502286a55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczNzE1OA==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r419737158", "bodyText": "This entire Pair logic seems really odd to me.  Why not just have getAuthentication() return either Authentication or null?  If an error needs to occur, then getAuthentication() should throw an exception, which then can be caught in this method and turned into a response.sendError().\nI don't see a scenario where you'd ever want to return both an Authentication and an error (which is what this Pair logic seems to imply could occur).  So, there's no need to have this Pair, as either you have an Authentication, it's null, or you throw an error.  Those can all be handled just via normal error handling scenarios.", "author": "tdonohue", "createdAt": "2020-05-04T21:23:25Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/StatelessAuthenticationFilter.java", "diffHunk": "@@ -58,16 +76,34 @@ protected void doFilterInternal(HttpServletRequest req,\n                                     HttpServletResponse res,\n                                     FilterChain chain) throws IOException, ServletException {\n \n-        Authentication authentication = getAuthentication(req);\n+        Pair<Authentication, Boolean> pair = getAuthentication(req, res);\n+        Authentication authentication = pair.getLeft();\n         if (authentication != null) {\n             SecurityContextHolder.getContext().setAuthentication(authentication);\n             restAuthenticationService.invalidateAuthenticationCookie(res);\n         }\n-\n+        if (pair.getRight()) {\n+            return;\n+        }", "originalCommit": "3c28c6550148f98f3144bc90126908f502286a55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTczODg0Ng==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r419738846", "bodyText": "This also seems a bit odd to me.  Why would you not return an error when an error occurred?  This seems to be essentially a no-op if a SQLException happens (or am I missing something)?", "author": "tdonohue", "createdAt": "2020-05-04T21:26:41Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/StatelessAuthenticationFilter.java", "diffHunk": "@@ -81,15 +117,69 @@ private Authentication getAuthentication(HttpServletRequest request) {\n \n                 //Get the Spring authorities for this eperson\n                 List<GrantedAuthority> authorities = authenticationProvider.getGrantedAuthorities(context, eperson);\n+                String onBehalfOfParameterValue = request.getHeader(ON_BEHALF_OF_REQUEST_PARAM);\n+                if (onBehalfOfParameterValue != null) {\n+                    if (configurationService.getBooleanProperty(\"webui.user.assumelogin\")) {\n+                        return getOnBehalfOfAuthentication(context, onBehalfOfParameterValue, res);\n+                    } else {\n+                        res.sendError(HttpServletResponse.SC_BAD_REQUEST, \"The login as feature is not allowed\" +\n+                            \" due to the current configuration\");\n+                        return Pair.of(null, true);\n+                    }\n+                }\n \n                 //Return the Spring authentication object\n-                return new DSpaceAuthentication(eperson.getEmail(), authorities);\n+                return Pair.of(new DSpaceAuthentication(eperson.getEmail(), authorities), false);\n             } else {\n-                return null;\n+                return Pair.of(null, false);\n+            }\n+        } else {\n+            if (request.getHeader(ON_BEHALF_OF_REQUEST_PARAM) != null) {\n+                res.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Only admins are allowed to use the\" +\n+                    \" login as feature\");\n+                return Pair.of(null, true);\n             }\n         }\n \n-        return null;\n+        return Pair.of(null, false);\n+    }\n+\n+    private Pair<Authentication, Boolean> getOnBehalfOfAuthentication(Context context, String onBehalfOfParameterValue,\n+                                                       HttpServletResponse res) throws IOException {\n+\n+        try {\n+            if (!authorizeService.isAdmin(context)) {\n+                res.sendError(HttpServletResponse.SC_FORBIDDEN, \"Only admins are allowed to use the\" +\n+                    \" login as feature\");\n+                return Pair.of(null, true);\n+            }\n+            UUID epersonUuid = UUIDUtils.fromString(onBehalfOfParameterValue);\n+            if (epersonUuid == null) {\n+                res.sendError(HttpServletResponse.SC_BAD_REQUEST, \"The given UUID in the X-On-Behalf-Of header \" +\n+                    \"was not a proper UUID\");\n+                return Pair.of(null, true);\n+            }\n+            EPerson onBehalfOfEPerson = ePersonService.find(context, epersonUuid);\n+            if (onBehalfOfEPerson == null) {\n+                res.sendError(HttpServletResponse.SC_BAD_REQUEST, \"The given UUID in the X-On-Behalf-Of header \" +\n+                    \"was not a proper EPerson UUID\");\n+                return Pair.of(null, true);\n+            }\n+            if (!authorizeService.isAdmin(context, onBehalfOfEPerson)) {\n+                requestService.setCurrentUserId(epersonUuid);\n+                context.switchContextUser(onBehalfOfEPerson);\n+                return Pair.of(new DSpaceAuthentication(onBehalfOfEPerson.getEmail(),\n+                                authenticationProvider.getGrantedAuthorities(context, onBehalfOfEPerson)), false);\n+            } else {\n+                res.sendError(HttpServletResponse.SC_BAD_REQUEST, \"You're unable to use the login as feature to log \" +\n+                    \"in as another admin\");\n+                return Pair.of(null, true);\n+            }\n+\n+        } catch (SQLException e) {\n+            log.error(e.getMessage(), e);\n+            return Pair.of(null, false);", "originalCommit": "3c28c6550148f98f3144bc90126908f502286a55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cb6c5ccccc8e280d81345387c966dd5c8512370f", "url": "https://github.com/DSpace/DSpace/commit/cb6c5ccccc8e280d81345387c966dd5c8512370f", "message": "[Task 70763] applied community feedback to the LoginOnBehalfOf feature", "committedDate": "2020-05-07T07:31:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzMzQ2OA==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r421533468", "bodyText": "the change in this class can be removed now that the test are moved to a dedicated class", "author": "abollini", "createdAt": "2020-05-07T14:09:02Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/AuthorizationRestRepositoryIT.java", "diffHunk": "@@ -125,6 +130,7 @@ public void setUp() throws Exception {\n         trueForLoggedUsers = authorizationFeatureService.find(TrueForLoggedUsersFeature.NAME);\n         trueForTestUsers = authorizationFeatureService.find(TrueForTestUsersFeature.NAME);\n         trueForUsersInGroupTest = authorizationFeatureService.find(TrueForUsersInGroupTestFeature.NAME);\n+        loginOnBehalfOf = authorizationFeatureService.find(LoginOnBehalfOfFeature.NAME);", "originalCommit": "cb6c5ccccc8e280d81345387c966dd5c8512370f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxNDAyMQ==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r422014021", "bodyText": "Good catch, we removed it.", "author": "KevinVdV", "createdAt": "2020-05-08T08:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzMzQ2OA=="}], "type": "inlineReview"}, {"oid": "ece341e7ba7409e4973a22f9ac21f16f3231b422", "url": "https://github.com/DSpace/DSpace/commit/ece341e7ba7409e4973a22f9ac21f16f3231b422", "message": "Removed unused AuthorizationFeature variable", "committedDate": "2020-05-08T08:21:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4ODkwNw==", "url": "https://github.com/DSpace/DSpace/pull/2740#discussion_r422188907", "bodyText": "These JavaDocs are now incorrect as they describe how the method worked prior to the refactor. The Pair was removed.  @KevinVdV could we get these updated quickly?  This is the last thing I see that needs updating before we can merge.", "author": "tdonohue", "createdAt": "2020-05-08T14:52:05Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/security/StatelessAuthenticationFilter.java", "diffHunk": "@@ -58,16 +77,45 @@ protected void doFilterInternal(HttpServletRequest req,\n                                     HttpServletResponse res,\n                                     FilterChain chain) throws IOException, ServletException {\n \n-        Authentication authentication = getAuthentication(req);\n+        Authentication authentication = null;\n+        try {\n+            authentication = getAuthentication(req, res);\n+        } catch (AuthorizeException e) {\n+            res.sendError(HttpServletResponse.SC_UNAUTHORIZED, e.getMessage());\n+            log.error(e.getMessage(), e);\n+            return;\n+        } catch (IllegalArgumentException | SQLException e) {\n+            res.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());\n+            log.error(e.getMessage(), e);\n+            return;\n+        } catch (AccessDeniedException e) {\n+            res.sendError(HttpServletResponse.SC_FORBIDDEN, e.getMessage());\n+            log.error(e.getMessage(), e);\n+            return;\n+        }\n         if (authentication != null) {\n             SecurityContextHolder.getContext().setAuthentication(authentication);\n             restAuthenticationService.invalidateAuthenticationCookie(res);\n         }\n-\n         chain.doFilter(req, res);\n     }\n \n-    private Authentication getAuthentication(HttpServletRequest request) {\n+    /**\n+     * This method will return a Pair instance with an Authentication object as the left side of the pair and a Boolean\n+     * for the right side of the pair which will indicate whether there was an error in the OnBehalfOf parsing or not\n+     * The Authentication object will be attempted to be for the eperson with the uuid in the parameter. Incase\n+     * this is able to be done properly, we'll be giving a pair back with the EPerson Authentication in the left side\n+     * and a false boolean as the right side.\n+     * If the Authentication object returned is not null, we'll be logged in as this EPerson given through from the\n+     * request. If the Boolean is true, we'll stop the execution and show a BadRequest error\n+     * @param request       The current request\n+     * @param res           The current response\n+     * @return              A Pair instance with the Authentication object on the left side and the boolean\n+     *                      indicating errors on the right side\n+     * @throws IOException  If something goes wrong\n+     */\n+    private Authentication getAuthentication(HttpServletRequest request, HttpServletResponse res)", "originalCommit": "ece341e7ba7409e4973a22f9ac21f16f3231b422", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d7cbe8c90ae70aa4096f0dc2e67c676366d391d8", "url": "https://github.com/DSpace/DSpace/commit/d7cbe8c90ae70aa4096f0dc2e67c676366d391d8", "message": "Updated javadoc on StatelessAuthenticationFilter#getAuthentication", "committedDate": "2020-05-11T06:33:39Z", "type": "commit"}]}