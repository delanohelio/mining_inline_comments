{"pr_number": 2739, "pr_title": "[DS-3940] SHERPA API v2 refactor", "pr_createdAt": "2020-04-07T03:48:33Z", "pr_url": "https://github.com/DSpace/DSpace/pull/2739", "timeline": [{"oid": "1dc76cb380f37270f0c3e9ca845989407acf97e6", "url": "https://github.com/DSpace/DSpace/commit/1dc76cb380f37270f0c3e9ca845989407acf97e6", "message": "[DS-3940] SHERPA API v2 refactor", "committedDate": "2020-04-07T03:34:35Z", "type": "commit"}, {"oid": "2a7b24963dfb12eec0a6caf29c4318083fafe070", "url": "https://github.com/DSpace/DSpace/commit/2a7b24963dfb12eec0a6caf29c4318083fafe070", "message": "[DS-3940] Apply missing license header for one bean class", "committedDate": "2020-04-07T04:10:58Z", "type": "commit"}, {"oid": "a9c13d586c483c5fa7699c66a74471b05b3df133", "url": "https://github.com/DSpace/DSpace/commit/a9c13d586c483c5fa7699c66a74471b05b3df133", "message": "[DS-3940] Revert \"getISSNs\" to return LinkedHashSet to avoid duplicates", "committedDate": "2020-04-08T00:32:35Z", "type": "commit"}, {"oid": "476f0fd04d36deacbe5414d43254defb37030f8b", "url": "https://github.com/DSpace/DSpace/commit/476f0fd04d36deacbe5414d43254defb37030f8b", "message": "[DS-3940] Changes to handle multiple ISSN queries / errors in JSPUI", "committedDate": "2020-04-10T00:34:53Z", "type": "commit"}, {"oid": "b4edbc2a1bc4966f832385ea80336e2eeb523115", "url": "https://github.com/DSpace/DSpace/commit/b4edbc2a1bc4966f832385ea80336e2eeb523115", "message": "[DS-3940] Remove unused imports", "committedDate": "2020-04-10T00:48:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAwOTY1MQ==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r408009651", "bodyText": "The \"InputStreamReader\" should be closed.", "author": "KevinVdV", "createdAt": "2020-04-14T09:50:24Z", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAResponse.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.log4j.Logger;\n+import org.dspace.core.I18nUtil;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+\n+/**\n+ * Model class for the SHERPAv2 API (JSON) response\n+ * The structure and approached used is quite different to the simple v1 API used previously\n+ * \n+ * @author Kim Shepherd\n+ * \n+ */\n+public class SHERPAResponse\n+{\n+    private boolean error;\n+    private String message;\n+    private String license;\n+    private String licenseURL;\n+    private String disclaimer;\n+    private SHERPASystemMetadata metadata;\n+    private List<SHERPAJournal> journals;\n+\n+\n+    // Internal Sherpa ID\n+    private int id;\n+\n+    // SHERPA URI (the human page version of this API response)\n+\n+    private String uri;\n+\n+    // Journal / publisher URL\n+    private String journalUrl;\n+\n+    public enum SHERPAFormat {\n+        XML, JSON\n+    };\n+\n+    private static Logger log = Logger.getLogger(SHERPAResponse.class);\n+\n+    public SHERPAResponse(InputStream inputStream) {\n+        this(inputStream, SHERPAFormat.XML);\n+    }\n+\n+    public SHERPAResponse(InputStream input, SHERPAFormat format) {\n+        if (format == SHERPAFormat.JSON) {\n+            parseJSON(input);\n+        }\n+    }\n+\n+    /**\n+     * Parse the SHERPA v2 API JSON and construct Romeo policy data for display\n+     * @param jsonData\n+     */\n+    private void parseJSON(InputStream jsonData) {\n+        JSONTokener jsonTokener = new JSONTokener(new InputStreamReader(jsonData));", "originalCommit": "b4edbc2a1bc4966f832385ea80336e2eeb523115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU2Njg2Mw==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r410566863", "bodyText": "Thanks, I have done this in a finally block (and the main methods now throw IOException)", "author": "kshepherd", "createdAt": "2020-04-18T02:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAwOTY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxMDE4NQ==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r408010185", "bodyText": "The \"responseBody.getContent()\" returns an inputStream, this one should be closed.", "author": "KevinVdV", "createdAt": "2020-04-14T09:51:22Z", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/SHERPAService.java", "diffHunk": "@@ -89,7 +104,7 @@ public SHERPAResponse searchByJournalISSN(String query)\n                 HttpEntity responseBody = response.getEntity();\n \n                 if (null != responseBody)\n-                    sherpaResponse = new SHERPAResponse(responseBody.getContent());\n+                    sherpaResponse = new SHERPAResponse(responseBody.getContent(), SHERPAResponse.SHERPAFormat.JSON);", "originalCommit": "b4edbc2a1bc4966f832385ea80336e2eeb523115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU2NjkxMA==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r410566910", "bodyText": "Thanks, I have done this in a finally block (and the main methods now throw IOException)", "author": "kshepherd", "createdAt": "2020-04-18T02:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxMDE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwMzMzOQ==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r415703339", "bodyText": "@kshepherd Did you forget to commit the fix here ? Because this class wasn't altered recently.", "author": "KevinVdV", "createdAt": "2020-04-27T10:40:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxMDE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwODUwNg==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r416308506", "bodyText": "Thanks, I've pushed a change now", "author": "kshepherd", "createdAt": "2020-04-28T03:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxMDE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxNTE3Ng==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r408015176", "bodyText": "This variable is parsed here, but isn't used anywhere. Maybe we should create a getter for this, it will make things easier if we ever which to use it.", "author": "KevinVdV", "createdAt": "2020-04-14T09:59:20Z", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAResponse.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.log4j.Logger;\n+import org.dspace.core.I18nUtil;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+\n+/**\n+ * Model class for the SHERPAv2 API (JSON) response\n+ * The structure and approached used is quite different to the simple v1 API used previously\n+ * \n+ * @author Kim Shepherd\n+ * \n+ */\n+public class SHERPAResponse\n+{\n+    private boolean error;\n+    private String message;\n+    private String license;\n+    private String licenseURL;\n+    private String disclaimer;\n+    private SHERPASystemMetadata metadata;\n+    private List<SHERPAJournal> journals;\n+\n+\n+    // Internal Sherpa ID\n+    private int id;\n+\n+    // SHERPA URI (the human page version of this API response)\n+\n+    private String uri;\n+\n+    // Journal / publisher URL\n+    private String journalUrl;\n+\n+    public enum SHERPAFormat {\n+        XML, JSON\n+    };\n+\n+    private static Logger log = Logger.getLogger(SHERPAResponse.class);\n+\n+    public SHERPAResponse(InputStream inputStream) {\n+        this(inputStream, SHERPAFormat.XML);\n+    }\n+\n+    public SHERPAResponse(InputStream input, SHERPAFormat format) {\n+        if (format == SHERPAFormat.JSON) {\n+            parseJSON(input);\n+        }\n+    }\n+\n+    /**\n+     * Parse the SHERPA v2 API JSON and construct Romeo policy data for display\n+     * @param jsonData\n+     */\n+    private void parseJSON(InputStream jsonData) {\n+        JSONTokener jsonTokener = new JSONTokener(new InputStreamReader(jsonData));\n+        JSONObject httpResponse;\n+        try {\n+            httpResponse = new JSONObject(jsonTokener);\n+            if (httpResponse.has(\"items\")) {\n+                JSONArray items = httpResponse.getJSONArray(\"items\");\n+                // items array is search results, *not* journals or publishers - they are listed for each item\n+                // - however, we only ever want one result since we're passing an \"equals ISSN\" query\n+                if (items.length() > 0) {\n+                    metadata = new SHERPASystemMetadata();\n+                    this.journals = new LinkedList<>();\n+\n+                    for (int itemIndex = 0; itemIndex < items.length(); itemIndex++) {\n+                        List<SHERPAPublisher> sherpaPublishers = new LinkedList<>();\n+                        List<SHERPAPublisherPolicy> policies = new ArrayList<>();\n+                        SHERPAPublisher sherpaPublisher = new SHERPAPublisher();\n+                        SHERPAJournal sherpaJournal = new SHERPAJournal();\n+\n+                        JSONObject item = items.getJSONObject(0);\n+\n+                        if (item.has(\"system_metadata\")) {\n+                            JSONObject systemMetadata = item.getJSONObject(\"system_metadata\");\n+                            if (systemMetadata.has(\"uri\")) {\n+                                this.uri = systemMetadata.getString(\"uri\");\n+                                metadata.setUri(this.uri);\n+                            } else {\n+                                log.error(\"SHERPA URI missing for API response item\");\n+                            }\n+                            if (systemMetadata.has(\"id\")) {\n+                                this.id = systemMetadata.getInt(\"id\");\n+                                metadata.setId(this.id);\n+                            } else {\n+                                log.error(\"SHERPA internal ID missing for API response item\");\n+                            }\n+                            // Get date created and added - DSpace expects this in the publisher object, though\n+                            if (systemMetadata.has(\"date_created\")) {\n+                                metadata.setDateCreated(systemMetadata.getString(\"date_created\"));\n+                            }\n+                            if (systemMetadata.has(\"date_modified\")) {\n+                                metadata.setDateModified(systemMetadata.getString(\"date_modified\"));\n+                            }\n+                            // Is this item publicly visible?\n+                            if (systemMetadata.has(\"publicly_visible\")) {\n+                                metadata.setPubliclyVisible (\"yes\".equals(systemMetadata\n+                                    .getString(\"publicly_visible\")));\n+                            }\n+                            // Is this item listed in the DOAJ?\n+                            if (systemMetadata.has(\"listed_in_doaj\")) {\n+                                metadata.setPubliclyVisible (\"yes\".equals(systemMetadata\n+                                    .getString(\"listed_in_doaj\")));\n+                            }\n+                        }\n+                        if (item.has(\"url\")) {\n+                            this.journalUrl = item.getString(\"url\");", "originalCommit": "b4edbc2a1bc4966f832385ea80336e2eeb523115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU2Njk1Mw==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r410566953", "bodyText": "Removed", "author": "kshepherd", "createdAt": "2020-04-18T02:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAxNTE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA0Mjg1MA==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r408042850", "bodyText": "Maybe we should leave this variable out of here, we aren't using it in the code & Sherpa Romeo themselves aren't offering it up anymore.", "author": "KevinVdV", "createdAt": "2020-04-14T10:47:26Z", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAPublisher.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+public class SHERPAPublisher {\n+    private String name;\n+    private String relationshipType;\n+    private String country;\n+    private String uri;\n+    private int publicationCount;\n+\n+    // this is not technically in the same place in SHERPA data model but it makes more sense to apply it here\n+    // is it is treated as a 'special case' - just for printing links to paid OA access policies\n+    private String paidAccessDescription;\n+    private String paidAccessUrl;\n+\n+    // This is deprecated - we should not rely on 'SHERPA ROMeO colour' anymore and it is a bit dangerous\n+    // to try and calculated it ourselves, now that it is no longer supplied\n+    private String romeoColour;", "originalCommit": "b4edbc2a1bc4966f832385ea80336e2eeb523115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU2NzAxNw==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r410567017", "bodyText": "Removed", "author": "kshepherd", "createdAt": "2020-04-18T02:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA0Mjg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA0NzMzNA==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r408047334", "bodyText": "Can we split up this method into smaller parts ? This method is really big & when we split it up it should be easier to navigate to where certain sections are parsed (if we ever want to make changes). The javadoc for these smaller methods could then also display an example of the JSON it is parsing.", "author": "KevinVdV", "createdAt": "2020-04-14T10:55:49Z", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAResponse.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.log4j.Logger;\n+import org.dspace.core.I18nUtil;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+\n+/**\n+ * Model class for the SHERPAv2 API (JSON) response\n+ * The structure and approached used is quite different to the simple v1 API used previously\n+ * \n+ * @author Kim Shepherd\n+ * \n+ */\n+public class SHERPAResponse\n+{\n+    private boolean error;\n+    private String message;\n+    private String license;\n+    private String licenseURL;\n+    private String disclaimer;\n+    private SHERPASystemMetadata metadata;\n+    private List<SHERPAJournal> journals;\n+\n+\n+    // Internal Sherpa ID\n+    private int id;\n+\n+    // SHERPA URI (the human page version of this API response)\n+\n+    private String uri;\n+\n+    // Journal / publisher URL\n+    private String journalUrl;\n+\n+    public enum SHERPAFormat {\n+        XML, JSON\n+    };\n+\n+    private static Logger log = Logger.getLogger(SHERPAResponse.class);\n+\n+    public SHERPAResponse(InputStream inputStream) {\n+        this(inputStream, SHERPAFormat.XML);\n+    }\n+\n+    public SHERPAResponse(InputStream input, SHERPAFormat format) {\n+        if (format == SHERPAFormat.JSON) {\n+            parseJSON(input);\n+        }\n+    }\n+\n+    /**\n+     * Parse the SHERPA v2 API JSON and construct Romeo policy data for display\n+     * @param jsonData\n+     */\n+    private void parseJSON(InputStream jsonData) {", "originalCommit": "b4edbc2a1bc4966f832385ea80336e2eeb523115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU2NzQ4MA==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r410567480", "bodyText": "I've split this method into parts, so there are now separate methods for parsing PublisherPolicy, PermittedVersion, Publisher, Journal, and SystemMetadata. I have had to slightly rework some other logic and models to handle the change in scope, but it is working the same and hopefully is easier to follow. I also added javadoc annotation for each method.", "author": "kshepherd", "createdAt": "2020-04-18T02:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA0NzMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA0ODExOA==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r408048118", "bodyText": "What is the purpose of this section ? These variables aren't coming from our Sherpa response & are just retrieved from the messages.properties while the actual getters of these aren't used.", "author": "KevinVdV", "createdAt": "2020-04-14T10:57:20Z", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/v2/SHERPAResponse.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.sherpa.v2;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.log4j.Logger;\n+import org.dspace.core.I18nUtil;\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+import org.json.JSONTokener;\n+\n+/**\n+ * Model class for the SHERPAv2 API (JSON) response\n+ * The structure and approached used is quite different to the simple v1 API used previously\n+ * \n+ * @author Kim Shepherd\n+ * \n+ */\n+public class SHERPAResponse\n+{\n+    private boolean error;\n+    private String message;\n+    private String license;\n+    private String licenseURL;\n+    private String disclaimer;\n+    private SHERPASystemMetadata metadata;\n+    private List<SHERPAJournal> journals;\n+\n+\n+    // Internal Sherpa ID\n+    private int id;\n+\n+    // SHERPA URI (the human page version of this API response)\n+\n+    private String uri;\n+\n+    // Journal / publisher URL\n+    private String journalUrl;\n+\n+    public enum SHERPAFormat {\n+        XML, JSON\n+    };\n+\n+    private static Logger log = Logger.getLogger(SHERPAResponse.class);\n+\n+    public SHERPAResponse(InputStream inputStream) {\n+        this(inputStream, SHERPAFormat.XML);\n+    }\n+\n+    public SHERPAResponse(InputStream input, SHERPAFormat format) {\n+        if (format == SHERPAFormat.JSON) {\n+            parseJSON(input);\n+        }\n+    }\n+\n+    /**\n+     * Parse the SHERPA v2 API JSON and construct Romeo policy data for display\n+     * @param jsonData\n+     */\n+    private void parseJSON(InputStream jsonData) {\n+        JSONTokener jsonTokener = new JSONTokener(new InputStreamReader(jsonData));\n+        JSONObject httpResponse;\n+        try {\n+            httpResponse = new JSONObject(jsonTokener);\n+            if (httpResponse.has(\"items\")) {\n+                JSONArray items = httpResponse.getJSONArray(\"items\");\n+                // items array is search results, *not* journals or publishers - they are listed for each item\n+                // - however, we only ever want one result since we're passing an \"equals ISSN\" query\n+                if (items.length() > 0) {\n+                    metadata = new SHERPASystemMetadata();\n+                    this.journals = new LinkedList<>();\n+\n+                    for (int itemIndex = 0; itemIndex < items.length(); itemIndex++) {\n+                        List<SHERPAPublisher> sherpaPublishers = new LinkedList<>();\n+                        List<SHERPAPublisherPolicy> policies = new ArrayList<>();\n+                        SHERPAPublisher sherpaPublisher = new SHERPAPublisher();\n+                        SHERPAJournal sherpaJournal = new SHERPAJournal();\n+\n+                        JSONObject item = items.getJSONObject(0);\n+\n+                        if (item.has(\"system_metadata\")) {\n+                            JSONObject systemMetadata = item.getJSONObject(\"system_metadata\");\n+                            if (systemMetadata.has(\"uri\")) {\n+                                this.uri = systemMetadata.getString(\"uri\");\n+                                metadata.setUri(this.uri);\n+                            } else {\n+                                log.error(\"SHERPA URI missing for API response item\");\n+                            }\n+                            if (systemMetadata.has(\"id\")) {\n+                                this.id = systemMetadata.getInt(\"id\");\n+                                metadata.setId(this.id);\n+                            } else {\n+                                log.error(\"SHERPA internal ID missing for API response item\");\n+                            }\n+                            // Get date created and added - DSpace expects this in the publisher object, though\n+                            if (systemMetadata.has(\"date_created\")) {\n+                                metadata.setDateCreated(systemMetadata.getString(\"date_created\"));\n+                            }\n+                            if (systemMetadata.has(\"date_modified\")) {\n+                                metadata.setDateModified(systemMetadata.getString(\"date_modified\"));\n+                            }\n+                            // Is this item publicly visible?\n+                            if (systemMetadata.has(\"publicly_visible\")) {\n+                                metadata.setPubliclyVisible (\"yes\".equals(systemMetadata\n+                                    .getString(\"publicly_visible\")));\n+                            }\n+                            // Is this item listed in the DOAJ?\n+                            if (systemMetadata.has(\"listed_in_doaj\")) {\n+                                metadata.setPubliclyVisible (\"yes\".equals(systemMetadata\n+                                    .getString(\"listed_in_doaj\")));\n+                            }\n+                        }\n+                        if (item.has(\"url\")) {\n+                            this.journalUrl = item.getString(\"url\");\n+                        }\n+\n+                        boolean inDOAJ = false;\n+                        if (item.has(\"listed_in_doaj\")) {\n+                            inDOAJ = (\"yes\".equals(item.getString(\"listed_in_doaj\")));\n+                        }\n+\n+                        // Parse \"publisher policy\"\n+                        // note - most of the information that was previously under 'publisher' is now under here\n+                        if (item.has(\"publisher_policy\")) {\n+\n+                            // Parse main publisher policies node\n+                            JSONArray publisherPolicies = item.getJSONArray(\"publisher_policy\");\n+                            for (int i = 0; i < publisherPolicies.length(); i++) {\n+\n+                                JSONObject policy = publisherPolicies.getJSONObject(i);\n+\n+                                // Make my new PublisherPolicy object\n+                                SHERPAPublisherPolicy sherpaPublisherPolicy = new SHERPAPublisherPolicy();\n+\n+                                String moniker = null;\n+                                if (policy.has(\"internal_moniker\")) {\n+                                    moniker = policy.getString(\"internal_moniker\");\n+                                    sherpaPublisherPolicy.setInternalMoniker(moniker);\n+                                }\n+                                log.debug(\"Parsing publisher_policy number \" + i + \" (\" + moniker + \")\");\n+\n+                                // This seems to be usually policy(ies) for the journal proper\n+                                // and then an \"Open access option\" which contains some of the info\n+                                // that the 'paidaccess' node in the old API used to contain\n+                                // Look for: internal_moniker = \"Open access option\"\n+                                // Check if this is OA options (Paid Access) or not\n+                                if (\"Open access option\".equalsIgnoreCase(moniker)) {\n+                                    log.debug(\"This is the Open access options policy - a special case\");\n+                                    if (policy.has(\"urls\")) {\n+                                        JSONArray urls = policy.getJSONArray(\"urls\");\n+                                        for (int u = 0; u < urls.length(); u++) {\n+                                            JSONObject url = urls.getJSONObject(u);\n+                                            if (url.has(\"description\") &&\n+                                                \"Open Access\".equalsIgnoreCase(url.getString(\"description\"))) {\n+                                                log.debug(\"Found OA paid access url: \" + url.getString(\"url\"));\n+                                                sherpaPublisher.setPaidAccessDescription(url.getString(\"description\"));\n+                                                sherpaPublisher.setPaidAccessUrl(url.getString(\"url\"));\n+                                                break;\n+                                            }\n+                                        }\n+                                    }\n+                                    // Continue the loop here - this \"policy\" is a bit different and we\n+                                    // don't want to overwrite the other conditions, etc.\n+                                    continue;\n+                                }\n+\n+                                // URLs (used to be Copyright Links)\n+                                if (policy.has(\"urls\")) {\n+                                    JSONArray urls = policy.getJSONArray(\"urls\");\n+                                    Map<String, String> copyrightLinks = new TreeMap<>();\n+                                    for (int u = 0; u < urls.length(); u++) {\n+                                        JSONObject url = urls.getJSONObject(u);\n+                                        if (url.has(\"description\") && url.has(\"url\")) {\n+                                            log.debug(\"Setting copyright URL: \" + url.getString(\"url\"));\n+                                            copyrightLinks.put(url.getString(\"url\"), url.getString(\"description\"));\n+                                        }\n+                                    }\n+                                    sherpaPublisherPolicy.setUrls(copyrightLinks);\n+                                }\n+\n+                                // Permitted OA options\n+                                int submittedOption = 0;\n+                                int acceptedOption = 0;\n+                                int publishedOption = 0;\n+                                int currentOption = 0;\n+                                if (policy.has(\"permitted_oa\")) {\n+                                    List<String> allowed = new ArrayList<>();\n+                                    JSONArray permittedOA = policy.getJSONArray(\"permitted_oa\");\n+                                    List<SHERPAPermittedVersion> permittedVersions = new ArrayList<>();\n+                                    for (int p = 0; p < permittedOA.length(); p++) {\n+                                        JSONObject permitted = permittedOA.getJSONObject(p);\n+                                        // New PermittedVersion object\n+                                        SHERPAPermittedVersion permittedVersion = new SHERPAPermittedVersion();\n+                                        // Get the article version, which is ultimately used for the ticks / crosses\n+                                        // in the UI display. My assumptions around translation:\n+                                        // submitted = preprint\n+                                        // accepted = postprint\n+                                        // published = pdfversion\n+                                        String articleVersion = \"unknown\";\n+                                        String versionLabel = \"Unknown\";\n+\n+                                        if (permitted.has(\"article_version\")) {\n+                                            JSONArray versions = permitted.getJSONArray(\"article_version\");\n+                                            articleVersion = versions.getString(0);\n+                                            allowed.add(articleVersion);\n+                                            permittedVersion.setArticleVersion(articleVersion);\n+                                            log.debug(\"Added allowed version: \" + articleVersion + \" to list\");\n+                                        }\n+\n+                                        if (\"submitted\".equals(articleVersion)) {\n+                                            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.submitted-version-label\");\n+                                            submittedOption++;\n+                                            currentOption = submittedOption;\n+                                        } else if(\"accepted\".equals(articleVersion)) {\n+                                            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.accepted-version-label\");\n+                                            acceptedOption++;\n+                                            currentOption = acceptedOption;\n+                                        } else if(\"published\".equals(articleVersion)) {\n+                                            versionLabel = I18nUtil.getMessage(\"jsp.sherpa.published-version-label\");\n+                                            publishedOption++;\n+                                            currentOption = publishedOption;\n+                                        }\n+\n+                                        // These are now child arrays, in old API they were explicit like\n+                                        // \"preprint restrictions\", etc., and just contained text rather than data\n+                                        if (permitted.has(\"conditions\")) {\n+                                            List<String> conditionList = new ArrayList<>();\n+                                            JSONArray conditions = permitted.getJSONArray(\"conditions\");\n+                                            for (int c = 0; c < conditions.length(); c++) {\n+                                                conditionList.add(conditions.getString(c).trim());\n+                                            }\n+                                            permittedVersion.setConditions(conditionList);\n+                                        }\n+\n+                                        permittedVersion.setArticleVersion(versionLabel);\n+                                        permittedVersion.setOption(currentOption);\n+\n+                                        // Any prerequisites for this option (eg required by funder)\n+                                        List<String> prerequisites = new ArrayList<>();\n+                                        if (permitted.has(\"prerequisites\")) {\n+                                            JSONObject prereqs = permitted.getJSONObject(\"prerequisites\");\n+                                            if (prereqs.has(\"prerequisites_phrases\")) {\n+                                                JSONArray phrases = prereqs.getJSONArray(\"prerequisites_phrases\");\n+                                                for (int pp = 0; pp < phrases.length(); pp++) {\n+                                                    JSONObject phrase = phrases.getJSONObject(pp);\n+                                                    if (phrase.has(\"phrase\")) {\n+                                                        prerequisites.add(phrase.getString(\"phrase\").trim());\n+                                                    }\n+                                                }\n+                                            }\n+                                        }\n+                                        permittedVersion.setPrerequisites(prerequisites);\n+\n+                                        // A rough attempt at guessing colour based on the doc in the DSpace page\n+                                        // SHERPA have confirmed we shouldn't really use this anymore\n+                                        if (allowed.contains(\"submitted\") &&\n+                                            (allowed.contains(\"accepted\") || allowed.contains(\"published\"))) {\n+                                            sherpaPublisher.setRomeoColour(\"green\");\n+                                        } else if (allowed.contains(\"accepted\") || allowed.contains(\"published\")) {\n+                                            sherpaPublisher.setRomeoColour(\"blue\");\n+                                        } else if (allowed.contains(\"submitted\")) {\n+                                            sherpaPublisher.setRomeoColour(\"yellow\");\n+                                        } else if (inDOAJ) {\n+                                            sherpaPublisher.setRomeoColour(\"gray\");\n+                                        } else {\n+                                            sherpaPublisher.setRomeoColour(\"white\");\n+                                        }\n+\n+                                        // Populate the old indicators\n+                                        if (allowed.contains(\"submitted\")) {\n+                                            sherpaPublisherPolicy.setPreArchiving(\"can\");\n+                                        }\n+                                        if (allowed.contains(\"accepted\")) {\n+                                            sherpaPublisherPolicy.setPostArchiving(\"can\");\n+                                        }\n+                                        if (allowed.contains(\"published\")) {\n+                                            sherpaPublisherPolicy.setPubArchiving(\"can\");\n+                                        }\n+\n+                                        // Locations where this version / option may be archived\n+                                        List<String> sherpaLocations = new ArrayList<>();\n+                                        if (permitted.has(\"location\")) {\n+                                            JSONObject locations = permitted.getJSONObject(\"location\");\n+                                            if (locations.has(\"location_phrases\")) {\n+                                                JSONArray locationPhrases = locations.getJSONArray(\"location_phrases\");\n+                                                if (locationPhrases.length() > 0) {\n+                                                    for (int l = 0; l < locationPhrases.length(); l++) {\n+                                                        JSONObject locationPhrase = locationPhrases.getJSONObject(l);\n+                                                        if (locationPhrase.has(\"phrase\")) {\n+                                                            sherpaLocations.add(locationPhrase.getString(\"phrase\").trim());\n+                                                        }\n+                                                    }\n+                                                }\n+                                            }\n+                                        }\n+                                        permittedVersion.setLocations(sherpaLocations);\n+\n+                                        List<String> sherpaLicenses = new ArrayList<>();\n+                                        // required licences\n+                                        if (permitted.has(\"license\")) {\n+                                            JSONArray licences = permitted.getJSONArray(\"license\");\n+                                            for (int l = 0; l < licences.length(); l++) {\n+                                                JSONObject licence = licences.getJSONObject(l);\n+                                                if (licence.has(\"license_phrases\")) {\n+                                                    JSONArray phrases = licence.getJSONArray(\"license_phrases\");\n+                                                    for (int ll = 0; ll < phrases.length(); ll++) {\n+                                                        JSONObject phrase = phrases.getJSONObject(ll);\n+                                                        if (phrase.has(\"phrase\")) {\n+                                                            sherpaLicenses.add(phrase.getString(\"phrase\").trim());\n+                                                        }\n+                                                    }\n+                                                }\n+                                            }\n+                                        }\n+                                        permittedVersion.setLicenses(sherpaLicenses);\n+                                        permittedVersions.add(permittedVersion);\n+                                    }\n+                                    sherpaPublisherPolicy.setPermittedVersions(permittedVersions);\n+                                }\n+                                policies.add(sherpaPublisherPolicy);\n+                            }\n+\n+                            // set publisher name - note we're still in the if (publisher policy) block\n+                            // since this info is sort of combined, now.\n+                            // So I'll also just look for first publisher here, it's only for the name anyway\n+                            // (I imagine multiple is just for older owners/ name variants?)\n+                            if (item.has(\"publishers\")) {\n+                                JSONArray publishers = item.getJSONArray(\"publishers\");\n+                                if (publishers.length() > 0) {\n+                                    JSONObject publisherElement = publishers.getJSONObject(0);\n+                                    if (publisherElement.has(\"publisher\")) {\n+                                        JSONObject publisher = publisherElement.getJSONObject(\"publisher\");\n+                                        if (publisher.has(\"name\")) {\n+                                            JSONArray publisherNames = publisher.getJSONArray(\"name\");\n+                                            if (publisherNames.length() > 0) {\n+                                                JSONObject publisherName = publisherNames.getJSONObject(0);\n+                                                if (publisherName.has(\"name\")) {\n+                                                    sherpaPublisher.setName(publisherName.getString(\"name\").trim());\n+                                                }\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            // set title\n+                            if (item.has(\"title\")) {\n+                                JSONArray titles = item.getJSONArray(\"title\");\n+                                if (titles.length() > 0) {\n+                                    List<String> titleList = new ArrayList<>();\n+                                    for (int t = 0; t < titles.length(); t++) {\n+                                        JSONObject title = titles.getJSONObject(t);\n+                                        if (title.has(\"title\")) {\n+                                            titleList.add(title.getString(\"title\").trim());\n+                                        }\n+                                    }\n+                                    sherpaJournal.setTitles(titleList);\n+                                    if (titleList.size() > 0) {\n+                                        // Faking this a bit based on what I'd seen - not in the API v2 data\n+                                        sherpaJournal.setRomeoPub(sherpaPublisher.getName() + \": \"\n+                                            + titleList.get(0));\n+                                        sherpaJournal.setZetoPub(sherpaPublisher.getName() + \": \"\n+                                            + titleList.get(0));\n+                                    }\n+                                }\n+                            }\n+\n+                            // Journal URL\n+                            if (item.has(\"url\")) {\n+                                sherpaJournal.setUrl(item.getString(\"url\"));\n+                            }\n+\n+                            // set ISSNs\n+                            if (item.has(\"issns\")) {\n+                                JSONArray issns = item.getJSONArray(\"issns\");\n+                                // just get first - DSpace data model only allows for one\n+                                List<String> issnList = new ArrayList<>();\n+                                for (int ii = 0; ii < issns.length(); ii++) {\n+                                    JSONObject issn = issns.getJSONObject(ii);\n+                                    issnList.add(issn.getString(\"issn\").trim());\n+                                }\n+                                sherpaJournal.setIssns(issnList);\n+                            }\n+                        }\n+\n+                        sherpaPublishers.add(sherpaPublisher);\n+                        sherpaJournal.setPublisher(sherpaPublisher);\n+                        sherpaJournal.setPublishers(sherpaPublishers);\n+                        sherpaJournal.setPolicies(policies);\n+                        this.journals.add(sherpaJournal);\n+                    }\n+\n+                    String licenceText = I18nUtil.getMessage(\"jsp.sherpa.license-default\");\n+                    String disclaimerText = I18nUtil.getMessage(\"jsp.sherpa.disclaimer\");\n+                    String licenceUrl = I18nUtil.getMessage(\"jsp.sherpa.license-url\");\n+                    this.license = licenceText;\n+                    this.licenseURL = licenceUrl;\n+                    this.disclaimer = disclaimerText;", "originalCommit": "b4edbc2a1bc4966f832385ea80336e2eeb523115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU2NzUzMw==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r410567533", "bodyText": "Removed", "author": "kshepherd", "createdAt": "2020-04-18T02:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA0ODExOA=="}], "type": "inlineReview"}, {"oid": "005e00f7bc3d7d61b5f1b01c6c66f852eff7f020", "url": "https://github.com/DSpace/DSpace/commit/005e00f7bc3d7d61b5f1b01c6c66f852eff7f020", "message": "[DS-3940] Remove formatted text from response object as per review", "committedDate": "2020-04-18T00:53:31Z", "type": "commit"}, {"oid": "6a28df95b32986ad68a0b7aee082594127e3bcd4", "url": "https://github.com/DSpace/DSpace/commit/6a28df95b32986ad68a0b7aee082594127e3bcd4", "message": "[DS-3940] Close input stream reader, throw IOException from parse methods", "committedDate": "2020-04-18T01:00:21Z", "type": "commit"}, {"oid": "385fa6c76801c9b67744817a1add58bd6756d332", "url": "https://github.com/DSpace/DSpace/commit/385fa6c76801c9b67744817a1add58bd6756d332", "message": "[DS-3940] Remove ROMeO colour from data models, as per review", "committedDate": "2020-04-18T01:02:46Z", "type": "commit"}, {"oid": "7ec7cbe59de11c5bf2d9c2f51e6e1b5991d1a437", "url": "https://github.com/DSpace/DSpace/commit/7ec7cbe59de11c5bf2d9c2f51e6e1b5991d1a437", "message": "[DS-3940] Split large parseJSON method into functional parts\n\nincluding slightly restructuring Journal and Permitted Version\nto work better with the way things are scoped in the new structure", "committedDate": "2020-04-18T02:33:29Z", "type": "commit"}, {"oid": "8af613a851598af976fa7e18e14d3cd26bfda85f", "url": "https://github.com/DSpace/DSpace/commit/8af613a851598af976fa7e18e14d3cd26bfda85f", "message": "[DS-3940] Ensure publisher URL is set correctly, refactor parse pub name", "committedDate": "2020-04-18T02:43:05Z", "type": "commit"}, {"oid": "23c26a44f34c42677c44b7a337ed5742e155f697", "url": "https://github.com/DSpace/DSpace/commit/23c26a44f34c42677c44b7a337ed5742e155f697", "message": "[DS-3940] Explicitly close SHERPAService response content InputStream", "committedDate": "2020-04-28T03:56:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NTM4NA==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r417145384", "bodyText": "Can we place this content.close() in a finally ? If for whatever reason the parsing fails the inputStream won't be closed. After this change I approve of this PR !\nPs: We should also remember to port this PR to the latest DSpace 7 master.", "author": "KevinVdV", "createdAt": "2020-04-29T08:22:27Z", "path": "dspace-api/src/main/java/org/dspace/app/sherpa/SHERPAService.java", "diffHunk": "@@ -103,10 +106,14 @@ public SHERPAResponse searchByJournalISSN(String query)\n \n                 HttpEntity responseBody = response.getEntity();\n \n-                if (null != responseBody)\n-                    sherpaResponse = new SHERPAResponse(responseBody.getContent(), SHERPAResponse.SHERPAFormat.JSON);\n-                else\n+                if (null != responseBody) {\n+                    InputStream content = responseBody.getContent();\n+                    sherpaResponse = new SHERPAResponse(content, SHERPAResponse.SHERPAFormat.JSON);\n+                    content.close();", "originalCommit": "23c26a44f34c42677c44b7a337ed5742e155f697", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY0NzU2Mw==", "url": "https://github.com/DSpace/DSpace/pull/2739#discussion_r417647563", "bodyText": "Good point, I did that in my other implementation, I'm not sure why this one was different.\nI have rewritten this small section for a try/catch/finally block, and in the same commit I updated the class to conform to DSpace 7 code style for easier porting.", "author": "kshepherd", "createdAt": "2020-04-29T22:22:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NTM4NA=="}], "type": "inlineReview"}, {"oid": "8a744b43be0eb09bc4196b37220d0b71be7480c7", "url": "https://github.com/DSpace/DSpace/commit/8a744b43be0eb09bc4196b37220d0b71be7480c7", "message": "[DS-3940] try/catch for parsing before finally closing stream, d7 code style", "committedDate": "2020-04-29T22:19:53Z", "type": "commit"}]}