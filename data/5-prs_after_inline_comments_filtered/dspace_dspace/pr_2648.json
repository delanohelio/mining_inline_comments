{"pr_number": 2648, "pr_title": "Scripts & processes: importing and exporting csv's", "pr_createdAt": "2020-01-22T14:41:32Z", "pr_url": "https://github.com/DSpace/DSpace/pull/2648", "timeline": [{"oid": "08c7da4446109a440e0263266cc173db4a6d85cb", "url": "https://github.com/DSpace/DSpace/commit/08c7da4446109a440e0263266cc173db4a6d85cb", "message": "Implementing file import and export scripts", "committedDate": "2019-11-21T12:22:09Z", "type": "commit"}, {"oid": "9733bd34413b62d0ded645c153d2eb95521ae837", "url": "https://github.com/DSpace/DSpace/commit/9733bd34413b62d0ded645c153d2eb95521ae837", "message": "Merged master into this branch and fixed tests/issues with metadata-import", "committedDate": "2019-11-21T14:19:05Z", "type": "commit"}, {"oid": "84775128b1ed5b768c24a1d18a5da972366a20ec", "url": "https://github.com/DSpace/DSpace/commit/84775128b1ed5b768c24a1d18a5da972366a20ec", "message": "Adding missing MetadataExportServiceImpl to the core-services.xml file", "committedDate": "2019-12-05T14:59:52Z", "type": "commit"}, {"oid": "e295a76c70a8f211531248957ceb27df2019a078", "url": "https://github.com/DSpace/DSpace/commit/e295a76c70a8f211531248957ceb27df2019a078", "message": "[Task 66428] Applied feedback to the MetadataImport and Export scripts and framework", "committedDate": "2019-12-10T15:13:54Z", "type": "commit"}, {"oid": "248e67f9a34713a93f7979987d3a108522db667c", "url": "https://github.com/DSpace/DSpace/commit/248e67f9a34713a93f7979987d3a108522db667c", "message": "Merge remote-tracking branch 'dspace/master' into w2p-64428_scripts-prototype-importing-and-exporting\n\nConflicts:\n\tdspace-api/src/main/java/org/dspace/app/launcher/ScriptLauncher.java\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/ScriptProcessesController.java\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/scripts/handler/impl/RestDSpaceRunnableHandler.java\n\tdspace-server-webapp/src/test/java/org/dspace/app/scripts/handler/impl/TestDSpaceRunnableHandler.java", "committedDate": "2020-01-06T13:11:55Z", "type": "commit"}, {"oid": "a208058d387a2ec06c9153735e6deba15c0deded", "url": "https://github.com/DSpace/DSpace/commit/a208058d387a2ec06c9153735e6deba15c0deded", "message": "Working on fixes test issues", "committedDate": "2020-01-06T13:12:08Z", "type": "commit"}, {"oid": "24f5cf0896632c29e0631dfa0909fa0473f5ba1e", "url": "https://github.com/DSpace/DSpace/commit/24f5cf0896632c29e0631dfa0909fa0473f5ba1e", "message": "Fixed tests in CSVMetadataImportReferenceTest and script bean issues", "committedDate": "2020-01-09T14:03:42Z", "type": "commit"}, {"oid": "182a8f01f373d25031f9bc1a71c51e8ba8ddbae4", "url": "https://github.com/DSpace/DSpace/commit/182a8f01f373d25031f9bc1a71c51e8ba8ddbae4", "message": "Applied feedback to the MetadataExport and MetadataImport scripts", "committedDate": "2020-01-15T12:49:31Z", "type": "commit"}, {"oid": "2d9e688d95ab065ed0c21a619a8cefb291123d1c", "url": "https://github.com/DSpace/DSpace/commit/2d9e688d95ab065ed0c21a619a8cefb291123d1c", "message": "[Task 68281] applied feedback to the metadata-import and metadata-export scripts", "committedDate": "2020-01-20T10:43:14Z", "type": "commit"}, {"oid": "130db9531d871edc49af6412665babff082af7df", "url": "https://github.com/DSpace/DSpace/commit/130db9531d871edc49af6412665babff082af7df", "message": "[Task 68380] added files and file endpoints to the Process endpoints", "committedDate": "2020-01-22T13:14:01Z", "type": "commit"}, {"oid": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "url": "https://github.com/DSpace/DSpace/commit/5265ebd382097d221b9b9bfc2df708b5819f1fa0", "message": "Removing commented out code", "committedDate": "2020-01-22T13:53:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4MTIyOA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374781228", "bodyText": "I think you meant to import java.nio.charset.StandardCharsets here and use StandardCharsets.UTF_8 in the code later in this file.  It's a bit odd to be using PDFBox here, since obviously this CSV code has nothing to do with PDFs.", "author": "tdonohue", "createdAt": "2020-02-04T16:31:00Z", "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/DSpaceCSV.java", "diffHunk": "@@ -27,7 +22,9 @@\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.lang3.StringUtils;\n+import org.apache.pdfbox.util.Charsets;", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNDI0OQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426034249", "bodyText": "This is still unresolved.  It looks like you should be importing java.nio.charset.StandardCharsets here, as this code has nothing to do with PDFBox or PDFs.", "author": "tdonohue", "createdAt": "2020-05-15T20:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4MTIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NDU2OQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374784569", "bodyText": "No method should complete() a Context that it does not create.  This could have unintended consequences (as a completed Context can no longer be used).", "author": "tdonohue", "createdAt": "2020-02-04T16:36:35Z", "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            handler.logInfo(\"\\nfull export: metadata-export -f filename\");\n+            handler.logInfo(\"partial export: metadata-export -i handle -f filename\");\n+            printHelp();\n+            return;\n         }\n-        String filename = line.getOptionValue('f');\n \n-        // Create a context\n-        Context c = new Context(Context.Mode.READ_ONLY);\n-        c.turnOffAuthorisationSystem();\n-\n-        // The things we'll export\n-        Iterator<Item> toExport = null;\n-        MetadataExport exporter = null;\n+        DSpaceCSV dSpaceCSV = metadataDSpaceCsvExportService\n+            .handleExport(context, exportAllItems, exportAllMetadata, handle,\n+                          handler);\n+        handler.writeFilestream(context, filename, dSpaceCSV.getInputStream(), \"exportCSV\");\n+        context.restoreAuthSystemState();\n+        context.complete();", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxMjAxNg==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r375912016", "bodyText": "Yes, this introduces a subtle coupling between the creating class and the completing class that could bite us later.", "author": "mwoodiupui", "createdAt": "2020-02-06T15:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NDU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNjk2MA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426036960", "bodyText": "Again, please resolve prior feedback here.", "author": "tdonohue", "createdAt": "2020-05-15T20:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NDU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk1NTIwNQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r430955205", "bodyText": "@tdonohue @mwoodiupui This is not something that we can easily dismiss here. This class represents a class that is run in a separate thread. This class creates the context & closes it as well. For this particular case we could go for a context.abort() as well (as this is an export that doesn't modify any data). But leaving it out would not be recommended as we don't want any open database connections for threads that are done.", "author": "KevinVdV", "createdAt": "2020-05-27T08:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NDU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIyMTIxNw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r431221217", "bodyText": "@KevinVdV : I'm sorry, but we cannot merge this as is. It will need refactoring.  Currently you've changed the behavior of this MetadataExport class, which is fine.  But, you've added a major flaw here.  Essentially, there are now two public methods... a setup() which creates a Context, and a internalRun() which commits the Context.  If someone accidentally calls internalRun() first, this will immediately fail with a NPE as no Context yet exists.   My recommendation here is to not have so many public methods, and ensure there is one method that creates & completes the context. It can call other methods to do processing with that context, but the context creation & closing must occur in the same method (no exceptions).", "author": "tdonohue", "createdAt": "2020-05-27T15:16:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NDU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyNDQ3OA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r431424478", "bodyText": "Should not internalRun() create and adjust the Context, use it, and close it?  Should not setup() simply collect information that internalRun() will use later?\nI must agree with @tdonohue here:  a Context should be created and closed within a single method, preferably within a single try block.", "author": "mwoodiupui", "createdAt": "2020-05-27T20:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NDU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NTg1MQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374785851", "bodyText": "We seem to be turning off Authorisation in this Context for a long time (which also could have unintended consequences). It's turned off here in the setup, but not restored again until internalRun() finishes up.  That means the context is not checking any authorizations during that entire time.\nOur best practice is to only use turnOffAuthorisationSystem() and restoreAuthSystemState() around small blocks of code. We should never leave authorization turned off between methods.", "author": "tdonohue", "createdAt": "2020-02-04T16:38:45Z", "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            handler.logInfo(\"\\nfull export: metadata-export -f filename\");\n+            handler.logInfo(\"partial export: metadata-export -i handle -f filename\");\n+            printHelp();\n+            return;\n         }\n-        String filename = line.getOptionValue('f');\n \n-        // Create a context\n-        Context c = new Context(Context.Mode.READ_ONLY);\n-        c.turnOffAuthorisationSystem();\n-\n-        // The things we'll export\n-        Iterator<Item> toExport = null;\n-        MetadataExport exporter = null;\n+        DSpaceCSV dSpaceCSV = metadataDSpaceCsvExportService\n+            .handleExport(context, exportAllItems, exportAllMetadata, handle,\n+                          handler);\n+        handler.writeFilestream(context, filename, dSpaceCSV.getInputStream(), \"exportCSV\");\n+        context.restoreAuthSystemState();\n+        context.complete();\n+    }\n \n-        // Export everything?\n-        boolean exportAll = line.hasOption('a');\n+    public void setup() throws ParseException {\n+        context = new Context();\n+        context.turnOffAuthorisationSystem();", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNzA0MQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426037041", "bodyText": "Again, please resolve prior feedback here.", "author": "tdonohue", "createdAt": "2020-05-15T20:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NTg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2NDg1Mg==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r430964852", "bodyText": "This is a port from the CLI script that initially does this on the following places:\n\nhttps://github.com/DSpace/DSpace/blob/master/dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java#L226\nhttps://github.com/DSpace/DSpace/blob/master/dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java#L275\n\nThe reason for this being that IF the script is executed from the CLI you don't want AuthorizeExceptions. This script can now not only be executed from the CLI but also from the REST api (the same class is used for both of these). The REST api has a user (which right now, which is certainly an admin as scripts & processes can only be executed by admins), but the CLI doesn't.\nSo a possible solution would be, is adding an a mandatory user parameter for the CLI, that way we can leave this out.\nWhat do you think ?", "author": "KevinVdV", "createdAt": "2020-05-27T09:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NTg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIyNDA0OA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r431224048", "bodyText": "@KevinVdV : Again, you've accidentally introduced a flaw here.  As you linked to previously, it's perfectly OK to turn off/on authorizations within the same method.  However, now that this is across separate methods, it will require finer tuning.  You may need to turn it off & on & off & on again only when needed within specific methods.  Or, maybe there's a way to turn it off in the calling code in order to surround two other internal method calls...then turn it back on after those calls.\nBut, again, this PR's current behavior is flawed as we don't allow for turning off authorizations across methods...that can have unintended consequences and accidentally bypass AuthorizeExceptions that we expect to occur.\nI'm OK with us requiring a user parameter on CLI if that helps us get around this problem.", "author": "tdonohue", "createdAt": "2020-05-27T15:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NTg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyODkwNw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r431428907", "bodyText": "As above, I'd suggest moving turnOffAuthorizationSystem() and the subsequent setCurrentUser() from setup() to internalRun().  I don't see why setup() needs a Context at all, so I say that it shouldn't have one.", "author": "mwoodiupui", "createdAt": "2020-05-27T20:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NTg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgxMzIyOQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r431813229", "bodyText": "Agreed, we will make adjustments to keep the context object limited to methods & remove it as a variable in the class.", "author": "KevinVdV", "createdAt": "2020-05-28T12:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NTg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NjU0Mw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374786543", "bodyText": "I think this method (and others in this same file) is missing an @Override annotation", "author": "tdonohue", "createdAt": "2020-02-04T16:39:51Z", "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNTc5OA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426035798", "bodyText": "Again, still missing an @Override here I believe.", "author": "tdonohue", "createdAt": "2020-05-15T20:38:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NjU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NzgzMw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374787833", "bodyText": "Again, not a best practice. This method is completing a Context it didn't create.", "author": "tdonohue", "createdAt": "2020-02-04T16:41:51Z", "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataImport.java", "diffHunk": "@@ -167,21 +178,201 @@\n      * @param c        The context\n      * @param toImport An array of CSV lines to examine\n      */\n-    public MetadataImport(Context c, DSpaceCSV toImport) {\n+    public void initMetadataImport(DSpaceCSV toImport) {\n         // Store the import settings\n-        this.c = c;\n-        csv = toImport;\n         this.toImport = toImport.getCSVLines();\n-        installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-        collectionService = ContentServiceFactory.getInstance().getCollectionService();\n-        handleService = HandleServiceFactory.getInstance().getHandleService();\n-        authorityValueService = AuthorityServiceFactory.getInstance().getAuthorityValueService();\n-        workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n-        relationshipService = ContentServiceFactory.getInstance().getRelationshipService();\n-        relationshipTypeService = ContentServiceFactory.getInstance().getRelationshipTypeService();\n-        entityTypeService = ContentServiceFactory.getInstance().getEntityTypeService();\n-        entityService = ContentServiceFactory.getInstance().getEntityService();\n+    }\n+\n+    @Override\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            printHelp();\n+            return;\n+        }\n+        // Read commandLines from the CSV file\n+        try {\n+\n+            Optional<InputStream> optionalFileStream = handler.getFileStream(c, filename);\n+            if (optionalFileStream.isPresent()) {\n+                csv = new DSpaceCSV(optionalFileStream.get(), c);\n+            } else {\n+                throw new IllegalArgumentException(\"Error reading file, the file couldn't be found for filename: \" +\n+                                                       filename);\n+            }\n+        } catch (MetadataImportInvalidHeadingException miihe) {\n+            throw miihe;\n+        } catch (Exception e) {\n+            throw new Exception(\"Error reading file: \" + e.getMessage(), e);\n+        }\n+\n+        // Perform the first import - just highlight differences\n+        initMetadataImport(csv);\n+        List<BulkEditChange> changes;\n+\n+        if (!commandLine.hasOption('s') || validateOnly) {\n+            // See what has changed\n+            try {\n+                changes = runImport(false, useWorkflow, workflowNotify, useTemplate);\n+            } catch (MetadataImportException mie) {\n+                throw mie;\n+            }\n+\n+            // Display the changes\n+            int changeCounter = displayChanges(changes, false);\n+\n+            // If there were changes, ask if we should execute them\n+            if (!validateOnly && changeCounter > 0) {\n+                try {\n+                    // Ask the user if they want to make the changes\n+                    handler.logInfo(\"\\n\" + changeCounter + \" item(s) will be changed\\n\");\n+                    change = determineChange(handler);\n+\n+                } catch (IOException ioe) {\n+                    throw new IOException(\"Error: \" + ioe.getMessage() + \", No changes have been made\", ioe);\n+                }\n+            } else {\n+                handler.logInfo(\"There were no changes detected\");\n+            }\n+        } else {\n+            change = true;\n+        }\n+\n+        try {\n+            // If required, make the change\n+            if (change && !validateOnly) {\n+                try {\n+                    // Make the changes\n+                    changes = runImport(true, useWorkflow, workflowNotify, useTemplate);\n+                } catch (MetadataImportException mie) {\n+                    throw mie;\n+                }\n+\n+                // Display the changes\n+                displayChanges(changes, true);\n+            }\n+\n+            // Finsh off and tidy up\n+            c.restoreAuthSystemState();\n+            c.complete();", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzODA2Nw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426038067", "bodyText": "Again, please resolve prior feedback", "author": "tdonohue", "createdAt": "2020-05-15T20:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NzgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2Nzg1MQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r430967851", "bodyText": "See comments above about the MetadataExport, this is similar except that we need a complete here because we are making changes.", "author": "KevinVdV", "createdAt": "2020-05-27T09:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4NzgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4ODIyNw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374788227", "bodyText": "Again, we are turning off all authorization checks and leaving them off until internalRun gets called. This is a bad practice.", "author": "tdonohue", "createdAt": "2020-02-04T16:42:29Z", "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataImport.java", "diffHunk": "@@ -167,21 +178,201 @@\n      * @param c        The context\n      * @param toImport An array of CSV lines to examine\n      */\n-    public MetadataImport(Context c, DSpaceCSV toImport) {\n+    public void initMetadataImport(DSpaceCSV toImport) {\n         // Store the import settings\n-        this.c = c;\n-        csv = toImport;\n         this.toImport = toImport.getCSVLines();\n-        installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-        collectionService = ContentServiceFactory.getInstance().getCollectionService();\n-        handleService = HandleServiceFactory.getInstance().getHandleService();\n-        authorityValueService = AuthorityServiceFactory.getInstance().getAuthorityValueService();\n-        workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n-        relationshipService = ContentServiceFactory.getInstance().getRelationshipService();\n-        relationshipTypeService = ContentServiceFactory.getInstance().getRelationshipTypeService();\n-        entityTypeService = ContentServiceFactory.getInstance().getEntityTypeService();\n-        entityService = ContentServiceFactory.getInstance().getEntityService();\n+    }\n+\n+    @Override\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            printHelp();\n+            return;\n+        }\n+        // Read commandLines from the CSV file\n+        try {\n+\n+            Optional<InputStream> optionalFileStream = handler.getFileStream(c, filename);\n+            if (optionalFileStream.isPresent()) {\n+                csv = new DSpaceCSV(optionalFileStream.get(), c);\n+            } else {\n+                throw new IllegalArgumentException(\"Error reading file, the file couldn't be found for filename: \" +\n+                                                       filename);\n+            }\n+        } catch (MetadataImportInvalidHeadingException miihe) {\n+            throw miihe;\n+        } catch (Exception e) {\n+            throw new Exception(\"Error reading file: \" + e.getMessage(), e);\n+        }\n+\n+        // Perform the first import - just highlight differences\n+        initMetadataImport(csv);\n+        List<BulkEditChange> changes;\n+\n+        if (!commandLine.hasOption('s') || validateOnly) {\n+            // See what has changed\n+            try {\n+                changes = runImport(false, useWorkflow, workflowNotify, useTemplate);\n+            } catch (MetadataImportException mie) {\n+                throw mie;\n+            }\n+\n+            // Display the changes\n+            int changeCounter = displayChanges(changes, false);\n+\n+            // If there were changes, ask if we should execute them\n+            if (!validateOnly && changeCounter > 0) {\n+                try {\n+                    // Ask the user if they want to make the changes\n+                    handler.logInfo(\"\\n\" + changeCounter + \" item(s) will be changed\\n\");\n+                    change = determineChange(handler);\n+\n+                } catch (IOException ioe) {\n+                    throw new IOException(\"Error: \" + ioe.getMessage() + \", No changes have been made\", ioe);\n+                }\n+            } else {\n+                handler.logInfo(\"There were no changes detected\");\n+            }\n+        } else {\n+            change = true;\n+        }\n+\n+        try {\n+            // If required, make the change\n+            if (change && !validateOnly) {\n+                try {\n+                    // Make the changes\n+                    changes = runImport(true, useWorkflow, workflowNotify, useTemplate);\n+                } catch (MetadataImportException mie) {\n+                    throw mie;\n+                }\n+\n+                // Display the changes\n+                displayChanges(changes, true);\n+            }\n+\n+            // Finsh off and tidy up\n+            c.restoreAuthSystemState();\n+            c.complete();\n+        } catch (Exception e) {\n+            c.abort();\n+            throw new Exception(\n+                \"Error committing changes to database: \" + e.getMessage() + \", aborting most recent changes\", e);\n+        }\n+\n+    }\n+\n+    /**\n+     * This method determines whether the changes should be applied or not. This is default set to true for the REST\n+     * script as we don't want to interact with the caller. This will be overwritten in the CLI script to ask for\n+     * confirmation\n+     * @param handler   Applicable DSpaceRunnableHandler\n+     * @return boolean indicating the value\n+     * @throws IOException  If something goes wrong\n+     */\n+    protected boolean determineChange(DSpaceRunnableHandler handler) throws IOException {\n+        return true;\n+    }\n+\n+    public void setup() throws ParseException {\n+        useTemplate = false;\n+        filename = null;\n+        useWorkflow = false;\n+        workflowNotify = false;\n+\n+        if (commandLine.hasOption('h')) {\n+            help = true;\n+            return;\n+        }\n+\n+        // Check a filename is given\n+        if (!commandLine.hasOption('f')) {\n+            throw new ParseException(\"Required parameter -f missing!\");\n+        }\n+        filename = commandLine.getOptionValue('f');\n+\n+        // Option to apply template to new items\n+        if (commandLine.hasOption('t')) {\n+            useTemplate = true;\n+        }\n+\n+        // Options for workflows, and workflow notifications for new items\n+        if (commandLine.hasOption('w')) {\n+            useWorkflow = true;\n+            if (commandLine.hasOption('n')) {\n+                workflowNotify = true;\n+            }\n+        } else if (commandLine.hasOption('n')) {\n+            throw new ParseException(\n+                \"Invalid option 'n': (notify) can only be specified with the 'w' (workflow) option.\");\n+        }\n+        validateOnly = commandLine.hasOption('v');\n+\n+\n+        // Create a context\n+        try {\n+            c = new Context();\n+            c.turnOffAuthorisationSystem();", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzODE4Mw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426038183", "bodyText": "Again, please resolve prior feedback", "author": "tdonohue", "createdAt": "2020-05-15T20:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4ODIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk2ODA5Nw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r430968097", "bodyText": "See comment above, same as MetadataExport.", "author": "KevinVdV", "createdAt": "2020-05-27T09:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc4ODIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MjQ1NA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374792454", "bodyText": "Could we describe what the \"epersonIdentifier\" is?  I'm assuming this should actually say something like \"Get the UUID of the EPerson that the script is running as\"?\nSame for setEpersonIdentifier() method below....what the \"epersonIdentifier\" refers to is not currently clear to me. But, I think it likely is the EPerson this script is running as.", "author": "tdonohue", "createdAt": "2020-02-04T16:49:22Z", "path": "dspace-api/src/main/java/org/dspace/scripts/DSpaceRunnable.java", "diffHunk": "@@ -153,4 +170,32 @@ public boolean isAllowedToExecute(Context context) {\n         }\n         return false;\n     }\n+\n+    public void setBeanName(String beanName) {\n+        this.name = beanName;\n+    }\n+\n+    /**\n+     * Generic getter for the name\n+     * @return the name value of this DSpaceRunnable\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Generic getter for the epersonIdentifier", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzODk1Nw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426038957", "bodyText": "Again, please resolve prior feedback", "author": "tdonohue", "createdAt": "2020-05-15T20:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MjQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5OTYzMw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374799633", "bodyText": "Please rename this class...this is not a generic controller for the processes endpoint, as it looks like most of those requests would use ProcessRestRepository.  Instead, this should be updated to specifically deal with  /processes/files subresource.  So, maybe this should be:\n@RequestMapping(\"/api\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME + \"/files)\npublic class ProcessFilesRestController {", "author": "tdonohue", "createdAt": "2020-02-04T17:01:14Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessRestController.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.model.hateoas.ProcessFileWrapperResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedResources;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME)\n+public class ProcessRestController {", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzOTg5Mg==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426039892", "bodyText": "I think this Controller can now be removed in favor of a LinkRestRepository (see other LinkRestRepository classes as examples).  I don't see a reason why we this needs to a custom Controller", "author": "tdonohue", "createdAt": "2020-05-15T20:49:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5OTYzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc5NzExMg==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r431797112", "bodyText": "We moved part of the controller to the new \"ProcessFilesLinkRepository\" class, the other ones couldn't. The LinkRestRepository framework does not allow us to further specify a repository than just the Category, Model and Name of the linkRest. This means that we\u2019re stuck at the /files endpoint and can\u2019t further specify path variables or further deeper URL structures. Therefore we need this Controller to take care of it.", "author": "KevinVdV", "createdAt": "2020-05-28T12:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5OTYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDI5MQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374800291", "bodyText": "I'm assuming each of these methods should have @PreAuthorize annotations to access restrict files in some way?", "author": "tdonohue", "createdAt": "2020-02-04T17:02:21Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessRestController.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;\n+import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.model.hateoas.ProcessFileWrapperResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedResources;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME)\n+public class ProcessRestController {\n+\n+    private static final Logger log = LogManager.getLogger();\n+\n+    @Autowired\n+    HalLinkService linkService;\n+\n+    @Autowired\n+    private ProcessRestRepository processRestRepository;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Autowired\n+    private HalLinkService halLinkService;\n+\n+    @Autowired\n+    ProcessResourceHalLinkFactory processResourceHalLinkFactory;\n+\n+    @RequestMapping(method = RequestMethod.GET, value = \"/{processId}/files\")", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MDEyNg==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426040126", "bodyText": "All methods will need a @PreAuthorize annotation once you turn this into a LinkRestRepository.", "author": "tdonohue", "createdAt": "2020-05-15T20:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDY1MA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374800650", "bodyText": "This class is missing JavaDocs...as are the methods.", "author": "tdonohue", "createdAt": "2020-02-04T17:03:01Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/model/ProcessFileWrapperRest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.model;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+public class ProcessFileWrapperRest {", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MTk2Mw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426041963", "bodyText": "Again, please resolve prior feedback.", "author": "tdonohue", "createdAt": "2020-05-15T20:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDc3Ng==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374800776", "bodyText": "This class is also missing JavaDocs", "author": "tdonohue", "createdAt": "2020-02-04T17:03:14Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/ProcessFileWrapperResource.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.model.hateoas;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.MetadataValueRest;\n+import org.dspace.app.rest.model.ProcessFileWrapperRest;\n+import org.dspace.app.rest.utils.Utils;\n+\n+\n+public class ProcessFileWrapperResource extends HALResource<ProcessFileWrapperRest> {", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MTk5OQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426041999", "bodyText": "Again, please resolve prior feedback.", "author": "tdonohue", "createdAt": "2020-05-15T20:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMDc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMTE0OA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374801148", "bodyText": "Please add JavaDocs to all the new methods in this class", "author": "tdonohue", "createdAt": "2020-02-04T17:03:48Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ProcessRestRepository.java", "diffHunk": "@@ -59,6 +77,64 @@ public ProcessRest findOne(Context context, Integer id) {\n         }\n     }\n \n+    public List<BitstreamRest> getProcessBitstreams(Integer processId) throws SQLException, AuthorizeException {", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MjAzNw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426042037", "bodyText": "Again, please resolve prior feedback.", "author": "tdonohue", "createdAt": "2020-05-15T20:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMTE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwNjIxMg==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r374806212", "bodyText": "Since this \"type\" of \"exportCSV\" is going to end up saved into a metadata field (process.type), should we consider using a constant for the value (maybe in the Process class or similar?).  It seems odd to hardcode it if the value means something to the Process.", "author": "tdonohue", "createdAt": "2020-02-04T17:12:53Z", "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataExport.java", "diffHunk": "@@ -7,272 +7,101 @@\n  */\n package org.dspace.app.bulkedit;\n \n+import java.io.OutputStream;\n import java.sql.SQLException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n \n-import com.google.common.collect.Iterators;\n-import org.apache.commons.cli.CommandLine;\n-import org.apache.commons.cli.CommandLineParser;\n-import org.apache.commons.cli.HelpFormatter;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.apache.commons.cli.PosixParser;\n-import org.dspace.content.Collection;\n-import org.dspace.content.Community;\n-import org.dspace.content.DSpaceObject;\n-import org.dspace.content.Item;\n-import org.dspace.content.factory.ContentServiceFactory;\n-import org.dspace.content.service.ItemService;\n-import org.dspace.core.Constants;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n import org.dspace.core.Context;\n-import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.eperson.service.EPersonService;\n+import org.dspace.scripts.DSpaceRunnable;\n+import org.springframework.beans.factory.annotation.Autowired;\n \n /**\n  * Metadata exporter to allow the batch export of metadata into a file\n  *\n  * @author Stuart Lewis\n  */\n-public class MetadataExport {\n-    /**\n-     * The items to export\n-     */\n-    protected Iterator<Item> toExport;\n+public class MetadataExport extends DSpaceRunnable {\n \n-    protected ItemService itemService;\n+    private Context context = null;\n+    private boolean help = false;\n+    private String filename = null;\n+    private String handle = null;\n+    private boolean exportAllMetadata = false;\n+    private boolean exportAllItems = false;\n \n-    protected Context context;\n+    @Autowired\n+    private MetadataDSpaceCsvExportService metadataDSpaceCsvExportService;\n \n-    /**\n-     * Whether to export all metadata, or just normally edited metadata\n-     */\n-    protected boolean exportAll;\n+    @Autowired\n+    private EPersonService ePersonService;\n \n-    protected MetadataExport() {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n+    private MetadataExport() {\n+        this.options = constructOptions();\n     }\n \n-    /**\n-     * Set up a new metadata export\n-     *\n-     * @param c         The Context\n-     * @param toExport  The ItemIterator of items to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Iterator<Item> toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        // Store the export settings\n-        this.toExport = toExport;\n-        this.exportAll = exportAll;\n-        this.context = c;\n-    }\n-\n-    /**\n-     * Method to export a community (and sub-communities and collections)\n-     *\n-     * @param c         The Context\n-     * @param toExport  The Community to export\n-     * @param exportAll whether to export all metadata or not (include handle, provenance etc)\n-     */\n-    public MetadataExport(Context c, Community toExport, boolean exportAll) {\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-\n-        try {\n-            // Try to export the community\n-            this.toExport = buildFromCommunity(c, toExport, 0);\n-            this.exportAll = exportAll;\n-            this.context = c;\n-        } catch (SQLException sqle) {\n-            // Something went wrong...\n-            System.err.println(\"Error running exporter:\");\n-            sqle.printStackTrace(System.err);\n-            System.exit(1);\n-        }\n-    }\n-\n-    /**\n-     * Build an array list of item ids that are in a community (include sub-communities and collections)\n-     *\n-     * @param context   DSpace context\n-     * @param community The community to build from\n-     * @param indent    How many spaces to use when writing out the names of items added\n-     * @return The list of item ids\n-     * @throws SQLException if database error\n-     */\n-    protected Iterator<Item> buildFromCommunity(Context context, Community community, int indent)\n-        throws SQLException {\n-        // Add all the collections\n-        List<Collection> collections = community.getCollections();\n-        Iterator<Item> result = null;\n-        for (Collection collection : collections) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-\n-            Iterator<Item> items = itemService.findByCollection(context, collection);\n-            result = addItemsToResult(result, items);\n-\n-        }\n-        // Add all the sub-communities\n-        List<Community> communities = community.getSubcommunities();\n-        for (Community subCommunity : communities) {\n-            for (int i = 0; i < indent; i++) {\n-                System.out.print(\" \");\n-            }\n-            Iterator<Item> items = buildFromCommunity(context, subCommunity, indent + 1);\n-            result = addItemsToResult(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    private Iterator<Item> addItemsToResult(Iterator<Item> result, Iterator<Item> items) {\n-        if (result == null) {\n-            result = items;\n-        } else {\n-            result = Iterators.concat(result, items);\n-        }\n-\n-        return result;\n-    }\n-\n-    /**\n-     * Run the export\n-     *\n-     * @return the exported CSV lines\n-     */\n-    public DSpaceCSV export() {\n-        try {\n-            Context.Mode originalMode = context.getCurrentMode();\n-            context.setMode(Context.Mode.READ_ONLY);\n-\n-            // Process each item\n-            DSpaceCSV csv = new DSpaceCSV(exportAll);\n-            while (toExport.hasNext()) {\n-                Item item = toExport.next();\n-                csv.addItem(item);\n-                context.uncacheEntity(item);\n-            }\n-\n-            context.setMode(originalMode);\n-            // Return the results\n-            return csv;\n-        } catch (Exception e) {\n-            // Something went wrong...\n-            System.err.println(\"Error exporting to CSV:\");\n-            e.printStackTrace();\n-            return null;\n-        }\n-    }\n-\n-    /**\n-     * Print the help message\n-     *\n-     * @param options  The command line options the user gave\n-     * @param exitCode the system exit code to use\n-     */\n-    private static void printHelp(Options options, int exitCode) {\n-        // print the help message\n-        HelpFormatter myhelp = new HelpFormatter();\n-        myhelp.printHelp(\"MetadataExport\\n\", options);\n-        System.out.println(\"\\nfull export: metadataexport -f filename\");\n-        System.out.println(\"partial export: metadataexport -i handle -f filename\");\n-        System.exit(exitCode);\n-    }\n-\n-    /**\n-     * main method to run the metadata exporter\n-     *\n-     * @param argv the command line arguments given\n-     * @throws Exception if error occurs\n-     */\n-    public static void main(String[] argv) throws Exception {\n-        // Create an options object and populate it\n-        CommandLineParser parser = new PosixParser();\n-\n+    private Options constructOptions() {\n         Options options = new Options();\n \n         options.addOption(\"i\", \"id\", true, \"ID or handle of thing to export (item, collection, or community)\");\n+        options.getOption(\"i\").setType(String.class);\n         options.addOption(\"f\", \"file\", true, \"destination where you want file written\");\n+        options.getOption(\"f\").setType(OutputStream.class);\n+        options.getOption(\"f\").setRequired(true);\n         options.addOption(\"a\", \"all\", false,\n                           \"include all metadata fields that are not normally changed (e.g. provenance)\");\n+        options.getOption(\"a\").setType(boolean.class);\n         options.addOption(\"h\", \"help\", false, \"help\");\n+        options.getOption(\"h\").setType(boolean.class);\n \n-        CommandLine line = null;\n-\n-        try {\n-            line = parser.parse(options, argv);\n-        } catch (ParseException pe) {\n-            System.err.println(\"Error with commands.\");\n-            printHelp(options, 1);\n-            System.exit(0);\n-        }\n \n-        if (line.hasOption('h')) {\n-            printHelp(options, 0);\n-        }\n+        return options;\n+    }\n \n-        // Check a filename is given\n-        if (!line.hasOption('f')) {\n-            System.err.println(\"Required parameter -f missing!\");\n-            printHelp(options, 1);\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            handler.logInfo(\"\\nfull export: metadata-export -f filename\");\n+            handler.logInfo(\"partial export: metadata-export -i handle -f filename\");\n+            printHelp();\n+            return;\n         }\n-        String filename = line.getOptionValue('f');\n \n-        // Create a context\n-        Context c = new Context(Context.Mode.READ_ONLY);\n-        c.turnOffAuthorisationSystem();\n-\n-        // The things we'll export\n-        Iterator<Item> toExport = null;\n-        MetadataExport exporter = null;\n+        DSpaceCSV dSpaceCSV = metadataDSpaceCsvExportService\n+            .handleExport(context, exportAllItems, exportAllMetadata, handle,\n+                          handler);\n+        handler.writeFilestream(context, filename, dSpaceCSV.getInputStream(), \"exportCSV\");", "originalCommit": "5265ebd382097d221b9b9bfc2df708b5819f1fa0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNjkwMA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426036900", "bodyText": "Again, please resolve prior feedback here.", "author": "tdonohue", "createdAt": "2020-05-15T20:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwNjIxMg=="}], "type": "inlineReview"}, {"oid": "90073abfb7b7ffec2482751dd6ad92939ec874b0", "url": "https://github.com/DSpace/DSpace/commit/90073abfb7b7ffec2482751dd6ad92939ec874b0", "message": "[Task 68534] applied feedback to the metadata import and export script and wrote tests for them", "committedDate": "2020-02-11T11:41:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg5OTE2OQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r382899169", "bodyText": "if this attribute hold information related to a specific execution this imply that the bean needs to be declared as prototype or we need to force a single thread model. Both options are suboptimal, am I misreading?", "author": "abollini", "createdAt": "2020-02-22T09:14:02Z", "path": "dspace-api/src/main/java/org/dspace/scripts/DSpaceRunnable.java", "diffHunk": "@@ -24,8 +31,9 @@\n  * it provides the basic variables to be hold by the script as well as the means to initialize, parse and run the script\n  * Every DSpaceRunnable that is implemented in this way should be defined in the scripts.xml config file as a bean\n  */\n-public abstract class DSpaceRunnable implements Runnable {\n+public abstract class DSpaceRunnable implements Runnable, BeanNameAware {\n \n+    private UUID epersonIdentifier;", "originalCommit": "90073abfb7b7ffec2482751dd6ad92939ec874b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c5285109e97fd5b9a6fe4a4cecc75545216bd1a5", "url": "https://github.com/DSpace/DSpace/commit/c5285109e97fd5b9a6fe4a4cecc75545216bd1a5", "message": "Merge remote-tracking branch 'dspace/master' into w2p-64428_scripts-prototype-importing-and-exporting\n\nConflicts:\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/link/process/ProcessResourceHalLinkFactory.java", "committedDate": "2020-03-23T10:32:01Z", "type": "commit"}, {"oid": "e9d56e7c4146e718c5dfb32b369a1dbaf00f69cb", "url": "https://github.com/DSpace/DSpace/commit/e9d56e7c4146e718c5dfb32b369a1dbaf00f69cb", "message": "[Task 69724] Scripts&Processes: split configuration and runnable", "committedDate": "2020-03-23T13:13:11Z", "type": "commit"}, {"oid": "25ca31f8cf7a0e4da0bef4da4f812d51102228f9", "url": "https://github.com/DSpace/DSpace/commit/25ca31f8cf7a0e4da0bef4da4f812d51102228f9", "message": "[Task 69724] Scripts&Processes: cleanup and javadoc", "committedDate": "2020-03-23T13:44:55Z", "type": "commit"}, {"oid": "0232916dc5c04503f1ba08e082585a00b77f8d70", "url": "https://github.com/DSpace/DSpace/commit/0232916dc5c04503f1ba08e082585a00b77f8d70", "message": "[Task 70080] applying feedback to scripts and processes splitting config and runnable", "committedDate": "2020-03-27T14:03:05Z", "type": "commit"}, {"oid": "95f1124de55299825ce55aedd9a889aaabae63ca", "url": "https://github.com/DSpace/DSpace/commit/95f1124de55299825ce55aedd9a889aaabae63ca", "message": "[Task 70080] implemented generics and DSpaceRunnableClass definition on Spring level and fixed ITs", "committedDate": "2020-03-30T09:36:42Z", "type": "commit"}, {"oid": "4031e41a5dca40bd64d15052decd4906deea22c6", "url": "https://github.com/DSpace/DSpace/commit/4031e41a5dca40bd64d15052decd4906deea22c6", "message": "[Task 70080] applied feedback to the scripts and processes functionality", "committedDate": "2020-04-06T08:41:51Z", "type": "commit"}, {"oid": "861cdfb2b852a69347e467c2eb435f3f82a86528", "url": "https://github.com/DSpace/DSpace/commit/861cdfb2b852a69347e467c2eb435f3f82a86528", "message": "[Task 70080] applied feedback to the scripts prototype", "committedDate": "2020-05-06T09:02:47Z", "type": "commit"}, {"oid": "9e6a746404724e2591cb059f9712cc1029b846a4", "url": "https://github.com/DSpace/DSpace/commit/9e6a746404724e2591cb059f9712cc1029b846a4", "message": "Merge remote-tracking branch 'dspace/master' into w2p-64428_scripts-prototype-importing-and-exporting\n\nConflicts:\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/ScriptProcessesController.java\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/model/ParameterRest.java", "committedDate": "2020-05-06T09:49:23Z", "type": "commit"}, {"oid": "5e212192afa81f1da2fb393e3f02320c41947e27", "url": "https://github.com/DSpace/DSpace/commit/5e212192afa81f1da2fb393e3f02320c41947e27", "message": "[Task 70050] fixes after master merge", "committedDate": "2020-05-06T09:49:39Z", "type": "commit"}, {"oid": "026c2308eccf07a5f60dbf9572c264c028598f48", "url": "https://github.com/DSpace/DSpace/commit/026c2308eccf07a5f60dbf9572c264c028598f48", "message": "[Task 70750] made the Bitstream findAll endpoint not implemented", "committedDate": "2020-05-06T14:38:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNTU2Mw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426035563", "bodyText": "Once you update the import to be StandardCharsets, this line should likely replace \"UTF-8\" with StandardCharsets.UTF_8 for consistency.", "author": "tdonohue", "createdAt": "2020-05-15T20:38:08Z", "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/DSpaceCSV.java", "diffHunk": "@@ -141,18 +138,18 @@ public DSpaceCSV(boolean exportAll) {\n     /**\n      * Create a new instance, reading the lines in from file\n      *\n-     * @param f The file to read from\n+     * @param inputStream the inputstream to read from\n      * @param c The DSpace Context\n      * @throws Exception thrown if there is an error reading or processing the file\n      */\n-    public DSpaceCSV(File f, Context c) throws Exception {\n+    public DSpaceCSV(InputStream inputStream, Context c) throws Exception {\n         // Initialise the class\n         init();\n \n         // Open the CSV file\n         BufferedReader input = null;\n         try {\n-            input = new BufferedReader(new InputStreamReader(new FileInputStream(f), \"UTF-8\"));\n+            input = new BufferedReader(new InputStreamReader(inputStream, \"UTF-8\"));", "originalCommit": "026c2308eccf07a5f60dbf9572c264c028598f48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAzNTU5OQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426035599", "bodyText": "Please add JavaDocs to this new public method.", "author": "tdonohue", "createdAt": "2020-05-15T20:38:14Z", "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/DSpaceCSV.java", "diffHunk": "@@ -622,22 +619,12 @@ public final void addItem(String line) throws Exception {\n         return csvLines;\n     }\n \n-    /**\n-     * Save the CSV file to the given filename\n-     *\n-     * @param filename The filename to save the CSV file to\n-     * @throws IOException Thrown if an error occurs when writing the file\n-     */\n-    public final void save(String filename) throws IOException {\n-        // Save the file\n-        BufferedWriter out = new BufferedWriter(\n-            new OutputStreamWriter(\n-                new FileOutputStream(filename), \"UTF-8\"));\n+    public InputStream getInputStream() {", "originalCommit": "026c2308eccf07a5f60dbf9572c264c028598f48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0MTYwMw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r426041603", "bodyText": "Needs JavaDocs to describe this abstract class.  This is especially important because it's an empty class, so we need to describe why it's needed.", "author": "tdonohue", "createdAt": "2020-05-15T20:53:38Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/link/process/ProcessHalLinkFactory.java", "diffHunk": "@@ -0,0 +1,14 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.link.process;\n+\n+import org.dspace.app.rest.ProcessRestController;\n+import org.dspace.app.rest.link.HalLinkFactory;\n+\n+public abstract class ProcessHalLinkFactory<T> extends HalLinkFactory<T, ProcessRestController> {", "originalCommit": "026c2308eccf07a5f60dbf9572c264c028598f48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fa741eb188786c5019d737099b18d14382f04935", "url": "https://github.com/DSpace/DSpace/commit/fa741eb188786c5019d737099b18d14382f04935", "message": "[Task 70911] applied feedback to the Scripts and Processes functionality", "committedDate": "2020-05-18T12:48:39Z", "type": "commit"}, {"oid": "5b0bf29fd40ddc2247c1d2867594bd257beb094d", "url": "https://github.com/DSpace/DSpace/commit/5b0bf29fd40ddc2247c1d2867594bd257beb094d", "message": "Cleanup comment", "committedDate": "2020-05-18T12:52:13Z", "type": "commit"}, {"oid": "2a554cbd141618dfc30fd792c00ffc6adb405e39", "url": "https://github.com/DSpace/DSpace/commit/2a554cbd141618dfc30fd792c00ffc6adb405e39", "message": "Merge remote-tracking branch 'dspace/master' into w2p-64428_scripts-prototype-importing-and-exporting\n\nConflicts:\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/ScriptProcessesController.java\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ScriptRestRepository.java", "committedDate": "2020-05-28T07:23:19Z", "type": "commit"}, {"oid": "bc7cf1484cff1925e77be34b712dfc97f5fecdbc", "url": "https://github.com/DSpace/DSpace/commit/bc7cf1484cff1925e77be34b712dfc97f5fecdbc", "message": "Fixes after master merge", "committedDate": "2020-05-28T07:41:58Z", "type": "commit"}, {"oid": "8045194cc38f637683405acae796a23b4f6107ef", "url": "https://github.com/DSpace/DSpace/commit/8045194cc38f637683405acae796a23b4f6107ef", "message": "[Task 70911] applied feedback on the Process endpoints", "committedDate": "2020-05-28T08:29:09Z", "type": "commit"}, {"oid": "ce9ba1263b6ead1c3f337fac25d52e22785f5906", "url": "https://github.com/DSpace/DSpace/commit/ce9ba1263b6ead1c3f337fac25d52e22785f5906", "message": "Added more descriptive log to the ProcessRestRepository#delete method", "committedDate": "2020-05-28T09:40:01Z", "type": "commit"}, {"oid": "f19bf96bd2813a93a632512207e8cbcba8c9d936", "url": "https://github.com/DSpace/DSpace/commit/f19bf96bd2813a93a632512207e8cbcba8c9d936", "message": "[Task 70911] applied feedback to the MetadataExport and MetadataImport scripts as well as general Process functionality feedback", "committedDate": "2020-05-28T13:30:52Z", "type": "commit"}, {"oid": "8652e95686edf28f6431dd0f9e035e147ed01852", "url": "https://github.com/DSpace/DSpace/commit/8652e95686edf28f6431dd0f9e035e147ed01852", "message": "[Task 70911] added required parameter e check in the MetadataImport setup and cleanup", "committedDate": "2020-05-28T13:48:03Z", "type": "commit"}, {"oid": "47b75f313e543923997cbe8c2ae717323aea7170", "url": "https://github.com/DSpace/DSpace/commit/47b75f313e543923997cbe8c2ae717323aea7170", "message": "Fixed checkstyle", "committedDate": "2020-05-29T13:52:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk2ODg4OQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r431968889", "bodyText": "Please add Javadocs describing this implementation class", "author": "tdonohue", "createdAt": "2020-05-28T16:29:54Z", "path": "dspace-api/src/main/java/org/dspace/content/MetadataDSpaceCsvExportServiceImpl.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.content;\n+\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.google.common.collect.Iterators;\n+import org.dspace.app.bulkedit.DSpaceCSV;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.MetadataDSpaceCsvExportService;\n+import org.dspace.core.Constants;\n+import org.dspace.core.Context;\n+import org.dspace.handle.factory.HandleServiceFactory;\n+import org.dspace.scripts.handler.DSpaceRunnableHandler;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class MetadataDSpaceCsvExportServiceImpl implements MetadataDSpaceCsvExportService {", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk3MDgyMg==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r431970822", "bodyText": "Tiny thing, we likely can remove this Try/Catch, as we usually don't do this when creating a new Context (see the code you wrote in MetadataExport).  If there's a need for it you've discovered, then I'd recommend we throw a RuntimeException here (not a ParseException), and also return the stacktrace, as e.getMessage() may not be enough info to know why the Context couldn't be created.  So, if you need the try/catch, this last line should be throw new RuntimeException(\"Unable to create a new DSpace Context\", e);", "author": "tdonohue", "createdAt": "2020-05-28T16:32:57Z", "path": "dspace-api/src/main/java/org/dspace/app/bulkedit/MetadataImport.java", "diffHunk": "@@ -143,45 +133,213 @@\n      */\n     protected Integer rowCount = 1;\n \n+    private boolean useTemplate = false;\n+    private String filename = null;\n+    private boolean useWorkflow = false;\n+    private boolean workflowNotify = false;\n+    private boolean change = false;\n+    private boolean help = false;\n+    protected boolean validateOnly;\n+\n     /**\n      * Logger\n      */\n     protected static final Logger log = org.apache.logging.log4j.LogManager.getLogger(MetadataImport.class);\n \n-    protected final AuthorityValueService authorityValueService;\n-\n-    protected final ItemService itemService;\n-    protected final InstallItemService installItemService;\n-    protected final CollectionService collectionService;\n-    protected final HandleService handleService;\n-    protected final WorkspaceItemService workspaceItemService;\n-    protected final RelationshipTypeService relationshipTypeService;\n-    protected final RelationshipService relationshipService;\n-    protected final EntityTypeService entityTypeService;\n-    protected final EntityService entityService;\n+    protected ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    protected InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    protected CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    protected HandleService handleService = HandleServiceFactory.getInstance().getHandleService();\n+    protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n+    protected RelationshipTypeService relationshipTypeService = ContentServiceFactory.getInstance()\n+                                                                                     .getRelationshipTypeService();\n+    protected RelationshipService relationshipService = ContentServiceFactory.getInstance().getRelationshipService();\n+    protected EntityTypeService entityTypeService = ContentServiceFactory.getInstance().getEntityTypeService();\n+    protected EntityService entityService = ContentServiceFactory.getInstance().getEntityService();\n+    protected AuthorityValueService authorityValueService = AuthorityServiceFactory.getInstance()\n+                                                                                   .getAuthorityValueService();\n \n     /**\n      * Create an instance of the metadata importer. Requires a context and an array of CSV lines\n      * to examine.\n      *\n-     * @param c        The context\n      * @param toImport An array of CSV lines to examine\n      */\n-    public MetadataImport(Context c, DSpaceCSV toImport) {\n+    public void initMetadataImport(DSpaceCSV toImport) {\n         // Store the import settings\n-        this.c = c;\n-        csv = toImport;\n         this.toImport = toImport.getCSVLines();\n-        installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n-        itemService = ContentServiceFactory.getInstance().getItemService();\n-        collectionService = ContentServiceFactory.getInstance().getCollectionService();\n-        handleService = HandleServiceFactory.getInstance().getHandleService();\n-        authorityValueService = AuthorityServiceFactory.getInstance().getAuthorityValueService();\n-        workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n-        relationshipService = ContentServiceFactory.getInstance().getRelationshipService();\n-        relationshipTypeService = ContentServiceFactory.getInstance().getRelationshipTypeService();\n-        entityTypeService = ContentServiceFactory.getInstance().getEntityTypeService();\n-        entityService = ContentServiceFactory.getInstance().getEntityService();\n+    }\n+\n+    @Override\n+    public void internalRun() throws Exception {\n+        if (help) {\n+            printHelp();\n+            return;\n+        }\n+        // Create a context\n+        Context c = null;\n+        try {\n+            c = new Context();\n+            c.turnOffAuthorisationSystem();\n+        } catch (Exception e) {\n+            throw new ParseException(\"Unable to create a new DSpace Context: \" + e.getMessage());\n+        }", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMjY3Nw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432132677", "bodyText": "We've lost the JavaDocs on this class. It used to have some, but they may need updating anyways based on the changes to this class.  So, please add new JavaDocs.", "author": "tdonohue", "createdAt": "2020-05-28T21:25:14Z", "path": "dspace-api/src/main/java/org/dspace/scripts/DSpaceRunnable.java", "diffHunk": "@@ -7,70 +7,65 @@\n  */\n package org.dspace.scripts;\n \n-import java.sql.SQLException;\n+import java.io.InputStream;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.UUID;\n \n import org.apache.commons.cli.CommandLine;\n import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.Option;\n import org.apache.commons.cli.Options;\n import org.apache.commons.cli.ParseException;\n-import org.dspace.authorize.service.AuthorizeService;\n-import org.dspace.core.Context;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.scripts.configuration.ScriptConfiguration;\n import org.dspace.scripts.handler.DSpaceRunnableHandler;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.beans.factory.annotation.Required;\n \n-/**\n- * This abstract class is the class that should be extended by each script.\n- * it provides the basic variables to be hold by the script as well as the means to initialize, parse and run the script\n- * Every DSpaceRunnable that is implemented in this way should be defined in the scripts.xml config file as a bean\n- */\n-public abstract class DSpaceRunnable implements Runnable {\n+public abstract class DSpaceRunnable<T extends ScriptConfiguration> implements Runnable {", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzODY1Nw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432138657", "bodyText": "Small thing, but I wonder if dspace.process.type should be a constant, so that we don't have to remember what this field is called.  This is not a required change though, the PR can proceed without it.", "author": "tdonohue", "createdAt": "2020-05-28T21:37:40Z", "path": "dspace-api/src/main/java/org/dspace/scripts/ProcessServiceImpl.java", "diffHunk": "@@ -141,6 +177,34 @@ public void update(Context context, Process process) throws SQLException {\n         return parameterList;\n     }\n \n+    @Override\n+    public Bitstream getBitstreamByName(Context context, Process process, String bitstreamName) {\n+        for (Bitstream bitstream : getBitstreams(context, process, null)) {\n+            if (StringUtils.equals(bitstream.getName(), bitstreamName)) {\n+                return bitstream;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public List<Bitstream> getBitstreams(Context context, Process process, String type) {\n+        List<Bitstream> allBitstreams = process.getBitstreams();\n+\n+        if (type == null) {\n+            return allBitstreams;\n+        } else {\n+            List<Bitstream> filteredBitstreams = new ArrayList<>();\n+            for (Bitstream bitstream : allBitstreams) {\n+                if (StringUtils.equals(bitstreamService.getMetadata(bitstream, \"dspace.process.type\"), type)) {", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MTcwOQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432141709", "bodyText": "Please add a context.restoreAuthSystemState(); call after test data is created.", "author": "tdonohue", "createdAt": "2020-05-28T21:44:48Z", "path": "dspace-api/src/test/java/org/dspace/app/bulkedit/MetadataExportTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.bulkedit;\n+\n+import static junit.framework.TestCase.assertTrue;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.dspace.AbstractIntegrationTest;\n+import org.dspace.app.launcher.ScriptLauncher;\n+import org.dspace.app.scripts.handler.impl.TestDSpaceRunnableHandler;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.services.ConfigurationService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.junit.Test;\n+\n+public class MetadataExportTest extends AbstractIntegrationTest {\n+\n+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    private CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    private CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    private WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n+    private InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();\n+\n+    @Test\n+    public void metadataExportToCsvTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community community = communityService.create(null, context);\n+        Collection collection = collectionService.create(context, community);\n+        WorkspaceItem wi = workspaceItemService.create(context, collection, true);\n+        Item item = wi.getItem();\n+        itemService.addMetadata(context, item, \"dc\", \"contributor\", \"author\", null, \"Donald, Smith\");\n+        item = installItemService.installItem(context, wi);", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjU1Ng==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432142556", "bodyText": "Again, please add a context.restoreAuthSystemState(); call after test data is created.", "author": "tdonohue", "createdAt": "2020-05-28T21:46:49Z", "path": "dspace-api/src/test/java/org/dspace/app/bulkedit/MetadataImportTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.bulkedit;\n+\n+import static junit.framework.TestCase.assertTrue;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.AbstractIntegrationTest;\n+import org.dspace.app.launcher.ScriptLauncher;\n+import org.dspace.app.scripts.handler.impl.TestDSpaceRunnableHandler;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.services.ConfigurationService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.junit.Test;\n+\n+public class MetadataImportTest extends AbstractIntegrationTest {\n+\n+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    private CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    private CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();\n+\n+    @Test\n+    public void metadataImportTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community community = communityService.create(null, context);\n+        collectionService.create(context, community);", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0NDgwNg==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432144806", "bodyText": "This test does not appear to be cleaning up after itself.  Shouldn't we be deleting the test Community/Collection/Item at the end of this test?  Otherwise, they will remain in our test database and can impact any tests that run later.", "author": "tdonohue", "createdAt": "2020-05-28T21:52:17Z", "path": "dspace-api/src/test/java/org/dspace/app/bulkedit/MetadataExportTest.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.bulkedit;\n+\n+import static junit.framework.TestCase.assertTrue;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.dspace.AbstractIntegrationTest;\n+import org.dspace.app.launcher.ScriptLauncher;\n+import org.dspace.app.scripts.handler.impl.TestDSpaceRunnableHandler;\n+import org.dspace.content.Collection;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.WorkspaceItem;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.InstallItemService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.content.service.WorkspaceItemService;\n+import org.dspace.services.ConfigurationService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.junit.Test;\n+\n+public class MetadataExportTest extends AbstractIntegrationTest {\n+\n+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    private CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    private CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    private WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();\n+    private InstallItemService installItemService = ContentServiceFactory.getInstance().getInstallItemService();\n+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();\n+\n+    @Test\n+    public void metadataExportToCsvTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community community = communityService.create(null, context);\n+        Collection collection = collectionService.create(context, community);\n+        WorkspaceItem wi = workspaceItemService.create(context, collection, true);\n+        Item item = wi.getItem();\n+        itemService.addMetadata(context, item, \"dc\", \"contributor\", \"author\", null, \"Donald, Smith\");\n+        item = installItemService.installItem(context, wi);\n+        String fileLocation = configurationService.getProperty(\"dspace.dir\") + testProps.get(\"test.exportcsv\")\n+                                                                                        .toString();\n+\n+        String[] args = new String[] {\"metadata-export\", \"-i\", String.valueOf(item.getHandle()), \"-f\", fileLocation};\n+        TestDSpaceRunnableHandler testDSpaceRunnableHandler = new TestDSpaceRunnableHandler();\n+\n+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), testDSpaceRunnableHandler, kernelImpl);\n+        File file = new File(fileLocation);\n+        String fileContent = IOUtils.toString(new FileInputStream(file), StandardCharsets.UTF_8);\n+        assertTrue(fileContent.contains(\"Donald, Smith\"));\n+        assertTrue(fileContent.contains(String.valueOf(item.getID())));", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0ODM2Ng==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432148366", "bodyText": "This line seems potentially fragile to me (and not the best performance to load up all Items into memory only to find the \"next()\" one).  Is there no other way to parse out what Item was created from the output of the metadata-import script?   I'd prefer it if we could test that the output of the script is also correct here.", "author": "tdonohue", "createdAt": "2020-05-28T22:00:30Z", "path": "dspace-api/src/test/java/org/dspace/app/bulkedit/MetadataImportTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.bulkedit;\n+\n+import static junit.framework.TestCase.assertTrue;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.AbstractIntegrationTest;\n+import org.dspace.app.launcher.ScriptLauncher;\n+import org.dspace.app.scripts.handler.impl.TestDSpaceRunnableHandler;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.services.ConfigurationService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.junit.Test;\n+\n+public class MetadataImportTest extends AbstractIntegrationTest {\n+\n+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    private CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    private CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();\n+\n+    @Test\n+    public void metadataImportTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community community = communityService.create(null, context);\n+        collectionService.create(context, community);\n+\n+        String fileLocation = configurationService.getProperty(\"dspace.dir\") + testProps.get(\"test.importcsv\")\n+                                                                                        .toString();\n+        String[] args = new String[] {\"metadata-import\", \"-f\", fileLocation, \"-e\", eperson.getEmail(), \"-s\"};\n+        TestDSpaceRunnableHandler testDSpaceRunnableHandler = new TestDSpaceRunnableHandler();\n+\n+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), testDSpaceRunnableHandler, kernelImpl);\n+        Item importedItem = itemService.findAll(context).next();", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2NjE5MQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r438666191", "bodyText": "I understand why it can seem fragile, but as every test is cleaning up after itself there is only a single item in the iterator. There is no other way to retrieve the item that was ingested, as the handleScript() method doesn't provide output that we can parse to do a specific lookup for an item.", "author": "KevinVdV", "createdAt": "2020-06-11T09:41:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0ODM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0ODYwMw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432148603", "bodyText": "Again, it looks like this test isn't cleaning up the data it creates.  It should be updated to cleanup any test data.", "author": "tdonohue", "createdAt": "2020-05-28T22:01:01Z", "path": "dspace-api/src/test/java/org/dspace/app/bulkedit/MetadataImportTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.bulkedit;\n+\n+import static junit.framework.TestCase.assertTrue;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.AbstractIntegrationTest;\n+import org.dspace.app.launcher.ScriptLauncher;\n+import org.dspace.app.scripts.handler.impl.TestDSpaceRunnableHandler;\n+import org.dspace.content.Community;\n+import org.dspace.content.Item;\n+import org.dspace.content.factory.ContentServiceFactory;\n+import org.dspace.content.service.CollectionService;\n+import org.dspace.content.service.CommunityService;\n+import org.dspace.content.service.ItemService;\n+import org.dspace.services.ConfigurationService;\n+import org.dspace.services.factory.DSpaceServicesFactory;\n+import org.junit.Test;\n+\n+public class MetadataImportTest extends AbstractIntegrationTest {\n+\n+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();\n+    private CollectionService collectionService = ContentServiceFactory.getInstance().getCollectionService();\n+    private CommunityService communityService = ContentServiceFactory.getInstance().getCommunityService();\n+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();\n+\n+    @Test\n+    public void metadataImportTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        Community community = communityService.create(null, context);\n+        collectionService.create(context, community);\n+\n+        String fileLocation = configurationService.getProperty(\"dspace.dir\") + testProps.get(\"test.importcsv\")\n+                                                                                        .toString();\n+        String[] args = new String[] {\"metadata-import\", \"-f\", fileLocation, \"-e\", eperson.getEmail(), \"-s\"};\n+        TestDSpaceRunnableHandler testDSpaceRunnableHandler = new TestDSpaceRunnableHandler();\n+\n+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), testDSpaceRunnableHandler, kernelImpl);\n+        Item importedItem = itemService.findAll(context).next();\n+        assertTrue(\n+            StringUtils.equals(\n+                itemService.getMetadata(importedItem, \"dc\", \"contributor\", \"author\", Item.ANY).get(0).getValue(),\n+                \"Donald, SmithImported\"));", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1MTc5NA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432151794", "bodyText": "Just as a reminder, we should not be creating Controllers unless absolutely required. Generally speaking, if you ever start to create a Controller for any type of  GET request, this is a sign that you should rethink your code to try and use either a RestRepository or LinkRestRepository.  More advice inline below.", "author": "tdonohue", "createdAt": "2020-05-28T22:08:41Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessFilesRestController.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedModel;\n+import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME + \"/{processId}/files\")\n+public class ProcessFilesRestController {", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2ODYyMw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r438668623", "bodyText": "A small update was needed on the RestResourceController in order to support one of the 2 methods for which this controller was needed. The remaining one is too specific & cannot be moved to the repository (unless we change the contract & this is still an open discussion).", "author": "KevinVdV", "createdAt": "2020-06-11T09:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1MTc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU2MDAzNg==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r439560036", "bodyText": "@KevinVdV : I don't understand your note here, as the path this Controller responds to is not in the Contract: DSpace/RestContract#99   I'd need to understand the purpose of this endpoint as it's not clear to me.\nAlso, it's worth noting, per the REST Contract README, we don't support subpaths of the type you've added here.  You seem to be implying by the path /process/[id]/files/name/[name] that there are TWO unique identifiers for a File within a Process, either the name or the type (which is already documented as the unique identifier in the contract and has a path /process/[id]/files/[type]).  This is something we've not allowed on other endpoints, so we'd need a different path here that doesn't require a custom Controller (Again, as I've noted, we highly recommend against custom Controllers. If you find yourself creating one, please ask for advice on how to avoid it.)  One manner of implementing this in another way would be to reconsider this as a /api/core/bitstreams/search/byProcessAndName?process=[]&name=[].  It could still end up with a unique result, but it'd clarify that it's not the main unique identifier (and that Type is considered the main unique identifier).", "author": "tdonohue", "createdAt": "2020-06-12T17:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1MTc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcxMzQ3Nw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r440713477", "bodyText": "This controller was removed as the name endpoint isn't used. A small leftover from an initial implementation.", "author": "KevinVdV", "createdAt": "2020-06-16T09:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1MTc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUyOTM2MQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432529361", "bodyText": "This endpoint looks to be acting like a /search of Bitstreams (https://github.com/DSpace/Rest7Contract/blob/master/search-rels.md).  I see that's the same feedback that @abollini gave you in the REST Contract, which it looks like wasn't addressed yet: DSpace/RestContract#99 (comment)\nMy recommendation is to redesign this (in the Contract and here) to be /api/core/bitstreams/search/byProcessAndType or similar. This would allow you to move this code into the BitstreamRestRepository class in a method annotated with @SearchRestMethod.", "author": "tdonohue", "createdAt": "2020-05-29T14:35:06Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessFilesRestController.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedModel;\n+import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME + \"/{processId}/files\")\n+public class ProcessFilesRestController {\n+\n+    private static final Logger log = LogManager.getLogger();\n+\n+    @Autowired\n+    HalLinkService linkService;\n+\n+    @Autowired\n+    private ProcessRestRepository processRestRepository;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Autowired\n+    ProcessResourceHalLinkFactory processResourceHalLinkFactory;\n+\n+    @RequestMapping(method = RequestMethod.GET, value = \"/{fileType}\")\n+    @PreAuthorize(\"hasPermission(#processId, 'PROCESS', 'READ')\")\n+    public PagedModel<BitstreamResource> listFilesWithTypeFromProcess(", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMDI1NA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432530254", "bodyText": "This endpoint seems to be missing from the original Rest Contract: DSpace/RestContract#99   So, I'm not sure of the use case here.  It might be implemented more like a /search as well (like above), but it seems like it's somehow implied to be a unique lookup, so it could also be a LinkRestRepository perhaps.", "author": "tdonohue", "createdAt": "2020-05-29T14:36:33Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/ProcessFilesRestController.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.dspace.app.rest.link.HalLinkService;\n+import org.dspace.app.rest.link.process.ProcessResourceHalLinkFactory;\n+import org.dspace.app.rest.model.BitstreamRest;\n+import org.dspace.app.rest.model.ProcessRest;\n+import org.dspace.app.rest.model.hateoas.BitstreamResource;\n+import org.dspace.app.rest.repository.ProcessRestRepository;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.authorize.AuthorizeException;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.web.PagedResourcesAssembler;\n+import org.springframework.hateoas.Link;\n+import org.springframework.hateoas.PagedModel;\n+import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+@RestController\n+@RequestMapping(\"/api/\" + ProcessRest.CATEGORY + \"/\" + ProcessRest.PLURAL_NAME + \"/{processId}/files\")\n+public class ProcessFilesRestController {\n+\n+    private static final Logger log = LogManager.getLogger();\n+\n+    @Autowired\n+    HalLinkService linkService;\n+\n+    @Autowired\n+    private ProcessRestRepository processRestRepository;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    @Autowired\n+    ProcessResourceHalLinkFactory processResourceHalLinkFactory;\n+\n+    @RequestMapping(method = RequestMethod.GET, value = \"/{fileType}\")\n+    @PreAuthorize(\"hasPermission(#processId, 'PROCESS', 'READ')\")\n+    public PagedModel<BitstreamResource> listFilesWithTypeFromProcess(\n+        @PathVariable(name = \"processId\") Integer processId,\n+        @PathVariable(name = \"fileType\") String fileType,\n+        Pageable pageable, PagedResourcesAssembler assembler) throws SQLException, AuthorizeException {\n+\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Retrieving Files with type \" + fileType + \" from Process with ID: \" + processId);\n+        }\n+\n+        List<BitstreamResource> bitstreamResources = processRestRepository\n+            .getProcessBitstreamsByType(processId, fileType).stream()\n+            .map(bitstreamRest -> new BitstreamResource(bitstreamRest, utils))\n+            .collect(Collectors.toList());\n+\n+        Page<BitstreamResource> page = utils.getPage(bitstreamResources, pageable);\n+\n+        Link link = WebMvcLinkBuilder.linkTo(\n+            methodOn(this.getClass()).listFilesWithTypeFromProcess(processId, fileType, pageable, assembler))\n+            .withSelfRel();\n+        PagedModel<BitstreamResource> result = assembler.toModel(page, link);\n+\n+        return result;\n+    }\n+\n+\n+    @RequestMapping(method = RequestMethod.GET, value = \"/name/{fileName:.+}\")\n+    @PreAuthorize(\"hasPermission(#processId, 'PROCESS', 'READ')\")\n+    public BitstreamResource getBitstreamByName(@PathVariable(name = \"processId\") Integer processId,", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzNjMwMg==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432536302", "bodyText": "This is an undocumented change.  So, we need this to added/changed in the REST Contract.", "author": "tdonohue", "createdAt": "2020-05-29T14:45:47Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/BitstreamRestRepository.java", "diffHunk": "@@ -95,22 +91,7 @@ public BitstreamRest findOne(Context context, UUID id) {\n     @Override\n     @PreAuthorize(\"hasAuthority('ADMIN')\")\n     public Page<BitstreamRest> findAll(Context context, Pageable pageable) {\n-        List<Bitstream> bit = new ArrayList<Bitstream>();\n-        Iterator<Bitstream> it = null;\n-        int total = 0;\n-        try {\n-            total = bs.countTotal(context);\n-            it = bs.findAll(context, pageable.getPageSize(), Math.toIntExact(pageable.getOffset()));\n-            while (it.hasNext()) {\n-                bit.add(it.next());\n-            }\n-        } catch (SQLException e) {\n-            throw new RuntimeException(e.getMessage(), e);\n-        }\n-        Projection projection = utils.obtainProjection();\n-        Page<BitstreamRest> page = new PageImpl<>(bit, pageable, total)\n-                .map((bitstream) -> converter.toRest(bitstream, projection));\n-        return page;\n+        throw new RepositoryMethodNotImplementedException(BitstreamRest.NAME, \"findAll\");", "originalCommit": "8652e95686edf28f6431dd0f9e035e147ed01852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY3Mzk2Ng==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r438673966", "bodyText": "Agreed, I added a small commit to the outstanding contract PR for these changes: DSpace/RestContract@0ac3647", "author": "KevinVdV", "createdAt": "2020-06-11T09:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzNjMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NTE5OA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432565198", "bodyText": "I'm not sure I understand what a ProcessFileWrapper is, as this isn't explained in this JavaDocs.  However, it might make more sense once the REST Contract is updated with examples.", "author": "tdonohue", "createdAt": "2020-05-29T15:31:32Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/model/ProcessFileWrapperRest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.model;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+\n+/**\n+ * The ProcessFileWrapper REST Resource\n+ *\n+ */\n+public class ProcessFileWrapperRest implements RestModel {", "originalCommit": "47b75f313e543923997cbe8c2ae717323aea7170", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEwODIzOQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r440108239", "bodyText": "This one is needed for the following endpoint: https://github.com/DSpace/Rest7Contract/pull/99/files#diff-12aac6d84a3393b361553d3f2fe93962R141, we need a way here to have in our output:\n\nA process identifier\nA list of files\n\nThis object provides that wrapper, we can always rename it if you wish.\nPS: JavaDocs have been added.", "author": "KevinVdV", "createdAt": "2020-06-15T11:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NTE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNDQ3Ng==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r440324476", "bodyText": "@KevinVdV : OK, I see. It seems like it's more about grouping this files by type.  So, we might consider calling this the ProcessFileTypeWrapperRest.  But, I don't feel strongly either way here.\nOne thing to note though is that the behavior of this endpoint is a bit different than normal, so we might want to verify with the Angular team that caching will work appropriately here.  Essentially, this endpoint is returning ProcessFileWrapperResource which is just a wrapper around a BitstreamResource.  So, the client side / UI needs to be aware of that so that it does NOT cache the ProcessFileWrapper separate from cached Bitstream objects (as treating these separately could end up duplicating some objects in the cache).\n@artlowel : have you seen the approach of this PR?\nNormally, to make this similar to other existing endpoints, the behavior here would be to have the /processes/<:process-id>/files endpoint directly return BitstreamResource objects.  But, that'd require rethinking the REST Contract slightly (as this /files path could no longer be grouped by dspace.process.filetype....but we still could have /files/[:type] return just the file of that type).\nI don't feel strongly either way here. I'm just pointing out that this endpoint is different from how others normally behave.  If @artlowel sees no issues with caching on the Angular side, then I'm OK with this approach.  Otherwise, if needed, we could rethink the Contract again to align this endpoint more with others that act similarly (e.g. /bundles/[:id]/bitstreams is somewhat similar in that it returns just a list of bitstreams, in that case belonging to a specific bundle)", "author": "tdonohue", "createdAt": "2020-06-15T17:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NTE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ3NTI0MQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r441475241", "bodyText": "Thanks for the heads up @tdonohue. That /files endpoint as described in the rest contract is indeed problematic. I'll discuss it with Kevin and Ben to see if we can't come up with something better.", "author": "artlowel", "createdAt": "2020-06-17T11:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NTE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYyODExNw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r441628117", "bodyText": "@tdonohue In discussion with Art & Ben I created the following contract PR: DSpace/RestContract#130, feel free to add feedback there, once accepted, we will implement these changes.", "author": "KevinVdV", "createdAt": "2020-06-17T15:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NTE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0NzE0MA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r441647140", "bodyText": "@KevinVdV : I've added a review to the contract changes. They look good overall, I just added minor rewording suggestions.\nBased on the new contract changes, all my feedback in this discussion thread above can be ignored, and I'd expect all of the ProcessFileWrapper* classes to now be removed from this PR.  We should be able to now use a simple LinkRepository to return the Bitstreams associated with the Process.", "author": "tdonohue", "createdAt": "2020-06-17T15:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NjcwNg==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432566706", "bodyText": "If we are changing the behavior to be a 405 response, we only need to test that once.  So, this test is now unneeded, as you already test that the endpoint returns a 405 above.", "author": "tdonohue", "createdAt": "2020-05-29T15:33:55Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/BitstreamRestRepositoryIT.java", "diffHunk": "@@ -162,33 +155,13 @@ public void findAllPaginationTest() throws Exception {\n         getClient(token).perform(get(\"/api/core/bitstreams/\")\n                    .param(\"size\", \"1\")\n                    .param(\"projection\", \"full\"))\n-                   .andExpect(status().isOk())\n-                   .andExpect(content().contentType(contentType))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.contains(\n-                       BitstreamMatcher.matchBitstreamEntry(bitstream))\n-                   ))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.not(\n-                       Matchers.contains(\n-                           BitstreamMatcher.matchBitstreamEntry(bitstream1))\n-                                       )\n-                   ))\n-\n-        ;\n+                   .andExpect(status().isMethodNotAllowed());", "originalCommit": "47b75f313e543923997cbe8c2ae717323aea7170", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2NzA3Ng==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432567076", "bodyText": "Same here, this test can be removed, we already test for 405 response above.  Retesting with different params isn't really necessary.", "author": "tdonohue", "createdAt": "2020-05-29T15:34:36Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/BitstreamRestRepositoryIT.java", "diffHunk": "@@ -162,33 +155,13 @@ public void findAllPaginationTest() throws Exception {\n         getClient(token).perform(get(\"/api/core/bitstreams/\")\n                    .param(\"size\", \"1\")\n                    .param(\"projection\", \"full\"))\n-                   .andExpect(status().isOk())\n-                   .andExpect(content().contentType(contentType))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.contains(\n-                       BitstreamMatcher.matchBitstreamEntry(bitstream))\n-                   ))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.not(\n-                       Matchers.contains(\n-                           BitstreamMatcher.matchBitstreamEntry(bitstream1))\n-                                       )\n-                   ))\n-\n-        ;\n+                   .andExpect(status().isMethodNotAllowed());\n \n         getClient(token).perform(get(\"/api/core/bitstreams/\")\n                                 .param(\"size\", \"1\")\n                                 .param(\"page\", \"1\")\n                                 .param(\"projection\", \"full\"))\n-                   .andExpect(status().isOk())\n-                   .andExpect(content().contentType(contentType))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.contains(\n-                       BitstreamMatcher.matchBitstreamEntry(bitstream1)\n-                   )))\n-                   .andExpect(jsonPath(\"$._embedded.bitstreams\", Matchers.not(\n-                       Matchers.contains(\n-                           BitstreamMatcher.matchBitstreamEntry(bitstream)\n-                       )\n-                   )));\n+                   .andExpect(status().isMethodNotAllowed());", "originalCommit": "47b75f313e543923997cbe8c2ae717323aea7170", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3MTUwNw==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432571507", "bodyText": "Recently we've discovered this form of cleanup after a POST is incredibly inefficient (and sloooow).  The recommended way to do cleanup after a POST can be found in this recent PR: #2759.  Here's also a good example on master in the EPersonRestRepositoryIT:\n\nFirst use an andDo to capture the ID of the created object (which is more efficient then pulling down the entire response): https://github.com/DSpace/DSpace/blob/master/dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java#L107-L108\nThen, use (or create) a Builder deletion method in a finally block: https://github.com/DSpace/DSpace/blob/master/dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java#L119-L122\n\nPlease refactor this test to do something similar, as it'll help us retain consistency & speed up our tests. Thanks!", "author": "tdonohue", "createdAt": "2020-05-29T15:41:42Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/ScriptRestRepositoryIT.java", "diffHunk": "@@ -155,12 +178,22 @@ public void postProcessAdminWrongOptionsException() throws Exception {\n \n         String token = getAuthToken(admin.getEmail(), password);\n \n-        getClient(token).perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\"))\n-                        .andExpect(status().isAccepted())\n-                        .andExpect(jsonPath(\"$\", is(\n-                            ProcessMatcher.matchProcess(\"mock-script\",\n-                                                        String.valueOf(admin.getID()), new LinkedList<>(),\n-                                                        ProcessStatus.FAILED))));\n+        MvcResult mvcResult = getClient(token)\n+            .perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\"))\n+            .andExpect(status().isAccepted())\n+            .andExpect(jsonPath(\"$\", is(\n+                ProcessMatcher.matchProcess(\"mock-script\",\n+                                            String.valueOf(admin.getID()), new LinkedList<>(),\n+                                            ProcessStatus.FAILED)))).andReturn();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String, Object> map = mapper.readValue(content, Map.class);\n+        Integer processId = Integer.valueOf(String.valueOf(map.get(\"processId\")));\n+\n+        getClient(token).perform(delete(\"/api/system/processes/\" + processId));", "originalCommit": "47b75f313e543923997cbe8c2ae717323aea7170", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MDUyOQ==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432580529", "bodyText": "Same here, please refactor this cleanup after POST as described above.", "author": "tdonohue", "createdAt": "2020-05-29T15:55:19Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/ScriptRestRepositoryIT.java", "diffHunk": "@@ -182,19 +215,28 @@ public void postProcessAdminNoOptionsFailedStatus() throws Exception {\n         parameters.add(new DSpaceCommandLineParameter(\"-q\", null));\n \n         List<ParameterValueRest> list = parameters.stream()\n-                .map(dSpaceCommandLineParameter -> dSpaceRunnableParameterConverter\n-                        .convert(dSpaceCommandLineParameter, Projection.DEFAULT)).collect(Collectors.toList());\n+                                                  .map(dSpaceCommandLineParameter -> dSpaceRunnableParameterConverter\n+                                                      .convert(dSpaceCommandLineParameter, Projection.DEFAULT))\n+                                                  .collect(Collectors.toList());\n \n         String token = getAuthToken(admin.getEmail(), password);\n \n-        getClient(token).perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\")\n-                                                                                  .param(\"properties\",\n-                                                                                         new Gson().toJson(list)))\n-                        .andExpect(status().isAccepted())\n-                        .andExpect(jsonPath(\"$\", is(\n-                            ProcessMatcher.matchProcess(\"mock-script\",\n-                                                        String.valueOf(admin.getID()), parameters,\n-                                                        ProcessStatus.FAILED))));\n+        MvcResult mvcResult = getClient(token)\n+            .perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\")\n+                                                                      .param(\"properties\",\n+                                                                             new Gson().toJson(list)))\n+            .andExpect(status().isAccepted())\n+            .andExpect(jsonPath(\"$\", is(\n+                ProcessMatcher.matchProcess(\"mock-script\",\n+                                            String.valueOf(admin.getID()), parameters,\n+                                            ProcessStatus.FAILED)))).andReturn();\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String, Object> map = mapper.readValue(content, Map.class);\n+        Integer processId = Integer.valueOf(String.valueOf(map.get(\"processId\")));\n+\n+        getClient(token).perform(delete(\"/api/system/processes/\" + processId));", "originalCommit": "47b75f313e543923997cbe8c2ae717323aea7170", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MDY5OA==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432580698", "bodyText": "Same here, please refactor this cleanup after POST as described above.", "author": "tdonohue", "createdAt": "2020-05-29T15:55:37Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/ScriptRestRepositoryIT.java", "diffHunk": "@@ -214,24 +256,34 @@ public void postProcessAdminWithOptionsSuccess() throws Exception {\n         parameters.add(new DSpaceCommandLineParameter(\"-i\", null));\n \n         List<ParameterValueRest> list = parameters.stream()\n-                .map(dSpaceCommandLineParameter -> dSpaceRunnableParameterConverter\n-                        .convert(dSpaceCommandLineParameter, Projection.DEFAULT)).collect(Collectors.toList());\n+                                                  .map(dSpaceCommandLineParameter -> dSpaceRunnableParameterConverter\n+                                                      .convert(dSpaceCommandLineParameter, Projection.DEFAULT))\n+                                                  .collect(Collectors.toList());\n \n         String token = getAuthToken(admin.getEmail(), password);\n         List<ProcessStatus> acceptableProcessStatuses = new LinkedList<>();\n         acceptableProcessStatuses.addAll(Arrays.asList(ProcessStatus.SCHEDULED,\n                                                        ProcessStatus.RUNNING,\n                                                        ProcessStatus.COMPLETED));\n \n-        getClient(token).perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\")\n-                                                                                  .param(\"properties\",\n-                                                                                         new Gson().toJson(list)))\n-                        .andExpect(status().isAccepted())\n-                        .andExpect(jsonPath(\"$\", is(\n-                            ProcessMatcher.matchProcess(\"mock-script\",\n-                                                        String.valueOf(admin.getID()),\n-                                                        parameters,\n-                                                        acceptableProcessStatuses))));\n+        MvcResult mvcResult = getClient(token)\n+            .perform(post(\"/api/system/scripts/mock-script/processes\").contentType(\"multipart/form-data\")\n+                                                                      .param(\"properties\",\n+                                                                             new Gson().toJson(list)))\n+            .andExpect(status().isAccepted())\n+            .andExpect(jsonPath(\"$\", is(\n+                ProcessMatcher.matchProcess(\"mock-script\",\n+                                            String.valueOf(admin.getID()),\n+                                            parameters,\n+                                            acceptableProcessStatuses)))).andReturn();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String, Object> map = mapper.readValue(content, Map.class);\n+        Integer processId = Integer.valueOf(String.valueOf(map.get(\"processId\")));\n+\n+        getClient(token).perform(delete(\"/api/system/processes/\" + processId));", "originalCommit": "47b75f313e543923997cbe8c2ae717323aea7170", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MDk2Ng==", "url": "https://github.com/DSpace/DSpace/pull/2648#discussion_r432580966", "bodyText": "Same here, please refactor this cleanup after POST as described above.", "author": "tdonohue", "createdAt": "2020-05-29T15:56:05Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/ScriptRestRepositoryIT.java", "diffHunk": "@@ -243,12 +295,78 @@ public void postProcessAdminWithWrongContentTypeBadRequestException() throws Exc\n                         .andExpect(status().isBadRequest());\n     }\n \n+    @Test\n+    public void postProcessAdminWithFileSuccess() throws Exception {\n+        LinkedList<DSpaceCommandLineParameter> parameters = new LinkedList<>();\n+\n+        parameters.add(new DSpaceCommandLineParameter(\"-r\", \"test\"));\n+        parameters.add(new DSpaceCommandLineParameter(\"-i\", null));\n+\n+\n+        context.turnOffAuthorisationSystem();\n+\n+        parentCommunity = CommunityBuilder.createCommunity(context)\n+                                          .withName(\"Parent Community\")\n+                                          .build();\n+        Community child1 = CommunityBuilder.createSubCommunity(context, parentCommunity)\n+                                           .withName(\"Sub Community\")\n+                                           .build();\n+        Collection col1 = CollectionBuilder.createCollection(context, child1).withName(\"Collection 1\").build();\n+        Collection col2 = CollectionBuilder.createCollection(context, child1).withName(\"Collection 2\").build();\n+\n+        //2. Three public items that are readable by Anonymous with different subjects\n+        Item publicItem1 = ItemBuilder.createItem(context, col1)\n+                                      .withTitle(\"Public item 1\")\n+                                      .withIssueDate(\"2017-10-17\")\n+                                      .withAuthor(\"Smith, Donald\").withAuthor(\"Doe, John\")\n+                                      .withSubject(\"ExtraEntry\")\n+                                      .build();\n+\n+        String bitstreamContent = \"Hello, World!\";\n+        MockMultipartFile bitstreamFile = new MockMultipartFile(\"file\",\n+                                                                \"helloProcessFile.txt\", MediaType.TEXT_PLAIN_VALUE,\n+                                                                bitstreamContent.getBytes());\n+        parameters.add(new DSpaceCommandLineParameter(\"-f\", \"helloProcessFile.txt\"));\n+\n+        List<ParameterValueRest> list = parameters.stream()\n+                                                  .map(dSpaceCommandLineParameter -> dSpaceRunnableParameterConverter\n+                                                      .convert(dSpaceCommandLineParameter, Projection.DEFAULT))\n+                                                  .collect(Collectors.toList());\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        List<ProcessStatus> acceptableProcessStatuses = new LinkedList<>();\n+        acceptableProcessStatuses.addAll(Arrays.asList(ProcessStatus.SCHEDULED,\n+                                                       ProcessStatus.RUNNING,\n+                                                       ProcessStatus.COMPLETED));\n+\n+        MvcResult mvcResult = getClient(token)\n+            .perform(fileUpload(\"/api/system/scripts/mock-script/processes\").file(bitstreamFile)\n+                                                                            .param(\"properties\",\n+                                                                                   new Gson().toJson(list)))\n+            .andExpect(status().isAccepted())\n+            .andExpect(jsonPath(\"$\", is(\n+                ProcessMatcher.matchProcess(\"mock-script\",\n+                                            String.valueOf(admin.getID()),\n+                                            parameters,\n+                                            acceptableProcessStatuses)))).andReturn();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String, Object> map = mapper.readValue(content, Map.class);\n+        Integer processId = Integer.valueOf(String.valueOf(map.get(\"processId\")));\n+\n+        getClient(token).perform(delete(\"/api/system/processes/\" + processId));", "originalCommit": "47b75f313e543923997cbe8c2ae717323aea7170", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5d7524970cb63dc903f778fa5b248dad16758415", "url": "https://github.com/DSpace/DSpace/commit/5d7524970cb63dc903f778fa5b248dad16758415", "message": "[Task 71272] applied feedback to the Scripts and Processes functionality", "committedDate": "2020-06-09T13:04:51Z", "type": "commit"}, {"oid": "e464ec0f8cfac7031dd0a15ff7b30ff2e50c8464", "url": "https://github.com/DSpace/DSpace/commit/e464ec0f8cfac7031dd0a15ff7b30ff2e50c8464", "message": "[Task 71272] minor cleanup to the Scripts and Processes functionality", "committedDate": "2020-06-09T13:06:39Z", "type": "commit"}, {"oid": "b32c461006ecb8ae32222199891c0025e7b694ab", "url": "https://github.com/DSpace/DSpace/commit/b32c461006ecb8ae32222199891c0025e7b694ab", "message": "[Task 71405] applied community feedback to the Scripts and Processes endpoints", "committedDate": "2020-06-15T12:58:11Z", "type": "commit"}, {"oid": "31c87c2ba1d6771def879dd7d15eb03f59310984", "url": "https://github.com/DSpace/DSpace/commit/31c87c2ba1d6771def879dd7d15eb03f59310984", "message": "[Task 71405] fixed the Process Files endpoints and added two tests for them", "committedDate": "2020-06-16T07:46:01Z", "type": "commit"}, {"oid": "de357b581c3b70973000e2b4dd19428eba5d3377", "url": "https://github.com/DSpace/DSpace/commit/de357b581c3b70973000e2b4dd19428eba5d3377", "message": "[Task 71441] altered the processFiles endpoint and added the process filetypes endpoint with tests", "committedDate": "2020-06-18T10:49:43Z", "type": "commit"}, {"oid": "57d63c211eb53dd9c28fad1597c54b92516b3d63", "url": "https://github.com/DSpace/DSpace/commit/57d63c211eb53dd9c28fad1597c54b92516b3d63", "message": "[Task 71441] added javadoc and minor cleanup", "committedDate": "2020-06-18T10:58:23Z", "type": "commit"}]}